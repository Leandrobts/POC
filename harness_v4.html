<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PS4 WebKit Harness v4 (Safe Invariants)</title>
</head>
<body>
<h2>PS4 WebKit Harness v4 — Safe Invariants (sem exploração / sem DoS)</h2>

<div>
  <label>Mode:
    <select id="modeSel">
      <option value="SAFE">SAFE</option>
      <option value="AGGR">AGGR</option>
    </select>
  </label>
  <label style="margin-left:10px;">Seed:
    <input id="seedSel" type="number" value="1337" min="1" step="1">
  </label>
  <label style="margin-left:10px;">Loop N:
    <input id="loopN" type="number" value="30" min="1" step="1">
  </label>
  <label style="margin-left:10px;">Delay ms:
    <input id="delayMs" type="number" value="30" min="0" step="10">
  </label>
</div>

<div style="margin-top:10px;">
  <button onclick="CTRL.clearLog()">Limpar log</button>
  <button onclick="UI.runOnceSelected()">RUN Once (selecionados)</button>
  <button onclick="UI.loopSelected()">Loop N (selecionados)</button>
  <button onclick="CTRL.stopNow()">STOP</button>
</div>

<hr>

<div>
  <b>Selecione testes:</b><br>
  <label><input type="checkbox" class="tchk" value="NAV1" checked> NAV1 — History clone/ack + bookkeeping</label><br>
  <label><input type="checkbox" class="tchk" value="CLONE1" checked> CLONE1 — Structured clone via MessageChannel (invariantes)</label><br>
  <label><input type="checkbox" class="tchk" value="DOM1" checked> DOM1 — DOM lifecycle + getters (invariantes)</label><br>
  <label><input type="checkbox" class="tchk" value="MEDIA1"> MEDIA1 — Media teardown invariants (video/TextTrack)</label><br>
  <label><input type="checkbox" class="tchk" value="CAN1"> CAN1 — Canvas2D resize/destroy invariants</label><br>
</div>

<hr>

<pre id="log" style="white-space:pre-wrap;word-break:break-word;"></pre>

<script>
const CTRL = {
  stop: false,
  lastTest: "NONE",
  fails: 0,
  clearLog(){
    document.getElementById("log").textContent = "";
  },
  stopNow(){
    this.stop = true;
    log("[CTRL] stop=1 (requested)");
  }
};

function nowMs(){ return (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now(); }
function log(s){
  const el = document.getElementById("log");
  el.textContent += s + "\n";
  try { el.scrollTop = el.scrollHeight; } catch(e){}
}
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

function rand32(seed){
  let x = seed >>> 0;
  x ^= (x << 13) >>> 0;
  x ^= (x >>> 17) >>> 0;
  x ^= (x << 5) >>> 0;
  return x >>> 0;
}

function makeCaps(mode){
  if(mode === "AGGR"){
    return { budgetMs:10, historyOps:25, domNodes:1200, canvasOps:120, mediaOps:30, cloneOps:80, ackTimeoutMs:160, driftWarnMs:30 };
  }
  return { budgetMs:6, historyOps:12, domNodes:600, canvasOps:60, mediaOps:15, cloneOps:40, ackTimeoutMs:120, driftWarnMs:20 };
}

function ctxFromUI(){
  const mode = document.getElementById("modeSel").value;
  const seed = (parseInt(document.getElementById("seedSel").value, 10) || 1337) >>> 0;
  return { mode, seed, cap: makeCaps(mode) };
}

function RC(code, msg){ return `[RC:${code}] ${msg}`; }
function pass(tag, msg){ log(`[PASS] ${tag} :: ${msg}`); }
function fail(tag, msg){ CTRL.fails++; log(`[FAIL] ${tag} :: ${msg}`); }

function snapshot(tag){
  let href=""; let len=-1;
  try{ href = location.href; }catch(e){ href="(nohref)"; }
  try{ len = history.length; }catch(e){ len=-2; }
  log(`[SNAP] ${tag} href=${href} histLen=${len}`);
}

async function healthDrift(tag){
  const t0 = nowMs();
  await sleep(0);
  const d = nowMs() - t0;
  log(`[HLTH] ${tag} eventLoop drift ~${d.toFixed(2)}ms`);
  return d;
}

function selectTests(){
  const boxes = document.querySelectorAll(".tchk");
  const out = [];
  for(let i=0;i<boxes.length;i++) if(boxes[i].checked) out.push(boxes[i].value);
  return out;
}

const TESTS = {};

/* ========================= NAV1 ========================= */
TESTS.NAV1 = async function(ctx){
  const tag = "NAV1";
  CTRL.lastTest = tag;
  log(`[TEST] ${tag} :: history state clone/ack + bookkeeping | mode=${ctx.mode} seed=${ctx.seed}`);
  const cap = ctx.cap;

  let urlMutable = true;
  let href = "";
  let origin = "(noorigin)";
  try{ href = location.href || ""; }catch(e){ href = ""; }
  try{ origin = location.origin; }catch(e){ origin = "(noorigin)"; }
  if(origin === "null") urlMutable = false;
  if(href.indexOf("content://") === 0) urlMutable = false;

  const baseToken = (rand32(ctx.seed) ^ 0xC0DEF00D) >>> 0;

  function makeState(idx, token){
    const buf = new ArrayBuffer(64);
    const u32 = new Uint32Array(buf);
    u32[0] = (0xA11A0000 ^ idx) >>> 0;
    u32[1] = (0xB22B0000 ^ token) >>> 0;
    u32[2] = idx >>> 0;
    u32[3] = token >>> 0;
    return { v:4, idx:idx>>>0, token:token>>>0, buf:buf, sig:{a:u32[0]>>>0,b:u32[1]>>>0}, nested:{t:"NAV1:"+(token>>>0), a:[1,2,3]} };
  }

  let expectedIdx = 0;
  const pushed = [];
  let envBlocked=0, goErrors=0, timeouts=0, stateAnom=0, contam=0;
  let popSeen=0, cloneAtPush=0, refAlias=0, inconclusive=0;

  let expect=null, ackResolve=null;
  function armAck(e){ expect=e; return new Promise(res=>{ ackResolve=res; }); }
  function disarmAck(){ expect=null; ackResolve=null; }

  function safeReplaceState(st, urlStr){
    try{
      if(urlMutable && urlStr) history.replaceState(st,"",urlStr);
      else history.replaceState(st,"",undefined);
      return true;
    }catch(e){
      envBlocked++;
      log(`[INFO] ${tag} replaceState blocked: ${e && e.message ? e.message : e}`);
      return false;
    }
  }
  function safePushState(st, urlStr){
    try{
      if(urlMutable && urlStr) history.pushState(st,"",urlStr);
      else history.pushState(st,"",undefined);
      return true;
    }catch(e){
      envBlocked++;
      log(`[INFO] ${tag} pushState blocked: ${e && e.message ? e.message : e}`);
      return false;
    }
  }

  const onPop = (ev)=>{
    popSeen++;
    const st = ev.state;
    if(!st || typeof st !== "object"){ stateAnom++; if(ackResolve) ackResolve({ok:false,why:"no_state"}); disarmAck(); return; }
    const idx = (st.idx>>>0);
    const token = (st.token>>>0);
    if(expect){
      if(idx !== (expect.wantIdx>>>0) || token !== (expect.wantToken>>>0)){
        let matchedOther=false;
        for(let i=0;i<pushed.length;i++){
          if((pushed[i].idx>>>0)===idx && (pushed[i].token>>>0)===token){ matchedOther=true; break; }
        }
        if(matchedOther) contam++;
        stateAnom++;
        if(ackResolve) ackResolve({ok:false,why:"mismatch",idx,token,wantIdx:expect.wantIdx,wantToken:expect.wantToken});
        disarmAck();
        return;
      }
    }
    if(ackResolve) ackResolve({ok:true,idx,token});
    disarmAck();
  };

  window.addEventListener("popstate", onPop);

  const baseQ = "?seed=" + (ctx.seed>>>0);
  const initOk = safeReplaceState(makeState(0, baseToken), urlMutable ? (baseQ + "&i=0") : null);
  if(!initOk){
    window.removeEventListener("popstate", onPop);
    fail(tag, RC("ENV_BLOCK","History replaceState blocked (origin/url policy). No conclusão em PS4."));
    snapshot(tag);
    return;
  }
  pushed.push({idx:0, token:baseToken});

  for(let i=1;i<=cap.historyOps && !CTRL.stop;i++){
    const token = (rand32(baseToken ^ i) ^ 0x13579BDF) >>> 0;
    const st = makeState(i, token);
    const origU32 = new Uint32Array(st.buf);
    const okPush = safePushState(st, urlMutable ? (baseQ + "&i=" + i) : null);
    if(!okPush) break;
    expectedIdx = i;
    pushed.push({idx:i, token});

    // mutate original AFTER push to test cloneAtPush
    try{ origU32[0] = (origU32[0] ^ 0xFFFFFFFF) >>> 0; }catch(e){}

    // go(-1)
    try{
      const wantIdxBack = (expectedIdx - 1) >>> 0;
      const wantTokBack = pushed[wantIdxBack].token >>> 0;
      const pBack = armAck({wantIdx:wantIdxBack, wantToken:wantTokBack, dir:-1});
      history.go(-1);
      const rBack = await Promise.race([pBack, sleep(cap.ackTimeoutMs).then(()=>({ok:false,why:"timeout"}))]);
      if(!rBack || !rBack.ok){ timeouts++; log(`[WARN] ${tag} go(-1) ${RC("EVENT_DROP", (rBack&&rBack.why)?rBack.why:"timeout")}`); }
      else expectedIdx = wantIdxBack;
    }catch(e){ goErrors++; break; }

    // go(+1)
    try{
      const wantIdxFwd = (expectedIdx + 1) >>> 0;
      const wantTokFwd = pushed[wantIdxFwd].token >>> 0;
      const pFwd = armAck({wantIdx:wantIdxFwd, wantToken:wantTokFwd, dir:+1});
      history.go(1);
      const rFwd = await Promise.race([pFwd, sleep(cap.ackTimeoutMs).then(()=>({ok:false,why:"timeout"}))]);
      if(!rFwd || !rFwd.ok){ timeouts++; log(`[WARN] ${tag} go(+1) ${RC("EVENT_DROP", (rFwd&&rFwd.why)?rFwd.why:"timeout")}`); }
      else expectedIdx = wantIdxFwd;
    }catch(e){ goErrors++; break; }

    // classify cloneAtPush conservatively
    try{
      const cur = history.state;
      if(cur && cur.buf){
        const v = new Uint32Array(cur.buf);
        if((v[0]>>>0) !== (origU32[0]>>>0)) cloneAtPush++;
        else refAlias++;
      }else inconclusive++;
    }catch(e){ inconclusive++; }

    const d = await healthDrift(tag + ":step");
    if(d > cap.driftWarnMs){ log(`[INFO] ${tag} ${RC("DRIFT","drift alto; yield 1 frame para reduzir ruído")}`); await sleep(16); }
  }

  window.removeEventListener("popstate", onPop);

  log(`[OK] popSeen=${popSeen} cloneAtPush=${cloneAtPush} refAlias=${refAlias} wrong/inconclusive=${stateAnom+inconclusive} crossContam=${contam} timeouts=${timeouts} goErrors=${goErrors} envBlocked=${envBlocked}`);

  if(envBlocked>0){ fail(tag, RC("ENV_BLOCK","History API bloqueada por policy (mais comum no Android content://).")); snapshot(tag); return; }
  if(contam>=2){ fail(tag, RC("STATE_ANOMALY","Cross-entry contamination (token/idx de entrada errada).")); snapshot(tag); return; }
  if(stateAnom>=3){ fail(tag, RC("STATE_ANOMALY","Múltiplas anomalias em ev.state/idx/token (bookkeeping).")); snapshot(tag); return; }
  if(refAlias>=2 && cloneAtPush===0){ fail(tag, RC("ALIAS","History state parece aliasar buffer original (repetível).")); snapshot(tag); return; }

  pass(tag, "OK (bounded), invariants mantidos.");
};

/* ========================= CLONE1 ========================= */
TESTS.CLONE1 = async function(ctx){
  const tag="CLONE1";
  CTRL.lastTest=tag;
  log(`[TEST] ${tag} :: MessageChannel structured clone invariants | mode=${ctx.mode} seed=${ctx.seed}`);
  const cap = ctx.cap;

  let ok=0,bad=0,throws=0,aliasSus=0,shapeAnom=0;

  function makePayload(i){
    const buf=new ArrayBuffer(64);
    const u32=new Uint32Array(buf);
    const token=(rand32(ctx.seed ^ i) ^ 0xABCD1234)>>>0;
    u32[0]=(0xC10E0000 ^ i)>>>0;
    u32[1]=token>>>0;
    return {v:1,i:i>>>0,token:token>>>0,buf:buf,nested:{s:"C:"+(token>>>0),a:[i,i+1]}};
  }

  const ch=new MessageChannel();
  const p1=ch.port1, p2=ch.port2;
  p2.start();

  for(let i=0;i<cap.cloneOps && !CTRL.stop;i++){
    const payload=makePayload(i);
    const orig=new Uint32Array(payload.buf);
    const before0=orig[0]>>>0;
    let got=null;

    try{
      const pr=new Promise(res=>{ p2.onmessage=(ev)=>res(ev.data); });
      p1.postMessage(payload);
      got = await Promise.race([pr, sleep(cap.ackTimeoutMs).then(()=>null)]);
    }catch(e){ throws++; continue; }

    if(!got){ bad++; log(`[WARN] ${tag} ${RC("EVENT_DROP","sem retorno no timeout")}`); continue; }
    if(typeof got!=="object" || !got.buf || typeof got.token!=="number"){ shapeAnom++; continue; }

    try{ orig[0]=(orig[0]^0xFFFFFFFF)>>>0; }catch(e){}

    try{
      const g=new Uint32Array(got.buf);
      const g0=g[0]>>>0;
      if(g0 === (orig[0]>>>0)) aliasSus++;
      if(g0 === before0) ok++; else bad++;
    }catch(e){ bad++; }
  }

  log(`[OK] ok=${ok} bad=${bad} throws=${throws} aliasSus=${aliasSus} shapeAnom=${shapeAnom}`);
  if(aliasSus>=2){ fail(tag, RC("ALIAS","Buffer clonado parece refletir mutação do original (inesperado).")); snapshot(tag); return; }
  if(shapeAnom>=3){ fail(tag, RC("SHAPE","Anomalias repetidas no payload clonado.")); snapshot(tag); return; }
  pass(tag,"OK (bounded).");
};

/* ========================= DOM1 ========================= */
TESTS.DOM1 = async function(ctx){
  const tag="DOM1";
  CTRL.lastTest=tag;
  log(`[TEST] ${tag} :: DOM lifecycle + getters invariants | mode=${ctx.mode} seed=${ctx.seed}`);
  const cap = ctx.cap;

  let created=0,removed=0,reattached=0,anom=0,throws=0;
  const host=document.createElement("div");
  host.id="dom1_host_"+(ctx.seed>>>0);
  document.body.appendChild(host);

  function makeNode(i){
    const d=document.createElement("div");
    d.setAttribute("data-i",""+i);
    d.textContent="N"+i;
    return d;
  }

  const limit = Math.min(cap.domNodes, 300);
  for(let i=0;i<limit && !CTRL.stop;i++){
    try{
      const n=makeNode(i);
      host.appendChild(n); created++;

      const w=n.offsetWidth, t=n.offsetTop;
      if(typeof w!=="number" || typeof t!=="number") anom++;

      n.remove(); removed++;
      await Promise.resolve();

      host.appendChild(n); reattached++;
      const w2=n.offsetWidth;
      if(typeof w2!=="number") anom++;

      n.setAttribute("data-x","x"+((rand32(ctx.seed^i))>>>0));
      n.style.display = (i%7===0) ? "none" : "block";
      const h2=n.offsetHeight;
      if(typeof h2!=="number") anom++;
    }catch(e){ throws++; }

    if((i%50)===0) await sleep(0);
  }

  try{ host.remove(); }catch(e){}
  log(`[OK] created=${created} removed=${removed} reattached=${reattached} anom=${anom} throws=${throws}`);
  if(throws>=3){ fail(tag, RC("EXC","Exceções repetidas durante operações DOM bounded.")); snapshot(tag); return; }
  pass(tag,"OK (bounded).");
};

/* ========================= MEDIA1 ========================= */
TESTS.MEDIA1 = async function(ctx){
  const tag="MEDIA1";
  CTRL.lastTest=tag;
  log(`[TEST] ${tag} :: media teardown invariants (video/TextTrack) | mode=${ctx.mode} seed=${ctx.seed}`);
  const cap=ctx.cap;
  let ops=0,skips=0,throws=0;

  for(let i=0;i<cap.mediaOps && !CTRL.stop;i++){
    const v=document.createElement("video");
    v.muted=true;
    try{
      document.body.appendChild(v);
      v.src="";
      if(typeof v.load==="function") v.load();
      if(typeof v.addTextTrack==="function"){
        const tt=v.addTextTrack("subtitles","t","en");
        tt.mode="hidden"; tt.mode="disabled";
      }else skips++;

      if(v.pause) v.pause();
      v.removeAttribute("src");
      if(typeof v.load==="function") v.load();
      v.remove();
      ops++;
    }catch(e){
      throws++;
      try{ v.remove(); }catch(_){}
    }
    await sleep(0);
  }

  log(`[OK] ops=${ops} skips=${skips} throws=${throws}`);
  if(throws>=2){ fail(tag, RC("EXC","Exceções inesperadas em teardown de mídia (bounded).")); snapshot(tag); return; }
  pass(tag,"OK (bounded).");
};

/* ========================= CAN1 ========================= */
TESTS.CAN1 = async function(ctx){
  const tag="CAN1";
  CTRL.lastTest=tag;
  log(`[TEST] ${tag} :: Canvas2D resize/destroy invariants | mode=${ctx.mode} seed=${ctx.seed}`);
  const cap=ctx.cap;
  let ops=0,skips=0,throws=0,anom=0;

  for(let i=0;i<cap.canvasOps && !CTRL.stop;i++){
    const c=document.createElement("canvas");
    c.width=64; c.height=64;
    try{
      document.body.appendChild(c);
      const g=c.getContext("2d");
      if(!g){ skips++; c.remove(); continue; }
      g.fillRect(0,0,1,1);
      g.clearRect(0,0,64,64);
      c.width = 32 + (i%32);
      c.height = 32 + ((i*3)%32);
      const img=g.getImageData(0,0,1,1);
      if(!img || !img.data || img.data.length<4) anom++;
      c.remove();
      ops++;
    }catch(e){
      throws++;
      try{ c.remove(); }catch(_){}
    }
    if((i%30)===0) await sleep(0);
  }

  log(`[OK] ops=${ops} skips=${skips} throws=${throws} anom=${anom}`);
  if(throws>=2){ fail(tag, RC("EXC","Exceções inesperadas em ciclo de canvas (bounded).")); snapshot(tag); return; }
  pass(tag,"OK (bounded).");
};

/* ========================= Runner/UI ========================= */
const UI = {
  async runOnceSelected(){
    CTRL.stop=false; CTRL.fails=0;
    const ctx=ctxFromUI();
    const sel=selectTests();

    log(`[READY] Harness v4 carregado. Sugestão: SAFE -> Run ALL once. Depois SAFE -> selecionar 2-3 e Loop N.`);
    log(`[INFO] Sem window.open. Tudo roda na mesma aba. SAFE/AGGR são bounded (não é DoS).`);
    log(`[RUN] Once | tests=${sel.length} mode=${ctx.mode}`);
    log(`[INFO] mode=${ctx.mode} caps: budgetMs=${ctx.cap.budgetMs} historyOps=${ctx.cap.historyOps} cloneOps=${ctx.cap.cloneOps} domNodes<=${Math.min(ctx.cap.domNodes,300)} canvasOps=${ctx.cap.canvasOps} mediaOps=${ctx.cap.mediaOps}`);

    for(let i=0;i<sel.length && !CTRL.stop;i++){
      const name=sel[i], fn=TESTS[name];
      if(!fn){ log(`[SKIP] unknown test ${name}`); continue; }
      log("------------------------------------------------------------");
      log(`[CP] begin ${name}`);
      await healthDrift(name + ":pre");
      const t0=nowMs();
      try{ await fn(ctx); }
      catch(e){ fail(name, RC("EXC","Unhandled exception: "+(e&&e.message?e.message:e))); snapshot(name); }
      const dt=nowMs()-t0;
      await healthDrift(name + ":post");
      log(`[CP] end ${name} dt=${dt.toFixed(2)}ms`);
    }

    log("------------------------------------------------------------");
    log(`[RUN] Done. fails=${CTRL.fails} lastTest=${CTRL.lastTest}`);
  },

  async loopSelected(){
    CTRL.stop=false; CTRL.fails=0;
    const base=ctxFromUI();
    const sel=selectTests();
    const N=Math.max(1, parseInt(document.getElementById("loopN").value,10)||10);
    const delay=Math.max(0, parseInt(document.getElementById("delayMs").value,10)||0);

    log(`[RUN] Loop | tests=${sel.length} mode=${base.mode} loopN=${N} delayMs=${delay}`);

    for(let k=1;k<=N && !CTRL.stop;k++){
      log("------------------------------------------------------------");
      log(`[ITER] ${k}/${N}`);

      const ctx={ mode:base.mode, seed:(base.seed+(k-1))>>>0, cap:base.cap };

      for(let i=0;i<sel.length && !CTRL.stop;i++){
        const name=sel[i], fn=TESTS[name];
        if(!fn) continue;
        log("------------------------------------------------------------");
        log(`[CP] begin ${name}`);
        await healthDrift(name + ":pre");
        const t0=nowMs();
        try{ await fn(ctx); }
        catch(e){ fail(name, RC("EXC","Unhandled exception: "+(e&&e.message?e.message:e))); snapshot(name); }
        const dt=nowMs()-t0;
        await healthDrift(name + ":post");
        log(`[CP] end ${name} dt=${dt.toFixed(2)}ms`);
      }

      log("------------------------------------------------------------");
      log(`[RUN] Done iter=${k}. fails=${CTRL.fails} lastTest=${CTRL.lastTest}`);
      if(delay) await sleep(delay);
    }

    log(`[RUN] Loop done. fails=${CTRL.fails}`);
  }
};

(function(){
  log(`[READY] Harness v4 carregado. Objetivo: indicadores de vulnerabilidade (sem exploração / sem DoS).`);
  log(`[INFO] Dica: no Android via content:// o History bloqueia URL mutation (origin=null). No PS4 via file:// ou http isso tende a funcionar.`);
})();
</script>
</body>
</html>
