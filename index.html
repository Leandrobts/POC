<!DOCTYPE html>
<html>
<head>
    <title>PS4 Thread-War (Worker Race Condition)</title>
    <style>
        body { background: #000; color: #ffcc00; font-family: monospace; overflow: hidden; margin: 0; }
        #hud { 
            position: fixed; top: 0; left: 0; width: 100%; 
            background: rgba(20, 20, 0, 0.95); 
            border-bottom: 2px solid #fc0; 
            padding: 15px; z-index: 9999;
            font-size: 24px; font-weight: bold;
        }
        .race-target { border: 5px solid red; width: 50px; height: 50px; display: inline-block; }
    </style>
</head>
<body>
    <div id="hud">
        <div>THREAD WAR: <span style="color:lime">RODANDO</span> <span id="beat">⚡</span></div>
        <div style="font-size: 16px; color: #aaa; margin-top: 5px;">
            SEED: <span id="seed-disp" style="color:#fff">...</span> | CONFLITOS: <span id="conflict-count">0</span>
        </div>
    </div>

    <div id="arena" style="margin-top: 100px;"></div>

    <script>
        // ================= CONFIGURAÇÃO DE CONCORRÊNCIA =================
        const WORKER_COUNT = 4; // PS4 tem 8 núcleos, vamos usar 4 workers para estressar
        // ================================================================

        let currentSeed = parseInt(localStorage.getItem('thread_seed') || Math.floor(Math.random() * 100000));
        localStorage.setItem('thread_last_start', currentSeed);

        const seedSpan = document.getElementById('seed-disp');
        const conflictSpan = document.getElementById('conflict-count');
        const beatSpan = document.getElementById('beat');
        const arena = document.getElementById('arena');
        let conflicts = 0;

        // --- 1. CRIAÇÃO DO CÓDIGO DO WORKER (EM TEMPO REAL) ---
        // O Worker vai bombardear a thread principal com mensagens de ArrayBuffer
        const workerCode = `
            self.onmessage = function(e) {
                // Modo Loop Infinito no Worker
                setInterval(() => {
                    // Cria dados aleatórios para confundir a memória
                    let payload = new Float64Array(100).fill(Math.random());
                    
                    // Envia para a thread principal (postMessage transfere memória)
                    // Transferir memória (Transferable Objects) é o ponto crítico de bugs
                    self.postMessage({cmd: 'stress', data: payload}, [payload.buffer]);
                }, 5); // Bombardeio a cada 5ms
            };
        `;
        
        const blob = new Blob([workerCode], {type: 'application/javascript'});
        const workerURL = URL.createObjectURL(blob);
        let workers = [];

        // Inicia os Workers
        for(let i=0; i<WORKER_COUNT; i++) {
            let w = new Worker(workerURL);
            w.onmessage = handleWorkerMessage;
            w.postMessage("START"); // Acorda o worker
            workers.push(w);
        }

        // --- 2. LIDA COM O BOMBARDEIO ---
        function handleWorkerMessage(e) {
            // O Worker mandou dados. O navegador precisa alocar isso na Thread Principal.
            // Se estivermos deletando coisas agora, pode dar ruim.
            conflicts++;
            conflictSpan.innerText = conflicts;
            
            // Tenta causar confusão acessando o DOM durante a recepção da mensagem
            if (liveNodes.length > 0) {
                let victim = liveNodes[Math.floor(Math.random() * liveNodes.length)];
                try {
                    // Acesso de leitura forçado
                    let _ = victim.style.opacity;
                    // Modificação leve
                    victim.style.transform = `rotate(${Math.random()*360}deg)`;
                } catch(e){}
            }
        }

        // --- 3. LÓGICA DA THREAD PRINCIPAL (DOM) ---
        let liveNodes = [];

        function createNode() {
            let div = document.createElement('div');
            div.className = 'race-target';
            div.style.backgroundColor = `hsl(${Math.random()*360}, 100%, 50%)`;
            // SVG + ForeignObject (favorito do WebKit UAF)
            div.innerHTML = '<svg><foreignObject width="40" height="40"><span>X</span></foreignObject></svg>';
            return div;
        }

        async function loop() {
            while(true) {
                seedSpan.innerText = currentSeed;
                beatSpan.style.opacity = (beatSpan.style.opacity == "1") ? "0.2" : "1";
                
                // Salva seed
                if (conflicts % 1000 === 0) localStorage.setItem('thread_seed', currentSeed);

                // Pausa para renderizar (evita congelamento visual)
                await new Promise(r => setTimeout(r, 30));

                // Lote de operações DOM
                for(let k=0; k<10; k++) {
                    // Cria
                    if (liveNodes.length < 200) {
                        let el = createNode();
                        arena.appendChild(el);
                        liveNodes.push(el);
                    }

                    // Mata (enquanto os workers estão gritando no fundo)
                    if (liveNodes.length > 50) {
                        let idx = Math.floor(Math.random() * liveNodes.length);
                        let dying = liveNodes[idx];
                        liveNodes.splice(idx, 1);
                        
                        // Race condition clássica: setTimeout 0 vs Worker Message
                        if (Math.random() > 0.5) {
                            setTimeout(() => { try{ dying.remove(); }catch(e){} }, 0);
                        } else {
                            try{ dying.remove(); }catch(e){}
                        }
                    }
                }
                currentSeed++;
                
                // Limpeza visual periódica
                if (conflicts > 5000) {
                    arena.innerHTML = "";
                    liveNodes = [];
                    conflicts = 0;
                }
            }
        }

        setTimeout(loop, 500);

    </script>
</body>
</html>
