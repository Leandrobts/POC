<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Stress Suite (DOM, Unicode, Mem)</title>
    <style>
        body { background-color: #121212; color: #e0e0e0; font-family: 'Courier New', monospace; padding: 20px; }
        h1 { border-bottom: 1px solid #333; padding-bottom: 10px; color: #ff5555; }
        .panel { border: 1px solid #444; background: #1e1e1e; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        .log-box { height: 250px; overflow-y: scroll; border: 1px solid #333; background: #000; padding: 10px; font-size: 0.85em; color: #00ff00; margin-top: 10px; }
        button { 
            padding: 12px 20px; margin-right: 10px; margin-bottom: 10px;
            background: #333; color: white; border: 1px solid #555; 
            cursor: pointer; font-size: 1em; font-family: inherit; font-weight: bold;
        }
        button:hover { background: #555; border-color: #777; }
        button.danger { border-color: #ff5555; color: #ff5555; }
        button.danger:hover { background: #300000; }
        
        .test-desc { font-size: 0.8em; color: #888; margin-bottom: 10px; display: block; }
        #hidden-area { display: none; }
    </style>
</head>
<body>

    <h1>Stress Suite v2.0</h1>

    <div class="panel">
        <h3>Controles de Teste</h3>
        
        <span class="test-desc">1. Cria milhares de DIVs aninhados (Stack Overflow).</span>
        <button onclick="runDOMTest()">1. DOM Depth (Nesting)</button>
        
        <br><br>

        <span class="test-desc">2. Cria sequência ZWJ massiva (Render/Memory).</span>
        <button onclick="runUnicodeTest()">2. Unicode Bomb</button>

        <br><br>

        <span class="test-desc">3. Tenta acessar memória transferida (Use-After-Free check).</span>
        <button onclick="runBufferTest()">3. Buffer Detach</button>

        <hr style="border-color: #333;">
        <button onclick="clearLog()">Limpar Log</button>
    </div>

    <h3>Console de Log:</h3>
    <div class="log-box" id="console-log"></div>

    <div id="test-sandbox"></div>

    <script>
        const logBox = document.getElementById('console-log');
        const sandbox = document.getElementById('test-sandbox');

        function log(msg, type="info") {
            const div = document.createElement('div');
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if (type === "error") div.style.color = "#ff5555";
            if (type === "success") div.style.color = "#55ffff";
            logBox.appendChild(div);
            logBox.scrollTop = logBox.scrollHeight;
        }

        function clearLog() {
            logBox.innerHTML = "";
        }

        // --- TESTE 1: DOM Depth (Stack Exhaustion) ---
        function runDOMTest() {
            log("INICIANDO: DOM Depth Test...", "info");
            // WebKit costuma falhar entre 4000 e 10000
            const depth = 6000; 
            
            setTimeout(() => { // Timeout para permitir renderizar o log antes de travar
                try {
                    let root = document.createElement('div');
                    let current = root;
                    
                    for (let i = 0; i < depth; i++) {
                        let child = document.createElement('div');
                        current.appendChild(child);
                        current = child;
                    }
                    
                    log(`Estrutura criada com ${depth} níveis. Inserindo no DOM...`);
                    
                    // O momento perigoso é aqui:
                    sandbox.appendChild(root);
                    
                    // Força recálculo de estilo
                    let h = root.offsetHeight; 
                    
                    log(`SUCESSO: Navegador renderizou ${depth} níveis sem crash.`, "success");
                    
                    // Limpeza
                    sandbox.innerHTML = "";
                } catch (e) {
                    log(`ERRO CAPTURADO: O navegador bloqueou a recursão: ${e.message}`, "error");
                }
            }, 100);
        }

        // --- TESTE 2: Unicode Bomb (ZWJ Sequence) ---
        function runUnicodeTest() {
            log("INICIANDO: Unicode ZWJ Bomb...", "info");
            
            setTimeout(() => {
                try {
                    const target = document.createElement('div');
                    // Estilo para garantir que o navegador tente renderizar
                    target.style.position = 'absolute';
                    target.style.top = '-1000px'; 
                    sandbox.appendChild(target);

                    const man = "\u{1F468}";
                    const joiner = "\u{200D}";
                    const loops = 10000; // Tente aumentar se não acontecer nada

                    log(`Gerando string com ${loops} junções...`);
                    
                    // Constrói a string massiva
                    let payload = man;
                    for(let i=0; i < loops; i++) {
                        payload += joiner + man;
                    }

                    target.innerText = payload;
                    
                    // Gatilho de renderização
                    let width = target.offsetWidth;
                    
                    log(`SUCESSO: Renderizado. Largura: ${width}px`, "success");
                    sandbox.innerHTML = "";
                    
                } catch (e) {
                    log(`ERRO: ${e.message}`, "error");
                }
            }, 100);
        }

        // --- TESTE 3: Array Buffer Detach (Worker Transfer) ---
        function runBufferTest() {
            log("INICIANDO: Buffer Detach Test...", "info");
            
            try {
                // 1. Cria um buffer grande (10MB)
                const size = 1024 * 1024 * 10;
                const buffer = new ArrayBuffer(size);
                log(`Buffer criado: ${size} bytes.`);

                // 2. Cria um Worker inline (sem arquivo externo)
                const workerScript = `
                    self.onmessage = function(e) { 
                        // Apenas recebe o buffer e termina
                        postMessage("Buffer recebido pelo Worker");
                    };
                `;
                const blob = new Blob([workerScript], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));

                worker.onmessage = function(e) {
                    log(`Worker respondeu: ${e.data}`);
                };

                // 3. Verifica tamanho antes
                if (buffer.byteLength === 0) {
                    log("Erro: Buffer já está vazio antes do envio!", "error");
                    return;
                }

                // 4. Transfere o buffer (DETACH)
                // O segundo argumento [buffer] indica transferência, não cópia.
                worker.postMessage({ buffer: buffer }, [buffer]);

                // 5. TESTE CRÍTICO: Tenta ler o buffer na thread principal
                // Se a implementação estiver correta, byteLength deve ser 0.
                // Se tiver bug (Race Condition ou falha de detach), será > 0.
                if (buffer.byteLength === 0) {
                    log("Resultado: SEGURO. O buffer foi desligado corretamente.", "success");
                } else {
                    log(`ALERTA: Buffer ainda tem tamanho ${buffer.byteLength} após transferência!`, "error");
                    log("POTENCIAL VULNERABILIDADE DETECTADA (Use-After-Free logic)", "error");
                }

            } catch (e) {
                log(`ERRO na execução do Worker: ${e.message}`, "error");
            }
        }
    </script>
</body>
</html>
