<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>PS4 Fullscreen+Blur Rootcause Suite (No Dump)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: monospace; margin: 0; padding: 10px; background: #111; color: #ddd; }
    h1 { margin: 0 0 8px 0; font-size: 16px; }
    #log { border: 1px solid #444; background: #000; padding: 8px; height: 55vh; overflow: auto; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0; }
    button { padding: 8px 10px; font-family: monospace; }
    .hint { color: #9bd; }
    .warn { color: #ffb84d; }
    .bad  { color: #ff5c5c; }
    .good { color: #7CFC9A; }
    .muted{ color: #888; }
    #frame { width: 1px; height: 1px; position: fixed; left: -9999px; top: -9999px; border: 0; }
  </style>
</head>
<body>
  <h1>PS4 Fullscreen+Blur Rootcause Suite (No Dump / No OOB)</h1>

  <div class="row">
    <button id="btnLoad" onclick="loadIframe()">Load / Reset Iframe</button>
    <button onclick="clearLog()">Clear Log</button>
  </div>

  <div class="row">
    <div class="hint">
      Sequência: (1) Load/Reset Iframe (2) Clique no botão dentro do iframe (na tela) (3) ENTRE em Fullscreen (automático)
      (4) Abra OPTIONS (blur) (5) Aguarde o teardown e o log no parent.
    </div>
  </div>

  <div id="log"></div>

  <iframe id="frame"></iframe>

<script>
(function(){
  const logEl = document.getElementById('log');
  const frame = document.getElementById('frame');

  function ts() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  function log(line, cls) {
    const div = document.createElement('div');
    div.textContent = `[${ts()}] ${line}`;
    if (cls) div.className = cls;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  window.clearLog = () => { logEl.innerHTML = ''; };
  window.loadIframe = () => {
    log('[PARENT] Loading iframe...', 'muted');
    frame.srcdoc = iframeHTML();
  };

  window.addEventListener('message', (e) => {
    // Tudo que vem do iframe já vem como string pronta
    if (typeof e.data === 'string') {
      log(e.data);
    } else if (e.data && e.data.type === 'log') {
      log(e.data.msg, e.data.cls || '');
    }
  });

  // Carrega de início
  loadIframe();

  function iframeHTML() {
return `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IFRAME Runner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin: 0; background: #000; color: #0f0; font-family: monospace; }
    .wrap { padding: 10px; }
    h2 { margin: 0 0 8px 0; font-size: 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; }
    button { padding: 10px; font-family: monospace; }
    select, input { font-family: monospace; padding: 6px; background: #111; color: #0f0; border: 1px solid #0f0; }
    .hint { color: #9f9; }
    .warn { color: #ff0; }
    .bad  { color: #f66; }
    .ok   { color: #0f0; }
    .box { border: 1px solid #0f0; padding: 8px; background: #001100; }
    #status { white-space: pre-wrap; }
  </style>
</head>
<body>
<div class="wrap">
  <h2>IFRAME: Rootcause Tests (A–F)</h2>

  <div class="box" id="status">
Clique um teste abaixo. O iframe vai pedir fullscreen.
Depois abra OPTIONS (blur). Após blur, o teste faz teardown e retorna log ao PARENT.
  </div>

  <div class="row">
    <label>Array Type:
      <select id="type">
        <option value="f64">Float64Array</option>
        <option value="u8">Uint8Array</option>
        <option value="dv">DataView</option>
        <option value="ab">ArrayBuffer-only</option>
      </select>
    </label>

    <label>count:
      <select id="count">
        <option>1</option>
        <option>4</option>
        <option>32</option>
        <option>256</option>
        <option>1024</option>
      </select>
    </label>

    <label>len:
      <select id="len">
        <option value="8">8</option>
        <option value="64">64</option>
        <option value="256">256</option>
        <option value="1024">1024</option>
        <option value="8192">8192</option>
      </select>
    </label>

    <label>Detach before blur:
      <select id="detach">
        <option value="no">no</option>
        <option value="yes">yes (postMessage transfer)</option>
      </select>
    </label>

    <label>Teardown action:
      <select id="teardown">
        <option value="dom_small">DOM small mutation</option>
        <option value="dom_big">DOM big rewrite (innerHTML)</option>
        <option value="kill_iframe">Kill iframe (document.open minimal)</option>
        <option value="doc_write">document.write full</option>
        <option value="reload">location.reload (aggressive)</option>
      </select>
    </label>
  </div>

  <div class="row">
    <button onclick="runA()">TEST A: Detach vs Non-Detach</button>
    <button onclick="runB()">TEST B: GC/Pressure Matrix</button>
    <button onclick="runC()">TEST C: Event Order / State Machine</button>
    <button onclick="runD()">TEST D: Blur vs Visibility (which first?)</button>
    <button onclick="runE()">TEST E: Minimal Teardown Bisection</button>
    <button onclick="runF()">TEST F: Glitch Persistence Checklist</button>
  </div>

  <div class="hint">
Observação: Alguns eventos podem não disparar sempre. O valor aqui é comparar runs “crasha” vs “não crasha” (quando ocorrer).
  </div>
</div>

<script>
(function(){
  function send(msg, cls) {
    window.parent.postMessage({type:'log', msg:'[MSG] ' + msg, cls: cls || ''}, '*');
  }
  function setStatus(t) {
    document.getElementById('status').textContent = t;
  }

  // --------- Global counters / event capture ----------
  let armed = false;
  let counts = { blur:0, visibility:0, fullscreen:0, pagehide:0 };
  let order = [];
  let lastVis = null;

  function resetEvents(tag) {
    counts = { blur:0, visibility:0, fullscreen:0, pagehide:0 };
    order = [];
    lastVis = document.visibilityState;
    send('=== RESET EVENTS ('+tag+') ===');
    send('visibilityState initial=' + document.visibilityState);
  }

  function note(ev) {
    order.push(ev);
    send('[EVENT] ' + ev);
  }

  function installListeners() {
    window.onblur = function(){
      counts.blur++;
      note('blur #' + counts.blur);
      if (armed) onTrigger('blur');
    };
    document.addEventListener('visibilitychange', function(){
      counts.visibility++;
      const s = document.visibilityState;
      note('visibilitychange #' + counts.visibility + ' -> ' + s);
      lastVis = s;
      // Não dispara trigger aqui automaticamente. Só mede.
    }, true);

    document.addEventListener('fullscreenchange', function(){
      counts.fullscreen++;
      const active = !!document.fullscreenElement || !!document.webkitFullscreenElement;
      note('fullscreenchange #' + counts.fullscreen + ' active=' + active);
    }, true);

    window.addEventListener('pagehide', function(){
      counts.pagehide++;
      note('pagehide #' + counts.pagehide);
    }, true);
  }

  installListeners();

  function snapshot(label, obj) {
    // Sem dump: apenas invariantes JS-level permitidas
    let s = '[SNAPSHOT] ' + label + '\\n';
    s += '  type=' + obj.kind + ' count=' + obj.count + ' len=' + obj.len + ' detach=' + obj.detach + '\\n';
    s += '  visibilityState=' + document.visibilityState + '\\n';
    s += '  counts=' + JSON.stringify(counts) + '\\n';
    s += '  order=' + JSON.stringify(order) + '\\n';
    s += '  js: ';
    try {
      s += 'view.length=' + (obj.view ? obj.view.length : 'null') + ' ';
      s += 'view.byteLength=' + (obj.view ? obj.view.byteLength : 'null') + ' ';
      s += 'ab.byteLength=' + (obj.ab ? obj.ab.byteLength : 'null') + ' ';
      s += 'v0=' + (obj.view ? obj.view[0] : 'null');
    } catch(e) {
      s += 'ERR(' + e + ')';
    }
    send(s);
  }

  function requestFS() {
    const el = document.documentElement;
    try {
      if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      else if (el.requestFullscreen) el.requestFullscreen();
      send('[STATE] fullscreen requested');
    } catch(e) {
      send('[STATE] fullscreen request failed: ' + e, 'bad');
    }
  }

  function getParams() {
    return {
      kind: document.getElementById('type').value,
      count: parseInt(document.getElementById('count').value, 10),
      len: parseInt(document.getElementById('len').value, 10),
      detach: document.getElementById('detach').value,
      teardown: document.getElementById('teardown').value,
    };
  }

  // --------- Allocation without spray / no OOB ----------
  let keep = {
    views: [],
    abs: [],
    dv: null,
    alias: null,
    kind: null,
    detached: false
  };

  function alloc(params) {
    keep.views = [];
    keep.abs = [];
    keep.dv = null;
    keep.alias = null;
    keep.kind = params.kind;
    keep.detached = false;

    if (params.kind === 'ab') {
      for (let i=0;i<params.count;i++){
        const ab = new ArrayBuffer(params.len * 8); // sized similarly
        keep.abs.push(ab);
      }
      send('[ALLOC] ArrayBuffer-only: ' + params.count + ' x ' + (params.len*8) + ' bytes');
      return { kind: params.kind, count: params.count, len: params.len, ab: keep.abs[0] || null, view: null };
    }

    // Create ArrayBuffer + view
    for (let i=0;i<params.count;i++){
      const ab = new ArrayBuffer(params.len * 8);
      keep.abs.push(ab);

      let view = null;
      if (params.kind === 'f64') view = new Float64Array(ab);
      else if (params.kind === 'u8') view = new Uint8Array(ab);
      else if (params.kind === 'dv') view = new DataView(ab);

      // seed recognizable but not exploit-like
      if (params.kind === 'f64') view[0] = 13.37;
      if (params.kind === 'u8') view[0] = 0x41;

      keep.views.push(view);
    }

    send('[ALLOC] ' + params.kind + ': count=' + params.count + ' len=' + params.len + ' (kept alive)');
    return {
      kind: params.kind,
      count: params.count,
      len: params.len,
      ab: keep.abs[0],
      view: (params.kind === 'dv') ? null : keep.views[0]  // DataView não tem length
    };
  }

  function detachIfRequested(params) {
    if (params.detach !== 'yes') return;

    // Detach (neuter) via postMessage transfer (same-origin)
    try {
      const ab0 = keep.abs[0];
      if (!ab0) { send('[DETACH] no ArrayBuffer to detach'); return; }
      window.postMessage({x:1}, '*', [ab0]);
      keep.detached = true;
      send('[DETACH] postMessage transfer executed (buffer may be neutered)');
    } catch(e) {
      send('[DETACH] transfer failed: ' + e, 'warn');
    }
  }

  // --------- Trigger handling ----------
  function armAndWait(hint) {
    armed = true;
    setStatus('ARMED.\\nAbra OPTIONS agora (blur).\\n' + hint);
    send('[HINT] Abra OPTIONS agora (trigger blur)');
  }

  function onTrigger(source) {
    armed = false;
    send('========================================');
    send('[TRIGGER] ' + source + ' detected');
    send('========================================');
    // Deixe o teste corrente conduzir o teardown
    if (typeof window.__afterTrigger === 'function') {
      try { window.__afterTrigger(); } catch(e) { send('[AFTER] error: ' + e, 'bad'); }
    }
  }

  // --------- Teardown actions (bisection friendly) ----------
  function doTeardown(action) {
    send('[TEARDOWN] action=' + action);
    try {
      if (action === 'dom_small') {
        const d = document.createElement('div');
        d.textContent = 'x';
        document.body.appendChild(d);
        send('[TEARDOWN] DOM small done');
      } else if (action === 'dom_big') {
        document.body.innerHTML = '<pre>big rewrite</pre>'.repeat(200);
        send('[TEARDOWN] DOM big rewrite done');
      } else if (action === 'kill_iframe') {
        document.open();
        document.write('bye');
        document.close();
      } else if (action === 'doc_write') {
        document.open();
        document.write('<html><body><h1>doc.write teardown</h1></body></html>');
        document.close();
      } else if (action === 'reload') {
        // Ação agressiva: pode derrubar o processo se o bug estiver presente.
        location.reload();
      }
    } catch(e) {
      send('[TEARDOWN] threw: ' + e, 'warn');
    }
  }

  // --------- Tests A–F ----------
  window.runA = function(){
    // A: Detach vs Non-Detach (two sub-runs)
    const base = getParams();
    resetEvents('TEST A');
    send('=== START TEST A (Detach vs Non-Detach) ===', 'good');

    // First run: non-detach
    const p1 = Object.assign({}, base, { detach: 'no' });
    runSingle('A1 non-detach', p1, function(obj){
      snapshot('before fullscreen', obj);
      requestFS();
      armAndWait('A1: non-detach. Após blur: teardown=' + p1.teardown);
      window.__afterTrigger = function(){
        snapshot('after blur', obj);
        doTeardown(p1.teardown);
      };
    });

    // Second run: detach (requires reloading iframe by user to keep clean)
    setStatus('TEST A iniciou A1 (non-detach).\\nApós completar/crash, recarregue o iframe e rode A novamente para A2 (detach).\\n(Em PS4, manter dois sub-runs no mesmo processo distorce timing.)');
    send('[NOTE] Por estabilidade, rode A2 (detach) em uma nova execução do iframe (Load/Reset no parent).', 'warn');
  };

  window.runB = function(){
    // B: GC/pressure matrix (count/len)
    const base = getParams();
    resetEvents('TEST B');
    send('=== START TEST B (GC/Pressure Matrix) ===', 'good');

    // Matriz mínima: 3 combos, para não pesar
    const combos = [
      {count: 1, len: 8},
      {count: 32, len: 256},
      {count: 256, len: 1024}
    ];

    setStatus('TEST B: você vai repetir 3 execuções (recarregando o iframe entre elas)\\nObjetivo: ver se crash/glitch correlaciona com pressão.');

    send('[NOTE] Execute B em 3 rodadas separadas (Load/Reset entre rodadas): combos=' + JSON.stringify(combos), 'warn');

    // Faz apenas a primeira combinação nesta execução, para manter determinismo.
    const c = combos[0];
    const p = Object.assign({}, base, { count: c.count, len: c.len });
    runSingle('B combo1', p, function(obj){
      snapshot('before fullscreen', obj);
      requestFS();
      armAndWait('B combo1: count=' + p.count + ' len=' + p.len + '. Após blur: teardown=' + p.teardown);
      window.__afterTrigger = function(){
        snapshot('after blur', obj);
        doTeardown(p.teardown);
      };
    });
  };

  window.runC = function(){
    // C: Event order / state machine capture
    const p = getParams();
    resetEvents('TEST C');
    send('=== START TEST C (Event Order / State Machine) ===', 'good');

    const obj = alloc(p);
    detachIfRequested(p);
    snapshot('before fullscreen', obj);
    requestFS();
    armAndWait('C: somente capturar ordem. Após blur: executa teardown=' + p.teardown);
    window.__afterTrigger = function(){
      snapshot('after blur', obj);
      send('[C] event-order captured. Executing teardown now.');
      doTeardown(p.teardown);
    };
  };

  window.runD = function(){
    // D: Blur vs Visibility (which came first)
    const p = getParams();
    resetEvents('TEST D');
    send('=== START TEST D (Blur vs Visibility First?) ===', 'good');

    const obj = alloc(p);
    detachIfRequested(p);

    snapshot('before fullscreen', obj);
    requestFS();

    armAndWait('D: observe order array in snapshot. Após blur: teardown=' + p.teardown);
    window.__afterTrigger = function(){
      // Determine first occurrence index
      const firstBlur = order.findIndex(x => x.indexOf('blur') === 0);
      const firstVis  = order.findIndex(x => x.indexOf('visibilitychange') === 0);
      send('[D] firstBlurIndex=' + firstBlur + ' firstVisIndex=' + firstVis);
      snapshot('after blur', obj);
      doTeardown(p.teardown);
    };
  };

  window.runE = function(){
    // E: Minimal teardown bisection (suggest running multiple times with different action)
    const p = getParams();
    resetEvents('TEST E');
    send('=== START TEST E (Minimal Teardown Bisection) ===', 'good');

    const obj = alloc(p);
    detachIfRequested(p);

    snapshot('before fullscreen', obj);
    requestFS();

    armAndWait('E: action=' + p.teardown + '. Rode E repetindo e mudando Teardown action.');
    window.__afterTrigger = function(){
      snapshot('after blur', obj);
      doTeardown(p.teardown);
    };
  };

  window.runF = function(){
    // F: Glitch persistence checklist (human observation)
    const p = getParams();
    resetEvents('TEST F');
    send('=== START TEST F (Glitch Persistence Checklist) ===', 'good');

    const obj = alloc(p);
    detachIfRequested(p);

    snapshot('before fullscreen', obj);
    requestFS();

    armAndWait('F: Após blur, faremos teardown simples. Depois, OBSERVE manualmente: menu OPTIONS, textos, ícones, botões.');
    window.__afterTrigger = function(){
      snapshot('after blur', obj);
      send('[F] CHECKLIST: após o teardown, verifique se:');
      send('  1) Menu OPTIONS mudou labels (ex: msg_refresh_vb)?');
      send('  2) Texto fora do menu/ícones/botões do browser alteraram?');
      send('  3) Persistiu após fechar menu?');
      send('  4) Some ao reiniciar browser?');
      doTeardown(p.teardown === 'reload' ? 'dom_small' : p.teardown);
    };
  };

  function runSingle(name, params, fn) {
    send('[RUN] ' + name + ' params=' + JSON.stringify(params));
    const obj = alloc(params);
    detachIfRequested(params);
    fn(obj);
  }
})();
<\/script>
</body>
</html>`;
  }
})();
</script>
</body>
</html>
