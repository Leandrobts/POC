<!DOCTYPE html>
<html>
<head>
    <title>PS4 JSON Logic Probe (Advanced)</title>
    <style>
        body { background: #050505; color: #0f0; font-family: monospace; padding: 20px; font-size: 20px; }
        #console { border: 1px solid #333; padding: 10px; height: 85vh; overflow-y: auto; }
        .log { margin-bottom: 5px; color: #aaa; }
        .vuln { color: #f00; font-weight: bold; background: #200; border-left: 4px solid red; padding-left: 5px; }
        .safe { color: #0f0; font-weight: bold; }
        .info { color: #0ff; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>
    <h3>JSON LOGIC PROBE (FW 12.00)</h3>
    <div id="console">Iniciando sondas lógicas...<br></div>

    <script>
        const con = document.getElementById('console');
        function log(msg, type='log') {
            con.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            con.scrollTop = con.scrollHeight;
        }

        // ================= SONDA 1: Transição de Memória (Map Transition) =================
        async function probe1_MapTransition() {
            log("SONDA 1: Testando Transição de Estrutura (Fast->Slow)...", "info");
            
            let victim = { a: 1, b: 2 };
            let hijacked = false;
            
            // O gatilho
            Object.defineProperty(Object.prototype, 'toJSON', {
                value: function() {
                    if(this === victim) {
                        hijacked = true;
                        // Expandimos o objeto massivamente para forçar o motor a mover ele na memória
                        // De "Fast Properties" (no objeto) para "Dictionary Mode" (hash map externo)
                        for(let i=0; i<2000; i++) {
                            this['prop' + i] = i; 
                        }
                        return "trap";
                    }
                },
                configurable: true
            });

            try {
                JSON.stringify(victim);
            } catch(e) {}

            // Verificação: O objeto sobreviveu à cirurgia?
            if (victim.a === 1 && victim.prop1999 === 1999) {
                log("Seguro: O motor lidou bem com a transição de memória.", "safe");
            } else {
                log("ALERTA: Objeto corrompido após transição!", "vuln");
            }
            delete Object.prototype.toJSON;
        }

        // ================= SONDA 2: Conversão de Array (Int -> Double) =================
        // ESTE É O MAIS CRÍTICO. Se der VULN, temos leitura de memória.
        async function probe2_ArrayConversion() {
            log("SONDA 2: Testando Conversão de Array (Int->Double)...", "info");
            
            // Array de inteiros (SMI - Small Integers)
            let arr = [1, 2, 3, 4]; 
            let val = 0;

            // Armadilha no índice 1
            Object.defineProperty(arr, '1', {
                get: function() {
                    // Convertemos o array inteiro para Doubles (Floats)
                    // Isso muda o armazenamento interno de 4 bytes para 8 bytes
                    arr[0] = 1.5; 
                    arr[2] = 2.5;
                    return 99;
                }
            });

            // O motor lê o índice 0 (Int), entra no índice 1 (Armadilha),
            // converte o array, e depois volta para ler o índice 2.
            // Se o motor ainda acha que é um array de Ints, ele vai ler metade do Float 2.5
            // resultando em um número lixo enorme.
            
            // Simula a leitura sequencial que o JSON faria
            // Usamos um loop forçado para emular o acesso C++
            let res = [];
            try {
                res = arr.map(x => x); // .map é nativo e rápido, vulnerável a isso
            } catch(e) {}

            log(`Resultado da leitura: [${res.join(', ')}]`);

            // Se lermos um número estranho (não 1.5, 99, 2.5), o motor leu lixo
            if (res.some(x => x > 1000 || x < 0)) {
                log("CRÍTICO: Leitura de memória inválida detectada (Confusão Int/Double)!", "vuln");
                log("Este é um vetor de Exploit válido (Addrof/Fakeobj).", "vuln");
            } else {
                log("Seguro: O motor percebeu a mudança de tipo do array.", "safe");
            }
        }

        // ================= SONDA 3: Reentrância Recursiva =================
        async function probe3_Recursion() {
            log("SONDA 3: Testando Recursão de Stack...", "info");
            
            let depth = 0;
            let victim = { a: 1 };

            Object.defineProperty(Object.prototype, 'toJSON', {
                value: function() {
                    depth++;
                    if(depth < 5) {
                        // Chama stringify de novo no mesmo objeto
                        // Isso pode confundir o estado interno de "visitado"
                        return JSON.stringify(this); 
                    }
                    return "deep";
                },
                configurable: true
            });

            try {
                let res = JSON.stringify(victim);
                log(`Retorno: ${res.substring(0, 20)}...`);
                log("Seguro: Recursão tratada sem travar.", "safe");
            } catch(e) {
                log(`Erro (Esperado): ${e.message}`, "safe");
            }
            delete Object.prototype.toJSON;
        }

        // ================= SONDA 4: Prototype Swapping =================
        async function probe4_ProtoSwap() {
            log("SONDA 4: Testando Troca de Protótipo em Voo...", "info");
            
            let protoA = { id: "A", val: 1 };
            let protoB = { id: "B", val: 2, extra: 999 }; // Tamanhos diferentes
            let victim = Object.create(protoA);

            Object.defineProperty(Object.prototype, 'toJSON', {
                value: function() {
                    // Troca o pai do objeto enquanto o filho está sendo lido
                    Object.setPrototypeOf(victim, protoB);
                    return "swapped";
                },
                configurable: true
            });

            JSON.stringify(victim);
            
            // Verifica se a propriedade herdada está correta
            if(victim.extra === 999) {
                log("Seguro: Protótipo atualizado corretamente.", "safe");
            } else {
                log("ALERTA: Cache de protótipo desatualizado!", "vuln");
            }
            delete Object.prototype.toJSON;
        }

        async function run() {
            await new Promise(r=>setTimeout(r, 500));
            await probe1_MapTransition();
            await new Promise(r=>setTimeout(r, 500));
            await probe2_ArrayConversion();
            await new Promise(r=>setTimeout(r, 500));
            await probe3_Recursion();
            await new Promise(r=>setTimeout(r, 500));
            await probe4_ProtoSwap();
            
            log("--- SONDAGEM FINALIZADA ---", "info");
        }

        setTimeout(run, 1000);
    </script>
</body>
</html>
