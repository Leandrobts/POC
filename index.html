<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 PoC v100000 (GC Stress)</title>
</head>
<body>
<h1>v100000: GC AGGRESSION</h1>
<p>Cada teste aloca memória, remove referências e força o GC para tentar acessar memória liberada.</p>
<div id="log" style="border:1px solid #000; height: 300px; overflow: scroll;">Ready...</div>
<hr>

<button onclick="run(g01)">01. EventListener Host GC</button>
<button onclick="run(g02)">02. CustomElement Upgrade GC</button>
<button onclick="run(g03)">03. AttributeNode Owner GC</button>
<button onclick="run(g04)">04. TextNode Split GC</button>
<button onclick="run(g05)">05. ShadowRoot Host Detach GC</button>

<button onclick="run(g06)">06. ArrayBufferView Buffer GC</button>
<button onclick="run(g07)">07. Blob Slice Parent GC</button>
<button onclick="run(g08)">08. File Reader Event GC</button>
<button onclick="run(g09)">09. ImageData Canvas GC</button>
<button onclick="run(g10)">10. TextDecoder Stream GC</button>

<button onclick="run(g11)">11. WeakMap Key Resurrection GC</button>
<button onclick="run(g12)">12. FinalizationRegistry Race</button>
<button onclick="run(g13)">13. Proxy Revoke Target GC</button>
<button onclick="run(g14)">14. RegExp Compile LastIndex GC</button>
<button onclick="run(g15)">15. Promise Resolve Context GC</button>

<button onclick="run(g16)">16. Worker PostMessage Transfer GC</button>
<button onclick="run(g17)">17. MessagePort Entangle GC</button>
<button onclick="run(g18)">18. BroadcastChannel Listener GC</button>
<button onclick="run(g19)">19. Worker Terminate Ref GC</button>
<button onclick="run(g20)">20. Shared ArrayBuffer (Mock) GC</button>

<button onclick="run(g21)">21. FontFace Set Delete GC</button>
<button onclick="run(g22)">22. Canvas Pattern Source GC</button>
<button onclick="run(g23)">23. AudioNode (Mock) Disconnect GC</button>
<button onclick="run(g24)">24. StyleSheet Insert Rule GC</button>
<button onclick="run(g25)">25. Video Track Cue GC</button>

<script>
    const L = document.getElementById('log');
    function log(m) { L.innerHTML += m + "<br>"; L.scrollTop = L.scrollHeight; }
    
    // Função crítica: Tenta forçar o GC alocando e liberando memória rapidamente
    function pressure() {
        const trash = [];
        for(let i=0; i<100; i++) {
            // Aloca blocos de 1MB
            trash.push(new ArrayBuffer(1024 * 1024));
        }
        // Limpa referência para o GC coletar tudo de uma vez
        trash.length = 0; 
    }

    function run(fn) {
        log("GC Test: " + fn.name);
        try { 
            fn(); 
            pressure(); // Força GC imediatamente após a lógica
            setTimeout(pressure, 50); // Força novamente um pouco depois
        } catch(e) { log("Error: " + e.message); }
    }

    // --- DOM & EVENT GC ---
    function g01() {
        let el = document.createElement('div');
        el.id = "target";
        // O handler mantém referência ao ID, mas o elemento é nulificado
        el.addEventListener('click', function() { 
            const x = this.id; 
        });
        el = null; // Drop ref
    }

    function g02() {
        // Tenta coletar um Custom Element durante o upgrade
        class MyEl extends HTMLElement { disconnectedCallback() { this.innerHTML = ""; } }
        customElements.define('my-gc', MyEl);
        let el = new MyEl();
        document.body.appendChild(el);
        el.remove();
        el = null; // Drop ref
    }

    function g03() {
        let d = document.createElement('div');
        let a = document.createAttribute('test');
        d.setAttributeNode(a);
        d = null; // O atributo ainda deve existir? GC pressure testa o ownership
        const val = a.value;
    }

    function g04() {
        let t = document.createTextNode("Splittable");
        let t2 = t.splitText(5);
        t = null; // GC o pai
        t2.data = "Crash"; // Acessa o irmão que dependia do pai?
    }

    function g05() {
        let host = document.createElement('div');
        let root = host.attachShadow({mode:'open'});
        host = null; // GC o host
        root.innerHTML = "<div></div>"; // Acessa a shadow tree órfã
    }

    // --- BINARY GC ---
    function g06() {
        let buf = new ArrayBuffer(1024);
        let view = new Uint8Array(buf);
        buf = null; // GC o buffer
        pressure();
        view[0] = 1; // A view deve manter o buffer vivo. Se falhar, UAF.
    }

    function g07() {
        let b = new Blob(["test"]);
        let s = b.slice(0, 1);
        b = null; // GC o blob original
        pressure();
        const fr = new FileReader();
        fr.readAsText(s);
    }

    function g08() {
        let fr = new FileReader();
        fr.onload = () => { console.log("done"); };
        fr.readAsText(new Blob(["a"]));
        fr = null; // GC o reader enquanto lê
    }

    function g09() {
        let c = document.createElement('canvas');
        let ctx = c.getContext('2d');
        let img = ctx.createImageData(10,10);
        c = null; ctx = null; // GC o canvas
        pressure();
        img.data[0] = 255; // Acessa dados órfãos
    }

    function g10() {
        let enc = new TextEncoder();
        let u = new Uint8Array(100);
        enc.encodeInto("test", u);
        enc = null; // GC encoder
        pressure();
        // Verifica integridade do buffer u
        u[0] = 0; 
    }

    // --- OBJECT LIFECYCLE ---
    function g11() {
        let wm = new WeakMap();
        let k = {id: 1};
        wm.set(k, "val");
        k = null; // Key GC
        pressure();
        // Stress interno do WeakMap ao perder a chave
    }

    function g12() {
        // FinalizationRegistry (Se suportado, ótimo vetor de crash)
        if(window.FinalizationRegistry) {
            let r = new FinalizationRegistry(val => {});
            let t = {};
            r.register(t, "token");
            t = null;
        }
    }

    function g13() {
        let t = {};
        let p = Proxy.revocable(t, {});
        t = null; // GC target
        pressure();
        p.revoke(); // Revoga proxy sem target
    }

    function g14() {
        let re = /a/g;
        let s = "a";
        re.exec(s);
        re.lastIndex = { valueOf: () => { pressure(); return 0; } };
        re.exec(s);
    }

    function g15() {
        let p = Promise.resolve();
        let ref = {x: 1};
        p.then(() => {
            return ref.x;
        });
        ref = null; // GC o objeto referenciado na closure
    }

    // --- WORKER & IPC ---
    function g16() {
        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
        let b = new ArrayBuffer(1024);
        w.postMessage(b, [b]); // Transfere
        b = null; w = null; // GC tudo
    }

    function g17() {
        let mc = new MessageChannel();
        mc.port1.postMessage("test");
        mc = null; // GC o canal com mensagem pendente
    }

    function g18() {
        let bc = new BroadcastChannel("gc_test");
        bc.onmessage = () => {};
        bc = null; // GC com listener ativo
    }

    function g19() {
        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
        w.terminate();
        w = null; // GC objeto worker terminado
    }

    function g20() {
        // Simulação de GC em buffer compartilhado
        let b = new ArrayBuffer(1024);
        let v = new Int32Array(b);
        b = null;
        pressure();
        v[0] = 1;
    }

    // --- MEDIA & STYLE ---
    function g21() {
        let f = new FontFace("X", "url(x)");
        document.fonts.add(f);
        document.fonts.delete(f);
        f = null; // GC a fonte deletada
        pressure();
        document.fonts.load("10px X");
    }

    function g22() {
        let c = document.createElement('canvas');
        let ctx = c.getContext('2d');
        let img = document.createElement('img'); // Empty img
        let p = ctx.createPattern(img, 'repeat'); // Might fail/throw
        img = null; // GC source
        pressure();
        ctx.fillStyle = p; // Use pattern with dead source
    }

    function g23() {
        // WebAudio Mock (AudioContext é complexo, testamos criação básica e GC)
        try {
            let ac = new (window.AudioContext || window.webkitAudioContext)();
            let osc = ac.createOscillator();
            osc.start();
            osc = null; // GC node rodando
            ac.close();
            ac = null; // GC context
        } catch(e) {}
    }

    function g24() {
        let s = document.createElement('style');
        document.head.appendChild(s);
        let sheet = s.sheet;
        s.remove();
        s = null; // GC elemento style
        pressure();
        try { sheet.insertRule("body{color:red}", 0); } catch(e){} // Acessa sheet órfão
    }

    function g25() {
        let v = document.createElement('video');
        let t = v.addTextTrack("subtitles");
        let c = new VTTCue(0, 1, "test");
        t.addCue(c);
        c = null; // GC o cue
        pressure();
        let x = t.cues[0]; // Recupera do track (deve estar vivo ou crashar)
    }
</script>
</body>
</html>
