<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>PS4 12.xx Render Logic Probe</title>
<style>
    body { background: #111; color: #0f0; font-family: monospace; padding: 20px; }
    .log { border: 1px solid #333; height: 200px; overflow-y: auto; margin-bottom: 20px; padding: 10px; }
    /* Oculta elementos de teste para não poluir a tela, mas força renderização */
    .test-area { position: absolute; left: -9999px; top: -9999px; visibility: hidden; }
</style>
</head>
<body>

<h1>PS4 Render Logic Probe (No-JIT Focus)</h1>
<p>Alvos: SVG Filters, MathML & XSLT Transformations.</p>

<button onclick="runSVGStress()">1. TESTE SVG FILTERS (Deep Chain)</button>
<button onclick="runXSLTAttack()">2. TESTE XSLT (XML Transform)</button>
<button onclick="runMathML()">3. TESTE MATHML (Layout Complexo)</button>

<div id="log" class="log">Pronto.</div>
<div id="container" class="test-area"></div>

<script>
const logEl = document.getElementById('log');
const container = document.getElementById('container');

function log(msg) {
    logEl.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
    logEl.scrollTop = logEl.scrollHeight;
}

// === 1. ATAQUE DE FILTROS SVG ===
// Tenta criar uma cadeia de filtros cíclica ou muito profunda que confunda o renderizador
function runSVGStress() {
    log("Iniciando SVG Filter Chain...");
    
    const ns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(ns, "svg");
    svg.setAttribute("width", "500");
    svg.setAttribute("height", "500");

    // Cria um filtro complexo
    const filter = document.createElementNS(ns, "filter");
    filter.setAttribute("id", "evilFilter");

    // Encadeia múltiplos efeitos de iluminação e fusão
    // Isso estressa o cálculo de pixels na CPU/GPU
    let prevResult = "SourceGraphic";
    
    try {
        for(let i=0; i<50; i++) {
            // Effect 1: Specular Lighting (Matemática pesada)
            const feSpec = document.createElementNS(ns, "feSpecularLighting");
            feSpec.setAttribute("in", prevResult);
            feSpec.setAttribute("surfaceScale", "5");
            feSpec.setAttribute("specularConstant", "1");
            feSpec.setAttribute("specularExponent", "20");
            feSpec.setAttribute("result", "spec" + i);
            
            const feSpot = document.createElementNS(ns, "feSpotLight");
            feSpot.setAttribute("x", "-20");
            feSpot.setAttribute("y", "-20");
            feSpot.setAttribute("z", "100");
            feSpec.appendChild(feSpot);
            filter.appendChild(feSpec);

            // Effect 2: Composite (Mistura camadas)
            const feComp = document.createElementNS(ns, "feComposite");
            feComp.setAttribute("in", "spec" + i);
            feComp.setAttribute("in2", "SourceGraphic"); // Tenta referenciar original
            feComp.setAttribute("operator", "arithmetic");
            feComp.setAttribute("k1", "0.5");
            feComp.setAttribute("k2", "0.5");
            feComp.setAttribute("result", "comp" + i);
            filter.appendChild(feComp);
            
            prevResult = "comp" + i;
        }

        svg.appendChild(filter);

        // Aplica o filtro a um retângulo
        const rect = document.createElementNS(ns, "rect");
        rect.setAttribute("width", "100%");
        rect.setAttribute("height", "100%");
        rect.setAttribute("filter", "url(#evilFilter)");
        
        svg.appendChild(rect);
        container.appendChild(svg);
        
        // Força renderização movendo para área visível brevemente
        container.style.position = "static"; 
        container.style.visibility = "visible";
        
        setTimeout(() => {
            log("SVG renderizado. Se não travou, o renderizador é robusto.");
            container.innerHTML = ""; // Limpa
        }, 2000);

    } catch(e) {
        log("Erro no SVG: " + e.message);
    }
}

// === 2. ATAQUE XSLT (XML Transformation) ===
// WebKit tem histórico de bugs ao transformar XMLs maliciosos
function runXSLTAttack() {
    log("Iniciando transformação XSLT...");
    
    const xmlString = `
    <root>
        ${"<item>Data</item>".repeat(500)}
    </root>`;
    
    const xslString = `
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <html>
                <body>
                    <xsl:for-each select="root/item">
                        <div><xsl:value-of select="."/></div>
                        <xsl:call-template name="recursive">
                            <xsl:with-param name="depth" select="10"/>
                        </xsl:call-template>
                    </xsl:for-each>
                </body>
            </html>
        </xsl:template>
        <xsl:template name="recursive">
            <xsl:param name="depth"/>
            <xsl:if test="$depth > 0">
                <span>X</span>
                <xsl:call-template name="recursive">
                    <xsl:with-param name="depth" select="$depth - 1"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:template>
    </xsl:stylesheet>`;

    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
        const xslDoc = parser.parseFromString(xslString, "text/xml");

        if (window.XSLTProcessor) {
            const xsltProcessor = new XSLTProcessor();
            xsltProcessor.importStylesheet(xslDoc);
            
            log("Processando XSLT...");
            const resultDocument = xsltProcessor.transformToFragment(xmlDoc, document);
            container.appendChild(resultDocument);
            
            log("XSLT concluído.");
            setTimeout(() => container.innerHTML = "", 1000);
        } else {
            log("XSLTProcessor não suportado.");
        }
    } catch(e) {
        log("Erro XSLT: " + e.message);
    }
}

// === 3. ATAQUE MATHML (Mathematical Layout) ===
// O motor de layout matemático é complexo e menos auditado que o HTML normal
function runMathML() {
    log("Gerando MathML aninhado...");
    
    const div = document.createElement("div");
    let mathML = "<math xmlns='http://www.w3.org/1998/Math/MathML'><mrow>";
    
    // Cria aninhamento profundo de frações e raízes
    for(let i=0; i<200; i++) {
        mathML += "<mfrac><mi>x</mi><msqrt>";
    }
    for(let i=0; i<200; i++) {
        mathML += "</msqrt></mfrac>";
    }
    mathML += "</mrow></math>";
    
    div.innerHTML = mathML;
    container.appendChild(div);
    
    log("MathML inserido no DOM. Verificando estabilidade...");
    setTimeout(() => {
        container.innerHTML = "";
        log("Limpo.");
    }, 1000);
}
</script>

</body>
</html>
