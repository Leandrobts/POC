<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Direct Crash Tests</title>
</head>
<body>
    <h1>PS4 Direct Crash Tests</h1>
    
    <button onclick="crash01()">01: ArrayBuffer Detach Loop</button>
    <button onclick="crash02()">02: TypedArray Sort Detach</button>
    <button onclick="crash03()">03: Array Shift Overflow</button>
    <button onclick="crash04()">04: Worker Buffer Transfer</button>
    <button onclick="crash05()">05: DOM Node Recursion</button>
    <button onclick="crash06()">06: Canvas Pattern Cycle</button>
    <button onclick="crash07()">07: Prototype Chain Loop</button>
    <button onclick="crash08()">08: String Concat Massive</button>
    <button onclick="crash09()">09: MessagePort Flood</button>
    <button onclick="crash10()">10: Getter Infinite Loop</button>
    <button onclick="crash11()">11: ArrayBuffer View Storm</button>
    <button onclick="crash12()">12: Document Write Recursion</button>
    <button onclick="crash13()">13: Event Listener Bomb</button>
    <button onclick="crash14()">14: MutationObserver Chain</button>
    <button onclick="crash15()">15: Blob Array Massive</button>
    <button onclick="crash16()">16: Range Extract Loop</button>
    <button onclick="crash17()">17: StyleSheet Rule Bomb</button>
    <button onclick="crash18()">18: TreeWalker Deep</button>
    <button onclick="crash19()">19: Promise Chain Deep</button>
    <button onclick="crash20()">20: Proxy Trap Recursion</button>

    <script>
        function crash01() {
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            for (let i = 0; i < 1000; i++) {
                const buffer = new ArrayBuffer(65536);
                const view = new Uint8Array(buffer);
                view.fill(0x41);
                w.postMessage(buffer, [buffer]);
                try { view[0] = 0xFF; } catch(e) {}
            }
        }

        function crash02() {
            const buffer = new ArrayBuffer(1048576);
            const array = new Float64Array(buffer);
            for (let i = 0; i < array.length; i++) array[i] = Math.random();
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            array.sort((a, b) => {
                w.postMessage(buffer, [buffer]);
                return a - b;
            });
        }

        function crash03() {
            const arrays = [];
            for (let i = 0; i < 100; i++) {
                const arr = new Array(10000);
                for (let j = 0; j < arr.length; j++) arr[j] = {data: new ArrayBuffer(1024)};
                arrays.push(arr);
            }
            for (let round = 0; round < 1000; round++) {
                for (let i = 0; i < arrays.length; i++) {
                    arrays[i].shift();
                    arrays[i].push({data: new ArrayBuffer(1024)});
                }
            }
        }

        function crash04() {
            const code = `onmessage=e=>{postMessage(e.data);}`;
            for (let i = 0; i < 50; i++) {
                const w = new Worker(URL.createObjectURL(new Blob([code], {type:"text/javascript"})));
                for (let j = 0; j < 100; j++) {
                    const buf = new ArrayBuffer(32768);
                    w.postMessage(buf, [buf]);
                }
            }
        }

        function crash05() {
            function deepTree(parent, depth) {
                if (depth > 100) return;
                for (let i = 0; i < 10; i++) {
                    const child = document.createElement('div');
                    parent.appendChild(child);
                    deepTree(child, depth + 1);
                }
            }
            const root = document.createElement('div');
            document.body.appendChild(root);
            deepTree(root, 0);
            document.body.removeChild(root);
            deepTree(root, 0);
        }

        function crash06() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            const pattern = ctx.createPattern(canvas, 'repeat');
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, 2048, 2048);
                canvas.width = 1024;
                canvas.width = 2048;
            }
        }

        function crash07() {
            const objs = [];
            for (let i = 0; i < 100; i++) {
                const obj = {id: i};
                objs.push(obj);
                if (i > 0) Object.setPrototypeOf(obj, objs[i - 1]);
            }
            Object.setPrototypeOf(objs[0], objs[99]);
            try {
                for (let i = 0; i < 1000; i++) {
                    const val = objs[0].nonexistent;
                }
            } catch(e) {}
        }

        function crash08() {
            let str = 'A'.repeat(100000);
            for (let i = 0; i < 100; i++) {
                str = str + str;
                if (str.length > 10000000) break;
            }
        }

        function crash09() {
            const channels = [];
            for (let i = 0; i < 1000; i++) {
                const mc = new MessageChannel();
                channels.push(mc);
                mc.port1.onmessage = e => mc.port1.postMessage(e.data);
                mc.port1.start();
                mc.port2.postMessage(new ArrayBuffer(4096));
            }
        }

        function crash10() {
            const obj = {};
            Object.defineProperty(obj, 'x', {
                get: function() {
                    return obj.x;
                }
            });
            try { const val = obj.x; } catch(e) {}
        }

        function crash11() {
            const buffer = new ArrayBuffer(1048576);
            const views = [];
            for (let i = 0; i < 1000; i++) {
                views.push(new Uint8Array(buffer));
                views.push(new Uint16Array(buffer));
                views.push(new Uint32Array(buffer));
                views.push(new Float32Array(buffer));
                views.push(new Float64Array(buffer));
            }
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            w.postMessage(buffer, [buffer]);
            for (let i = 0; i < views.length; i++) {
                try { views[i][0] = 0xFF; } catch(e) {}
            }
        }

        function crash12() {
            const iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            const doc = iframe.contentDocument;
            function recurse(depth) {
                if (depth > 50) return;
                doc.write('<div>');
                recurse(depth + 1);
                doc.write('</div>');
            }
            doc.open();
            recurse(0);
            doc.close();
        }

        function crash13() {
            const target = document.createElement('div');
            document.body.appendChild(target);
            for (let i = 0; i < 10000; i++) {
                target.addEventListener('click', function() {
                    target.dispatchEvent(new Event('click'));
                });
            }
            target.dispatchEvent(new Event('click'));
        }

        function crash14() {
            const target = document.createElement('div');
            document.body.appendChild(target);
            const observer = new MutationObserver((mutations) => {
                target.appendChild(document.createElement('span'));
            });
            observer.observe(target, {childList: true});
            target.appendChild(document.createElement('span'));
        }

        function crash15() {
            const blobs = [];
            for (let i = 0; i < 10000; i++) {
                const data = new Uint8Array(65536);
                data.fill(0x41);
                blobs.push(new Blob([data.buffer]));
            }
        }

        function crash16() {
            const container = document.createElement('div');
            for (let i = 0; i < 1000; i++) {
                const span = document.createElement('span');
                span.textContent = 'Text ' + i;
                container.appendChild(span);
            }
            document.body.appendChild(container);
            const range = document.createRange();
            for (let i = 0; i < 100; i++) {
                range.selectNodeContents(container);
                const fragment = range.extractContents();
                container.appendChild(fragment);
            }
        }

        function crash17() {
            const style = document.createElement('style');
            document.head.appendChild(style);
            for (let i = 0; i < 10000; i++) {
                style.sheet.insertRule('.class' + i + ' { color: red; }', 0);
            }
        }

        function crash18() {
            const container = document.createElement('div');
            function deepNest(parent, depth) {
                if (depth > 1000) return;
                const child = document.createElement('span');
                parent.appendChild(child);
                deepNest(child, depth + 1);
            }
            deepNest(container, 0);
            document.body.appendChild(container);
            const walker = document.createTreeWalker(container, NodeFilter.SHOW_ALL);
            for (let i = 0; i < 10000; i++) {
                walker.nextNode();
            }
        }

        function crash19() {
            let promise = Promise.resolve(0);
            for (let i = 0; i < 100000; i++) {
                promise = promise.then(x => x + 1);
            }
        }

        function crash20() {
            const handler = {
                get: function(target, prop) {
                    return new Proxy({}, handler);
                }
            };
            const proxy = new Proxy({}, handler);
            try {
                for (let i = 0; i < 1000; i++) {
                    const val = proxy.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p;
                }
            } catch(e) {}
        }
    </script>
</body>
</html>
