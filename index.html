<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 ELF Extractor v3.0 (ROP & Dynamic Analysis)</title>
    <style>
        body { background: #050505; color: #00ff00; font-family: 'Consolas', monospace; padding: 20px; font-size: 12px; }
        h1 { border-bottom: 2px solid #00ff00; padding-bottom: 5px; color: #fff; }
        .zone { 
            border: 2px dashed #333; padding: 40px; text-align: center; background: #0a0a0a; 
            cursor: pointer; margin-bottom: 20px; transition: 0.3s;
        }
        .zone:hover { border-color: #00ff00; background: #111; }
        #log { 
            height: 400px; overflow-y: auto; border: 1px solid #222; padding: 10px; 
            background: #000; white-space: pre-wrap; color: #ccc; margin-bottom: 10px;
        }
        .bar-container { height: 20px; background: #222; margin-bottom: 5px; }
        .bar { height: 100%; background: #00ff00; width: 0%; }
        button { 
            width: 100%; padding: 15px; background: #002200; color: #0f0; border: 1px solid #0f0; 
            font-weight: bold; cursor: pointer; 
        }
        button:hover { background: #0f0; color: #000; }
        .tag { display: inline-block; padding: 2px 5px; border-radius: 3px; background: #333; margin-right: 5px; font-size: 10px; }
        .tag.rop { background: #500; color: #fff; }
    </style>
</head>
<body>

<h1>ELF EXTRACTOR v3.0: THE ROP HUNTER</h1>
<p>Arraste <strong>libSceNKWebKit.sprx</strong> e <strong>libkernel.sprx</strong>. Esta ferramenta varre o código de máquina.</p>

<input type="file" id="fInput" multiple style="display:none" onchange="start(this.files)">
<div class="zone" onclick="document.getElementById('fInput').click()">
    [ CARREGAR BINÁRIOS ]
</div>

<div id="status">Aguardando...</div>
<div class="bar-container"><div class="bar" id="bar"></div></div>
<div id="log">Logs de sistema...</div>
<button id="dlBtn" style="display:none" onclick="download()">BAIXAR RELATÓRIO JSON (COM GADGETS)</button>

<script>
    const LOG = document.getElementById('log');
    const BAR = document.getElementById('bar');
    const STAT = document.getElementById('status');
    const DL = document.getElementById('dlBtn');
    
    let REPORT = { meta: { version: "3.0", target: "ROP/Gadgets" }, binaries: [] };

    // Assinaturas de Gadgets Críticos (x64)
    // Procuramos o opcode RET (0xC3) e olhamos para trás
    const GADGET_SIGS = {
        "pop rdi; ret": [0x5F, 0xC3],
        "pop rsi; ret": [0x5E, 0xC3],
        "pop rdx; ret": [0x5A, 0xC3],
        "pop rcx; ret": [0x59, 0xC3],
        "pop rax; ret": [0x58, 0xC3], // Útil para syscall number
        "pop rsp; ret": [0x5C, 0xC3], // Stack Pivot (Muito importante)
        "mov [rdi], rsi; ret": [0x48, 0x89, 0x37, 0xC3] // Write Primitive
    };

    function log(msg) { LOG.innerText += `\n> ${msg}`; LOG.scrollTop = LOG.scrollHeight; }
    
    function bigIntToHex(bi) { return "0x" + bi.toString(16); }

    async function start(files) {
        if(!files.length) return;
        REPORT.binaries = [];
        DL.style.display = "none";
        
        for(let i=0; i<files.length; i++) {
            STAT.innerText = `Analisando ${files[i].name} (${i+1}/${files.length})...`;
            try {
                const data = await parseBinary(files[i]);
                REPORT.binaries.push(data);
            } catch(e) {
                log(`ERRO em ${files[i].name}: ${e.message}`);
            }
        }
        
        STAT.innerText = "Concluído.";
        BAR.style.width = "100%";
        log("Análise finalizada. Baixe o JSON.");
        DL.style.display = "block";
    }

    function readBlock(file, offset, size) {
        return new Promise((res, rej) => {
            const r = new FileReader();
            r.onload = e => res(e.target.result);
            r.onerror = rej;
            r.readAsArrayBuffer(file.slice(offset, offset+size));
        });
    }

    async function parseBinary(file) {
        log(`Abrindo ${file.name}...`);
        const headBuf = await readBlock(file, 0, 64);
        const headView = new DataView(headBuf);
        
        if(headView.getUint32(0) !== 0x7F454C46) throw new Error("Não é ELF.");
        
        const endian = headView.getUint8(5) === 1;
        const e_phoff = Number(headView.getBigUint64(32, endian));
        const e_phnum = headView.getUint16(56, endian);
        const e_shoff = Number(headView.getBigUint64(40, endian));
        const e_shnum = headView.getUint16(60, endian);

        let binData = {
            filename: file.name,
            segments: [],
            dynamic_libs: [],
            gadgets: [],
            exports_preview: []
        };

        // 1. Ler Segmentos (Procurar TEXT/EXECUTABLE)
        const phSize = e_phnum * 56;
        const phBuf = await readBlock(file, e_phoff, phSize);
        const phView = new DataView(phBuf);
        
        let textSegment = null;

        for(let i=0; i<e_phnum; i++) {
            const off = i * 56;
            const p_type = phView.getUint32(off, endian);
            const p_flags = phView.getUint32(off + 4, endian);
            const p_offset = Number(phView.getBigUint64(off + 8, endian));
            const p_vaddr = Number(phView.getBigUint64(off + 16, endian));
            const p_filesz = Number(phView.getBigUint64(off + 32, endian));
            
            binData.segments.push({ type: p_type, flags: p_flags, vaddr: bigIntToHex(p_vaddr), size: p_filesz });

            // Flags: 1=X, 2=W, 4=R. WebKit code usually R+X (5)
            if(p_type === 1 && (p_flags & 1)) {
                if(p_filesz > 10000) { // Assume o maior segmento executável é o código principal
                    textSegment = { offset: p_offset, size: p_filesz, vaddr: p_vaddr };
                }
            }
            
            // PT_DYNAMIC (2)
            if(p_type === 2) {
                await parseDynamicSection(file, p_offset, p_filesz, endian, binData);
            }
        }

        // 2. ROP Gadget Scan (Scanner de Assinaturas)
        if(textSegment) {
            log(`  Iniciando varredura ROP em ${bigIntToHex(textSegment.vaddr)} (${(textSegment.size/1024/1024).toFixed(2)} MB)...`);
            await scanForGadgets(file, textSegment, binData);
        } else {
            log("  [!] Segmento de texto não encontrado ou ilegível.");
        }
        
        // 3. Exports Preview (Tentativa de ler tabela de símbolos se existir)
        // (Simplificado: Seção anterior v2 já cobria isso, aqui focamos em código)

        return binData;
    }

    async function parseDynamicSection(file, offset, size, endian, binData) {
        log("  Lendo dependências dinâmicas...");
        const buf = await readBlock(file, offset, size);
        const view = new DataView(buf);
        const entries = size / 16;
        
        // Precisamos da string table para ler os nomes das libs. 
        // Em um parser simples, apenas pegamos os offsets por enquanto.
        // DT_NEEDED = 1
        for(let i=0; i<entries; i++) {
            const tag = Number(view.getBigUint64(i*16, endian));
            const val = Number(view.getBigUint64(i*16 + 8, endian));
            
            if(tag === 1) { // DT_NEEDED
                // O valor é um offset na String Table. Sem ler a strtab, guardamos o ID.
                binData.dynamic_libs.push({ str_offset: val }); 
            }
        }
    }

    async function scanForGadgets(file, seg, binData) {
        const CHUNK = 1024 * 1024; // 1MB chunks
        let foundCount = 0;
        
        for(let pos = 0; pos < seg.size; pos += CHUNK) {
            const size = Math.min(CHUNK, seg.size - pos);
            const buf = await readBlock(file, seg.offset + pos, size);
            const u8 = new Uint8Array(buf);
            
            // Varredura linear por bytes 0xC3 (RET)
            for(let i = 0; i < u8.length; i++) {
                if(u8[i] === 0xC3) {
                    // Checa assinaturas para trás
                    for(let [name, bytes] of Object.entries(GADGET_SIGS)) {
                        let match = true;
                        // bytes ex: [0x5F, 0xC3]. u8[i] is 0xC3. Check u8[i-1] == 0x5F
                        if (i - (bytes.length - 1) < 0) continue; // Boundary check chunk

                        for(let k=0; k < bytes.length - 1; k++) {
                            // Compara bytes anteriores ao RET
                            // A assinatura é [OP, RET]. bytes[0] deve casar com u8[i-1]
                            if(u8[i - (bytes.length - 1) + k] !== bytes[k]) {
                                match = false;
                                break;
                            }
                        }
                        
                        if(match) {
                            // Gadget encontrado!
                            const fileOffset = seg.offset + pos + i - (bytes.length - 1);
                            const vaddr = seg.vaddr + pos + i - (bytes.length - 1);
                            
                            // Evita duplicatas excessivas, guarda apenas os primeiros 5 de cada tipo
                            const existing = binData.gadgets.filter(g => g.name === name);
                            if(existing.length < 5) {
                                binData.gadgets.push({
                                    name: name,
                                    offset: bigIntToHex(fileOffset),
                                    vaddr: bigIntToHex(vaddr)
                                });
                                foundCount++;
                            }
                        }
                    }
                }
            }
            
            // Update UI
            BAR.style.width = `${((pos / seg.size) * 100)}%`;
            if(pos % (CHUNK * 5) === 0) await new Promise(r => setTimeout(r, 0)); // Yield
        }
        log(`  > ${foundCount} Gadgets críticos encontrados.`);
    }

    function download() {
        const blob = new Blob([JSON.stringify(REPORT, null, 2)], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "ps4_rop_analysis.json";
        document.body.appendChild(a);
        a.click();
    }

</script>
</body>
</html>
