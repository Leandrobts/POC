<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Getter Exploitation</title>
</head>
<body>
<h2>PS4 12.00 - Getter Side-Effect Tests</h2>
<p><b>Testing if getters can trigger during critical operations</b></p>
<hr>

<button onclick="testArrayOperations()">Test 1: Array Operations</button>
<button onclick="testTypeCoercion()">Test 2: Type Coercion</button>
<button onclick="testComparison()">Test 3: Comparison Ops</button>
<button onclick="testJSONParse()">Test 4: JSON.parse()</button>
<button onclick="logEl.value = ''">Clear</button>

<br><br>
<textarea id="log" rows="350" cols="1200"></textarea>

<script>
const logEl = document.getElementById("log");

function log(m){ 
  logEl.value += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// Setup pollution first
async function setupPollution() {
  log("Setting up pollution via UAF race...\n");
  
  let raceTriggered = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40 && !raceTriggered) {
      raceTriggered = true;
      log(">> Race triggered, injecting pollution...\n");
      return true;
    }
  });
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  return raceTriggered;
}

// ============================================================
// TEST 1: Array Operations with Getter Side-Effects
// ============================================================
async function testArrayOperations() {
  logEl.value = "";
  log("================================================================");
  log("TEST 1: ARRAY OPERATIONS WITH GETTER SIDE-EFFECTS");
  log("================================================================\n");
  
  // Trigger pollution first
  const polluted = await setupPollution();
  
  if(!polluted) {
    log("Setting up manual pollution for testing...\n");
  }
  
  log("[1.1] Installing length getter with side-effects");
  
  let lengthGetterCalled = 0;
  let victimArray = null;
  
  Object.defineProperty(Object.prototype, 'length', {
    get: function() {
      lengthGetterCalled++;
      
      log("  >> length getter called #" + lengthGetterCalled);
      log("     Context: " + this.constructor.name);
      
      // Side effect: modify victim array if it exists
      if(victimArray && this !== victimArray) {
        log("     >> Side effect: modifying victim array!");
        victimArray.push(0xDEADBEEF);
      }
      
      // Return huge value to trigger OOB
      if(Array.isArray(this)) {
        log("     >> Returning 0xFFFFFFFF for Array!");
        return 0xFFFFFFFF;
      }
      
      return undefined;
    },
    configurable: true
  });
  
  log("  Getter installed\n");
  
  log("[1.2] Testing Array.sort()");
  
  victimArray = [3, 1, 4, 1, 5, 9, 2, 6];
  const originalLength = victimArray.length;
  
  log("  Victim array: [" + victimArray + "]");
  log("  Original length: " + originalLength);
  
  try {
    victimArray.sort();
    
    log("  After sort: [" + victimArray + "]");
    log("  New length: " + victimArray.length);
    
    if(victimArray.length > originalLength) {
      log("\n  >> CRITICAL: Array modified during sort!");
      log("  >> Length changed from " + originalLength + " to " + victimArray.length);
    }
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  log("\n[1.3] Testing Array.splice()");
  
  victimArray = [1, 2, 3, 4, 5];
  lengthGetterCalled = 0;
  
  log("  Victim array: [" + victimArray + "]");
  
  try {
    const removed = victimArray.splice(2, 2);
    
    log("  Removed: [" + removed + "]");
    log("  Remaining: [" + victimArray + "]");
    log("  Getter called: " + lengthGetterCalled + " times");
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  log("\n[1.4] Testing Array.concat()");
  
  const arr1 = [1, 2, 3];
  const arr2 = [4, 5, 6];
  lengthGetterCalled = 0;
  
  try {
    const result = arr1.concat(arr2);
    
    log("  Result: [" + result + "]");
    log("  Result length: " + result.length);
    log("  Getter called: " + lengthGetterCalled + " times");
    
    if(result.length > 6) {
      log("\n  >> CRITICAL: Concat created oversized array!");
    }
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  // Cleanup
  delete Object.prototype.length;
  
  log("\n================================================================");
  log("TEST 1 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// TEST 2: Type Coercion with Getter
// ============================================================
async function testTypeCoercion() {
  logEl.value = "";
  log("================================================================");
  log("TEST 2: TYPE COERCION WITH GETTER");
  log("================================================================\n");
  
  log("[2.1] Installing valueOf getter");
  
  let valueOfCalled = 0;
  
  Object.defineProperty(Object.prototype, 'valueOf', {
    get: function() {
      valueOfCalled++;
      
      log("  >> valueOf getter called #" + valueOfCalled);
      log("     Context: " + this.constructor.name);
      
      // Return function that returns controlled value
      return function() {
        log("     >> valueOf() executed, returning 0x41424344");
        return 0x41424344;
      };
    },
    configurable: true
  });
  
  log("  Getter installed\n");
  
  log("[2.2] Testing arithmetic operations");
  
  const obj = { name: "test" };
  
  try {
    const result1 = obj + 10;
    log("  obj + 10 = " + result1);
    
    const result2 = obj * 2;
    log("  obj * 2 = " + result2);
    
    const result3 = +obj;
    log("  +obj = " + result3);
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  log("\n[2.3] Testing comparison operations");
  
  try {
    const cmp1 = obj > 100;
    log("  obj > 100: " + cmp1);
    
    const cmp2 = obj == 0x41424344;
    log("  obj == 0x41424344: " + cmp2);
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  // Cleanup
  delete Object.prototype.valueOf;
  
  log("\n================================================================");
  log("TEST 2 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// TEST 3: Comparison Operations
// ============================================================
async function testComparison() {
  logEl.value = "";
  log("================================================================");
  log("TEST 3: COMPARISON OPERATIONS");
  log("================================================================\n");
  
  log("[3.1] Installing toString getter");
  
  let toStringCalled = 0;
  
  Object.defineProperty(Object.prototype, 'toString', {
    get: function() {
      toStringCalled++;
      
      log("  >> toString getter called #" + toStringCalled);
      log("     Context: " + this.constructor.name);
      
      return function() {
        log("     >> toString() executed");
        return "[POLLUTED]";
      };
    },
    configurable: true
  });
  
  log("  Getter installed\n");
  
  log("[3.2] Testing string coercion");
  
  const obj = { id: 123 };
  
  try {
    const str1 = String(obj);
    log("  String(obj): " + str1);
    
    const str2 = obj + "";
    log("  obj + '': " + str2);
    
    const str3 = `${obj}`;
    log("  Template: " + str3);
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  log("\n[3.3] Testing RegExp.test()");
  
  try {
    const re = /POLLUTED/;
    const result = re.test(obj);
    
    log("  /POLLUTED/.test(obj): " + result);
    
    if(result) {
      log("\n  >> Object coerced to '[POLLUTED]' via getter!");
    }
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  // Cleanup
  delete Object.prototype.toString;
  
  log("\n================================================================");
  log("TEST 3 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// TEST 4: JSON.parse() Exploitation
// ============================================================
async function testJSONParse() {
  logEl.value = "";
  log("================================================================");
  log("TEST 4: JSON.PARSE() EXPLOITATION");
  log("================================================================\n");
  
  log("[4.1] Installing constructor getter");
  
  let constructorCalled = 0;
  
  Object.defineProperty(Object.prototype, 'constructor', {
    get: function() {
      constructorCalled++;
      
      log("  >> constructor getter called #" + constructorCalled);
      
      // Try to return malicious constructor
      return function MaliciousConstructor() {
        log("     >> MALICIOUS CONSTRUCTOR CALLED!");
        this.pwned = true;
        this.code = "INJECTED";
      };
    },
    configurable: true
  });
  
  log("  Getter installed\n");
  
  log("[4.2] Testing JSON.parse()");
  
  const jsonStr = '{"name":"test","value":123}';
  
  try {
    const parsed = JSON.parse(jsonStr);
    
    log("  Parsed object:");
    log("    name: " + parsed.name);
    log("    value: " + parsed.value);
    log("    pwned: " + parsed.pwned);
    log("    code: " + parsed.code);
    log("  Constructor getter called: " + constructorCalled + " times");
    
    if(parsed.pwned) {
      log("\n  >> CRITICAL: Malicious constructor executed!");
    }
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  log("\n[4.3] Testing with __proto__");
  
  constructorCalled = 0;
  
  const jsonWithProto = '{"__proto__":{"injected":true},"name":"test"}';
  
  try {
    const parsed = JSON.parse(jsonWithProto);
    
    log("  Parsed object:");
    log("    name: " + parsed.name);
    log("    injected: " + parsed.injected);
    
    const newObj = {};
    log("  New empty object:");
    log("    injected: " + newObj.injected);
    
    if(newObj.injected) {
      log("\n  >> CRITICAL: Pollution via JSON.parse()!");
    }
    
  } catch(e) {
    log("  Exception: " + e.message);
  }
  
  // Cleanup
  delete Object.prototype.constructor;
  
  log("\n================================================================");
  log("TEST 4 COMPLETE");
  log("================================================================\n");
}

// Initialize
log("PS4 12.00 - Getter Side-Effect Exploitation Tests\n");
log("These tests explore if polluted getters can trigger");
log("during critical operations to cause memory corruption.\n");
log("Click buttons to run individual tests.\n");
</script>
</body>
</html>
