<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Data Processing Fuzzer</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; padding: 20px; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; }
        button { 
            padding: 20px; 
            background: #fff; 
            color: #000; 
            border: 2px solid #333; 
            font-size: 16px; 
            font-weight: bold; 
            cursor: pointer; 
            text-align: left;
        }
        button:active { background: #999; }
        #log { margin-top: 20px; border-top: 1px solid #555; padding-top: 10px; white-space: pre-wrap; }
        canvas { display: none; }
    </style>
</head>
<body>

    <h1>WebCore Data & Raster Fuzzer</h1>
    <p>Target: 1200_libSceNKWebKit.sprx (Legacy Parsers)</p>

    <div class="btn-group">
        <button onclick="testCanvasPath()">TEST 1: Canvas Path Explosion (Memory Panic)</button>
        <button onclick="testWebVTT()">TEST 2: WebVTT Subtitle Parser (C++ Logic Error)</button>
        <button onclick="testRegexBomb()">TEST 3: RegExp Catastrophic Backtracking</button>
        <button onclick="testBlobSlice()">TEST 4: Blob Slice Race (Allocation Fail)</button>
    </div>

    <div id="log">Status: Ready.</div>
    <canvas id="c" width="4000" height="4000"></canvas>
    <video id="v" style="display:none"></video>

    <script>
        function log(msg) { 
            const l = document.getElementById('log');
            l.innerText = `[${new Date().toLocaleTimeString()}] ${msg}\n` + l.innerText;
        }

        // --- TEST 1: Canvas Path Complexity ---
        // Cria um caminho vetorial com milhões de pontos e tenta preenchê-lo.
        // O rasterizador de software (CPU) pode falhar ao alocar o buffer de scanline.
        function testCanvasPath() {
            log("Iniciando Canvas Path Stress...");
            setTimeout(() => {
                try {
                    const canvas = document.getElementById('c');
                    const ctx = canvas.getContext('2d');
                    ctx.beginPath();
                    // Cria uma forma complexa (espiral da morte)
                    for (let i = 0; i < 50000; i++) {
                        ctx.lineTo(Math.cos(i) * i, Math.sin(i) * i);
                    }
                    log("Caminho criado. Renderizando Sombra e Preenchimento...");
                    
                    // Sombras complexas forçam buffers auxiliares
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = "red";
                    ctx.fillStyle = "white";
                    
                    // O Gatilho: Rasterizar 50k pontos com blur em 4k x 4k
                    ctx.fill(); 
                    
                    log("Canvas renderizado (Sem crash).");
                } catch(e) { log("Erro: " + e.message); }
            }, 100);
        }

        // --- TEST 2: WebVTT Parser ---
        // O WebKit tem um parser de legendas escrito em C++.
        // Tentaremos carregar uma legenda com timestamps inválidos/infinitos.
        function testWebVTT() {
            log("Iniciando ataque ao WebVTT Parser...");
            const v = document.getElementById('v');
            
            // Cria um arquivo .vtt malicioso na memória
            // Timestamps enormes e tags aninhadas
            let vttContent = "WEBVTT\n\n";
            for(let i=0; i<1000; i++) {
                vttContent += `${i}:00.000 --> ${i}:00.001\n<v box><c.red>Payload ${i}</c></v>\n\n`;
            }
            
            const blob = new Blob([vttContent], {type: 'text/vtt'});
            const url = URL.createObjectURL(blob);
            
            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.label = 'Attack';
            track.srclang = 'en';
            track.src = url;
            track.default = true;
            
            v.appendChild(track);
            document.body.appendChild(v);
            
            setTimeout(() => {
                log("Carregando track...");
                // Força o parser a ler o arquivo
                track.track.mode = 'showing'; 
                
                // Tenta pular pelo vídeo rapidamente para estressar o sincronizador de texto
                let jump = setInterval(() => {
                    v.currentTime = Math.random() * 1000;
                }, 10);

                setTimeout(() => {
                    clearInterval(jump);
                    log("WebVTT Parser sobreviveu.");
                    document.body.removeChild(v);
                }, 2000);
            }, 500);
        }

        // --- TEST 3: RegExp Catastrophic Backtracking ---
        // Trava a thread principal ou causa Stack Overflow no motor de Regex
        function testRegexBomb() {
            log("Preparando RegExp Bomb...");
            setTimeout(() => {
                try {
                    // Padrão clássico de ReDoS
                    // (x+)+ força o motor a tentar todas as combinações possíveis
                    const regex = /((a+)+)+$/; 
                    const str = "a".repeat(100) + "!"; // O '!' no final causa a falha
                    
                    log("Executando RegExp (Pode congelar por alguns segundos)...");
                    regex.test(str);
                    
                    log("RegExp finalizado (Sem crash).");
                } catch(e) { log("Erro: " + e.message); }
            }, 100);
        }

        // --- TEST 4: Blob Slice Race ---
        // Manipulação de memória bruta. Tenta fatiar blobs gigantes.
        function testBlobSlice() {
            log("Iniciando Blob Allocation & Slicing...");
            try {
                const chunks = [];
                // Cria pressão de memória (512MB)
                const bigData = new Uint8Array(1024 * 1024 * 32).fill(0x41);
                
                let i = 0;
                let interval = setInterval(() => {
                    i++;
                    // Cria blob
                    let b = new Blob([bigData]);
                    // Fatia o blob (referência interna)
                    let slice = b.slice(0, 1024 * 1024 * 16);
                    chunks.push(slice);
                    
                    if(i % 10 === 0) log(`Alocados: ${i} Blobs`);
                    
                    // Tenta ler o slice imediatamente (Race?)
                    let fr = new FileReader();
                    fr.readAsArrayBuffer(slice);
                    
                    if (i > 50) {
                        clearInterval(interval);
                        log("Blob Test finalizado.");
                    }
                }, 50);
            } catch(e) { log("Erro: " + e.message); }
        }

    </script>
</body>
</html>
