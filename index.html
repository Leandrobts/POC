<!DOCTYPE html>
<html>
<head>
    <title>PS4 Mega Fuzzer (Shadow + Selection + SVG)</title>
    <style>
        body { background: #220000; color: #ffaaaa; font-family: monospace; overflow: hidden; }
        /* CSS que força recálculo de layout pesado */
        .gpu-stress { transform: rotate3d(1, 1, 1, 45deg); filter: blur(2px); opacity: 0.9; }
        .flex-chaos { display: flex; flex-direction: row-reverse; justify-content: space-around; }
        #log { background: #000; padding: 5px; border-bottom: 2px solid red; }
    </style>
</head>
<body>
    <div id="log">Carregando Mega Fuzzer...</div>
    <div id="arena"></div>

    <script>
        // ================= CONFIGURAÇÃO EXTREMA =================
        const REPLAY_MODE = false;
        const REPLAY_SEED = 0; 
        const ITERATIONS = 200; // Aumentado para maior cobertura por ciclo
        // ========================================================

        const TAGS = [
            'div', 'span', 'p', 'table', 'button', 'input',
            'svg', 'circle', 'foreignObject', // Vetor SVG
            'details', 'summary', 'marquee',  // Vetor Legacy
            'template', 'slot',               // Vetor Shadow DOM
            'canvas', 'iframe'
        ];

        // PRNG (Mesmo do anterior para manter consistência)
        let currentSeed = 1;
        function seed(s) { currentSeed = s; }
        function rnd() {
            var t = currentSeed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        function pick(arr) { return arr[Math.floor(rnd() * arr.length)]; }
        function coinflip() { return rnd() > 0.5; }

        // Estado
        const logBox = document.getElementById('log');
        let savedCycle = parseInt(localStorage.getItem('mega_cycle') || 1);
        let savedSeed  = parseInt(localStorage.getItem('mega_seed') || 9999);

        if (REPLAY_MODE) savedSeed = REPLAY_SEED;
        else savedSeed = (savedSeed + 137) % 2147483647; // Pulo maior na seed

        if (!REPLAY_MODE) {
            localStorage.setItem('mega_cycle', savedCycle + 1);
            localStorage.setItem('mega_seed', savedSeed);
        }
        logBox.innerHTML = `Ciclo: ${savedCycle} | SEED: ${savedSeed}`;
        seed(savedSeed);

        // --- NOVOS VETORES DE ATAQUE ---

        // 1. Ataque via Selection API (Range)
        // Tenta selecionar um texto e deletar o nó ao mesmo tempo
        function fuzzSelection(el) {
            try {
                if (!el.firstChild) el.textContent = "SELECTION_TEST";
                let range = document.createRange();
                let sel = window.getSelection();
                
                // Seleciona o elemento
                range.selectNodeContents(el);
                sel.removeAllRanges();
                sel.addRange(range);

                // Muta o range aleatoriamente
                if (coinflip()) range.collapse(true);
                if (coinflip()) range.deleteContents(); // Perigo: altera DOM baseada na seleção
            } catch(e) {}
        }

        // 2. Ataque via Shadow DOM
        // Cria árvores de DOM isoladas que confundem o renderizador
        function fuzzShadow(el) {
            try {
                if (el.attachShadow) {
                    // 'closed' mode é mais restritivo e propenso a erros de implementação
                    let shadow = el.attachShadow({mode: coinflip() ? 'open' : 'closed'});
                    let child = document.createElement('div');
                    child.textContent = "SHADOW_REALM";
                    shadow.appendChild(child);
                }
            } catch(e) {}
        }

        // 3. Ataque via CSSOM (CSS Object Model)
        function fuzzStyles(el) {
            try {
                // Propriedades que forçam GPU ou Layout Engine complexo
                el.style.clipPath = `circle(${rnd()*50}%)`;
                el.style.mask = "url(#nonexistent)";
                if (coinflip()) el.className = "gpu-stress flex-chaos";
            } catch(e) {}
        }

        function runMegaFuzz() {
            const arena = document.getElementById('arena');
            let nodes = [];

            try {
                // CRIAÇÃO
                for (let i = 0; i < 30; i++) {
                    let tag = pick(TAGS);
                    let el;
                    if (['svg','circle','foreignObject'].includes(tag)) el = document.createElementNS("http://www.w3.org/2000/svg", tag);
                    else el = document.createElement(tag);

                    // Aplica os novos vetores
                    fuzzStyles(el);
                    if (rnd() > 0.7) fuzzShadow(el);
                    
                    // Aninhamento
                    if (nodes.length > 0 && coinflip()) {
                        try { pick(nodes).appendChild(el); } catch(e) { arena.appendChild(el); }
                    } else {
                        arena.appendChild(el);
                    }
                    nodes.push(el);
                }

                // MUTAÇÃO E ESTRESSE
                for (let i = 0; i < 20; i++) {
                    let target = pick(nodes);
                    
                    // Vetor Selection API
                    if (rnd() > 0.6) fuzzSelection(target);

                    // Vetor Attribute Thrashing
                    if (coinflip()) target.setAttribute("dir", coinflip()?"rtl":"ltr");
                    
                    // Move na árvore (Reparenting é uma causa comum de UAF)
                    if (nodes.length > 2 && coinflip()) {
                        try { 
                            let newParent = pick(nodes);
                            if (newParent !== target && !target.contains(newParent)) {
                                newParent.appendChild(target);
                            }
                        } catch(e){}
                    }
                }

                // DESTRUIÇÃO (Com atraso via setTimeout para tentar Race Conditions)
                // Em vez de deletar agora, agendamos para deletar em 0ms (próximo tick)
                // Isso permite que o código de renderização rode um pouco antes da morte do objeto
                nodes.forEach(node => {
                    if (rnd() > 0.5) {
                        node.remove();
                    } else {
                        setTimeout(() => { try{node.remove()}catch(e){} }, 0);
                    }
                });

                // Limpeza de memória agressiva (ArrayBuffer grande)
                // Aumentado para 4MB para pressionar mais o PS4
                let junk = new ArrayBuffer(1024 * 1024 * 4); 

            } catch (e) {}
            
            // Limpa visualmente a cada rodada do loop interno
            if (rnd() > 0.9) arena.innerHTML = ""; 
        }

        // Loop Principal
        setTimeout(() => {
            // Executa o Mega Fuzz várias vezes antes de recarregar
            for (let j=0; j < ITERATIONS; j++) {
                runMegaFuzz();
            }
            
            if (!REPLAY_MODE) window.location.reload();
            else logBox.innerHTML += "<br>Replay finalizado. Verifique logs.";
        }, 300); // Delay inicial para o navegador respirar

    </script>
</body>
</html>
