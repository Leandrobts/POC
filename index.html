<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v390000: Reload Trap</title>
<style>
    body { background: #100; color: #f55; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f00; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #300; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #500; color: #fff; border: 2px solid #f00;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f00; color: #000; }
    
    #stage { background: #000; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v390000: THE RELOAD TRAP</h1>

<div class="status">
    ESTRATÉGIA: CORROMPER MEMÓRIA + FORÇAR REFRESH (TEARDOWN CRASH)<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA
</div>

<button onclick="reload_trap(r01)">01. Buffer Sieve + Auto Reload</button>

<button onclick="reload_trap(r02)">02. Iframe Destruction Loop</button>

<button onclick="reload_trap(r03)">03. History State + Reload Race</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Armazém global para fragmentação
    const holes = []; 

    // =================================================================
    // EXECUTOR REFRESH
    // =================================================================
    function reload_trap(vectorFunc) {
        Stage.innerHTML = "";
        holes.length = 0;
        
        // 1. Configura o Alvo
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing
        requestAnimationFrame(() => {
            setTimeout(() => {
                // ALERTA
                window.alert("⚠️ RELOAD TRAP ⚠️\n\nAo fechar, vamos forçar o navegador a se limpar (Crash).");

                // A. DETONAÇÃO (Sujar a memória)
                if(target._detonate) target._detonate();

                // B. RECARREGAMENTO FORÇADO (O Gatilho do seu Softlock)
                // Esperamos um pouquinho para garantir que a memória esteja suja
                setTimeout(() => {
                    if(target._reload) {
                        target._reload(); 
                    } else {
                        // Método padrão de refresh forçado (ignora cache)
                        window.location.reload(true);
                    }
                }, 100); // 100ms de atraso
                
            }, 50);
        });
    }

    // =================================================================
    // 01. Buffer Sieve + Auto Reload
    // Recria exatamente o cenário do Teste 1 anterior, mas o script aperta F5 por você.
    // =================================================================
    function r01(stage) {
        const d = document.createElement('div');
        d.innerText = "RAM SIEVE RELOAD";
        stage.appendChild(d);

        // ALOCAÇÃO (Preenche RAM)
        const blocks = [];
        const blockSize = 1024 * 256; // 1MB chunks
        for(let i=0; i<300; i++) {
            blocks.push(new Uint32Array(blockSize).fill(0xAAAAAAAA));
        }

        d._detonate = () => {
            // FRAGMENTAÇÃO (Cria buracos)
            for(let i=0; i<blocks.length; i+=2) {
                blocks[i] = null; // Libera blocos alternados
            }
            
            // PRESSÃO (Tenta realocar nos buracos imediatamente)
            // Isso deixa o Heap num estado "queijo suíço" instável
            for(let i=0; i<50; i++) {
                try {
                    holes.push(new Uint32Array(blockSize + 128).fill(0xBBBBBBBB));
                } catch(e){}
            }
            
            // Tela Preta
            document.body.innerHTML = "RELOADING...";
        };
        
        // Usa o reload padrão do executor
        return d;
    }

    // =================================================================
    // 02. Iframe Destruction Loop
    // Em vez de recarregar a página toda (que pode resetar o script),
    // Recarrega um iframe pesado repetidamente. Isso simula o "Fechar/Abrir Aba".
    // =================================================================
    function r02(stage) {
        const d = document.createElement('div');
        d.innerText = "IFRAME RELOADER";
        stage.appendChild(d);

        const ifr = document.createElement('iframe');
        ifr.style.width = "100%"; ifr.style.height = "500px";
        document.body.appendChild(ifr);

        d._detonate = () => {
            // Nada visual aqui, a ação é no reload
        };

        d._reload = () => {
            // Loop Infinito de Reload do Iframe
            let count = 0;
            function cycle() {
                count++;
                // Navega para about:blank (Teardown)
                ifr.src = "about:blank";
                
                // Força Garbage Collection implícito
                const junk = new Uint8Array(1024*1024*10); // 10MB lixo
                
                setTimeout(() => {
                    // Navega para conteúdo pesado (Alloc)
                    // javascript: cria um novo contexto de execução
                    ifr.src = "javascript:'<script>const a=new Array(1000000).fill(1);<\\/script><h1>LOAD "+count+"</h1>'";
                    
                    if(count < 50) setTimeout(cycle, 50); // Loop rápido (20x por segundo)
                    else window.location.reload(); // Gran Finale: Reload da página pai
                }, 50);
            }
            cycle();
        };
        return d;
    }

    // =================================================================
    // 03. History State + Reload Race
    // Confunde o gerenciador de sessão (Session Restore).
    // =================================================================
    function r03(stage) {
        const d = document.createElement('div');
        d.innerText = "HISTORY RELOAD";
        stage.appendChild(d);

        // Objeto gigante para salvar no histórico
        const heavyState = { data: "A".repeat(1024*1024*5) }; // 5MB string

        d._detonate = () => {
            // Empurra estado pesado para o histórico do navegador
            // O navegador grava isso em disco ou RAM persistente
            try {
                history.replaceState(heavyState, "", "#crash");
            } catch(e) {}
        };

        d._reload = () => {
            // Força o reload imediatamente. 
            // O navegador tenta restaurar o 'heavyState' de 5MB durante o boot
            // enquanto ainda está limpando a memória anterior.
            window.location.reload();
        };
        return d;
    }

</script>
</body>
</html>
