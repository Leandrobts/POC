<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Memory Corruption Tests (51-60)</title>
</head>
<body>
    <h1>PS4 WebKit Memory Corruption Tests (51-60)</h1>
    <h2>Obscure PS4 Browser Vectors - Memory Corruption & Crash</h2>

    <button onclick="test51_NodeIteratorCorrupt()">TEST 51: NodeIterator Corrupt</button>
    <button onclick="test52_CSSValueListUAF()">TEST 52: CSSValueList UAF</button>
    <button onclick="test53_MediaQueryListCorrupt()">TEST 53: MediaQueryList Corrupt</button>
    <button onclick="test54_DocumentFragmentClone()">TEST 54: DocumentFragment Clone</button>
    <button onclick="test55_ComputedStyleCorrupt()">TEST 55: ComputedStyle Corrupt</button>
    <button onclick="test56_ScrollIntoViewRace()">TEST 56: ScrollIntoView Race</button>
    <button onclick="test57_InputValidationUAF()">TEST 57: Input Validation UAF</button>
    <button onclick="test58_NamedNodeMapCorrupt()">TEST 58: NamedNodeMap Corrupt</button>
    <button onclick="test59_CreateElementNSRace()">TEST 59: CreateElementNS Race</button>
    <button onclick="test60_WindowFramesCorrupt()">TEST 60: Window Frames Corrupt</button>

    <h3>Results</h3>
    <div id="log"></div>

    <script>
        function log(msg, status) {
            const el = document.getElementById('log');
            const color = status === 'SUCCESS' ? 'green' : status === 'FAIL' ? 'red' : 'blue';
            el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg} - ${status}</div>`;
        }

        function test51_NodeIteratorCorrupt() {
            log('TEST 51: NodeIterator Corrupt', 'RUNNING');
            try {
                const containers = [];
                const iterators = [];
                const visitedNodes = [];
                
                for (let i = 0; i < 20; i++) {
                    const container = document.createElement('div');
                    container.id = 'iterator_root_' + i;
                    
                    for (let j = 0; j < 40; j++) {
                        const node = document.createElement('span');
                        node.textContent = 'Node_' + i + '_' + j;
                        node.setAttribute('data-index', j.toString());
                        container.appendChild(node);
                        
                        if (j % 3 === 0) {
                            const textNode = document.createTextNode('Text ' + j);
                            node.appendChild(textNode);
                        }
                    }
                    
                    document.body.appendChild(container);
                    containers.push(container);
                    
                    const iterator = document.createNodeIterator(
                        container,
                        NodeFilter.SHOW_ALL,
                        null
                    );
                    iterators.push(iterator);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < iterators.length; i++) {
                        const iterator = iterators[i];
                        const container = containers[i];
                        
                        try {
                            for (let j = 0; j < 10; j++) {
                                const node = iterator.nextNode();
                                if (node) {
                                    visitedNodes.push(node);
                                    if (node.nodeType === Node.ELEMENT_NODE) {
                                        node.setAttribute('visited', round.toString());
                                    }
                                }
                            }
                            
                            const currentRef = iterator.referenceNode;
                            
                            if (round % 3 === 0 && currentRef && currentRef.parentNode) {
                                currentRef.parentNode.removeChild(currentRef);
                                
                                try {
                                    const afterRemoval = iterator.nextNode();
                                    if (afterRemoval === currentRef) {
                                        log('TEST 51: Iterator returned removed reference node', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                            }
                            
                            if (round % 5 === 0) {
                                while (container.firstChild) {
                                    container.removeChild(container.firstChild);
                                }
                                
                                try {
                                    const nodeAfterClear = iterator.nextNode();
                                    if (nodeAfterClear && nodeAfterClear.parentNode === null) {
                                        log('TEST 51: Iterator navigated in cleared tree', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                                
                                for (let j = 0; j < 20; j++) {
                                    const newNode = document.createElement('div');
                                    newNode.textContent = 'New_' + round + '_' + j;
                                    container.appendChild(newNode);
                                }
                            }
                            
                            iterator.referenceNode = container;
                            
                            document.body.removeChild(container);
                            
                            try {
                                const detachedNext = iterator.nextNode();
                                if (detachedNext) {
                                    detachedNext.textContent = 'UAF_TEST';
                                    log('TEST 51: Iterator modified detached node', 'SUCCESS');
                                    return;
                                }
                            } catch(e) {}
                            
                            document.body.appendChild(container);
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 51: No NodeIterator corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 51: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test52_CSSValueListUAF() {
            log('TEST 52: CSSValueList UAF', 'RUNNING');
            try {
                const elements = [];
                const styleLists = [];
                
                for (let i = 0; i < 25; i++) {
                    const elem = document.createElement('div');
                    elem.style.cssText = 'width: 100px; height: 100px; margin: 10px 20px 30px 40px; padding: 5px 10px 15px 20px;';
                    elem.style.border = '2px solid red';
                    elem.style.background = 'linear-gradient(to right, red, blue)';
                    
                    document.body.appendChild(elem);
                    elements.push(elem);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < elements.length; i++) {
                        const elem = elements[i];
                        
                        try {
                            const computed = window.getComputedStyle(elem);
                            
                            const marginTop = computed.marginTop;
                            const marginRight = computed.marginRight;
                            const marginBottom = computed.marginBottom;
                            const marginLeft = computed.marginLeft;
                            
                            styleLists.push({
                                element: elem,
                                marginTop: marginTop,
                                computed: computed
                            });
                            
                            elem.style.margin = '50px';
                            
                            const newComputed = window.getComputedStyle(elem);
                            const newMarginTop = newComputed.marginTop;
                            
                            if (marginTop === newMarginTop && round > 0) {
                                log('TEST 52: Computed style not updated', 'SUCCESS');
                                return;
                            }
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(elem);
                                
                                try {
                                    const afterRemove = window.getComputedStyle(elem);
                                    const width = afterRemove.width;
                                    if (width && width !== 'auto') {
                                        log('TEST 52: getComputedStyle on removed element', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                                
                                document.body.appendChild(elem);
                            }
                            
                            elem.style.cssText = '';
                            
                            try {
                                const afterClear = computed.marginTop;
                                if (afterClear === marginTop) {
                                    log('TEST 52: Old computed style holds cleared values', 'SUCCESS');
                                    return;
                                }
                            } catch(e) {}
                            
                            elem.style.cssText = 'transform: rotate(45deg) scale(2);';
                            const transform = computed.transform;
                            
                        } catch(e) {}
                    }
                    
                    if (styleLists.length > 50) {
                        styleLists.splice(0, 25);
                    }
                }
                
                log('TEST 52: No CSSValueList UAF', 'FAIL');
                
            } catch(e) {
                log('TEST 52: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test53_MediaQueryListCorrupt() {
            log('TEST 53: MediaQueryList Corrupt', 'RUNNING');
            try {
                const queries = [];
                const listeners = [];
                
                const mediaQueries = [
                    '(min-width: 600px)',
                    '(max-width: 800px)',
                    '(orientation: portrait)',
                    '(orientation: landscape)',
                    '(min-height: 400px)',
                    'screen and (color)',
                    'print',
                    '(min-resolution: 2dppx)'
                ];
                
                for (let i = 0; i < mediaQueries.length; i++) {
                    try {
                        const mql = window.matchMedia(mediaQueries[i]);
                        queries.push(mql);
                        
                        const listener = function(e) {
                            if (e.matches) {
                                listeners.push({
                                    query: e.media,
                                    matches: e.matches,
                                    timestamp: Date.now()
                                });
                            }
                        };
                        
                        if (mql.addListener) {
                            mql.addListener(listener);
                        }
                        
                    } catch(e) {}
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < queries.length; i++) {
                        const mql = queries[i];
                        
                        try {
                            const matches = mql.matches;
                            const media = mql.media;
                            
                            if (round % 10 === 0) {
                                const newMql = window.matchMedia(media);
                                
                                if (newMql.matches !== matches) {
                                    if (media === mql.media) {
                                        log('TEST 53: Same query different match state', 'SUCCESS');
                                        return;
                                    }
                                }
                            }
                            
                            const iframe = document.createElement('iframe');
                            iframe.style.width = '500px';
                            iframe.style.height = '300px';
                            document.body.appendChild(iframe);
                            
                            try {
                                const iframeDoc = iframe.contentDocument;
                                const iframeMql = iframe.contentWindow.matchMedia(media);
                                
                                document.body.removeChild(iframe);
                                
                                const afterRemoval = iframeMql.matches;
                                if (typeof afterRemoval === 'boolean') {
                                    log('TEST 53: MediaQueryList accessible after iframe removal', 'SUCCESS');
                                    return;
                                }
                            } catch(e) {}
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 53: No MediaQueryList corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 53: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test54_DocumentFragmentClone() {
            log('TEST 54: DocumentFragment Clone', 'RUNNING');
            try {
                const fragments = [];
                const clones = [];
                
                for (let i = 0; i < 30; i++) {
                    const fragment = document.createDocumentFragment();
                    
                    for (let j = 0; j < 30; j++) {
                        const elem = document.createElement('div');
                        elem.textContent = 'Fragment_' + i + '_' + j;
                        elem.setAttribute('data-frag', i.toString());
                        elem.setAttribute('data-node', j.toString());
                        
                        const child = document.createElement('span');
                        child.textContent = 'Child_' + j;
                        elem.appendChild(child);
                        
                        fragment.appendChild(elem);
                    }
                    
                    fragments.push(fragment);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < fragments.length; i++) {
                        const fragment = fragments[i];
                        
                        try {
                            const clone = fragment.cloneNode(true);
                            clones.push(clone);
                            
                            const container = document.createElement('div');
                            container.appendChild(fragment);
                            document.body.appendChild(container);
                            
                            try {
                                const afterAppend = fragment.childNodes.length;
                                if (afterAppend > 0) {
                                    log('TEST 54: Fragment still has children after append', 'SUCCESS');
                                    return;
                                }
                            } catch(e) {}
                            
                            const cloneChildren = clone.childNodes;
                            for (let j = 0; j < cloneChildren.length; j++) {
                                cloneChildren[j].setAttribute('cloned', round.toString());
                            }
                            
                            container.appendChild(clone);
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(container);
                                
                                for (let j = 0; j < cloneChildren.length; j++) {
                                    try {
                                        cloneChildren[j].textContent = 'Modified';
                                        const text = cloneChildren[j].textContent;
                                        if (text === 'Modified') {
                                            log('TEST 54: Cloned node modified after container removal', 'SUCCESS');
                                            return;
                                        }
                                    } catch(e) {}
                                }
                            }
                            
                            const deepClone = clone.cloneNode(true);
                            
                            while (clone.firstChild) {
                                clone.removeChild(clone.firstChild);
                            }
                            
                            if (deepClone.childNodes.length === 0) {
                                log('TEST 54: Deep clone affected by original removal', 'SUCCESS');
                                return;
                            }
                            
                        } catch(e) {}
                    }
                    
                    if (clones.length > 50) {
                        clones.splice(0, 25);
                    }
                }
                
                log('TEST 54: No DocumentFragment clone corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 54: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test55_ComputedStyleCorrupt() {
            log('TEST 55: ComputedStyle Corrupt', 'RUNNING');
            try {
                const elements = [];
                const computedStyles = [];
                
                for (let i = 0; i < 25; i++) {
                    const elem = document.createElement('div');
                    elem.style.cssText = 'width: 100px; height: 100px; position: absolute; left: 0; top: 0;';
                    elem.style.transform = 'translateX(50px) translateY(50px) rotate(45deg)';
                    elem.style.opacity = '0.5';
                    elem.style.zIndex = i.toString();
                    
                    document.body.appendChild(elem);
                    elements.push(elem);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < elements.length; i++) {
                        const elem = elements[i];
                        
                        try {
                            const computed = window.getComputedStyle(elem);
                            computedStyles.push(computed);
                            
                            const width = computed.width;
                            const transform = computed.transform;
                            const opacity = computed.opacity;
                            const zIndex = computed.zIndex;
                            
                            elem.style.width = (200 + round) + 'px';
                            elem.style.transform = 'scale(2)';
                            
                            const sameComputed = computed.width;
                            if (sameComputed === width) {
                                log('TEST 55: Computed style object not live', 'SUCCESS');
                                return;
                            }
                            
                            const pseudoBefore = window.getComputedStyle(elem, '::before');
                            const pseudoAfter = window.getComputedStyle(elem, '::after');
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(elem);
                                
                                try {
                                    const afterRemove = computed.width;
                                    const pseudoAfterRemove = pseudoBefore.content;
                                    
                                    if (afterRemove || pseudoAfterRemove) {
                                        log('TEST 55: Computed style accessible after removal', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                                
                                document.body.appendChild(elem);
                            }
                            
                            for (let prop in computed) {
                                if (typeof computed[prop] === 'string') {
                                    try {
                                        const val = computed[prop];
                                        if (val.includes('NaN') || val.includes('Infinity')) {
                                            log('TEST 55: Computed style contains invalid value', 'SUCCESS');
                                            return;
                                        }
                                    } catch(e) {}
                                }
                            }
                            
                        } catch(e) {}
                    }
                    
                    if (computedStyles.length > 50) {
                        computedStyles.splice(0, 25);
                    }
                }
                
                log('TEST 55: No ComputedStyle corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 55: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test56_ScrollIntoViewRace() {
            log('TEST 56: ScrollIntoView Race', 'RUNNING');
            try {
                const containers = [];
                const targets = [];
                
                for (let i = 0; i < 20; i++) {
                    const container = document.createElement('div');
                    container.style.height = '2000px';
                    container.style.overflow = 'auto';
                    container.style.position = 'relative';
                    
                    for (let j = 0; j < 50; j++) {
                        const elem = document.createElement('div');
                        elem.style.height = '100px';
                        elem.textContent = 'Element ' + j;
                        elem.id = 'scroll_target_' + i + '_' + j;
                        container.appendChild(elem);
                        
                        if (j === 25) {
                            targets.push(elem);
                        }
                    }
                    
                    document.body.appendChild(container);
                    containers.push(container);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < targets.length; i++) {
                        const target = targets[i];
                        const container = containers[i];
                        
                        try {
                            target.scrollIntoView({behavior: 'auto', block: 'start'});
                            
                            const scrollTop = container.scrollTop;
                            
                            if (round % 3 === 0) {
                                container.removeChild(target);
                                
                                try {
                                    target.scrollIntoView({behavior: 'auto'});
                                    log('TEST 56: scrollIntoView on removed element', 'SUCCESS');
                                    return;
                                } catch(e) {}
                                
                                container.appendChild(target);
                            }
                            
                            target.scrollIntoView({behavior: 'auto', block: 'end'});
                            
                            document.body.removeChild(container);
                            
                            try {
                                target.scrollIntoView({behavior: 'auto', block: 'center'});
                                
                                const newScrollTop = container.scrollTop;
                                if (newScrollTop !== scrollTop) {
                                    log('TEST 56: Scroll position changed in detached container', 'SUCCESS');
                                    return;
                                }
                            } catch(e) {}
                            
                            document.body.appendChild(container);
                            
                            for (let j = 0; j < 5; j++) {
                                target.scrollIntoView({behavior: 'auto'});
                            }
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 56: No ScrollIntoView race', 'FAIL');
                
            } catch(e) {
                log('TEST 56: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test57_InputValidationUAF() {
            log('TEST 57: Input Validation UAF', 'RUNNING');
            try {
                const forms = [];
                const inputs = [];
                
                for (let i = 0; i < 20; i++) {
                    const form = document.createElement('form');
                    form.id = 'validation_form_' + i;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.required = true;
                    input.pattern = '[A-Za-z]{3,}';
                    input.id = 'validation_input_' + i;
                    form.appendChild(input);
                    
                    const textarea = document.createElement('textarea');
                    textarea.required = true;
                    textarea.minLength = 10;
                    form.appendChild(textarea);
                    
                    const select = document.createElement('select');
                    select.required = true;
                    for (let j = 0; j < 5; j++) {
                        const option = document.createElement('option');
                        option.value = 'opt' + j;
                        option.textContent = 'Option ' + j;
                        select.appendChild(option);
                    }
                    form.appendChild(select);
                    
                    document.body.appendChild(form);
                    forms.push(form);
                    inputs.push({input: input, textarea: textarea, select: select});
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < forms.length; i++) {
                        const form = forms[i];
                        const controls = inputs[i];
                        
                        try {
                            const isValid = form.checkValidity();
                            
                            controls.input.value = 'abc';
                            controls.textarea.value = 'Valid text here';
                            controls.select.selectedIndex = 1;
                            
                            const nowValid = form.checkValidity();
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(form);
                                
                                try {
                                    const afterRemove = form.checkValidity();
                                    if (typeof afterRemove === 'boolean') {
                                        log('TEST 57: Form validation works after removal', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                                
                                try {
                                    controls.input.reportValidity();
                                    log('TEST 57: reportValidity on detached input', 'SUCCESS');
                                    return;
                                } catch(e) {}
                                
                                document.body.appendChild(form);
                            }
                            
                            controls.input.setCustomValidity('Custom error');
                            const customValid = controls.input.checkValidity();
                            
                            controls.input.setCustomValidity('');
                            
                            form.reset();
                            
                            const afterReset = form.checkValidity();
                            if (afterReset === nowValid) {
                                log('TEST 57: Form validity unchanged after reset', 'SUCCESS');
                                return;
                            }
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 57: No Input validation UAF', 'FAIL');
                
            } catch(e) {
                log('TEST 57: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test58_NamedNodeMapCorrupt() {
            log('TEST 58: NamedNodeMap Corrupt', 'RUNNING');
            try {
                const elements = [];
                const nodeMaps = [];
                
                for (let i = 0; i < 25; i++) {
                    const elem = document.createElement('div');
                    
                    for (let j = 0; j < 30; j++) {
                        elem.setAttribute('attr' + j, 'value' + j + '_' + i);
                    }
                    
                    document.body.appendChild(elem);
                    elements.push(elem);
                    
                    const attrs = elem.attributes;
                    nodeMaps.push(attrs);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < elements.length; i++) {
                        const elem = elements[i];
                        const attrs = nodeMaps[i];
                        
                        try {
                            const length = attrs.length;
                            const snapshot = [];
                            
                            for (let j = 0; j < attrs.length; j++) {
                                snapshot.push({
                                    name: attrs[j].name,
                                    value: attrs[j].value
                                });
                            }
                            
                            for (let j = 0; j < length; j += 2) {
                                elem.removeAttribute(attrs[j].name);
                            }
                            
                            if (attrs.length === length) {
                                log('TEST 58: NamedNodeMap length not updated', 'SUCCESS');
                                return;
                            }
                            
                            for (let j = 0; j < snapshot.length; j++) {
                                try {
                                    const attr = attrs.getNamedItem(snapshot[j].name);
                                    if (!attr && elem.hasAttribute(snapshot[j].name)) {
                                        log('TEST 58: NamedNodeMap out of sync with element', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                            }
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(elem);
                                
                                try {
                                    const afterRemove = attrs.length;
                                    if (afterRemove > 0) {
                                        const firstAttr = attrs[0];
                                        if (firstAttr) {
                                            firstAttr.value = 'modified';
                                            log('TEST 58: NamedNodeMap modified after element removal', 'SUCCESS');
                                            return;
                                        }
                                    }
                                } catch(e) {}
                                
                                document.body.appendChild(elem);
                            }
                            
                            for (let j = 0; j < 10; j++) {
                                elem.setAttribute('new' + j, 'round' + round);
                            }
                            
                            const item5 = attrs.item(5);
                            elem.removeAttribute(item5.name);
                            
                            const stillItem5 = attrs.item(5);
                            if (stillItem5 && stillItem5.name === item5.name) {
                                log('TEST 58: NamedNodeMap item unchanged after removal', 'SUCCESS');
                                return;
                            }
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 58: No NamedNodeMap corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 58: Exception - ' + e.message, 'SUCCESS');
            }
        }
    </script>
</body>
</html>

        
