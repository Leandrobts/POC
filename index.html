<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 Ultimate ELF Extractor v2.0</title>
    <style>
        body { background-color: #0d0d0d; color: #00ff41; font-family: 'Consolas', monospace; padding: 20px; font-size: 13px; }
        h1 { border-bottom: 2px solid #00ff41; padding-bottom: 10px; margin-bottom: 20px; text-transform: uppercase; }
        .drop-zone {
            border: 2px dashed #333; padding: 50px; text-align: center; margin-bottom: 20px;
            background: #111; cursor: pointer; transition: 0.2s; color: #888;
        }
        .drop-zone:hover { border-color: #00ff41; color: #fff; background: #1a1a1a; }
        #log {
            background: #000; border: 1px solid #333; height: 400px; overflow-y: auto;
            padding: 10px; font-size: 11px; white-space: pre-wrap; color: #ccc; margin-bottom: 10px;
        }
        .progress-container { background: #222; height: 25px; margin-bottom: 10px; border: 1px solid #444; }
        .progress-bar { height: 100%; background: #004400; width: 0%; transition: width 0.1s; }
        button {
            padding: 15px; background: #003300; color: #fff; border: 1px solid #00ff41;
            font-weight: bold; cursor: pointer; width: 100%; font-family: 'Consolas', monospace;
        }
        button:hover { background: #00ff41; color: #000; }
        .stats { display: flex; justify-content: space-between; color: #666; margin-bottom: 5px; }
    </style>
</head>
<body>

    <h1>Ultimate ELF Extractor v2.0 (Deep Analysis)</h1>
    <p>Arraste arquivos <strong>.elf</strong> ou <strong>.sprx</strong> (Descriptografados). Extrai: Sections, Segments, Symbols, Relocations & Full Strings.</p>

    <input type="file" id="fileInput" multiple style="display:none" onchange="processFiles(this.files)">
    <div class="drop-zone" onclick="document.getElementById('fileInput').click()">
        [ CLIQUE OU ARRASTE OS ARQUIVOS AQUI ]
    </div>

    <div class="stats">
        <span id="currentStatus">Aguardando...</span>
        <span id="pct">0%</span>
    </div>
    <div class="progress-container"><div class="progress-bar" id="pBar"></div></div>
    
    <div id="log">Logs do sistema...</div>
    
    <button id="dlBtn" style="display:none" onclick="downloadData()">BAIXAR DADOS JSON</button>

<script>
    const LOG = document.getElementById('log');
    const STATUS = document.getElementById('currentStatus');
    const PBAR = document.getElementById('pBar');
    const PCT = document.getElementById('pct');
    const DLBTN = document.getElementById('dlBtn');

    let FINAL_DATA = {
        meta: { tool: "Ultimate ELF v2", timestamp: new Date().toISOString() },
        binaries: []
    };

    function log(msg) {
        LOG.innerText += `\n> ${msg}`;
        LOG.scrollTop = LOG.scrollHeight;
    }

    // Helper para converter BigInt em string no JSON
    function jsonReplacer(key, value) {
        if (typeof value === 'bigint') {
            return "0x" + value.toString(16);
        }
        return value;
    }

    async function processFiles(files) {
        if(files.length === 0) return;
        FINAL_DATA.binaries = [];
        DLBTN.style.display = 'none';
        LOG.innerText = "Iniciando análise profunda...";

        for(let i=0; i<files.length; i++) {
            STATUS.innerText = `Processando: ${files[i].name} (${i+1}/${files.length})`;
            try {
                const result = await parseELF(files[i]);
                FINAL_DATA.binaries.push(result);
            } catch(e) {
                log(`[ERRO] ${files[i].name}: ${e.message}`);
                console.error(e);
            }
        }

        STATUS.innerText = "Finalizado.";
        PBAR.style.width = "100%";
        PCT.innerText = "100%";
        log("------------------------------------------------");
        log("Extração completa. Clique abaixo para baixar o JSON.");
        DLBTN.style.display = 'block';
    }

    function readFileBlock(file, offset, length) {
        return new Promise((resolve, reject) => {
            const r = new FileReader();
            const blob = file.slice(offset, offset + length);
            r.onload = e => resolve(e.target.result);
            r.onerror = reject;
            r.readAsArrayBuffer(blob);
        });
    }

    async function parseELF(file) {
        log(`Abrindo ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)...`);
        
        // Lê header inicial (64 bytes)
        const headerBuf = await readFileBlock(file, 0, 64);
        const view = new DataView(headerBuf);

        // Magic Check
        if(view.getUint32(0) !== 0x7F454C46) throw new Error("Não é um arquivo ELF válido.");

        const is64 = view.getUint8(4) === 2;
        const endian = view.getUint8(5) === 1; // 1 = Little
        if(!is64) log("  ! Aviso: Arquivo 32-bit (Suporte limitado)");

        // ELF Header Parse
        const e_phoff = Number(view.getBigUint64(32, endian));
        const e_shoff = Number(view.getBigUint64(40, endian));
        const e_phentsize = view.getUint16(54, endian);
        const e_phnum = view.getUint16(56, endian);
        const e_shentsize = view.getUint16(58, endian);
        const e_shnum = view.getUint16(60, endian);
        const e_shstrndx = view.getUint16(62, endian);

        const elfData = {
            filename: file.name,
            header: { entry: "0x"+view.getBigUint64(24, endian).toString(16), type: view.getUint16(16, endian) },
            sections: [],
            segments: [],
            symbols: [],
            relocations: [],
            strings: [] // "strings" command dump
        };

        // --- 1. LER PROGRAM HEADERS (SEGMENTS) ---
        log(`  Lendo ${e_phnum} Segmentos de Memória...`);
        const phBuf = await readFileBlock(file, e_phoff, e_phnum * e_phentsize);
        const phView = new DataView(phBuf);
        for(let i=0; i<e_phnum; i++) {
            const off = i * e_phentsize;
            const p_type = phView.getUint32(off, endian);
            const p_flags = phView.getUint32(off + 4, endian);
            const p_offset = Number(phView.getBigUint64(off + 8, endian));
            const p_vaddr = Number(phView.getBigUint64(off + 16, endian));
            const p_memsz = Number(phView.getBigUint64(off + 40, endian));
            
            elfData.segments.push({ type: p_type, flags: p_flags, vaddr: "0x"+p_vaddr.toString(16), size: p_memsz });
        }

        // --- 2. LER SECTION HEADERS ---
        log(`  Lendo ${e_shnum} Seções...`);
        const shBuf = await readFileBlock(file, e_shoff, e_shnum * e_shentsize);
        const shView = new DataView(shBuf);
        let shStrTabOffset = 0;

        // Primeiro passo: Encontrar .shstrtab
        if(e_shstrndx < e_shnum) {
            const off = e_shstrndx * e_shentsize;
            shStrTabOffset = Number(shView.getBigUint64(off + 24, endian)); // sh_offset
        }

        // Ler tabela de nomes de seção
        // Assumindo tamanho razoável < 1MB para tabela de strings
        let shStrTabBuf = new ArrayBuffer(0);
        if(shStrTabOffset > 0) {
            shStrTabBuf = await readFileBlock(file, shStrTabOffset, 50000); // Ler bloco seguro
        }
        const shStrView = new DataView(shStrTabBuf);

        const sectionsRaw = [];
        
        for(let i=0; i<e_shnum; i++) {
            const off = i * e_shentsize;
            const sh_name = shView.getUint32(off, endian);
            const sh_type = shView.getUint32(off + 4, endian);
            const sh_addr = Number(shView.getBigUint64(off + 16, endian));
            const sh_offset = Number(shView.getBigUint64(off + 24, endian));
            const sh_size = Number(shView.getBigUint64(off + 32, endian));
            const sh_link = shView.getUint32(off + 40, endian);
            const sh_entsize = Number(shView.getBigUint64(off + 56, endian));

            // Resolver nome
            let name = "";
            try {
                let nOff = sh_name;
                while(nOff < shStrTabBuf.byteLength && shStrView.getUint8(nOff) !== 0) {
                    name += String.fromCharCode(shStrView.getUint8(nOff++));
                }
            } catch(e){ name = `sec_${i}`; }

            sectionsRaw.push({ index: i, name, type: sh_type, offset: sh_offset, size: sh_size, link: sh_link, addr: sh_addr, entsize: sh_entsize });
            elfData.sections.push({ index: i, name, type: sh_type, addr: "0x"+sh_addr.toString(16) });
        }

        // --- 3. LER SYMBOLS (.dynsym) ---
        const dynSymSec = sectionsRaw.find(s => s.type === 11); // SHT_DYNSYM
        const dynStrSec = sectionsRaw.find(s => s.name === ".dynstr");
        
        if(dynSymSec && dynStrSec) {
            log(`  Extraindo Símbolos Dinâmicos de ${dynSymSec.name}...`);
            const symBuf = await readFileBlock(file, dynSymSec.offset, dynSymSec.size);
            const strBuf = await readFileBlock(file, dynStrSec.offset, dynStrSec.size);
            const symView = new DataView(symBuf);
            const strView = new DataView(strBuf);
            
            const count = dynSymSec.size / 24; // Elf64_Sym size
            
            // Processamento em blocos para não travar
            const BLOCK = 2000;
            for(let i=0; i<count; i++) {
                if(i % BLOCK === 0) {
                    PBAR.style.width = `${(i/count)*30}%`;
                    await new Promise(r => setTimeout(r, 0));
                }

                const off = i * 24;
                const st_name = symView.getUint32(off, endian);
                const st_value = Number(symView.getBigUint64(off + 8, endian));
                // const st_info = symView.getUint8(off + 4);
                
                if(st_name === 0) continue;

                let name = "";
                let nOff = st_name;
                try {
                    while(nOff < strBuf.byteLength && strView.getUint8(nOff) !== 0) {
                        name += String.fromCharCode(strView.getUint8(nOff++));
                    }
                } catch(e){}

                if(name) {
                    elfData.symbols.push({ name, addr: "0x"+st_value.toString(16), isExport: st_value > 0 });
                }
            }
        }

        // --- 4. LER RELOCATIONS (.rela.dyn / .rela.plt) ---
        // Essencial para saber quais funções externas são chamadas
        const relaSections = sectionsRaw.filter(s => s.type === 4); // SHT_RELA
        log(`  Processando ${relaSections.length} tabelas de Relocação...`);
        
        for(let sec of relaSections) {
            const relBuf = await readFileBlock(file, sec.offset, sec.size);
            const relView = new DataView(relBuf);
            const count = sec.size / 24; // Elf64_Rela size
            
            // Pega tabela de símbolos linkada para resolver nomes
            const linkedSymSec = sectionsRaw[sec.link];
            let linkedSyms = []; 
            // (Simplificação: idealmente carregaríamos a tabela linkada, 
            // aqui vamos assumir que mapeia para a dynsym já carregada se for o caso)

            for(let i=0; i<count; i++) {
                 // Apenas pega os offsets e índices por enquanto para não estourar memória
                 const off = i * 24;
                 const r_offset = Number(relView.getBigUint64(off, endian));
                 const r_info = Number(relView.getBigUint64(off + 8, endian));
                 const r_addend = Number(relView.getBigUint64(off + 16, endian));
                 const r_sym = Math.floor(r_info / 4294967296); // R_SYM (High 32)
                 const r_type = r_info >>> 0; // R_TYPE (Low 32)

                 // Tenta cruzar com os símbolos extraídos anteriormente se possível
                 let symName = (elfData.symbols[r_sym]) ? elfData.symbols[r_sym].name : `idx_${r_sym}`;
                 
                 elfData.relocations.push({ offset: "0x"+r_offset.toString(16), sym: symName, type: r_type });
            }
            await new Promise(r => setTimeout(r, 0));
        }

        // --- 5. FULL STRING DUMP (Scan .rodata/.data) ---
        // Procura por chaves de erro, logs, caminhos
        log("  Executando varredura de strings (Deep Scan)...");
        const rodata = sectionsRaw.find(s => s.name === ".rodata") || sectionsRaw.find(s => s.name === ".data");
        if(rodata) {
            const buf = await readFileBlock(file, rodata.offset, Math.min(rodata.size, 5000000)); // Limit 5MB scan
            const u8 = new Uint8Array(buf);
            let currentStr = "";
            for(let i=0; i<u8.length; i++) {
                const c = u8[i];
                if(c >= 32 && c <= 126) {
                    currentStr += String.fromCharCode(c);
                } else {
                    if(currentStr.length > 5) { // Min length 5
                        elfData.strings.push(currentStr);
                    }
                    currentStr = "";
                }
                
                if(i % 100000 === 0) await new Promise(r => setTimeout(r, 0));
            }
        }

        return elfData;
    }

    function downloadData() {
        const blob = new Blob([JSON.stringify(FINAL_DATA, jsonReplacer, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "ps4_advanced_analysis.json";
        document.body.appendChild(a);
        a.click();
    }
</script>
</body>
</html>
