<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PS4 WebKit – Sanity/Crash Hunting Suite (20 testes – V2)</title>
  <style>
    body { background:#000; color:#0f0; font-family:monospace; margin:12px; }
    h1,h2 { color:#9f9; margin:8px 0; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    button { background:#111; color:#0f0; border:1px solid #0f0; padding:10px 12px; cursor:pointer; }
    button:hover { background:#0f0; color:#000; }
    #log { white-space:pre-wrap; border:1px solid #0f0; padding:10px; height:430px; overflow:auto; background:#060606; }
    .muted { color:#6f6; }
  </style>
</head>
<body>
  <h1>PS4 WebKit – Sanity/Crash Hunting Suite (20 testes – V2)</h1>
  <div class="muted">
    Foco: novos vetores de CE/crash (sem exploração). WebAudio removido. <br>
    Use RESET entre testes. Se travar/CE, anote o último "STEP".
  </div>

  <div class="row" style="margin:10px 0;">
    <button onclick="clearLog()">CLEAR</button>
    <button onclick="resetEnv()">RESET DOM</button>
    <button onclick="stopLoop()">STOP LOOP</button>
    <button onclick="loopAll(50)">LOOP ALL x50</button>
  </div>

  <h2>Testes (T21–T40)</h2>
  <div class="row">
    <button onclick="run(T21)">T21 DOMParser SVG + serialize + attach</button>
    <button onclick="run(T22)">T22 XMLSerializer + live mutation</button>
    <button onclick="run(T23)">T23 SVG textPath + metrics churn</button>
    <button onclick="run(T24)">T24 SVG use/xlink href churn</button>

    <button onclick="run(T25)">T25 CSS Grid/Flex alternância + layout</button>
    <button onclick="run(T26)">T26 Tables: section move + layout</button>
    <button onclick="run(T27)">T27 Scroll container + scrollIntoView removido</button>
    <button onclick="run(T28)">T28 getClientRects() em Range + teardown</button>

    <button onclick="run(T29)">T29 iframe srcdoc churn + postMessage</button>
    <button onclick="run(T30)">T30 document.write em iframe + rebuild</button>

    <button onclick="run(T31)">T31 Media <video> teardown (sem rede)</button>
    <button onclick="run(T32)">T32 TextTrack/cues (se suportado)</button>

    <button onclick="run(T33)">T33 MessageChannel ports churn</button>
    <button onclick="run(T34)">T34 Dedicated Worker churn (se suportado)</button>

    <button onclick="run(T35)">T35 contentEditable + execCommand (se existir)</button>
    <button onclick="run(T36)">T36 selection APIs + caretRangeFromPoint (se houver)</button>

    <button onclick="run(T37)">T37 template clone/adoptNode/importNode churn</button>
    <button onclick="run(T38)">T38 createHTMLDocument + adoptNode + replace</button>

    <button onclick="run(T39)">T39 Canvas2D toDataURL + teardown</button>
    <button onclick="run(T40)">T40 Image decode Blob URL + revoke + reuse</button>
  </div>

  <pre id="log">Status: pronto.</pre>

<script>
/* =========================
   Infra / Logger
========================= */
const logEl = document.getElementById('log');
let keeper = [];
let loopTimer = null;
let loopStop = false;
let lastTestName = "";

function ts(){
  const d = new Date();
  const z = (n)=>String(n).padStart(2,'0');
  return `${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,'0')}`;
}
function log(s){ logEl.textContent += `\n[${ts()}] ${s}`; logEl.scrollTop = logEl.scrollHeight; }
function warn(s){ log(`WARN: ${s}`); }
function step(s){ log(`STEP: ${s}`); }
function ok(s){ log(`OK: ${s}`); }

function clearLog(){ logEl.textContent = "Status: pronto."; }
function stopLoop(){ loopStop = true; if (loopTimer) { clearTimeout(loopTimer); loopTimer=null; } log("LOOP: stop solicitado."); }

function resetEnv(){
  stopLoop();
  keeper = [];
  const nodes = Array.from(document.body.querySelectorAll(".sandbox"));
  for (const n of nodes) n.remove();
  ok("RESET: sandbox limpo.");
}

function run(fn){
  stopLoop();
  keeper = [];
  lastTestName = fn.name;
  log(`\n=== RUN ${fn.name} ===`);
  setTimeout(() => {
    try { fn(); }
    catch(e){ warn(`${fn.name} exception: ${e && e.message ? e.message : e}`); }
    finally { ok(`${fn.name} finished (se não travou).`); }
  }, 0);
}

function loopAll(n){
  stopLoop();
  loopStop = false;
  const tests = [T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40];
  let i = 0, iter = 0;
  log(`\n=== LOOP ALL start: ${n} iterações ===`);
  const tick = () => {
    if (loopStop) { ok("LOOP ALL stopped."); return; }
    if (iter >= n) { ok("LOOP ALL concluído."); return; }
    const fn = tests[i];
    keeper = [];
    lastTestName = fn.name;
    log(`\n--- LOOP iter=${iter+1}/${n} test=${fn.name} ---`);
    try { fn(); } catch(e){ warn(`${fn.name} exception: ${e && e.message ? e.message : e}`); }
    i++;
    if (i >= tests.length) { i=0; iter++; }
    loopTimer = setTimeout(tick, 70); // delay pequeno para timing variability
  };
  loopTimer = setTimeout(tick, 80);
}

function mkSandbox(){
  const d = document.createElement('div');
  d.className = "sandbox";
  d.style.cssText = "position:relative; border:1px dashed #0f0; margin:10px 0; padding:8px;";
  document.body.appendChild(d);
  return d;
}

function forceLayout(el){
  try { void el.offsetHeight; } catch(e){}
  try { void el.getBoundingClientRect(); } catch(e){}
  try { void getComputedStyle(el).width; } catch(e){}
}

function heapPressure(kb){
  const n = Math.max(24, Math.min(600, kb|0));
  const arr = [];
  for (let i=0;i<n;i++) arr.push(new Uint8Array(1024));
  keeper.push(arr);
}

/* =========================================================
   T21–T24: SVG via parser/serializer e constructs
========================================================= */
function T21(){
  const box = mkSandbox();
  step("DOMParser: parse SVG string, importar e anexar; depois mutar atributos e medir");
  if (typeof DOMParser === "undefined") { warn("DOMParser não suportado."); return; }

  const svgText =
    `<svg xmlns="http://www.w3.org/2000/svg" width="320" height="120">
       <path id="p" d="M10 10 C 100 10 200 110 310 110" stroke="lime" fill="none" stroke-width="2"/>
     </svg>`;
  const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
  const svg = document.importNode(doc.documentElement, true);
  svg.style.border = "1px solid #0f0";
  box.appendChild(svg);

  const p = svg.getElementById ? svg.getElementById("p") : svg.querySelector("#p");
  for (let i=0;i<80;i++){
    p.setAttribute("d", `M10 ${10+(i%90)} C 100 10 200 ${110-(i%90)} 310 110`);
    try { p.getTotalLength && p.getTotalLength(); } catch(e){ warn("getTotalLength: "+e.message); }
    if (i % 10 === 0) forceLayout(svg);
  }
  ok("DOMParser SVG churn concluído.");
}

function T22(){
  const box = mkSandbox();
  step("XMLSerializer: serializa SVG live enquanto sofre mutações/teardown");
  if (typeof XMLSerializer === "undefined") { warn("XMLSerializer não suportado."); return; }

  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns, "svg");
  svg.setAttribute("width","320"); svg.setAttribute("height","140");
  svg.style.border = "1px solid #0f0";
  const g = document.createElementNS(ns,"g");
  const t = document.createElementNS(ns,"text");
  t.setAttribute("x","10"); t.setAttribute("y","30"); t.textContent = "serialize";
  g.appendChild(t); svg.appendChild(g); box.appendChild(svg);

  const ser = new XMLSerializer();
  for (let i=0;i<120;i++){
    t.textContent = "serialize #" + i + " " + "X".repeat(i%30);
    if (i === 50){ step("remove <g>"); g.remove(); }
    if (i === 70){ step("re-add <g>"); svg.appendChild(g); }
    try { ser.serializeToString(svg); } catch(e){ warn("serialize: "+e.message); break; }
    if (i % 12 === 0) forceLayout(svg);
  }
  ok("XMLSerializer churn concluído.");
}

function T23(){
  const box = mkSandbox();
  step("SVG textPath: altera path e chama getComputedTextLength()");
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns,'svg');
  svg.setAttribute('width','360'); svg.setAttribute('height','160');
  svg.style.border="1px solid #0f0";

  const defs = document.createElementNS(ns,'defs');
  const path = document.createElementNS(ns,'path');
  path.setAttribute('id','tp');
  defs.appendChild(path);
  svg.appendChild(defs);

  const text = document.createElementNS(ns,'text');
  const tp = document.createElementNS(ns,'textPath');
  tp.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#tp");
  tp.textContent = "TextPath metrics churn " + "Y".repeat(50);
  text.appendChild(tp);
  svg.appendChild(text);
  box.appendChild(svg);

  for (let i=0;i<90;i++){
    path.setAttribute('d', `M10 ${80+(i%40)} Q 180 ${10+(i%80)} 340 ${80+(i%40)}`);
    try { text.getComputedTextLength && text.getComputedTextLength(); } catch(e){ warn("getComputedTextLength: "+e.message); }
    if (i === 45){ step("remove text"); text.remove(); }
    if (i === 60){ step("re-add text"); svg.appendChild(text); }
    if (i % 10 === 0) forceLayout(svg);
  }
  ok("SVG textPath churn concluído.");
}

function T24(){
  const box = mkSandbox();
  step("SVG <use> href churn + remove/re-add referenced node");
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns,'svg');
  svg.setAttribute('width','320'); svg.setAttribute('height','160');
  svg.style.border="1px solid #0f0";

  const defs = document.createElementNS(ns,'defs');
  const sym = document.createElementNS(ns,'g');
  sym.setAttribute('id','sym');
  const r = document.createElementNS(ns,'rect');
  r.setAttribute('x','0'); r.setAttribute('y','0'); r.setAttribute('width','40'); r.setAttribute('height','40');
  r.setAttribute('fill','#0a0');
  sym.appendChild(r);
  defs.appendChild(sym);
  svg.appendChild(defs);

  const use = document.createElementNS(ns,'use');
  use.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#sym");
  svg.appendChild(use);
  box.appendChild(svg);

  for (let i=0;i<120;i++){
    use.setAttribute('x', String(10+(i%250)));
    use.setAttribute('y', String(10+((i*3)%100)));
    if (i === 40){ step("remove referenced symbol"); sym.remove(); }
    if (i === 65){ step("re-add referenced symbol"); defs.appendChild(sym); }
    if (i % 12 === 0) forceLayout(svg);
  }
  ok("<use> href churn concluído.");
}

/* =========================================================
   T25–T28: Layout engines (Grid/Flex/Table/Range rects/scroll)
========================================================= */
function T25(){
  const box = mkSandbox();
  step("Alterna Grid/Flex/Block com muitos filhos e força layout");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  const items = [];
  for (let i=0;i<120;i++){
    const d = document.createElement('div');
    d.textContent = "i"+i;
    d.style.cssText = "border:1px solid #090; margin:1px; padding:2px;";
    host.appendChild(d);
    items.push(d);
  }

  for (let i=0;i<90;i++){
    const mode = i % 3;
    if (mode === 0) host.style.display = "grid", host.style.gridTemplateColumns = "repeat(6, 1fr)";
    if (mode === 1) host.style.display = "flex", host.style.flexWrap = "wrap";
    if (mode === 2) host.style.display = "block";
    if (i % 10 === 0) items[i % items.length].remove(), host.appendChild(items[i % items.length]); // reparent
    forceLayout(host);
  }
  ok("Grid/Flex alternância concluída.");
}

function T26(){
  const box = mkSandbox();
  step("Tabela: move THEAD/TBODY/TFOOT, altera rows e força layout");
  const table = document.createElement('table');
  table.style.cssText = "border:1px solid #0f0; border-collapse:collapse; width:340px;";
  const thead = document.createElement('thead');
  const tbody = document.createElement('tbody');
  const tfoot = document.createElement('tfoot');
  const mkRow = (txt) => {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.textContent = txt;
    td.style.cssText = "border:1px solid #090; padding:2px;";
    tr.appendChild(td);
    return tr;
  };
  thead.appendChild(mkRow("HEAD"));
  for (let i=0;i<60;i++) tbody.appendChild(mkRow("R"+i));
  tfoot.appendChild(mkRow("FOOT"));
  table.appendChild(thead); table.appendChild(tbody); table.appendChild(tfoot);
  box.appendChild(table);

  for (let i=0;i<80;i++){
    if (i === 20){ step("remove THEAD"); thead.remove(); }
    if (i === 35){ step("re-add THEAD"); table.insertBefore(thead, table.firstChild); }
    if (i % 8 === 0){
      const tr = tbody.rows[0];
      if (tr) tbody.appendChild(tr); // rotate rows
    }
    if (i % 12 === 0){
      // rewrite de uma célula
      const idx = (i*3) % tbody.rows.length;
      if (tbody.rows[idx]) tbody.rows[idx].cells[0].innerHTML = "X".repeat((i%30)+1);
    }
    forceLayout(table);
  }
  ok("Table churn concluído.");
}

function T27(){
  const box = mkSandbox();
  step("Scroll container + scrollIntoView em elemento removido/reanexado");
  const sc = document.createElement('div');
  sc.style.cssText = "width:340px;height:140px;overflow:auto;border:1px solid #0f0;";
  const inner = document.createElement('div');
  inner.style.height = "1200px";
  sc.appendChild(inner);
  box.appendChild(sc);

  const target = document.createElement('div');
  target.textContent = "TARGET";
  target.style.cssText = "margin-top:600px;border:1px solid #090;height:40px;";
  inner.appendChild(target);

  for (let i=0;i<70;i++){
    sc.scrollTop = (i*37) % 1100;
    if (i === 25){ step("remove target"); target.remove(); }
    if (i === 40){ step("re-add target"); inner.appendChild(target); }
    try { target.scrollIntoView && target.scrollIntoView(); } catch(e){ warn("scrollIntoView: "+e.message); }
    forceLayout(sc);
  }
  ok("ScrollIntoView churn concluído.");
}

function T28(){
  const box = mkSandbox();
  step("Range.getClientRects em nós que são removidos/reescritos");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  host.innerHTML = "<span id='a'>AAAAA BBBBB CCCCC DDDDD</span> <em id='b'>EEEEE FFFFF GGGGG</em>";
  box.appendChild(host);

  const a = host.querySelector("#a");
  const b = host.querySelector("#b");

  for (let i=0;i<80;i++){
    try{
      const r = document.createRange();
      r.setStart(a.firstChild, Math.min(1+i%5, a.firstChild.length));
      r.setEnd(b.firstChild, Math.min(1+(i%7), b.firstChild.length));
      r.getClientRects && r.getClientRects(); // força caminho de layout/geometry
    } catch(e){
      warn("getClientRects: " + e.message);
      break;
    }
    if (i === 30){ step("rewrite host"); host.innerHTML = "<span id='a'>RESET "+i+"</span><em id='b'>ZZZZZ</em>"; }
    if (i === 55){ step("remove host"); host.remove(); box.appendChild(host); }
    forceLayout(host);
  }
  ok("Range rect churn concluído.");
}

/* =========================================================
   T29–T30: iframes + srcdoc/document.write
========================================================= */


/* =========================================================
   T31–T32: Media (sem rede) + TextTrack (se houver)
========================================================= */
function T31(){
  const box = mkSandbox();
  step("<video> teardown com src vazio/blob e eventos (sem rede)");
  const v = document.createElement('video');
  v.controls = true;
  v.muted = true;
  v.style.cssText = "width:340px;height:160px;border:1px solid #0f0;";
  box.appendChild(v);

  let ev = 0;
  const inc = (name)=>{ ev++; if (ev <= 6) log("event: " + name); };
  ["error","loadedmetadata","canplay","stalled","abort","emptied"].forEach(n => v.addEventListener(n, ()=>inc(n)));

  for (let i=0;i<60;i++){
    // alterna "teardown" sem depender de fetch
    if (i % 2 === 0) v.removeAttribute("src");
    else v.src = ""; // vazio
    try { v.load(); } catch(e){}
    if (i % 10 === 0) { step("remove/readd video"); v.remove(); box.appendChild(v); }
    if (i % 12 === 0) heapPressure(80);
  }
  ok("Media teardown disparado. events=" + ev);
}

function T32(){
  const box = mkSandbox();
  step("TextTrack/cues (se suportado) – add/remove cues rapidamente");
  const v = document.createElement('video');
  v.controls = true;
  v.muted = true;
  v.style.cssText = "width:340px;height:160px;border:1px solid #0f0;";
  box.appendChild(v);

  if (!v.addTextTrack) { warn("TextTrack API não suportada."); return; }
  let track;
  try {
    track = v.addTextTrack("captions", "cap", "en");
    track.mode = "showing";
  } catch(e){
    warn("addTextTrack err: " + e.message);
    return;
  }

  for (let i=0;i<80;i++){
    try{
      if (typeof VTTCue !== "undefined") {
        const c = new VTTCue(i*0.1, i*0.1+0.05, "cue"+i);
        track.addCue(c);
      } else if (typeof TextTrackCue !== "undefined") {
        const c = new TextTrackCue(i*0.1, i*0.1+0.05, "cue"+i);
        track.addCue(c);
      }
      if (i % 5 === 0 && track.cues && track.cues.length) {
        const first = track.cues[0];
        try { track.removeCue(first); } catch(e){}
      }
    } catch(e){
      warn("cue err: " + e.message);
      break;
    }
    if (i % 12 === 0) { step("toggle mode"); track.mode = (track.mode === "disabled") ? "showing" : "disabled"; }
  }
  ok("TextTrack churn concluído (se não travou).");
}

/* =========================================================
   T33–T34: MessageChannel / Worker (moderado)
========================================================= */
function T33(){
  const box = mkSandbox();
  step("MessageChannel ports churn: postMessage/close e GC leve");
  if (typeof MessageChannel === "undefined") { warn("MessageChannel não suportado."); return; }

  let msgs = 0;
  const channels = [];
  for (let i=0;i<120;i++){
    const ch = new MessageChannel();
    ch.port1.onmessage = () => { msgs++; };
    try { ch.port2.postMessage({i, s:"x".repeat(i%50)}); } catch(e){}
    if (i % 3 === 0) { try { ch.port1.close(); ch.port2.close(); } catch(e){} }
    channels.push(ch);
    if (i % 20 === 0) heapPressure(70);
  }
  keeper.push(channels);
  ok("MessageChannel churn concluído. msgs=" + msgs);
}

function T34(){
  const box = mkSandbox();
  step("Dedicated Worker churn (se suportado): cria/termina + mensagens");
  if (typeof Worker === "undefined" || typeof Blob === "undefined") { warn("Worker/Blob não suportado."); return; }

  const code = `
    self.onmessage = (e) => {
      // pequeno churn interno
      let s = 0;
      for (let i=0;i<5000;i++) s += i;
      postMessage({ok:true, n:e.data.n, s});
    };
  `;
  const url = URL.createObjectURL(new Blob([code], {type:"application/javascript"}));
  let replies = 0;

  for (let i=0;i<30;i++){
    try{
      const w = new Worker(url);
      w.onmessage = () => { replies++; };
      w.postMessage({n:i});
      if (i % 2 === 0) w.terminate();
      keeper.push(w);
    } catch(e){
      warn("Worker err: " + e.message);
      break;
    }
  }
  try { URL.revokeObjectURL(url); } catch(e){}
  ok("Worker churn disparado. replies=" + replies);
}

/* =========================================================
   T35–T36: Editing/selection corner cases
========================================================= */
function T35(){
  const box = mkSandbox();
  step("contentEditable + execCommand (se existir) + rewrite/normalize");
  const host = document.createElement('div');
  host.contentEditable = "true";
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px; min-height:70px;";
  host.innerHTML = "Edit <b>bold</b> <i>italic</i> " + "A".repeat(120);
  box.appendChild(host);

  // seleciona algo
  const sel = window.getSelection && window.getSelection();
  if (!sel) { warn("Selection API ausente."); return; }

  for (let i=0;i<50;i++){
    try{
      const r = document.createRange();
      r.setStart(host.firstChild, 0);
      r.setEnd(host.firstChild, Math.min(4+i%10, host.firstChild.length));
      sel.removeAllRanges(); sel.addRange(r);

      if (document.queryCommandSupported && document.queryCommandSupported("bold")) {
        if (i % 5 === 0) document.execCommand("bold", false, null);
      } else if (document.execCommand) {
        // ainda pode existir mesmo sem queryCommandSupported
        if (i % 7 === 0) { try { document.execCommand("insertText", false, "X"); } catch(e){} }
      }

      if (i % 10 === 0) host.innerHTML = "rewrite#" + i + " " + "<span>" + "B".repeat(80) + "</span>";
      if (i % 12 === 0) host.normalize();
      forceLayout(host);
    } catch(e){
      warn("editing err: " + e.message);
      break;
    }
  }
  ok("Editing churn concluído.");
}

function T36(){
  const box = mkSandbox();
  step("Selection + caretRangeFromPoint/caretPositionFromPoint (se houver) com DOM churn");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px; height:120px;";
  host.innerHTML = "<span>" + "C".repeat(400) + "</span>";
  box.appendChild(host);

  const sel = window.getSelection && window.getSelection();
  if (!sel) { warn("Selection API ausente."); return; }

  for (let i=0;i<80;i++){
    try{
      const x = 20 + (i % 100);
      const y = 20 + ((i*3) % 80);
      let range = null;

      if (document.caretRangeFromPoint) {
        range = document.caretRangeFromPoint(x, y);
      } else if (document.caretPositionFromPoint) {
        const pos = document.caretPositionFromPoint(x, y);
        if (pos) {
          range = document.createRange();
          range.setStart(pos.offsetNode, Math.min(pos.offset, (pos.offsetNode && pos.offsetNode.length) ? pos.offsetNode.length : pos.offset));
          range.setEnd(range.startContainer, range.startOffset);
        }
      }

      if (range) { sel.removeAllRanges(); sel.addRange(range); }
      if (i === 30) { step("rewrite host"); host.innerHTML = "<span>rewrite</span>" + "D".repeat(200); }
      if (i === 55) { step("remove/readd host"); host.remove(); box.appendChild(host); }
      forceLayout(host);
    } catch(e){
      warn("caret/selection err: " + e.message);
      break;
    }
  }
  ok("Caret/selection churn concluído.");
}

/* =========================================================
   T37–T38: template/import/adopt + createHTMLDocument
========================================================= */
function T37(){
  const box = mkSandbox();
  step("template clone + adoptNode/importNode + replaceChildren");
  const tpl = document.createElement('template');
  tpl.innerHTML = "<div><span>tpl</span><b>bold</b><i>italic</i></div>";
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  for (let i=0;i<120;i++){
    const frag = tpl.content.cloneNode(true);
    try{
      const node = frag.firstElementChild;
      node.querySelector('span').textContent = "tpl#" + i;
      if (i % 3 === 0) host.replaceChildren(node);
      else host.appendChild(node);

      if (i % 7 === 0) {
        const adopted = document.adoptNode(node.cloneNode(true));
        host.appendChild(adopted);
      }
      if (i % 11 === 0) {
        const imported = document.importNode(node, true);
        host.appendChild(imported);
      }
      if (host.childNodes.length > 25) host.textContent = "reset " + i;
    } catch(e){
      warn("template/adopt/import err: " + e.message);
      break;
    }
    if (i % 10 === 0) forceLayout(host);
  }
  ok("Template/adopt/import churn concluído.");
}

function T38(){
  const box = mkSandbox();
  step("createHTMLDocument + adoptNode into main doc + replace subtree");
  if (!document.implementation || !document.implementation.createHTMLDocument) { warn("createHTMLDocument não suportado."); return; }

  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  for (let i=0;i<50;i++){
    try{
      const d2 = document.implementation.createHTMLDocument("x"+i);
      d2.body.innerHTML = "<div><p>doc2 #" + i + "</p><span>" + "E".repeat(i%80) + "</span></div>";
      const n = d2.body.firstElementChild;
      const adopted = document.adoptNode(n);
      if (i % 2 === 0) host.replaceChildren(adopted);
      else host.appendChild(adopted);
      if (i % 10 === 0) host.innerHTML = "<b>reset</b> " + i;
      forceLayout(host);
    } catch(e){
      warn("createHTMLDocument/adopt err: " + e.message);
      break;
    }
  }
  ok("createHTMLDocument churn concluído.");
}

/* =========================================================
   T39–T40: Canvas toDataURL + Blob URL image decode/revoke
========================================================= */
function T39(){
  const box = mkSandbox();
  step("Canvas2D toDataURL em loop + teardown/recreate");
  const c = document.createElement('canvas');
  c.width = 256; c.height = 128;
  c.style.border = "1px solid #0f0";
  box.appendChild(c);

  for (let i=0;i<60;i++){
    const ctx = c.getContext('2d');
    ctx.fillRect(0,0,c.width,c.height);
    try { c.toDataURL("image/png"); } catch(e){ warn("toDataURL err: "+e.message); break; }
    if (i % 12 === 0) { step("teardown canvas"); c.remove(); box.appendChild(c); }
    if (i % 10 === 0) heapPressure(90);
  }
  ok("Canvas toDataURL churn concluído.");
}

function T40(){
  const box = mkSandbox();
  step("Image decode via Blob URL + revokeObjectURL + reuse element");
  if (typeof Blob === "undefined" || typeof URL === "undefined") { warn("Blob/URL não suportado."); return; }

  // PNG 1x1 verde (bytes)
  const pngBytes = Uint8Array.from(atob(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+J8b0AAAAASUVORK5CYII="
  ), c => c.charCodeAt(0));

  const img = document.createElement('img');
  img.style.cssText = "border:1px solid #0f0; width:32px; height:32px;";
  box.appendChild(img);

  let loads=0, errors=0;
  img.onload = ()=>{ loads++; };
  img.onerror = ()=>{ errors++; };

  for (let i=0;i<120;i++){
    try{
      const blob = new Blob([pngBytes], {type:"image/png"});
      const url = URL.createObjectURL(blob);
      img.src = url;
      if (i % 2 === 0) { try { URL.revokeObjectURL(url); } catch(e){} } // revoke cedo
      if (i % 15 === 0) { step("remove/readd img"); img.remove(); box.appendChild(img); }
    } catch(e){
      warn("BlobURL err: " + e.message);
      break;
    }
    if (i % 20 === 0) heapPressure(80);
  }
  ok(`BlobURL churn disparado. loads=${loads} errors=${errors} (pode continuar assíncrono).`);
}

/* =========================
   Global traps
========================= */
window.addEventListener('error', (e) => warn("window.onerror: " + (e && e.message ? e.message : "error")));
window.addEventListener('unhandledrejection', (e) => warn("unhandledrejection: " + (e && e.reason && e.reason.message ? e.reason.message : e.reason)));
</script>
</body>
</html>
