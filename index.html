<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WASM & Grid Fuzzer</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { 
            background: #111; color: #fff; border: 1px solid #0f0; 
            padding: 20px; width: 100%; margin-bottom: 15px; 
            font-size: 18px; font-weight: bold; cursor: pointer; text-align: left;
        }
        button:hover { background: #333; }
        #log { border: 1px solid #0f0; padding: 10px; margin-top: 20px; min-height: 100px; white-space: pre-wrap; }
        
        /* Área de teste do Grid - Escondida mas ativa */
        #grid-zone {
            display: grid;
            width: 100px; height: 100px;
            overflow: hidden;
            position: absolute; left: -9999px;
        }
    </style>
</head>
<body>

    <h1>COMPUTATIONAL COMPLEXITY ATTACKS</h1>
    <p>Target: WebAssembly LLInt & CSS Grid Solver</p>

    <button onclick="runWASMBomb()">TEST 1: WebAssembly Memory OOB</button>
    <button onclick="runGridExplosion()">TEST 2: CSS Grid Layout Calc Overflow</button>
    <button onclick="runProxyTrap()">TEST 3: Proxy Recursion (Internal Error)</button>

    <div id="grid-zone"></div>
    <div id="log">Status: Pronto.</div>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // --- TESTE 1: WebAssembly Memory OOB ---
        // Tenta alocar e acessar memória WASM de forma agressiva.
        // Se o interpretador LLInt falhar na verificação de limites, CRASH.
        async function runWASMBomb() {
            log("Iniciando WebAssembly Stress...");
            
            if (!window.WebAssembly) {
                log("ERRO: WebAssembly desativado neste firmware.");
                return;
            }

            try {
                // Binário WASM mínimo (Magic Header + Version)
                // Vamos tentar compilar algo que pede memória excessiva
                const wasmCode = new Uint8Array([
                    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // Header
                    0x05, 0x03, 0x01, 0x00, 0x01,                   // Memory Section
                    // Aqui tentaríamos importar ou exportar funções inválidas
                ]);

                // Tenta alocar memória WASM no limite de 32-bit (2GB/4GB)
                // O WebKit no PS4 tem limites rígidos, queremos encontrar o bug na checagem.
                const memory = new WebAssembly.Memory({ initial: 1000, maximum: 32767 }); 
                log("Memória WASM alocada. Tentando crescer...");

                const interval = setInterval(() => {
                    try {
                        memory.grow(100); // Cresce 6.4MB por vez
                    } catch(e) {
                        log("Limite WASM atingido (Seguro): " + e.message);
                        clearInterval(interval);
                    }
                }, 10);

            } catch(e) { log("Erro WASM: " + e.message); }
        }

        // --- TESTE 2: CSS Grid Layout Explosion ---
        // O CSS Grid usa algoritmos matriciais para calcular onde colocar os itens.
        // Vamos criar um grid com 50.000 trilhas e tentar animá-lo.
        function runGridExplosion() {
            log("Iniciando CSS Grid Solver Stress...");
            const el = document.getElementById('grid-zone');
            
            setTimeout(() => {
                try {
                    // 1. Definição Impossível
                    // Cria 50.000 colunas de tamanho variável
                    // O motor precisa resolver uma matriz gigante na CPU
                    el.style.gridTemplateColumns = "repeat(50000, minmax(10px, 1fr))";
                    el.style.gridTemplateRows = "repeat(1000, 1fr)";
                    
                    // 2. Adiciona itens que ocupam espaços conflitantes
                    for(let i=0; i<100; i++) {
                        let div = document.createElement('div');
                        // Span negativo ou gigante tenta quebrar o cálculo de área
                        div.style.gridColumn = `1 / span ${500 + i}`; 
                        div.style.gridRow = `${i} / span 2`;
                        el.appendChild(div);
                    }

                    // 3. O Gatilho: Forçar leitura de layout
                    log("Forçando cálculo da Matriz de Grid...");
                    const forceLayout = el.offsetHeight; 
                    
                    // 4. Modificação Dinâmica (Race Condition no Layout)
                    el.style.gridTemplateColumns = "repeat(10, 1fr)"; // Reduz drasticamente
                    
                    log("Grid recalculado (Sem crash).");
                    el.innerHTML = ""; // Limpa
                } catch(e) { log("Erro: " + e.message); }
            }, 100);
        }

        // --- TESTE 3: Proxy Trap Recursion ---
        // Usa Proxies (interceptadores JS) para fazer o motor engasgar em chamadas internas.
        function runProxyTrap() {
            log("Armando Proxy Trap...");
            
            try {
                const target = {};
                const handler = {
                    get: function(obj, prop) {
                        // Quando o motor tenta ler, nós chamamos o próprio motor
                        // gerando uma recursão na CADEIA DE PROTÓTIPOS, não na pilha JS normal.
                        if (prop === "toString") return function() { return proxy; };
                        return proxy; 
                    }
                };
                
                const proxy = new Proxy(target, handler);
                
                // Gatilho: Tenta converter esse objeto infinito em String
                // O WebKit tenta ser esperto e converter, caindo no loop.
                log("Disparando conversão implícita...");
                const crash = "Value: " + proxy;
                
            } catch(e) { 
                log("Stack Overflow Interno (Seguro): " + e.message); 
            }
        }

    </script>
</body>
</html>
