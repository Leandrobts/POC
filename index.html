<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 ELF/SPRX Ultimate Analyzer</title>
    <style>
        body { background-color: #121212; color: #e0e0e0; font-family: 'Consolas', 'Monaco', monospace; padding: 20px; }
        h2 { color: #00ff9d; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .container { max-width: 1000px; margin: 0 auto; }
        
        #drop-zone {
            border: 2px dashed #333; padding: 40px; text-align: center; margin-bottom: 20px; 
            cursor: pointer; background: #1e1e1e; transition: all 0.3s;
        }
        #drop-zone:hover { border-color: #00ff9d; background: #252525; }
        
        #progress-container { width: 100%; background-color: #333; height: 25px; margin-bottom: 20px; border-radius: 4px; overflow: hidden; }
        #progress-bar { width: 0%; height: 100%; background-color: #00ff9d; transition: width 0.1s; }
        
        textarea {
            width: 100%; height: 500px; background-color: #101010; color: #a5b3ce; 
            border: 1px solid #333; padding: 10px; font-family: monospace; font-size: 12px;
        }
        
        .btn {
            background-color: #00ff9d; color: #000; border: none; padding: 10px 20px; 
            font-weight: bold; cursor: pointer; margin-top: 10px;
        }
        .btn:hover { opacity: 0.8; }
        
        .status { color: #aaa; margin-bottom: 5px; }
        .highlight { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h2>PS4 ELF Binary Analyzer & Gadget Extractor</h2>
    <p>Extrai Seções, Símbolos e Gadgets ROP para JSON. Processamento assíncrono (Anti-Freeze).</p>

    <div id="drop-zone" onclick="document.getElementById('fileInput').click()">
        ARRASTE O ARQUIVO .ELF OU .SPRX AQUI
        <input type="file" id="fileInput" style="display:none">
    </div>

    <div class="status" id="status-text">Aguardando arquivo...</div>
    <div id="progress-container">
        <div id="progress-bar"></div>
    </div>

    <textarea id="output" readonly placeholder="O JSON aparecerá aqui..."></textarea>
    <button class="btn" onclick="copyJSON()">Copiar JSON</button>
</div>

<script>
    // === CONFIGURAÇÃO DE GADGETS ===
    // Assinaturas de bytes para encontrar instruções ROP (x64 Little Endian)
    const ROP_TARGETS = {
        // Stack Control
        "pop_rdi": [0x5F, 0xC3],
        "pop_rsi": [0x5E, 0xC3],
        "pop_rdx": [0x5A, 0xC3],
        "pop_rcx": [0x59, 0xC3],
        "pop_rax": [0x58, 0xC3],
        "pop_r8":  [0x41, 0x58, 0xC3],
        "pop_rsp": [0x5C, 0xC3], // Stack Pivot Simples
        
        // Memory Access (Primitives)
        "mov_ptr_rdi_rax": [0x48, 0x89, 0x07, 0xC3], // Write: mov [rdi], rax
        "mov_rax_ptr_rdi": [0x48, 0x8B, 0x07, 0xC3], // Read: mov rax, [rdi]
        "mov_ptr_rax_rsi": [0x48, 0x89, 0x30, 0xC3], // Write Alt
        
        // JOP & Call
        "jmp_ptr_rsi": [0xFF, 0x26],
        "jmp_ptr_rdi": [0xFF, 0x27],
        "call_ptr_rax": [0xFF, 0x10],
        
        // Misc
        "syscall": [0x0F, 0x05],
        "ret": [0xC3],
        "leave_ret": [0xC9, 0xC3]
    };

    let fileBytes = null;
    let fileSize = 0;
    
    // Objeto final do relatório
    let report = {
        filename: "",
        filesize: 0,
        sections: {},
        symbols: {},
        gadgets: {}
    };

    document.getElementById('fileInput').addEventListener('change', handleFile);
    document.getElementById('drop-zone').addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    document.getElementById('drop-zone').addEventListener('drop', (e) => { e.preventDefault(); handleFile({ target: { files: e.dataTransfer.files } }); });

    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;

        report.filename = file.name;
        report.filesize = file.size;
        
        updateStatus(`Carregando ${file.name}...`);
        
        const reader = new FileReader();
        reader.onload = function(evt) {
            fileBytes = new Uint8Array(evt.target.result);
            fileSize = fileBytes.length;
            startAnalysis();
        };
        reader.readAsArrayBuffer(file);
    }

    function updateStatus(msg) {
        document.getElementById('status-text').innerText = msg;
    }

    function updateProgress(percent) {
        document.getElementById('progress-bar').style.width = percent + "%";
    }

    // --- PARSER LÓGICO ---

    async function startAnalysis() {
        // 1. Validar Header ELF
        if (fileBytes[0] !== 0x7F || fileBytes[1] !== 0x45 || fileBytes[2] !== 0x4C || fileBytes[3] !== 0x46) {
            alert("ERRO: Arquivo não é um ELF válido.");
            return;
        }

        updateStatus("Analisando Cabeçalhos e Seções...");
        await sleep(50);

        // Parse Section Headers
        const e_shoff = Number(read64(0x28)); // Start of section headers
        const e_shentsize = read16(0x3A);     // Size of section header
        const e_shnum = read16(0x3C);         // Number of section headers
        const e_shstrndx = read16(0x3E);      // Section header string table index

        // Encontrar a Tabela de Strings das Seções (.shstrtab)
        const shstrtab_offset = Number(read64(e_shoff + (e_shstrndx * e_shentsize) + 0x18));
        
        let textSection = { offset: 0, size: 0 };
        let dynsymSection = { offset: 0, size: 0, link: 0 };
        let dynstrSection = { offset: 0 };

        // Varre as seções para identificar .text, .dynsym, etc.
        for (let i = 0; i < e_shnum; i++) {
            const sh_offset = e_shoff + (i * e_shentsize);
            const sh_name_idx = read32(sh_offset);
            const sh_type = read32(sh_offset + 0x04);
            const sh_offset_val = Number(read64(sh_offset + 0x18));
            const sh_size = Number(read64(sh_offset + 0x20));
            const sh_link = read32(sh_offset + 0x28);

            // Ler nome da seção
            const name = readString(shstrtab_offset + sh_name_idx);
            
            // Salva no relatório
            report.sections[name] = { 
                offset: "0x" + sh_offset_val.toString(16), 
                size: "0x" + sh_size.toString(16),
                raw_offset: sh_offset_val,
                raw_size: sh_size
            };

            if (name === ".text") {
                textSection = { offset: sh_offset_val, size: sh_size };
            } else if (sh_type === 11) { // SHT_DYNSYM
                dynsymSection = { offset: sh_offset_val, size: sh_size, link: sh_link };
            } else if (i === dynsymSection.link && dynsymSection.link !== 0) {
                // A tabela de string associada aos símbolos
                dynstrSection = { offset: sh_offset_val };
            }
        }

        // Se achou símbolos, extrair (Opcional, mas útil)
        if (dynsymSection.offset > 0) {
            updateStatus("Extraindo Símbolos (Funções)...");
            await sleep(50);
            extractSymbols(dynsymSection, dynstrSection);
        }

        // Inicia Scanner de Gadgets (Chunked)
        if (textSection.size > 0) {
            updateStatus("Iniciando Scanner de Gadgets ROP...");
            scanGadgets(textSection);
        } else {
            alert("Aviso: Seção .text não encontrada. Escaneando arquivo inteiro (Lento).");
            scanGadgets({ offset: 0, size: fileSize });
        }
    }

    function extractSymbols(symSec, strSec) {
        // Cada entrada de símbolo tem 24 bytes (ELF64)
        const entrySize = 24;
        const numEntries = symSec.size / entrySize;
        
        // Limita a extração para não poluir demais o JSON (apenas funções globais)
        let count = 0;
        for (let i = 0; i < numEntries; i++) {
            const entryOff = symSec.offset + (i * entrySize);
            const st_name = read32(entryOff);
            const st_value = Number(read64(entryOff + 8)); // Offset da função
            const st_info = fileBytes[entryOff + 4];

            const type = st_info & 0xf;
            const binding = st_info >> 4;

            // STT_FUNC (2) ou STT_OBJECT (1) e GLOBAL (1)
            if ((type === 2 || type === 1) && st_value > 0) {
                const symName = readString(strSec.offset + st_name);
                if (symName && symName.length > 0) {
                    report.symbols[symName] = "0x" + st_value.toString(16);
                    count++;
                }
            }
        }
        report.symbols["_COUNT"] = count;
    }

    function scanGadgets(region) {
        const CHUNK = 1024 * 512; // 512KB por frame
        let currentPtr = 0;
        
        // Preparar arrays de busca para performance
        const targets = [];
        for (let key in ROP_TARGETS) {
            targets.push({ name: key, bytes: ROP_TARGETS[key] });
            report.gadgets[key] = []; // Inicializa array
        }

        function processChunk() {
            const end = Math.min(currentPtr + CHUNK, region.size);
            const absoluteBase = region.offset;
            
            // Loop principal de varredura
            for (let i = currentPtr; i < end; i++) {
                const absPos = absoluteBase + i;
                const byte = fileBytes[absPos];

                // Otimização: Só verifica se o byte bate com o início de algum gadget
                for (let t = 0; t < targets.length; t++) {
                    const tgt = targets[t];
                    // Limite de 5 gadgets por tipo para não inflar o JSON
                    if (report.gadgets[tgt.name].length >= 5) continue; 

                    if (byte === tgt.bytes[0]) {
                        // Verifica resto
                        let match = true;
                        for (let k = 1; k < tgt.bytes.length; k++) {
                            if (fileBytes[absPos + k] !== tgt.bytes[k]) {
                                match = false;
                                break;
                            }
                        }
                        if (match) {
                            // Salva offset relativo ao arquivo (que é o offset da lib)
                            report.gadgets[tgt.name].push("0x" + absPos.toString(16));
                        }
                    }
                }
            }

            // Atualiza UI
            currentPtr = end;
            const pct = Math.floor((currentPtr / region.size) * 100);
            updateProgress(pct);
            updateStatus(`Escaneando Gadgets: ${pct}%`);

            if (currentPtr < region.size) {
                // Agenda próximo bloco
                setTimeout(processChunk, 0);
            } else {
                finish();
            }
        }

        processChunk();
    }

    function finish() {
        updateStatus("Concluído!");
        const json = JSON.stringify(report, null, 2);
        document.getElementById('output').value = json;
    }

    // --- HELPER FUNCTIONS ---
    function read16(off) {
        return fileBytes[off] | (fileBytes[off+1] << 8);
    }
    function read32(off) {
        return (fileBytes[off] | (fileBytes[off+1] << 8) | (fileBytes[off+2] << 16) | (fileBytes[off+3] << 24)) >>> 0;
    }
    function read64(off) {
        const lo = read32(off);
        const hi = read32(off+4);
        return BigInt(lo) + (BigInt(hi) << 32n);
    }
    function readString(off) {
        let str = "";
        let i = off;
        while (i < fileSize && fileBytes[i] !== 0) {
            str += String.fromCharCode(fileBytes[i]);
            i++;
        }
        return str;
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    function copyJSON() {
        document.getElementById('output').select();
        document.execCommand('copy');
        alert("JSON copiado para a área de transferência!");
    }
</script>

</body>
</html>
