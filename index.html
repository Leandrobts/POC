
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 Scheduler Flood (Auto-Loop)</title>
    
</head>
<body>

    <h1>KERNEL SCHEDULER FLOOD (Auto-Loop)</h1>
    <div id="status">Aguardando início...</div>
    <button onclick="startLoop()">INICIAR ATAQUE (Loop Infinito)</button>
    <br><br>
    <div id="log"></div>

    <script>
        // ==============================================================
        // CONFIGURAÇÃO DE LOG (Opcional - Configure o IP do seu PC)
        // ==============================================================
        const LOG_SERVER_IP = "192.168.0.XX"; // <-- Mude isso se usar o server.py
        const LOG_SERVER_PORT = "8080";
        // ==============================================================

        let cycleCount = 0;
        let isRunning = false;
        let workers = [];
        
        // Blob do Worker: Loop infinito leve para segurar a thread no kernel
        // Usamos setInterval para manter o worker ativo mas permitindo interrupções
        const workerBlob = new Blob(["setInterval(()=>{}, 100)"], {type:'text/javascript'});
        const workerUrl = URL.createObjectURL(workerBlob);

        function logger(msg) {
            const el = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const line = `[${time}] ${msg}`;
            
            // Log na tela
            const div = document.createElement('div');
            div.innerText = line;
            if(msg.includes("CICLO")) div.className = "cycle-header";
            el.appendChild(div);
            el.scrollTop = el.scrollHeight;

            // Log via Rede (Tenta enviar para o PC antes do crash)
            try {
                fetch(`http://${LOG_SERVER_IP}:${LOG_SERVER_PORT}`, {
                    method: "POST",
                    body: line,
                    mode: 'no-cors',
                    keepalive: true
                }).catch(()=>{});
            } catch(e){}
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        function startLoop() {
            if(isRunning) return;
            isRunning = true;
            logger(">>> INICIANDO LOOP DE STRESS DO SCHEDULER <<<");
            runBatch();
        }

        // Esta função roda um lote de stress, para, e chama a si mesma
        function runBatch() {
            cycleCount++;
            updateStatus(`Executando CICLO #${cycleCount} (Pressão Máxima)...`);
            logger(`--- INICIANDO CICLO ${cycleCount} ---`);

            // Configuração agressiva
            const MAX_WORKERS = navigator.hardwareConcurrency * 6; // Sobrecarga (ex: 48 threads em 8 cores)
            const SPAWN_RATE = 5; // Workers por tick
            const TICK_RATE = 5;  // ms

            // Intervalo de Ataque
            const attackInterval = setInterval(() => {
                try {
                    // 1. Fase de Spawn (Criação)
                    for(let i=0; i<SPAWN_RATE; i++) {
                        workers.push(new Worker(workerUrl));
                    }

                    // 2. Fase de Kill (Churning)
                    // Matamos threads antigas para forçar o scheduler a re-calcular afinidade
                    // Mantemos o sistema sempre perto do limite
                    if(workers.length > MAX_WORKERS) {
                        // Mata metade para criar "buracos" na tabela de processos
                        while(workers.length > (MAX_WORKERS / 2)) {
                            const w = workers.shift();
                            w.terminate(); 
                        }
                    }
                } catch(e) {
                    logger(`Erro de Alocação (Sinal Bom!): ${e.message}`);
                }
            }, TICK_RATE);

            // Duração do lote: 2500ms (Tempo suficiente para sujar a memória, curto o suficiente para repetir rápido)
            setTimeout(() => {
                clearInterval(attackInterval);
                cleanupAndRestart();
            }, 2500);
        }

        function cleanupAndRestart() {
            logger(`Ciclo ${cycleCount} finalizado. Limpando...`);
            
            // Mata todos os workers restantes deste ciclo
            // Isso gera uma onda massiva de eventos "thread exit" no kernel
            while(workers.length > 0) {
                const w = workers.shift();
                w.terminate();
            }

            // O SEGREDO DO "3x":
            // Não damos tempo para o Kernel limpar totalmente as estruturas "zombie".
            // Reiniciamos quase imediatamente.
            updateStatus(`Recarregando para CICLO #${cycleCount + 1}...`);
            
            setTimeout(() => {
                runBatch(); // Recursão infinita
            }, 200); // 200ms de pausa apenas
        }

    </script>
</body>
</html>
