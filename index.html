<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>PS4 Rootcause Suite (Parent Logger + Visible Iframe)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin:0; background:#111; color:#ddd; font-family: monospace; }
    #topbar { padding:8px 10px; border-bottom:1px solid #333; background:#0b0b0b; }
    #log { height: 30vh; overflow:auto; background:#000; border-top:1px solid #333; padding:8px; }
    .hint { color:#9bd; }
    .muted{ color:#888; }
    .warn { color:#ffb84d; }
    .bad  { color:#ff5c5c; }
    .good { color:#7CFC9A; }

    /* IFRAME VISÍVEL E GRANDE */
    #frame {
      width: 100vw;
      height: 70vh;       /* deixa o log visível embaixo */
      border: 0;
      display: block;
      background: #000;
    }
    button { font-family: monospace; }
  </style>
</head>
<body>

  <div id="topbar">
    <div><b>PARENT LOGGER</b></div>
    <div class="hint">
      Fluxo: clique em um TESTE dentro do iframe → ele pede fullscreen → abra OPTIONS (blur) → ele roda e faz teardown → logs ficam aqui.
    </div>
    <div style="margin-top:6px;">
      <button onclick="loadIframe()">Load / Reset Iframe</button>
      <button onclick="clearLog()">Clear Log</button>
    </div>
  </div>

  <iframe id="frame"></iframe>

  <div id="log"></div>

<script>
(function(){
  const logEl = document.getElementById('log');
  const frame = document.getElementById('frame');

  function ts() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }
  function log(line, cls) {
    const div = document.createElement('div');
    div.textContent = `[${ts()}] ${line}`;
    if (cls) div.className = cls;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  window.clearLog = () => { logEl.innerHTML = ''; };

  window.addEventListener('message', (e) => {
    if (!e.data) return;
    if (typeof e.data === 'string') {
      log(e.data);
      return;
    }
    if (e.data.type === 'log') {
      log(e.data.msg, e.data.cls || '');
      return;
    }
  });

  window.loadIframe = () => {
    log('[PARENT] Loaded iframe', 'muted');
    frame.srcdoc = iframeHTML();
  };

  // auto-load
  loadIframe();

  function iframeHTML(){
return `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IFRAME Runner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin:0; background:#000; color:#0f0; font-family: monospace; }
    .wrap { padding: 10px; }
    h2 { margin: 0 0 10px 0; font-size: 16px; }
    .row { display:flex; flex-wrap:wrap; gap:8px; margin:8px 0; align-items:center; }
    .box { border:1px solid #0f0; padding:8px; background:#001100; white-space: pre-wrap; }
    select { font-family: monospace; padding:6px; background:#111; color:#0f0; border:1px solid #0f0; }
    button { padding:10px; font-family: monospace; background:#0f0; color:#000; border:0; }
    .hint { color:#9f9; }
    .warn { color:#ff0; }
  </style>
</head>
<body>
<div class="wrap">
  <h2>IFRAME: Rootcause Tests A–F</h2>

  <div class="box" id="status">
Clique em um teste. Ele pedirá fullscreen.
Depois abra OPTIONS (blur). O resto é automático.
Logs aparecem no PARENT (fora do iframe).
  </div>

  <div class="row">
    <label>Array Type:
      <select id="type">
        <option value="f64">Float64Array</option>
        <option value="u8">Uint8Array</option>
        <option value="ab">ArrayBuffer-only</option>
      </select>
    </label>

    <label>count:
      <select id="count">
        <option>1</option>
        <option>4</option>
        <option>32</option>
        <option>256</option>
        <option>1024</option>
      </select>
    </label>

    <label>len:
      <select id="len">
        <option value="8">8</option>
        <option value="64">64</option>
        <option value="256">256</option>
        <option value="1024">1024</option>
        <option value="8192">8192</option>
      </select>
    </label>

    <label>Detach before blur:
      <select id="detach">
        <option value="no">no</option>
        <option value="yes">yes (postMessage transfer)</option>
      </select>
    </label>

    <label>Teardown:
      <select id="teardown">
        <option value="dom_small">DOM small</option>
        <option value="dom_big">DOM big</option>
        <option value="kill_iframe">Kill iframe (document.open)</option>
        <option value="doc_write">document.write</option>
        <option value="reload">reload</option>
      </select>
    </label>
  </div>

  <div class="row">
    <button onclick="runA()">TEST A: Detach vs Non-Detach</button>
    <button onclick="runB()">TEST B: GC/Pressure</button>
    <button onclick="runC()">TEST C: Event Order</button>
    <button onclick="runD()">TEST D: Blur vs Visibility</button>
    <button onclick="runE()">TEST E: Minimal Teardown</button>
    <button onclick="runF()">TEST F: Glitch Checklist</button>
  </div>

  <div class="hint">
Dica: após finalizar um teste, use "Load/Reset Iframe" no parent para rodar o próximo limpo.
  </div>
</div>

<script>
(function(){
  function send(msg, cls){
    window.parent.postMessage({type:'log', msg:'[MSG] ' + msg, cls: cls || ''}, '*');
  }
  function status(t){ document.getElementById('status').textContent = t; }

  let armed = false;
  let counts = { blur:0, visibility:0, fullscreen:0, pagehide:0 };
  let order = [];

  function reset(tag){
    counts = { blur:0, visibility:0, fullscreen:0, pagehide:0 };
    order = [];
    send('=== RESET ('+tag+') ===');
    send('visibilityState=' + document.visibilityState);
  }
  function note(ev){
    order.push(ev);
    send('[EVENT] ' + ev);
  }

  window.onblur = function(){
    counts.blur++;
    note('blur #' + counts.blur);
    if (armed) trigger('blur');
  };
  document.addEventListener('visibilitychange', function(){
    counts.visibility++;
    note('visibilitychange #' + counts.visibility + ' -> ' + document.visibilityState);
  }, true);
  document.addEventListener('fullscreenchange', function(){
    counts.fullscreen++;
    const active = !!document.fullscreenElement || !!document.webkitFullscreenElement;
    note('fullscreenchange #' + counts.fullscreen + ' active=' + active);
  }, true);
  window.addEventListener('pagehide', function(){
    counts.pagehide++;
    note('pagehide #' + counts.pagehide);
  }, true);

  function getParams(){
    return {
      kind: document.getElementById('type').value,
      count: parseInt(document.getElementById('count').value, 10),
      len: parseInt(document.getElementById('len').value, 10),
      detach: document.getElementById('detach').value,
      teardown: document.getElementById('teardown').value,
    };
  }

  let keep = { abs: [], views: [], detached:false };

  function alloc(p){
    keep.abs = [];
    keep.views = [];
    keep.detached = false;

    if (p.kind === 'ab'){
      for (let i=0;i<p.count;i++){
        keep.abs.push(new ArrayBuffer(p.len * 8));
      }
      send('[ALLOC] ArrayBuffer-only count=' + p.count + ' size=' + (p.len*8) + ' bytes');
      return { ab: keep.abs[0] || null, view: null };
    }

    for (let i=0;i<p.count;i++){
      const ab = new ArrayBuffer(p.len * 8);
      keep.abs.push(ab);
      let v = null;
      if (p.kind === 'f64') v = new Float64Array(ab);
      if (p.kind === 'u8')  v = new Uint8Array(ab);
      if (p.kind === 'f64') v[0] = 13.37;
      if (p.kind === 'u8')  v[0] = 0x41;
      keep.views.push(v);
    }
    send('[ALLOC] ' + p.kind + ' count=' + p.count + ' len=' + p.len + ' (kept alive)');
    return { ab: keep.abs[0] || null, view: keep.views[0] || null };
  }

  function detachIfNeeded(p){
    if (p.detach !== 'yes') return;
    try {
      const ab0 = keep.abs[0];
      if (!ab0) { send('[DETACH] no buffer'); return; }
      window.postMessage({x:1}, '*', [ab0]);
      keep.detached = true;
      send('[DETACH] postMessage transfer executed (buffer may be neutered)');
    } catch(e){
      send('[DETACH] failed: ' + e, 'warn');
    }
  }

  function snapshot(label, p, obj){
    let s = '[SNAPSHOT] ' + label + '\\n';
    s += '  params=' + JSON.stringify(p) + '\\n';
    s += '  vis=' + document.visibilityState + '\\n';
    s += '  counts=' + JSON.stringify(counts) + '\\n';
    s += '  order=' + JSON.stringify(order) + '\\n';
    try {
      const v = obj.view;
      const ab = obj.ab;
      s += '  js: ';
      s += 'ab.byteLength=' + (ab ? ab.byteLength : 'null') + ' ';
      s += 'v.length=' + (v ? v.length : 'null') + ' ';
      s += 'v.byteLength=' + (v ? v.byteLength : 'null') + ' ';
      s += 'v[0]=' + (v ? v[0] : 'null');
    } catch(e){
      s += '  js: ERR(' + e + ')';
    }
    send(s);
  }

  function requestFS(){
    try {
      const el = document.documentElement;
      if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      else if (el.requestFullscreen) el.requestFullscreen();
      send('[STATE] fullscreen requested');
    } catch(e){
      send('[STATE] fullscreen failed: ' + e, 'warn');
    }
  }

  function arm(hint){
    armed = true;
    status('ARMED.\\nAbra OPTIONS agora (blur).\\n' + hint);
    send('[HINT] Abra OPTIONS agora (trigger blur)');
  }

  let afterTrigger = null;
  function trigger(source){
    armed = false;
    send('========================================');
    send('[TRIGGER] ' + source + ' detected');
    send('========================================');
    if (afterTrigger) {
      try { afterTrigger(); } catch(e){ send('[AFTER] error: ' + e, 'warn'); }
    }
  }

  function teardown(action){
    send('[TEARDOWN] action=' + action);
    try {
      if (action === 'dom_small') {
        const d = document.createElement('div'); d.textContent = 'x';
        document.body.appendChild(d);
      } else if (action === 'dom_big') {
        document.body.innerHTML = '<pre>big</pre>'.repeat(200);
      } else if (action === 'kill_iframe') {
        document.open(); document.write('bye'); document.close();
      } else if (action === 'doc_write') {
        document.open(); document.write('<html><body><h1>doc.write teardown</h1></body></html>'); document.close();
      } else if (action === 'reload') {
        location.reload();
      }
    } catch(e){
      send('[TEARDOWN] threw: ' + e, 'warn');
    }
  }

  // -------- TESTS ----------
  window.runA = function(){
    const p = getParams();
    reset('TEST A');
    send('=== START TEST A (Detach vs Non-Detach) ===', 'good');
    status('TEST A: Rode em duas execuções separadas.\\nA1: detach=no\\nA2: detach=yes\\nApós terminar, recarregue o iframe no PARENT e rode de novo mudando detach.');

    const obj = alloc(p);
    detachIfNeeded(p);
    snapshot('before fullscreen', p, obj);
    requestFS();
    arm('A: ao blur faremos snapshot e teardown.');

    afterTrigger = function(){
      snapshot('after blur', p, obj);
      teardown(p.teardown);
    };
  };

  window.runB = function(){
    const p = getParams();
    reset('TEST B');
    send('=== START TEST B (GC/Pressure) ===', 'good');

    const obj = alloc(p);
    detachIfNeeded(p);
    snapshot('before fullscreen', p, obj);
    requestFS();
    arm('B: observe se count/len impacta crash/glitch. Ao blur: teardown.');

    afterTrigger = function(){
      snapshot('after blur', p, obj);
      teardown(p.teardown);
    };
  };

  window.runC = function(){
    const p = getParams();
    reset('TEST C');
    send('=== START TEST C (Event Order) ===', 'good');

    const obj = alloc(p);
    detachIfNeeded(p);
    snapshot('before fullscreen', p, obj);
    requestFS();
    arm('C: foco na ordem dos eventos. Ao blur: snapshot + teardown.');

    afterTrigger = function(){
      snapshot('after blur', p, obj);
      teardown(p.teardown);
    };
  };

  window.runD = function(){
    const p = getParams();
    reset('TEST D');
    send('=== START TEST D (Blur vs Visibility) ===', 'good');

    const obj = alloc(p);
    detachIfNeeded(p);
    snapshot('before fullscreen', p, obj);
    requestFS();
    arm('D: vamos medir índices de blur vs visibility na "order".');

    afterTrigger = function(){
      const firstBlur = order.findIndex(x => x.indexOf('blur') === 0);
      const firstVis  = order.findIndex(x => x.indexOf('visibilitychange') === 0);
      send('[D] firstBlurIndex=' + firstBlur + ' firstVisIndex=' + firstVis);
      snapshot('after blur', p, obj);
      teardown(p.teardown);
    };
  };

  window.runE = function(){
    const p = getParams();
    reset('TEST E');
    send('=== START TEST E (Minimal Teardown) ===', 'good');

    const obj = alloc(p);
    detachIfNeeded(p);
    snapshot('before fullscreen', p, obj);
    requestFS();
    arm('E: repita mudando apenas Teardown para achar o mínimo que reproduz.');

    afterTrigger = function(){
      snapshot('after blur', p, obj);
      teardown(p.teardown);
    };
  };

  window.runF = function(){
    const p = getParams();
    reset('TEST F');
    send('=== START TEST F (Glitch Checklist) ===', 'good');

    const obj = alloc(p);
    detachIfNeeded(p);
    snapshot('before fullscreen', p, obj);
    requestFS();
    arm('F: após blur+teardown, observe manualmente UI/menu/botões/glitch.');

    afterTrigger = function(){
      snapshot('after blur', p, obj);
      send('[F] CHECKLIST pós-teardown:');
      send('  1) Menu OPTIONS mudou labels (ex msg_refresh_vb)?');
      send('  2) Texto/ícones/botões do browser alteraram?');
      send('  3) Persistiu após fechar menu?');
      send('  4) Some ao reiniciar browser?');
      teardown(p.teardown === 'reload' ? 'dom_small' : p.teardown);
    };
  };

  // sinaliza load
  send('[IFRAME] Loaded');
})();
<\/script>
</body>
</html>`;
  }
})();
</script>
</body>
</html>
