<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v600000: Navigation Kamikaze</title>
<style>
    body { background: #000; color: #ff0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #ff0; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #550; color: #fff; font-weight: bold;
    }
    .ghost { display: none; width: 100px; height: 100px; background: red; }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #330; color: #fff; border: 2px solid #ff0;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #ff0; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v600000: NAVIGATION KAMIKAZE</h1>

<div class="status" id="msg">
    OBJETIVO: SIMULAR O "REFRESH MANUAL" VIA CÓDIGO<br>
    CLIQUE -> OK -> CRASH AUTOMÁTICO
</div>

<button onclick="kamikaze(k01)">01. Location.Reload(true)</button>

<button onclick="kamikaze(k02)">02. Location.Replace(Blank)</button>

<button onclick="kamikaze(k03)">03. Blob URL Navigation</button>

<button onclick="kamikaze(k04)">04. Hash Flood Navigation</button>

<button onclick="kamikaze(k05)">05. Window.Stop() + GC Bomb</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Spray Global
    let junk = [];
    const pattern = new Uint32Array(1024).fill(0x41414141);

    function kamikaze(vectorFunc) {
        Stage.innerHTML = "";
        junk = [];
        
        // 1. Configura
        const element = vectorFunc(Stage);
        
        // 2. Dispara (com delay mínimo)
        setTimeout(() => {
            if(element.trigger) element.trigger();
        }, 50);
    }

    // =================================================================
    // 01. Location.Reload(true)
    // Simula EXATAMENTE o botão "Atualizar".
    // O parâmetro 'true' força o recarregamento do servidor (ignora cache),
    // o que causa uma destruição mais completa da página.
    // =================================================================
    function k01(stage) {
        const d = document.createElement('div');
        d.className = 'ghost'; // Invisível
        d.innerText = "RELOAD TRAP";
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ RELOAD TRAP ⚠️\nAo clicar OK: Fullscreen -> Auto Reload.");
            
            // 1. Fullscreen no invisível
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // 2. Tenta forçar o navegador a iniciar o recarregamento
            // num intervalo curtíssimo (Race Condition)
            setTimeout(() => {
                window.location.reload(true);
            }, 10); 
            
            // Spray enquanto espera morrer
            for(let i=0; i<1000; i++) junk.push(new Uint32Array(pattern));
        };
        return d;
    }

    // =================================================================
    // 02. Location.Replace(Blank)
    // Navega para 'about:blank'. Diferente do reload, isso descarrega
    // o motor de renderização HTML completamente para mostrar uma página vazia.
    // É mais destrutivo para a memória.
    // =================================================================
    function k02(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ BLANK NUKE ⚠️\nAo clicar OK: Fullscreen -> Ir para Blank.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Navegação destrutiva imediata
            setTimeout(() => {
                window.location.replace("about:blank");
            }, 0);
            
            // Alocação de memória pesada
            junk.push(new ArrayBuffer(1024*1024*5));
        };
        return d;
    }

    // =================================================================
    // 03. Blob URL Navigation
    // Navega para um arquivo binário (Blob) gerado na memória.
    // Isso força o navegador a trocar de "Modo Página Web" para "Modo Download/Visualizador".
    // Essa troca de contexto costuma quebrar o Fullscreen.
    // =================================================================
    function k03(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);

        // Cria um arquivo binário falso
        const blob = new Blob(["CRASH DATA " + "A".repeat(1000)], {type: 'application/octet-stream'});
        const url = URL.createObjectURL(blob);

        d.trigger = () => {
            window.alert("⚠️ BLOB SWITCH ⚠️\nAo clicar OK: Fullscreen -> Abrir Blob.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Navega para o blob
            setTimeout(() => {
                window.location.href = url;
            }, 10);
            
            // Spray
            junk.push(new Float64Array(1000).fill(1.1));
        };
        return d;
    }

    // =================================================================
    // 04. Hash Flood Navigation
    // Muda o URL (#hash) milhares de vezes por segundo.
    // Isso estressa o gerenciador de histórico enquanto o Fullscreen tenta ativar.
    // =================================================================
    function k04(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ HASH FLOOD ⚠️\nAo clicar OK: Fullscreen -> Spam de Navegação.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Loop de navegação frenética
            let count = 0;
            const interval = setInterval(() => {
                count++;
                window.location.hash = "crash" + Math.random();
                
                // A cada 50 hashes, tenta limpar o DOM
                if(count % 50 === 0) document.body.innerHTML = "WIPED";
                
                if(count > 1000) clearInterval(interval);
            }, 1);
        };
        return d;
    }

    // =================================================================
    // 05. Window.Stop() + GC Bomb
    // window.stop() é o equivalente ao botão "X" (Parar Carregamento).
    // Tenta parar o processo de Fullscreen no meio e encher a memória.
    // =================================================================
    function k05(stage) {
        const d = document.createElement('div');
        d.className = 'ghost';
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ STOP & FILL ⚠️\nAo clicar OK: Fullscreen -> Parar -> GC.");
            
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            setTimeout(() => {
                // 1. Manda parar tudo
                window.stop();
                
                // 2. Remove o elemento alvo
                d.remove();
                
                // 3. Bomba de memória para forçar o Garbage Collector
                // a rodar em cima da memória parada
                try {
                    for(let i=0; i<10000; i++) {
                        junk.push({a: new Uint8Array(1024), b: "junk"});
                    }
                } catch(e) {}
            }, 10);
        };
        return d;
    }

</script>
</body>
</html>
