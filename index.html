<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vulnerability Tests</title>
</head>
<body>
    <h1>PS4 WebKit Vulnerability Test Suite</h1>
    
    <h2>Controls</h2>
    <button onclick="runAllTests()">Run All Tests</button>
    <button onclick="clearLog()">Clear Log</button>
    <button onclick="clearTestArea()">Clear Test Area</button>
    
    <h2>Individual Tests</h2>
    <div id="testButtons"></div>
    
    <h2>Log</h2>
    <div id="log"></div>
    
    <h2>Test Area</h2>
    <div id="testArea"></div>

    <script>
        const log = document.getElementById('log');
        const testArea = document.getElementById('testArea');
        const testButtons = document.getElementById('testButtons');
        let testCount = 0;
        let crashes = 0;

        function addLog(msg, isError = false) {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toISOString()}] ${msg}`;
            if (isError) p.textContent = 'ðŸ”´ ' + p.textContent;
            log.appendChild(p);
            console.log(msg);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            log.innerHTML = '';
            crashes = 0;
            addLog('Log cleared');
        }

        function clearTestArea() {
            testArea.innerHTML = '';
            addLog('Test area cleared');
        }

        // Test 1: UAF via deleteRow + Event Handler
        function test1_TableRowUAF() {
            addLog('TEST 1: Table Row UAF via deleteRow + onfocus');
            try {
                const table = document.createElement('table');
                const tbody = table.createTBody();
                const row = tbody.insertRow();
                const cell = row.insertCell();
                
                row.onfocus = function() {
                    tbody.deleteRow(0);
                    cell.textContent = 'UAF trigger';
                };
                
                testArea.appendChild(table);
                row.focus();
                setTimeout(() => row.blur(), 10);
            } catch(e) {
                addLog('Test 1 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 2: Race condition - removeChild + onblur
        function test2_RemoveChildBlur() {
            addLog('TEST 2: removeChild during onblur');
            try {
                const div = document.createElement('div');
                const input = document.createElement('input');
                
                input.onblur = function() {
                    div.removeChild(input);
                    input.focus();
                };
                
                div.appendChild(input);
                testArea.appendChild(div);
                input.focus();
                setTimeout(() => input.blur(), 10);
            } catch(e) {
                addLog('Test 2 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 3: adoptNode + replaceChild race
        function test3_AdoptNodeRace() {
            addLog('TEST 3: adoptNode + replaceChild race condition');
            try {
                const iframe1 = document.createElement('iframe');
                const iframe2 = document.createElement('iframe');
                testArea.appendChild(iframe1);
                testArea.appendChild(iframe2);
                
                iframe1.onload = function() {
                    const doc1 = iframe1.contentDocument;
                    const doc2 = iframe2.contentDocument;
                    const div = doc1.createElement('div');
                    
                    div.onbeforeunload = function() {
                        doc2.adoptNode(div);
                        doc1.body.replaceChild(div, doc1.body.firstChild);
                    };
                    
                    doc1.body.appendChild(div);
                    iframe1.src = 'about:blank';
                };
                
                iframe1.src = 'about:blank';
            } catch(e) {
                addLog('Test 3 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 4: WebKit fullscreen + deleteCaption
        function test4_FullscreenTable() {
            addLog('TEST 4: webkitRequestFullscreen + deleteCaption');
            try {
                const table = document.createElement('table');
                const caption = table.createCaption();
                caption.textContent = 'Test';
                
                table.onwebkitfullscreenchange = function() {
                    table.deleteCaption();
                    table.createCaption().textContent = 'New';
                };
                
                testArea.appendChild(table);
                if (table.webkitRequestFullscreen) {
                    table.webkitRequestFullscreen();
                    setTimeout(() => {
                        if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    }, 100);
                }
            } catch(e) {
                addLog('Test 4 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 5: SVG + detach + onanimationend
        function test5_SVGDetach() {
            addLog('TEST 5: SVG element detach during animation');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                rect.onwebkitanimationend = function() {
                    svg.removeChild(rect);
                    rect.setAttribute('x', '100');
                };
                
                svg.appendChild(rect);
                testArea.appendChild(svg);
            } catch(e) {
                addLog('Test 5 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 6: Range deleteContents + Selection
        function test6_RangeDeleteContents() {
            addLog('TEST 6: Range.deleteContents with Selection');
            try {
                const div = document.createElement('div');
                div.innerHTML = 'Test content for selection';
                testArea.appendChild(div);
                
                const range = document.createRange();
                range.selectNodeContents(div);
                
                div.onselect = function() {
                    range.deleteContents();
                    div.textContent = 'Modified';
                };
                
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            } catch(e) {
                addLog('Test 6 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 7: WebSocket close + onmessage
        function test7_WebSocketRace() {
            addLog('TEST 7: WebSocket close during onmessage');
            try {
                const ws = new WebSocket('ws://localhost:9999');
                
                ws.onmessage = function(e) {
                    ws.close();
                    ws.send('after close');
                };
                
                ws.onerror = function() {
                    addLog('WebSocket error (expected)');
                };
            } catch(e) {
                addLog('Test 7 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 8: Canvas getImageData + removeChild
        function test8_CanvasUAF() {
            addLog('TEST 8: Canvas getImageData after removal');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                testArea.appendChild(canvas);
                
                setTimeout(() => {
                    testArea.removeChild(canvas);
                    const imageData = ctx.getImageData(0, 0, 100, 100);
                    ctx.putImageData(imageData, 0, 0);
                }, 10);
            } catch(e) {
                addLog('Test 8 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 9: Video element + onemptied + IndexedDB
        function test9_VideoEmptied() {
            addLog('TEST 9: Video onemptied + IndexedDB');
            try {
                const video = document.createElement('video');
                
                video.onemptied = function() {
                    const request = indexedDB.open('testDB', 1);
                    request.onupgradeneeded = function(e) {
                        const db = e.target.result;
                        const store = db.createObjectStore('test', {keyPath: 'id'});
                        db.deleteObjectStore('test');
                    };
                };
                
                testArea.appendChild(video);
                video.src = 'data:video/mp4;base64,AAAAAA==';
                video.load();
            } catch(e) {
                addLog('Test 9 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 10: Multiple iframe detach + onpageshow
        function test10_IframeDetach() {
            addLog('TEST 10: Multiple iframe detach during onpageshow');
            try {
                const iframes = [];
                for (let i = 0; i < 5; i++) {
                    const iframe = document.createElement('iframe');
                    iframe.onpageshow = function() {
                        iframes.forEach(f => {
                            if (f.parentNode) {
                                f.parentNode.removeChild(f);
                            }
                        });
                    };
                    testArea.appendChild(iframe);
                    iframes.push(iframe);
                }
                
                iframes[0].src = 'about:blank';
            } catch(e) {
                addLog('Test 10 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 11: CSSSOM deleteRule + matchMedia
        function test11_CSSOMRace() {
            addLog('TEST 11: CSSSOM deleteRule + matchMedia');
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                sheet.insertRule('body { color: red; }', 0);
                sheet.insertRule('div { margin: 10px; }', 1);
                
                const mql = window.matchMedia('(min-width: 500px)');
                mql.addListener(function() {
                    sheet.deleteRule(0);
                    sheet.insertRule('body { color: blue; }', 0);
                });
                
                window.dispatchEvent(new Event('resize'));
            } catch(e) {
                addLog('Test 11 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 12: innerHTML + onhashchange
        function test12_InnerHTMLHash() {
            addLog('TEST 12: innerHTML modification during onhashchange');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<a href="#test">Link</a>';
                testArea.appendChild(div);
                
                window.onhashchange = function() {
                    div.innerHTML = '';
                    div.innerHTML = '<span>Changed</span>';
                };
                
                window.location.hash = 'test';
                setTimeout(() => window.location.hash = '', 100);
            } catch(e) {
                addLog('Test 12 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 13: cloneNode deep + ontouchstart
        function test13_CloneNodeTouch() {
            addLog('TEST 13: Deep cloneNode during ontouchstart');
            try {
                const div = document.createElement('div');
                for (let i = 0; i < 100; i++) {
                    const child = document.createElement('span');
                    child.textContent = 'Child ' + i;
                    div.appendChild(child);
                }
                
                div.ontouchstart = function() {
                    const clone = div.cloneNode(true);
                    testArea.appendChild(clone);
                    div.parentNode.removeChild(div);
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 13 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 14: Worker terminate + onmessage
        function test14_WorkerTerminate() {
            addLog('TEST 14: Worker terminate during onmessage');
            try {
                const blob = new Blob(['self.postMessage("test");'], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));
                
                worker.onmessage = function(e) {
                    worker.terminate();
                    worker.postMessage('after terminate');
                };
            } catch(e) {
                addLog('Test 14 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 15: Storage event + deleteDatabase
        function test15_StorageDelete() {
            addLog('TEST 15: Storage event + IndexedDB deleteDatabase');
            try {
                window.onstorage = function() {
                    const request = indexedDB.deleteDatabase('testDB2');
                    request.onsuccess = function() {
                        localStorage.setItem('test', 'value');
                    };
                };
                
                localStorage.setItem('trigger', 'test');
            } catch(e) {
                addLog('Test 15 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 16: Form reset + deleteRow
        function test16_FormReset() {
            addLog('TEST 16: Form reset + table deleteRow');
            try {
                const form = document.createElement('form');
                const table = document.createElement('table');
                const tbody = table.createTBody();
                const row = tbody.insertRow();
                
                form.onreset = function() {
                    tbody.deleteRow(0);
                    tbody.insertRow();
                };
                
                form.appendChild(table);
                testArea.appendChild(form);
                form.reset();
            } catch(e) {
                addLog('Test 16 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 17: popstate + replaceChild
        function test17_PopstateReplace() {
            addLog('TEST 17: popstate event + replaceChild');
            try {
                const div1 = document.createElement('div');
                const div2 = document.createElement('div');
                div1.textContent = 'Original';
                testArea.appendChild(div1);
                
                window.onpopstate = function() {
                    testArea.replaceChild(div2, div1);
                    div1.textContent = 'After replace';
                };
                
                history.pushState({}, '', '#state1');
                history.back();
            } catch(e) {
                addLog('Test 17 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 18: Drag events + removeChild
        function test18_DragRemove() {
            addLog('TEST 18: ondragend + removeChild');
            try {
                const div = document.createElement('div');
                div.draggable = true;
                div.textContent = 'Drag me';
                
                div.ondragend = function() {
                    testArea.removeChild(div);
                    div.textContent = 'Dragged';
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 18 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 19: Audio context + onerror
        function test19_AudioError() {
            addLog('TEST 19: Audio element error + context manipulation');
            try {
                const audio = document.createElement('audio');
                
                audio.onerror = function() {
                    audio.src = 'data:audio/wav;base64,INVALID';
                    audio.load();
                };
                
                testArea.appendChild(audio);
                audio.src = 'invalid.mp3';
            } catch(e) {
                addLog('Test 19 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Test 20: insertAdjacentHTML + onscroll
        function test20_InsertAdjacent() {
            addLog('TEST 20: insertAdjacentHTML during onscroll');
            try {
                const div = document.createElement('div');
                div.innerHTML = 'Content';
                
                div.onscroll = function() {
                    div.insertAdjacentHTML('beforeend', '<p>Inserted</p>');
                    div.innerHTML = '';
                };
                
                testArea.appendChild(div);
                div.scrollTop = 10;
            } catch(e) {
                addLog('Test 20 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 21: createDocumentFragment + onpagehide
        function test21_FragmentPageHide() {
            addLog('TEST 21: DocumentFragment + onpagehide');
            try {
                const fragment = document.createDocumentFragment();
                for (let i = 0; i < 50; i++) {
                    const div = document.createElement('div');
                    div.textContent = 'Fragment ' + i;
                    fragment.appendChild(div);
                }
                
                window.onpagehide = function() {
                    testArea.appendChild(fragment);
                    fragment.appendChild(document.createElement('div'));
                };
                
                testArea.appendChild(fragment);
            } catch(e) {
                addLog('Test 21 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 22: deleteTHead + onfocus
        function test22_TableHeadUAF() {
            addLog('TEST 22: deleteTHead during onfocus');
            try {
                const table = document.createElement('table');
                const thead = table.createTHead();
                const row = thead.insertRow();
                const cell = row.insertCell();
                cell.textContent = 'Header';
                
                table.onfocus = function() {
                    table.deleteTHead();
                    const newHead = table.createTHead();
                    newHead.insertRow().insertCell().textContent = 'New';
                };
                
                testArea.appendChild(table);
                table.setAttribute('tabindex', '0');
                table.focus();
            } catch(e) {
                addLog('Test 22 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 23: SVG createSVGMatrix + onwebkittransitionend
        function test23_SVGMatrix() {
            addLog('TEST 23: SVG createSVGMatrix + transition');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                if (svg.createSVGMatrix) {
                    const matrix = svg.createSVGMatrix();
                    
                    rect.onwebkittransitionend = function() {
                        matrix.a = 2;
                        testArea.removeChild(svg);
                        matrix.b = 3;
                    };
                    
                    svg.appendChild(rect);
                    testArea.appendChild(svg);
                }
            } catch(e) {
                addLog('Test 23 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 24: importNode + onunload
        function test24_ImportNodeUnload() {
            addLog('TEST 24: importNode during onunload');
            try {
                const iframe = document.createElement('iframe');
                testArea.appendChild(iframe);
                
                iframe.onload = function() {
                    const iframeDoc = iframe.contentDocument;
                    const div = iframeDoc.createElement('div');
                    div.innerHTML = '<span>Test</span>';
                    
                    window.onunload = function() {
                        const imported = document.importNode(div, true);
                        testArea.appendChild(imported);
                    };
                    
                    iframeDoc.body.appendChild(div);
                };
                
                iframe.src = 'about:blank';
            } catch(e) {
                addLog('Test 24 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 25: Canvas toDataURL + releaseEvents
        function test25_CanvasDataURL() {
            addLog('TEST 25: Canvas toDataURL + event release');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200;
                const ctx = canvas.getContext('2d');
                
                ctx.fillRect(0, 0, 200, 200);
                
                canvas.onclick = function() {
                    const dataURL = canvas.toDataURL();
                    if (window.releaseEvents) {
                        window.releaseEvents();
                    }
                    canvas.toDataURL();
                };
                
                testArea.appendChild(canvas);
                canvas.click();
            } catch(e) {
                addLog('Test 25 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 26: textarea onselect + Range detach
        function test26_TextareaRange() {
            addLog('TEST 26: Textarea selection + Range.detach');
            try {
                const textarea = document.createElement('textarea');
                textarea.value = 'Test content for range manipulation';
                
                textarea.onselect = function() {
                    const range = document.createRange();
                    range.selectNodeContents(textarea);
                    if (range.detach) {
                        range.detach();
                    }
                    textarea.setSelectionRange(0, 5);
                };
                
                testArea.appendChild(textarea);
                textarea.select();
            } catch(e) {
                addLog('Test 26 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 27: Video timeupdate + deleteCell
        function test27_VideoTimeUpdate() {
            addLog('TEST 27: Video ontimeupdate + table deleteCell');
            try {
                const video = document.createElement('video');
                const table = document.createElement('table');
                const row = table.insertRow();
                const cell = row.insertCell();
                
                video.ontimeupdate = function() {
                    row.deleteCell(0);
                    row.insertCell().textContent = 'Updated';
                };
                
                testArea.appendChild(video);
                testArea.appendChild(table);
                video.currentTime = 1;
            } catch(e) {
                addLog('Test 27 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 28: WebGL loseContext + onresize
        function test28_WebGLLoseContext() {
            addLog('TEST 28: WebGL loseContext during resize');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    const ext = gl.getExtension('WEBGL_lose_context');
                    
                    window.onresize = function() {
                        if (ext) {
                            ext.loseContext();
                            gl.clear(gl.COLOR_BUFFER_BIT);
                        }
                    };
                    
                    testArea.appendChild(canvas);
                    window.dispatchEvent(new Event('resize'));
                }
            } catch(e) {
                addLog('Test 28 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 29: MessageChannel + onclose
        function test29_MessageChannel() {
            addLog('TEST 29: MessageChannel port close race');
            try {
                const channel = new MessageChannel();
                
                channel.port1.onmessage = function(e) {
                    channel.port1.close();
                    channel.port2.postMessage('after close');
                };
                
                channel.port2.onclose = function() {
                    channel.port1.postMessage('test');
                };
                
                channel.port1.start();
                channel.port2.start();
                channel.port2.postMessage('trigger');
            } catch(e) {
                addLog('Test 29 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 30: outerHTML + onanimationiteration
        function test30_OuterHTMLAnimation() {
            addLog('TEST 30: outerHTML during animation iteration');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<p>Original</p>';
                
                div.onanimationiteration = function() {
                    div.outerHTML = '<span>Replaced</span>';
                };
                
                testArea.appendChild(div);
            } catch(e) {
                addLog('Test 30 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 31: createObjectStore recursive + onseeking
        function test31_IndexedDBRecursive() {
            addLog('TEST 31: IndexedDB recursive operations');
            try {
                const video = document.createElement('video');
                
                video.onseeking = function() {
                    const request = indexedDB.open('recursiveDB', 1);
                    request.onupgradeneeded = function(e) {
                        const db = e.target.result;
                        for (let i = 0; i < 10; i++) {
                            const store = db.createObjectStore('store' + i, {keyPath: 'id'});
                            db.deleteObjectStore('store' + i);
                        }
                    };
                };
                
                testArea.appendChild(video);
                video.currentTime = 0.5;
            } catch(e) {
                addLog('Test 31 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 32: SVG suspendRedraw + ondurationchange
        function test32_SVGSuspendRedraw() {
            addLog('TEST 32: SVG suspendRedraw manipulation');
            try {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const video = document.createElement('video');
                
                video.ondurationchange = function() {
                    if (svg.suspendRedraw) {
                        const id = svg.suspendRedraw(1000);
                        testArea.removeChild(svg);
                        if (svg.unsuspendRedraw) {
                            svg.unsuspendRedraw(id);
                        }
                    }
                };
                
                testArea.appendChild(svg);
                testArea.appendChild(video);
            } catch(e) {
                addLog('Test 32 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 33: textContent setter + onpointerup
        function test33_TextContentPointer() {
            addLog('TEST 33: textContent setter during pointer events');
            try {
                const div = document.createElement('div');
                div.innerHTML = '<span>Original</span><b>Text</b>';
                
                div.onpointerup = function() {
                    div.textContent = 'New content';
                    div.innerHTML = '<p>Changed</p>';
                };
                
                div.onpointerdown = function() {
                    div.textContent = '';
                };
                
                testArea.appendChild(div);
                div.dispatchEvent(new PointerEvent('pointerdown'));
                div.dispatchEvent(new PointerEvent('pointerup'));
            } catch(e) {
                addLog('Test 33 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 34: CSSSOM cssText + onvolumechange
        function test34_CSSTextVolume() {
            addLog('TEST 34: CSSSOM cssText manipulation');
            try {
                const audio = document.createElement('audio');
                const style = document.createElement('style');
                document.head.appendChild(style);
                
                audio.onvolumechange = function() {
                    if (style.sheet) {
                        style.sheet.insertRule('body { background: red; }', 0);
                        style.sheet.cssRules[0].style.cssText = 'background: blue;';
                        style.sheet.deleteRule(0);
                    }
                };
                
                testArea.appendChild(audio);
                audio.volume = 0.5;
            } catch(e) {
                addLog('Test 34 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // NEW TEST 35: Multiple nested iframes + onbeforeunload
        function test35_NestedIframes() {
            addLog('TEST 35: Nested iframes onbeforeunload chain');
            try {
                const iframe1 = document.createElement('iframe');
                testArea.appendChild(iframe1);
                
                iframe1.onload = function() {
                    const doc1 = iframe1.contentDocument;
                    const iframe2 = doc1.createElement('iframe');
                    
                    iframe2.onload = function() {
                        const doc2 = iframe2.contentDocument;
                        
                        doc2.body.onbeforeunload = function() {
                            doc1.body.removeChild(iframe2);
                            doc1.body.appendChild(iframe2);
                        };
                        
                        iframe2.src = 'about:blank';
                    };
                    
                    doc1.body.appendChild(iframe2);
                    iframe2.src = 'about:blank';
                };
                
                iframe1.src = 'about:blank';
            } catch(e) {
                addLog('Test 35 Exception: ' + e.message, true);
                crashes++;
            }
        }

        // Array of all tests
        const allTests = [
            {name: 'Test 1: Table Row UAF', func: test1_TableRowUAF},
            {name: 'Test 2: RemoveChild Blur', func: test2_RemoveChildBlur},
            {name: 'Test 3: AdoptNode Race', func: test3_AdoptNodeRace},
            {name: 'Test 4: Fullscreen Table', func: test4_FullscreenTable},
            {name: 'Test 5: SVG Detach', func: test5_SVGDetach},
            {name: 'Test 6: Range DeleteContents', func: test6_RangeDeleteContents},
            {name: 'Test 7: WebSocket Race', func: test7_WebSocketRace},
            {name: 'Test 8: Canvas UAF', func: test8_CanvasUAF},
            {name: 'Test 9: Video Emptied', func: test9_VideoEmptied},
            {name: 'Test 10: Iframe Detach', func: test10_IframeDetach},
            {name: 'Test 11: CSSSOM Race', func: test11_CSSOMRace},
            {name: 'Test 12: innerHTML Hash', func: test12_InnerHTMLHash},
            {name: 'Test 13: CloneNode Touch', func: test13_CloneNodeTouch},
            {name: 'Test 14: Worker Terminate', func: test14_WorkerTerminate},
            {name: 'Test 15: Storage Delete', func: test15_StorageDelete},
            {name: 'Test 16: Form Reset', func: test16_FormReset},
            {name: 'Test 17: Popstate Replace', func: test17_PopstateReplace},
            {name: 'Test 18: Drag Remove', func: test18_DragRemove},
            {name: 'Test 19: Audio Error', func: test19_AudioError},
            {name: 'Test 20: InsertAdjacent', func: test20_InsertAdjacent},
            {name: 'Test 21: Fragment PageHide', func: test21_FragmentPageHide},
            {name: 'Test 22: Table Head UAF', func: test22_TableHeadUAF},
            {name: 'Test 23: SVG Matrix', func: test23_SVGMatrix},
            {name: 'Test 24: ImportNode Unload', func: test24_ImportNodeUnload},
            {name: 'Test 25: Canvas DataURL', func: test25_CanvasDataURL},
            {name: 'Test 26: Textarea Range', func: test26_TextareaRange},
            {name: 'Test 27: Video TimeUpdate', func: test27_VideoTimeUpdate},
            {name: 'Test 28: WebGL LoseContext', func: test28_WebGLLoseContext},
            {name: 'Test 29: MessageChannel', func: test29_MessageChannel},
            {name: 'Test 30: OuterHTML Animation', func: test30_OuterHTMLAnimation},
            {name: 'Test 31: IndexedDB Recursive', func: test31_IndexedDBRecursive},
            {name: 'Test 32: SVG SuspendRedraw', func: test32_SVGSuspendRedraw},
            {name: 'Test 33: TextContent Pointer', func: test33_TextContentPointer},
            {name: 'Test 34: CSSText Volume', func: test34_CSSTextVolume},
            {name: 'Test 35: Nested Iframes', func: test35_NestedIframes}
        ];

        // Create individual test buttons
        function createTestButtons() {
            allTests.forEach((test, index) => {
                const btn = document.createElement('button');
                btn.textContent = test.name;
                btn.onclick = function() {
                    addLog(`Running ${test.name}...`);
                    test.func();
                };
                testButtons.appendChild(btn);
                testButtons.appendChild(document.createTextNode(' '));
            });
        }

        // Run all tests
        function runAllTests() {
            addLog('=== Starting PS4 WebKit Vulnerability Tests ===');
            
            let i = 0;
            function runNext() {
                if (i < allTests.length) {
                    allTests[i].func();
                    i++;
                    setTimeout(runNext, 200);
                } else {
                    addLog(`=== Tests Complete: ${crashes} exceptions detected ===`);
                }
            }
            
            runNext();
        }

        // Initialize
        createTestButtons();
        addLog('Test suite loaded. Click individual tests or "Run All Tests".
