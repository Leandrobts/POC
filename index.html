<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hybrid Resource Collider</title>
    <style>
        body { background-color: #000; color: #ff0; font-family: monospace; padding: 20px; }
        .stat { font-size: 20px; margin: 10px 0; }
        #result { font-size: 30px; font-weight: bold; color: #fff; margin-top: 20px; }
        button { font-size: 24px; padding: 15px; width: 100%; cursor: pointer; background: #333; color: #fff; border: 1px solid #ff0; }
    </style>
</head>
<body>

    <h1>Teste Híbrido: Threads vs Sockets</h1>
    <p>Objetivo: Mudar o número mágico (418) usando Sockets.</p>

    <div class="stat">Threads Vivas: <span id="thCount">0</span></div>
    <div class="stat">Sockets Abertos: <span id="sockCount">0</span></div>
    <div id="result">Pronto.</div>

    <button onclick="runHybridTest()">INICIAR COLISÃO</button>

    <script>
        const workerCode = `postMessage("done");`; // Worker leve
        const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
        
        let threads = [];
        let sockets = [];

        function log(msg) {
            document.getElementById('result').innerText = msg;
        }

        function updateStats() {
            document.getElementById('thCount').innerText = threads.length;
            document.getElementById('sockCount').innerText = sockets.length;
        }

        function runHybridTest() {
            log("Fase 1: Enchendo Threads até 300...");
            
            // 1. Cria 300 Threads (Zona Segura)
            let tInterval = setInterval(() => {
                let w = new Worker(url);
                w.onmessage = () => {};
                threads.push(w);
                updateStats();

                if(threads.length >= 300) {
                    clearInterval(tInterval);
                    startSocketSpray();
                }
            }, 20);
        }

        function startSocketSpray() {
            log("Fase 2: INJETANDO 1000 SOCKETS...");
            document.body.style.backgroundColor = "#000033"; // Azul

            // 2. Tenta alocar 1000 WebSockets (consome File Descriptors e Kernel Memory)
            // Isso deve pressionar o mesmo mapa de memória que as threads usam
            let sCount = 0;
            let sInterval = setInterval(() => {
                try {
                    // Abre conexão local (não precisa funcionar, só alocar a estrutura)
                    let s = new WebSocket("ws://127.0.0.1:9090/" + sCount);
                    s.onerror = () => {}; // Ignora erro de conexão
                    sockets.push(s);
                } catch(e) {
                    // Ignora
                }
                sCount++;
                updateStats();

                if(sCount >= 1000) {
                    clearInterval(sInterval);
                    startFinalPush();
                }
            }, 2); // Muito rápido
        }

        function startFinalPush() {
            log("Fase 3: EMPURRANDO THREADS (O Crash vai mudar?)");
            document.body.style.backgroundColor = "#330000"; // Vermelho

            // 3. Volta a criar threads até o crash
            let finalInterval = setInterval(() => {
                let w = new Worker(url);
                w.onmessage = () => {};
                threads.push(w);
                updateStats();

                // Se passar de 418 significativamente, algo estranho aconteceu
                if(threads.length > 450) {
                    clearInterval(finalInterval);
                    log("RESULTADO: Sem colisão (Limite isolado).");
                }
            }, 50); // Lento para ver o número exato
        }
    </script>
</body>
</html>
