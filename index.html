<!DOCTYPE html>
<html>
<head>
    <title>Memory Fingerprinter V2 (Safe)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 400px; overflow-y: auto; white-space: pre-wrap;}
        button { font-size: 20px; padding: 15px; background: #222; color: #fff; border: 1px solid #0f0; cursor: pointer; }
        .highlight { color: #0ff; font-weight: bold; }
        .warn { color: #ff0; }
        .fail { color: #f00; }
    </style>
</head>
<body>
    <h2>Memory Fingerprinter V2 (Safe Mode)</h2>
    <p>Análise de Heap com proteção contra OOM (Out of Memory).</p>
    
    <button onclick="runSafeAnalysis()">INICIAR ANÁLISE SEGURA</button>
    <div id="log">Pronto.</div>

    <script>
        function log(msg, type='') {
            const el = document.getElementById('log');
            // Usamos span para colorir partes específicas se necessário
            el.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // Força GC alocando e liberando buffers grandes
        async function forceGC() {
            log("   (Limpando memória...)", 'warn');
            try {
                let a = [];
                for(let i=0; i<100; i++) a.push(new Uint8Array(1024 * 1024)); // 100MB lixo
                a = null;
            } catch(e) {}
            await sleep(500); // Pausa para o sistema respirar
        }

        async function runSafeAnalysis() {
            document.getElementById('log').innerHTML = "Iniciando...\n";
            
            // --- TESTE 1: BLOCOS CONTÍGUOS (Large Heap) ---
            log("--- TESTE 1: Limite de Alocação Única ---");
            // Testamos marcos seguros em vez de loop infinito
            const sizes = [64, 128, 256, 512, 800]; // MB
            let maxSafe = 0;

            for (let mb of sizes) {
                await sleep(100);
                try {
                    log(`Tentando alocar ${mb} MB...`);
                    let ab = new ArrayBuffer(mb * 1024 * 1024);
                    maxSafe = mb;
                    
                    // Verifica se realmente alocou
                    if (ab.byteLength === (mb * 1024 * 1024)) {
                        log(`OK: ${mb} MB alocado com sucesso.`);
                    }
                    ab = null; // Libera
                    
                } catch(e) {
                    log(`FALHA: Não foi possível alocar ${mb} MB. Limite atingido.`, 'fail');
                    break; // Para o teste aqui, não insiste
                }
                await forceGC();
            }
            log(`>> Conclusão Teste 1: Máximo Contíguo ~${maxSafe} MB`, 'highlight');


            // --- TESTE 2: VELOCIDADE DE ALOCAÇÃO (IsoHeap) ---
            log("\n--- TESTE 2: Performance de Alocação (IsoHeap) ---");
            await sleep(500);
            
            let count = 20000; // Reduzido de 50k para 20k para segurança
            let smallBuffers = [];
            let t0 = performance.now();
            
            try {
                for(let i=0; i<count; i++) {
                    smallBuffers.push(new Uint8Array(64));
                }
            } catch(e) {
                log("Erro durante teste 2 (Memória cheia?)", 'fail');
            }
            
            let t1 = performance.now();
            let duration = t1 - t0;
            
            // Limpeza imediata
            smallBuffers = null;
            await forceGC();

            log(`Tempo para ${count} objetos: ${duration.toFixed(2)}ms`);
            if (duration < 50) {
                log(">> ALOCAÇÃO MUITO RÁPIDA (Heap Simples/Bump Pointer)", 'highlight');
            } else {
                log(">> ALOCAÇÃO LENTA (Heap Seguro/IsoHeap)", 'warn');
            }


            // --- TESTE 3: POINTER COMPRESSION (Inferência) ---
            log("\n--- TESTE 3: Pointer Compression Check ---");
            // Se houver compressão, ponteiros são 32-bit (4 bytes).
            // Se não houver, são 64-bit (8 bytes).
            // Alocar 2 milhão de objetos:
            // Com compressão: ~8MB de ponteiros + Overhead.
            // Sem compressão: ~16MB de ponteiros + Overhead.
            
            await sleep(500);
            let ptrArr = [];
            let ptrCount = 0;
            const SAFE_LIMIT = 2000000; // 2 Milhões (Seguro)

            t0 = performance.now();
            try {
                for(let i=0; i<SAFE_LIMIT; i++) {
                    ptrArr.push({}); // Objeto vazio
                    ptrCount++;
                    // Checagem a cada 100k para não travar UI
                    if (i % 200000 === 0) await sleep(10); 
                }
                log(`Sucesso: ${ptrCount} objetos alocados.`);
                log(">> O sistema aguentou a carga sem crash.", 'highlight');
                
            } catch(e) {
                log(`OOM atingido em ${ptrCount} objetos.`, 'fail');
                log(">> O sistema ficou sem memória rapidamente (Indício de 64-bit Pointers).", 'warn');
            }
            
            // Limpeza Final
            ptrArr = null;
            await forceGC();

            log("\n--- ANÁLISE CONCLUÍDA ---");
        }
    </script>
</body>
</html>
