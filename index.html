
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v140000: Memory Minefield</title>
<style>
    body { background: #200; color: #f88; font-family: monospace; padding: 20px; }
    h1 { color: #f00; }
    button { 
        width: 100%; padding: 15px; margin: 5px 0; 
        background: #500; color: #fff; border: 1px solid #f00; 
        font-weight: bold; cursor: pointer; text-align: left;
    }
    button:hover { background: #f00; }
    #log { border: 1px solid #f00; height: 250px; overflow-y: scroll; padding: 10px; margin-top: 20px; background: #100;}
</style>
</head>
<body>

<h1>v140000: MEMORY MINEFIELD</h1>
<div id="log">Sistema pronto. Cuidado onde pisa.</div>

<button onclick="run(m01)">01. Canvas putImageData Detached Buffer Race</button>
<button onclick="run(m02)">02. Array.prototype.push Proxy Length Trap</button>
<button onclick="run(m03)">03. TypedArray Constructor Integer Underflow</button>

<button onclick="run(m04)">04. CSS nth-child Mutation Layout Thrash</button>
<button onclick="run(m05)">05. HTMLFormControlsCollection Named Item UAF</button>
<button onclick="run(m06)">06. Detached StyleSheet InsertRule Crash</button>

<button onclick="run(m07)">07. Map.prototype.forEach Clear Mutate</button>
<button onclick="run(m08)">08. RegExp Subclass Exec State Corruption</button>
<button onclick="run(m09)">09. JSON.stringify Getter Side-Effect Detach</button>
<button onclick="run(m10)">10. Large Comment Node Data Overflow Attempt</button>

<script>
    const L = document.getElementById('log');
    function log(msg) { L.innerHTML += "[!] " + msg + "\n"; L.scrollTop = L.scrollHeight; }

    function run(fn) {
        L.innerHTML += "\n>>> ARMANDO " + fn.name + " <<<\n";
        // Tenta limpar o heap antes do teste para aumentar determinismo
        pressure();
        setTimeout(() => {
            try { 
                fn(); 
                log("Executado sem crash imediato.");
            } catch(e) { 
                log("Exceção Segura capturada: " + e.message); 
            }
            // Pressão pós-teste para tentar engatilhar UAFs latentes
            setTimeout(pressure, 50);
        }, 100);
    }

    // =================================================================
    // 01. Canvas putImageData Detached Buffer Race
    // Tenta desenhar no canvas usando um buffer que é "desanexado"
    // (transferido para um worker) no exato momento do desenho.
    // =================================================================
    function m01() {
        log("Preparando Canvas e Worker...");
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        const imgData = ctx.createImageData(100, 100);
        
        // Worker para neuterizar o buffer
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        
        log("Race: putImageData vs Transfer...");
        // Transfere o buffer subjacente
        w.postMessage(imgData.data.buffer, [imgData.data.buffer]);
        
        // Tenta usar os dados agora inválidos. Se a engine não checar, crash.
        ctx.putImageData(imgData, 0, 0);
        w.terminate();
    }

    // =================================================================
    // 02. Array.prototype.push Proxy Length Trap
    // Usa um Proxy para interceptar a leitura do tamanho do array
    // durante um push, alterando o objeto subjacente no meio da operação.
    // =================================================================
    function m02() {
        log("Configurando Proxy Trap no Array...");
        const target = [];
        const p = new Proxy(target, {
            get(t, prop) {
                if (prop === 'length') {
                    log("Trap 'length' ativada! Corrompendo alvo...");
                    // Substitui o alvo por algo incompatível
                    t[0] = {}; 
                    // Força realocação de armazenamento
                    t.length = 1000; 
                    return 0; // Retorna tamanho falso
                }
                return t[prop];
            }
        });

        log("Executando push()...");
        // O motor C++ pode calcular o deslocamento de memória baseado no length 0,
        // mas escrever em um buffer que foi realocado.
        Array.prototype.push.call(p, 1);
    }

    // =================================================================
    // 03. TypedArray Constructor Integer Underflow
    // Tenta passar um tamanho negativo massivo para o construtor,
    // esperando um erro de cálculo de inteiro sem sinal.
    // =================================================================
    function m03() {
        log("Tentando alocação com Underflow...");
        try {
            // 0xFFFFFFFF = -1 em 32-bit assinado.
            // Se tratado como não assinado, é 4GB.
            // Se o cálculo de offset falhar, pode apontar para memória inválida.
            const ta = new Uint8Array(0xFFFFFFFF);
            log("Alocação falhou de forma segura (Esperado).");
        } catch(e) {
            log("Erro capturado: " + e.message);
        }
    }

    // =================================================================
    // 04. CSS nth-child Mutation Layout Thrash
    // Força recálculos de estilo complexos (nth-child) enquanto
    // a árvore DOM é violentamente modificada.
    // =================================================================
    function m04() {
        log("Construindo lista complexa...");
        const ul = document.createElement('ul');
        document.body.appendChild(ul);
        // Regra CSS que depende da posição do irmão
        const style = document.createElement('style');
        style.textContent = "li:nth-child(even) { color: red; border: 1px solid black; }";
        document.head.appendChild(style);

        for(let i=0; i<100; i++) ul.appendChild(document.createElement('li'));

        log("Iniciando Thrashing (Mutação + Layout)...");
        for(let i=0; i<50; i++) {
            // Força cálculo de layout síncrono
            const h = ul.offsetHeight; 
            // Remove elementos no meio da lista (invalida caches de nth-child)
            if(ul.children.length > 2) ul.children[1].remove();
            // Adiciona novos
            ul.appendChild(document.createElement('li'));
        }
        log("Sobreviveu ao thrashing.");
        ul.remove(); style.remove();
    }

    // =================================================================
    // 05. HTMLFormControlsCollection Named Item UAF
    // Manipula IDs de elementos de formulário para confundir o cache
    // interno da coleção, tentando acessar um item liberado.
    // =================================================================
    function m05() {
        log("Criando Form Collection...");
        const f = document.createElement('form');
        const i1 = document.createElement('input'); i1.id = "target"; i1.name = "target";
        f.appendChild(i1);
        document.body.appendChild(f);

        // Acessa para criar cache
        const ref = f.elements['target'];
        
        log("Mutando ID e forçando GC...");
        i1.id = "moved"; // Invalida cache
        i1.remove();     // Remove do DOM
        pressure();      // GC tenta coletar i1
        
        log("Acessando coleção novamente...");
        // Se o cache da coleção manteve um ponteiro para i1, isso é UAF.
        const zombie = f.elements['target']; 
        if(zombie) log("Item ainda acessível (Potencial problema).");
        f.remove();
    }

    // =================================================================
    // 06. Detached StyleSheet InsertRule Crash
    // Tenta inserir regras CSS em uma folha de estilos que pertence
    // a um iframe que já foi removido do documento.
    // =================================================================
    function m06() {
        log("Criando iframe e stylesheet...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        const style = ifr.contentDocument.createElement('style');
        ifr.contentDocument.head.appendChild(style);
        const sheet = style.sheet;

        log("Destacando iframe (Detach)...");
        ifr.remove();
        pressure();

        log("Tentando inserir regra em sheet órfão...");
        try {
            // O objeto C++ do stylesheet pode ter sido limpo.
            sheet.insertRule("body { background: red; }", 0);
        } catch(e) {
            log("Erro esperado em objeto detached: " + e.message);
        }
    }

    // =================================================================
    // 07. Map.prototype.forEach Clear Mutate
    // Um clássico: Iterar sobre uma estrutura de dados enquanto a esvazia.
    // =================================================================
    function m07() {
        log("Preenchendo Map...");
        const m = new Map();
        for(let i=0; i<100; i++) m.set(i, {});

        log("Iniciando forEach destrutivo...");
        m.forEach((val, key) => {
            if (key === 50) {
                log("Limpando Map durante iteração...");
                m.clear();
                pressure(); // Força liberação dos itens
            }
            // Se o iterador C++ não for robusto, ele tentará acessar o item 51 
            // em uma estrutura de apoio que foi liberada.
        });
    }

    // =================================================================
    // 08. RegExp Subclass Exec State Corruption
    // Subclasse de RegExp que interfere no estado interno durante a execução.
    // =================================================================
    function m08() {
        class EvilRegExp extends RegExp {
            exec(str) {
                log("Exec interceptado. Modificando lastIndex...");
                // Altera estado interno no meio do matching
                this.lastIndex = 1000; 
                return super.exec(str);
            }
        }
        const re = new EvilRegExp('a', 'g');
        log("Rodando match...");
        "abaac".match(re);
    }

    // =================================================================
    // 09. JSON.stringify Getter Side-Effect Detach
    // Usa um getter durante a serialização JSON para remover o objeto
    // que está sendo serializado do DOM, causando UAF.
    // =================================================================
    function m09() {
        const container = document.createElement('div');
        const obj = {
            get x() {
                log("Getter durante stringify. Removendo container...");
                container.remove();
                pressure();
                return "detached";
            }
        };
        container.x_ref = obj; // Anexa ao DOM
        document.body.appendChild(container);

        log("Serializando...");
        JSON.stringify(container.x_ref);
    }

    // =================================================================
    // 10. Large Comment Node Data Overflow Attempt
    // Tenta criar um nó de comentário com uma quantidade absurda de dados,
    // testando limites de alocação de strings no DOM.
    // =================================================================
    function m10() {
        log("Tentando criar string massiva (256MB+)...");
        try {
            let s = "X".repeat(1024 * 1024); // 1MB
            s = s.repeat(256); // 256MB
            
            log("Atribuindo a nó de comentário...");
            // Isso força o DOM a alocar armazenamento para essa string
            const c = document.createComment(s);
            log("Comentário criado (Sistema suportou a carga).");
            s = null; // Libera memória
        } catch(e) {
            log("Falha de alocação (OOM Seguro): " + e.message);
        }
    }

    // === FUNÇÃO AUXILIAR DE PRESSÃO DE MEMÓRIA (GC) ===
    // Tenta forçar o Garbage Collector a rodar alocando e liberando memória rapidamente.
    function pressure() {
        const trash = [];
        for(let i=0; i<200; i++) trash.push(new Uint8Array(1024 * 64));
        trash.length = 0;
    }

</script>
</body>
</html>
