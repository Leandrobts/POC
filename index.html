<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Direct Crash Tests</title>
</head>
<body>
    <h1>PS4 Direct Crash Tests</h1>
    
    <button onclick="crash01()">01: ArrayBuffer Detach Loop</button>
    <button onclick="crash02()">02: TypedArray Sort Detach</button>
    <button onclick="crash03()">03: Array Shift Overflow</button>
    <button onclick="crash04()">04: Worker Buffer Transfer</button>
    <button onclick="crash05()">05: DOM Node Recursion</button>
    <button onclick="crash06()">06: Canvas Pattern Cycle</button>
    <button onclick="crash07()">07: Prototype Chain Loop</button>
    <button onclick="crash08()">08: String Concat Massive</button>
    <button onclick="crash09()">09: MessagePort Flood</button>
    <button onclick="crash10()">10: Getter Infinite Loop</button>
    <button onclick="crash11()">11: ArrayBuffer View Storm</button>
    <button onclick="crash12()">12: Document Write Recursion</button>
    <button onclick="crash13()">13: Event Listener Bomb</button>
    <button onclick="crash14()">14: MutationObserver Chain</button>
    <button onclick="crash15()">15: Blob Array Massive</button>
    <button onclick="crash16()">16: Range Extract Loop</button>
    <button onclick="crash17()">17: StyleSheet Rule Bomb</button>
    <button onclick="crash18()">18: TreeWalker Deep</button>
    <button onclick="crash19()">19: Promise Chain Deep</button>
    <button onclick="crash20()">20: Proxy Trap Recursion</button>
        <button onclick="crash21()">21: DataView Type Punning</button>
    <button onclick="crash22()">22: Subarray Detach Chain</button>
    <button onclick="crash23()">23: FormData Massive</button>
    <button onclick="crash24()">24: TextNode Fragment Bomb</button>
    <button onclick="crash25()">25: AudioBuffer Corruption</button>
    <button onclick="crash26()">26: ImageData Race</button>
    <button onclick="crash27()">27: WeakMap GC Storm</button>
    <button onclick="crash28()">28: Attribute Node Flood</button>
    <button onclick="crash29()">29: History State Overflow</button>
    <button onclick="crash30()">30: XHR ArrayBuffer Loop</button>
    <button onclick="crash31()">31: Shadow DOM Deep</button>
    <button onclick="crash32()">32: Selection Range Bomb</button>
    <button onclick="crash33()">33: Clipboard Event Storm</button>
    <button onclick="crash34()">34: StructuredClone Deep</button>
    <button onclick="crash35()">35: Crypto Buffer Detach</button>
    <button onclick="crash36()">36: NodeIterator Infinite</button>
    <button onclick="crash37()">37: CSSValueList Massive</button>
    <button onclick="crash38()">38: IntersectionObserver Flood</button>
    <button onclick="crash39()">39: Iframe Document Write</button>
    <button onclick="crash40()">40: URL Object Bomb</button>
    <button onclick="crash41()">41: PerformanceEntry Flood</button>
    <button onclick="crash42()">42: Video Track Spam</button>
    <button onclick="crash43()">43: FontFace Load Loop</button>
    <button onclick="crash44()">44: MediaQuery Listener Bomb</button>
    <button onclick="crash45()">45: Window Frames Recursion</button>
    <button onclick="crash46()">46: Array Iterator Corruption</button>
    <button onclick="crash47()">47: Function Prototype Storm</button>
    <button onclick="crash48()">48: Object.defineProperty Bomb</button>
    <button onclick="crash49()">49: DOMRect List Massive</button>
    <button onclick="crash50()">50: Computed Style Flood</button>
    

    <script>
        function crash01() {
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            for (let i = 0; i < 1000; i++) {
                const buffer = new ArrayBuffer(65536);
                const view = new Uint8Array(buffer);
                view.fill(0x41);
                w.postMessage(buffer, [buffer]);
                try { view[0] = 0xFF; } catch(e) {}
            }
        }

        function crash02() {
            const buffer = new ArrayBuffer(1048576);
            const array = new Float64Array(buffer);
            for (let i = 0; i < array.length; i++) array[i] = Math.random();
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            array.sort((a, b) => {
                w.postMessage(buffer, [buffer]);
                return a - b;
            });
        }

        function crash03() {
            const arrays = [];
            for (let i = 0; i < 100; i++) {
                const arr = new Array(10000);
                for (let j = 0; j < arr.length; j++) arr[j] = {data: new ArrayBuffer(1024)};
                arrays.push(arr);
            }
            for (let round = 0; round < 1000; round++) {
                for (let i = 0; i < arrays.length; i++) {
                    arrays[i].shift();
                    arrays[i].push({data: new ArrayBuffer(1024)});
                }
            }
        }

        function crash04() {
            const code = `onmessage=e=>{postMessage(e.data);}`;
            for (let i = 0; i < 50; i++) {
                const w = new Worker(URL.createObjectURL(new Blob([code], {type:"text/javascript"})));
                for (let j = 0; j < 100; j++) {
                    const buf = new ArrayBuffer(32768);
                    w.postMessage(buf, [buf]);
                }
            }
        }

        function crash05() {
            function deepTree(parent, depth) {
                if (depth > 100) return;
                for (let i = 0; i < 10; i++) {
                    const child = document.createElement('div');
                    parent.appendChild(child);
                    deepTree(child, depth + 1);
                }
            }
            const root = document.createElement('div');
            document.body.appendChild(root);
            deepTree(root, 0);
            document.body.removeChild(root);
            deepTree(root, 0);
        }

        function crash06() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            const pattern = ctx.createPattern(canvas, 'repeat');
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, 2048, 2048);
                canvas.width = 1024;
                canvas.width = 2048;
            }
        }

        function crash07() {
            const objs = [];
            for (let i = 0; i < 100; i++) {
                const obj = {id: i};
                objs.push(obj);
                if (i > 0) Object.setPrototypeOf(obj, objs[i - 1]);
            }
            Object.setPrototypeOf(objs[0], objs[99]);
            try {
                for (let i = 0; i < 1000; i++) {
                    const val = objs[0].nonexistent;
                }
            } catch(e) {}
        }

        function crash08() {
            let str = 'A'.repeat(100000);
            for (let i = 0; i < 100; i++) {
                str = str + str;
                if (str.length > 10000000) break;
            }
        }

        function crash09() {
            const channels = [];
            for (let i = 0; i < 1000; i++) {
                const mc = new MessageChannel();
                channels.push(mc);
                mc.port1.onmessage = e => mc.port1.postMessage(e.data);
                mc.port1.start();
                mc.port2.postMessage(new ArrayBuffer(4096));
            }
        }

        function crash10() {
            const obj = {};
            Object.defineProperty(obj, 'x', {
                get: function() {
                    return obj.x;
                }
            });
            try { const val = obj.x; } catch(e) {}
        }

        function crash11() {
            const buffer = new ArrayBuffer(1048576);
            const views = [];
            for (let i = 0; i < 1000; i++) {
                views.push(new Uint8Array(buffer));
                views.push(new Uint16Array(buffer));
                views.push(new Uint32Array(buffer));
                views.push(new Float32Array(buffer));
                views.push(new Float64Array(buffer));
            }
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            w.postMessage(buffer, [buffer]);
            for (let i = 0; i < views.length; i++) {
                try { views[i][0] = 0xFF; } catch(e) {}
            }
        }

        function crash12() {
            const iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            const doc = iframe.contentDocument;
            function recurse(depth) {
                if (depth > 50) return;
                doc.write('<div>');
                recurse(depth + 1);
                doc.write('</div>');
            }
            doc.open();
            recurse(0);
            doc.close();
        }

        function crash13() {
            const target = document.createElement('div');
            document.body.appendChild(target);
            for (let i = 0; i < 10000; i++) {
                target.addEventListener('click', function() {
                    target.dispatchEvent(new Event('click'));
                });
            }
            target.dispatchEvent(new Event('click'));
        }

        function crash14() {
            const target = document.createElement('div');
            document.body.appendChild(target);
            const observer = new MutationObserver((mutations) => {
                target.appendChild(document.createElement('span'));
            });
            observer.observe(target, {childList: true});
            target.appendChild(document.createElement('span'));
        }

        function crash15() {
            const blobs = [];
            for (let i = 0; i < 10000; i++) {
                const data = new Uint8Array(65536);
                data.fill(0x41);
                blobs.push(new Blob([data.buffer]));
            }
        }

        function crash16() {
            const container = document.createElement('div');
            for (let i = 0; i < 1000; i++) {
                const span = document.createElement('span');
                span.textContent = 'Text ' + i;
                container.appendChild(span);
            }
            document.body.appendChild(container);
            const range = document.createRange();
            for (let i = 0; i < 100; i++) {
                range.selectNodeContents(container);
                const fragment = range.extractContents();
                container.appendChild(fragment);
            }
        }

        function crash17() {
            const style = document.createElement('style');
            document.head.appendChild(style);
            for (let i = 0; i < 10000; i++) {
                style.sheet.insertRule('.class' + i + ' { color: red; }', 0);
            }
        }

        function crash18() {
            const container = document.createElement('div');
            function deepNest(parent, depth) {
                if (depth > 1000) return;
                const child = document.createElement('span');
                parent.appendChild(child);
                deepNest(child, depth + 1);
            }
            deepNest(container, 0);
            document.body.appendChild(container);
            const walker = document.createTreeWalker(container, NodeFilter.SHOW_ALL);
            for (let i = 0; i < 10000; i++) {
                walker.nextNode();
            }
        }

        function crash19() {
            let promise = Promise.resolve(0);
            for (let i = 0; i < 100000; i++) {
                promise = promise.then(x => x + 1);
            }
        }

        function crash20() {
            const handler = {
                get: function(target, prop) {
                    return new Proxy({}, handler);
                }
            };
            const proxy = new Proxy({}, handler);
            try {
                for (let i = 0; i < 1000; i++) {
                    const val = proxy.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p;
                }
            } catch(e) {}
        }
    
    

    
        function crash21() {
            const buffers = [];
            for (let i = 0; i < 500; i++) {
                const buf = new ArrayBuffer(16384);
                const dv = new DataView(buf);
                const u32 = new Uint32Array(buf);
                const f64 = new Float64Array(buf);
                
                for (let j = 0; j < 100; j++) {
                    dv.setUint32(j * 4, 0xDEADBEEF, true);
                    u32[j] = f64[j % (f64.length)];
                    f64[j % f64.length] = u32[j];
                }
                buffers.push({dv, u32, f64});
            }
        }

        function crash22() {
            const main = new ArrayBuffer(1048576);
            const view = new Uint32Array(main);
            const subs = [];
            
            for (let i = 0; i < 100; i++) {
                subs.push(view.subarray(i * 1000, (i + 1) * 1000));
            }
            
            const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(1)"], {type:"text/javascript"})));
            w.postMessage(main, [main]);
            
            for (let i = 0; i < subs.length; i++) {
                for (let j = 0; j < subs[i].length; j++) {
                    subs[i][j] = 0x41414141;
                }
            }
        }

        function crash23() {
            const forms = [];
            for (let i = 0; i < 1000; i++) {
                const fd = new FormData();
                for (let j = 0; j < 100; j++) {
                    fd.append('field' + j, 'X'.repeat(10000));
                    const blob = new Blob([new Uint8Array(8192)]);
                    fd.append('file' + j, blob, 'file.bin');
                }
                forms.push(fd);
            }
        }

        function crash24() {
            const fragments = [];
            for (let i = 0; i < 100; i++) {
                const frag = document.createDocumentFragment();
                for (let j = 0; j < 1000; j++) {
                    frag.appendChild(document.createTextNode('Text'.repeat(1000)));
                }
                fragments.push(frag);
                
                const container = document.createElement('div');
                container.appendChild(frag);
                document.body.appendChild(container);
                document.body.removeChild(container);
            }
        }

        function crash25() {
            if (!window.AudioContext && !window.webkitAudioContext) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            
            const contexts = [];
            for (let i = 0; i < 20; i++) {
                const ctx = new AudioContext();
                contexts.push(ctx);
                
                for (let j = 0; j < 50; j++) {
                    const buffer = ctx.createBuffer(2, 44100, 44100);
                    const ch0 = buffer.getChannelData(0);
                    const ch1 = buffer.getChannelData(1);
                    
                    for (let k = 0; k < ch0.length; k++) {
                        ch0[k] = Math.random();
                        ch1[k] = Math.random();
                    }
                    
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);
                    try { source.start(0); } catch(e) {}
                }
            }
        }

        function crash26() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            
            for (let i = 0; i < 100; i++) {
                const imgData = ctx.createImageData(2048, 2048);
                const data = imgData.data;
                
                for (let j = 0; j < data.length; j += 4) {
                    data[j] = 0xFF;
                    data[j+1] = 0x00;
                    data[j+2] = 0x00;
                    data[j+3] = 0xFF;
                }
                
                ctx.putImageData(imgData, 0, 0);
                canvas.width = 1024;
                canvas.width = 2048;
                
                const readback = ctx.getImageData(0, 0, 2048, 2048);
            }
        }

        function crash27() {
            const wm = new WeakMap();
            const keys = [];
            
            for (let i = 0; i < 100000; i++) {
                const key = {id: i, data: new ArrayBuffer(1024)};
                wm.set(key, {value: i, buffer: new Uint8Array(2048)});
                
                if (i % 2 === 0) {
                    keys.push(key);
                } else {
                    keys.push(null);
                }
            }
            
            for (let i = 0; i < keys.length; i += 3) {
                keys[i] = null;
            }
        }

        function crash28() {
            const elements = [];
            for (let i = 0; i < 1000; i++) {
                const elem = document.createElement('div');
                for (let j = 0; j < 100; j++) {
                    elem.setAttribute('attr' + j, 'value'.repeat(1000));
                }
                elements.push(elem);
                document.body.appendChild(elem);
            }
            
            for (let i = 0; i < elements.length; i++) {
                const attrs = elements[i].attributes;
                for (let j = 0; j < attrs.length; j++) {
                    attrs[j].value = 'modified'.repeat(1000);
                }
            }
        }

        function crash29() {
            for (let i = 0; i < 1000; i++) {
                const state = {
                    id: i,
                    data: new Array(1000).fill(i),
                    buffer: new ArrayBuffer(4096),
                    nested: {
                        deep: new Uint8Array(8192)
                    }
                };
                try {
                    history.pushState(state, '', '#state' + i);
                } catch(e) {}
            }
        }

        function crash30() {
            for (let i = 0; i < 100; i++) {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';
                xhr.open('GET', 'data:application/octet-stream;base64,' + btoa('X'.repeat(65536)), true);
                xhr.onload = function() {
                    const buffer = xhr.response;
                    const view = new Uint8Array(buffer);
                    view[0] = 0xFF;
                };
                xhr.send();
            }
        }

        function crash31() {
            if (!document.body.attachShadow) return;
            
            const hosts = [];
            for (let i = 0; i < 100; i++) {
                const host = document.createElement('div');
                document.body.appendChild(host);
                
                try {
                    const shadow = host.attachShadow({mode: 'open'});
                    
                    for (let j = 0; j < 100; j++) {
                        const nested = document.createElement('div');
                        shadow.appendChild(nested);
                        
                        try {
                            const nestedShadow = nested.attachShadow({mode: 'open'});
                            for (let k = 0; k < 50; k++) {
                                nestedShadow.appendChild(document.createElement('span'));
                            }
                        } catch(e) {}
                    }
                    
                    hosts.push(host);
                } catch(e) {}
            }
        }

        function crash32() {
            const container = document.createElement('div');
            container.contentEditable = true;
            container.innerHTML = 'A'.repeat(100000);
            document.body.appendChild(container);
            
            const selection = window.getSelection();
            
            for (let i = 0; i < 1000; i++) {
                const range = document.createRange();
                range.setStart(container.firstChild, 0);
                range.setEnd(container.firstChild, 1000);
                
                selection.removeAllRanges();
                selection.addRange(range);
                
                const extracted = range.extractContents();
                container.appendChild(extracted);
            }
        }

        function crash33() {
            const textarea = document.createElement('textarea');
            textarea.value = 'X'.repeat(100000);
            document.body.appendChild(textarea);
            
            for (let i = 0; i < 1000; i++) {
                textarea.select();
                document.execCommand('copy');
                document.execCommand('paste');
            }
        }

        function crash34() {
            const code = `onmessage=e=>{postMessage(e.data);}`;
            const w = new Worker(URL.createObjectURL(new Blob([code], {type:"text/javascript"})));
            
            for (let i = 0; i < 100; i++) {
                const obj = {
                    level: i,
                    buffer: new ArrayBuffer(8192),
                    nested: null
                };
                
                let current = obj;
                for (let j = 0; j < 50; j++) {
                    current.nested = {
                        data: new Uint32Array(1024),
                        next: null
                    };
                    current = current.nested;
                }
                
                w.postMessage(obj, [obj.buffer]);
            }
        }

        function crash35() {
            if (!crypto.getRandomValues) return;
            
            const buffers = [];
            for (let i = 0; i < 500; i++) {
                const buf = new ArrayBuffer(65536);
                const view = new Uint8Array(buf);
                crypto.getRandomValues(view);
                buffers.push(buf);
            }
            
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            
            for (let i = 0; i < buffers.length; i++) {
                w.postMessage(buffers[i], [buffers[i]]);
                
                const view = new Uint8Array(buffers[i]);
                try {
                    crypto.getRandomValues(view);
                } catch(e) {}
            }
        }

        function crash36() {
            const container = document.createElement('div');
            
            for (let i = 0; i < 10000; i++) {
                container.appendChild(document.createElement('span'));
            }
            
            document.body.appendChild(container);
            
            const iterator = document.createNodeIterator(container, NodeFilter.SHOW_ALL);
            
            let count = 0;
            while (iterator.nextNode() && count < 100000) {
                count++;
                
                if (count % 100 === 0) {
                    container.removeChild(container.lastChild);
                    container.appendChild(document.createElement('div'));
                }
            }
        }

        function crash37() {
            const elements = [];
            
            for (let i = 0; i < 1000; i++) {
                const elem = document.createElement('div');
                elem.style.cssText = 'margin: 10px 20px 30px 40px; padding: 5px 10px 15px 20px; border: 1px 2px 3px 4px solid red;';
                elem.style.transform = 'matrix(1,0,0,1,0,0) scale(2) rotate(45deg) translate(100px, 100px)';
                
                document.body.appendChild(elem);
                elements.push(elem);
                
                const computed = window.getComputedStyle(elem);
                const margin = computed.margin;
                const transform = computed.transform;
            }
        }

        function crash38() {
            if (!window.IntersectionObserver) return;
            
            const targets = [];
            const observers = [];
            
            for (let i = 0; i < 1000; i++) {
                const elem = document.createElement('div');
                elem.style.height = '100px';
                document.body.appendChild(elem);
                targets.push(elem);
                
                const observer = new IntersectionObserver(entries => {
                    entries.forEach(entry => {
                        entry.target.style.height = '200px';
                    });
                }, {threshold: [0, 0.25, 0.5, 0.75, 1.0]});
                
                observer.observe(elem);
                observers.push(observer);
            }
            
            for (let i = 0; i < 100; i++) {
                window.scrollBy(0, 100);
            }
        }

        function crash39() {
            for (let i = 0; i < 50; i++) {
                const iframe = document.createElement('iframe');
                document.body.appendChild(iframe);
                
                const doc = iframe.contentDocument;
                doc.open();
                
                for (let j = 0; j < 100; j++) {
                    doc.write('<div style="width:100%;height:100px;">'.repeat(10));
                    doc.write('X'.repeat(10000));
                    doc.write('</div>'.repeat(10));
                }
                
                doc.close();
                
                setTimeout(() => {
                    document.body.removeChild(iframe);
                }, 10);
            }
        }

        function crash40() {
            const blobs = [];
            const urls = [];
            
            for (let i = 0; i < 10000; i++) {
                const data = new Uint8Array(4096);
                data.fill(i % 256);
                const blob = new Blob([data.buffer]);
                blobs.push(blob);
                
                const url = URL.createObjectURL(blob);
                urls.push(url);
            }
            
            for (let i = 0; i < urls.length; i += 2) {
                URL.revokeObjectURL(urls[i]);
            }
            
            for (let i = 0; i < urls.length; i++) {
                try {
                    const newURL = new URL(urls[i]);
                } catch(e) {}
            }
        }

        function crash41() {
            if (!performance.mark) return;
            
            for (let i = 0; i < 10000; i++) {
                performance.mark('mark_' + i);
            }
            
            for (let i = 0; i < 9999; i++) {
                try {
                    performance.measure('measure_' + i, 'mark_' + i, 'mark_' + (i + 1));
                } catch(e) {}
            }
            
            const entries = performance.getEntriesByType('mark');
            
            for (let i = 0; i < 100; i++) {
                performance.clearMarks();
                
                for (let j = 0; j < 1000; j++) {
                    performance.mark('new_' + i + '_' + j);
                }
            }
        }

        function crash42() {
            for (let i = 0; i < 100; i++) {
                const video = document.createElement('video');
                video.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQ==';
                
                for (let j = 0; j < 10; j++) {
                    video.addTextTrack('subtitles', 'Track_' + j, 'en');
                }
                
                document.body.appendChild(video);
                video.load();
            }
        }

        function crash43() {
            if (!window.FontFace) return;
            
            const fontData = 'data:font/woff2;base64,d09GMgABAAAAAAFgAAoAAAAAAwgAAAEWAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAgkIKASgLBgABNgIkAwgEIAUgBzgbpQLIngV2w/URNmEoQ+lTXv4jHr7f739r73u+iWcRxaNZNBGJWqiQKKGTIZLpECJeGSL5NjOH8d8lUGytjq+VWyi15c/kab3TD/i3Ou2bLgq0pIWU4J1y4IkHKgkGLhe8og2uCzdBEEPxgBKfY1ZDvk+4m0PjnyF3SK0VQHQCYM/e3dvO/8SfiGv1O3HNVgTEHjApUKHCqADbVQKjikliEfyJuv4HThJA1HN2goIWzGIeUEBqKqWjxWxpq2sv5za8P/KueWfgbcuL/ldN9wZet75of93g+d7n4DmKM91dmpqK4LnfqJrFd+JCB1xfPLIiblFf/p0eHQAEgi/vb/bE9v+NkODvl4c11X/ZlI00ShBUK/Udh3KqzvkxAQDIuGo65/lAGtYE1UtwS5CSSHZe/mQw4QAAAA==';
            
            for (let i = 0; i < 100; i++) {
                const font = new FontFace('TestFont' + i, 'url(' + fontData + ')');
                font.load().then(f => {
                    document.fonts.add(f);
                }).catch(e => {});
            }
        }

        function crash44() {
            if (!window.matchMedia) return;
            
            const queries = [];
            
            for (let i = 0; i < 1000; i++) {
                const mql = matchMedia('(min-width: ' + i + 'px)');
                queries.push(mql);
                
                for (let j = 0; j < 10; j++) {
                    const listener = function(e) {
                        mql.matches;
                    };
                    
                    if (mql.addListener) {
                        mql.addListener(listener);
                    }
                }
            }
        }

        function crash45() {
            function createNestedFrames(depth) {
                if (depth > 5) return;
                
                const iframe = document.createElement('iframe');
                document.body.appendChild(iframe);
                
                const doc = iframe.contentDocument;
                doc.open();
                doc.write('<html><body></body></html>');
                doc.close();
                
                if (iframe.contentWindow && iframe.contentWindow.document) {
                    const innerBody = iframe.contentWindow.document.body;
                    innerBody.innerHTML = '<div>Nested ' + depth + '</div>';
                    
                    setTimeout(() => {
                        createNestedFrames(depth + 1);
                    }, 10);
                }
            }
            
            createNestedFrames(0);
        }

        function crash46() {
            const arrays = [];
            const iterators = [];
            
            for (let i = 0; i < 1000; i++) {
                const arr = new Array(1000);
                for (let j = 0; j < arr.length; j++) {
                    arr[j] = {id: j, data: new ArrayBuffer(1024)};
                }
                arrays.push(arr);
                iterators.push(arr[Symbol.iterator]());
            }
            
            for (let round = 0; round < 100; round++) {
                for (let i = 0; i < iterators.length; i++) {
                    iterators[i].next();
                    
                    arrays[i].length = 500;
                    arrays[i].length = 1000;
                    
                    for (let j = 0; j < 100; j++) {
                        arrays[i].shift();
                    }
                    
                    iterators[i].next();
                }
            }
        }

        function crash47() {
            const constructors = [];
            
            for (let i = 0; i < 1000; i++) {
                const ctor = function(x) {
                    this.id = i;
                    this.value = x;
                    this.data = new Array(100).fill(new ArrayBuffer(1024));
                };
                
                ctor.prototype = {
                    getValue: function() { return this.value; }
                };
                
                constructors.push(ctor);
                
                for (let j = 0; j < 100; j++) {
                    new ctor(j);
                }
                
                ctor.prototype = null;
            }
        }

        function crash48() {
            const objects = [];
            
            for (let i = 0; i < 1000; i++) {
                const obj = {id: i};
                objects.push(obj);
                
                for (let j = 0; j < 100; j++) {
                    Object.defineProperty(obj, 'prop' + j, {
                        get: function() {
                            return new ArrayBuffer(1024);
                        },
                        set: function(val) {
                            this['_prop' + j] = val;
                        },
                        configurable: true
                    });
                }
                
                for (let j = 0; j < 100; j++) {
                    obj['prop' + j];
                    obj['prop' + j] = j;
                }
            }
        }

        function crash49() {
            const elements = [];
            
            for (let i = 0; i < 1000; i++) {
                const elem = document.createElement('div');
                elem.style.position = 'absolute';
                elem.style.left = i + 'px';
                elem.style.top = i + 'px';
                elem.style.width = '100px';
                elem.style.height = '100px';
                
                for (let j = 0; j < 10; j++) {
                    const child = document.createElement('span');
                    child.textContent = 'Text ' + j;
                    elem.appendChild(child);
                }
                
                document.body.appendChild(elem);
                elements.push(elem);
            }
            
            for (let round = 0; round < 100; round++) {
                for (let i = 0; i < elements.length; i++) {
                    const rects = elements[i].getClientRects();
                    
                    for (let j = 0; j < rects.length; j++) {
                        const r = rects[j];
                        const x = r.x;
                        const y = r.y;
                    }
                    
                    elements[i].style.left = (round * 10) + 'px';
                }
            }
        }

        function crash50() {
            const elements = [];
            
            for (let i = 0; i < 5000; i++) {
                const elem = document.createElement('div');
                elem.style.cssText = 'width:100px;height:100px;margin:10px;padding:5px;border:1px solid red;transform:rotate(45deg);opacity:0.5;';
                document.body.appendChild(elem);
                elements.push(elem);
            }
            
            for (let round = 0; round < 50; round++) {
                for (let i = 0; i < elements.length; i++) {
                    const computed = window.getComputedStyle(elements[i]);
                    const width = computed.width;
                    const height = computed.height;
                    const transform = computed.transform;
                    const opacity = computed.opacity;
                    const margin = computed.marginTop;
                }
            }
        }
    </script>
</body>
</html>

