<!doctype html>
<meta charset="utf-8">
<title>PS4 Reflect.construct Sanity Suite</title>

<body style="background:#000;color:#0f0;font-family:monospace">
<h2>PS4 Reflect.construct – Sanity Suite (length snapshot vs leak)</h2>
<p>Objetivo: diferenciar comportamento spec-like (snapshot de length + Gets) de evidências reais (valor inesperado / type confusion / crash).</p>

<button onclick="clearLog()">CLEAR</button>
<button onclick="S1_baseline()">S1 Baseline (sem shrink)</button>
<button onclick="S2_shrink_mid()">S2 Shrink no meio (Proxy audit)</button>
<button onclick="S3_length_reads()">S3 Quantas vezes lê 'length'?</button>
<button onclick="S4_missing_vs_own()">S4 Missing vs OwnProps (holes / deletes)</button>
<button onclick="S5_invariants()">S5 Invariants (mesma execução repetida)</button>
<button onclick="S6_typedarray_detach()">S6 TypedArray Detach Sanity</button>
<button onclick="S7_cross_realm()">S7 Cross-Realm Sanity (iframe)</button>
    <button onclick="S6_typedarray_detach_FIXED()">S6 TypedArray Detach Sanity (FIXED)</button>


<pre id="log" style="border:1px solid #0f0; padding:10px; height:420px; overflow:auto; white-space:pre-wrap;"></pre>

<script>
const L = document.getElementById('log');
function log(s){ L.textContent += s + "\n"; }
function gold(s){ L.textContent += "[GOLD] " + s + "\n"; }
function warn(s){ L.textContent += "[WARN] " + s + "\n"; }
function clearLog(){ L.textContent = ""; }

// Util: formata valores sem estourar o log
function fmt(v){
  const t = typeof v;
  if (v === undefined) return "undefined";
  if (v === null) return "null";
  if (t === "number") return (Object.is(v, -0) ? "-0" : String(v));
  if (t === "string") return JSON.stringify(v);
  if (t === "boolean") return String(v);
  if (t === "symbol") return v.toString();
  if (t === "function") return "[Function " + (v.name||"anon") + "]";
  try {
    if (Array.isArray(v)) return "[Array len=" + v.length + "]";
    if (v && v.constructor && v.constructor.name) return "[Object " + v.constructor.name + "]";
  } catch(e){}
  return "[Object]";
}

// Util: roda Reflect.construct e captura ...r
function reflectRun(argsLike, label){
  let got = null;
  function Target(...r){ got = r; }
  try {
    Reflect.construct(Target, argsLike);
    log("[" + label + "] OK. received.length=" + (got ? got.length : "null"));
  } catch(e){
    warn("[" + label + "] EXCEPTION: " + e.message);
  }
  return got;
}

/* =========================================================
   S1: Baseline — sem shrink
   Prova o "comportamento normal" e serve de controle.
========================================================= */
function S1_baseline(){
  log("=== S1 BASELINE ===");
  const args = [1,2,3,4];
  const r = reflectRun(args, "baseline");
  if (!r) return;

  // Checagens básicas
  log("Values: " + r.map(fmt).join(", "));
  if (r.length !== 4) warn("Baseline length inesperado: " + r.length);
  if (r[3] !== 4) warn("Baseline r[3] inesperado: " + fmt(r[3]));
  log("S1 done.\n");
}

/* =========================================================
   S2: Shrink no meio + Proxy audit
   Registra (a) quantos índices são acessados e (b) se o engine
   tenta acessar índices altos após o shrink (esperado).
   O "sucesso" aqui NÃO é bug — é telemetria.
========================================================= */
function S2_shrink_mid(){
  log("=== S2 SHRINK MID (Proxy audit) ===");
  const base = new Array(100);
  for (let i=0;i<100;i++) base[i] = 0x11110000 + i;

  let getCount = 0;
  let lengthReadCount = 0;
  const accessed = [];
  const p = new Proxy(base, {
    get(target, prop, recv){
      if (prop === "length") {
        lengthReadCount++;
        return Reflect.get(target, prop, recv);
      }
      // intercepta índices numéricos
      const n = (typeof prop === "string" && prop === String(prop|0)) ? (prop|0) : NaN;
      if (!Number.isNaN(n)) {
        getCount++;
        if (accessed.length < 50) accessed.push(n); // cap
        // gatilho: no índice 10, encolhe para 0
        if (n === 10) {
          target.length = 0;
          log("[*] shrink triggered at index 10 (length->0)");
        }
      }
      return Reflect.get(target, prop, recv);
    }
  });

  const r = reflectRun(p, "shrink_mid");
  log("Telemetry: lengthReadCount=" + lengthReadCount + " getCount=" + getCount);
  log("First accessed indices (cap 50): " + accessed.join(", "));
  if (r) {
    // Aqui r.length pode permanecer 100 (snapshot) — isso é o ponto.
    log("received.length=" + r.length);
    // Checa se valores após o shrink viram undefined (esperado)
    let undefAfter = 0;
    for (let i=20; i<Math.min(r.length, 100); i++){
      if (r[i] === undefined) undefAfter++;
    }
    log("undefined count in range [20..99]: " + undefAfter);
  }
  log("S2 done.\n");
}

/* =========================================================
   S3: Quantas vezes lê 'length'?
   Alguns engines leem 1x, outros podem ler mais (depende de
   otimizações). Isso NÃO é bug; é fingerprint comportamental.
========================================================= */
function S3_length_reads(){
  log("=== S3 LENGTH READS ===");
  const base = new Array(1000);
  base.fill(7);

  let lengthReads = 0;
  const p = new Proxy(base, {
    get(t, k, r){
      if (k === "length") lengthReads++;
      // gatilho leve: no índice 5, shrink
      if (k === "5") t.length = 0;
      return Reflect.get(t, k, r);
    }
  });

  reflectRun(p, "length_reads");
  log("lengthReads=" + lengthReads);
  log("S3 done.\n");
}

/* =========================================================
   S4: Missing vs OwnProps (holes/deletes)
   Distingue:
   - hole (prop ausente)
   - prop existente mas valor undefined
========================================================= */
function S4_missing_vs_own(){
  log("=== S4 MISSING vs OWNPROPS ===");
  const args = new Array(20);
  args.fill(1);
  // cria holes
  delete args[5];
  delete args[6];
  // cria ownProp undefined
  args[7] = undefined;

  const p = new Proxy(args, {
    get(t,k,r){
      if (k === "length") return Reflect.get(t,k,r);
      if (k === "3") { t.length = 0; log("[*] shrink at index 3"); }
      return Reflect.get(t,k,r);
    },
    has(t,k){ return Reflect.has(t,k); },
    getOwnPropertyDescriptor(t,k){ return Reflect.getOwnPropertyDescriptor(t,k); }
  });

  const r = reflectRun(p, "missing_vs_own");
  if (!r) return;

  // reporta slots de interesse
  function slot(i){
    const has = (i in args);
    const v = r[i];
    return "i=" + i + " (own=" + has + ") => " + fmt(v);
  }
  log(slot(5));
  log(slot(6));
  log(slot(7));

  // GOLD só se algo realmente anômalo aparecer: não-undefined vindo de slot que virou missing
  if (!(5 in args) && r[5] !== undefined) gold("Slot 5 missing mas veio " + fmt(r[5]));
  if (!(6 in args) && r[6] !== undefined) gold("Slot 6 missing mas veio " + fmt(r[6]));
  log("S4 done.\n");
}

/* =========================================================
   S5: Invariants — repetibilidade (N execuções)
   Se aparecer valor não-determinístico em slots missing,
   isso é muito mais interessante do que "undefined".
========================================================= */
function S5_invariants(){
  log("=== S5 INVARIANTS (repeatability) ===");
  const N = 30;
  const seen = new Map();

  for (let iter=0; iter<N; iter++){
    const args = new Array(200);
    args.fill(0x2222);

    Object.defineProperty(args, 10, {
      get: () => { args.length = 0; return 0x3333; }
    });

    let r = null;
    function T(...x){ r = x; }
    try { Reflect.construct(T, args); } catch(e){ warn("iter "+iter+": " + e.message); continue; }

    // checa alguns índices altos
    const idxs = [50, 100, 150, 199];
    for (const i of idxs){
      const v = r[i];
      const key = "i" + i;
      const s = fmt(v) + "|" + (typeof v);
      if (!seen.has(key)) seen.set(key, new Set());
      seen.get(key).add(s);
    }
  }

  for (const [k,set] of seen.entries()){
    log(k + " uniqueValues=" + set.size + " => " + Array.from(set).join(", "));
    // GOLD: diversidade inesperada (não-determinismo)
    // Observação: pode ocorrer por diferenças legítimas, mas é um bom gatilho de investigação.
    if (set.size > 1) gold("Non-determinism detected at " + k);
  }
  log("S5 done.\n");
}

/* =========================================================
   S6: TypedArray detach sanity
   Verifica se detach no meio muda resultados de forma
   consistente. Não é exploit; é fingerprint + estabilidade.
========================================================= */
function S6_typedarray_detach(){
  log("=== S6 TYPEDARRAY DETACH ===");
  const buf = new ArrayBuffer(64);
  const u32 = new Uint32Array(buf);
  for (let i=0;i<u32.length;i++) u32[i] = 0x44440000 + i;

  const p = new Proxy(u32, {
    get(t,k,r){
      if (k === "length") return Reflect.get(t,k,r);
      if (k === "2") {
        try { postMessage(buf, [buf]); log("[*] detach attempted"); } catch(e){ warn("detach failed: "+e.message); }
      }
      return Reflect.get(t,k,r);
    }
  });

  const r = reflectRun(p, "typed_detach");
  if (r) log("Sample: r[0]=" + fmt(r[0]) + " r[3]=" + fmt(r[3]));
  log("S6 done.\n");
}

/* =========================================================
   S7: Cross-realm sanity (iframe)
   Verifica apenas consistência do comportamento em realm
   diferente e registra telemetria simples.
========================================================= */
function S7_cross_realm(){
  log("=== S7 CROSS REALM ===");
  const ifr = document.createElement("iframe");
  document.body.appendChild(ifr);

  try {
    const w = ifr.contentWindow;
    const args = new w.Array(100);
    args.fill(9);

    let lengthReads = 0;
    const p = new w.Proxy(args, {
      get(t,k,r){
        if (k === "length") lengthReads++;
        if (k === "5") t.length = 0;
        return w.Reflect.get(t,k,r);
      }
    });

    let got = null;
    function T(...x){ got = x; }
    w.Reflect.construct(T, p);

    log("received.length=" + (got ? got.length : "null") + " lengthReads=" + lengthReads);
    if (got) log("samples: " + [0,1,5,99].map(i=>("r["+i+"]="+fmt(got[i]))).join(" "));
  } catch(e){
    warn("cross-realm exception: " + e.message);
  } finally {
    ifr.remove();
  }
  log("S7 done.\n");
}
    function S6_typedarray_detach_FIXED(){
  log("=== S6 TYPEDARRAY DETACH (FIXED) ===");
  const buf = new ArrayBuffer(64);
  const u32 = new Uint32Array(buf);
  for (let i=0;i<u32.length;i++) u32[i] = 0x44440000 + i;

  let lengthReads = 0;
  let idxReads = 0;

  const p = new Proxy(u32, {
    get(t,k){
      if (k === "length") { lengthReads++; return t.length; }

      // dispara detach quando o engine tenta pegar o índice 2
      if (k === "2") {
        try { postMessage(buf, [buf]); log("[*] detach attempted"); } 
        catch(e){ warn("detach failed: " + e.message); }
      }

      // para índices numéricos, acessa direto no TypedArray (evita Reflect.get/receiver)
      if (typeof k === "string" && k === String(k|0)) {
        idxReads++;
        return t[k|0];
      }

      // fallback: propriedades comuns
      return t[k];
    }
  });

  let got=null;
  function T(...r){ got=r; }

  try {
    Reflect.construct(T, p);
    log("[typed_detach_fixed] OK. received.length=" + (got ? got.length : "null"));
    log("Telemetry: lengthReads=" + lengthReads + " idxReads=" + idxReads);
    if (got) log("Sample: r[0]=" + fmt(got[0]) + " r[2]=" + fmt(got[2]) + " r[3]=" + fmt(got[3]));
  } catch(e){
    warn("[typed_detach_fixed] EXCEPTION: " + e.message);
  }

  log("S6 fixed done.\n");
}
</script>
</body>
