<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v510000: Reverse Entry</title>
<style>
    body { background: #000; color: #ff0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #ff0; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #440; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #220; color: #fff; border: 2px solid #ff0;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #ff0; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v510000: REVERSE ENTRY</h1>

<div class="status" id="msg">
    ESTRATÉGIA: ALERTA -> CORRUPÇÃO -> FULLSCREEN<br>
    CLIQUE -> LEIA O ALERTA -> CLIQUE OK
</div>

<button onclick="reverse(r01)">01. Dead Element Fullscreen Race</button>

<button onclick="reverse(r02)">02. Video Overlay Detach Race</button>

<button onclick="reverse(r03)">03. Recursive DOM Fullscreen</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Variável para manter lixo na memória
    let junk = [];

    function reverse(vectorFunc) {
        Stage.innerHTML = "";
        junk = [];
        
        // 1. Prepara o cenário
        const target = vectorFunc(Stage);
        
        // 2. Executa a lógica com pequeno delay para renderizar o DOM inicial
        setTimeout(() => {
            if(target._trigger) target._trigger();
        }, 100);
    }

    // =================================================================
    // 01. Dead Element Fullscreen Race
    // A ideia: Criar um elemento, abrir o alerta.
    // Ao clicar OK: Remover o elemento do DOM e pedir Fullscreen DELE mesmo.
    // O WebKit antigo pode tentar colocar um elemento "morto" em tela cheia.
    // =================================================================
    function r01(stage) {
        const d = document.createElement('div');
        d.innerText = "DEAD TARGET";
        d.style.background = "red";
        d.style.width = "100%"; d.style.height = "100%";
        stage.appendChild(d);

        d._trigger = () => {
            // 1. A Pausa
            window.alert("⚠️ PREPARADO? ⚠️\n\nAo clicar OK, vamos destruir este elemento e forçar Fullscreen nele.");
            
            // 2. A Ação (Roda imediatamente após o OK)
            
            // Passo A: Destrói o elemento (Remove do DOM tree)
            d.remove();
            
            // Passo B: Tenta Fullscreen no elemento órfão
            // Em teoria, isso deveria falhar, mas se houver Race Condition,
            // o navegador tenta criar a janela de overlay para um objeto nulo.
            try {
                if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
                else if (d.requestFullscreen) d.requestFullscreen();
            } catch(e) {}
            
            // Passo C: Enche a memória onde o elemento estava
            for(let i=0; i<5000; i++) junk.push(new Uint32Array(1024).fill(0x41414141));
        };
        return d;
    }

    // =================================================================
    // 02. Video Overlay Detach Race
    // PS4 usa um "Hardware Overlay" para vídeo. É um plano separado.
    // Se pedirmos fullscreen num vídeo e destruirmos a tag <video> ao mesmo tempo,
    // o hardware overlay pode desincronizar do navegador.
    // =================================================================
    function r02(stage) {
        const v = document.createElement('video');
        // Usa um blob vazio ou vídeo curto se possível, aqui simulamos a tag
        v.src = ""; 
        v.controls = true;
        v.style.width = "100%";
        stage.appendChild(v);

        d._trigger = () => {
            window.alert("⚠️ VIDEO RACE ⚠️\n\nAo clicar OK: Destruir Vídeo -> Fullscreen.");
            
            // 1. Remove o vídeo
            v.remove();
            
            // 2. Pede Fullscreen no STAGE (Pai), mas o renderizador
            // ainda acha que tem que desenhar o vídeo que estava lá
            try {
                if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
                else if (stage.requestFullscreen) stage.requestFullscreen();
            } catch(e){}
            
            // 3. Spray de memória
            junk.push(new Float64Array(10000).fill(1.123456));
        };
        // Pequena adaptação para retornar o elemento correto
        return { _trigger: d._trigger }; 
    }

    // =================================================================
    // 03. Recursive DOM Fullscreen
    // Cria uma árvore profunda de elementos.
    // Ao clicar OK: Inverte a árvore e pede fullscreen.
    // Força recálculo massivo de layout durante a transição de vídeo.
    // =================================================================
    function r03(stage) {
        const root = document.createElement('div');
        let curr = root;
        // Cria 500 divs aninhadas
        for(let i=0; i<500; i++) {
            const el = document.createElement('div');
            el.style.padding = "1px";
            el.style.border = "1px solid red";
            curr.appendChild(el);
            curr = el;
        }
        stage.appendChild(root);

        root._trigger = () => {
            window.alert("⚠️ DOM INVERSION ⚠️\n\nAo clicar OK: Inverter DOM -> Fullscreen.");
            
            // 1. Modifica drasticamente o DOM (Reflow)
            stage.innerHTML = "<h1>CRASH?</h1>";
            
            // 2. Pede Fullscreen no corpo, forçando renderizar o novo estado
            // enquanto a memória antiga ainda está sendo limpa
            try {
                if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
                else if (document.body.requestFullscreen) document.body.requestFullscreen();
            } catch(e){}
            
            // 3. Loop síncrono para travar a thread de limpeza
            const start = Date.now();
            while(Date.now() - start < 200) { Math.random(); }
        };
        return root;
    }

</script>
</body>
</html>
