<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 WebKit Memory Corruption Fuzzer (Revisado)</title>
</head>
<body>
    <h1>PS4 WebKit Memory Corruption Fuzzer v2.0</h1>
    <p><strong>Objetivo:</strong> Detectar crashes reais do processo (CE-34878-0 / fechamento) com sequências reproduzíveis</p>
    <p><strong>Firmware Alvo:</strong> PS4 12.00</p>
    
    <hr>
    
    <h2>Status do Teste</h2>
    <div id="status">Aguardando início...</div>
    <div id="current-test"></div>
    
    <hr>
    
    <h2>Controles</h2>
    <button onclick="startFuzzing()">INICIAR FUZZING</button>
    <button onclick="stopFuzzing()">PARAR</button>
    <button onclick="clearLogs()">LIMPAR LOGS</button>
    <button onclick="showResults()">VER RESULTADOS</button>
    <button onclick="clearAllData()">LIMPAR TUDO (localStorage)</button>
    
    <hr>
    
    <h2>Log de Execução (Tempo Real)</h2>
    <div id="log"></div>
    
    <hr>
    
    <h2>Resultados Detectados</h2>
    <div id="results"></div>

    <script>
        // ============================================
        // SISTEMA DE PERSISTÊNCIA ROBUSTO
        // ============================================
        
        var STORAGE_KEY = 'ps4_fuzzer_state_v2';
        var RESULTS_KEY = 'ps4_fuzzer_results_v2';
        var running = false;
        var currentTestIndex = 0;
        var sessionId = Date.now();
        
        // Salvar estado (apenas a cada 5 iterações ou início de fase)
        function saveState(testName, iteration, phase, data) {
            var state = {
                running: true,
                test: testName,
                iteration: iteration,
                phase: phase || 'running',
                timestamp: new Date().toISOString(),
                sessionId: sessionId,
                data: data || {}
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            console.log('[STATE] ' + testName + ' iter=' + iteration + ' phase=' + phase);
        }
        
        // Marcar saída limpa (clean exit)
        function markCleanExit(reason) {
            var state = loadState();
            if (state) {
                state.running = false;
                state.exitReason = reason;
                state.exitTimestamp = new Date().toISOString();
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                console.log('[CLEAN EXIT] reason=' + reason);
            }
        }
        
        // Carregar último estado
        function loadState() {
            try {
                var saved = localStorage.getItem(STORAGE_KEY);
                return saved ? JSON.parse(saved) : null;
            } catch(e) {
                return null;
            }
        }
        
        // Limpar estado após teste bem-sucedido
        function clearState() {
            localStorage.removeItem(STORAGE_KEY);
            console.log('[STATE CLEARED]');
        }
        
        // Salvar resultado (crash, telemetria, etc.)
        function saveResult(type, testName, category, message, details) {
            var results = [];
            try {
                var saved = localStorage.getItem(RESULTS_KEY);
                results = saved ? JSON.parse(saved) : [];
            } catch(e) {}
            
            results.push({
                type: type, // 'CRASH', 'TELEMETRY', 'INVARIANT', 'EVENT'
                test: testName,
                category: category, // 'DOM', 'History', 'TypedArray', etc.
                message: message,
                timestamp: new Date().toISOString(),
                details: details || {}
            });
            
            localStorage.setItem(RESULTS_KEY, JSON.stringify(results));
            console.log('[' + type + '] ' + testName + ' - ' + message);
        }
        
        // ============================================
        // DETECÇÃO DE CRASH REAL (SEM FALSOS POSITIVOS)
        // ============================================
        
        function detectRealCrash() {
            var lastState = loadState();
            
            if (!lastState) {
                return null; // Nenhum estado anterior
            }
            
            // Se tem marca de clean exit, não foi crash
            if (!lastState.running || lastState.exitReason) {
                console.log('[NO CRASH] Last exit was clean: ' + lastState.exitReason);
                clearState(); // Limpar estado antigo
                return null;
            }
            
            // Se running=true e sem exitReason = possível crash
            var timeDiff = Date.now() - new Date(lastState.timestamp).getTime();
            
            // Se passou muito tempo (>1h), pode ser reload manual
            if (timeDiff > 3600000) {
                console.log('[UNCERTAIN] State too old (' + Math.floor(timeDiff/60000) + 'min), ignoring');
                clearState();
                return null;
            }
            
            // CRASH REAL DETECTADO
            return {
                test: lastState.test,
                iteration: lastState.iteration,
                phase: lastState.phase,
                timestamp: lastState.timestamp,
                data: lastState.data
            };
        }
        
        // ============================================
        // LOGGER
        // ============================================
        
        function log(msg, isError) {
            var logDiv = document.getElementById('log');
            var time = new Date().toLocaleTimeString();
            var p = document.createElement('p');
            p.textContent = '[' + time + '] ' + msg;
            p.style.color = isError ? 'red' : 'black';
            logDiv.appendChild(p);
            
            while (logDiv.children.length > 50) {
                logDiv.removeChild(logDiv.firstChild);
            }
            
            console.log('[' + time + '] ' + msg);
        }
        
        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }
        
        function updateCurrentTest(testName) {
            document.getElementById('current-test').innerHTML = '<strong>Teste Atual:</strong> ' + testName;
        }
        
        // ============================================
        // TESTES REVISADOS (FOCO EM CRASH REAL)
        // ============================================
        
        // TESTE 1: DOM UAF Patterns (com reentrância)
        function test_DOM_UAF() {
            var testName = 'DOM_UAF';
            updateCurrentTest(testName);
            log('Iniciando ' + testName);
            
            try {
                saveState(testName, 0, 'init', {});
                
                for (var i = 0; i < 30; i++) {
                    if (i % 5 === 0) {
                        saveState(testName, i, 'iteration', {i: i});
                    }
                    
                    // Criar estrutura DOM com atributos
                    var div = document.createElement('div');
                    var attr1 = document.createAttribute('data-test');
                    var attr2 = document.createAttribute('id');
                    
                    attr1.value = 'value_' + i;
                    attr2.value = 'id_' + i;
                    
                    div.setAttributeNode(attr1);
                    div.setAttributeNode(attr2);
                    document.body.appendChild(div);
                    
                    // Criar event listener que pode causar reentrância
                    div.addEventListener('DOMAttrModified', function(e) {
                        try {
                            e.target.removeAttribute('data-test');
                        } catch(ex) {}
                    });
                    
                    // Remover do DOM mas manter referência
                    var attrRef = div.attributes[0];
                    document.body.removeChild(div);
                    
                    // Tentar acessar (telemetria, não "crash detectado")
                    try {
                        var v = attrRef.value;
                        var n = attrRef.name;
                    } catch(e) {
                        saveResult('TELEMETRY', testName, 'DOM', 
                            e.name + ': ' + e.message, {iteration: i});
                    }
                }
                
                markCleanExit('test_completed');
                clearState();
                log(testName + ' concluído: SEM CRASH');
            } catch(e) {
                saveResult('TELEMETRY', testName, 'DOM', 
                    'Exception: ' + e.name + ' - ' + e.message, {});
                markCleanExit('exception');
            }
        }
        
        // TESTE 2: History Event-Driven (com popstate real)
        function test_History_Events() {
            var testName = 'History_Events';
            updateCurrentTest(testName);
            log('Iniciando ' + testName + ' (event-driven)');
            
            var popstateCount = 0;
            var pushCount = 0;
            
            // Instalar handler de popstate
            var popstateHandler = function(e) {
                popstateCount++;
                console.log('[POPSTATE EVENT] count=' + popstateCount + ' state=' + 
                    (e.state ? JSON.stringify(e.state) : 'null'));
                saveResult('EVENT', testName, 'History', 'popstate fired', {
                    count: popstateCount,
                    state: e.state
                });
            };
            
            window.addEventListener('popstate', popstateHandler);
            
            try {
                saveState(testName, 0, 'init', {});
                
                // Push múltiplos estados
                for (var i = 0; i < 20; i++) {
                    if (i % 5 === 0) {
                        saveState(testName, i, 'pushing', {i: i, pushCount: pushCount});
                    }
                    
                    var stateObj = {
                        id: i,
                        data: new Array(50),
                        timestamp: Date.now()
                    };
                    
                    // Preencher array
                    for (var j = 0; j < 50; j++) {
                        stateObj.data[j] = (i * 1000) + j;
                    }
                    
                    history.pushState(stateObj, '', '#state' + i);
                    pushCount++;
                    
                    // Validar que foi salvo
                    var retrieved = history.state;
                    if (!retrieved || retrieved.id !== i) {
                        saveResult('INVARIANT', testName, 'History', 
                            'State mismatch after push', {
                            expected: i,
                            got: retrieved ? retrieved.id : 'null'
                        });
                    }
                }
                
                saveState(testName, pushCount, 'going_back', {pushCount: pushCount});
                
                // Voltar e esperar eventos
                log('Navegando back para disparar popstate...');
                for (var i = 0; i < 5; i++) {
                    history.back();
                }
                
                // Aguardar eventos assíncronos (importante!)
                setTimeout(function() {
                    window.removeEventListener('popstate', popstateHandler);
                    
                    log('popstate disparado ' + popstateCount + ' vezes');
                    saveResult('TELEMETRY', testName, 'History', 
                        'Test completed', {
                        pushCount: pushCount,
                        popstateCount: popstateCount
                    });
                    
                    markCleanExit('test_completed');
                    clearState();
                    log(testName + ' concluído: SEM CRASH (popstate=' + popstateCount + ')');
                    
                    // Próximo teste
                    setTimeout(continueToNextTest, 500);
                }, 1000);
                
                return; // Sair sem chamar continueToNextTest aqui
                
            } catch(e) {
                window.removeEventListener('popstate', popstateHandler);
                saveResult('TELEMETRY', testName, 'History', 
                    'Exception: ' + e.name + ' - ' + e.message, {});
                markCleanExit('exception');
            }
        }
        
        // TESTE 3: TypedArray Sanity (como canário, não detector)
        function test_TypedArray_Sanity() {
            var testName = 'TypedArray_Sanity';
            updateCurrentTest(testName);
            log('Iniciando ' + testName + ' (canário de invariantes)');
            
            try {
                saveState(testName, 0, 'init', {});
                
                for (var i = 0; i < 30; i++) {
                    if (i % 5 === 0) {
                        saveState(testName, i, 'iteration', {i: i});
                    }
                    
                    var size = 256 + (i * 64);
                    var buffer = new ArrayBuffer(size);
                    var view1 = new Uint32Array(buffer);
                    var view2 = new Float64Array(buffer);
                    
                    // Preencher
                    for (var j = 0; j < view1.length; j++) {
                        view1[j] = j * 0xDEADBEEF;
                    }
                    
                    // Validar invariantes básicos
                    if (buffer.byteLength !== size) {
                        saveResult('INVARIANT', testName, 'TypedArray', 
                            'Buffer size mismatch', {
                            expected: size,
                            got: buffer.byteLength,
                            iteration: i
                        });
                    }
                    
                    if ((view1.length * 4) !== buffer.byteLength) {
                        saveResult('INVARIANT', testName, 'TypedArray', 
                            'View1 length inconsistent', {
                            view1Length: view1.length,
                            bufferLength: buffer.byteLength,
                            iteration: i
                        });
                    }
                    
                    if ((view2.length * 8) !== buffer.byteLength) {
                        saveResult('INVARIANT', testName, 'TypedArray', 
                            'View2 length inconsistent', {
                            view2Length: view2.length,
                            bufferLength: buffer.byteLength,
                            iteration: i
                        });
                    }
                    
                    // Tentativa de criar view com offset inválido (guard-rail esperado)
                    try {
                        var badView = new Uint32Array(buffer, 1);
                        // Se não lançou exceção, isso é estranho
                        saveResult('TELEMETRY', testName, 'TypedArray', 
                            'Misaligned view allowed', {iteration: i});
                    } catch(e) {
                        // Esperado - guard-rail funcionou
                    }
                }
                
                markCleanExit('test_completed');
                clearState();
                log(testName + ' concluído: SEM CRASH');
            } catch(e) {
                saveResult('TELEMETRY', testName, 'TypedArray', 
                    'Exception: ' + e.name + ' - ' + e.message, {});
                markCleanExit('exception');
            }
        }
        
        // TESTE 4: Canvas + ImageData (pressão de memória controlada)
        function test_Canvas_ImageData() {
            var testName = 'Canvas_ImageData';
            updateCurrentTest(testName);
            log('Iniciando ' + testName);
            
            try {
                saveState(testName, 0, 'init', {});
                
                var canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                var ctx = canvas.getContext('2d');
                
                for (var i = 0; i < 25; i++) {
                    if (i % 5 === 0) {
                        saveState(testName, i, 'iteration', {i: i});
                    }
                    
                    // Obter imageData grande
                    var imageData = ctx.getImageData(0, 0, 512, 512);
                    var data = imageData.data;
                    var originalLength = data.length;
                    
                    // Manipular pixels
                    for (var j = 0; j < 10000; j++) {
                        data[j] = (i * j) & 0xFF;
                    }
                    
                    // Colocar de volta
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Verificar que não houve corrupção no length
                    var verify = ctx.getImageData(0, 0, 512, 512);
                    if (verify.data.length !== originalLength) {
                        saveResult('INVARIANT', testName, 'Canvas', 
                            'ImageData length changed', {
                            original: originalLength,
                            after: verify.data.length,
                            iteration: i
                        });
                    }
                    
                    // Verificar alguns pixels
                    var mismatch = false;
                    for (var j = 0; j < 100; j++) {
                        if (verify.data[j] !== data[j]) {
                            mismatch = true;
                            break;
                        }
                    }
                    
                    if (mismatch) {
                        saveResult('INVARIANT', testName, 'Canvas', 
                            'Pixel data mismatch after putImageData', {iteration: i});
                    }
                }
                
                markCleanExit('test_completed');
                clearState();
                log(testName + ' concluído: SEM CRASH');
            } catch(e) {
                saveResult('TELEMETRY', testName, 'Canvas', 
                    'Exception: ' + e.name + ' - ' + e.message, {});
                markCleanExit('exception');
            }
        }
        
        // TESTE 5: Determinismo (checksum múltiplo)
        function test_Determinism() {
            var testName = 'Determinism';
            updateCurrentTest(testName);
            log('Iniciando ' + testName + ' (3 execuções idênticas)');
            
            try {
                saveState(testName, 0, 'init', {});
                
                var results = [];
                
                for (var run = 0; run < 3; run++) {
                    saveState(testName, run, 'run', {run: run});
                    
                    var buffer = new ArrayBuffer(512);
                    var view = new Uint32Array(buffer);
                    
                    // Sequência determinística
                    for (var i = 0; i < 128; i++) {
                        view[i] = (i * 0xCAFEBABE) | 0;
                    }
                    
                    // Calcular checksum simples
                    var sum = 0;
                    for (var i = 0; i < 128; i++) {
                        sum = (sum + view[i]) | 0; // Manter em 32-bit
                    }
                    
                    results.push(sum);
                    log('Run ' + run + ': checksum=' + sum);
                }
                
                // Comparar
                if (results[0] !== results[1] || results[1] !== results[2]) {
                    saveResult('INVARIANT', testName, 'Determinism', 
                        'Non-deterministic behavior detected', {
                        run1: results[0],
                        run2: results[1],
                        run3: results[2]
                    });
                    log('DIVERGÊNCIA DETECTADA!', true);
                } else {
                    log('Comportamento determinístico: OK');
                }
                
                markCleanExit('test_completed');
                clearState();
                log(testName + ' concluído: SEM CRASH');
            } catch(e) {
                saveResult('TELEMETRY', testName, 'Determinism', 
                    'Exception: ' + e.name + ' - ' + e.message, {});
                markCleanExit('exception');
            }
        }
        
        // ============================================
        // ORQUESTRADOR
        // ============================================
        
        var tests = [
            {name: 'DOM UAF', func: test_DOM_UAF},
            {name: 'History Events', func: test_History_Events, async: true},
            {name: 'TypedArray Sanity', func: test_TypedArray_Sanity},
            {name: 'Canvas ImageData', func: test_Canvas_ImageData},
            {name: 'Determinism', func: test_Determinism}
        ];
        
        function continueToNextTest() {
            currentTestIndex++;
            runNextTest();
        }
        
        function runNextTest() {
            if (!running || currentTestIndex >= tests.length) {
                running = false;
                updateStatus('Fuzzing concluído');
                log('=== FUZZING COMPLETO ===');
                showResults();
                return;
            }
            
            var test = tests[currentTestIndex];
            log('');
            log('=== TESTE ' + (currentTestIndex + 1) + '/' + tests.length + ': ' + test.name + ' ===');
            
            setTimeout(function() {
                test.func();
                
                // Se não é async, continuar imediatamente
                if (!test.async) {
                    setTimeout(continueToNextTest, 1000);
                }
                // Se é async, o próprio teste chama continueToNextTest()
            }, 500);
        }
        
        function startFuzzing() {
            if (running) {
                log('Fuzzing já está rodando!');
                return;
            }
            
            running = true;
            currentTestIndex = 0;
            
            log('=== INICIANDO FUZZING ===');
            log('Data/Hora: ' + new Date().toString());
            log('UserAgent: ' + navigator.userAgent);
            log('Total de testes: ' + tests.length);
            log('');
            
            updateStatus('Fuzzing em execução...');
            runNextTest();
        }
        
        function stopFuzzing() {
            running = false;
            markCleanExit('user_stop');
            updateStatus('Fuzzing parado pelo usuário');
            log('Fuzzing interrompido');
        }
        
        function clearLogs() {
            document.getElementById('log').innerHTML = '';
            log('Logs limpos');
        }
        
        function clearAllData() {
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(RESULTS_KEY);
            log('Todos os dados removidos do localStorage');
            showResults();
        }
        
        function showResults() {
            var resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            try {
                var saved = localStorage.getItem(RESULTS_KEY);
                var results = saved ? JSON.parse(saved) : [];
                
                if (results.length === 0) {
                    resultsDiv.innerHTML = '<p>Nenhum resultado ainda</p>';
                    return;
                }
                
                // Agrupar por tipo
                var crashes = results.filter(function(r) { return r.type === 'CRASH'; });
                var invariants = results.filter(function(r) { return r.type === 'INVARIANT'; });
                var telemetry = results.filter(function(r) { return r.type === 'TELEMETRY'; });
                var events = results.filter(function(r) { return r.type === 'EVENT'; });
                
                resultsDiv.innerHTML = '<h3>Resumo</h3>' +
                    '<p>CRASHES: ' + crashes.length + '</p>' +
                    '<p>INVARIANTES QUEBRADOS: ' + invariants.length + '</p>' +
                    '<p>TELEMETRIA: ' + telemetry.length + '</p>' +
                    '<p>EVENTOS: ' + events.length + '</p>';
                
                // Mostrar crashes
                if (crashes.length > 0) {
                    resultsDiv.innerHTML += '<h3>CRASHES DETECTADOS</h3>';
                    for (var i = 0; i < crashes.length; i++) {
                        var c = crashes[i];
                        resultsDiv.innerHTML += '<hr>' +
                            '<p><strong>Teste:</strong> ' + c.test + '</p>' +
                            '<p><strong>Categoria:</strong> ' + c.category + '</p>' +
                            '<p><strong>Mensagem:</strong> ' + c.message + '</p>' +
                            '<p><strong>Timestamp:</strong> ' + c.timestamp + '</p>' +
                            '<p><strong>Detalhes:</strong> ' + JSON.stringify(c.details) + '</p>';
                    }
                }
                
                // Mostrar invariantes
                if (invariants.length > 0) {
                    resultsDiv.innerHTML += '<h3>INVARIANTES QUEBRADOS</h3>';
                    for (var i = 0; i < invariants.length; i++) {
                        var inv = invariants[i];
                        resultsDiv.innerHTML += '<hr>' +
                            '<p><strong>Teste:</strong> ' + inv.test + '</p>' +
                            '<p><strong>Categoria:</strong> ' + inv.category + '</p>' +
                            '<p><strong>Mensagem:</strong> ' + inv.message + '</p>' +
                            '<p><strong>Detalhes:</strong> ' + JSON.stringify(inv.details) + '</p>';
                    }
                }
                
            } catch(e) {
                resultsDiv.innerHTML = '<p>Erro ao carregar resultados: ' + e.message + '</p>';
            }
        }
        
        // ============================================
        // INICIALIZAÇÃO E DETECÇÃO DE CRASH
        // ============================================
        
        window.onload = function() {
            log('Fuzzer carregado');
            log('UserAgent: ' + navigator.userAgent);
            
            // Detectar crash real (sem falsos positivos)
            var crash = detectRealCrash();
            if (crash) {
                log('=== CRASH REAL DETECTADO ===', true);
                log('Teste: ' + crash.test, true);
                log('Iteração: ' + crash.iteration, true);
                log('Fase: ' + crash.phase, true);
                log('Timestamp: ' + crash.timestamp, true);
                log('PROCESSO DO NAVEGADOR CRASHOU!', true);
                
                saveResult('CRASH', crash.test, 'BrowserCrash', 
                    'Processo crashou durante teste', crash.data);
                
                clearState(); // Limpar para próxima execução
            }
            
            showResults();
            updateStatus('Pronto para iniciar');
        };
        
        // Marcar clean exit em eventos de saída normal
        window.addEventListener('beforeunload', function() {
            if (running) {
                markCleanExit('page_unload');
            }
        });
        
        window.addEventListener('pagehide', function() {
            if (running) {
                markCleanExit('page_hide');
            }
        });
        
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && running) {
                markCleanExit('visibility_change');
            }
        });
    </script>

    <hr>
    
    <h2>Metodologia Revisada (v2.0)</h2>
    
    <h3>Como Detectamos Crash REAL (sem falsos positivos):</h3>
    <ul>
        <li><strong>Clean Exit Marker:</strong> Toda saída normal marca exitReason (user_stop, page_unload, test_completed)</li>
        <li><strong>Crash = Estado Sujo:</strong> Se running=true E sem exitReason = crash real</li>
        <li><strong>Eventos de saída:</strong> beforeunload, pagehide, visibilitychange marcam clean exit</li>
        <li><strong>Timeout de 1h:</strong> Estados muito antigos são descartados (não são crashes)</li>
    </ul>
    
    <h3>Categorias de Resultados:</h3>
    <ul>
        <li><strong>CRASH:</strong> Processo do navegador morreu (CE-34878-0 ou fechamento)</li>
        <li><strong>INVARIANT:</strong> Propriedade do objeto em estado impossível (forte evidência de corrupção)</li>
        <li><strong>TELEMETRY:</strong> Exceções JS, guard-rails atingidos (não são crashes)</li>
        <li><strong>EVENT:</strong> Eventos disparados (popstate, etc.) para validar execução</li>
    </ul>
    
    <h3>Testes e Objetivos:</h3>
    <ol>
        <li><strong>DOM UAF:</strong> Use-after-free com reentrância em eventos (sanidade)</li>
        <li><strong>History Events:</strong> Event-driven com popstate real e validação assíncrona</li>
        <li><strong>TypedArray Sanity:</strong> Canário de invariantes (não detector)</li>
        <li><strong>Canvas ImageData:</strong> Pressão de memória controlada com validação</li>
        <li><strong>Determinism:</strong> Detecta não-determinismo (UB forte)</li>
    </ol>
    
    <h3>Mudanças Principais:</h3>
    <ul>
        <li>✅ Clean exit marker (sem falsos positivos de reload/voltar)</li>
        <li>✅ Persistência a cada 5 iterações (não toda iteração)</li>
        <li>✅ History com popstate event-driven real</li>
        <li>✅ Exceções JS = telemetria (não "crash detectado")</li>
        <li>✅ Testes como sanidade/canários (realismo sobre poder de detecção)</li>
        <li>✅ Timeout de 1h para estados antigos</li>
    </ul>
    
    <h3>Entregável para Análise:</h3>
    <p>Para cada execução, você terá:</p>
    <ul>
        <li><strong>Resultado:</strong> CRASH / INVARIANT / TELEMETRY / EVENT</li>
        <li><strong>Superfície:</strong> DOM / History / TypedArray / Canvas / Determinism</li>
        <li><strong>Se crash:</strong> Teste exato, iteração, fase, timestamp</li>
        <li><strong>Se invariante:</strong> Detalhes do estado impossível</li>
        <li><strong>Console.log:</strong> Todos os eventos importantes (sobrevive a crash)</li>
    </ul>
    
    <h3>Interpretação dos Resultados:</h3>
    <table border="1">
        <tr>
            <th>Resultado</th>
            <th>Significado</th>
            <th>Prioridade</th>
        </tr>
        <tr>
            <td>CRASH</td>
            <td>Processo morreu - crash real detectado</td>
            <td>CRÍTICA</td>
        </tr>
        <tr>
            <td>INVARIANT (Non-determinism)</td>
            <td>UB/memory corruption muito provável</td>
            <td>ALTA</td>
        </tr>
        <tr>
            <td>INVARIANT (Length mismatch)</td>
            <td>Estado inconsistente - corrupção possível</td>
            <td>ALTA</td>
        </tr>
        <tr>
            <td>TELEMETRY</td>
            <td>Guard-rail ou exceção JS - não é crash</td>
            <td>BAIXA</td>
        </tr>
        <tr>
            <td>EVENT</td>
            <td>Validação de execução - teste funcionou</td>
            <td>INFO</td>
        </tr>
    </table>
    
    <h3>Como Usar no PS4:</h3>
    <ol>
        <li>Abra esta página no navegador do PS4</li>
        <li>Clique em "INICIAR FUZZING"</li>
        <li>Aguarde (~1-2 minutos para todos os testes)</li>
        <li><strong>Se o navegador crashar (CE-34878-0):</strong> Reabra a página - o crash será detectado automaticamente</li>
        <li>Clique em "VER RESULTADOS" para análise</li>
        <li>Verifique console do navegador (se disponível) para logs detalhados</li>
    </ol>
    
    <footer>
        <hr>
        <p><small>PS4 WebKit Memory Corruption Fuzzer v2.0 (Revisado)</small></p>
        <p><small>Foco em detecção de crash real sem falsos positivos</small></p>
        <p><small>Clean exit markers + Event-driven + Sanidade realista</small></p>
    </footer>
</body>
</html>
