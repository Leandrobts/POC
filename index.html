<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PS4 WebKit – Sanity/Crash Hunting Suite (20 testes)</title>
  <style>
    body { background:#000; color:#0f0; font-family:monospace; margin:12px; }
    h1,h2 { color:#9f9; margin:8px 0; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    button { background:#111; color:#0f0; border:1px solid #0f0; padding:10px 12px; cursor:pointer; }
    button:hover { background:#0f0; color:#000; }
    #log { white-space:pre-wrap; border:1px solid #0f0; padding:10px; height:420px; overflow:auto; background:#060606; }
    .muted { color:#6f6; }
  </style>
</head>
<body>
  <h1>PS4 WebKit – Sanity/Crash Hunting Suite (20 testes)</h1>
  <div class="muted">
    Foco: encontrar novos vetores de crash/CE (sem exploração).<br>
    Dica: rode 1 por vez; se travar, anote o último "STEP" no log.
  </div>

  <div class="row" style="margin:10px 0;">
    <button onclick="clearLog()">CLEAR</button>
    <button onclick="resetEnv()">RESET DOM</button>
    <button onclick="stopLoop()">STOP LOOP</button>
    <button onclick="loopAll(30)">LOOP ALL x30</button>
  </div>

  <h2>Testes (clique para executar)</h2>
  <div class="row">
    <button onclick="run(T01)">T01 SVG Path metrics + mutação</button>
    <button onclick="run(T02)">T02 SVG getBBox/getCTM + teardown</button>
    <button onclick="run(T03)">T03 SVG filters (blur) + remoção</button>
    <button onclick="run(T04)">T04 SVG foreignObject + subtree churn</button>

    <button onclick="run(T05)">T05 Range.surroundContents + remoção</button>
    <button onclick="run(T06)">T06 Range.extractContents + normalize</button>
    <button onclick="run(T07)">T07 Selection churn + DOM rewrite</button>
    <button onclick="run(T08)">T08 TreeWalker/NodeIterator + remoção</button>

    <button onclick="run(T09)">T09 MutationObserver reentrância + flush</button>
    <button onclick="run(T10)">T10 ResizeObserver loop (se houver)</button>
    <button onclick="run(T11)">T11 IntersectionObserver churn (se houver)</button>

    <button onclick="run(T12)">T12 Canvas2D resize + get/putImageData</button>
    <button onclick="run(T13)">T13 Canvas2D pattern/gradient + teardown</button>
    <button onclick="run(T14)">T14 Image decode data: + remove/reuse</button>
    <button onclick="run(T15)">T15 createImageBitmap (se houver)</button>

    <button onclick="run(T16)">T16 WebAudio graph churn (se houver)</button>
    <button onclick="run(T17)">T17 FontFace load churn (se houver)</button>

    <button onclick="run(T18)">T18 History/hashchange + teardown</button>
    <button onclick="run(T19)">T19 CSS variables/calc + layout thrash</button>
    <button onclick="run(T20)">T20 Shadow DOM/slots churn (se houver)</button>
  </div>

  <pre id="log">Status: pronto.</pre>

<script>
/* =========================
   Infra / Logger
========================= */
const logEl = document.getElementById('log');
let keeper = [];
let loopTimer = null;
let loopStop = false;
let lastTestName = "";

function ts(){
  const d = new Date();
  const z = (n)=>String(n).padStart(2,'0');
  return `${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,'0')}`;
}
function log(s){ logEl.textContent += `\n[${ts()}] ${s}`; logEl.scrollTop = logEl.scrollHeight; }
function warn(s){ log(`WARN: ${s}`); }
function step(s){ log(`STEP: ${s}`); }
function ok(s){ log(`OK: ${s}`); }

function clearLog(){ logEl.textContent = "Status: pronto."; }
function stopLoop(){ loopStop = true; if (loopTimer) { clearTimeout(loopTimer); loopTimer=null; } log("LOOP: stop solicitado."); }

function resetEnv(){
  stopLoop();
  keeper = [];
  // limpa body extra, preserva UI
  const nodes = Array.from(document.body.querySelectorAll(".sandbox"));
  for (const n of nodes) n.remove();
  ok("RESET: sandbox limpo.");
}

function run(fn){
  stopLoop();
  keeper = [];
  lastTestName = fn.name;
  log(`\n=== RUN ${fn.name} ===`);
  // isola execução e captura exceções
  setTimeout(() => {
    try { fn(); }
    catch(e){ warn(`${fn.name} exception: ${e && e.message ? e.message : e}`); }
    finally { ok(`${fn.name} finished (se não travou).`); }
  }, 0);
}

function loopAll(n){
  stopLoop();
  loopStop = false;
  const tests = [T01,T02,T03,T04,T05,T06,T07,T08,T09,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20];
  let i = 0, iter = 0;
  log(`\n=== LOOP ALL start: ${n} iterações ===`);
  const tick = () => {
    if (loopStop) { ok("LOOP ALL stopped."); return; }
    if (iter >= n) { ok("LOOP ALL concluído."); return; }
    const fn = tests[i];
    keeper = [];
    lastTestName = fn.name;
    log(`\n--- LOOP iter=${iter+1}/${n} test=${fn.name} ---`);
    try { fn(); } catch(e){ warn(`${fn.name} exception: ${e && e.message ? e.message : e}`); }
    i++;
    if (i >= tests.length) { i=0; iter++; }
    loopTimer = setTimeout(tick, 60); // pequeno delay para variar timing
  };
  loopTimer = setTimeout(tick, 50);
}

/* =========================
   Helpers
========================= */
function mkSandbox(){
  const d = document.createElement('div');
  d.className = "sandbox";
  d.style.cssText = "position:relative; border:1px dashed #0f0; margin:10px 0; padding:8px;";
  document.body.appendChild(d);
  return d;
}

function forceLayout(el){
  // pequenas leituras que tendem a forçar flush de layout
  try { void el.offsetHeight; } catch(e){}
  try { void el.getBoundingClientRect(); } catch(e){}
  try { void getComputedStyle(el).width; } catch(e){}
}

function heapPressure(bytesKB){
  // pressão moderada, não agressiva a ponto de parecer DoS intencional
  const n = Math.max(32, Math.min(512, bytesKB|0));
  const arr = [];
  for (let i=0;i<n;i++) arr.push(new Uint8Array(1024));
  keeper.push(arr);
}

/* =========================================================
   01–04: SVG
========================================================= */
function T01(){
  const box = mkSandbox();
  step("Criando SVG path e alternando atributo 'd' enquanto chama getTotalLength()");
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns,'svg');
  svg.setAttribute('width','320'); svg.setAttribute('height','120');
  const path = document.createElementNS(ns,'path');
  path.setAttribute('stroke','#0f0'); path.setAttribute('fill','none'); path.setAttribute('stroke-width','2');
  svg.appendChild(path); box.appendChild(svg);

  for (let i=0;i<80;i++){
    const d = `M 5 ${10+(i%80)} C 80 ${10+(i%50)} 160 ${110-(i%90)} 315 ${10+(i%80)}`;
    path.setAttribute('d', d);
    // métricas de path costumam tocar código interno SVG
    try { path.getTotalLength(); } catch(e){ warn("getTotalLength: "+e.message); }
    if (i % 10 === 0) forceLayout(svg);
  }
  ok("SVG path metrics loop concluído.");
}

function T02(){
  const box = mkSandbox();
  step("SVG getBBox/getCTM + remover/reanexar elemento durante leituras");
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns,'svg');
  svg.setAttribute('width','320'); svg.setAttribute('height','160');
  const g = document.createElementNS(ns,'g');
  const r = document.createElementNS(ns,'rect');
  r.setAttribute('x','10'); r.setAttribute('y','10'); r.setAttribute('width','120'); r.setAttribute('height','80');
  r.setAttribute('fill','#0a0');
  g.appendChild(r); svg.appendChild(g); box.appendChild(svg);

  for (let i=0;i<120;i++){
    r.setAttribute('transform', `translate(${(i%20)},${(i%30)}) rotate(${i%30})`);
    try { r.getBBox(); } catch(e){ warn("getBBox: "+e.message); }
    try { r.getCTM && r.getCTM(); } catch(e){ warn("getCTM: "+e.message); }
    if (i === 40){ step("Teardown parcial: remove rect"); r.remove(); }
    if (i === 60){ step("Reanexando rect"); g.appendChild(r); }
    if (i % 15 === 0) forceLayout(svg);
  }
  ok("SVG bbox/ctm churn concluído.");
}

function T03(){
  const box = mkSandbox();
  step("SVG filter (GaussianBlur) alternando + remoção do nó");
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns,'svg');
  svg.setAttribute('width','320'); svg.setAttribute('height','160');

  const defs = document.createElementNS(ns,'defs');
  const filter = document.createElementNS(ns,'filter');
  filter.setAttribute('id','f1');
  const blur = document.createElementNS(ns,'feGaussianBlur');
  blur.setAttribute('stdDeviation','2');
  filter.appendChild(blur);
  defs.appendChild(filter);
  svg.appendChild(defs);

  const rect = document.createElementNS(ns,'rect');
  rect.setAttribute('x','10'); rect.setAttribute('y','10'); rect.setAttribute('width','280'); rect.setAttribute('height','120');
  rect.setAttribute('fill','#090');
  rect.setAttribute('filter','url(#f1)');
  svg.appendChild(rect);
  box.appendChild(svg);

  for (let i=0;i<140;i++){
    blur.setAttribute('stdDeviation', String((i%10)+0.2));
    rect.setAttribute('opacity', String((i%10)/10));
    if (i === 60){ step("Removendo rect durante filter churn"); rect.remove(); }
    if (i === 80){ step("Reanexando rect"); svg.appendChild(rect); }
    if (i % 10 === 0) forceLayout(svg);
  }
  ok("SVG filter churn concluído.");
}

function T04(){
  const box = mkSandbox();
  step("SVG foreignObject com subtree HTML churn (cria/remove) + medições");
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns,'svg');
  svg.setAttribute('width','360'); svg.setAttribute('height','160');
  const fo = document.createElementNS(ns,'foreignObject');
  fo.setAttribute('x','10'); fo.setAttribute('y','10'); fo.setAttribute('width','340'); fo.setAttribute('height','140');
  const div = document.createElement('div');
  div.style.cssText = "font-size:14px; color:#0f0; border:1px solid #0f0;";
  div.textContent = "foreignObject";
  fo.appendChild(div);
  svg.appendChild(fo);
  box.appendChild(svg);

  for (let i=0;i<80;i++){
    // churn subtree
    const span = document.createElement('span');
    span.textContent = " #" + i + " ";
    div.appendChild(span);
    if (i % 5 === 0) div.innerHTML = "reset " + i; // rewrite
    if (i % 7 === 0) forceLayout(svg);
    if (i === 40){ step("Remove foreignObject"); fo.remove(); }
    if (i === 55){ step("Re-add foreignObject"); svg.appendChild(fo); }
  }
  ok("SVG foreignObject churn concluído.");
}

/* =========================================================
   05–08: Range/Selection/Traversal
========================================================= */
function T05(){
  const box = mkSandbox();
  step("Range.surroundContents + remover nós alvo durante operação");
  const host = document.createElement('div');
  host.innerHTML = "<p>AAA <b>BBB</b> CCC <i>DDD</i> EEE</p>";
  box.appendChild(host);

  const p = host.querySelector('p');
  const b = host.querySelector('b');
  const iel = host.querySelector('i');

  const r = document.createRange();
  r.setStart(p.firstChild, 0);
  r.setEnd(iel.firstChild, 2);

  const wrap = document.createElement('span');
  wrap.style.cssText = "border:1px solid #0f0;";

  try {
    // teardown em timing microtask
    Promise.resolve().then(() => { step("Microtask: removendo <b>"); b.remove(); });
    r.surroundContents(wrap);
    ok("surroundContents OK");
  } catch(e){
    warn("surroundContents exception: " + e.message);
  }
  forceLayout(host);
}

function T06(){
  const box = mkSandbox();
  step("Range.extractContents + normalize + rewrite");
  const host = document.createElement('div');
  host.innerHTML = "<div id='x'>Hello <span>World</span> <em>!!</em> <u>test</u></div>";
  box.appendChild(host);
  const x = host.querySelector('#x');

  const r = document.createRange();
  r.setStart(x.firstChild, 2);
  r.setEnd(x.querySelector('u').firstChild, 2);

  for (let k=0;k<30;k++){
    try {
      const frag = r.extractContents();
      keeper.push(frag);
      x.normalize();
      if (k % 3 === 0) x.innerHTML += "<span>.</span>";
      if (k % 5 === 0) x.innerHTML = "<span>reset</span>" + k;
    } catch(e){
      warn("extract/normalize exception: " + e.message);
      break;
    }
    forceLayout(x);
  }
  ok("Range extract loop concluído (ou interrompido por exceção).");
}

function T07(){
  const box = mkSandbox();
  step("Selection churn + DOM rewrite (sem execCommand)");
  const host = document.createElement('div');
  host.contentEditable = "true";
  host.style.cssText = "border:1px solid #0f0; padding:6px; min-height:60px;";
  host.textContent = "Editable text for selection churn. " + "X".repeat(200);
  box.appendChild(host);

  const sel = window.getSelection ? window.getSelection() : null;
  if (!sel){ warn("Selection API ausente."); return; }

  for (let i=0;i<60;i++){
    try{
      const r = document.createRange();
      const tn = host.firstChild;
      const a = Math.min(10+i, tn.length-1);
      const b = Math.min(a+5, tn.length);
      r.setStart(tn, a);
      r.setEnd(tn, b);
      sel.removeAllRanges();
      sel.addRange(r);

      if (i % 8 === 0) host.innerHTML = "rewrite " + i + " " + "Y".repeat(120);
      if (i % 10 === 0) host.removeAttribute("contenteditable"), host.contentEditable="true";
      forceLayout(host);
    } catch(e){
      warn("Selection churn exception: " + e.message);
      break;
    }
  }
  ok("Selection churn concluído.");
}

function T08(){
  const box = mkSandbox();
  step("TreeWalker/NodeIterator + remoção enquanto itera");
  const host = document.createElement('div');
  host.innerHTML = "<ul>" + Array.from({length:80}, (_,i)=>`<li><span>A${i}</span><b>B${i}</b></li>`).join("") + "</ul>";
  box.appendChild(host);

  const tw = document.createTreeWalker(host, NodeFilter.SHOW_ELEMENT, null, false);
  let count = 0;
  let node;
  while ((node = tw.nextNode())) {
    count++;
    if (count % 17 === 0) {
      // remove um ancestral para bagunçar a iteração
      const li = node.closest && node.closest('li');
      if (li) li.remove();
    }
    if (count > 300) break;
  }
  ok("TreeWalker iter count=" + count);
  forceLayout(host);
}

/* =========================================================
   09–11: Observers
========================================================= */
function T09(){
  const box = mkSandbox();
  step("MutationObserver reentrante + flush de layout dentro do callback");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px;";
  box.appendChild(host);

  let fired = 0;
  const mo = new MutationObserver((mutList) => {
    fired++;
    // reentrância: desconecta/reconecta + teardown parcial
    if (fired === 1) step("MO fired#1: disconnect + rebuild");
    if (fired % 2 === 0) mo.disconnect();
    if (fired === 3) host.innerHTML = ""; // teardown
    if (fired === 4) host.innerHTML = "<span>rebuilt</span>";
    forceLayout(host);
    if (fired % 2 === 0) mo.observe(host, {childList:true, subtree:true, attributes:true});
  });

  mo.observe(host, {childList:true, subtree:true, attributes:true});
  for (let i=0;i<50;i++){
    const s = document.createElement('span');
    s.textContent = "x"+i;
    host.appendChild(s);
    if (i % 5 === 0) host.setAttribute('data-x', String(i));
  }
  mo.disconnect();
  ok("MutationObserver churn concluído. fired=" + fired);
}

function T10(){
  const box = mkSandbox();
  step("ResizeObserver loop (se suportado) com teardown no callback");
  if (typeof ResizeObserver === "undefined") { warn("ResizeObserver não suportado."); return; }
  const host = document.createElement('div');
  host.style.cssText = "width:80px; height:40px; border:1px solid #0f0;";
  box.appendChild(host);

  let n = 0;
  const ro = new ResizeObserver(() => {
    n++;
    if (n === 1) step("RO fired#1");
    if (n === 4) { step("RO: removing host"); host.remove(); }
    if (n === 6) { step("RO: re-adding host"); box.appendChild(host); }
  });
  ro.observe(host);

  for (let i=0;i<40;i++){
    host.style.width = (80 + (i%30)) + "px";
    host.style.height = (40 + (i%20)) + "px";
    forceLayout(host);
  }
  ro.disconnect();
  ok("ResizeObserver churn concluído. fired=" + n);
}

function T11(){
  const box = mkSandbox();
  step("IntersectionObserver churn (se suportado) + removals");
  if (typeof IntersectionObserver === "undefined") { warn("IntersectionObserver não suportado."); return; }
  const scroller = document.createElement('div');
  scroller.style.cssText = "width:320px;height:120px;overflow:auto;border:1px solid #0f0;";
  const inner = document.createElement('div');
  inner.style.height = "800px";
  scroller.appendChild(inner);
  box.appendChild(scroller);

  const target = document.createElement('div');
  target.style.cssText = "margin-top:300px;height:40px;border:1px solid #0f0;";
  inner.appendChild(target);

  let hits = 0;
  const io = new IntersectionObserver((ents) => {
    hits += ents.length;
    if (hits === 1) step("IO first callback");
    if (hits === 3) { step("IO: remove target"); target.remove(); }
    if (hits === 5) { step("IO: re-add target"); inner.appendChild(target); }
  }, { root: scroller });

  io.observe(target);

  for (let i=0;i<50;i++){
    scroller.scrollTop = (i*20) % 700;
    forceLayout(scroller);
  }
  io.disconnect();
  ok("IntersectionObserver churn concluído. hits=" + hits);
}

/* =========================================================
   12–15: Canvas/Image
========================================================= */
function T12(){
  const box = mkSandbox();
  step("Canvas2D resize + getImageData/putImageData alternando tamanhos");
  const c = document.createElement('canvas');
  c.width = 32; c.height = 32;
  c.style.border = "1px solid #0f0";
  box.appendChild(c);
  const ctx = c.getContext('2d');

  for (let i=0;i<40;i++){
    const w = (i%2===0) ? 64 : 256;
    const h = (i%3===0) ? 64 : 128;
    c.width = w; c.height = h;
    ctx.fillRect(0,0,w,h);
    try {
      const img = ctx.getImageData(0,0,Math.min(32,w),Math.min(32,h));
      ctx.putImageData(img, 0, 0);
    } catch(e){
      warn("get/putImageData exception: " + e.message);
      break;
    }
    forceLayout(c);
  }
  ok("Canvas2D resize/get/put concluído.");
}

function T13(){
  const box = mkSandbox();
  step("Canvas2D pattern/gradient + teardown/recreate context");
  const c = document.createElement('canvas');
  c.width = 256; c.height = 128;
  c.style.border = "1px solid #0f0";
  box.appendChild(c);

  for (let i=0;i<30;i++){
    const ctx = c.getContext('2d');
    try {
      const g = ctx.createLinearGradient(0,0,c.width,c.height);
      g.addColorStop(0,"#0f0"); g.addColorStop(1,"#000");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,c.width,c.height);

      const pcan = document.createElement('canvas');
      pcan.width = 8; pcan.height = 8;
      const pctx = pcan.getContext('2d');
      pctx.fillRect(0,0,8,8);
      const pat = ctx.createPattern(pcan, "repeat");
      ctx.fillStyle = pat;
      ctx.fillRect(0,0,c.width,c.height);

      if (i % 10 === 0) { step("Teardown canvas element"); c.remove(); box.appendChild(c); }
    } catch(e){
      warn("Canvas pattern/gradient exception: " + e.message);
      break;
    }
    forceLayout(c);
  }
  ok("Canvas2D pattern/gradient churn concluído.");
}

function T14(){
  const box = mkSandbox();
  step("Image decode data: + remove/reuse rapidamente");
  // PNG 1x1 verde (data URI)
  const dataPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+J8b0AAAAASUVORK5CYII=";
  const img = document.createElement('img');
  img.style.border = "1px solid #0f0";
  box.appendChild(img);

  let loads = 0, errors = 0;
  img.onload = () => { loads++; };
  img.onerror = () => { errors++; };

  for (let i=0;i<120;i++){
    img.src = dataPng + "#v=" + i; // força recarregar (varia URL)
    if (i % 10 === 0) { img.remove(); box.appendChild(img); }
    if (i % 15 === 0) heapPressure(96);
  }
  ok(`Image churn disparado. loads=${loads} errors=${errors} (pode continuar após fim do loop).`);
}

function T15(){
  const box = mkSandbox();
  step("createImageBitmap (se suportado) + cancel/teardown leve");
  if (typeof createImageBitmap === "undefined") { warn("createImageBitmap não suportado."); return; }

  const c = document.createElement('canvas');
  c.width = 64; c.height = 64;
  box.appendChild(c);
  const ctx = c.getContext('2d');
  ctx.fillRect(0,0,64,64);

  let done = 0;
  const jobs = [];
  for (let i=0;i<20;i++){
    const p = createImageBitmap(c).then(bm => {
      done++;
      // teardown
      if (i % 5 === 0) c.width = 64 + (i%3);
      keeper.push(bm);
    }).catch(e => warn("createImageBitmap err: " + e.message));
    jobs.push(p);
  }
  Promise.allSettled(jobs).then(()=> ok("createImageBitmap settled. done=" + done));
}

/* =========================================================
   16–17: WebAudio / Font loading
========================================================= */
function T16(){
  const box = mkSandbox();
  step("WebAudio graph churn (se suportado) – cria/fecha e conecta/desconecta");
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) { warn("WebAudio (AudioContext) não suportado."); return; }

  let created = 0, closed = 0;
  const label = document.createElement('div');
  label.textContent = "WebAudio running...";
  box.appendChild(label);

  (async () => {
    for (let i=0;i<8;i++){
      let ac;
      try {
        ac = new AC();
        created++;
        const osc = ac.createOscillator();
        const gain = ac.createGain();
        osc.connect(gain); gain.connect(ac.destination);
        gain.gain.value = (i%2) ? 0.0 : 0.001; // quase mudo
        osc.start();
        osc.stop(ac.currentTime + 0.02);

        if (ac.suspend) await ac.suspend().catch(()=>{});
        if (ac.resume) await ac.resume().catch(()=>{});
      } catch(e){
        warn("AudioContext create/use err: " + e.message);
      } finally {
        if (ac && ac.close) { try { await ac.close(); closed++; } catch(e){} }
      }
    }
    ok(`WebAudio churn done. created=${created} closed=${closed}`);
  })();
}

function T17(){
  const box = mkSandbox();
  step("FontFace load churn (se suportado) + swap rápido");
  if (typeof FontFace === "undefined" || !document.fonts) { warn("FontFace/document.fonts não suportado."); return; }

  const label = document.createElement('div');
  label.textContent = "FontFace churn...";
  label.style.fontSize = "18px";
  box.appendChild(label);

  // fonte mínima (Woff2 data muito curta pode falhar; objetivo é churn/erro controlado)
  // Usamos uma fonte inválida propositalmente? Melhor não. Vamos usar uma família fictícia e alternar CSS, sem carregar binário.
  // Ainda assim exercita document.fonts (check/status) e style churn.
  let checks = 0;
  (async () => {
    for (let i=0;i<60;i++){
      label.style.fontFamily = (i%2) ? "serif" : "monospace";
      try {
        // check e status podem tocar pipeline de fonts
        document.fonts.check("12px " + label.style.fontFamily);
        checks++;
      } catch(e){
        warn("fonts.check err: " + e.message);
        break;
      }
      if (i % 10 === 0) forceLayout(label);
    }
    ok("Font churn done. checks=" + checks);
  })();
}

/* =========================================================
   18–20: History/hashchange, CSS vars/layout, Shadow DOM
========================================================= */
function T18(){
  const box = mkSandbox();
  step("hashchange + teardown no handler + DOM churn");
  const host = document.createElement('div');
  host.textContent = "hashchange host";
  host.style.cssText = "border:1px solid #0f0; padding:6px;";
  box.appendChild(host);

  let hits = 0;
  const onHash = () => {
    hits++;
    if (hits === 1) step("hashchange fired#1");
    // teardown/rebuild
    if (hits % 2 === 0) host.innerHTML = "";
    else host.innerHTML = "<span>rebuilt " + hits + "</span>";
    forceLayout(host);
  };

  window.addEventListener('hashchange', onHash);
  for (let i=0;i<40;i++){
    location.hash = "t" + i;
    if (i % 8 === 0) { host.remove(); box.appendChild(host); }
  }
  window.removeEventListener('hashchange', onHash);
  ok("hashchange churn concluído. hits=" + hits);
}

function T19(){
  const box = mkSandbox();
  step("CSS variables + calc() + layout thrash + computedStyle");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; --a:10px; --b:2;";
  host.innerHTML = "<div id='inner'>inner</div>";
  const inner = host.querySelector('#inner');
  inner.style.cssText = "width: calc(var(--a) * var(--b)); height: calc(var(--a) * 3); background:#030;";
  box.appendChild(host);

  for (let i=0;i<120;i++){
    host.style.setProperty('--a', (10 + (i%50)) + "px");
    host.style.setProperty('--b', String(1 + (i%5)));
    inner.style.marginLeft = "calc(var(--a) / 2)";
    // alterna propriedades que forçam recálculo/layout
    if (i % 10 === 0) inner.style.display = (inner.style.display === "none") ? "block" : "none";
    try { void getComputedStyle(inner).width; } catch(e){ warn("computedStyle err: "+e.message); break; }
    forceLayout(inner);
  }
  ok("CSS vars/layout thrash concluído.");
}

function T20(){
  const box = mkSandbox();
  step("Shadow DOM/slots churn (se suportado) + reparenting");
  if (!HTMLElement.prototype.attachShadow) { warn("Shadow DOM não suportado."); return; }

  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px;";
  host.textContent = "host";
  box.appendChild(host);

  const shadow = host.attachShadow({mode:"open"});
  shadow.innerHTML = `
    <style> :host { display:block; } .c { border:1px solid #0f0; padding:4px; } </style>
    <div class="c"><slot name="s"></slot></div>
  `;

  const slotted = document.createElement('span');
  slotted.slot = "s";
  slotted.textContent = "slotted content";
  host.appendChild(slotted);

  for (let i=0;i<80;i++){
    slotted.textContent = "slot#" + i + " " + "Z".repeat(i%40);
    if (i % 10 === 0) { step("shadow rewrite " + i); shadow.innerHTML = shadow.innerHTML; }
    if (i % 16 === 0) { host.remove(); box.appendChild(host); }
    forceLayout(host);
  }
  ok("Shadow DOM churn concluído.");
}

/* =========================
   Inicialização
========================= */
window.addEventListener('error', (e) => {
  warn("window.onerror: " + (e && e.message ? e.message : "error"));
});
window.addEventListener('unhandledrejection', (e) => {
  warn("unhandledrejection: " + (e && e.reason && e.reason.message ? e.reason.message : e.reason));
});
</script>
</body>
</html>
