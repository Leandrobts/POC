<!DOCTYPE html>
<html>
<head>
    <title>PS4 WebKit Fuzzer: Advanced Vector</title>
    <style>
        body { background: #000; color: lime; font-family: monospace; overflow: hidden; }
        /* CSS Fuzzer: Força recálculos complexos */
        .v-stress { 
            position: absolute; 
            transform: translate3d(0,0,0); /* Força GPU */
            transition: all 0.1s;
            display: flex;
        }
        #log { border-bottom: 1px solid #444; padding: 5px; }
    </style>
</head>
<body>
    <div id="log">Inicializando Advanced Fuzzer...</div>
    <div id="arena" style="width: 2000px; height: 2000px;"></div>

    <script>
        // ================= CONFIGURAÇÃO =================
        const REPLAY_MODE = false;
        const REPLAY_SEED = 0; // Coloque a seed assassina aqui
        const ITERATIONS = 60; // Mais operações por ciclo
        // =================================================

        // 1. DICIONÁRIO EXPANDIDO (Ovos de Ouro do WebKit)
        // Inclui SVG, MathML e tags de mídia que têm parsers complexos
        const TAGS = [
            'div', 'span', 'a', 'img', 'iframe', 'video', 'audio', 
            'svg', 'path', 'circle', 'mask', // SVG Vector
            'math', 'row', 'frac', 'num',    // MathML Vector
            'table', 'form', 'fieldset', 'select', 'option',
            'details', 'summary', 'marquee'  // Tags Legacy problemáticas
        ];

        const EVENTS = ['click', 'focus', 'blur', 'scroll', 'DOMNodeRemoved', 'DOMSubtreeModified'];

        // 2. SEEDED PRNG (Copiado do anterior para manter reprodutibilidade)
        let currentSeed = 1;
        function seed(s) { currentSeed = s; }
        function rnd() {
            var t = currentSeed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        function pick(arr) { return arr[Math.floor(rnd() * arr.length)]; }
        function coinflip() { return rnd() > 0.5; }

        // Gerenciamento de Estado
        const logBox = document.getElementById('log');
        let savedCycle = parseInt(localStorage.getItem('adv_cycle') || 1);
        let savedSeed  = parseInt(localStorage.getItem('adv_seed') || 12345);

        if (REPLAY_MODE) savedSeed = REPLAY_SEED;
        else savedSeed++;

        if (!REPLAY_MODE) {
            localStorage.setItem('adv_cycle', savedCycle + 1);
            localStorage.setItem('adv_seed', savedSeed);
        }
        
        logBox.innerHTML = `Ciclo: ${savedCycle} | <b>SEED: ${savedSeed}</b>`;
        seed(savedSeed);

        // 3. ARSENAL AVANÇADO
        
        // Função que cria atributos problemáticos
        function fuzzAttributes(el) {
            try {
                if (coinflip()) el.id = "id_" + Math.floor(rnd() * 1000);
                if (coinflip()) el.setAttribute("class", "v-stress");
                // Atributos gigantes podem causar buffer overflow no parser
                if (rnd() > 0.9) el.setAttribute("data-junk", "X".repeat(2000)); 
                // Estilos que quebram layout
                if (coinflip()) el.style.cssText = `float: ${coinflip()?'left':'right'}; width: ${rnd()*100}px;`;
            } catch(e){}
        }

        // O "Interrompedor": Adiciona eventos que rodam DURANTE a destruição
        function addEvilEvents(el) {
            try {
                // DOMNodeRemoved é síncrono. Se o PS4 tentar remover este elemento,
                // esta função roda ANTES dele sumir. Se mudarmos o elemento aqui, 
                // o WebKit pode se perder e causar UAF.
                el.addEventListener('DOMNodeRemoved', function(ev) {
                    // Tenta modificar o elemento enquanto ele morre
                    ev.target.innerHTML = "<b>ZOMBIE</b>";
                    ev.target.setAttribute("id", "dead");
                    // Tenta acessar o pai que talvez já esteja instável
                    if (ev.target.parentNode) ev.target.parentNode.style.display = 'none';
                });
            } catch(e){}
        }

        function runFuzz() {
            const arena = document.getElementById('arena');
            let nodes = [];

            try {
                // FASE 1: CRIAÇÃO (Build)
                for (let i = 0; i < 50; i++) {
                    let tag = pick(TAGS);
                    // SVG e MathML precisam de namespace correto ou são tratados como span
                    let el;
                    if (['svg','path','circle'].includes(tag)) {
                        el = document.createElementNS("http://www.w3.org/2000/svg", tag);
                    } else if (['math','row'].includes(tag)) {
                        el = document.createElementNS("http://www.w3.org/1998/Math/MathML", tag);
                    } else {
                        el = document.createElement(tag);
                    }

                    fuzzAttributes(el);
                    addEvilEvents(el);

                    // Aninhamento complexo
                    if (nodes.length > 0 && coinflip()) {
                        let parent = pick(nodes);
                        try { parent.appendChild(el); } catch(e){ arena.appendChild(el); }
                    } else {
                        arena.appendChild(el);
                    }
                    nodes.push(el);
                }

                // FASE 2: MUTAÇÃO (Modify) - TreeWalker
                // O TreeWalker é uma forma nativa de andar pelo DOM.
                // Se modificarmos o DOM enquanto andamos, o TreeWalker pode crashar.
                let walker = document.createTreeWalker(arena, NodeFilter.SHOW_ELEMENT, null, false);
                let node = walker.nextNode();
                while(node) {
                    if (rnd() > 0.7) {
                        // Mutações agressivas
                        if (coinflip()) node.textContent = "A".repeat(100);
                        if (coinflip()) node.normalize(); // Junta text nodes (historicamente bugado)
                    }
                    node = walker.nextNode();
                }

                // FASE 3: DESTRUIÇÃO (Destroy) com GC
                for (let i = 0; i < 30; i++) {
                    let victim = pick(nodes);
                    try {
                        victim.remove(); 
                        // Acesso imediato pós-remoção para checar UAF
                        let ghost = victim.getAttribute("id");
                    } catch(e){}
                }

                // FASE 4: HEAP SPRAY (Pressão de Memória)
                // Cria arrays tipados para preencher buracos na memória
                let spray = [];
                for(let k=0; k<200; k++) {
                    spray.push(new Float64Array(1000).fill(1.123456789e-100)); // Padrão float específico
                }
                spray = null; // Solta para o GC limpar tudo de uma vez

            } catch (e) {
                // Ignora erros de JS, queremos segfaults
            }

            // Limpa visualmente (mas a memória pode estar suja)
            arena.textContent = "";
        }

        // Loop de Execução
        setTimeout(() => {
            for (let j=0; j < ITERATIONS; j++) runFuzz();
            if (!REPLAY_MODE) window.location.reload();
            else logBox.innerHTML += "<br>Replay finalizado.";
        }, 200);

    </script>
</body>
</html>
