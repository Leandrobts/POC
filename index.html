<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PS4 WebKit – Sanity/Crash Hunting Suite (20 testes – V3)</title>
  <style>
    body { background:#000; color:#0f0; font-family:monospace; margin:12px; }
    h1,h2 { color:#9f9; margin:8px 0; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    button { background:#111; color:#0f0; border:1px solid #0f0; padding:10px 12px; cursor:pointer; }
    button:hover { background:#0f0; color:#000; }
    #log { white-space:pre-wrap; border:1px solid #0f0; padding:10px; height:440px; overflow:auto; background:#060606; }
    .muted { color:#6f6; }
  </style>
</head>
<body>
  <h1>PS4 WebKit – Sanity/Crash Hunting Suite (20 testes – V3)</h1>
  <div class="muted">
    Foco: novos vetores de CE/crash (sanidade/crash hunting). Sem exploração.<br>
    Recomendo: RESET entre testes. Para timing/race, use LOOP ALL x80.
  </div>

  <div class="row" style="margin:10px 0;">
    <button onclick="clearLog()">CLEAR</button>
    <button onclick="resetEnv()">RESET DOM</button>
    <button onclick="stopLoop()">STOP LOOP</button>
    <button onclick="loopAll(80)">LOOP ALL x80</button>
  </div>

  <h2>Testes (T41–T60)</h2>
  <div class="row">
    <button onclick="run(T41)">T41 CSSOM insertRule/deleteRule churn</button>
    <button onclick="run(T42)">T42 Keyframes/animation rule churn</button>
    <button onclick="run(T43)">T43 getComputedStyle flood + class churn</button>
    <button onclick="run(T44)">T44 DOMTokenList (classList) reentrante</button>

    <button onclick="run(T45)">T45 XPath evaluate + DOM teardown</button>
    <button onclick="run(T46)">T46 XML Document import/adopt churn</button>
    <button onclick="run(T47)">T47 XSLTProcessor transform (se houver)</button>

    <button onclick="run(T48)">T48 Focus/blur storm em inputs + rewrite</button>
    <button onclick="run(T49)">T49 Textarea selectionRange churn</button>
    <button onclick="run(T50)">T50 Form clone/reset + validity (se houver)</button>

    <button onclick="run(T51)">T51 EventTarget add/remove listeners massivo</button>
    <button onclick="run(T52)">T52 dispatchEvent com subtree removido</button>
    <button onclick="run(T53)">T53 requestAnimationFrame churn + teardown</button>

    <button onclick="run(T54)">T54 localStorage churn (se houver)</button>
    <button onclick="run(T55)">T55 URL/URLSearchParams churn</button>
    <button onclick="run(T56)">T56 FileReader Blob churn (se houver)</button>

    <button onclick="run(T57)">T57 MessagePort chain relay (se houver)</button>
    <button onclick="run(T58)">T58 Worker nested postMessage (se houver)</button>

    <button onclick="run(T59)">T59 DOMSubtreeModified event (se houver)</button>
    <button onclick="run(T60)">T60 DocumentFragment/Range deleteContents churn</button>
  </div>

  <pre id="log">Status: pronto.</pre>

<script>
/* =========================
   Infra / Logger
========================= */
const logEl = document.getElementById('log');
let keeper = [];
let loopTimer = null;
let loopStop = false;

function ts(){
  const d = new Date();
  const z = (n)=>String(n).padStart(2,'0');
  return `${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,'0')}`;
}
function log(s){ logEl.textContent += `\n[${ts()}] ${s}`; logEl.scrollTop = logEl.scrollHeight; }
function warn(s){ log(`WARN: ${s}`); }
function step(s){ log(`STEP: ${s}`); }
function ok(s){ log(`OK: ${s}`); }

function clearLog(){ logEl.textContent = "Status: pronto."; }
function stopLoop(){ loopStop = true; if (loopTimer) { clearTimeout(loopTimer); loopTimer=null; } log("LOOP: stop solicitado."); }

function resetEnv(){
  stopLoop();
  keeper = [];
  const nodes = Array.from(document.body.querySelectorAll(".sandbox"));
  for (const n of nodes) n.remove();
  ok("RESET: sandbox limpo.");
}

function run(fn){
  stopLoop();
  keeper = [];
  log(`\n=== RUN ${fn.name} ===`);
  setTimeout(() => {
    try { fn(); }
    catch(e){ warn(`${fn.name} exception: ${e && e.message ? e.message : e}`); }
    finally { ok(`${fn.name} finished (se não travou).`); }
  }, 0);
}

function loopAll(n){
  stopLoop();
  loopStop = false;
  const tests = [T41,T42,T43,T44,T45,T46,T47,T48,T49,T50,T51,T52,T53,T54,T55,T56,T57,T58,T59,T60];
  let i = 0, iter = 0;
  log(`\n=== LOOP ALL start: ${n} iterações ===`);
  const tick = () => {
    if (loopStop) { ok("LOOP ALL stopped."); return; }
    if (iter >= n) { ok("LOOP ALL concluído."); return; }
    const fn = tests[i];
    keeper = [];
    log(`\n--- LOOP iter=${iter+1}/${n} test=${fn.name} ---`);
    try { fn(); } catch(e){ warn(`${fn.name} exception: ${e && e.message ? e.message : e}`); }
    i++;
    if (i >= tests.length) { i=0; iter++; }
    loopTimer = setTimeout(tick, 70);
  };
  loopTimer = setTimeout(tick, 80);
}

/* =========================
   Helpers
========================= */
function mkSandbox(){
  const d = document.createElement('div');
  d.className = "sandbox";
  d.style.cssText = "position:relative; border:1px dashed #0f0; margin:10px 0; padding:8px;";
  document.body.appendChild(d);
  return d;
}
function forceLayout(el){
  try { void el.offsetHeight; } catch(e){}
  try { void el.getBoundingClientRect(); } catch(e){}
  try { void getComputedStyle(el).width; } catch(e){}
}
function heapPressure(kb){
  const n = Math.max(24, Math.min(700, kb|0));
  const arr = [];
  for (let i=0;i<n;i++) arr.push(new Uint8Array(1024));
  keeper.push(arr);
}

/* =========================================================
   T41–T44: CSSOM / style system edge cases
========================================================= */
function T41(){
  const box = mkSandbox();
  step("CSSOM: cria stylesheet, insertRule/deleteRule intensivo + forceLayout");
  const st = document.createElement('style');
  st.textContent = "/* init */";
  box.appendChild(st);

  const sheet = st.sheet;
  if (!sheet || !sheet.insertRule) { warn("CSSStyleSheet insertRule não suportado."); return; }

  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  for (let i=0;i<200;i++){
    const cls = "c" + (i%50);
    host.className = cls;
    try {
      const rule = `.${cls} { margin-left:${(i%30)}px; padding:${(i%7)}px; }`;
      sheet.insertRule(rule, Math.min(sheet.cssRules.length, 0));
      if (sheet.cssRules.length > 120) sheet.deleteRule(0);
    } catch(e){
      warn("CSSOM rule err: " + e.message);
      break;
    }
    if (i % 15 === 0) forceLayout(host);
  }
  ok("CSSOM churn concluído.");
}

function T42(){
  const box = mkSandbox();
  step("Keyframes/animation rule churn (inserir/remover @keyframes e alternar animação)");
  const st = document.createElement('style');
  box.appendChild(st);
  const sheet = st.sheet;
  if (!sheet || !sheet.insertRule) { warn("CSSOM insertRule não suportado."); return; }

  const el = document.createElement('div');
  el.textContent = "anim";
  el.style.cssText = "border:1px solid #0f0; width:120px; height:30px; line-height:30px;";
  box.appendChild(el);

  for (let i=0;i<80;i++){
    const name = "k" + i;
    try {
      sheet.insertRule(`@keyframes ${name}{0%{transform:translateX(0)}100%{transform:translateX(${(i%30)}px)}}`, sheet.cssRules.length);
      el.style.animation = `${name} 0.05s linear infinite`;
      if (sheet.cssRules.length > 40) sheet.deleteRule(0);
    } catch(e){
      warn("keyframes err: " + e.message);
      break;
    }
    if (i % 8 === 0) { el.remove(); box.appendChild(el); }
    forceLayout(el);
  }
  ok("Keyframes churn concluído.");
}

function T43(){
  const box = mkSandbox();
  step("ComputedStyle flood + alternância de classes + rewrite periódico");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  const st = document.createElement('style');
  st.textContent = Array.from({length:40}, (_,i)=>`.k${i}{margin-left:${i}px; padding:${i%5}px;}`).join("\n");
  box.appendChild(st);

  for (let i=0;i<500;i++){
    host.className = "k" + (i%40);
    try { void getComputedStyle(host).marginLeft; } catch(e){ warn("getComputedStyle err: "+e.message); break; }
    if (i % 50 === 0) host.innerHTML = "<span>rewrite " + i + "</span>" + "X".repeat(200);
    if (i % 35 === 0) forceLayout(host);
  }
  ok("ComputedStyle flood concluído.");
}

function T44(){
  const box = mkSandbox();
  step("classList reentrante: toggle dentro de handler disparado por MutationObserver");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  host.textContent = "tokenlist";
  box.appendChild(host);

  let fired = 0;
  const mo = new MutationObserver(() => {
    fired++;
    // reentrância: mexe em classList durante observação de atributo
    host.classList.toggle("a");
    host.classList.toggle("b");
    if (fired % 5 === 0) host.textContent = "fired#" + fired;
    forceLayout(host);
  });
  mo.observe(host, {attributes:true});

  for (let i=0;i<120;i++){
    host.className = (i%2) ? "x" : "y";
    if (i % 20 === 0) heapPressure(60);
  }
  mo.disconnect();
  ok("DOMTokenList reentrante concluído. fired=" + fired);
}

/* =========================================================
   T45–T47: XPath / XML docs / XSLT
========================================================= */
function T45(){
  const box = mkSandbox();
  step("XPath evaluate + DOM teardown enquanto itera resultados");
  if (!document.evaluate) { warn("XPath (document.evaluate) não suportado."); return; }

  const host = document.createElement('div');
  host.innerHTML = "<ul>" + Array.from({length:120}, (_,i)=>`<li><span class='x'>A${i}</span><b>B${i}</b></li>`).join("") + "</ul>";
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  for (let i=0;i<40;i++){
    try {
      const snap = document.evaluate("//span[@class='x']", host, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let k=0;k<snap.snapshotLength;k+=7){
        const n = snap.snapshotItem(k);
        if (n) n.textContent = "X" + i + ":" + k;
        if (k === 21 && i % 5 === 0) { step("teardown host.innerHTML"); host.innerHTML = "<div>reset</div>"; }
      }
    } catch(e){
      warn("XPath err: " + e.message);
      break;
    }
    forceLayout(host);
  }
  ok("XPath churn concluído.");
}

function T46(){
  const box = mkSandbox();
  step("XML docs: createDocument + importNode/adoptNode + replaceChildren");
  if (!document.implementation || !document.implementation.createDocument) { warn("createDocument não suportado."); return; }

  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  for (let i=0;i<80;i++){
    try {
      const xd = document.implementation.createDocument("", "root", null);
      const r = xd.documentElement;
      const child = xd.createElement("item");
      child.setAttribute("n", String(i));
      child.textContent = "Z".repeat(i%60);
      r.appendChild(child);

      const imported = document.importNode(r, true);
      if (i % 2 === 0) host.replaceChildren(imported);
      else host.appendChild(imported);

      if (i % 10 === 0) host.textContent = "reset " + i;
    } catch(e){
      warn("XML import/adopt err: " + e.message);
      break;
    }
    if (i % 8 === 0) forceLayout(host);
  }
  ok("XML import/adopt churn concluído.");
}

function T47(){
  const box = mkSandbox();
  step("XSLTProcessor transformToFragment (se suportado) + teardown alvo");
  if (typeof XSLTProcessor === "undefined" || !document.implementation || !document.implementation.createDocument) {
    warn("XSLTProcessor não suportado.");
    return;
  }

  try {
    const xml = document.implementation.createDocument("", "root", null);
    for (let i=0;i<40;i++){
      const it = xml.createElement("item");
      it.textContent = "I" + i;
      xml.documentElement.appendChild(it);
    }

    const xslText =
      `<?xml version="1.0"?>
       <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
         <xsl:template match="/">
           <div>
             <xsl:for-each select="root/item">
               <span><xsl:value-of select="."/></span>
             </xsl:for-each>
           </div>
         </xsl:template>
       </xsl:stylesheet>`;

    const xslDoc = new DOMParser().parseFromString(xslText, "application/xml");
    const proc = new XSLTProcessor();
    proc.importStylesheet(xslDoc);

    const host = document.createElement('div');
    host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
    box.appendChild(host);

    for (let i=0;i<80;i++){
      const frag = proc.transformToFragment(xml, document);
      host.replaceChildren(frag);
      if (i === 30) { step("remove host"); host.remove(); box.appendChild(host); }
      if (i % 10 === 0) forceLayout(host);
    }
    ok("XSLT churn concluído.");
  } catch(e){
    warn("XSLT err: " + e.message);
  }
}

/* =========================================================
   T48–T50: Forms / selection / validity
========================================================= */
function T48(){
  const box = mkSandbox();
  step("Focus/blur storm em inputs + rewrite do container");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  const inputs = [];
  for (let i=0;i<20;i++){
    const inp = document.createElement('input');
    inp.value = "v" + i;
    inp.style.cssText = "display:block; margin:2px 0; width:320px;";
    host.appendChild(inp);
    inputs.push(inp);
  }

  for (let i=0;i<200;i++){
    const t = inputs[i % inputs.length];
    try { t.focus(); } catch(e){}
    try { t.blur(); } catch(e){}
    if (i % 40 === 0) { step("rewrite host"); host.innerHTML = ""; inputs.forEach(x=>host.appendChild(x)); }
    if (i % 30 === 0) forceLayout(host);
  }
  ok("Focus/blur storm concluído.");
}

function T49(){
  const box = mkSandbox();
  step("Textarea selectionRange churn + value rewrite + remove/readd");
  const ta = document.createElement('textarea');
  ta.style.cssText = "width:340px;height:120px;border:1px solid #0f0;background:#000;color:#0f0;";
  ta.value = "A".repeat(2000);
  box.appendChild(ta);

  for (let i=0;i<200;i++){
    try {
      const a = (i*7) % 1900;
      const b = a + (i%80);
      ta.setSelectionRange(a, b);
      if (i % 25 === 0) ta.value = "B".repeat(2200) + " #" + i;
      if (i % 40 === 0) { step("remove/readd textarea"); ta.remove(); box.appendChild(ta); }
    } catch(e){
      warn("selectionRange err: " + e.message);
      break;
    }
    if (i % 15 === 0) forceLayout(ta);
  }
  ok("Textarea selection churn concluído.");
}

function T50(){
  const box = mkSandbox();
  step("Form clone/reset + constraint validation (se houver) + replaceChildren");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  const form = document.createElement('form');
  form.innerHTML =
    `<input required value="x">
     <input type="email" value="a@b">
     <input pattern="\\d+" value="123">
     <button type="reset">reset</button>`;
  host.appendChild(form);

  for (let i=0;i<120;i++){
    try {
      if (form.checkValidity) form.checkValidity();
      if (i % 5 === 0 && form.reset) form.reset();
      if (i % 7 === 0) {
        const clone = form.cloneNode(true);
        host.replaceChildren(clone);
      }
    } catch(e){
      warn("form validity/reset err: " + e.message);
      break;
    }
    if (i % 10 === 0) forceLayout(host);
  }
  ok("Form churn concluído.");
}

/* =========================================================
   T51–T53: Events / rAF / dispatch
========================================================= */
function T51(){
  const box = mkSandbox();
  step("add/remove listeners massivo em muitos nós + dispatch");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  const nodes = [];
  for (let i=0;i<120;i++){
    const d = document.createElement('div');
    d.textContent = "n"+i;
    host.appendChild(d);
    nodes.push(d);
  }

  let hits = 0;
  const handler = () => { hits++; };

  for (let i=0;i<200;i++){
    const n = nodes[i % nodes.length];
    n.addEventListener("click", handler);
    if (i % 2 === 0) n.removeEventListener("click", handler);
    try { n.dispatchEvent(new MouseEvent("click")); } catch(e){}
    if (i % 40 === 0) heapPressure(70);
  }
  ok("Event listeners churn concluído. hits=" + hits);
}

function T52(){
  const box = mkSandbox();
  step("dispatchEvent em subtree removido (custom event) + reattach");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  const child = document.createElement('div');
  child.textContent = "child";
  host.appendChild(child);
  box.appendChild(host);

  let got = 0;
  child.addEventListener("omega", () => { got++; });

  for (let i=0;i<120;i++){
    if (i === 40) { step("remove host"); host.remove(); }
    if (i === 60) { step("reattach host"); box.appendChild(host); }
    try { child.dispatchEvent(new CustomEvent("omega", {bubbles:true})); } catch(e){ warn("dispatch err: "+e.message); }
    if (i % 10 === 0) forceLayout(child);
  }
  ok("dispatchEvent churn concluído. got=" + got);
}

function T53(){
  const box = mkSandbox();
  step("requestAnimationFrame churn: cria/remove muitos nós por frame (curto)");
  if (!window.requestAnimationFrame) { warn("rAF não suportado."); return; }

  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  let frames = 0;
  function frame(){
    frames++;
    // churn por frame
    for (let i=0;i<30;i++){
      const d = document.createElement('div');
      d.textContent = "f"+frames+"-"+i;
      host.appendChild(d);
    }
    while (host.childNodes.length > 80) host.removeChild(host.firstChild);

    if (frames === 20) { step("teardown host"); host.remove(); box.appendChild(host); }
    forceLayout(host);

    if (frames < 120) requestAnimationFrame(frame);
    else ok("rAF churn concluído. frames=" + frames);
  }
  requestAnimationFrame(frame);
}

/* =========================================================
   T54–T56: Storage / URL / FileReader
========================================================= */
function T54(){
  const box = mkSandbox();
  step("localStorage churn (se suportado) + JSON + removeItem/clear");
  if (!window.localStorage) { warn("localStorage não suportado."); return; }

  let okOps = 0;
  try {
    for (let i=0;i<400;i++){
      localStorage.setItem("k"+(i%80), JSON.stringify({i, s:"X".repeat(i%120)}));
      if (i % 3 === 0) localStorage.removeItem("k"+((i*7)%80));
      if (i % 97 === 0) localStorage.clear();
      okOps++;
      if (i % 50 === 0) heapPressure(60);
    }
    ok("localStorage churn concluído. ops=" + okOps);
  } catch(e){
    warn("localStorage err: " + e.message + " (ops=" + okOps + ")");
  }
}

function T55(){
  const box = mkSandbox();
  step("URL/URLSearchParams churn + encode/decode + new URL()");
  if (typeof URL === "undefined") { warn("URL API não suportada."); return; }

  for (let i=0;i<800;i++){
    try{
      const u = new URL("https://example.invalid/path?x=1");
      u.searchParams.set("a", "A".repeat(i%200));
      u.searchParams.set("b", String(i));
      const s = u.toString();
      // parse de volta
      const u2 = new URL(s);
      void u2.searchParams.get("a");
    } catch(e){
      warn("URL churn err: " + e.message);
      break;
    }
  }
  ok("URL/URLSearchParams churn concluído.");
}

function T56(){
  const box = mkSandbox();
  step("FileReader Blob churn (se suportado): readAsText/readAsArrayBuffer alternando");
  if (typeof FileReader === "undefined" || typeof Blob === "undefined") { warn("FileReader/Blob não suportado."); return; }

  let done = 0, err = 0;
  for (let i=0;i<60;i++){
    try{
      const fr = new FileReader();
      const blob = new Blob(["Z".repeat(20000 + (i%10)*1000)], {type:"text/plain"});
      fr.onerror = () => { err++; };
      fr.onload = () => { done++; };

      if (i % 2 === 0 && fr.readAsArrayBuffer) fr.readAsArrayBuffer(blob);
      else fr.readAsText(blob);
      keeper.push(fr);
    } catch(e){
      warn("FileReader err: " + e.message);
      break;
    }
    if (i % 10 === 0) heapPressure(80);
  }
  ok("FileReader churn disparado. done=" + done + " err=" + err + " (assíncrono)");
}

/* =========================================================
   T57–T58: MessagePorts / Workers (variação)
========================================================= */
function T57(){
  const box = mkSandbox();
  step("MessagePort chain relay (se suportado): porta1->porta2->porta3");
  if (typeof MessageChannel === "undefined") { warn("MessageChannel não suportado."); return; }

  const ch1 = new MessageChannel();
  const ch2 = new MessageChannel();
  const ch3 = new MessageChannel();
  keeper.push(ch1, ch2, ch3);

  let hops = 0;
  ch1.port1.onmessage = (e) => { hops++; try { ch2.port2.postMessage(e.data); } catch(_){} };
  ch2.port1.onmessage = (e) => { hops++; try { ch3.port2.postMessage(e.data); } catch(_){} };
  ch3.port1.onmessage = (e) => { hops++; };

  for (let i=0;i<200;i++){
    try { ch1.port2.postMessage({i, s:"M".repeat(i%60)}); } catch(e){ warn("postMessage err: "+e.message); break; }
    if (i % 50 === 0) { try { ch2.port1.close(); ch2.port2.close(); } catch(_){} } // fecha no meio
  }
  ok("MessagePort chain relay concluído. hops=" + hops);
}

function T58(){
  const box = mkSandbox();
  step("Worker nested postMessage (se suportado): worker ecoa e cria payload variado");
  if (typeof Worker === "undefined" || typeof Blob === "undefined" || typeof URL === "undefined") { warn("Worker/Blob/URL não suportado."); return; }

  const code = `
    self.onmessage = (e) => {
      const n = e.data.n|0;
      // payload moderado
      const arr = [];
      for (let i=0;i<50;i++) arr.push("X".repeat((n+i)%40));
      postMessage({n, arrlen:arr.length});
    };
  `;
  const url = URL.createObjectURL(new Blob([code], {type:"application/javascript"}));
  let got = 0;

  try{
    const w = new Worker(url);
    w.onmessage = () => { got++; };
    for (let i=0;i<120;i++){
      w.postMessage({n:i});
      if (i === 60) { step("terminate worker mid-stream"); w.terminate(); }
    }
    keeper.push(w);
  } catch(e){
    warn("Worker err: " + e.message);
  } finally {
    try { URL.revokeObjectURL(url); } catch(_){}
  }
  ok("Worker nested postMessage disparado. got=" + got + " (assíncrono)");
}

/* =========================================================
   T59: Mutation Events legacy
========================================================= */
function T59(){
  const box = mkSandbox();
  step("DOMSubtreeModified (se suportado) + mutações + teardown no handler");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  box.appendChild(host);

  let fired = 0;
  const handler = () => {
    fired++;
    if (fired === 1) step("DOMSubtreeModified fired#1");
    if (fired === 20) { step("handler teardown host"); host.innerHTML = ""; }
    forceLayout(host);
  };

  try { host.addEventListener("DOMSubtreeModified", handler); } catch(e){ warn("addEventListener DOMSubtreeModified falhou: "+e.message); return; }

  for (let i=0;i<80;i++){
    const s = document.createElement('span');
    s.textContent = "s" + i;
    host.appendChild(s);
    if (i % 10 === 0) host.textContent = "reset " + i;
  }
  host.removeEventListener("DOMSubtreeModified", handler);
  ok("DOMSubtreeModified churn concluído. fired=" + fired);
}

/* =========================================================
   T60: DocumentFragment + Range deleteContents churn
========================================================= */
function T60(){
  const box = mkSandbox();
  step("DocumentFragment + Range.deleteContents + append/prepend + normalize");
  const host = document.createElement('div');
  host.style.cssText = "border:1px solid #0f0; padding:6px; width:340px;";
  host.innerHTML = "<p>" + "Q".repeat(800) + "</p><p>" + "W".repeat(800) + "</p>";
  box.appendChild(host);

  for (let i=0;i<60;i++){
    try{
      const p1 = host.firstElementChild;
      const p2 = host.lastElementChild;
      const r = document.createRange();
      r.setStart(p1.firstChild, Math.min(10+(i%50), p1.firstChild.length-1));
      r.setEnd(p2.firstChild, Math.min(20+(i%60), p2.firstChild.length-1));
      r.deleteContents();

      const frag = document.createDocumentFragment();
      for (let k=0;k<10;k++){
        const s = document.createElement('span');
        s.textContent = "@" + i + ":" + k;
        frag.appendChild(s);
      }
      host.prepend(frag);
      if (i % 10 === 0) host.normalize();
      if (i === 30) { step("rewrite host"); host.innerHTML = "<p>reset</p>" + "<p>" + "E".repeat(600) + "</p>"; }
    } catch(e){
      warn("Range/fragment err: " + e.message);
      break;
    }
    if (i % 6 === 0) forceLayout(host);
  }
  ok("Fragment/Range deleteContents churn concluído.");
}

/* =========================
   Global traps
========================= */
window.addEventListener('error', (e) => warn("window.onerror: " + (e && e.message ? e.message : "error")));
window.addEventListener('unhandledrejection', (e) => warn("unhandledrejection: " + (e && e.reason && e.reason.message ? e.reason.message : e.reason)));
</script>
</body>
</html>
