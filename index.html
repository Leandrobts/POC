<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Research Lab</title>    
</head>
<body>
    <h1>PS4 WebKit Fuzzer</h1>
    <p>Selecione um vetor para iniciar o teste de estresse:</p>

    <button onclick="runUAF()">1. Testar DOM Use-After-Free</button>
    <button onclick="runCSS()">2. Testar CSS Layout Stress</button>
    <button onclick="runGC()">3. Testar GC & TypedArray</button>
   <button onclick="runWebAudio()">1. Testar WebAudio Node Race</button>
    <button onclick="runSVG()">2. Testar SVG SMIL Animation</button>
    <button onclick="runIndexedDB()">3. Testar IndexedDB Corruption</button>
    <button onclick="runCanvas2D()">1. Canvas 2D Path Stress (OOB Write)</button>
    <button onclick="runWorkers()">2. Web Workers Race Condition</button>
    <button onclick="runRegExp()">3. RegExp Stack Exhaustion</button>
    <button onclick="runIntl()">4. Intl API String Stress</button>
    <button onclick="runBlobURL()">5. Blob Object URL Exhaustion</button>

    <div id="status">Aguardando comando...</div>
    <div id="layout-container" class="stress-box"></div>

    <script>
        const status = document.getElementById('status');

        function log(msg) {
            status.innerText = msg;
            console.log(msg);
        }

        // Teste 1: DOM Use-After-Free
        function runUAF() {
            log("Iniciando DOM UAF Stress...");
            for (let i = 0; i < 2000; i++) {
                let div = document.createElement('div');
                div.addEventListener('DOMNodeRemoved', function() {
                    // Tentativa de realocação de memória durante a destruição
                    let temp = [];
                    for (let j = 0; j < 50; j++) {
                        temp.push(new Uint32Array(1024));
                    }
                }, false);
                document.body.appendChild(div);
                document.body.removeChild(div);
            }
            log("DOM UAF concluído sem crash imediato.");
        }

        // Teste 2: CSS Layout Stress
        function runCSS() {
            log("Iniciando CSS Layout Stress...");
            const container = document.getElementById('layout-container');
            container.style.display = 'block';
            
            let html = '';
            for (let i = 0; i < 3000; i++) {
                html += `<div style="
                    mask-image: linear-gradient(to bottom, black, white);
                    filter: blur(${i%10}px) contrast(${i%200}%);
                    column-count: ${i%50};
                    float: left;
                    width: 1px; height: 1px;
                "></div>`;
            }
            container.innerHTML = html;
            log("CSS Layout renderizado. Verifique estabilidade.");
        }

        // Teste 3: Garbage Collection & TypedArray
        function runGC() {
            log("Iniciando GC & TypedArray Stress...");
            let storage = [];
            
            try {
                for (let i = 0; i < 1500; i++) {
                    // Alocações massivas para forçar expansão do Heap
                    let buf = new Uint32Array(0x100000); 
                    buf.fill(0x41414141);
                    storage.push(buf);

                    if (i % 100 === 0) {
                        log("Alocação: " + i + " unidades...");
                        // Libera referências parciais para forçar o GC
                        for(let k = 0; k < storage.length / 2; k++) {
                            storage[k] = null;
                        }
                        // Trigger de pressão de memória
                        let dummy = new Array(10000).join("A");
                    }
                }
            } catch (e) {
                log("Erro: " + e.message);
            }
            log("Teste de GC finalizado.");
        }
 // Teste 1: WebAudio API (UAF em AudioNodes)
        function runWebAudio() {
            log("Iniciando WebAudio Stress...");
            try {
                for (let i = 0; i < 500; i++) {
                    let ctx = new (window.AudioContext || window.webkitAudioContext)();
                    let osc = ctx.createOscillator();
                    let gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.start(0);
                    ctx.close(); // Fecha o contexto imediatamente para tentar causar UAF
                    osc = null;
                    gain = null;
                }
                log("WebAudio concluído.");
            } catch (e) { log("Erro no WebAudio: " + e.message); }
        }

        // Teste 2: SVG SMIL (Corrupção de Memória em Animações)
        function runSVG() {
            log("Iniciando SVG Stress...");
            const container = document.getElementById('svg-container');
            let svgHtml = '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">';
            
            for (let i = 0; i < 1000; i++) {
                svgHtml += `
                    <circle cx="50" cy="50" r="40">
                        <animate attributeName="r" from="0" to="100" dur="${i%10}s" repeatCount="indefinite" />
                        <animate attributeName="cx" from="-1000" to="1000" dur="${i%5}s" repeatCount="indefinite" />
                    </circle>`;
            }
            svgHtml += '</svg>';
            container.innerHTML = svgHtml;
            log("SVG renderizado. Observe o consumo de memória.");
        }

        // Teste 3: IndexedDB (Race Condition em Transações)
        function runIndexedDB() {
            log("Iniciando IndexedDB Stress...");
            for (let i = 0; i < 100; i++) {
                let dbName = "TestDB_" + i;
                let request = indexedDB.open(dbName, 1);
                
                request.onupgradeneeded = function(e) {
                    let db = e.target.result;
                    db.createObjectStore("store", { keyPath: "id" });
                };

                request.onsuccess = function(e) {
                    let db = e.target.result;
                    // Tenta deletar o banco enquanto ele pode estar em uso
                    db.close();
                    indexedDB.deleteDatabase(dbName);
                };
            }
            log("IndexedDB loops iniciados.");
        }
 // 1. Canvas 2D: Estresse de caminhos complexos para tentar OOB no buffer de renderização
        function runCanvas2D() {
            log("Iniciando Canvas 2D Stress...");
            const ctx = document.getElementById('testCanvas').getContext('2d');
            ctx.beginPath();
            for (let i = 0; i < 100000; i++) {
                ctx.lineTo(Math.random() * 1000, Math.random() * 1000);
                if (i % 1000 === 0) ctx.stroke();
            }
            log("Canvas 2D concluído.");
        }

        // 2. Web Workers: Tentativa de causar race condition na thread principal
        function runWorkers() {
            log("Iniciando Web Workers...");
            const workerCode = "onmessage = function(e) { postMessage(e.data); }";
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const workerUrl = URL.createObjectURL(blob);

            for (let i = 0; i < 100; i++) {
                let w = new Worker(workerUrl);
                w.postMessage(new Uint8Array(0x100000)); // Envia 1MB
                w.onmessage = function() { w.terminate(); };
            }
            log("Workers disparados.");
        }

        // 3. RegExp: Estresse de pilha do motor de busca de padrões
        function runRegExp() {
            log("Iniciando RegExp Stress...");
            try {
                let pattern = "(a+)+$";
                let re = new RegExp(pattern);
                let str = "a".repeat(5000) + "!"; 
                re.test(str); // Pode causar backtracking catastrófico ou stack overflow
            } catch (e) { log("RegExp capturado: " + e.message); }
            log("RegExp concluído.");
        }

        // 4. Intl API: Manipulação de strings internacionais (comum para falhas de lógica)
        function runIntl() {
            log("Iniciando Intl Stress...");
            let bigStr = "A".repeat(10000);
            for (let i = 0; i < 5000; i++) {
                let collator = new Intl.Collator('de-DE-u-co-phonebk');
                collator.compare(bigStr, bigStr);
            }
            log("Intl API concluído.");
        }

        // 5. Blob/URL: Estresse do rastreador de recursos do navegador
        function runBlobURL() {
            log("Iniciando Blob URL Stress...");
            let urls = [];
            try {
                for (let i = 0; i < 10000; i++) {
                    let b = new Blob([new Uint8Array(1024)]);
                    urls.push(URL.createObjectURL(b));
                    if (i % 1000 === 0) {
                        // Revoga metade para tentar causar inconsistência no rastreamento
                        URL.revokeObjectURL(urls.shift());
                    }
                }
            } catch (e) { log("Erro Blob: " + e.message); }
            log("Blob URL concluído.");
        }
    </script>
</body>
</html>
