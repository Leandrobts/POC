<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v130000: The Architect</title>
<style>
    body { background: #111; color: #fff; font-family: 'Courier New', monospace; padding: 20px; }
    button { 
        width: 100%; padding: 15px; margin: 8px 0; 
        background: #444; color: #0f0; border: 1px solid #0f0; 
        font-weight: bold; cursor: pointer; text-align: left;
    }
    button:hover { background: #0f0; color: #000; }
    #log { border: 1px solid #fff; height: 300px; overflow-y: scroll; padding: 10px; margin-top: 20px;}
</style>
</head>
<body>

<h1>v130000: ARCHITECTURAL CRACKS</h1>
<div id="log">Sistema pronto. Selecione o vetor...</div>

<button onclick="run(j01)">01. Array.reverse Accessor Resize (Heap Corruption)</button>
<button onclick="run(j02)">02. String.replace Object Detach (Frame Crash)</button>
<button onclick="run(j03)">03. Function.apply Stack Smash (Recursion Limit)</button>

<button onclick="run(l01)">04. CSS Float Deep Nesting (Layout Stack Overflow)</button>
<button onclick="run(l02)">05. Table ColSpan Integer Overflow (Rendering Crash)</button>
<button onclick="run(l03)">06. Selection Extend Detached Node (Selection UAF)</button>

<button onclick="run(d01)">07. document.write Script Injection Race</button>
<button onclick="run(d02)">08. Range.insertNode Fragment Confusion</button>

<button onclick="run(b01)">09. Canvas DrawImage Recursion (GPU Memory)</button>
<button onclick="run(b02)">10. Large TypedArray Construction OOM</button>

<script>
    const L = document.getElementById('log');
    function log(msg) { L.innerHTML += "[*] " + msg + "\n"; L.scrollTop = L.scrollHeight; }

    function run(fn) {
        L.innerHTML += "\n>>> EXECUTANDO " + fn.name + " <<<\n";
        pressure(); // Pre-grooming
        setTimeout(() => {
            try { fn(); } catch(e) { log("Erro Seguro: " + e.message); }
        }, 100);
    }

    // =================================================================
    // 01. Array.reverse Accessor Resize
    // O método reverse() itera sobre o array. Se definirmos um 'getter'
    // em um índice que altera o tamanho do array no meio da operação,
    // o motor pode acessar memória fora dos limites.
    // =================================================================
    function j01() {
        log("Configurando Array Accessor Trap...");
        const arr = [1, 2, 3, 4];
        
        Object.defineProperty(arr, '0', {
            get: function() {
                log("Trap ativada! Reduzindo array...");
                arr.length = 0; // Zera o array
                pressure(); // GC para limpar o buffer antigo
                return 10;
            }
        });
        
        log("Chamando reverse()...");
        // Se vulnerável, o motor tenta escrever nos índices 1, 2, 3 
        // de um array que agora tem tamanho 0.
        arr.reverse(); 
    }

    // =================================================================
    // 02. String.replace Object Detach
    // Passamos um objeto como segundo argumento do replace.
    // Quando o método toString() do objeto é chamado, removemos o iframe
    // onde o código está rodando (se aplicável) ou limpamos o documento.
    // =================================================================
    function j02() {
        log("Criando objeto 'Venenoso'...");
        const poison = {
            toString: function() {
                log("toString() chamado. Destruindo DOM...");
                // Nuke no body força a liberação de muitos objetos
                document.body.innerHTML = ""; 
                pressure();
                return "CRASH";
            }
        };
        
        log("Executando replace...");
        // O motor C++ mantém ponteiros para a string original e o match.
        // O callback destrói o mundo. O motor tenta escrever o resultado.
        "AAAA".replace("A", poison);
    }

    // =================================================================
    // 03. Function.apply Stack Smash
    // Tenta estourar a pilha de execução C++ passando um número
    // absurdo de argumentos via apply.
    // =================================================================
    function j03() {
        log("Gerando array de argumentos gigante...");
        // 2^18 argumentos (262k). Muitos motores limitam a 65k.
        // Se a verificação de limite falhar, corrompe a Stack.
        const args = new Array(262144).fill(1);
        
        function target() { return 1; }
        
        log("Disparando apply()...");
        target.apply(null, args);
    }

    // =================================================================
    // 04. CSS Float Deep Nesting (Layout Engine Crash)
    // Cria uma estrutura de elementos flutuantes aninhados tão profunda
    // que o motor de renderização estoura a pilha ao calcular a posição.
    // =================================================================
    function l01() {
        log("Construindo Torre de Floats...");
        const container = document.createElement('div');
        container.style.width = "100px";
        let curr = container;
        
        // 5000 níveis de aninhamento com float
        for(let i=0; i<5000; i++) {
            const d = document.createElement('div');
            d.style.float = "left";
            d.style.margin = "1px";
            curr.appendChild(d);
            curr = d;
        }
        
        log("Anexando ao DOM (Trigger Layout)...");
        document.body.appendChild(container);
        // Força reflow
        const h = container.offsetHeight; 
        log("Layout calculado (Safe).");
        container.remove();
    }

    // =================================================================
    // 05. Table ColSpan Integer Overflow
    // Tenta bugar o cálculo de largura de tabela usando valores
    // que excedem inteiros de 32 bits ou causam wrap-around.
    // =================================================================
    function l02() {
        log("Criando tabela com ColSpan 1.000.000...");
        const t = document.createElement('table');
        const r = t.insertRow();
        const c = r.insertCell();
        
        // Valor massivo
        c.colSpan = 1000000; 
        c.innerHTML = "Overflow Test";
        
        document.body.appendChild(t);
        // Força renderização complexa
        t.style.borderCollapse = "collapse";
        t.style.width = "100%";
        
        const w = t.offsetWidth;
        log("Tabela renderizada.");
        t.remove();
    }

    // =================================================================
    // 06. Selection Extend Detached Node
    // Seleciona um nó, remove-o do DOM, e tenta estender a seleção
    // para dentro desse nó morto.
    // =================================================================
    function l03() {
        log("Preparando nó de seleção...");
        const d = document.createElement('div');
        d.textContent = "Selection Target";
        document.body.appendChild(d);
        
        const sel = window.getSelection();
        const r = document.createRange();
        r.selectNode(d);
        sel.removeAllRanges();
        sel.addRange(r);
        
        log("Removendo nó e estendendo seleção...");
        d.remove();
        pressure();
        
        // Tenta estender a seleção para um nó que não tem mais documento
        try {
            sel.extend(d, 0); 
        } catch(e) {
            log("Erro capturado: " + e.message);
        }
    }

    // =================================================================
    // 07. document.write Script Injection Race
    // Usa document.write dentro de um script para confundir o parser
    // HTML (Preload Scanner vs Main Parser).
    // =================================================================
    function d01() {
        log("Injetando iframe com write race...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        const doc = ifr.contentDocument;
        doc.open();
        // Escreve um script que escreve outro script que fecha o doc
        // Isso causa reentrância no parser
        doc.write('<script>document.write("<script>window.parent.log(\'Race Triggered\'); parent.pressure();<\/script>");<\/script>');
        doc.close();
        
        setTimeout(() => ifr.remove(), 200);
    }

    // =================================================================
    // 08. Range.insertNode Fragment Confusion
    // Tenta inserir um DocumentFragment que contém o próprio nó
    // onde a inserção está ocorrendo (Ciclo).
    // =================================================================
    function d02() {
        log("Criando ciclo de fragmentos...");
        const frag = document.createDocumentFragment();
        const d = document.createElement('div');
        frag.appendChild(d);
        
        const r = document.createRange();
        r.selectNodeContents(d);
        
        // Tenta inserir o fragmento (que contém d) dentro de d
        log("Inserindo...");
        try {
            r.insertNode(frag);
        } catch(e) {
            log("Erro HierarchyRequest (Safe): " + e.message);
        }
    }

    // =================================================================
    // 09. Canvas DrawImage Recursion (GPU Stress)
    // Desenha o canvas dentro dele mesmo repetidamente para estressar
    // a memória de textura da GPU.
    // =================================================================
    function b01() {
        log("Iniciando Loop de Canvas...");
        const c = document.createElement('canvas');
        c.width = 1000; c.height = 1000;
        const ctx = c.getContext('2d');
        
        let i = 0;
        function loop() {
            // Desenha o próprio canvas (textura) sobre si mesmo
            ctx.drawImage(c, 0, 0);
            if (i++ < 100) loop();
            else log("Loop GPU finalizado.");
        }
        loop();
    }

    // =================================================================
    // 10. Large TypedArray Construction OOM
    // Tenta alocar um ArrayBuffer maior que a RAM física disponível
    // para forçar falha no alocador do Kernel (mmap failure).
    // =================================================================
    function b02() {
        log("Tentando alocar 3GB...");
        try {
            // PS4 tem memória unificada, mas o browser tem limites
            // 3GB deve estourar qualquer limite seguro
            const huge = new Uint8Array(1024 * 1024 * 1024 * 3);
            huge[0] = 1;
            log("Alocação bem sucedida (Surpreendente).");
        } catch(e) {
            log("OOM Seguro: " + e.message);
        }
    }

    // Helper: Heap Feng Shui
    function pressure() {
        const t = [];
        for(let i=0; i<100; i++) t.push(new ArrayBuffer(1024*128));
        t.length = 0;
    }

</script>
</body>
</html>
