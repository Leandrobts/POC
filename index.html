
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PS4 WebKit Fuzzer v3.0 - PS4 Optimized</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    font-family: 'Courier New', monospace; 
    background: #000; 
    color: #0f0; 
    padding: 15px;
    font-size: 14px;
}
.container { max-width: 1400px; margin: 0 auto; }
h1 { 
    color: #0ff; 
    border-bottom: 2px solid #0ff; 
    padding-bottom: 10px; 
    margin-bottom: 20px;
    font-size: 22px;
}
h2 { 
    color: #ff0; 
    margin: 20px 0 10px 0; 
    font-size: 16px;
}
button {
    background: #003300;
    color: #0f0;
    border: 2px solid #0f0;
    padding: 12px 20px;
    margin: 5px;
    cursor: pointer;
    font-family: monospace;
    font-size: 14px;
}
button:hover { background: #005500; }
button.danger { background: #330000; border-color: #f00; color: #f00; }
button.primary { background: #000033; border-color: #00f; color: #0ff; }
input {
    background: #001100;
    color: #0f0;
    border: 1px solid #0f0;
    padding: 8px;
    font-family: monospace;
    margin: 5px;
    font-size: 14px;
}
.status-bar {
    background: #001100;
    border: 2px solid #0f0;
    padding: 15px;
    margin: 15px 0;
}
.status-item {
    display: inline-block;
    margin-right: 20px;
    padding: 5px 10px;
    background: #002200;
}
.status-value {
    color: #ff0;
    font-weight: bold;
    font-size: 18px;
}
#log {
    background: #001100;
    border: 2px solid #0f0;
    padding: 10px;
    height: 400px;
    overflow-y: auto;
    font-size: 12px;
    white-space: pre-wrap;
}
.crash-list {
    background: #110000;
    border: 2px solid #f00;
    padding: 10px;
    margin: 10px 0;
    max-height: 300px;
    overflow-y: auto;
}
.crash-item {
    background: #220000;
    border-left: 4px solid #f00;
    padding: 8px;
    margin: 5px 0;
    cursor: pointer;
    font-size: 11px;
}
.crash-item:hover { background: #330000; }
.info-box {
    background: #000033;
    border: 2px solid #00f;
    padding: 15px;
    margin: 15px 0;
    color: #0ff;
}
.grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 10px;
}
.log-info { color: #0ff; }
.log-warn { color: #ff0; }
.log-error { color: #f00; }
.log-success { color: #0f0; }
.log-crash { 
    color: #f00; 
    font-weight: bold;
    background: #330000;
    padding: 2px 5px;
}
</style>
</head>
<body>

<div class="container">
<h1>üéÆ PS4 WebKit Fuzzer v3.0 - PS4 Optimized</h1>

<div class="info-box">
<strong>üî• OTIMIZADO PARA PS4 WEBKIT</strong><br>
‚Ä¢ Removido: WebGL, WebAudio, SharedArrayBuffer, IndexedDB<br>
‚Ä¢ Focado em: TypedArrays, History, Canvas, DOM, Promises<br>
‚Ä¢ Bug encontrado: <span style="color:#f00">RangeError em ArrayBuffer byteOffset!</span>
</div>

<div class="status-bar">
<div class="status-item">
    Iter: <span class="status-value" id="iter">0</span>
</div>
<div class="status-item">
    Crashes: <span class="status-value" id="crashes">0</span>
</div>
<div class="status-item">
    Except: <span class="status-value" id="exceptions">0</span>
</div>
<div class="status-item">
    Estado: <span class="status-value" id="state">Aguardando</span>
</div>
<div class="status-item">
    Storage: <span class="status-value" id="storage">0 KB</span>
</div>
</div>

<h2>‚öôÔ∏è Configura√ß√£o</h2>
<div>
<label>Itera√ß√µes: <input type="number" id="iterations" value="5000"></label>
<label>Delay (ms): <input type="number" id="delay" value="5"></label>
<label>Auto-save: <input type="checkbox" id="autosave" checked></label>
<label>Verbose: <input type="checkbox" id="verbose"></label>
</div>

<h2>üéØ Fuzzers (PS4 Compatible)</h2>
<div class="grid">
<button onclick="fuzzHistory()">History API</button>
<button onclick="fuzzTypedArrays()">TypedArrays</button>
<button onclick="fuzzCanvas()">Canvas 2D</button>
<button onclick="fuzzPromises()">Promises</button>
<button onclick="fuzzJIT()">JIT Compiler</button>
<button onclick="fuzzDOM()">DOM APIs</button>
<button onclick="fuzzArrayBuffer()" class="danger">üî• ArrayBuffer (Bug!)</button>
<button onclick="fuzzUAF()" class="danger">üî• UAF Patterns</button>
<button onclick="fuzzHeapSpray()">Heap Spray</button>
<button onclick="fuzzRaceConditions()">Race Conditions</button>
<button onclick="fuzzByteOffset()" class="primary">üéØ ByteOffset Bug</button>
<button onclick="fuzzFetch()">Fetch/XHR</button>
</div>

<h2>üöÄ A√ß√µes</h2>
<div>
<button onclick="fuzzAll()" class="danger">FUZZ ALL</button>
<button onclick="stopFuzzing()">‚èπÔ∏è Parar</button>
<button onclick="clearLog()">üóëÔ∏è Limpar Log</button>
</div>

<h2>üíæ Dados</h2>
<div>
<button onclick="saveCrashData()" class="primary">üíæ Salvar</button>
<button onclick="loadCrashData()" class="primary">üìÇ Carregar</button>
<button onclick="exportJSON()">üì§ Exportar</button>
<button onclick="clearStorage()" class="danger">üóëÔ∏è Limpar</button>
<button onclick="viewStats()">üìä Stats</button>
</div>

<h2>üìã Crashes Salvos (<span id="crashCount">0</span>)</h2>
<div class="crash-list" id="crashList">
<em>Nenhum crash ainda.</em>
</div>

<h2>üìù Log</h2>
<div id="log"></div>

</div>

<script>
// ============================================
// ESTADO GLOBAL
// ============================================
let running = false;
let iterCount = 0;
let crashCount = 0;
let exceptionCount = 0;
let crashLog = [];

const STORAGE_KEY = 'ps4_fuzzer_crashes';

// ============================================
// DETEC√á√ÉO DE FEATURES PS4
// ============================================
const PS4_FEATURES = {
    hasWebGL: typeof WebGLRenderingContext !== 'undefined',
    hasWebAudio: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined',
    hasSharedArrayBuffer: typeof SharedArrayBuffer !== 'undefined',
    hasIndexedDB: typeof indexedDB !== 'undefined',
    hasWorkers: typeof Worker !== 'undefined'
};

// ============================================
// PERSIST√äNCIA
// ============================================

function saveCrashData() {
    try {
        const data = {
            version: '3.0',
            timestamp: new Date().toISOString(),
            crashes: crashLog,
            stats: { totalIterations: iterCount, totalCrashes: crashCount, totalExceptions: exceptionCount }
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        updateStorageSize();
        log('üíæ Dados salvos', 'success');
    } catch (e) {
        log('‚ùå Erro ao salvar: ' + e.message, 'error');
    }
}

function loadCrashData() {
    try {
        const data = localStorage.getItem(STORAGE_KEY);
        if (!data) {
            log('‚ÑπÔ∏è Nenhum dado salvo', 'info');
            return;
        }
        const parsed = JSON.parse(data);
        crashLog = parsed.crashes || [];
        if (parsed.stats) {
            iterCount = parsed.stats.totalIterations || 0;
            crashCount = parsed.stats.totalCrashes || 0;
            exceptionCount = parsed.stats.totalExceptions || 0;
        }
        updateCounters();
        updateCrashList();
        updateStorageSize();
        log(`üìÇ ${crashLog.length} crashes carregados`, 'success');
    } catch (e) {
        log('‚ùå Erro ao carregar: ' + e.message, 'error');
    }
}

function exportJSON() {
    try {
        const data = {
            version: '3.0',
            exported: new Date().toISOString(),
            device: 'PS4 WebKit',
            crashes: crashLog,
            stats: { totalIterations: iterCount, totalCrashes: crashCount, totalExceptions: exceptionCount }
        };
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ps4_fuzzer_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        log('üì§ JSON exportado!', 'success');
    } catch (e) {
        log('‚ùå Erro ao exportar: ' + e.message, 'error');
        const win = window.open();
        win.document.write('<pre>' + JSON.stringify({crashes: crashLog}, null, 2) + '</pre>');
    }
}

function clearStorage() {
    if (!confirm('üóëÔ∏è Limpar TODOS os dados?')) return;
    localStorage.removeItem(STORAGE_KEY);
    crashLog = [];
    crashCount = 0;
    iterCount = 0;
    exceptionCount = 0;
    updateCounters();
    updateCrashList();
    updateStorageSize();
    log('üóëÔ∏è Storage limpo!', 'success');
}

function updateStorageSize() {
    try {
        const data = localStorage.getItem(STORAGE_KEY) || '';
        const sizeKB = (data.length / 1024).toFixed(2);
        document.getElementById('storage').textContent = sizeKB + ' KB';
    } catch (e) {
        document.getElementById('storage').textContent = 'N/A';
    }
}

function updateCrashList() {
    const listEl = document.getElementById('crashList');
    document.getElementById('crashCount').textContent = crashLog.length;
    
    if (crashLog.length === 0) {
        listEl.innerHTML = '<em>Nenhum crash ainda.</em>';
        return;
    }
    
    listEl.innerHTML = '';
    const recent = crashLog.slice(-20).reverse();
    
    recent.forEach(crash => {
        const div = document.createElement('div');
        div.className = 'crash-item';
        div.innerHTML = `<strong>[${new Date(crash.timestamp).toLocaleTimeString()}]</strong> ${crash.fuzzer}<br><small>${crash.error}: ${crash.message.substring(0, 80)}</small>`;
        div.onclick = () => alert(JSON.stringify(crash, null, 2));
        listEl.appendChild(div);
    });
}

function viewStats() {
    const errorTypes = {};
    crashLog.forEach(c => errorTypes[c.error] = (errorTypes[c.error] || 0) + 1);
    
    let report = 'üìä ESTAT√çSTICAS\n\n';
    report += `Itera√ß√µes: ${iterCount.toLocaleString()}\n`;
    report += `Crashes: ${crashCount}\n`;
    report += `Exceptions: ${exceptionCount}\n\n`;
    report += 'CRASHES POR TIPO:\n';
    Object.entries(errorTypes).sort((a,b) => b[1] - a[1]).forEach(([t, c]) => {
        report += `  ${t}: ${c}\n`;
    });
    alert(report);
}

// ============================================
// LOG
// ============================================

const logEl = document.getElementById('log');

function log(msg, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const typeClass = 'log-' + type;
    const line = document.createElement('div');
    line.className = typeClass;
    line.textContent = `[${timestamp}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
    
    if (type === 'crash' && document.getElementById('autosave').checked) {
        saveCrashData();
    }
}

function clearLog() {
    logEl.innerHTML = '';
}

function updateStatus(state) {
    document.getElementById('state').textContent = state;
}

function updateCounters() {
    document.getElementById('iter').textContent = iterCount.toLocaleString();
    document.getElementById('crashes').textContent = crashCount;
    document.getElementById('exceptions').textContent = exceptionCount;
}

function stopFuzzing() {
    running = false;
    updateStatus('Parado');
    log('‚èπÔ∏è Fuzzing parado', 'warn');
    saveCrashData();
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// ============================================
// RANDOM
// ============================================

function rand(min = 0, max = 0xFFFFFFFF) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randStr(maxLen = 1000) {
    return 'X'.repeat(rand(0, maxLen));
}

function randBytes(len) {
    const arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) arr[i] = rand(0, 255);
    return arr;
}

function randURL() {
    const schemes = ['#', 'http://', 'https://'];
    return schemes[rand(0, schemes.length - 1)] + randStr(rand(10, 1000));
}

// ============================================
// FUZZER WRAPPER
// ============================================

async function runFuzzer(name, fuzzerFn) {
    running = true;
    updateStatus('Rodando');
    
    const iterations = parseInt(document.getElementById('iterations').value);
    const delay = parseInt(document.getElementById('delay').value);
    const verbose = document.getElementById('verbose').checked;
    
    log(`üöÄ ${name} iniciado...`, 'info');
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            await fuzzerFn();
            
            if (verbose && i % 100 === 0) {
                log(`${name}: ${i}/${iterations}`, 'info');
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            
            // FILTRO: Ignorar erros comuns
            const ignoredErrors = [
                'InvalidCharacterError',
                'NotSupportedError',
                'SyntaxError',
                'NetworkError',
                'AbortError',
                'ReferenceError' // Features ausentes no PS4
            ];
            
            if (!ignoredErrors.includes(e.name)) {
                crashCount++;
                
                const crash = {
                    timestamp: new Date().toISOString(),
                    fuzzer: name,
                    iteration: i,
                    error: e.name,
                    message: e.message,
                    stack: e.stack || 'N/A'
                };
                
                crashLog.push(crash);
                log(`üí• ${e.name}: ${e.message}`, 'crash');
                updateCrashList();
            }
            
            updateCounters();
        }
        
        if (delay > 0) await sleep(delay);
    }
    
    updateStatus('Conclu√≠do');
    log(`‚úÖ ${name} finalizado`, 'success');
    saveCrashData();
}

// ============================================
// FUZZERS
// ============================================

async function fuzzHistory() {
    await runFuzzer('History API', async () => {
        const mutations = [
            () => history.pushState({}, '', randURL()),
            () => history.replaceState({}, '', randURL()),
            () => { for(let i=0; i<rand(1,30); i++) history.pushState({}, '', '#'+i); },
            () => { setTimeout(() => history.back(), 0); history.pushState({}, '', randURL()); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzTypedArrays() {
    await runFuzzer('TypedArrays', async () => {
        const types = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        const Type = types[rand(0, types.length - 1)];
        
        const mutations = [
            () => new Type(rand(0, 100000)),
            () => { const a = new Type(10); a[rand(-10, 20)] = rand(); },
            () => { const a = new Type(10); a.length = rand(0, 1000); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzCanvas() {
    await runFuzzer('Canvas 2D', async () => {
        const c = document.createElement('canvas');
        c.width = rand(1, 5000);
        c.height = rand(1, 5000);
        const ctx = c.getContext('2d');
        
        const mutations = [
            () => ctx.fillRect(rand(), rand(), rand(), rand()),
            () => ctx.createImageData(rand(1, 2000), rand(1, 2000)),
            () => c.toDataURL(),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzPromises() {
    await runFuzzer('Promises', async () => {
        const mutations = [
            () => new Promise((r,j) => setTimeout(() => r(rand()), rand(0,10))),
            () => Promise.race([new Promise(r=>r(1)), new Promise((_,j)=>j(rand()))]),
            () => Promise.all([new Promise(r=>r(1)), new Promise(r=>r(2))]),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzJIT() {
    await runFuzzer('JIT Compiler', async () => {
        const fn = new Function(`let x=${rand()}; for(let i=0;i<100;i++) x+=${rand()}; return x;`);
        for(let i=0; i<50; i++) fn();
    });
}

async function fuzzDOM() {
    await runFuzzer('DOM APIs', async () => {
        const validTags = ['div', 'span', 'p', 'a', 'img', 'canvas'];
        const mutations = [
            () => { const e = document.createElement(validTags[rand(0, validTags.length-1)]); e.innerHTML = randStr(100); document.body.appendChild(e); },
            () => { const e = document.createElement('div'); e.setAttribute('data-test', randStr(1000)); },
            () => { const r = document.createRange(); r.setStart(document.body, 0); r.setEnd(document.body, 1); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzFetch() {
    await runFuzzer('Fetch/XHR', async () => {
        fetch(randURL()).catch(() => {});
    });
}

// ============================================
// üî• FUZZER ESPEC√çFICO: ArrayBuffer ByteOffset
// ============================================
async function fuzzArrayBuffer() {
    await runFuzzer('ArrayBuffer', async () => {
        const mutations = [
            () => new ArrayBuffer(rand(0, 100000)),
            () => { const b = new ArrayBuffer(100); new Uint8Array(b, rand(0, 200)); },
            () => { const b = new ArrayBuffer(100); new Uint32Array(b, rand(0, 200)); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// üéØ FUZZER FOCADO: ByteOffset Bug
// ============================================
async function fuzzByteOffset() {
    await runFuzzer('ByteOffset Bug', async () => {
        // Este √© o bug que voc√™ encontrou!
        // "ArrayBuffer length minus the byteOffset is not a multiple of the element size"
        
        const mutations = [
            // Pattern 1: Offset n√£o-alinhado
            () => {
                const buffer = new ArrayBuffer(rand(10, 1000));
                const offset = rand(0, buffer.byteLength);
                new Uint32Array(buffer, offset); // Deve ser m√∫ltiplo de 4!
            },
            
            // Pattern 2: Offset maior que buffer
            () => {
                const buffer = new ArrayBuffer(100);
                const offset = rand(50, 200);
                new Uint8Array(buffer, offset);
            },
            
            // Pattern 3: Combina√ß√£o perigosa
            () => {
                const buffer = new ArrayBuffer(rand(100, 1000));
                const offset = rand(1, buffer.byteLength);
                const types = [Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array];
                const Type = types[rand(0, types.length - 1)];
                new Type(buffer, offset);
            },
            
            // Pattern 4: Length + Offset overflow
            () => {
                const buffer = new ArrayBuffer(100);
                const offset = rand(50, 100);
                const length = rand(10, 100);
                new Uint32Array(buffer, offset, length);
            },
        ];
        
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// üî• UAF PATTERNS (PS4 Compatible)
// ============================================
async function fuzzUAF() {
    await runFuzzer('UAF Patterns', async () => {
        const mutations = [
            // Pattern 1: Array UAF
            () => {
                let arr = new Array(rand(10, 100));
                setTimeout(() => { arr = null; }, 0);
                for(let i=0; i<10; i++) if(arr) arr[i] = rand();
            },
            
            // Pattern 2: Object delete
            () => {
                let obj = {buffer: new ArrayBuffer(rand(100, 1000))};
                delete obj.buffer;
                new Uint8Array(obj.buffer);
            },
            
            // Pattern 3: DOM UAF
            () => {
                const div = document.createElement('div');
                document.body.appendChild(div);
                div.remove();
                div.innerHTML = randStr(100);
            },
            
            // Pattern 4: ArrayBuffer detach simulation
            () => {
                const buffer = new ArrayBuffer(rand(100, 1000));
                const view = new Uint32Array(buffer);
                view[0] = rand();
                // Simulate detach by creating conflicting views
                new Uint8Array(buffer);
                new Float64Array(buffer);
                view[0] = rand();
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// üî• HEAP SPRAY
// ============================================
async function fuzzHeapSpray() {
    await runFuzzer('Heap Spray', async () => {
        const mutations = [
            () => {
                const spray = [];
                for(let i=0; i<rand(50, 200); i++) spray.push(randStr(rand(64, 256)));
            },
            () => {
                const spray = [];
                for(let i=0; i<rand(50, 200); i++) spray.push({marker: 0x41414141, data: new Uint8Array(128)});
            },
            () => {
                const spray = [];
                for(let i=0; i<rand(20, 100); i++) spray.push(new ArrayBuffer(rand(512, 2048)));
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// üî• RACE CONDITIONS (PS4 Compatible)
// ============================================
async function fuzzRaceConditions() {
    await runFuzzer('Race Conditions', async () => {
        const mutations = [
            // Race 1: History
            () => {
                for(let i=0; i<rand(3,10); i++) {
                    setTimeout(() => history.pushState({}, '', '#'+i), rand(0,10));
                    setTimeout(() => history.back(), rand(0,10));
                }
            },
            
            // Race 2: Canvas
            () => {
                const c = document.createElement('canvas');
                const ctx = c.getContext('2d');
                for(let i=0; i<rand(5,20); i++) {
                    setTimeout(() => {
                        ctx.fillRect(rand(), rand(), rand(10,100), rand(10,100));
                        c.toDataURL();
                    }, rand(0,10));
                }
            },
            
            // Race 3: Promise race with array
            () => {
                const arr = new Array(rand(10,50));
                Promise.race([
                    new Promise(r => setTimeout(() => { arr.length = 0; r(); }, rand(0,5))),
                    new Promise(r => setTimeout(() => { for(let i=0;i<arr.length;i++) arr[i]=rand(); r(); }, rand(0,5)))
                ]);
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// FUZZ ALL
// ============================================
async function fuzzAll() {
    if (!confirm('‚ö†Ô∏è Executar todos os fuzzers?\n\nPode travar o navegador!')) return;
    
    log('üî• FUZZ ALL INICIADO', 'warn');
    
    const fuzzers = [
        fuzzByteOffset,     // Bug encontrado!
        fuzzUAF,
        fuzzTypedArrays,
        fuzzArrayBuffer,
        fuzzHistory,
        fuzzCanvas,
        fuzzPromises,
        fuzzJIT,
        fuzzDOM,
        fuzzHeapSpray,
        fuzzRaceConditions,
        fuzzFetch
    ];
    
    for (const fuzzer of fuzzers) {
        if (!running) break;
        await fuzzer();
        await sleep(1000);
    }
    
    log('üéâ FUZZ ALL COMPLETO!', 'success');
    saveCrashData();
}

// ============================================
// INIT
// ============================================

window.addEventListener('load', () => {
    log('üéÆ PS4 WebKit Fuzzer v3.0', 'success');
    
    // Detectar features
    log('üîç Detectando features do PS4...', 'info');
    Object.entries(PS4_FEATURES).forEach(([key, value]) => {
        log(`  ${key}: ${value ? '‚úÖ' : '‚ùå'}`, value ? 'success' : 'warn');
    });
    
    loadCrashData();
    updateStorageSize();
    
    log('‚úÖ Pronto!', 'success');
    log('üí° Bug encontrado: ByteOffset n√£o-alinhado em TypedArrays!', 'crash');
});

window.addEventListener('beforeunload', () => {
    if (crashCount > 0) saveCrashData();
});
</script>

</body>
</html>
