<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DOM UAF / State Corruption Verifier</title>
<style>
body { font-family: monospace; background:#111; color:#0f0; }
.pass { color:#0f0; }
.fail { color:#f00; }
.warn { color:#ff0; }
</style>
</head>
<body>

<h2>DOM State Corruption Verification Suite</h2>
<button onclick="runTest()">RUN FULL VERIFICATION</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
function log(msg, cls="") {
    const d = document.createElement("div");
    d.textContent = msg;
    if (cls) d.className = cls;
    logEl.appendChild(d);
}

/* ===============================
   GLOBALS
================================ */
let node, marker;
let mutationLog = [];
let observer;
let results = {
    invariant:false,
    api:false,
    mutation:false,
    identity:false,
    gc:false,
    cross:false,
    final:false
};

/* ===============================
   STEP 1 – INVARIANT CHECK
================================ */
function checkInvariants(stage) {
    let ok = true;

    if (node.parentNode !== null) ok = false;
    if (node.isConnected !== false) ok = false;
    if (document.contains(node)) ok = false;

    const pos = node.compareDocumentPosition(document);
    if (!(pos & Node.DOCUMENT_POSITION_DISCONNECTED)) ok = false;

    const root = node.getRootNode();
    if (root !== node && root.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) ok = false;

    log(`[Invariant ${stage}] parentNode=${node.parentNode} isConnected=${node.isConnected} contains=${document.contains(node)} pos=0x${pos.toString(16)}`);
    return ok;
}

/* ===============================
   STEP 2 – API TRIANGULATION
================================ */
function apiTriangulation() {
    let errors = 0;

    try {
        const r = document.createRange();
        r.selectNode(node);
        log("[API] Range.selectNode ACCEPTED removed node", "fail");
        errors++;
    } catch {
        log("[API] Range.selectNode rejected", "pass");
    }

    try {
        const it = document.createNodeIterator(document, NodeFilter.SHOW_ALL);
        let cur;
        while (cur = it.nextNode()) {
            if (cur === node) {
                log("[API] NodeIterator returned removed node", "fail");
                errors++;
                break;
            }
        }
    } catch {}

    try {
        const tw = document.createTreeWalker(document, NodeFilter.SHOW_ALL);
        let cur;
        while (cur = tw.nextNode()) {
            if (cur === node) {
                log("[API] TreeWalker returned removed node", "fail");
                errors++;
                break;
            }
        }
    } catch {}

    return errors > 0;
}

/* ===============================
   STEP 3 – MUTATION OBSERVER
================================ */
function setupObserver() {
    observer = new MutationObserver(muts => {
        muts.forEach(m => {
            m.removedNodes.forEach(n => {
                if (n === node) mutationLog.push("removed");
            });
            m.addedNodes.forEach(n => {
                if (n === node) mutationLog.push("added");
            });
        });
    });
    observer.observe(document.body, { childList:true, subtree:true });
}

/* ===============================
   STEP 4 – IDENTITY MARKER
================================ */
function markIdentity() {
    marker = Symbol("identity");
    node[marker] = 0x1337;
}

function checkIdentity() {
    return node && node[marker] === 0x1337;
}

/* ===============================
   STEP 5 – GC PRESSURE
================================ */
function forceGC() {
    let junk = [];
    for (let i=0;i<20000;i++) {
        junk.push(new ArrayBuffer(1024));
    }
    junk = null;
}

/* ===============================
   STEP 6 – CROSS CONTEXT (iframe)
================================ */
function crossContextCheck(cb) {
    const iframe = document.createElement("iframe");
    iframe.onload = () => {
        try {
            const seen = iframe.contentWindow.document.contains(node);
            cb(seen);
        } catch {
            cb(false);
        }
        iframe.remove();
    };
    document.body.appendChild(iframe);
}

/* ===============================
   RUN ALL
================================ */
function runTest() {
    logEl.textContent = "";
    mutationLog = [];

    setupObserver();

    node = document.createElement("div");
    node.textContent = "TESTNODE";
    document.body.appendChild(node);

    markIdentity();

    document.body.removeChild(node);

    results.invariant = !checkInvariants("POST-REMOVE");

    results.api = apiTriangulation();

    results.mutation = mutationLog.length === 1 && mutationLog[0] === "removed";

    results.identity = checkIdentity();

    forceGC();

    results.gc = checkIdentity();

    crossContextCheck(seen => {
        results.cross = seen;

        finalize();
    });
}

/* ===============================
   FINAL DECISION
================================ */
function finalize() {
    log("================================");

    Object.entries(results).forEach(([k,v])=>{
        log(`${k}: ${v}`, v ? "fail" : "pass");
    });

    if (results.api || results.identity || results.cross) {
        log("BUG CONFIRMADO: DOM STATE CORRUPTION / UAF", "fail");
        results.final = true;
    } else {
        log("NÃO CONFIRMADO", "pass");
    }
}
</script>

</body>
</html>

