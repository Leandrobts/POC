<!DOCTYPE html>
<html>
<head>
    <title>PS4 Lite Fuzzer (Logic over RAM)</title>
    <style>
        body { background: #000; color: #00ffff; font-family: monospace; overflow: hidden; margin: 0; }
        #hud { 
            position: fixed; top: 0; left: 0; width: 100%; 
            background: rgba(0, 0, 20, 0.95); 
            border-bottom: 2px solid #0ff; 
            padding: 15px; z-index: 9999;
            font-size: 24px; font-weight: bold;
        }
        .chaos { border: 1px solid #333; position: absolute; }
    </style>
</head>
<body>
    <div id="hud">
        <div>LITE FUZZER: <span style="color:lime">ATIVO</span> <span id="beat">❤</span></div>
        <div style="font-size: 18px; color: #aaa; margin-top: 5px;">
            SEED ATUAL: <span id="seed-disp" style="color:#fff">...</span> | OBJETOS: <span id="nodes-count">0</span>
        </div>
    </div>

    <iframe id="victim-frame" style="width:1px; height:1px; opacity:0; position:absolute;"></iframe>
    <div id="arena" style="margin-top: 100px;"></div>

    <script>
        // ================= CONFIGURAÇÃO LEVE =================
        // Reduzido drasticamente para evitar OOM imediato
        const MAX_NODES = 150; 
        const ITERATIONS_PER_FRAME = 5; 
        // =====================================================

        let currentSeed = parseInt(localStorage.getItem('lite_seed') || Math.floor(Math.random() * 100000));
        localStorage.setItem('lite_last_start', currentSeed);

        // PRNG
        function seed(s) { currentSeed = s; }
        function rnd() {
            var t = currentSeed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        function coinflip() { return rnd() > 0.5; }

        // UI
        const seedSpan = document.getElementById('seed-disp');
        const nodesSpan = document.getElementById('nodes-count');
        const beatSpan = document.getElementById('beat');
        const arena = document.getElementById('arena');
        const frame = document.getElementById('victim-frame');

        let liveNodes = [];
        let cycleCount = 0;

        // --- VETORES DE ATAQUE (Lógica Pura) ---

        function createToxicNode() {
            // Mantemos o foreignObject pois é o vetor principal de vulnerabilidade
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let foreign = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
            let div = document.createElement("div");
            
            // Atributos leves, sem junk data gigante
            div.className = "chaos";
            if (coinflip()) div.id = "id_" + Math.floor(rnd() * 500);

            foreign.appendChild(div);
            svg.appendChild(foreign);
            return svg;
        }

        function triggerCrossDoc(el) {
            try {
                if (!frame.contentDocument) return;
                let otherDoc = frame.contentDocument;

                // A mágica acontece aqui: mover o nó enquanto observamos
                let obs = new MutationObserver((mutations) => {
                    let t = mutations[0].target;
                    // Tenta corromper o ponteiro
                    t.textContent = "DEAD"; 
                    if (t.parentNode) t.parentNode.removeChild(t);
                });
                
                obs.observe(el, { attributes: true, childList: true, subtree: true });

                // Move para o iframe
                otherDoc.adoptNode(el);
                otherDoc.body.appendChild(el);
                
                // Traz de volta
                document.adoptNode(el);
                arena.appendChild(el);
                
                // Corrupção de estrutura (Prototype Confusion)
                el.__proto__ = {}; 

                obs.disconnect();
            } catch(e) {}
        }

        // LOOP PRINCIPAL SEGURO
        async function loop() {
            while(true) {
                cycleCount++;
                seedSpan.innerText = currentSeed;
                nodesSpan.innerText = liveNodes.length;
                beatSpan.style.opacity = (beatSpan.style.opacity == "1") ? "0.2" : "1";

                // Salva seed com menos frequência para não travar I/O
                if (cycleCount % 20 === 0) localStorage.setItem('lite_seed', currentSeed);

                // PAUSA IMPORTANTE: Deixa o navegador desenhar o HUD
                await new Promise(r => setTimeout(r, 40));

                // Executa lote pequeno de testes
                for(let k=0; k < ITERATIONS_PER_FRAME; k++) {
                    seed(currentSeed);

                    // 1. Criação Controlada
                    if (liveNodes.length < MAX_NODES) {
                        let el = createToxicNode();
                        arena.appendChild(el);
                        liveNodes.push(el);
                    }

                    // 2. Ataque
                    let victim = liveNodes[Math.floor(rnd() * liveNodes.length)];
                    if (victim) {
                        if (coinflip()) triggerCrossDoc(victim);
                        
                        // Layout Thrashing leve
                        try { let _ = victim.getBoundingClientRect().top; } catch(e){}
                    }

                    // 3. Limpeza (Garbage Collection Assistant)
                    // Removemos nós mais agressivamente para manter RAM baixa
                    if (liveNodes.length > MAX_NODES * 0.7) {
                        let idx = Math.floor(rnd() * liveNodes.length);
                        let dying = liveNodes[idx];
                        liveNodes.splice(idx, 1);
                        
                        // Deleção imediata ou atrasada (Race Condition)
                        if (coinflip()) {
                            setTimeout(() => { try{ dying.remove(); }catch(e){} }, 0);
                        } else {
                            try{ dying.remove(); }catch(e){}
                        }
                    }
                    rnd(); 
                }
                
                currentSeed++;

                // Limpeza forçada do DOM para evitar vazamentos eternos
                if (cycleCount % 100 === 0) {
                    arena.innerHTML = ""; // Reseta visual
                    liveNodes = []; // Reseta array JS
                    // Pequeno spray para fragmentar o Heap após limpeza
                    let spray = new Float64Array(100).fill(1.1);
                }
            }
        }

        // Iniciar
        setTimeout(loop, 500);

    </script>
</body>
</html>
