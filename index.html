<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Fullscreen Lock Exploit</title>
</head>
<body>

<h1>PS4 WebKit - Fullscreen Lock Bug Exploitation</h1>

<p><strong>BUG ENCONTRADO:</strong> Alert durante fullscreen TRAVA o estado de fullscreen!</p>
<p><strong>Testes que travam:</strong> 5, 9, 11, 13, 14, 15, 17</p>
<p><strong>Padrão:</strong> Fullscreen + Alert durante transição = Estado corrompido</p>

<h2>Testes Focados (Exploração do Bug)</h2>

<button onclick="exploit1()">Exploit 1: Fullscreen + Alert Imediato</button><br>
<button onclick="exploit2()">Exploit 2: Alert Durante Transição (100ms)</button><br>
<button onclick="exploit3()">Exploit 3: Múltiplos Alerts em Fullscreen</button><br>
<button onclick="exploit4()">Exploit 4: Fullscreen -> Alert -> Tentar Sair</button><br>
<button onclick="exploit5()">Exploit 5: Loop de Fullscreen + Alert</button><br>
<button onclick="exploit6()">Exploit 6: Element Fullscreen + Alert</button><br>
<button onclick="exploit7()">Exploit 7: Fullscreen + Prompt (Input)</button><br>
<button onclick="exploit8()">Exploit 8: Fullscreen + Confirm</button><br>
<button onclick="exploit9()">Exploit 9: Double Alert em Fullscreen</button><br>
<button onclick="exploit10()">Exploit 10: Alert + exitFullscreen() Forçado</button><br>

<h2>Testes de Corrupção (Forçar Crash)</h2>

<button onclick="corruption1()">Corrupção 1: Heap Spray + Fullscreen Lock</button><br>
<button onclick="corruption2()">Corrupção 2: History + Fullscreen Lock</button><br>
<button onclick="corruption3()">Corrupção 3: Canvas + Fullscreen Lock</button><br>
<button onclick="corruption4()">Corrupção 4: TypedArray + Fullscreen Lock</button><br>
<button onclick="corruption5()">Corrupção 5: DOM Manipulation + Lock</button><br>

<h2>Modo Agressivo</h2>

<button onclick="crashTest1()">CRASH TEST 1: 50x Fullscreen Lock</button><br>
<button onclick="crashTest2()">CRASH TEST 2: Lock + Memory Pressure</button><br>
<button onclick="crashTest3()">CRASH TEST 3: Lock + Rapid DOM Changes</button><br>

<h2>Controles</h2>
<button onclick="forceExit()">Forçar Saída de Fullscreen</button>
<button onclick="clearLog()">Limpar Log</button>
<button onclick="saveState()">Salvar Estado</button>

<h2>Log</h2>
<pre id="log"></pre>

<div id="testDiv">Elemento de teste</div>
<canvas id="testCanvas" width="100" height="100"></canvas>

<script>
let lockCount = 0;
let crashAttempts = 0;

function log(msg, type = 'info') {
    const logEl = document.getElementById('log');
    const ts = new Date().toLocaleTimeString();
    const prefix = {
        'info': '[INFO]',
        'warn': '[WARN]',
        'error': '[ERROR]',
        'bug': '[BUG]',
        'crash': '[CRASH]'
    }[type] || '[INFO]';
    logEl.textContent += `[${ts}] ${prefix} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
    document.getElementById('log').textContent = '';
}

function forceExit() {
    try {
        document.exitFullscreen();
        log('Saída de fullscreen forçada', 'info');
    } catch(e) {
        log('Erro ao forçar saída: ' + e.message, 'error');
    }
}

function saveState() {
    const state = {
        lockCount,
        crashAttempts,
        inFullscreen: !!document.fullscreenElement,
        timestamp: new Date().toISOString()
    };
    localStorage.setItem('ps4_fullscreen_bug', JSON.stringify(state));
    log('Estado salvo: ' + JSON.stringify(state), 'info');
}

async function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// ============================================
// EXPLOIT 1: Fullscreen + Alert Imediato
// ============================================
async function exploit1() {
    log('=== EXPLOIT 1: Fullscreen + Alert Imediato ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        // Alert IMEDIATO (0ms delay)
        alert('Alert imediato durante fullscreen!');
        log('Alert fechado', 'info');
        
        // Tentar sair
        log('Tentando sair de fullscreen...', 'warn');
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG: Ainda em fullscreen! Estado travado!', 'bug');
            lockCount++;
            saveState();
        } else {
            log('OK: Saiu de fullscreen normalmente', 'info');
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 2: Alert Durante Transição
// ============================================
async function exploit2() {
    log('=== EXPLOIT 2: Alert Durante Transição (100ms) ===', 'bug');
    
    try {
        document.documentElement.requestFullscreen();
        log('Fullscreen solicitado', 'info');
        
        // Alert durante animação de transição
        await sleep(100);
        alert('Alert durante transição de fullscreen!');
        log('Alert fechado', 'info');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG: Estado de fullscreen travado!', 'bug');
            lockCount++;
            
            // Tentar múltiplas saídas
            for (let i = 0; i < 5; i++) {
                try {
                    await document.exitFullscreen();
                    log('Tentativa ' + (i+1) + ' de sair', 'warn');
                } catch(e) {
                    log('Falha na tentativa ' + (i+1) + ': ' + e.message, 'error');
                }
                await sleep(200);
            }
            
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 3: Múltiplos Alerts
// ============================================
async function exploit3() {
    log('=== EXPLOIT 3: Múltiplos Alerts em Fullscreen ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        await sleep(100);
        
        // 3 alerts seguidos
        alert('Alert 1 de 3');
        log('Alert 1 fechado', 'info');
        
        alert('Alert 2 de 3');
        log('Alert 2 fechado', 'info');
        
        alert('Alert 3 de 3');
        log('Alert 3 fechado', 'info');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG: Múltiplos alerts travaram fullscreen!', 'bug');
            lockCount++;
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 4: Fullscreen -> Alert -> Forçar Saída
// ============================================
async function exploit4() {
    log('=== EXPLOIT 4: Fullscreen -> Alert -> Tentar Sair ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        await sleep(100);
        alert('Pressione OK e tentaremos sair...');
        
        // Tentar sair IMEDIATAMENTE após alert
        log('Tentando exitFullscreen() imediatamente...', 'warn');
        await document.exitFullscreen();
        log('exitFullscreen() executado', 'info');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG CRÍTICO: exitFullscreen() foi ignorado!', 'bug');
            lockCount++;
            
            // Isso é muito suspeito - estado interno corrompido
            log('Estado interno provavelmente corrompido', 'error');
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 5: Loop de Fullscreen + Alert
// ============================================
async function exploit5() {
    if (!confirm('Loop de 10x Fullscreen + Alert. Continuar?')) return;
    
    log('=== EXPLOIT 5: Loop de Fullscreen + Alert ===', 'bug');
    
    for (let i = 0; i < 10; i++) {
        try {
            log(`Iteração ${i+1}/10...`, 'info');
            
            await document.documentElement.requestFullscreen();
            await sleep(100);
            
            alert(`Alert ${i+1}/10`);
            
            await sleep(200);
            
            if (document.fullscreenElement) {
                log(`Iteração ${i+1}: Estado travado`, 'bug');
                lockCount++;
            }
            
            await document.exitFullscreen().catch(()=>{});
            await sleep(300);
            
        } catch(e) {
            log(`CRASH na iteração ${i+1}: ${e.message}`, 'crash');
            crashAttempts++;
            saveState();
            break;
        }
    }
    
    log('Loop completo', 'info');
}

// ============================================
// EXPLOIT 6: Element Fullscreen + Alert
// ============================================
async function exploit6() {
    log('=== EXPLOIT 6: Element Fullscreen + Alert ===', 'bug');
    
    const div = document.getElementById('testDiv');
    
    try {
        await div.requestFullscreen();
        log('Elemento em fullscreen', 'info');
        
        await sleep(100);
        alert('Alert com elemento específico em fullscreen!');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG: Elemento travado em fullscreen!', 'bug');
            log('Elemento travado: ' + document.fullscreenElement.tagName, 'bug');
            lockCount++;
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 7: Fullscreen + Prompt
// ============================================
async function exploit7() {
    log('=== EXPLOIT 7: Fullscreen + Prompt (Input) ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        await sleep(100);
        
        const input = prompt('Digite algo durante fullscreen:');
        log('Prompt input: ' + (input || 'null'), 'info');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG: Prompt travou fullscreen!', 'bug');
            lockCount++;
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 8: Fullscreen + Confirm
// ============================================
async function exploit8() {
    log('=== EXPLOIT 8: Fullscreen + Confirm ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        await sleep(100);
        
        const result = confirm('Confirma durante fullscreen?');
        log('Confirm resultado: ' + result, 'info');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG: Confirm travou fullscreen!', 'bug');
            lockCount++;
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 9: Double Alert
// ============================================
async function exploit9() {
    log('=== EXPLOIT 9: Double Alert em Fullscreen ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        await sleep(50);
        alert('Alert 1');
        
        // Segundo alert IMEDIATAMENTE após o primeiro
        alert('Alert 2 (imediato)');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG CRÍTICO: Double alert travou completamente!', 'bug');
            lockCount++;
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// EXPLOIT 10: Alert + exitFullscreen Forçado
// ============================================
async function exploit10() {
    log('=== EXPLOIT 10: Alert + exitFullscreen() Forçado ===', 'bug');
    
    try {
        await document.documentElement.requestFullscreen();
        log('Fullscreen ativado', 'info');
        
        // Agendar saída durante alert
        setTimeout(async () => {
            log('Tentando sair durante alert aberto...', 'warn');
            try {
                await document.exitFullscreen();
                log('exitFullscreen() chamado durante alert', 'warn');
            } catch(e) {
                log('Erro durante exit: ' + e.message, 'error');
            }
        }, 200);
        
        await sleep(100);
        alert('Alert longo - exitFullscreen será chamado enquanto isso!');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG SEVERO: exitFullscreen() durante alert foi ignorado!', 'bug');
            lockCount++;
            saveState();
        }
        
    } catch(e) {
        log('CRASH: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CORRUPÇÃO 1: Heap Spray + Fullscreen Lock
// ============================================
async function corruption1() {
    if (!confirm('Heap Spray + Fullscreen Lock. Pode crashar! Continuar?')) return;
    
    log('=== CORRUPÇÃO 1: Heap Spray + Fullscreen Lock ===', 'bug');
    
    try {
        // Heap spray
        log('Criando heap spray...', 'info');
        const spray = [];
        for (let i = 0; i < 500; i++) {
            spray.push({
                marker: 0x41414141,
                data: new Uint8Array(256).fill(0x42)
            });
        }
        log('Heap spray criado (500 objetos)', 'info');
        
        // Fullscreen + Alert (trava)
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('Heap spray ativo + fullscreen travado!');
        
        // Tentar manipular heap enquanto travado
        log('Manipulando heap com fullscreen travado...', 'warn');
        for (let i = 0; i < 100; i++) {
            spray[i] = null; // Free
            spray.push(new ArrayBuffer(512)); // Realloc
        }
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG + HEAP SPRAY: Estado corrompido!', 'bug');
            log('Possível UAF ou heap corruption', 'error');
            saveState();
        }
        
    } catch(e) {
        log('CRASH COM HEAP SPRAY: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CORRUPÇÃO 2: History + Fullscreen Lock
// ============================================
async function corruption2() {
    log('=== CORRUPÇÃO 2: History + Fullscreen Lock ===', 'bug');
    
    try {
        // Manipular histórico
        log('Criando entradas de histórico...', 'info');
        for (let i = 0; i < 40; i++) {
            history.pushState({}, '', '#history' + i);
        }
        log('40 entradas criadas', 'info');
        
        // Fullscreen + Alert (trava)
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('Histórico cheio + fullscreen travado!');
        
        // Navegar com fullscreen travado
        log('Navegando no histórico com fullscreen travado...', 'warn');
        for (let i = 0; i < 10; i++) {
            history.back();
            await sleep(50);
        }
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG + HISTORY: Combinação perigosa!', 'bug');
            saveState();
        }
        
    } catch(e) {
        log('CRASH COM HISTORY: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CORRUPÇÃO 3: Canvas + Fullscreen Lock
// ============================================
async function corruption3() {
    log('=== CORRUPÇÃO 3: Canvas + Fullscreen Lock ===', 'bug');
    
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    
    try {
        // Fullscreen no canvas + Alert
        await canvas.requestFullscreen();
        await sleep(100);
        alert('Canvas em fullscreen travado!');
        
        // Manipular canvas enquanto travado
        log('Manipulando canvas com fullscreen travado...', 'warn');
        for (let i = 0; i < 100; i++) {
            ctx.fillRect(0, 0, 100, 100);
            ctx.clearRect(0, 0, 100, 100);
        }
        
        // Tentar toDataURL
        const data = canvas.toDataURL();
        log('toDataURL executado: ' + data.length + ' bytes', 'info');
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG + CANVAS: Possível memory corruption!', 'bug');
            saveState();
        }
        
    } catch(e) {
        log('CRASH COM CANVAS: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CORRUPÇÃO 4: TypedArray + Fullscreen Lock
// ============================================
async function corruption4() {
    log('=== CORRUPÇÃO 4: TypedArray + Fullscreen Lock ===', 'bug');
    
    try {
        // Criar TypedArrays
        log('Criando TypedArrays...', 'info');
        const arrays = [];
        for (let i = 0; i < 100; i++) {
            arrays.push(new Uint32Array(1000));
        }
        
        // Fullscreen + Alert
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('TypedArrays + fullscreen travado!');
        
        // Manipular arrays com fullscreen travado
        log('Manipulando TypedArrays com fullscreen travado...', 'warn');
        for (let i = 0; i < arrays.length; i++) {
            for (let j = 0; j < arrays[i].length; j++) {
                arrays[i][j] = 0x41414141;
            }
        }
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG + TYPEDARRAY: Combinação exploitável!', 'bug');
            saveState();
        }
        
    } catch(e) {
        log('CRASH COM TYPEDARRAY: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CORRUPÇÃO 5: DOM + Fullscreen Lock
// ============================================
async function corruption5() {
    log('=== CORRUPÇÃO 5: DOM Manipulation + Lock ===', 'bug');
    
    try {
        // Fullscreen + Alert
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('Fullscreen travado - manipulando DOM!');
        
        // Manipular DOM agressivamente
        log('Manipulando DOM com fullscreen travado...', 'warn');
        for (let i = 0; i < 100; i++) {
            const div = document.createElement('div');
            div.innerHTML = 'Test ' + i;
            document.body.appendChild(div);
            
            if (i % 2 === 0) {
                div.remove();
            }
        }
        
        await sleep(500);
        
        if (document.fullscreenElement) {
            log('BUG + DOM: Estado DOM corrompido!', 'bug');
            saveState();
        }
        
    } catch(e) {
        log('CRASH COM DOM: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CRASH TEST 1: 50x Fullscreen Lock
// ============================================
async function crashTest1() {
    if (!confirm('50 iterações de Fullscreen Lock. ALTO RISCO! Continuar?')) return;
    
    log('=== CRASH TEST 1: 50x Fullscreen Lock ===', 'crash');
    
    for (let i = 0; i < 50; i++) {
        try {
            log(`[${i+1}/50] Tentando travar...`, 'warn');
            
            await document.documentElement.requestFullscreen();
            await sleep(50);
            alert('Lock ' + (i+1));
            
            if (document.fullscreenElement) {
                log(`[${i+1}] TRAVADO!`, 'bug');
                lockCount++;
            }
            
            await document.exitFullscreen().catch(()=>{});
            await sleep(100);
            
        } catch(e) {
            log(`CRASH NA ITERAÇÃO ${i+1}: ${e.message}`, 'crash');
            crashAttempts++;
            saveState();
            break;
        }
    }
    
    log('Crash test 1 completo', 'info');
    log(`Total de locks: ${lockCount}`, 'bug');
    log(`Total de crashes: ${crashAttempts}`, 'crash');
}

// ============================================
// CRASH TEST 2: Lock + Memory Pressure
// ============================================
async function crashTest2() {
    if (!confirm('Lock + Memory Pressure. RISCO EXTREMO! Continuar?')) return;
    
    log('=== CRASH TEST 2: Lock + Memory Pressure ===', 'crash');
    
    try {
        // Memory pressure
        log('Criando memory pressure...', 'warn');
        const big = [];
        for (let i = 0; i < 100; i++) {
            big.push(new Array(10000).fill('X'.repeat(1000)));
        }
        log('Memory pressure criada', 'info');
        
        // Fullscreen Lock
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('Memory pressure + Fullscreen lock!');
        
        // Mais alocações com lock ativo
        log('Alocando mais memória com lock ativo...', 'warn');
        for (let i = 0; i < 50; i++) {
            big.push(new ArrayBuffer(100000));
        }
        
        await sleep(500);
        
        log('Teste completo - se não crashou, é resiliente', 'info');
        
    } catch(e) {
        log('CRASH COM MEMORY PRESSURE: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// CRASH TEST 3: Lock + Rapid DOM Changes
// ============================================
async function crashTest3() {
    if (!confirm('Lock + Rapid DOM. RISCO ALTO! Continuar?')) return;
    
    log('=== CRASH TEST 3: Lock + Rapid DOM Changes ===', 'crash');
    
    try {
        // Fullscreen Lock
        await document.documentElement.requestFullscreen();
        await sleep(100);
        alert('Lock ativo - modificando DOM rapidamente!');
        
        // DOM changes rápidos
        log('Modificações rápidas de DOM...', 'warn');
        for (let i = 0; i < 1000; i++) {
            const el = document.createElement('div');
            el.innerHTML = '<span>Test</span>'.repeat(10);
            document.body.appendChild(el);
            el.remove();
        }
        
        await sleep(500);
        
        log('DOM stress test completo', 'info');
        
    } catch(e) {
        log('CRASH COM DOM RAPID: ' + e.message, 'crash');
        crashAttempts++;
        saveState();
    }
}

// ============================================
// INIT
// ============================================
log('PS4 WebKit - Fullscreen Lock Exploit Tool');
log('Bug Pattern: Fullscreen + Alert = Estado travado');
log('');
log('Testes que travam: 5, 9, 11, 13, 14, 15, 17');
log('');
log('Estatísticas:');
const saved = localStorage.getItem('ps4_fullscreen_bug');
if (saved) {
    const state = JSON.parse(saved);
    log('  Locks anteriores: ' + state.lockCount);
    log('  Crashes anteriores: ' + state.crashAttempts);
    log('  Último teste: ' + state.timestamp);
}
log('');
log('Pronto para exploração!');
</script>

</body>
</html>
