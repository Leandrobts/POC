<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Invariant Violation Suite v32000</title>
<style>
    body { background: #050505; color: #ccc; font-family: 'Consolas', monospace; padding: 15px; }
    h1 { color: #ff5555; border-bottom: 2px solid #ff5555; text-transform: uppercase; font-size: 18px; }
    .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    button { 
        padding: 12px; background: #1a1a1a; color: #fff; border: 1px solid #444; 
        cursor: pointer; text-align: left; font-size: 11px; transition: 0.2s;
    }
    button:hover { background: #333; border-color: #ff5555; }
    #log { 
        border: 1px solid #444; height: 350px; overflow-y: auto; 
        background: #000; padding: 10px; margin-top: 15px; white-space: pre-wrap; font-size: 12px;
    }
    .clean { color: #666; }
    .leak { color: #00ff00; font-weight: bold; border-left: 3px solid #00ff00; padding-left: 5px; }
    .suspicious { color: #ffff00; }
</style>
</head>
<body>

<h1>SUITE V32000: INVARIANT VIOLATIONS II</h1>
<p>Methodology: Native API -> Callback Mutation -> Desynchronized Read</p>

<div class="btn-group">
    <button onclick="testReduceShrink()">01. Array.reduceRight -> Shrink Length</button>

    <button onclick="testRegExpGetter()">02. RegExp.exec -> 'input' Getter Mutation</button>

    <button onclick="testFormDataLoop()">03. FormData Iterator -> Infinite Append Loop</button>

    <button onclick="testURLSort()">04. URLSearchParams.sort -> Mutate during Compare</button>

    <button onclick="testTypedArrayOverlap()">05. TypedArray.set -> Self-Overlap (Memcpy)</button>

    <button onclick="testIntlCache()">06. Intl.NumberFormat -> Getter Cache Invalidation</button>

    <button onclick="testSpliceParams()">07. Array.splice -> Proxy Params Resize</button>

    <button onclick="testMessageNeuter()">08. MessageEvent -> Getter Neutering Buffer</button>

    <button onclick="testStringMatch()">09. String.match -> RegExp.lastIndex Side-Effect</button>

    <button onclick="testPromiseRace()">10. Promise.race -> Thenable State Mutation</button>
</div>

<div id="log">Waiting for input...</div>

<script>
    const LOG = document.getElementById('log');

    function log(msg, type = 'clean') {
        const div = document.createElement('div');
        div.textContent = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}`;
        div.className = type;
        LOG.appendChild(div);
        LOG.scrollTop = LOG.scrollHeight;
    }

    // Analisador de Memória Real
    // Não usamos valores falsos. Analisamos o que o motor nos devolveu.
    function analyze(val, context) {
        if (val === undefined || val === null) {
            log(`${context}: Clean (Undefined/Null)`);
            return;
        }

        if (typeof val === 'number') {
            // Se for um inteiro pequeno, é lógico.
            // Se for gigante (ponteiro) ou float quebrado (memória suja), é leak.
            if (Number.isInteger(val) && Math.abs(val) < 10000) {
                log(`${context}: Logical Result (${val})`, 'clean');
            } else {
                log(`[!!!] MEMORY LEAK (${context}): ${val}`, 'leak');
                // Tenta converter para Hex para ver se parece ponteiro
                if(Math.abs(val) > 0xFFFFFF) console.log("Hex candidate: 0x" + Math.abs(val).toString(16));
            }
            return;
        }

        if (typeof val === 'string') {
            // Strings vazias ou normais são ok.
            // Strings com caracteres de controle (ASCII < 32) são vazamento de heap.
            if (/[\x00-\x08\x0E-\x1F]/.test(val)) {
                log(`[!!!] STRING BUFFER LEAK (${context}): Contains Control Chars`, 'leak');
            } else {
                log(`${context}: String Clean`, 'clean');
            }
        }
    }

    // 01. Array.reduceRight Shrink
    // Invariante: reduceRight itera de length-1 até 0.
    // Violação: Se diminuirmos o length durante a redução, o índice interno pode ficar maior que o array real.
    // Resultado: Leitura de memória OOB (Out of Bounds).
    function testReduceShrink() {
        const arr = [0, 1, 2, 3, 4, 5];
        let leak = undefined;
        
        try {
            arr.reduceRight((acc, val, i, theArr) => {
                if (i === 4) {
                    // MUTATION: Corta o array drasticamente
                    theArr.length = 0;
                    // Tenta forçar GC ou realloc imediato
                    const filler = new Array(100).fill(1.1);
                }
                // Se o motor continuar para o índice 3, 2, 1... mas o array tem tamanho 0,
                // 'val' será lido de onde o array estava.
                if (theArr.length === 0 && val !== undefined) {
                    leak = val;
                }
                return acc;
            });
            analyze(leak, "ReduceRight Shrink");
        } catch(e) { log("ReduceRight Safe: " + e.message); }
    }

    // 02. RegExp.exec 'input' Getter Mutation
    // Invariante: A string de input deve ser estável.
    // Violação: Usamos uma subclasse de RegExp para interceptar a leitura de 'exec'.
    function testRegExpGetter() {
        class EvilRegExp extends RegExp {
            exec(str) {
                // A engine chama exec. Nós chamamos o super.exec, mas passamos algo mutável?
                // Ou exploramos o lastIndex.
                return super.exec(str);
            }
        }
        const re = new EvilRegExp(/./);
        // O truque aqui é RegExp.input é estático.
        const str = "test";
        re.exec(str);
        
        // Verifica se RegExp.input mantém referência para string morta
        const residue = RegExp.input; 
        // Em alguns builds, se deletarmos a string original...
        analyze(residue, "RegExp Input");
    }

    // 03. FormData Iterator Infinite Append Loop
    // Invariante: Iteradores devem lidar com modificações na coleção.
    // Violação: Adicionar itens enquanto itera. Algumas implementações leem buffers desalocados ao redimensionar.
    function testFormDataLoop() {
        const fd = new FormData();
        fd.append("a", "1");
        
        let count = 0;
        let leaked = null;
        
        for (const [key, val] of fd) {
            if (count++ > 50) break; // Previne travamento total
            
            // MUTATION: Append forçando resize do backing store
            fd.append("b" + count, "x".repeat(100));
            
            // Se o iterador não atualizar o ponteiro do buffer após o resize,
            // 'key' ou 'val' podem ler do buffer antigo (freed).
            if (key.length > 100 || val.length > 100) continue; // Skip normais
            
            // Checa por anomalias
            if (val !== "1" && !val.startsWith("x")) leaked = val;
        }
        analyze(leaked, "FormData Iterator");
    }

    // 04. URLSearchParams.sort Mutate during Compare
    // Invariante: A lista não muda durante o sort.
    // Violação: O callback de comparação (via toString) altera a lista.
    function testURLSort() {
        const p = new URLSearchParams("a=1&b=2&c=3");
        
        // Custom object que será convertido para string durante o sort interno
        const evil = {
            toString: () => {
                // MUTATION: Deleta tudo
                p.delete("a");
                p.delete("b");
                p.delete("c");
                return "a";
            }
        };
        
        p.append("d", evil);
        
        try {
            p.sort();
            // Se o algoritmo de sort (quicksort/mergesort) tinha ponteiros para 'a', 'b', 'c'...
            // eles agora são inválidos. O que sobrou na lista?
            const res = p.toString();
            log("URLSort Result: " + res, 'clean');
        } catch(e) { log("URLSort Safe"); }
    }

    // 05. TypedArray.set Self-Overlap (Memcpy)
    // Invariante: Cópia de memória com overlap deve usar memmove.
    // Violação: Se a engine otimizar para memcpy em offsets específicos.
    function testTypedArrayOverlap() {
        const buf = new ArrayBuffer(1024);
        const u8 = new Uint8Array(buf);
        // Preenche com padrão conhecido
        for(let i=0; i<1024; i++) u8[i] = i % 255;
        
        // Copia do índice 0 para o índice 1 (Overlap de 1 byte para frente)
        // Se for memcpy, vai propagar o primeiro byte (0) para tudo.
        // Se for memmove, vai deslocar corretamente.
        u8.set(u8.subarray(0, 500), 1);
        
        // Verifica corrupção
        if (u8[1] === u8[0] && u8[2] === u8[0] && u8[10] === u8[0]) {
            // Se propagou, é memcpy incorreto (Logic Bug, não Leak, mas perigoso)
            log("TypedArray Overlap: CORRUPTED (Memcpy used)", "suspicious");
        } else {
            log("TypedArray Overlap: Safe (Memmove used)", "clean");
        }
    }

    // 06. Intl.NumberFormat Getter Cache Invalidation
    // Invariante: Caches internos do Intl assumem objetos imutáveis.
    // Violação: Passar um objeto que muda suas propriedades quando lido.
    function testIntlCache() {
        const nf = new Intl.NumberFormat();
        const evil = {
            get value() {
                // Tenta limpar o cache do Intl forçando GC ou nova configuração
                // (Conceitual, difícil triggerar sem API específica)
                return 1; 
            },
            valueOf: () => {
                // MUTATION
                return 100;
            }
        };
        
        try {
            const res = nf.format(evil);
            analyze(undefined, "Intl Format (Safe)");
        } catch(e) { log("Intl Safe"); }
    }

    // 07. Array.splice Proxy Params Resize
    // Invariante: Argumentos de splice (start, deleteCount) são lidos uma vez.
    // Violação: Usar um objeto com valueOf que redimensiona o array entre a leitura de 'start' e 'deleteCount'.
    function testSpliceParams() {
        const arr = [1, 2, 3, 4];
        const evil = {
            valueOf: () => {
                // MUTATION: Esvazia array
                arr.length = 0;
                return 0; // index 0
            }
        };
        
        // splice(start, deleteCount)
        // Se a engine ler 'start' (nosso evil object), rodar a mutação, e depois ler 'deleteCount'...
        // Ela vai tentar deletar itens de um array vazio.
        const res = arr.splice(evil, 10);
        
        // Se retornou itens que não deveriam estar lá (lixo de memória)
        if (res.length > 0 && res[0] !== 1) {
            analyze(res[0], "Splice Resize");
        } else {
            log("Splice Safe");
        }
    }

    // 08. MessageEvent Getter Neutering Buffer
    // Invariante: O buffer de dados do evento é válido durante o evento.
    // Violação: Usar um getter que transfere (neuter) o buffer.
    function testMessageNeuter() {
        const ab = new ArrayBuffer(1024);
        const ev = new MessageEvent("message", { data: ab });
        
        try {
            // Tenta acessar o buffer enquanto transfere ele via Worker (simulado aqui por falta de SAB)
            // Em JS puro, tentamos confundir o tipo.
            const d = ev.data;
            if (d.byteLength === 0) log("MessageEvent: Already neutered");
            else log("MessageEvent: Valid");
        } catch(e) {}
    }

    // 09. String.match RegExp.lastIndex Side-Effect
    // Invariante: lastIndex define onde começa o match.
    // Violação: O getter de lastIndex muda a string que está sendo processada? (Impossível em JS, string imutável).
    // Mas pode mudar o RegExp global.
    function testStringMatch() {
        const str = "test string";
        const re = /t/g;
        
        Object.defineProperty(re, 'lastIndex', {
            get: () => {
                // Side-effect: muda flags ou compilação
                return 0;
            }
        });
        
        try {
            const res = str.match(re);
            log("String Match: Safe");
        } catch(e) {
            // Se crashar ou der erro estranho
            analyze(e.message, "String Match Error");
        }
    }

    // 10. Promise.race Thenable State Mutation
    // Invariante: Promise.race itera e resolve o primeiro.
    // Violação: Um 'thenable' malicioso que muda o estado dos outros itens no array do race.
    function testPromiseRace() {
        const p1 = Promise.resolve(1);
        const evil = {
            then: (resolve) => {
                // MUTATION: Não resolve, mas consome muita CPU ou aloca memória
                // tentando forçar uma race no job queue
                const arr = new Uint32Array(100000); // Pressão de memória
                resolve(arr[0]); 
            }
        };
        
        Promise.race([evil, p1]).then(val => {
            // Se 'val' for lixo de memória devido à pressão...
            analyze(val, "Promise Race");
        });
    }

</script>

</body>
</html>
