<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Webkit Diagnostic Lab</title>
<style>
    body { background-color: #000; color: #0f0; font-family: 'Courier New', monospace; padding: 20px; font-size: 16px; }
    h1 { color: #fff; border-bottom: 2px solid #0f0; }
    .box { border: 1px solid #444; padding: 10px; margin-bottom: 10px; }
    .pass { color: lime; font-weight: bold; }
    .fail { color: red; font-weight: bold; }
    .warn { color: yellow; font-weight: bold; }
    #console-log { height: 300px; overflow-y: scroll; border: 1px solid #333; padding: 5px; color: #ccc; }
</style>
</head>
<body>

<h1>WEBKIT DIAGNOSTIC SUITE (v1.0)</h1>
<div id="status">Status: AGUARDANDO START...</div>

<div class="box">
    <div>TESTE 1 (Liveness): <span id="t1">---</span></div>
    <div>TESTE 2 (Float Overlap): <span id="t2">---</span></div>
    <div>TESTE 3 (Pointer Leak): <span id="t3">---</span></div>
    <div>TESTE 4 (String Safety): <span id="t4">---</span></div>
</div>

<button onclick="startLab()" style="padding:15px; font-size:1.2em; font-weight:bold;">INICIAR LABORATÓRIO</button>
<br><br>
<div id="console-log">Logs aparecerão aqui...</div>

<script>
    const logDiv = document.getElementById('console-log');
    function log(msg) { logDiv.innerHTML += ">> " + msg + "<br>"; logDiv.scrollTop = logDiv.scrollHeight; }
    
    // Configurações Globais
    let victim_arr = [];
    let spray_arr = [];
    let pressure_arr = [];
    
    // Variáveis de Controle
    let running = false;

    function startLab() {
        if(running) return;
        running = true;
        document.getElementById('status').innerText = "Status: PREPARANDO HEAP...";
        log("Iniciando alocação inicial...");

        // 1. Setup: Criação de Vítimas
        // Criamos arrays intercalados para tentar detectar corrupção vizinha
        for(let i=0; i<5000; i++) {
            let v = new Float64Array(8);
            v[0] = 1337; // Marcador de integridade
            victim_arr.push(v);
        }
        
        log("Heap pronto. Pressione OPTIONS para rodar os diagnósticos.");
        document.getElementById('status').innerText = "Status: ESPERANDO MENU OPTIONS (BLUR)";

        // Fullscreen Trigger
        const doc = document.documentElement;
        if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
        else if (doc.requestFullscreen) doc.requestFullscreen();

        // O GATILHO DA BATERIA DE TESTES
        window.onblur = function() {
            document.body.style.background = "#111";
            document.getElementById('status').innerText = "Status: EXECUTANDO TESTES...";
            log("Blur detectado! Iniciando diagnósticos sem refresh...");
            
            runTest1();
            setTimeout(runTest2, 500);
            setTimeout(runTest3, 1000);
            setTimeout(runTest4, 1500);
            
            setTimeout(() => {
                log("DIAGNÓSTICO COMPLETO. Se nada falhou, o bug é APENAS no Teardown.");
                document.getElementById('status').innerText = "Status: CONCLUÍDO. PODE ATUALIZAR AGORA.";
            }, 2000);
        };
    }

    // --- TESTE 1: Liveness Check (O objeto some?) ---
    function runTest1() {
        log("Rodando Teste 1: Checagem de Sobrevivência...");
        try {
            // Tentamos acessar um array antigo.
            // Se o UAF já tiver matado ele silenciosamente, isso vai dar erro.
            let val = victim_arr[100][0];
            if(val === 1337) {
                document.getElementById('t1').innerHTML = "<span class='pass'>PASS (Objeto Vivo)</span>";
                log("T1: Objetos acessíveis normalmente.");
            } else {
                document.getElementById('t1').innerHTML = "<span class='fail'>FAIL (Dados Corrompidos)</span>";
                log("T1: ALERTA! Dados mudaram sozinhos!");
            }
        } catch(e) {
            document.getElementById('t1').innerHTML = "<span class='warn'>ERRO (Objeto Morto)</span>";
            log("T1: Erro ao acessar objeto: " + e);
        }
    }

    // --- TESTE 2: Float Overlap (Spray Intrusivo) ---
    function runTest2() {
        log("Rodando Teste 2: Spray de Floats...");
        // Tentamos liberar metade dos arrays e encher com "Lixo"
        // Se o bug for agressivo, o lixo vai aparecer nos arrays que SOBRARAM.
        
        let local_spray = [];
        const MAGIC = 9.999e-300; // Um valor float específico

        try {
            // Simula free parcial (buracos no queijo suíço)
            // Cuidado: Liberar demais pode crashar
            for(let i=0; i<1000; i++) victim_arr[i] = null; 

            // Tenta preencher
            for(let i=0; i<2000; i++) {
                let f = new Float64Array(8);
                f.fill(MAGIC);
                local_spray.push(f);
            }

            // Verifica se vazou para os sobreviventes (índice 2000 em diante)
            let corrupt = false;
            for(let i=2000; i<3000; i++) {
                if(victim_arr[i] && victim_arr[i][0] !== 1337) {
                    corrupt = true;
                    log("T2: CORRUPÇÃO DETECTADA no índice " + i + " Valor: " + victim_arr[i][0]);
                }
            }

            if(corrupt) document.getElementById('t2').innerHTML = "<span class='fail'>FAIL (OVERLAP DETECTADO!)</span>";
            else document.getElementById('t2').innerHTML = "<span class='pass'>PASS (Estável)</span>";

        } catch(e) { log("T2 Erro: " + e); }
    }

    // --- TESTE 3: Pointer Leak (Confusão de Tipos) ---
    function runTest3() {
        log("Rodando Teste 3: Tentativa de AddrOf rápida...");
        // Tenta ver se algum float virou um número gigante bizarro
        let leak = false;
        try {
            for(let i=2000; i<3000; i++) {
                if(victim_arr[i]) {
                    let v = victim_arr[i][0];
                    if(v > 100000 && !Number.isInteger(v)) { // Heurística simples
                        leak = true;
                    }
                }
            }
            if(leak) document.getElementById('t3').innerHTML = "<span class='warn'>POSSIBLE LEAK</span>";
            else document.getElementById('t3').innerHTML = "<span class='pass'>PASS (Sem vazamento)</span>";
        } catch(e) {}
    }

    // --- TESTE 4: String Safety (Checa se Strings continuam legíveis) ---
    function runTest4() {
        log("Rodando Teste 4: Integridade de Texto...");
        // Aloca strings novas para ver se o alocador de string tá quebrado
        try {
            let s = "TESTE_DE_STRING_SEGURA";
            let s2 = s.toLowerCase();
            if(s2 === "teste_de_string_segura") {
                 document.getElementById('t4').innerHTML = "<span class='pass'>PASS (Strings OK)</span>";
            } else {
                 document.getElementById('t4').innerHTML = "<span class='fail'>FAIL (Strings Quebradas)</span>";
            }
        } catch(e) {
            document.getElementById('t4').innerHTML = "<span class='fail'>CRITICAL ERROR</span>";
        }
    }
</script>
</body>
</html>
