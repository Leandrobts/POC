<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Detecção DataView OOB (PS4)</title>
  <style>#log{white-space:pre-wrap;font-family:monospace;padding:10px;background:#111;color:#efe;height:60vh;overflow:auto}</style>
</head>
<body>
  <h2>Detecção DataView OOB — execute no navegador do PS4</h2>
  <button id="run">Rodar Teste DataView OOB (seguro)</button>
  <div id="log">Aguardando...</div>

  <script>
  const L = document.getElementById('log');
  function log(...a){ L.textContent = new Date().toISOString() + '  ' + a.join(' ') + '\n' + L.textContent; }

  function hexdump32(v){ return '0x' + v.toString(16); }

  function detectDataViewOOB(iterations = 2000, maxOffsetProbe = 80) {
    log('=== Iniciando DataView OOB detector ===');
    log('Iterations:', iterations, 'probe max offset:', maxOffsetProbe);

    let anomalies = [];
    for (let it = 0; it < iterations; it++) {
      // small buffer that must throw for offsets >= length
      const ab = new ArrayBuffer(16);
      const dv = new DataView(ab);

      // put a known sentinel on valid positions
      dv.setUint32(0, 0x11111111, true);
      dv.setUint32(4, 0x22222222, true);
      dv.setUint32(8, 0x33333333, true);
      dv.setUint32(12, 0x44444444, true);

      // probe offsets (including offsets beyond buffer)
      for (let off = 0; off <= maxOffsetProbe; off += 4) {
        try {
          const val = dv.getUint32(off, true); // expected: works for 0..12, RangeError for >=16
          // If no exception and offset >= 16 -> ANOMALIA
          if (off >= 16) {
            anomalies.push({iteration: it, offset: off, value: val});
            log('[ANOMALIA] getUint32 retornou sem RangeError at offset', off, '=>', hexdump32(val));
            // break early if many anomalies
            if (anomalies.length >= 20) break;
          }
        } catch (e) {
          // RangeError or other is expected for out-of-range offsets
          if (off < 16) {
            log('[ERRO INESPERADO] leitura em offset válido lançou:', off, e.message);
          }
        }
      }

      // small pressure to encourage GC / mixing
      if ((it % 50) === 0) {
        try {
          new ArrayBuffer(0x7FFFFF0); // stress allocation
        } catch (e) { /* ignore */ }
      }

      if (anomalies.length >= 20) break;
    }

    if (anomalies.length === 0) {
      log('Resultado: nenhum OOB detectado neste ciclo. (Comportamento esperado)');
    } else {
      log('>>> POSSÍVEL OOB detectado! total anomalies:', anomalies.length);
      // print short report
      anomalies.slice(0,20).forEach(a => log(JSON.stringify(a)));
    }

    // return summary for automated capture
    return { anomaliesCount: anomalies.length, anomaliesSample: anomalies.slice(0,10) };
  }

  document.getElementById('run').onclick = () => {
    L.textContent = '';
    const res = detectDataViewOOB(800, 80);
    log('Teste finalizado. anomaliesCount=', res.anomaliesCount);
    // if anomaly -> keep page open for you to copy logs
  };
  </script>
</body>
</html>
