<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v340000: GPU Starvation</title>
<style>
    body { background: #000; color: #fff; font-family: monospace; text-align: center; padding: 10px; overflow: hidden; }
    h1 { border-bottom: 2px solid #fff; }
    .status { 
        border: 2px solid #f00; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #300; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #900; color: #fff; border: 2px solid #f00;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f00; color: #000; }
    
    /* Camada de stress GPU */
    .layer {
        position: absolute; width: 10px; height: 10px; background: red;
        will-change: transform; /* Força criação de camada na GPU */
    }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v340000: GPU STARVATION</h1>

<div class="status">
    ESTRATÉGIA: TELA BRANCA + 3D LAYERS + CPU LOCK<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA
</div>

<button onclick="starve(s01)">01. 3D Layer Bomb + White Screen Lock</button>

<button onclick="starve(s02)">02. SVG Filter Bomb + White Screen Lock</button>

<button onclick="starve(s03)">03. Canvas Context Loss + CPU Lock</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    // =================================================================
    // FUNÇÃO DE CARGA GPU (PRE-CRASH)
    // Cria milhares de elementos compostos para encher a memória de vídeo
    // =================================================================
    function gpuLoad(container) {
        const frag = document.createDocumentFragment();
        // Cria 2000 elementos com aceleração de hardware (3D)
        for(let i=0; i<2000; i++) {
            const d = document.createElement('div');
            d.className = 'layer';
            // Espalha pela tela e usa Z para forçar profundidade
            d.style.transform = `translate3d(${Math.random()*100}vw, ${Math.random()*100}vh, ${Math.random()*100}px)`;
            frag.appendChild(d);
        }
        container.appendChild(frag);
    }

    // =================================================================
    // EXECUTOR
    // =================================================================
    function starve(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Configura o Alvo
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing
        requestAnimationFrame(() => {
            setTimeout(() => {
                // ALERTA
                window.alert("⚠️ GPU PRIMED ⚠️\n\nAo fechar, a CPU vai parar de falar com a GPU.");

                // AQUI ACONTECE O CAOS
                
                // 1. Matamos o Renderizador (Tela Branca)
                if(target._detonate) target._detonate();
                
                // 2. Travamos a CPU imediatamente (Loop Infinito)
                // Isso impede a limpeza correta das camadas GPU que criamos
                if(target._lock) target._lock();
                
            }, 50);
        });
    }

    // =================================================================
    // 01. 3D Layer Bomb + White Screen Lock
    // Cria camadas 3D pesadas e mata o DOM.
    // =================================================================
    function s01(stage) {
        const d = document.createElement('div');
        d.innerText = "3D LAYER TARGET";
        stage.appendChild(d);
        
        // Injeta carga na GPU
        gpuLoad(document.body);

        d._detonate = () => {
            // Script Nuke (O método comprovado)
            const s = document.createElement('script');
            s.src = "data:text/javascript,A";
            document.body.appendChild(s);
            s.remove();
            
            // NUKE: Mata o DOM (as camadas 3D ficam órfãs na GPU)
            document.open();
        };

        d._lock = () => {
            // CPU Lock sem alocação de memória (para evitar OOM)
            while(true) {
                // Apenas cálculos matemáticos pesados para manter o núcleo 100%
                Math.atan2(Math.random(), Math.random());
            }
        };
        return d;
    }

    // =================================================================
    // 02. SVG Filter Bomb + White Screen Lock
    // Filtros SVG (Blur, Matrix) são muito pesados para a GPU/CPU.
    // =================================================================
    function s02(stage) {
        const d = document.createElement('div');
        d.innerText = "SVG FILTER TARGET";
        stage.appendChild(d);

        // Cria SVG complexo com filtros
        d.innerHTML = `
            <svg width="100%" height="100%">
                <filter id="f">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="10" />
                    <feColorMatrix type="hueRotate" values="90" />
                </filter>
                <rect width="100%" height="100%" filter="url(#f)" fill="red" />
                ${"<rect width='10' height='10' x='0' y='0' filter='url(#f)' />".repeat(500)}
            </svg>
        `;

        d._detonate = () => {
            // NUKE
            document.open();
        };

        d._lock = () => {
            while(true) {
                Math.pow(Math.random(), Math.random());
            }
        };
        return d;
    }

    // =================================================================
    // 03. Canvas Context Loss + CPU Lock
    // Cria contextos 2D e tenta desenhar neles enquanto a aba morre.
    // =================================================================
    function s03(stage) {
        const d = document.createElement('div');
        d.innerText = "CANVAS TARGET";
        stage.appendChild(d);

        // Cria vários canvas
        const ctxs = [];
        for(let i=0; i<50; i++) {
            const c = document.createElement('canvas');
            c.width = 200; c.height = 200;
            document.body.appendChild(c);
            ctxs.push(c.getContext('2d'));
        }

        d._detonate = () => {
            // NUKE
            document.open();
            // Mantém referências aos contextos na memória do loop
            // Mesmo com o document.open(), os objetos JS 'ctxs' ainda existem na closure
        };

        d._lock = () => {
            // Tenta desenhar nos contextos órfãos em loop infinito
            // Isso força comunicação com o processo de GPU a partir de um documento morto
            while(true) {
                // Acessa o array da closure
                const ctx = ctxs[0]; 
                // Tenta ler propriedade (força sync)
                const w = ctx.canvas.width; 
            }
        };
        return d;
    }

</script>
</body>
</html>
