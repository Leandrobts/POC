<!DOCTYPE html>
<html>
<head>
    <title>PS4 Hybrid Fuzzer (Stress + Cross-Doc)</title>
    <style>
        body { background: #000; color: #00ff00; font-family: monospace; overflow: hidden; }
        .v-stress { 
            position: absolute; 
            transform: translate3d(0,0,0); /* Força GPU */
            transition: all 0.1s;
            display: flex;
            border: 1px solid red;
        }
        #log { border-bottom: 1px solid #0f0; padding: 5px; font-size: 20px; }
    </style>
</head>
<body>
    <div id="log">Inicializando Hybrid Fuzzer...</div>
    <iframe id="victim-frame" style="width:1px; height:1px; opacity:0; position:absolute;"></iframe>
    <div id="arena" style="width: 2000px; height: 2000px;"></div>

    <script>
        // ================= CONFIGURAÇÃO AJUSTADA =================
        const REPLAY_MODE = false;
        const REPLAY_SEED = 0; 
        // REDUZIDO DE 60 PARA 30: Para evitar "Falta de Memória" e focar no Crash real
        const ITERATIONS = 30; 
        // =========================================================

        const TAGS = [
            'div', 'span', 'a', 'img', 'iframe', 'video', 'audio', 
            'svg', 'path', 'circle', 'mask',
            'math', 'row', 'frac', 'num',    
            'table', 'form', 'fieldset', 'select', 'option',
            'details', 'summary', 'marquee'  
        ];

        // PRNG
        let currentSeed = parseInt(localStorage.getItem('hyb_seed') || Math.floor(Math.random() * 100000));
        localStorage.setItem('hyb_last_start', currentSeed);

        function seed(s) { currentSeed = s; }
        function rnd() {
            var t = currentSeed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        function pick(arr) { return arr[Math.floor(rnd() * arr.length)]; }
        function coinflip() { return rnd() > 0.5; }

        // Estado
        const logBox = document.getElementById('log');
        const frame = document.getElementById('victim-frame'); // Referência ao iframe
        
        if (REPLAY_MODE) seed(REPLAY_SEED);
        else seed(currentSeed);

        if (!REPLAY_MODE) localStorage.setItem('hyb_seed', currentSeed + 1);
        
        logBox.innerHTML = `SEED: ${currentSeed} | <span style="color:red">❤</span>`;

        // --- FUNÇÕES DE ATAQUE ---

        function fuzzAttributes(el) {
            try {
                if (coinflip()) el.id = "id_" + Math.floor(rnd() * 1000);
                if (coinflip()) el.className = "v-stress";
                // Reduzi o tamanho do junk data para economizar RAM
                if (rnd() > 0.9) el.setAttribute("data-junk", "X".repeat(500)); 
                if (coinflip()) el.style.cssText = `float: ${coinflip()?'left':'right'}; width: ${rnd()*100}px;`;
            } catch(e){}
        }

        function addEvilEvents(el) {
            try {
                el.addEventListener('DOMNodeRemoved', function(ev) {
                    ev.target.innerHTML = "<b>DEAD</b>";
                    // Tenta acessar estilo durante a morte do objeto (UAF Vector)
                    let _ = ev.target.style.display; 
                });
            } catch(e){}
        }

        // [NOVO] O Ataque Nuclear: Mover entre documentos
        function triggerCrossDoc(el) {
            try {
                if (!frame.contentDocument) return;
                let otherDoc = frame.contentDocument;
                
                // Move para o iframe e volta
                otherDoc.adoptNode(el);
                otherDoc.body.appendChild(el);
                document.adoptNode(el);
                
                // [NOVO] Corrupção de Protótipo pós-movimento
                el.__proto__ = {};
            } catch(e) {}
        }

        function runFuzz() {
            const arena = document.getElementById('arena');
            let nodes = [];

            try {
                // FASE 1: CRIAÇÃO
                for (let i = 0; i < 40; i++) { // Leve redução na quantidade
                    let tag = pick(TAGS);
                    let el;
                    if (['svg','path','circle'].includes(tag)) el = document.createElementNS("http://www.w3.org/2000/svg", tag);
                    else if (['math','row'].includes(tag)) el = document.createElementNS("http://www.w3.org/1998/Math/MathML", tag);
                    else el = document.createElement(tag);

                    fuzzAttributes(el);
                    addEvilEvents(el);

                    if (nodes.length > 0 && coinflip()) {
                        let parent = pick(nodes);
                        try { parent.appendChild(el); } catch(e){ arena.appendChild(el); }
                    } else {
                        arena.appendChild(el);
                    }
                    nodes.push(el);
                }

                // FASE 2: CONFUSÃO (CROSS-DOC & TREEWALKER)
                let walker = document.createTreeWalker(arena, NodeFilter.SHOW_ELEMENT, null, false);
                let node = walker.nextNode();
                while(node) {
                    if (rnd() > 0.7) {
                        // Aqui aplicamos o ataque nuclear nos nós existentes
                        triggerCrossDoc(node);
                        
                        if (coinflip()) node.normalize();
                    }
                    node = walker.nextNode();
                }

                // FASE 3: DESTRUIÇÃO
                for (let i = 0; i < 25; i++) {
                    let victim = pick(nodes);
                    try {
                        // Remove com setTimeout 0 para causar Race Condition
                        if (coinflip()) {
                            setTimeout(() => victim.remove(), 0);
                        } else {
                            victim.remove();
                        }
                    } catch(e){}
                }

                // FASE 4: MEMÓRIA (Otimizada)
                // Spray menor, mas mais frequente, evita OOM mas mantém pressão
                let spray = [];
                for(let k=0; k<50; k++) {
                    spray.push(new Float64Array(100).fill(1.123456789e-100));
                }
                spray = null;

            } catch (e) {}

            arena.textContent = "";
        }

        // Loop
        setTimeout(() => {
            for (let j=0; j < ITERATIONS; j++) runFuzz();
            if (!REPLAY_MODE) window.location.reload();
        }, 200);

    </script>
</body>
</html>
