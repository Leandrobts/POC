<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Storage & State Fuzzer</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; padding: 20px; }
        button { 
            background: #fff; color: #000; border: none; 
            padding: 15px; width: 100%; margin-bottom: 10px; 
            font-size: 16px; font-weight: bold; cursor: pointer; text-align: left;
        }
        button:hover { background: #ccc; }
        #log { border-top: 1px solid #fff; padding-top: 10px; margin-top: 20px; white-space: pre-wrap; }
        #editor { background: #222; padding: 10px; min-height: 50px; }
    </style>
</head>
<body>

    <h1>STORAGE & STATE ATTACKS</h1>
    <p>Target: IndexedDB Transactions & DOM Selection Range</p>

    <button onclick="runIDBRace()">TEST 1: IndexedDB Transaction Abort Race</button>
    <button onclick="runSelectionChaos()">TEST 2: Selection API Range Chaos</button>
    <button onclick="runFontFaceCrash()">TEST 3: FontFace Lifecycle UAF</button>

    <div id="editor" contenteditable="true">Texto editável para teste de seleção...</div>
    <div id="log">Status: Pronto.</div>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // TESTE 1: IndexedDB Race
        // Tenta criar e abortar transações rapidamente.
        // O objetivo é confundir o gerenciador de estado do banco de dados.
        function runIDBRace() {
            log("Iniciando IndexedDB Transaction Race...");
            const request = indexedDB.open("CrashDB", 1);
            
            request.onupgradeneeded = function(e) {
                const db = e.target.result;
                if (!db.objectStoreNames.contains("store")) {
                    db.createObjectStore("store");
                }
            };

            request.onsuccess = function(e) {
                const db = e.target.result;
                let count = 0;
                
                const interval = setInterval(() => {
                    count++;
                    if(count > 1000) {
                        clearInterval(interval);
                        log("IDB Teste Finalizado.");
                        return;
                    }

                    try {
                        // Cria transação de escrita
                        const tx = db.transaction("store", "readwrite");
                        const store = tx.objectStore("store");
                        
                        // Adiciona dados
                        store.put("Dados de Teste " + Math.random(), "key");
                        
                        // O GOLPE: Aborta imediatamente (50% de chance)
                        // Isso força o rollback no meio da operação de I/O
                        if (Math.random() > 0.5) {
                            tx.abort();
                        }
                    } catch(err) { /* Ignora erros de lógica */ }
                }, 5); // Muito rápido
            };
        }

        // TESTE 2: Selection Chaos
        // Manipula faixas de seleção de texto (Ranges) de forma inválida.
        // O WebKit odeia quando o "foco" da seleção desaparece.
        function runSelectionChaos() {
            log("Executando Selection API Fuzzer...");
            const editor = document.getElementById('editor');
            const sel = window.getSelection();
            
            // Popula o editor com nós complexos
            editor.innerHTML = "<b>Negrito</b><i>Itálico</i><span>Normal</span>".repeat(50);

            let i = 0;
            const interval = setInterval(() => {
                i++;
                if(i > 500) {
                    clearInterval(interval);
                    log("Selection Test Finalizado.");
                    return;
                }

                try {
                    // Cria um Range aleatório
                    const range = document.createRange();
                    
                    // Seleciona nós aleatórios dentro do editor
                    const nodes = editor.childNodes;
                    const startNode = nodes[Math.floor(Math.random() * nodes.length)];
                    const endNode = nodes[Math.floor(Math.random() * nodes.length)];
                    
                    range.setStart(startNode, 0);
                    range.setEnd(endNode, 0);
                    
                    // Aplica a seleção
                    sel.removeAllRanges();
                    sel.addRange(range);
                    
                    // O GOLPE: Modifica o DOM selecionado imediatamente
                    // Tenta causar desincronia entre o Range visual e a memória
                    startNode.textContent = "MODIFICADO";
                    if (Math.random() > 0.8) {
                        editor.removeChild(endNode); // Remove o nó onde a seleção termina
                    }
                    
                } catch(e) {} // Ignora erros de índice inválido
            }, 10);
        }

        // TESTE 3: FontFace Lifecycle
        // Carrega e deleta fontes personalizadas durante a renderização.
        function runFontFaceCrash() {
            log("Testando ciclo de vida de Fontes...");
            
            const interval = setInterval(() => {
                try {
                    // 1. Cria uma fonte (pode ser válida ou url lixo)
                    const fontName = "Font" + Math.random();
                    const f = new FontFace(fontName, 'url(data:font/woff;base64,d09GRgABAAAA...)');
                    
                    // 2. Adiciona ao documento
                    document.fonts.add(f);
                    
                    // 3. Usa a fonte num elemento
                    const el = document.createElement('div');
                    el.style.fontFamily = fontName;
                    el.innerText = "TESTE DE FONTE";
                    document.body.appendChild(el);
                    
                    // 4. Força renderização (Layout)
                    const width = el.offsetWidth;
                    
                    // 5. O GOLPE: Remove a fonte e o elemento simultaneamente
                    document.fonts.delete(f);
                    document.body.removeChild(el);
                    
                    // Tenta acessar propriedade após delete (Race?)
                    const check = f.status; 
                    
                } catch(e) {}
            }, 20);

            setTimeout(() => {
                clearInterval(interval);
                log("FontFace Test Finalizado.");
            }, 5000);
        }

    </script>
</body>
</html>
