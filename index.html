
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v320000: Thread Locker</title>
<style>
    body { background: #000; color: #f00; font-family: 'Courier New', monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #f00; color: #fff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #200; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #600; color: #fff; border: 2px solid #f00;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f00; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v320000: THREAD LOCKER</h1>

<div class="status">
    OBJETIVO: TELA PRETA/BRANCA + TRAVAMENTO TOTAL (SOFTLOCK)<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA -> AGUARDE O TRAVAMENTO
</div>

<button onclick="lock(l01)">01. White Screen + History CPU Lock</button>

<button onclick="lock(l02)">02. Black Screen + Reflow CPU Lock</button>

<button onclick="lock(l03)">03. The Black Hole (Memory Alloc Loop)</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    // =================================================================
    // EXECUTOR COM TRAVAMENTO DE CPU
    // =================================================================
    function lock(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Cria o Alvo
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing
        requestAnimationFrame(() => {
            setTimeout(() => {
                // ALERTA
                window.alert("⚠️ THREAD LOCK ⚠️\n\nAo fechar, o navegador deve congelar totalmente.");

                // AQUI ACONTECE A MÁGICA
                // 1. Detona o Renderizador (Tela Branca/Preta)
                if(target._detonate) {
                    target._detonate();
                }
                
                // 2. Trava a CPU imediatamente (Impedindo o Refresh/Close)
                // O navegador ficará preso tentando executar isso para sempre.
                if(target._lock) {
                    target._lock(); // Loop Infinito
                }
            }, 50);
        });
    }

    // =================================================================
    // 01. White Screen + History CPU Lock
    // Baseado no Script Loader Nuke (v28 Teste 3)
    // Lock: Flood de histórico síncrono infinito
    // =================================================================
    function l01(stage) {
        const d = document.createElement('div');
        d.innerText = "WHITE LOCK";
        stage.appendChild(d);

        let s = null;

        // Setup do Script Nuke
        s = document.createElement('script');
        s.src = "data:text/javascript," + "A".repeat(5000);
        document.body.appendChild(s);

        d._detonate = () => {
            // O Crash Visual
            s.remove();
            d.remove();
            document.open(); // Mata o documento
            // Não fechamos o documento para deixar o estado inconsistente
        };

        d._lock = () => {
            // O Travamento da UI
            // Usamos um loop while(true)
            // Dentro dele, forçamos o Kernel a trabalhar (history state)
            let i = 0;
            while(true) {
                i++;
                // PushState consome memória do Kernel. Fazer isso em loop infinito trava tudo.
                history.pushState(i, "", "");
            }
        };
        return d;
    }

    // =================================================================
    // 02. Black Screen + Reflow CPU Lock
    // Baseado no DOM Spray (v28 Teste 4)
    // Lock: Forçar recálculo de layout em DOM morto
    // =================================================================
    function l02(stage) {
        const d = document.createElement('div');
        d.innerText = "BLACK LOCK";
        stage.appendChild(d);

        d._detonate = () => {
            // O Crash Visual
            d.remove();
            const f = document.createDocumentFragment();
            // Spray menor para ser rápido, pois vamos travar logo em seguida
            for(let i=0; i<5000; i++) {
                const s = document.createElement('div');
                s.innerText = "X";
                f.appendChild(s);
            }
            document.body.appendChild(f);
            document.body.innerHTML = ""; // Tela Preta
        };

        d._lock = () => {
            // O Travamento da UI
            // Tenta acessar propriedades de layout (offsetWidth) em loop
            // Isso força o navegador a tentar renderizar a página que acabou de morrer
            const deadBody = document.body;
            while(true) {
                const x = deadBody.offsetWidth; // Recalc layout
                const y = deadBody.offsetHeight;
            }
        };
        return d;
    }

    // =================================================================
    // 03. The Black Hole (Memory Alloc Loop)
    // Tenta causar Kernel Panic alocando memória infinita dentro do loop
    // =================================================================
    function l03(stage) {
        const d = document.createElement('div');
        d.innerText = "MEMORY HOLE";
        stage.appendChild(d);

        d._detonate = () => {
            // Morte simples do DOM
            document.body.innerHTML = "SYSTEM HALTED";
            document.body.remove();
        };

        d._lock = () => {
            // Alocação Infinita Síncrona
            // Isso vai travar a UI e comer toda a RAM em segundos
            // O OOM Killer do Kernel deve entrar em ação.
            // Se o Kernel demorar demais para matar, ele entra em pânico.
            const hole = [];
            while(true) {
                // Empurra strings gigantes para a memória
                hole.push("A".repeat(1024 * 1024)); // 1MB por iteração
            }
        };
        return d;
    }

</script>
</body>
</html>
