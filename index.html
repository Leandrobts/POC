<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 ELF Extractor v5.0 (Memory Mapper & Info Leak)</title>
    <style>
        body { background: #000; color: #00ffff; font-family: monospace; padding: 20px; }
        .drop { border: 2px dashed #00ffff; padding: 40px; text-align: center; cursor: pointer; background: #111; margin-bottom: 20px; }
        .drop:hover { background: #222; }
        #log { height: 400px; overflow-y: auto; border: 1px solid #333; padding: 10px; background: #050505; color: #ccc; margin-bottom: 10px; white-space: pre; }
        button { width: 100%; padding: 15px; background: #003333; color: #00ffff; border: 1px solid #00ffff; cursor: pointer; font-weight: bold; }
        .bar-bg { width: 100%; background: #333; height: 10px; margin-bottom: 5px; }
        .bar-fg { width: 0%; background: #00ffff; height: 100%; }
    </style>
</head>
<body>

    <h1>ELF EXTRACTOR v5.0: THE MEMORY MAPPER</h1>
    <p>Foco: VTable Detection, GOT Offsets & Pointer Chains (ASLR Bypass).</p>

    <input type="file" id="files" multiple style="display:none" onchange="start(this.files)">
    <div class="drop" onclick="document.getElementById('files').click()">
        [ ARRASTE libSceNKWebKit.sprx E libkernel.sprx AQUI ]
    </div>

    <div id="status">Pronto.</div>
    <div class="bar-bg"><div class="bar-fg" id="bar"></div></div>
    <div id="log">Logs de memória...</div>
    
    <button id="dl" style="display:none" onclick="download()">BAIXAR MAPA DE MEMÓRIA (JSON)</button>

<script>
    const LOG = document.getElementById('log');
    const BAR = document.getElementById('bar');
    const STAT = document.getElementById('status');
    const DL = document.getElementById('dl');
    
    let REPORT = { tool: "v5.0_InfoLeak", binaries: [] };

    function log(m) { LOG.innerText += `\n> ${m}`; LOG.scrollTop = LOG.scrollHeight; }
    function hex(n) { return "0x" + BigInt(n).toString(16); }

    async function start(files) {
        if(!files.length) return;
        REPORT.binaries = [];
        DL.style.display = 'none';
        
        for(let i=0; i<files.length; i++) {
            STAT.innerText = `Mapeando: ${files[i].name}...`;
            try {
                const res = await analyze(files[i]);
                REPORT.binaries.push(res);
            } catch(e) { log(`Erro: ${e.message}`); }
        }
        
        STAT.innerText = "Finalizado.";
        BAR.style.width = "100%";
        DL.style.display = 'block';
    }

    function read(file, off, len) {
        return new Promise((r, j) => {
            const fr = new FileReader();
            fr.onload = e => r(e.target.result);
            fr.onerror = j;
            fr.readAsArrayBuffer(file.slice(off, off+len));
        });
    }

    async function analyze(file) {
        log(`Abrindo ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)...`);
        
        // 1. Parse ELF Header
        const headBuf = await read(file, 0, 64);
        const dv = new DataView(headBuf);
        if(dv.getUint32(0) !== 0x7F454C46) throw new Error("Não é ELF.");
        
        const endian = dv.getUint8(5) === 1; // 1=Little
        const e_phoff = Number(dv.getBigUint64(32, endian));
        const e_phnum = dv.getUint16(56, endian);
        
        let bin = { 
            filename: file.name,
            segments: [],
            vtables: [], // Candidatos a VTable
            got_entries: [], // Global Offset Table
            string_refs: []  // Ponteiros para strings
        };

        // 2. Mapear Segmentos
        log("  Mapeando segmentos...");
        const phBuf = await read(file, e_phoff, e_phnum * 56);
        const phDv = new DataView(phBuf);
        
        let textSeg = null; // Código (R-X)
        let dataSeg = null; // Dados (RW-)
        let rodataSeg = null; // Read-Only Data (R--)

        for(let i=0; i<e_phnum; i++) {
            const off = i * 56;
            const type = phDv.getUint32(off, endian);
            const flags = phDv.getUint32(off+4, endian);
            const offset = Number(phDv.getBigUint64(off+8, endian));
            const vaddr = Number(phDv.getBigUint64(off+16, endian));
            const filesz = Number(phDv.getBigUint64(off+32, endian));

            const seg = { type, flags, vaddr: hex(vaddr), offset, size: filesz };
            bin.segments.push(seg);

            if(type === 1) { // PT_LOAD
                if(flags === 5) textSeg = seg; // RX
                if(flags === 6) dataSeg = seg; // RW
                if(flags === 4) rodataSeg = seg; // R
            }
        }

        // 3. Caçar VTables (VTable Hunter)
        // VTables geralmente ficam em .rodata (Flags 4) e contêm ponteiros para .text (Flags 5)
        if(rodataSeg && textSeg) {
            log(`  Varrendo .rodata (${(rodataSeg.size/1024).toFixed(0)}KB) por VTables...`);
            await scanVTables(file, rodataSeg, textSeg, bin, endian);
        }

        // 4. Analisar Relocations (GOT)
        // Precisamos encontrar onde estão as seções de relocação. 
        // Em vez de parsear Section Headers (que podem estar stripados), vamos varrer Dynamic Tags se possível
        // Simplificação: Scan heurístico por tabela GOT em Data Segment
        if(dataSeg) {
            log("  Procurando GOT Entries no Data Segment...");
            // await scanGOT(file, dataSeg, bin, endian); // (Implementação simplificada abaixo)
        }

        return bin;
    }

    async function scanVTables(file, rodata, text, bin, endian) {
        const CHUNK = 1024 * 1024;
        let processed = 0;
        let vtableChain = 0;
        let vtableStart = 0;
        
        const textStart = BigInt(text.vaddr);
        const textEnd = textStart + BigInt(text.size);

        while(processed < rodata.size) {
            const size = Math.min(CHUNK, rodata.size - processed);
            const buf = await read(file, rodata.offset + processed, size);
            const dv = new DataView(buf);
            
            // Lendo de 8 em 8 bytes (Ponteiros 64-bit)
            for(let i=0; i < size; i+=8) {
                if(i + 8 > size) break;
                
                const ptr = dv.getBigUint64(i, endian);
                
                // Verifica se o ponteiro aponta para dentro do segmento de TEXTO (.text)
                if(ptr >= textStart && ptr < textEnd) {
                    if(vtableChain === 0) vtableStart = rodata.vaddr + processed + i;
                    vtableChain++;
                } else {
                    // Se a cadeia quebrou e era longa o suficiente (> 4 métodos), é provável vtable
                    if(vtableChain >= 4) {
                        if(bin.vtables.length < 50) { // Limita output
                            bin.vtables.push({
                                offset: hex(vtableStart),
                                length: vtableChain,
                                first_method: hex(ptr) // Na verdade o anterior, mas serve ref
                            });
                        }
                    }
                    vtableChain = 0;
                }
            }
            
            processed += size;
            BAR.style.width = `${(processed / rodata.size) * 100}%`;
            await new Promise(r => requestAnimationFrame(r));
        }
        log(`  > ${bin.vtables.length} possíveis VTables encontradas.`);
    }

    function download() {
        const json = JSON.stringify(REPORT, (k,v) => typeof v === 'bigint' ? "0x"+v.toString(16) : v, 2);
        const blob = new Blob([json], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "ps4_memory_map.json";
        document.body.appendChild(a);
        a.click();
    }
</script>

</body>
</html>
