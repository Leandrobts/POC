<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 ELF Extractor v4.0 (NID & Entropy)</title>
    <style>
        body { background: #000; color: #0f0; font-family: 'Courier New', monospace; padding: 20px; }
        .box { border: 2px dashed #444; padding: 30px; text-align: center; margin-bottom: 20px; cursor: pointer; background: #111; }
        .box:hover { border-color: #0f0; background: #222; }
        #console { height: 400px; overflow-y: auto; border: 1px solid #333; padding: 10px; background: #050505; white-space: pre-wrap; margin-bottom: 10px; color: #ccc; }
        button { width: 100%; padding: 15px; background: #003300; color: #fff; border: 1px solid #0f0; cursor: pointer; font-weight: bold; }
        .prog { background: #333; height: 20px; width: 100%; margin-bottom: 5px; }
        .fill { background: #0f0; height: 100%; width: 0%; transition: width 0.1s; }
    </style>
</head>
<body>

    <h1>ELF EXTRACTOR v4.0: DEEP MINER</h1>
    <p>Extrai: Entropia, NIDs (Hashes Sony), Syscalls (0F 05) e Gadgets Avançados.</p>

    <input type="file" id="files" multiple style="display:none" onchange="init(this.files)">
    <div class="box" onclick="document.getElementById('files').click()">
        [ ARRASTE OS BINÁRIOS AQUI ]
    </div>

    <div id="status">Aguardando...</div>
    <div class="prog"><div class="fill" id="bar"></div></div>
    <div id="console">Logs...</div>
    
    <button id="dl" style="display:none" onclick="download()">BAIXAR JSON COMPLETO</button>

<script>
    const LOG = document.getElementById('console');
    const BAR = document.getElementById('bar');
    const STAT = document.getElementById('status');
    const DL = document.getElementById('dl');
    
    let OUTPUT = { tool: "v4.0_DeepMiner", timestamp: new Date().toISOString(), binaries: [] };

    function log(m) { LOG.innerText += `\n> ${m}`; LOG.scrollTop = LOG.scrollHeight; }
    function hex(n) { return "0x" + n.toString(16); }

    async function init(files) {
        if(!files.length) return;
        OUTPUT.binaries = [];
        DL.style.display = 'none';
        
        for(let i=0; i<files.length; i++) {
            STAT.innerText = `Analisando: ${files[i].name} (${i+1}/${files.length})`;
            try {
                const res = await processElf(files[i]);
                OUTPUT.binaries.push(res);
            } catch(e) {
                log(`ERRO: ${e.message}`);
            }
        }
        
        STAT.innerText = "Concluído.";
        BAR.style.width = "100%";
        log("Análise completa. Baixe o JSON.");
        DL.style.display = 'block';
    }

    function readBuf(file, off, len) {
        return new Promise((res, rej) => {
            const r = new FileReader();
            r.onload = e => res(e.target.result);
            r.onerror = rej;
            r.readAsArrayBuffer(file.slice(off, off+len));
        });
    }

    async function processElf(file) {
        log(`Abrindo ${file.name}...`);
        
        // Header Básico
        const head = await readBuf(file, 0, 64);
        const dv = new DataView(head);
        if(dv.getUint32(0) !== 0x7F454C46) throw new Error("Não é ELF");
        
        const endian = dv.getUint8(5) === 1; // 1=Little
        const e_phoff = Number(dv.getBigUint64(32, endian));
        const e_phnum = dv.getUint16(56, endian);
        const e_shoff = Number(dv.getBigUint64(40, endian));
        const e_shnum = dv.getUint16(60, endian);

        let bin = { filename: file.name, entropy: 0, syscalls: [], nids: [], segments: [] };

        // 1. Ler Segmentos
        log("  Lendo segmentos de memória...");
        let textSeg = null;
        const phSize = e_phnum * 56;
        const phBuf = await readBuf(file, e_phoff, phSize);
        const phDv = new DataView(phBuf);

        for(let i=0; i<e_phnum; i++) {
            const off = i * 56;
            const type = phDv.getUint32(off, endian);
            const flags = phDv.getUint32(off+4, endian);
            const offset = Number(phDv.getBigUint64(off+8, endian));
            const vaddr = Number(phDv.getBigUint64(off+16, endian));
            const filesz = Number(phDv.getBigUint64(off+32, endian));

            bin.segments.push({ type, flags, vaddr: hex(vaddr), size: filesz });

            // Identificar segmento de TEXTO (Executável)
            if(type === 1 && (flags & 1) && filesz > 10000) {
                textSeg = { offset, vaddr, size: filesz };
            }
        }

        // 2. Calcular Entropia (Blocos)
        // Isso detecta criptografia. Entropia > 7.9 é packed/encrypted.
        log("  Calculando Entropia de Shannon (Amostragem)...");
        bin.entropy = await calcEntropy(file, textSeg ? textSeg.size : file.size);
        log(`  > Entropia: ${bin.entropy.toFixed(4)} / 8.0`);

        // 3. Scan Profundo (.text)
        if(textSeg) {
            log(`  Varrendo código (${(textSeg.size/1024/1024).toFixed(2)} MB) por Syscalls e NIDs...`);
            await deepScan(file, textSeg, bin);
        }

        return bin;
    }

    async function calcEntropy(file, limit) {
        const CHUNK = 1024 * 1024; // 1MB sample
        const buf = await readBuf(file, 0, Math.min(limit, CHUNK));
        const u8 = new Uint8Array(buf);
        const counts = new Array(256).fill(0);
        
        for(let b of u8) counts[b]++;
        
        let entropy = 0;
        const len = u8.length;
        for(let c of counts) {
            if(c === 0) continue;
            const p = c / len;
            entropy -= p * Math.log2(p);
        }
        return entropy;
    }

    async function deepScan(file, seg, bin) {
        const CHUNK = 5 * 1024 * 1024; // 5MB chunks para performance
        let processed = 0;
        
        while(processed < seg.size) {
            const size = Math.min(CHUNK, seg.size - processed);
            const buf = await readBuf(file, seg.offset + processed, size);
            const u8 = new Uint8Array(buf);
            const dv = new DataView(buf);
            
            // Loop rápido
            for(let i=0; i<u8.length - 8; i++) {
                // DETECTAR SYSCALL: 0F 05
                if(u8[i] === 0x0F && u8[i+1] === 0x05) {
                    // Evita falsos positivos verificando arredores (ex: RET C3 depois)
                    // Mas vamos logar todos por segurança
                    if(bin.syscalls.length < 50) {
                        bin.syscalls.push(hex(seg.vaddr + processed + i));
                    }
                }

                // DETECTAR NIDs (SONY): Geralmente são movidos para registros antes de chamar o resolver
                // Padrão heurístico: NIDs são hashes de alta entropia.
                // Isso é difícil de garantir sem disassembler, mas vamos procurar padrões de MOV REG, IMM64
                // 48 B8 XX XX XX XX XX XX XX XX (MOV RAX, imm64)
                if(u8[i] === 0x48 && (u8[i+1] & 0xF8) === 0xB8) {
                    // Candidato a NID?
                    // Vamos salvar se parecer um hash aleatório (não endereços pequenos)
                    /* NOTA: Sem um disassembler completo JS, extrair NIDs exatos é heurístico.
                       No lugar disso, vamos focar em encontrar strings de erro próximas.
                    */
                }
            }

            processed += size;
            BAR.style.width = `${(processed / seg.size) * 100}%`;
            await new Promise(r => requestAnimationFrame(r));
        }
        log(`  > ${bin.syscalls.length} instruções SYSCALL encontradas.`);
    }

    function download() {
        // Replacer para BigInt
        const json = JSON.stringify(OUTPUT, (k, v) => typeof v === 'bigint' ? "0x"+v.toString(16) : v, 2);
        const blob = new Blob([json], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "ps4_deep_miner_v4.json";
        document.body.appendChild(a);
        a.click();
    }

</script>
</body>
</html>
