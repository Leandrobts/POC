<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>PS4 WebKit – Test 165 OOM/Hang Detector</title>
</head>
<body>
  <h1>PS4 WebKit – Teste 165 (PI + MutationObserver) – OOM/Hang Detector</h1>
  <p><b>SAFE</b> deve sempre logar e parar. <b>UNSAFE</b> tenta reproduzir OOM/starvation do teste original.</p>

  <button onclick="clearLog()">Limpar log</button>
  <hr>

  <label>Budget (SAFE):</label>
  <input id="budget" type="number" value="2000" min="1" step="500">
  <label>Seed mutações:</label>
  <input id="seed" type="number" value="200" min="1" step="50">

  <br><br>

  <button onclick="run165_safe()">Rodar 165 SAFE (controlado)</button>
  <button onclick="run165_unsafe()">Rodar 165 UNSAFE (tentativa de reproduzir OOM)</button>
  <button onclick="stop165()">Parar (best-effort)</button>

  <hr>
  <pre id="log" style="white-space:pre-wrap; font-family:monospace;"></pre>

<script>
"use strict";

const L = document.getElementById("log");
function log(s){ L.textContent += s + "\n"; }
function hr(){ log("------------------------------------------------------------"); }
function clearLog(){ L.textContent = ""; }

let running = false;
let obs = null;
let pi = null;

// Heartbeats (para saber se a UI/JS está “respirando” fora do observer)
let rafId = 0;
let hbTimer = 0;
let mc = null;
let lastBeat = 0;
let beats = 0;

// Métricas
let ticks = 0;
let budget = 0;
let t0 = 0;

function startHeartbeats(){
  stopHeartbeats();
  lastBeat = Date.now();
  beats = 0;

  // requestAnimationFrame heartbeat (depende de render loop)
  const rafBeat = () => {
    beats++;
    lastBeat = Date.now();
    if ((beats % 60) === 0) log("[HB][rAF] beats=" + beats);
    rafId = requestAnimationFrame(rafBeat);
  };
  rafId = requestAnimationFrame(rafBeat);

  // MessageChannel heartbeat (não depende de UI render, mas depende do event loop)
  mc = new MessageChannel();
  mc.port1.onmessage = () => {
    beats++;
    lastBeat = Date.now();
    if ((beats % 2000) === 0) log("[HB][MC] beats=" + beats);
    mc.port2.postMessage(0);
  };
  mc.port2.postMessage(0);

  // Watchdog: se beats pararem, sinaliza starvation/hang
  hbTimer = setInterval(() => {
    const dt = Date.now() - lastBeat;
    log("[HB] watchdog dt=" + dt + "ms ticks=" + ticks + " beats=" + beats);
    if (dt > 2000) {
      log("!! [HB] STARVATION/HANG provável: sem batimento por >2s (UI/event loop travado).");
      // não para automaticamente, porque pode já estar no caminho do travamento
      clearInterval(hbTimer);
      hbTimer = 0;
    }
  }, 500);
}

function stopHeartbeats(){
  if (rafId) { try { cancelAnimationFrame(rafId); } catch(e) {} rafId = 0; }
  if (hbTimer) { clearInterval(hbTimer); hbTimer = 0; }
  if (mc) { try { mc.port1.onmessage = null; mc.port1.close(); mc.port2.close(); } catch(e) {} mc = null; }
}

function setupPIAndObserver(isUnsafe){
  ticks = 0;
  t0 = Date.now();

  // Log ultra cedo (pra você nunca ficar 30 min sem output)
  log("[165] ENTER setup. unsafe=" + isUnsafe + " @ " + new Date().toISOString());

  // Cria e anexa PI
  pi = document.createProcessingInstruction("xml", "test");
  document.body.appendChild(pi);
  log("[165] PI anexado.");

  obs = new MutationObserver(() => {
    ticks++;

    // SAFE: corta pelo budget
    if (!isUnsafe) {
      if (--budget <= 0) {
        const dt = Date.now() - t0;
        log("[165][SAFE] Budget esgotado. ticks=" + ticks + " dt=" + dt + "ms");
        stop165();
        return;
      }
    }

    // Ação que pode se auto-alimentar via mutações
    try { pi.remove(); } catch(e) {}
    try { document.body.appendChild(pi); } catch(e) {}
    try { pi.remove(); } catch(e) {}

    // Log com baixa frequência (evita flood)
    if ((ticks % 500) === 0) {
      const dt = Date.now() - t0;
      log("[165] tick=" + ticks + " dt=" + dt + "ms");
    }
  });

  obs.observe(document.body, { childList: true, subtree: true });
  log("[165] Observer ativo.");
}

function seedMutations(n){
  log("[165] Seed mutações: " + n);
  for (let i = 0; i < n; i++) {
    const d = document.createElement("div");
    d.textContent = "x";
    document.body.appendChild(d);
    d.remove();
  }
  log("[165] Seed concluído.");
}

function run165_safe(){
  hr();
  if (running) { log("[165] Já rodando."); return; }
  running = true;

  // Ajustes
  budget = Math.max(1, (document.getElementById("budget").value|0));
  const seed = Math.max(1, (document.getElementById("seed").value|0));

  log("[165][SAFE] start budget=" + budget + " seed=" + seed);
  startHeartbeats();
  try {
    setupPIAndObserver(false);
    seedMutations(seed);
    log("[165][SAFE] Rodando… (deve finalizar sozinho ao acabar budget)");
  } catch (e) {
    log("[165][SAFE] EXCEPTION: " + (e && e.message ? e.message : e));
    stop165();
  }
}

function run165_unsafe(){
  hr();
  if (running) { log("[165] Já rodando."); return; }
  running = true;

  const seed = Math.max(1, (document.getElementById("seed").value|0));

  log("[165][UNSAFE] start seed=" + seed + " (pode causar OOM/starvation)");
  log("[165][UNSAFE] Se travar sem log depois daqui e aparecer 'falta de memória', isso é DoS por exaustão.");
  startHeartbeats();

  try {
    setupPIAndObserver(true);

    // UNSAFE: seed maior para forçar cascata
    seedMutations(seed * 5);

    // Armador: cria pressão extra leve e controlada para observar degradação
    // (não é spray agressivo; só ajuda a acelerar se o caminho for OOM)
    const junk = [];
    for (let i = 0; i < 2000; i++) junk.push(new ArrayBuffer(4096));
    log("[165][UNSAFE] Junk alocado (leve). junk=" + junk.length);

    log("[165][UNSAFE] Rodando…");
  } catch (e) {
    log("[165][UNSAFE] EXCEPTION: " + (e && e.message ? e.message : e));
    stop165();
  }
}

function stop165(){
  hr();
  log("[165] STOP solicitado (best-effort).");

  try { if (obs) obs.disconnect(); } catch(e) {}
  obs = null;

  try { if (pi) pi.remove(); } catch(e) {}
  pi = null;

  stopHeartbeats();
  running = false;

  log("[165] STOP concluído.");
}
</script>
</body>
</html>
