<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Invariant Violation Suite v31000</title>
<style>
    body { background: #111; color: #ddd; font-family: monospace; padding: 10px; }
    button { width: 100%; padding: 10px; margin: 5px 0; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; }
    #log { border: 1px solid #777; height: 400px; overflow-y: auto; background: #000; padding: 10px; white-space: pre-wrap; }
    .clean { color: #888; }
    .leak { color: #0f0; font-weight: bold; border: 1px solid #0f0; padding: 2px; }
</style>
</head>
<body>

<h1>SUITE V31000: INVARIANT VIOLATIONS</h1>
<p>Methodology: 1. Legitimate Source -> 2. Native Op -> 3. Unexpected Mutation -> 4. Stale Read</p>

<div id="log">Ready...</div>

<button onclick="testIteratorDetach()">01. TypedArray(Iterator) -> Detach Buffer Middle</button>

<button onclick="testConcatSpecies()">02. Array.concat -> Species Resize Trap</button>

<button onclick="testRegExpSideEffect()">03. String.replace -> RegExp LastIndex Mutation</button>

<button onclick="testAssignShrink()">04. Object.assign -> Getter Deletes Properties</button>

<button onclick="testFilterResize()">05. Array.filter -> Resize during Iteration</button>

<button onclick="testJSONLayout()">06. JSON.stringify -> Proxy Layout Mutation</button>

<button onclick="testHugeAlloc()">07. Huge Array Allocation -> Read Hole (No Fill)</button>

<button onclick="testMapRehash()">08. Map Set/Delete -> Force Rehash during Iteration</button>

<button onclick="testStackResidue()">09. Error.stack -> Recursion Depth Limit Check</button>

<button onclick="testEntropy()">10. Math.random() -> Entropy/Seeding Check</button>

<script>
    const LOG = document.getElementById('log');

    function log(msg, type = 'clean') {
        const div = document.createElement('div');
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        div.className = type;
        LOG.appendChild(div);
        LOG.scrollTop = LOG.scrollHeight;
    }

    // Validador Rigoroso: Só é leak se for dados "sujos" não escritos por nós
    function analyze(val, context) {
        if (val === undefined || val === null || val === 0) {
            log(`${context}: Clean (${val})`);
            return;
        }
        
        // Se for número: procuramos números que não são 0, nem inteiros pequenos lógicos
        if (typeof val === 'number') {
            if (Number.isInteger(val) && val < 1000 && val > -1000) {
                 log(`${context}: Logical Return (${val})`, 'clean');
            } else {
                 // Float estranho ou Inteiro gigante = Vazamento de memória não inicializada ou ponteiro
                 log(`[!!!] LEAK CANDIDATE (${context}): ${val}`, 'leak');
            }
            return;
        }

        // Se for string: procuramos caracteres de controle ou lixo de memória
        if (typeof val === 'string') {
            // Regex para caracteres não imprimíveis (excluindo espaço simples)
            if (/[\x00-\x08\x0E-\x1F]/.test(val)) {
                log(`[!!!] STRING LEAK (${context}): HexDump needed`, 'leak');
            } else {
                log(`${context}: String Clean`, 'clean');
            }
        }
    }

    // 01. TypedArray Constructor Iterator Detach
    // Invariante: O construtor calcula o tamanho baseado no iterável, aloca, e DEPOIS itera.
    // Violação: Durante a iteração, "desligamos" (detach) o buffer de destino ou origem.
    function testIteratorDetach() {
        try {
            const iter = {
                *[Symbol.iterator]() {
                    yield 1;
                    yield 2;
                    yield 3;
                    // MUTATION: Detach buffer no meio da construção
                    // (Simulado via worker transfer se SAB não disponível, ou lógica pura se suportado)
                    // Aqui usamos um truque de lógica:
                    // Se o motor alocou memória para 5 itens, e nós paramos de dar itens...
                    // O resto da memória fica suja?
                }
            };
            
            // Tenta criar array de tamanho fixo mas iterador termina cedo ou faz algo estranho
            // Em JS puro sem SAB, focamos em descompasso de tamanho
            const arr = new Uint32Array(iter); 
            // Se o construtor alocou espaço para X mas o iterador yieldou Y...
            // JS moderno lida bem, mas WebKit antigo vazava stack.
            
            if (arr.length > 0) analyze(arr[arr.length-1], "Iterator End");
        } catch(e) { log("Iterator Safe"); }
    }

    // 02. Array.concat Species Resize
    // Invariante: Concat espera que o array resultante seja soma dos tamanhos.
    // Violação: O construtor da espécie retorna um array menor.
    function testConcatSpecies() {
        class Leaky extends Array {
            static get [Symbol.species]() {
                return function(n) {
                    // Engine pede array de tamanho N
                    // Nós damos um array de tamanho 0, mas "mentimos" sobre a capacidade?
                    const a = new Array(n);
                    // Força array esparso (Hole)
                    return a; 
                }
            }
        }
        
        const arr = new Leaky(10);
        arr.fill(1);
        const res = arr.concat([2,3]);
        
        // Verifica se lemos buracos (holes) que contêm dados antigos
        // Em vez de undefined, lemos lixo?
        if (res.length > 0) analyze(res[0], "Concat Species");
    }

    // 03. String.replace RegExp Side-Effect
    // Invariante: A string fonte é imutável durante o replace.
    // Violação: Usamos um objeto com toString no argumento de replace para mudar o RegExp global.
    function testRegExpSideEffect() {
        const str = "A".repeat(100);
        const re = /A/g;
        
        const replacement = {
            toString: () => {
                // MUTATION: Altera lastIndex ou recompila o RegExp no meio do loop de replace
                re.compile("B"); 
                return "X";
            }
        };
        
        try {
            const res = str.replace(re, replacement);
            // Se a engine continuar lendo o buffer da string antiga usando offsets da nova regex...
            analyze(res.length, "RegExp SideEffect");
        } catch(e) { log("RegExp Safe"); }
    }

    // 04. Object.assign Getter Shrink
    // Invariante: Iterar sobre chaves e copiar valores.
    // Violação: O getter de uma chave deleta chaves subsequentes do objeto fonte.
    function testAssignShrink() {
        const source = {
            get a() {
                // MUTATION: Deleta 'b' enquanto 'assign' ainda vai tentar ler 'b'
                delete this.b;
                return 1;
            },
            b: 2,
            c: 0x41 // Valor marcador limpo
        };
        
        const target = {};
        Object.assign(target, source);
        
        // Se 'b' foi copiado APÓS ser deletado, o que foi lido?
        // JS padrão define undefined, mas engines otimizadas podem ler memória desalocada (stale pointer)
        analyze(target.b, "Assign Shrink");
    }

    // 05. Array.filter Resize
    // Invariante: Array não muda de tamanho durante filter.
    // Violação: Callback muda length para 0.
    function testFilterResize() {
        const arr = [1, 2, 3, 4, 5];
        const res = arr.filter((v, i, a) => {
            if (i === 2) {
                // MUTATION: Zera o array
                a.length = 0; 
                // Tenta forçar realloc
                a.push(9); 
            }
            return true;
        });
        
        // O filter continuou iterando sobre a memória antiga?
        // Se sim, 'res' terá valores lixo nos índices finais
        if (res.length > 3) analyze(res[3], "Filter Resize");
        else log("Filter Safe");
    }

    // 06. JSON.stringify Proxy Layout Change
    // Invariante: O layout do objeto (offsets das propriedades) é estável.
    // Violação: Proxy deleta propriedade durante a leitura.
    function testJSONLayout() {
        const target = { a: 1, b: 2, c: 3 };
        const p = new Proxy(target, {
            get(t, k) {
                if (k === 'b') {
                    // MUTATION: Muda o "shape" do objeto (deleta propriedade do meio)
                    delete t.c;
                    // Adiciona nova para mudar offset
                    t.d = 4;
                }
                return Reflect.get(t, k);
            }
        });
        
        try {
            // Stringify lê sequencialmente baseando-se em Hidden Class/Structure ID
            const s = JSON.stringify(p);
            // Se leu a memória de 'c' (que foi deletado), vazou?
            log("JSON: " + s, 'clean');
        } catch(e) {}
    }

    // 07. Huge Array Allocation -> Read Hole (No Fill)
    // Invariante: Memória alocada deve ser zerada (bzero).
    // Violação: Carga alta no sistema impede bzero (Race no Kernel/MMU).
    function testHugeAlloc() {
        try {
            // Tenta alocar 50MB
            // Em sistemas *BSD, alocações grandes usam mmap direto.
            // Se o kernel der uma página "suja" de outro processo...
            const arr = new Uint32Array(1024 * 1024 * 10);
            
            // Amostragem estatística (não ler tudo para não travar)
            let dirty = 0;
            for(let i=0; i<arr.length; i+=4096) { // Pula páginas (4KB)
                if (arr[i] !== 0) {
                    dirty = arr[i];
                    break;
                }
            }
            
            analyze(dirty, "Huge Alloc Hole");
        } catch(e) { log("Alloc Failed"); }
    }

    // 08. Map Set/Delete -> Force Rehash during Iteration
    // Invariante: Iterador deve ser robusto a rehashing.
    // Violação: Deletar e Inserir massivamente muda o ponteiro do backing store do Map.
    function testMapRehash() {
        const m = new Map();
        for(let i=0; i<100; i++) m.set(i, i);
        
        const iter = m.entries();
        iter.next(); // Inicia estado
        
        // MUTATION: Força resize interno
        for(let i=0; i<100; i++) m.delete(i);
        for(let i=0; i<200; i++) m.set("n"+i, i);
        
        // O iterador ainda aponta para a tabela antiga desalocada?
        try {
            const res = iter.next();
            if (!res.done) analyze(res.value[1], "Map Rehash");
            else log("Map Rehash Safe");
        } catch(e) { log("Map Error Safe"); }
    }

    // 09. Error.stack -> Recursion Depth Limit Check
    // Invariante: Stack trace deve parar em um limite seguro.
    // Violação: Recursão exata no limite da stack frame.
    function testStackResidue() {
        try {
            const overflow = () => overflow();
            overflow();
        } catch(e) {
            // Em WebKit antigo, a string do stack trace às vezes incluía
            // bytes da stack frame anterior se o buffer não fosse null-terminated
            if (e.stack && e.stack.length > 0) {
                // Procura por sequências que não são nomes de função ou números de linha
                // (Heurística visual no log)
                const lastLine = e.stack.split('\n').pop();
                analyze(lastLine, "Stack Residue");
            }
        }
    }

    // 10. Math.random() -> Entropy/Seeding Check
    // Invariante: Random deve ser pseudo-aleatório seguro.
    // Violação: Se o estado interno vazar, podemos prever endereços (ASLR bypass indireto).
    // (Apenas checagem de sanidade)
    function testEntropy() {
        const v1 = Math.random();
        const v2 = Math.random();
        log(`Entropy: ${v1.toFixed(10)} | ${v2.toFixed(10)}`, 'clean');
    }

</script>

</body>
</html>
