<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Logic Validation Fuzzer</title>
    <style>
        body { background-color: #000; color: #fff; font-family: monospace; padding: 20px; }
        button { 
            background: #fff; color: #000; border: none; 
            padding: 15px; width: 100%; margin-bottom: 10px; 
            font-size: 16px; font-weight: bold; cursor: pointer; text-align: left;
        }
        button:hover { background: #ccc; }
        #log { border-top: 1px solid #fff; padding-top: 10px; margin-top: 20px; }
    </style>
</head>
<body>

    <h1>INPUT VALIDATION ATTACKS</h1>
    <p>Target: C++ Parser Logic (Null Bytes, State Machine, URL Norm)</p>

    <button onclick="runNullByteXHR()">TEST 1: XHR Null Byte Injection (Method/URL)</button>
    <button onclick="runTypeConfusion()">TEST 2: XHR ResponseType Switching (Race)</button>
    <button onclick="runURLNormalization()">TEST 3: URL Path Normalization Overflow</button>
    <button onclick="runDoubleFree()">TEST 4: Event Listener Double Detach</button>

    <div id="log">Status: Aguardando...</div>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // TESTE 1: Injeção de Null Byte (\u0000)
        // O JS suporta \0, mas o C++ acha que é o fim da string.
        // Se o WebKit não validar isso na ponte JS->C++, pode haver leitura inválida.
        function runNullByteXHR() {
            log("Enviando Null Bytes para o NetworkProcess...");
            try {
                const xhr = new XMLHttpRequest();
                // Tenta injetar null byte no método HTTP
                // Esperado: Erro de sintaxe. Crash se a validação falhar.
                const methods = ["GET\u0000", "POST\u0000", "GET\u0000POST"];
                
                methods.forEach(m => {
                    try {
                        xhr.open(m, "/");
                        xhr.send();
                    } catch(e) { /* Ignora erros tratados */ }
                });

                // Tenta injetar no cabeçalho
                xhr.open("GET", "/");
                xhr.setRequestHeader("X-Test", "A".repeat(100) + "\u0000" + "B".repeat(100));
                xhr.send();
                
                log("Sobreviveu ao Null Byte.");
            } catch(e) { log("Erro JS: " + e.message); }
        }

        // TESTE 2: XHR Type Confusion
        // Tenta mudar o formato de armazenamento dos dados (JSON -> Blob -> ArrayBuffer)
        // ENQUANTO os dados estão chegando. Confunde o ponteiro de memória.
        function runTypeConfusion() {
            log("Iniciando XHR Type Switching...");
            const xhr = new XMLHttpRequest();
            xhr.open("GET", document.location.href + "?" + Math.random()); // Baixa a própria página
            
            xhr.onreadystatechange = function() {
                try {
                    // Estado 3 = LOADING (Recebendo dados)
                    if (xhr.readyState === 3) {
                        // O C++ está escrevendo na memória. Vamos mudar o tipo do buffer.
                        xhr.responseType = "arraybuffer";
                        xhr.responseType = "text";
                        xhr.responseType = "blob";
                    }
                } catch(e) {}
            };
            
            xhr.send();
            log("Requisição enviada. Monitorando...");
        }

        // TESTE 3: URL Path Normalization
        // Caminhos com muitos pontos (..) forçam o parser a calcular o diretório pai.
        // Um buffer overflow pode ocorrer se o caminho resultante for negativo ou gigante.
        function runURLNormalization() {
            log("Gerando URL Malformada...");
            setTimeout(() => {
                try {
                    // Cria: /a/../a/../a/../ repetido 50.000 vezes
                    const part = "/a/..";
                    const evilPath = part.repeat(50000);
                    
                    // Tenta forçar o navegador a resolver esse caminho na barra de endereço
                    history.pushState({}, "", evilPath);
                    
                    log("URL inserida no History (Sem Crash).");
                } catch(e) { log("Erro: " + e.message); }
            }, 100);
        }

        // TESTE 4: Event Listener Double Detach (DOM Logic)
        // Tenta remover um nó DOM dentro do evento que ele mesmo disparou.
        // Clássico Use-After-Free lógico.
        function runDoubleFree() {
            log("Executando DOM Detach...");
            const div = document.createElement('div');
            const child = document.createElement('span');
            div.appendChild(child);
            document.body.appendChild(div);

            child.addEventListener('DOMNodeRemoved', function() {
                // O nó está sendo removido. Vamos tentar acessar o pai
                // e forçar uma operação de layout nele.
                try {
                    div.innerHTML = ""; // Destrói o pai enquanto o filho morre
                    const crash = child.offsetWidth; // Acessa propriedade do filho morto
                } catch(e) {}
            });

            // Dispara o evento
            div.removeChild(child);
            log("DOM Detach finalizado.");
        }

    </script>
</body>
</html>
