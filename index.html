<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PS4 WebKit Fuzzer v2.0</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    font-family: 'Courier New', monospace; 
    background: #000; 
    color: #0f0; 
    padding: 15px;
    font-size: 14px;
}
.container { max-width: 1400px; margin: 0 auto; }
h1 { 
    color: #0ff; 
    border-bottom: 2px solid #0ff; 
    padding-bottom: 10px; 
    margin-bottom: 20px;
    font-size: 24px;
}
h2 { 
    color: #ff0; 
    margin: 20px 0 10px 0; 
    font-size: 18px;
}
button {
    background: #003300;
    color: #0f0;
    border: 2px solid #0f0;
    padding: 12px 20px;
    margin: 5px;
    cursor: pointer;
    font-family: monospace;
    font-size: 14px;
    transition: all 0.3s;
}
button:hover { background: #005500; }
button:active { background: #007700; }
button.danger { background: #330000; border-color: #f00; color: #f00; }
button.danger:hover { background: #550000; }
button.primary { background: #000033; border-color: #00f; color: #0ff; }
button.primary:hover { background: #000055; }
input, select {
    background: #001100;
    color: #0f0;
    border: 1px solid #0f0;
    padding: 8px;
    font-family: monospace;
    margin: 5px;
    font-size: 14px;
}
.status-bar {
    background: #001100;
    border: 2px solid #0f0;
    padding: 15px;
    margin: 15px 0;
}
.status-item {
    display: inline-block;
    margin-right: 20px;
    padding: 5px 10px;
    background: #002200;
    border-radius: 3px;
}
.status-value {
    color: #ff0;
    font-weight: bold;
    font-size: 18px;
}
#log {
    background: #001100;
    border: 2px solid #0f0;
    padding: 10px;
    height: 400px;
    overflow-y: auto;
    font-size: 12px;
    white-space: pre-wrap;
    word-wrap: break-word;
}
.crash-list {
    background: #110000;
    border: 2px solid #f00;
    padding: 10px;
    margin: 10px 0;
    max-height: 300px;
    overflow-y: auto;
}
.crash-item {
    background: #220000;
    border-left: 4px solid #f00;
    padding: 8px;
    margin: 5px 0;
    cursor: pointer;
}
.crash-item:hover { background: #330000; }
.info-box {
    background: #000033;
    border: 2px solid #00f;
    padding: 15px;
    margin: 15px 0;
    color: #0ff;
}
.grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
}
.log-info { color: #0ff; }
.log-warn { color: #ff0; }
.log-error { color: #f00; }
.log-success { color: #0f0; }
.log-crash { 
    color: #f00; 
    font-weight: bold;
    background: #330000;
    padding: 2px 5px;
}
</style>
</head>
<body>

<div class="container">
<h1>üéÆ PS4 WebKit Fuzzer v2.0 - Persistent Edition</h1>

<div class="info-box">
<strong>üíæ SISTEMA DE PERSIST√äNCIA ATIVO</strong><br>
‚Ä¢ Crashes salvos automaticamente no localStorage do PS4<br>
‚Ä¢ Dados sobrevivem ao fechamento do browser<br>
‚Ä¢ Exporta√ß√£o em JSON para an√°lise posterior<br>
‚Ä¢ GitHub: <span style="color:#ff0">Hospedar e acessar direto do PS4</span>
</div>

<div class="status-bar">
<div class="status-item">
    Itera√ß√µes: <span class="status-value" id="iter">0</span>
</div>
<div class="status-item">
    Crashes: <span class="status-value" id="crashes">0</span>
</div>
<div class="status-item">
    Exceptions: <span class="status-value" id="exceptions">0</span>
</div>
<div class="status-item">
    Estado: <span class="status-value" id="state">Aguardando</span>
</div>
<div class="status-item">
    Storage: <span class="status-value" id="storage">0 KB</span>
</div>
</div>

<h2>‚öôÔ∏è Configura√ß√£o</h2>
<div>
<label>Itera√ß√µes: <input type="number" id="iterations" value="5000"></label>
<label>Delay (ms): <input type="number" id="delay" value="5"></label>
<label>Auto-save: <input type="checkbox" id="autosave" checked></label>
<label>Verbose log: <input type="checkbox" id="verbose"></label>
</div>

<h2>üéØ Fuzzers Dispon√≠veis</h2>
<div class="grid">
<button onclick="fuzzHistory()">History API</button>
<button onclick="fuzzTypedArrays()">TypedArrays</button>
<button onclick="fuzzCanvas()">Canvas 2D</button>
<button onclick="fuzzWebGL()">WebGL</button>
<button onclick="fuzzIndexedDB()">IndexedDB</button>
<button onclick="fuzzWorkers()">Web Workers</button>
<button onclick="fuzzPromises()">Promises</button>
<button onclick="fuzzJIT()">JIT Compiler</button>
<button onclick="fuzzDOM()">DOM APIs</button>
<button onclick="fuzzMediaSource()">Media Source</button>
<button onclick="fuzzWebAudio()">Web Audio</button>
<button onclick="fuzzFetch()">Fetch/XHR</button>
<button onclick="fuzzUAF()">üî• UAF Patterns</button>
<button onclick="fuzzHeapSpray()">üî• Heap Spray</button>
<button onclick="fuzzRaceConditions()">üî• Race Conditions</button>
</div>

<h2>üöÄ A√ß√µes</h2>
<div>
<button onclick="fuzzAll()" class="danger">FUZZ ALL (Agressivo)</button>
<button onclick="stopFuzzing()">‚èπÔ∏è Parar</button>
<button onclick="resumeFuzzing()" class="primary">‚ñ∂Ô∏è Retomar</button>
<button onclick="clearLog()">üóëÔ∏è Limpar Log</button>
</div>

<h2>üíæ Gerenciamento de Dados</h2>
<div>
<button onclick="saveCrashData()" class="primary">üíæ Salvar Crashes</button>
<button onclick="loadCrashData()" class="primary">üìÇ Carregar Crashes</button>
<button onclick="exportJSON()">üì§ Exportar JSON</button>
<button onclick="importJSON()">üì• Importar JSON</button>
<button onclick="clearStorage()" class="danger">üóëÔ∏è Limpar Storage</button>
<button onclick="viewStats()">üìä Ver Estat√≠sticas</button>
</div>

<h2>üìã Crashes Salvos (<span id="crashCount">0</span>)</h2>
<div class="crash-list" id="crashList">
<em>Nenhum crash salvo ainda. Execute o fuzzer!</em>
</div>

<h2>üìù Log de Execu√ß√£o</h2>
<div id="log"></div>

</div>

<script>
// ============================================
// ESTADO GLOBAL
// ============================================
let running = false;
let paused = false;
let iterCount = 0;
let crashCount = 0;
let exceptionCount = 0;
let crashLog = [];
let currentFuzzer = null;

const STORAGE_KEY = 'ps4_fuzzer_crashes';
const CONFIG_KEY = 'ps4_fuzzer_config';
const STATS_KEY = 'ps4_fuzzer_stats';

// ============================================
// SISTEMA DE PERSIST√äNCIA
// ============================================

function saveCrashData() {
    try {
        const data = {
            version: '2.0',
            timestamp: new Date().toISOString(),
            crashes: crashLog,
            stats: {
                totalIterations: iterCount,
                totalCrashes: crashCount,
                totalExceptions: exceptionCount
            }
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        updateStorageSize();
        log('üíæ Dados salvos no localStorage (persistente)', 'success');
        
    } catch (e) {
        log('‚ùå Erro ao salvar: ' + e.message, 'error');
        
        // Se localStorage cheio, tentar limpar dados antigos
        if (e.name === 'QuotaExceededError') {
            if (confirm('Storage cheio! Limpar dados antigos?')) {
                clearOldCrashes();
                saveCrashData();
            }
        }
    }
}

function loadCrashData() {
    try {
        const data = localStorage.getItem(STORAGE_KEY);
        
        if (!data) {
            log('‚ÑπÔ∏è Nenhum dado salvo encontrado', 'info');
            return;
        }
        
        const parsed = JSON.parse(data);
        crashLog = parsed.crashes || [];
        
        if (parsed.stats) {
            iterCount = parsed.stats.totalIterations || 0;
            crashCount = parsed.stats.totalCrashes || 0;
            exceptionCount = parsed.stats.totalExceptions || 0;
        }
        
        updateCounters();
        updateCrashList();
        updateStorageSize();
        
        log(`üìÇ ${crashLog.length} crashes carregados do localStorage`, 'success');
        
    } catch (e) {
        log('‚ùå Erro ao carregar: ' + e.message, 'error');
    }
}

function exportJSON() {
    try {
        const data = {
            version: '2.0',
            exported: new Date().toISOString(),
            device: 'PS4 WebKit v12.00',
            crashes: crashLog,
            stats: {
                totalIterations: iterCount,
                totalCrashes: crashCount,
                totalExceptions: exceptionCount
            }
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `ps4_fuzzer_crashes_${Date.now()}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
        
        log('üì§ JSON exportado com sucesso!', 'success');
        
    } catch (e) {
        log('‚ùå Erro ao exportar: ' + e.message, 'error');
        
        // Fallback: mostrar JSON em nova janela
        const data = {crashes: crashLog, stats: {iterCount, crashCount, exceptionCount}};
        const win = window.open();
        win.document.write('<pre>' + JSON.stringify(data, null, 2) + '</pre>');
    }
}

function importJSON() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                if (data.crashes) {
                    crashLog = crashLog.concat(data.crashes);
                    crashCount = crashLog.length;
                    updateCounters();
                    updateCrashList();
                    saveCrashData();
                    log(`üì• ${data.crashes.length} crashes importados!`, 'success');
                }
                
            } catch (e) {
                log('‚ùå Erro ao importar: ' + e.message, 'error');
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

function clearStorage() {
    if (!confirm('üóëÔ∏è Limpar TODOS os dados salvos?\n\nEsta a√ß√£o n√£o pode ser desfeita!')) {
        return;
    }
    
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(CONFIG_KEY);
    localStorage.removeItem(STATS_KEY);
    
    crashLog = [];
    crashCount = 0;
    iterCount = 0;
    exceptionCount = 0;
    
    updateCounters();
    updateCrashList();
    updateStorageSize();
    
    log('üóëÔ∏è Storage limpo!', 'success');
}

function clearOldCrashes() {
    // Manter apenas os 100 crashes mais recentes
    if (crashLog.length > 100) {
        crashLog = crashLog.slice(-100);
        log('üóëÔ∏è Crashes antigos removidos (mantidos √∫ltimos 100)', 'warn');
    }
}

function updateStorageSize() {
    try {
        const data = localStorage.getItem(STORAGE_KEY) || '';
        const sizeKB = (data.length / 1024).toFixed(2);
        document.getElementById('storage').textContent = sizeKB + ' KB';
    } catch (e) {
        document.getElementById('storage').textContent = 'N/A';
    }
}

function updateCrashList() {
    const listEl = document.getElementById('crashList');
    document.getElementById('crashCount').textContent = crashLog.length;
    
    if (crashLog.length === 0) {
        listEl.innerHTML = '<em>Nenhum crash salvo ainda. Execute o fuzzer!</em>';
        return;
    }
    
    listEl.innerHTML = '';
    
    // Mostrar √∫ltimos 20 crashes
    const recent = crashLog.slice(-20).reverse();
    
    recent.forEach((crash, idx) => {
        const div = document.createElement('div');
        div.className = 'crash-item';
        div.innerHTML = `
            <strong>[${crash.timestamp}]</strong> ${crash.fuzzer || 'Unknown'}<br>
            <small>${crash.error}: ${crash.message}</small>
        `;
        div.onclick = () => {
            alert(JSON.stringify(crash, null, 2));
        };
        listEl.appendChild(div);
    });
}

function viewStats() {
    const stats = {
        totalIterations: iterCount,
        totalCrashes: crashCount,
        totalExceptions: exceptionCount,
        crashRate: crashCount > 0 ? ((crashCount / iterCount) * 100).toFixed(2) + '%' : '0%',
        storedCrashes: crashLog.length,
        storageUsed: document.getElementById('storage').textContent
    };
    
    // An√°lise de crashes por tipo
    const errorTypes = {};
    const interestingCrashes = [];
    
    crashLog.forEach(crash => {
        errorTypes[crash.error] = (errorTypes[crash.error] || 0) + 1;
        
        // Crashes interessantes (potencialmente explor√°veis)
        const highValue = [
            'RangeError',
            'TypeError', 
            'InternalError',
            'Error'
        ];
        
        if (highValue.includes(crash.error)) {
            interestingCrashes.push(crash);
        }
    });
    
    let report = 'üìä ESTAT√çSTICAS\n\n';
    report += `Total de Itera√ß√µes: ${stats.totalIterations.toLocaleString()}\n`;
    report += `Total de Crashes: ${stats.totalCrashes}\n`;
    report += `Total de Exceptions: ${stats.totalExceptions}\n`;
    report += `Taxa de Crash: ${stats.crashRate}\n`;
    report += `Storage Usado: ${stats.storageUsed}\n\n`;
    
    report += 'üìã CRASHES POR TIPO:\n';
    Object.entries(errorTypes).sort((a, b) => b[1] - a[1]).forEach(([type, count]) => {
        report += `  ${type}: ${count}\n`;
    });
    
    report += `\nüî• CRASHES INTERESSANTES: ${interestingCrashes.length}\n`;
    if (interestingCrashes.length > 0) {
        report += '\n√öltimos 5 crashes interessantes:\n';
        interestingCrashes.slice(-5).forEach((crash, i) => {
            report += `\n${i+1}. ${crash.fuzzer} - ${crash.error}\n`;
            report += `   ${crash.message}\n`;
        });
    }
    
    alert(report);
}

// ============================================
// SISTEMA DE LOG
// ============================================

const logEl = document.getElementById('log');

function log(msg, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const typeClass = 'log-' + type;
    
    const line = document.createElement('div');
    line.className = typeClass;
    line.textContent = `[${timestamp}] ${msg}`;
    
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
    
    // Auto-save ap√≥s crash
    if (type === 'crash' && document.getElementById('autosave').checked) {
        saveCrashData();
    }
}

function clearLog() {
    logEl.innerHTML = '';
    log('Log limpo', 'info');
}

function updateStatus(state) {
    document.getElementById('state').textContent = state;
    document.getElementById('state').style.color = 
        state === 'Rodando' ? '#0f0' :
        state === 'Pausado' ? '#ff0' :
        state === 'Erro' ? '#f00' : '#0ff';
}

function updateCounters() {
    document.getElementById('iter').textContent = iterCount.toLocaleString();
    document.getElementById('crashes').textContent = crashCount;
    document.getElementById('exceptions').textContent = exceptionCount;
}

// ============================================
// CONTROLES
// ============================================

function stopFuzzing() {
    running = false;
    paused = false;
    updateStatus('Parado');
    log('‚èπÔ∏è Fuzzing interrompido', 'warn');
    saveCrashData();
}

function resumeFuzzing() {
    if (currentFuzzer && paused) {
        paused = false;
        running = true;
        updateStatus('Rodando');
        log('‚ñ∂Ô∏è Fuzzing retomado', 'success');
        currentFuzzer();
    } else {
        log('‚ÑπÔ∏è Nenhum fuzzer para retomar. Inicie um novo.', 'info');
    }
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// ============================================
// GERADORES DE DADOS ALEAT√ìRIOS
// ============================================

function rand(min = 0, max = 0xFFFFFFFF) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randStr(maxLen = 1000) {
    const len = rand(0, maxLen);
    return 'X'.repeat(len);
}

function randBytes(len) {
    const arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) arr[i] = rand(0, 255);
    return arr;
}

function randURL() {
    const schemes = ['#', 'http://', 'https://', 'file://', 'data:', 'javascript:', 'blob:'];
    return schemes[rand(0, schemes.length - 1)] + randStr(rand(10, 10000));
}

function randObj(depth = 0) {
    if (depth > 3) return null;
    const types = [
        () => rand(),
        () => randStr(),
        () => null,
        () => undefined,
        () => new Array(rand(0, 100)),
        () => ({a: randObj(depth + 1)})
    ];
    return types[rand(0, types.length - 1)]();
}

// ============================================
// WRAPPER DE FUZZING
// ============================================

async function runFuzzer(name, fuzzerFn) {
    running = true;
    paused = false;
    currentFuzzer = () => runFuzzer(name, fuzzerFn);
    updateStatus('Rodando');
    
    const iterations = parseInt(document.getElementById('iterations').value);
    const delay = parseInt(document.getElementById('delay').value);
    const verbose = document.getElementById('verbose').checked;
    
    log(`üöÄ Iniciando ${name}...`, 'info');
    
    for (let i = 0; i < iterations && running && !paused; i++) {
        iterCount++;
        
        try {
            await fuzzerFn();
            
            if (verbose && i % 100 === 0) {
                log(`${name}: ${i}/${iterations}`, 'info');
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            
            // FILTRO: Ignorar erros comuns/n√£o-explor√°veis
            const ignoredErrors = [
                'InvalidCharacterError',
                'NotSupportedError', 
                'SyntaxError',
                'NetworkError',
                'AbortError'
            ];
            
            const isIgnored = ignoredErrors.includes(e.name);
            
            // Apenas contar como crash se for interessante
            if (!isIgnored) {
                crashCount++;
                
                const crash = {
                    timestamp: new Date().toISOString(),
                    fuzzer: name,
                    iteration: i,
                    error: e.name,
                    message: e.message,
                    stack: e.stack,
                    interesting: true
                };
                
                crashLog.push(crash);
                log(`üí• CRASH INTERESSANTE: ${e.name} - ${e.message}`, 'crash');
                updateCrashList();
            } else {
                // Log apenas se verbose
                if (verbose && i % 500 === 0) {
                    log(`‚ö†Ô∏è Erro comum ignorado: ${e.name}`, 'warn');
                }
            }
            
            updateCounters();
        }
        
        if (delay > 0) await sleep(delay);
    }
    
    updateStatus(paused ? 'Pausado' : 'Conclu√≠do');
    log(`‚úÖ ${name} finalizado: ${iterations} itera√ß√µes`, 'success');
    saveCrashData();
}

// ============================================
// FUZZERS
// ============================================

async function fuzzHistory() {
    await runFuzzer('History API', async () => {
        const mutations = [
            () => history.pushState({}, '', randURL()),
            () => history.replaceState({}, '', randURL()),
            () => history.pushState(randObj(), randStr(), randURL()),
            () => { for(let i=0; i<rand(1,50); i++) history.pushState({}, '', '#'+i); },
            () => { setTimeout(() => history.back(), 0); history.pushState({}, '', randURL()); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzTypedArrays() {
    await runFuzzer('TypedArrays', async () => {
        const types = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        const Type = types[rand(0, types.length - 1)];
        
        const mutations = [
            () => new Type(rand(0, 0xFFFF)),
            () => { const a = new Type(10); a[rand(-100, 100)] = rand(); },
            () => { const a = new Type(10); a.length = rand(0, 0xFFFFFFFF); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzCanvas() {
    await runFuzzer('Canvas 2D', async () => {
        const c = document.createElement('canvas');
        c.width = rand(1, 10000);
        c.height = rand(1, 10000);
        const ctx = c.getContext('2d');
        
        const mutations = [
            () => ctx.fillRect(rand(), rand(), rand(), rand()),
            () => ctx.createImageData(rand(1, 5000), rand(1, 5000)),
            () => c.toDataURL(),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzWebGL() {
    await runFuzzer('WebGL', async () => {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        if (!gl) return;
        
        const mutations = [
            () => { const b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b); gl.bufferData(gl.ARRAY_BUFFER, randBytes(rand(1000, 100000)), gl.STATIC_DRAW); },
            () => gl.createTexture(),
            () => gl.createShader(gl.VERTEX_SHADER),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzIndexedDB() {
    await runFuzzer('IndexedDB', async () => {
        const req = indexedDB.open('fuzz_' + rand(), rand(1, 10));
        req.onupgradeneeded = (e) => {
            const db = e.target.result;
            try { db.createObjectStore(randStr(20)); } catch(e) {}
        };
    });
}

async function fuzzWorkers() {
    await runFuzzer('Web Workers', async () => {
        const code = `onmessage=()=>postMessage(${rand()})`;
        const blob = new Blob([code], {type: 'application/javascript'});
        const w = new Worker(URL.createObjectURL(blob));
        w.postMessage(randObj());
        setTimeout(() => w.terminate(), 50);
    });
}

async function fuzzPromises() {
    await runFuzzer('Promises', async () => {
        const mutations = [
            () => new Promise((r,j) => setTimeout(() => r(randObj()), rand(0,10))),
            () => Promise.race([new Promise(r=>r(1)), new Promise((_,j)=>j(randObj()))]),
            () => Promise.all(new Array(rand(1,50)).fill(0).map(() => new Promise(r=>r(rand())))),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzJIT() {
    await runFuzzer('JIT Compiler', async () => {
        const fn = new Function(`let x=${rand()}; for(let i=0;i<1000;i++) x+=${rand()}; return x;`);
        for(let i=0; i<100; i++) fn();
    });
}

async function fuzzDOM() {
    await runFuzzer('DOM APIs', async () => {
        // Tags HTML v√°lidas para evitar InvalidCharacterError comum
        const validTags = ['div', 'span', 'p', 'a', 'img', 'canvas', 'video', 'audio', 'iframe', 'object', 'embed'];
        
        const mutations = [
            // Manipula√ß√£o de elementos v√°lidos
            () => { 
                const e = document.createElement(validTags[rand(0, validTags.length - 1)]); 
                e.innerHTML = randStr(rand(100, 10000)); 
                document.body.appendChild(e); 
            },
            
            // Atributos extremos
            () => { 
                const e = document.createElement('div'); 
                e.setAttribute('data-test', randStr(rand(1000, 100000))); 
            },
            
            // Range manipulation (UAF potential)
            () => {
                const range = document.createRange();
                range.setStart(document.body, rand(0, 100));
                range.setEnd(document.body, rand(0, 100));
                range.deleteContents();
            },
            
            // NodeList manipulation
            () => {
                const nodes = document.querySelectorAll('*');
                for (let i = 0; i < rand(1, nodes.length); i++) {
                    if (nodes[i] && nodes[i].parentNode) {
                        nodes[i].parentNode.removeChild(nodes[i]);
                    }
                }
            },
            
            // CSS extremo (heap spray)
            () => { 
                const e = document.createElement('div'); 
                e.style.cssText = 'background: url(data:image/png;base64,' + btoa(randStr(rand(10000, 100000))) + ')';
                document.body.appendChild(e);
            },
            
            // innerHTML com SVG (parser bugs)
            () => {
                const e = document.createElement('div');
                e.innerHTML = '<svg><text>' + randStr(1000) + '</text></svg>';
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzMediaSource() {
    await runFuzzer('Media Source', async () => {
        const v = document.createElement('video');
        const ms = new MediaSource();
        v.src = URL.createObjectURL(ms);
    });
}

async function fuzzWebAudio() {
    await runFuzzer('Web Audio', async () => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        osc.frequency.value = rand(20, 20000);
        osc.connect(ctx.destination);
    });
}

async function fuzzFetch() {
    await runFuzzer('Fetch/XHR', async () => {
        fetch(randURL()).catch(() => {});
    });
}

// ============================================
// üî• FUZZER AVAN√áADO: UAF PATTERNS
// ============================================
async function fuzzUAF() {
    await runFuzzer('UAF Patterns', async () => {
        const mutations = [
            // Pattern 1: Array + setTimeout
            () => {
                let arr = new Array(rand(10, 100));
                arr.fill({data: randStr(1000)});
                setTimeout(() => { arr = null; }, 0);
                for (let i = 0; i < 100; i++) {
                    if (arr) arr[rand(0, arr.length - 1)] = rand();
                }
            },
            
            // Pattern 2: Object + Delete + Use
            () => {
                let obj = {buffer: new ArrayBuffer(rand(1000, 10000))};
                delete obj.buffer;
                new Uint8Array(obj.buffer);
            },
            
            // Pattern 3: DOM Node + Remove + Access
            () => {
                const div = document.createElement('div');
                div.innerHTML = randStr(1000);
                document.body.appendChild(div);
                div.remove();
                div.innerHTML = randStr(1000); // Use after free?
            },
            
            // Pattern 4: Event Listener UAF
            () => {
                const el = document.createElement('div');
                el.addEventListener('click', function handler() {
                    el.removeEventListener('click', handler);
                    el.innerHTML = randStr(10000);
                });
                el.click();
                el.click(); // Use after free?
            },
            
            // Pattern 5: TypedArray Detach
            () => {
                const buffer = new ArrayBuffer(rand(1000, 100000));
                const view = new Uint32Array(buffer);
                view[0] = rand();
                // Worker detaches buffer
                const worker = new Worker(URL.createObjectURL(
                    new Blob([`onmessage = e => postMessage(e.data)`], {type: 'application/javascript'})
                ));
                worker.postMessage(buffer, [buffer]);
                view[0] = rand(); // Use after transfer?
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// üî• FUZZER AVAN√áADO: HEAP SPRAY
// ============================================
async function fuzzHeapSpray() {
    await runFuzzer('Heap Spray', async () => {
        const mutations = [
            // Spray 1: String spray
            () => {
                const spray = [];
                for (let i = 0; i < rand(100, 1000); i++) {
                    spray.push(randStr(rand(128, 256)));
                }
            },
            
            // Spray 2: Object spray with controlled layout
            () => {
                const spray = [];
                const markerValue = 0x41414141;
                for (let i = 0; i < rand(100, 500); i++) {
                    spray.push({
                        marker: markerValue,
                        padding: new Uint8Array(rand(64, 128)).fill(0x42),
                        index: i
                    });
                }
            },
            
            // Spray 3: ArrayBuffer spray
            () => {
                const spray = [];
                for (let i = 0; i < rand(50, 200); i++) {
                    spray.push(new ArrayBuffer(rand(1024, 4096)));
                }
            },
            
            // Spray 4: Mixed type spray (confusion)
            () => {
                const spray = [];
                for (let i = 0; i < rand(100, 500); i++) {
                    if (i % 2 === 0) {
                        spray.push(new Float64Array(rand(10, 50)));
                    } else {
                        spray.push({x: rand(), y: rand()});
                    }
                }
            },
            
            // Spray 5: Canvas ImageData spray
            () => {
                const spray = [];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                for (let i = 0; i < rand(20, 100); i++) {
                    spray.push(ctx.createImageData(rand(64, 256), rand(64, 256)));
                }
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

// ============================================
// üî• FUZZER AVAN√áADO: RACE CONDITIONS
// ============================================
async function fuzzRaceConditions() {
    await runFuzzer('Race Conditions', async () => {
        const mutations = [
            // Race 1: Multiple workers accessing shared buffer
            () => {
                const sab = new SharedArrayBuffer(rand(1024, 4096));
                const view = new Int32Array(sab);
                
                for (let i = 0; i < rand(2, 10); i++) {
                    const worker = new Worker(URL.createObjectURL(
                        new Blob([`
                            onmessage = e => {
                                const v = new Int32Array(e.data);
                                for(let i=0; i<1000; i++) v[0]++;
                            }
                        `], {type: 'application/javascript'})
                    ));
                    worker.postMessage(sab);
                }
                
                for (let i = 0; i < 1000; i++) view[0]--;
            },
            
            // Race 2: History navigation race
            () => {
                for (let i = 0; i < rand(5, 20); i++) {
                    setTimeout(() => history.pushState({}, '', '#' + i), rand(0, 10));
                    setTimeout(() => history.back(), rand(0, 10));
                    setTimeout(() => history.forward(), rand(0, 10));
                }
            },
            
            // Race 3: IndexedDB transaction race
            () => {
                const req = indexedDB.open('race_' + rand(), 1);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    const store = db.createObjectStore('test');
                    
                    for (let i = 0; i < rand(10, 50); i++) {
                        setTimeout(() => {
                            const tx = db.transaction(['test'], 'readwrite');
                            tx.objectStore('test').put({val: rand()}, i);
                        }, rand(0, 50));
                    }
                };
            },
            
            // Race 4: Canvas racing operations
            () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                for (let i = 0; i < rand(10, 50); i++) {
                    setTimeout(() => {
                        ctx.fillRect(rand(), rand(), rand(100, 500), rand(100, 500));
                        canvas.toDataURL();
                    }, rand(0, 20));
                }
            },
            
            // Race 5: Promise race with side effects
            () => {
                const arr = new Array(rand(10, 100));
                
                Promise.race([
                    new Promise(r => setTimeout(() => { arr.length = 0; r(); }, rand(0, 10))),
                    new Promise(r => setTimeout(() => { for(let i=0; i<arr.length; i++) arr[i] = rand(); r(); }, rand(0, 10)))
                ]);
            },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzAll() {
    if (!confirm('‚ö†Ô∏è Modo agressivo pode travar o navegador!\n\nContinuar?')) return;
    
    log('üî• MODO AGRESSIVO ATIVADO', 'warn');
    
    const fuzzers = [
        // Fuzzers b√°sicos
        fuzzHistory, fuzzTypedArrays, fuzzCanvas, fuzzWebGL,
        fuzzIndexedDB, fuzzWorkers, fuzzPromises, fuzzJIT,
        fuzzDOM, fuzzMediaSource, fuzzWebAudio, fuzzFetch,
        // Fuzzers avan√ßados (maior probabilidade de bugs explor√°veis)
        fuzzUAF, fuzzHeapSpray, fuzzRaceConditions
    ];
    
    for (const fuzzer of fuzzers) {
        if (!running) break;
        await fuzzer();
        await sleep(1000);
    }
    
    log('üéâ FUZZ ALL COMPLETO!', 'success');
    saveCrashData();
}

// ============================================
// INICIALIZA√á√ÉO
// ============================================

window.addEventListener('load', () => {
    log('üéÆ PS4 WebKit Fuzzer v2.0 carregado', 'success');
    log('üíæ Sistema de persist√™ncia ativo', 'info');
    
    // Carregar dados salvos automaticamente
    loadCrashData();
    updateStorageSize();
    
    log('‚úÖ Pronto para fuzzing!', 'success');
});

// Auto-save ao fechar
window.addEventListener('beforeunload', () => {
    if (crashCount > 0) {
        saveCrashData();
    }
});
</script>

</body>
</html>
