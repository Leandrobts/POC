<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit Advanced Tests</title>
</head>
<body>

<h1>PS4 WebKit Advanced Exploitation Tests</h1>

<p><b>CRITICAL FINDINGS FROM PREVIOUS TESTS:</b></p>
<ul>
<li>Test 3: "The object cannot be cloned" - Structured clone limit found</li>
<li>Test 4: Stack trace differences - Potential info leak</li>
<li>Test 5: Type confusion (bool becomes object)</li>
</ul>

<hr>

<h2>Advanced Tests</h2>

<button onclick="testCloneLimit()">Test 1: Clone Algorithm Limit Exploitation</button><br>
<button onclick="testStackLeak()">Test 2: Stack Address Leak Attempts</button><br>
<button onclick="testTypeConfusionExploit()">Test 3: Type Confusion Chain</button><br>
<button onclick="testArrayBufferCorruption()">Test 4: ArrayBuffer Corruption</button><br>
<button onclick="testIntegerOverflow()">Test 5: Integer Overflow Tests</button><br>
<button onclick="testPrototypePoison()">Test 6: Prototype Poisoning</button><br>
<button onclick="testRecursiveStructure()">Test 7: Recursive Structure Exploitation</button><br>
<button onclick="testGCTiming()">Test 8: Garbage Collection Timing</button><br>
<button onclick="testBoundaryPrecision()">Test 9: Precise Boundary Mapping</button><br>
<button onclick="testMemoryDisclosure()">Test 10: Memory Disclosure via Errors</button><br>
<br>
<button onclick="clearLog()">Clear Log</button>
<button onclick="exportResults()">Export Results</button>

<hr>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
let testResults = [];

function log(msg) {
    const timestamp = new Date().toISOString().split('T')[1].slice(0, 8);
    const line = '[' + timestamp + '] ' + msg;
    logEl.textContent += line + '\n';
    testResults.push({timestamp, message: msg});
    logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
    logEl.textContent = '';
    testResults = [];
    log('Log cleared');
}

function exportResults() {
    const blob = new Blob([JSON.stringify(testResults, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ps4_advanced_test_' + Date.now() + '.json';
    a.click();
    log('Results exported');
}

// Test 1: Clone Algorithm Limit Exploitation
function testCloneLimit() {
    log('=== TEST 1: Clone Algorithm Limit Exploitation ===');
    
    // The previous test showed "The object cannot be cloned"
    // This happens when trying to clone functions or certain objects
    
    const testCases = [
        {name: 'Function in object', obj: {fn: function(){return 1;}}},
        {name: 'Symbol', obj: {sym: Symbol('test')}},
        {name: 'Circular reference', obj: (function(){const o={}; o.self=o; return o;})()},
        {name: 'DOM Node', obj: {node: document.body}},
        {name: 'Large nested', obj: createDeepNested(100)},
        {name: 'Mixed uncloneable', obj: {
            fn: ()=>1,
            arr: new Array(1000),
            data: 'X'.repeat(977)
        }}
    ];
    
    testCases.forEach(({name, obj}) => {
        try {
            history.pushState(obj, "", "#clone_" + name.replace(/\s/g,'_'));
            log('  [PASS] ' + name + ' - cloned successfully');
        } catch(e) {
            log('  [FAIL] ' + name + ' - ' + e.message);
            log('    Error type: ' + e.name);
            if(e.stack) {
                const frames = e.stack.split('\n').length;
                log('    Stack frames: ' + frames);
            }
        }
    });
    
    // Try to exploit the boundary with uncloneable objects
    try {
        const exploit = {
            data: 'A'.repeat(977),
            poison: function() { return 0x41414141; },
            overflow: new Array(14460).fill(0x42)
        };
        history.pushState(exploit, "", "#exploit_clone");
        log('  [CRITICAL] Exploit object accepted!');
    } catch(e) {
        log('  [INFO] Exploit rejected: ' + e.message);
    }
    
    log('Clone limit test completed\n');
}

function createDeepNested(depth) {
    let obj = {value: 'deep'};
    for(let i = 0; i < depth; i++) {
        obj = {nested: obj, level: i};
    }
    return obj;
}

// Test 2: Stack Address Leak
function testStackLeak() {
    log('=== TEST 2: Stack Address Leak Attempts ===');
    
    // Previous test showed stack traces differ after history operations
    
    const captureStack = () => {
        try {
            throw new Error('capture');
        } catch(e) {
            return e.stack;
        }
    };
    
    const baseline = captureStack();
    log('Baseline stack captured');
    
    // Perform history operations
    for(let i = 0; i < 20; i++) {
        history.pushState({id: i}, "", "#leak_" + i);
    }
    
    const modified = captureStack();
    log('Modified stack captured');
    
    // Compare stacks
    const baseLines = baseline.split('\n');
    const modLines = modified.split('\n');
    
    log('Baseline frames: ' + baseLines.length);
    log('Modified frames: ' + modLines.length);
    
    // Look for differences
    let differences = 0;
    for(let i = 0; i < Math.min(baseLines.length, modLines.length); i++) {
        if(baseLines[i] !== modLines[i]) {
            differences++;
            log('  [DIFF] Frame ' + i);
            log('    Before: ' + baseLines[i].substring(0, 80));
            log('    After:  ' + modLines[i].substring(0, 80));
        }
    }
    
    log('Total differences: ' + differences);
    
    // Try to extract addresses from stack traces
    const addrPattern = /0x[0-9a-fA-F]{8,}/g;
    const addrs = modified.match(addrPattern);
    if(addrs) {
        log('[LEAK] Potential addresses found:');
        addrs.forEach(addr => log('  ' + addr));
    }
    
    // Deep recursion to expose more stack
    function recurse(n, collector) {
        if(n === 0) {
            const stack = captureStack();
            collector.push(stack);
            return;
        }
        recurse(n - 1, collector);
    }
    
    const stacks = [];
    recurse(100, stacks);
    log('Deep recursion stack frames: ' + stacks[0].split('\n').length);
    
    log('Stack leak test completed\n');
}

// Test 3: Type Confusion Chain
function testTypeConfusionExploit() {
    log('=== TEST 3: Type Confusion Chain ===');
    
    // Previous test showed bool becomes object - exploit this
    
    // Test 1: Boolean confusion
    const boolObj = new Boolean(true);
    history.pushState({type: 'bool', data: boolObj}, "", "#conf1");
    history.back();
    history.forward();
    const retrieved = history.state;
    
    log('Boolean test:');
    log('  Original type: ' + typeof boolObj);
    log('  Retrieved type: ' + typeof retrieved.data);
    log('  Types match: ' + (typeof boolObj === typeof retrieved.data));
    
    // Test 2: Number to Object
    const numObj = new Number(0x41414141);
    history.pushState({num: numObj}, "", "#conf2");
    const num2 = history.state;
    log('Number object type: ' + typeof num2.num);
    
    // Test 3: String to Array
    const strObj = new String('AAAA');
    history.pushState({str: strObj}, "", "#conf3");
    const str2 = history.state;
    log('String object type: ' + typeof str2.str);
    
    // Test 4: Exploit type confusion with large data
    const confusionExploit = {
        fakeType: new Boolean(false),
        fakeSize: new Number(0xffffffff),
        fakePointer: new String('A'.repeat(977)),
        realData: [0x41, 0x42, 0x43, 0x44]
    };
    
    history.pushState(confusionExploit, "", "#exploit_conf");
    const exploitRetrieved = history.state;
    
    log('Exploit types after retrieval:');
    log('  fakeType: ' + typeof exploitRetrieved.fakeType);
    log('  fakeSize: ' + typeof exploitRetrieved.fakeSize);
    log('  fakePointer: ' + typeof exploitRetrieved.fakePointer);
    
    log('Type confusion test completed\n');
}

// Test 4: ArrayBuffer Corruption
function testArrayBufferCorruption() {
    log('=== TEST 4: ArrayBuffer Corruption ===');
    
    // Test if we can corrupt ArrayBuffer metadata
    
    const buffer = new ArrayBuffer(1024);
    const view32 = new Uint32Array(buffer);
    const view8 = new Uint8Array(buffer);
    
    // Fill with pattern
    for(let i = 0; i < view32.length; i++) {
        view32[i] = 0x41414141 + i;
    }
    
    log('ArrayBuffer created: ' + buffer.byteLength + ' bytes');
    
    // Try to push to history
    try {
        history.pushState({buf: buffer}, "", "#buf1");
        log('ArrayBuffer pushed to history');
        
        const retrieved = history.state;
        log('Retrieved buffer size: ' + retrieved.buf.byteLength);
        
        // Check if data was preserved
        const retrievedView = new Uint32Array(retrieved.buf);
        let corrupted = false;
        for(let i = 0; i < Math.min(10, retrievedView.length); i++) {
            if(retrievedView[i] !== 0x41414141 + i) {
                corrupted = true;
                log('  [CORRUPTION] Index ' + i + ': expected ' + 
                    (0x41414141 + i).toString(16) + ', got ' + 
                    retrievedView[i].toString(16));
            }
        }
        
        if(!corrupted) {
            log('  [INFO] Data preserved correctly');
        }
        
    } catch(e) {
        log('ArrayBuffer push failed: ' + e.message);
    }
    
    // Try overlapping views
    const overlap = new ArrayBuffer(977);
    const overlapView1 = new Uint32Array(overlap, 0, 100);
    const overlapView2 = new Uint8Array(overlap, 400, 577);
    
    overlapView1.fill(0x41414141);
    overlapView2.fill(0x42);
    
    try {
        history.pushState({
            buf: overlap,
            v1: overlapView1,
            v2: overlapView2
        }, "", "#overlap");
        log('Overlapping views pushed successfully');
    } catch(e) {
        log('Overlapping views failed: ' + e.message);
    }
    
    log('ArrayBuffer corruption test completed\n');
}

// Test 5: Integer Overflow
function testIntegerOverflow() {
    log('=== TEST 5: Integer Overflow Tests ===');
    
    // Test size calculations with boundary values
    const sizes = [
        977,
        978,
        0xffff,
        0xffffffff,
        0x7fffffff,
        Number.MAX_SAFE_INTEGER,
        -1,
        -977
    ];
    
    sizes.forEach(size => {
        try {
            if(size > 0 && size < 100000) {
                const data = 'A'.repeat(size);
                history.pushState({size: size, data: data}, "", "#size_" + size);
                log('  [PASS] Size ' + size + ' accepted');
            } else {
                history.pushState({size: size, marker: 'test'}, "", "#size_" + size);
                log('  [PASS] Size ' + size + ' as metadata accepted');
            }
        } catch(e) {
            log('  [FAIL] Size ' + size + ': ' + e.message);
        }
    });
    
    // Test with size 977 + various increments
    log('Testing incremental sizes from 977:');
    for(let inc = 14450; inc < 14470; inc++) {
        const testSize = Math.min(977, 100000); // Keep safe
        try {
            const data = 'A'.repeat(testSize);
            history.pushState({
                baseSize: 977,
                increment: inc,
                total: 977 + inc,
                data: data
            }, "", "#inc_" + inc);
            log('  [INFO] 977 + ' + inc + ' = ' + (977 + inc) + ' (metadata only)');
        } catch(e) {
            log('  [FAIL] 977 + ' + inc + ': ' + e.message);
        }
    }
    
    log('Integer overflow test completed\n');
}

// Test 6: Prototype Poisoning
function testPrototypePoison() {
    log('=== TEST 6: Prototype Poisoning ===');
    
    // Try to poison object prototypes through history
    
    const poisonObj = Object.create(null);
    poisonObj.toString = function() { return 'POISONED'; };
    poisonObj.valueOf = function() { return 0x41414141; };
    poisonObj.data = 'A'.repeat(977);
    
    try {
        history.pushState(poisonObj, "", "#poison1");
        log('Poisoned object pushed');
        
        const retrieved = history.state;
        if(retrieved.toString) {
            log('  toString exists: ' + retrieved.toString());
        }
        if(retrieved.valueOf) {
            log('  valueOf exists: ' + retrieved.valueOf());
        }
    } catch(e) {
        log('Poison failed: ' + e.message);
    }
    
    // Try Array prototype poison
    const arrPoison = [];
    arrPoison.length = 977;
    arrPoison[0] = 'FIRST';
    arrPoison[976] = 'LAST';
    arrPoison.customProp = 'CUSTOM';
    
    try {
        history.pushState({arr: arrPoison}, "", "#arrpoison");
        const arr2 = history.state;
        log('Array length: ' + arr2.arr.length);
        log('Array[0]: ' + arr2.arr[0]);
        log('Array[976]: ' + arr2.arr[976]);
        log('Custom prop: ' + arr2.arr.customProp);
    } catch(e) {
        log('Array poison failed: ' + e.message);
    }
    
    log('Prototype poisoning test completed\n');
}

// Test 7: Recursive Structure
function testRecursiveStructure() {
    log('=== TEST 7: Recursive Structure Exploitation ===');
    
    // Create circular reference (should fail clone)
    const circular = {data: 'A'.repeat(977)};
    circular.self = circular;
    
    try {
        history.pushState(circular, "", "#circular");
        log('[CRITICAL] Circular reference accepted!');
    } catch(e) {
        log('Circular rejected: ' + e.message);
    }
    
    // Create deep recursion
    function createChain(depth) {
        if(depth === 0) return {end: true};
        return {next: createChain(depth - 1), depth: depth};
    }
    
    const depths = [10, 50, 100, 500, 1000];
    depths.forEach(d => {
        try {
            const chain = createChain(d);
            history.pushState(chain, "", "#chain_" + d);
            log('  [PASS] Depth ' + d + ' accepted');
        } catch(e) {
            log('  [FAIL] Depth ' + d + ': ' + e.message);
        }
    });
    
    log('Recursive structure test completed\n');
}

// Test 8: Garbage Collection Timing
function testGCTiming() {
    log('=== TEST 8: Garbage Collection Timing ===');
    
    // Create many objects to trigger GC
    const objects = [];
    for(let i = 0; i < 1000; i++) {
        objects.push({
            id: i,
            data: 'X'.repeat(1000),
            array: new Array(100).fill(i)
        });
    }
    
    log('Created 1000 objects');
    
    // Push some to history
    for(let i = 0; i < 10; i++) {
        history.pushState(objects[i * 100], "", "#gc_" + i);
    }
    
    log('Pushed 10 objects to history');
    
    // Clear references
    objects.length = 0;
    log('Cleared object references');
    
    // Try to access history after GC
    history.back();
    history.back();
    const retrieved = history.state;
    
    if(retrieved) {
        log('Retrieved after GC: ID ' + retrieved.id);
        log('  Data length: ' + retrieved.data.length);
    } else {
        log('[CRITICAL] Object lost after GC!');
    }
    
    log('GC timing test completed\n');
}

// Test 9: Precise Boundary Mapping
function testBoundaryPrecision() {
    log('=== TEST 9: Precise Boundary Mapping ===');
    
    // Map exact crash boundary
    // Known: 977 + 14460 = SAFE, 978 + 14460 = CRASH, 977 + 14461 = CRASH
    
    const safeTests = [
        {base: 976, inc: 14460},
        {base: 977, inc: 14459},
        {base: 977, inc: 14460},
        {base: 975, inc: 14461},
        {base: 976, inc: 14461}
    ];
    
    safeTests.forEach(({base, inc}) => {
        try {
            const data = 'A'.repeat(base);
            history.pushState({
                base: base,
                increment: inc,
                total: base + inc,
                data: data
            }, "", "#boundary_" + base + "_" + inc);
            log('  [SAFE] Base ' + base + ' + inc ' + inc + ' = ' + (base + inc));
        } catch(e) {
            log('  [EXCEPTION] Base ' + base + ' + inc ' + inc + ': ' + e.message);
        }
    });
    
    // Test with exact boundary data
    log('Testing exact boundary combinations:');
    const exactTest = 'A'.repeat(977);
    for(let i = 0; i < 5; i++) {
        try {
            history.pushState({iteration: i, data: exactTest}, "", "#exact_" + i);
            history.replaceState({iteration: i + 1000, data: exactTest.slice(0, 488)}, "", "#exact_" + i);
            if(i % 2 === 0) history.back();
            log('  Iteration ' + i + ' completed safely');
        } catch(e) {
            log('  Iteration ' + i + ' exception: ' + e.message);
        }
    }
    
    log('Precise boundary mapping completed\n');
}

// Test 10: Memory Disclosure via Errors
function testMemoryDisclosure() {
    log('=== TEST 10: Memory Disclosure via Errors ===');
    
    // Try to trigger errors that might leak memory info
    
    const errorTests = [
        () => null.toString(),
        () => undefined.call(),
        () => ({}).nonexistent.property,
        () => new Array(-1),
        () => 'string'.nonExistent(),
        () => (0).toPrecision(101)
    ];
    
    errorTests.forEach((test, idx) => {
        try {
            test();
        } catch(e) {
            log('Error test ' + idx + ':');
            log('  Type: ' + e.name);
            log('  Message: ' + e.message);
            
            if(e.stack) {
                const stackLines = e.stack.split('\n');
                log('  Stack lines: ' + stackLines.length);
                
                // Look for addresses
                const addrs = e.stack.match(/0x[0-9a-fA-F]+/g);
                if(addrs) {
                    log('  [LEAK] Addresses in stack:');
                    addrs.forEach(a => log('    ' + a));
                }
            }
        }
    });
    
    // Try to cause error during history operation
    try {
        const badObj = {
            get data() { throw new Error('getter error'); }
        };
        history.pushState(badObj, "", "#error");
    } catch(e) {
        log('History error test:');
        log('  ' + e.message);
        if(e.stack) log('  Stack: ' + e.stack.substring(0, 100));
    }
    
    log('Memory disclosure test completed\n');
}

log('PS4 WebKit Advanced Exploitation Suite Loaded');
log('Based on previous test findings:');
log('  - Clone algorithm limits detected');
log('  - Stack trace variations found');
log('  - Type confusion confirmed');
log('Ready to run advanced tests.');
log('');
</script>

</body>
</html>
