<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Memory Corruption Tests (31-40)</title>
</head>
<body>
    <h1>PS4 WebKit Memory Corruption Tests (31-40)</h1>
    <h2>Advanced Exploitation Vectors</h2>

    <button onclick="test31_HistoryStateCorrupt()">TEST 31: History State Corrupt</button>
    <button onclick="test32_DocumentWriteUAF()">TEST 32: Document Write UAF</button>
    <button onclick="test33_IntersectionObserverRace()">TEST 33: IntersectionObserver Race</button>
    <button onclick="test34_ClipboardDataCorrupt()">TEST 34: Clipboard Data Corrupt</button>
    <button onclick="test35_ArrayIteratorCorrupt()">TEST 35: Array Iterator Corrupt</button>
    <button onclick="test36_WeakMapCollision()">TEST 36: WeakMap Collision</button>
    <button onclick="test37_PromiseChainUAF()">TEST 37: Promise Chain UAF</button>
    <button onclick="test38_ProxyHandlerCorrupt()">TEST 38: Proxy Handler Corrupt</button>
    <button onclick="test39_ShadowDOMCorrupt()">TEST 39: Shadow DOM Corrupt</button>
    <button onclick="test40_XMLHttpRequestUAF()">TEST 40: XMLHttpRequest UAF</button>

    <h3>Results</h3>
    <div id="log"></div>

    <script>
        function log(msg, status) {
            const el = document.getElementById('log');
            const color = status === 'SUCCESS' ? 'green' : status === 'FAIL' ? 'red' : 'blue';
            el.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg} - ${status}</div>`;
        }

        function test31_HistoryStateCorrupt() {
            log('TEST 31: History State Corrupt', 'RUNNING');
            try {
                const states = [];
                
                for (let i = 0; i < 50; i++) {
                    const stateObj = {
                        id: i,
                        data: new Array(1000).fill(i),
                        nested: {
                            value: 0xDEADBEEF + i,
                            buffer: new ArrayBuffer(2048)
                        },
                        timestamp: Date.now()
                    };
                    
                    states.push(stateObj);
                    
                    try {
                        history.pushState(stateObj, 'State ' + i, '#state' + i);
                    } catch(e) {}
                }
                
                window.onpopstate = function(event) {
                    try {
                        const state = event.state;
                        if (state) {
                            if (typeof state.nested !== 'object') {
                                log('TEST 31: History state structure corrupted', 'SUCCESS');
                            }
                            
                            if (state.nested && state.nested.buffer) {
                                const view = new Uint8Array(state.nested.buffer);
                                view[0] = 0xFF;
                                
                                if (view[0] === 0xFF) {
                                    log('TEST 31: History state buffer writable', 'SUCCESS');
                                }
                            }
                        }
                    } catch(e) {}
                };
                
                for (let round = 0; round < 100; round++) {
                    try {
                        history.back();
                        
                        setTimeout(() => {
                            const currentState = history.state;
                            if (currentState) {
                                currentState.modified = round;
                                
                                history.replaceState(currentState, 'Modified', location.href);
                                
                                const checkState = history.state;
                                if (checkState && checkState.modified === round) {
                                    if (checkState.nested && checkState.nested.value) {
                                        const expected = 0xDEADBEEF + checkState.id;
                                        if (checkState.nested.value !== expected) {
                                            log('TEST 31: History state value corrupted', 'SUCCESS');
                                        }
                                    }
                                }
                            }
                        }, 10);
                        
                        history.forward();
                    } catch(e) {}
                }
                
                setTimeout(() => {
                    log('TEST 31: No History corruption', 'FAIL');
                }, 2000);
                
            } catch(e) {
                log('TEST 31: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test32_DocumentWriteUAF() {
            log('TEST 32: Document Write UAF', 'RUNNING');
            try {
                const iframes = [];
                const documents = [];
                
                for (let i = 0; i < 15; i++) {
                    const iframe = document.createElement('iframe');
                    document.body.appendChild(iframe);
                    iframes.push(iframe);
                    
                    const iframeDoc = iframe.contentDocument;
                    documents.push(iframeDoc);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < documents.length; i++) {
                        const doc = documents[i];
                        
                        try {
                            doc.open();
                            doc.write('<html><head><title>Test ' + i + '</title></head>');
                            doc.write('<body><div id="content' + i + '">Content ' + round + '</div>');
                            
                            const div = doc.createElement('div');
                            div.innerHTML = '<span>Dynamic ' + round + '</span>';
                            doc.body.appendChild(div);
                            
                            doc.write('<script>var test' + i + ' = ' + round + ';<\/script>');
                            doc.write('</body></html>');
                            doc.close();
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(iframes[i]);
                                
                                try {
                                    doc.write('<div>After removal</div>');
                                    log('TEST 32: Document write on removed iframe', 'SUCCESS');
                                    return;
                                } catch(e) {}
                                
                                document.body.appendChild(iframes[i]);
                            }
                            
                            const contentDiv = doc.getElementById('content' + i);
                            if (contentDiv) {
                                contentDiv.innerHTML = 'Modified ' + round;
                                
                                doc.open();
                                
                                const stillExists = doc.getElementById('content' + i);
                                if (stillExists) {
                                    log('TEST 32: Element persists after document.open()', 'SUCCESS');
                                    return;
                                }
                            }
                            
                        } catch(e) {}
                    }
                }
                
                iframes.forEach(iframe => {
                    try {
                        document.body.removeChild(iframe);
                    } catch(e) {}
                });
                
                log('TEST 32: No Document Write UAF', 'FAIL');
                
            } catch(e) {
                log('TEST 32: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test33_IntersectionObserverRace() {
            log('TEST 33: IntersectionObserver Race', 'RUNNING');
            try {
                if (!window.IntersectionObserver) {
                    log('TEST 33: IntersectionObserver not available', 'FAIL');
                    return;
                }
                
                const observers = [];
                const targets = [];
                const intersections = [];
                
                for (let i = 0; i < 30; i++) {
                    const target = document.createElement('div');
                    target.id = 'observer_target_' + i;
                    target.style.width = '100px';
                    target.style.height = '100px';
                    target.style.margin = '10px';
                    document.body.appendChild(target);
                    targets.push(target);
                    
                    const observer = new IntersectionObserver((entries) => {
                        for (let entry of entries) {
                            intersections.push({
                                target: entry.target,
                                isIntersecting: entry.isIntersecting,
                                ratio: entry.intersectionRatio,
                                time: entry.time
                            });
                            
                            if (!entry.target.parentNode) {
                                log('TEST 33: Intersection on disconnected element', 'SUCCESS');
                            }
                            
                            try {
                                entry.target.style.backgroundColor = entry.isIntersecting ? 'red' : 'blue';
                            } catch(e) {}
                        }
                    }, {
                        threshold: [0, 0.25, 0.5, 0.75, 1.0]
                    });
                    
                    observer.observe(target);
                    observers.push(observer);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < targets.length; i++) {
                        const target = targets[i];
                        
                        target.style.marginTop = (round * 10) + 'px';
                        
                        if (round % 3 === 0) {
                            observers[i].disconnect();
                            
                            try {
                                document.body.removeChild(target);
                            } catch(e) {}
                            
                            target.style.width = '200px';
                            
                            try {
                                document.body.appendChild(target);
                                observers[i].observe(target);
                            } catch(e) {}
                        }
                        
                        if (round % 7 === 0) {
                            observers[i].unobserve(target);
                            
                            target.style.display = 'none';
                            target.style.display = 'block';
                            
                            observers[i].observe(target);
                        }
                    }
                    
                    window.scrollBy(0, 50);
                }
                
                setTimeout(() => {
                    for (let i = 0; i < intersections.length; i++) {
                        try {
                            const inter = intersections[i];
                            if (inter.target && !document.body.contains(inter.target)) {
                                log('TEST 33: Intersection record holds detached node', 'SUCCESS');
                                return;
                            }
                        } catch(e) {}
                    }
                    
                    observers.forEach(o => o.disconnect());
                    log('TEST 33: No IntersectionObserver race', 'FAIL');
                }, 1500);
                
            } catch(e) {
                log('TEST 33: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test34_ClipboardDataCorrupt() {
            log('TEST 34: Clipboard Data Corrupt', 'RUNNING');
            try {
                const textAreas = [];
                const clipboardData = [];
                
                for (let i = 0; i < 20; i++) {
                    const textarea = document.createElement('textarea');
                    textarea.value = 'Clipboard test ' + i + ' with data ' + 'X'.repeat(1000);
                    document.body.appendChild(textarea);
                    textAreas.push(textarea);
                }
                
                let copyCount = 0;
                let pasteCount = 0;
                
                document.addEventListener('copy', function(e) {
                    try {
                        const data = window.getSelection().toString();
                        clipboardData.push({
                            data: data,
                            timestamp: Date.now(),
                            length: data.length
                        });
                        
                        e.clipboardData.setData('text/plain', data + '_MODIFIED_' + copyCount);
                        e.preventDefault();
                        
                        copyCount++;
                    } catch(err) {}
                });
                
                document.addEventListener('paste', function(e) {
                    try {
                        const pasted = e.clipboardData.getData('text/plain');
                        
                        if (pasted.includes('_MODIFIED_')) {
                            const original = pasted.split('_MODIFIED_')[0];
                            
                            if (clipboardData.length > 0) {
                                const lastCopy = clipboardData[clipboardData.length - 1];
                                if (lastCopy.data !== original) {
                                    log('TEST 34: Clipboard data mismatch', 'SUCCESS');
                                }
                            }
                        }
                        
                        pasteCount++;
                    } catch(err) {}
                });
                
                for (let round = 0; round < 50; round++) {
                    for (let i = 0; i < textAreas.length; i++) {
                        const textarea = textAreas[i];
                        
                        try {
                            textarea.select();
                            document.execCommand('copy');
                            
                            textarea.value = '';
                            document.execCommand('paste');
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(textarea);
                                
                                try {
                                    textarea.select();
                                    document.execCommand('copy');
                                    log('TEST 34: Copy from removed textarea', 'SUCCESS');
                                    return;
                                } catch(e) {}
                                
                                document.body.appendChild(textarea);
                            }
                            
                        } catch(e) {}
                    }
                }
                
                setTimeout(() => {
                    log('TEST 34: No Clipboard corruption (copied: ' + copyCount + ', pasted: ' + pasteCount + ')', 'FAIL');
                }, 1000);
                
            } catch(e) {
                log('TEST 34: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test35_ArrayIteratorCorrupt() {
            log('TEST 35: Array Iterator Corrupt', 'RUNNING');
            try {
                const arrays = [];
                const iterators = [];
                
                for (let i = 0; i < 30; i++) {
                    const arr = new Array(1000);
                    for (let j = 0; j < arr.length; j++) {
                        arr[j] = {id: i, value: j, data: new Array(10).fill(0xDEAD)};
                    }
                    arrays.push(arr);
                    
                    const iterator = arr[Symbol.iterator]();
                    iterators.push(iterator);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < arrays.length; i++) {
                        const arr = arrays[i];
                        const iter = iterators[i];
                        
                        try {
                            const result = iter.next();
                            
                            if (!result.done && result.value) {
                                const obj = result.value;
                                if (obj.data && obj.data[0] === 0xDEAD) {
                                    obj.data[0] = 0xBEEF;
                                }
                            }
                            
                            if (round % 10 === 0) {
                                arr.length = 500;
                                arr.length = 1000;
                                
                                const nextResult = iter.next();
                                if (!nextResult.done) {
                                    if (nextResult.value === undefined) {
                                        log('TEST 35: Iterator returned undefined after resize', 'SUCCESS');
                                        return;
                                    }
                                }
                            }
                            
                            if (round % 15 === 0) {
                                for (let j = 0; j < 100; j++) {
                                    arr.shift();
                                }
                                
                                const shiftResult = iter.next();
                                if (!shiftResult.done && shiftResult.value) {
                                    const expectedId = shiftResult.value.id;
                                    if (expectedId !== i) {
                                        log('TEST 35: Iterator ID mismatch after shift', 'SUCCESS');
                                        return;
                                    }
                                }
                            }
                            
                            if (round % 20 === 0) {
                                arr.splice(200, 300);
                                
                                const spliceResult = iter.next();
                                if (!spliceResult.done) {
                                    if (spliceResult.value && spliceResult.value.value > 1000) {
                                        log('TEST 35: Iterator value out of range', 'SUCCESS');
                                        return;
                                    }
                                }
                            }
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 35: No Array Iterator corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 35: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test36_WeakMapCollision() {
            log('TEST 36: WeakMap Collision', 'RUNNING');
            try {
                const weakMaps = [];
                const keys = [];
                
                for (let i = 0; i < 20; i++) {
                    const wm = new WeakMap();
                    weakMaps.push(wm);
                }
                
                for (let i = 0; i < 100; i++) {
                    const key = {id: i, data: new ArrayBuffer(1024)};
                    keys.push(key);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < weakMaps.length; i++) {
                        const wm = weakMaps[i];
                        
                        for (let j = 0; j < keys.length; j++) {
                            const key = keys[j];
                            const value = {
                                round: round,
                                index: j,
                                buffer: new Uint32Array(256),
                                nested: {data: 0xDEADBEEF}
                            };
                            
                            value.buffer.fill(0x41414141);
                            
                            wm.set(key, value);
                        }
                        
                        if (round % 5 === 0) {
                            for (let j = 0; j < keys.length; j += 2) {
                                keys[j] = null;
                            }
                            
                            for (let j = 0; j < keys.length; j++) {
                                if (keys[j] === null) {
                                    keys[j] = {id: j + 1000, data: new ArrayBuffer(2048)};
                                }
                            }
                        }
                        
                        for (let j = 0; j < keys.length; j++) {
                            if (keys[j]) {
                                const retrieved = wm.get(keys[j]);
                                if (retrieved) {
                                    if (retrieved.round !== round) {
                                        log('TEST 36: WeakMap value from wrong round', 'SUCCESS');
                                        return;
                                    }
                                    
                                    if (retrieved.buffer[0] !== 0x41414141) {
                                        log('TEST 36: WeakMap buffer corrupted', 'SUCCESS');
                                        return;
                                    }
                                    
                                    if (retrieved.nested.data !== 0xDEADBEEF) {
                                        log('TEST 36: WeakMap nested value corrupted', 'SUCCESS');
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                
                log('TEST 36: No WeakMap collision', 'FAIL');
                
            } catch(e) {
                log('TEST 36: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test37_PromiseChainUAF() {
            log('TEST 37: Promise Chain UAF', 'RUNNING');
            try {
                const promises = [];
                const chains = [];
                
                for (let i = 0; i < 30; i++) {
                    const promise = new Promise((resolve, reject) => {
                        setTimeout(() => {
                            resolve({id: i, data: new Array(100).fill(i)});
                        }, Math.random() * 100);
                    });
                    
                    promises.push(promise);
                }
                
                for (let i = 0; i < promises.length; i++) {
                    const chain = promises[i]
                        .then(result => {
                            result.processed = true;
                            return result;
                        })
                        .then(result => {
                            result.step2 = {value: 0xDEADBEEF};
                            return result;
                        })
                        .then(result => {
                            result.final = new Uint8Array(512);
                            result.final.fill(0xFF);
                            return result;
                        });
                    
                    chains.push(chain);
                }
                
                let resolvedCount = 0;
                let corruptionFound = false;
                
                for (let i = 0; i < chains.length; i++) {
                    chains[i]
                        .then(result => {
                            resolvedCount++;
                            
                            if (!result.processed) {
                                log('TEST 37: Promise chain step skipped', 'SUCCESS');
                                corruptionFound = true;
                            }
                            
                            if (!result.step2 || result.step2.value !== 0xDEADBEEF) {
                                log('TEST 37: Promise chain value corrupted', 'SUCCESS');
                                corruptionFound = true;
                            }
                            
                            if (!result.final || result.final[0] !== 0xFF) {
                                log('TEST 37: Promise chain buffer corrupted', 'SUCCESS');
                                corruptionFound = true;
                            }
                            
                            result.data = null;
                            result.final = null;
                            
                        })
                        .catch(err => {});
                }
                
                const racePromises = [];
                for (let i = 0; i < 50; i++) {
                    racePromises.push(new Promise((resolve) => {
                        setTimeout(() => resolve(i), Math.random() * 50);
                    }));
                }
                
                Promise.race(racePromises)
                    .then(winner => {
                        if (typeof winner !== 'number') {
                            log('TEST 37: Promise.race returned non-number', 'SUCCESS');
                            corruptionFound = true;
                        }
                    });
                
                Promise.all(chains)
                    .then(results => {
                        for (let i = 0; i < results.length; i++) {
                            if (results[i].id !== i) {
                                log('TEST 37: Promise.all result ID mismatch', 'SUCCESS');
                                corruptionFound = true;
                            }
                        }
                    })
                    .catch(err => {});
                
                setTimeout(() => {
                    if (!corruptionFound) {
                        log('TEST 37: No Promise chain UAF (resolved: ' + resolvedCount + ')', 'FAIL');
                    }
                }, 2000);
                
            } catch(e) {
                log('TEST 37: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test38_ProxyHandlerCorrupt() {
            log('TEST 38: Proxy Handler Corrupt', 'RUNNING');
            try {
                const targets = [];
                const proxies = [];
                const handlers = [];
                
                for (let i = 0; i < 30; i++) {
                    const target = {
                        id: i,
                        value: 0xDEAD + i,
                        buffer: new ArrayBuffer(1024),
                        nested: {data: new Uint32Array(256)}
                    };
                    
                    targets.push(target);
                    
                    const handler = {
                        get: function(obj, prop) {
                            if (prop === 'corrupted') {
                                delete obj.value;
                                obj.value = new Array(100).fill(0xBEEF);
                            }
                            return obj[prop];
                        },
                        set: function(obj, prop, value) {
                            if (prop === 'trigger') {
                                obj.buffer = new ArrayBuffer(2048);
                                obj.nested = null;
                            }
                            obj[prop] = value;
                            return true;
                        },
                        deleteProperty: function(obj, prop) {
                            if (prop === 'value') {
                                obj.backup = obj.value;
                            }
                            delete obj[prop];
                            return true;
                        }
                    };
                    
                    handlers.push(handler);
                    
                    const proxy = new Proxy(target, handler);
                    proxies.push(proxy);
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < proxies.length; i++) {
                        const proxy = proxies[i];
                        const target = targets[i];
                        
                        try {
                            const val = proxy.corrupted;
                            
                            if (Array.isArray(proxy.value)) {
                                if (proxy.value[0] === 0xBEEF) {
                                    if (target.value !== proxy.value) {
                                        log('TEST 38: Proxy and target diverged', 'SUCCESS');
                                        return;
                                    }
                                }
                            }
                            
                            proxy.trigger = round;
                            
                            if (!proxy.nested) {
                                if (target.nested !== null) {
                                    log('TEST 38: Proxy set not applied to target', 'SUCCESS');
                                    return;
                                }
                            }
                            
                            delete proxy.value;
                            
                            if (proxy.backup) {
                                const backupType = typeof proxy.backup;
                                if (backupType === 'object' && Array.isArray(proxy.backup)) {
                                    log('TEST 38: Proxy backup holds array', 'SUCCESS');
                                    return;
                                }
                            }
                            
                            proxy.newProp = {data: new Uint8Array(512)};
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 38: No Proxy handler corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 38: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test39_ShadowDOMCorrupt() {
            log('TEST 39: Shadow DOM Corrupt', 'RUNNING');
            try {
                const hosts = [];
                const shadows = [];
                
                for (let i = 0; i < 20; i++) {
                    const host = document.createElement('div');
                    host.id = 'shadow_host_' + i;
                    document.body.appendChild(host);
                    hosts.push(host);
                    
                    try {
                        const shadow = host.attachShadow({mode: 'open'});
                        shadows.push(shadow);
                        
                        for (let j = 0; j < 10; j++) {
                            const elem = document.createElement('span');
                            elem.textContent = 'Shadow content ' + j;
                            elem.setAttribute('data-index', j.toString());
                            shadow.appendChild(elem);
                        }
                        
                        const style = document.createElement('style');
                        style.textContent = 'span { color: red; }';
                        shadow.appendChild(style);
                        
                    } catch(e) {
                        shadows.push(null);
                    }
                }
                
                for (let round = 0; round < 100; round++) {
                    for (let i = 0; i < hosts.length; i++) {
                        const host = hosts[i];
                        const shadow = shadows[i];
                        
                        if (!shadow) continue;
                        
                        try {
                            const children = shadow.querySelectorAll('span');
                            
                            for (let j = 0; j < children.length; j++) {
                                children[j].textContent = 'Modified ' + round;
                            }
                            
                            if (round % 5 === 0) {
                                document.body.removeChild(host);
                                
                                try {
                                    const afterRemove = shadow.querySelectorAll('span');
                                    if (afterRemove.length > 0) {
                                        afterRemove[0].textContent = 'UAF test';
                                        log('TEST 39: Shadow DOM accessible after host removal', 'SUCCESS');
                                        return;
                                    }
                                } catch(e) {}
                                
                                document.body.appendChild(host);
                            }
                            
                            const newElem = document.createElement('div');
                            newElem.innerHTML = '<slot></slot>';
                            shadow.appendChild(newElem);
                            
                            host.innerHTML = '<p>Light DOM content ' + round + '</p>';
                            
                            while (shadow.childNodes.length > 15) {
                                shadow.removeChild(shadow.firstChild);
                            }
                            
                        } catch(e) {}
                    }
                }
                
                log('TEST 39: No Shadow DOM corruption', 'FAIL');
                
            } catch(e) {
                log('TEST 39: Exception - ' + e.message, 'SUCCESS');
            }
        }

        function test40_XMLHttpRequestUAF() {
            log('TEST 40: XMLHttpRequest UAF', 'RUNNING');
            try {
                const xhrs = [];
                const responses = [];
                
                for (let i = 0; i < 25; i++) {
                    const xhr = new XMLHttpRequest();
                    xhrs.push(xhr);
                    
                    xhr.onreadystatechange = function() {
                        try {
                            if (xhr.readyState === 4) {
                                responses.push({
                                    status: xhr.status,
                                    response: xhr.responseText,
                                    headers: xhr.getAllResponseHeaders(),
                                    index: i
                                });
                                
                                xhr.abort();
                                
                                try {
                                    const afterAbort = xhr.responseText;
                                    if (afterAbort.length > 0) {
                                        log('TEST 40: XHR response accessible after abort', 'SUCCESS');
                                    }
                                } catch(e) {}
                            }
                        } catch(e) {}
                    };
                    
                    xhr.onerror = function() {
                        try {
                            const errorStatus = xhr.status;
                            if (errorStatus !== 0) {
                                log('TEST 40: XHR has status after error', 'SUCCESS');
                            }
                        } catch(e) {}
                    };
                }
                
                const dataURL = 'data:text/plain;base64,VGVzdCBEYXRhIGZvciBYSFIgdGVzdGluZw==';
                
                for (let round = 0; round < 50; round++) {
                    for (let i = 0; i < xhrs.length; i++) {
                        const xhr = xhrs[i];
                        
                        try {
                            xhr.open('GET', dataURL + '?round=' + round + '&index=' + i, true);
                            xhr.setRequestHeader('X-Custom-Header', 'Value' + round);
                            xhr.send();
                            
                            if (round % 3 === 0) {
                                setTimeout(() => {
                                    xhr.abort();
                                    
                                    try {
                                        xhr.open('GET', dataURL + '?aborted=' + i, true);
                                        xhr.send();
                                    } catch(e) {}
                                }, 10);
                            }
                            
                            if (round % 7 === 0) {
                                xhr.responseType = 'arraybuffer';
                                
                                xhr.onload = function() {
                                    try {
                                        const buffer = xhr.response;
                                        if (buffer instanceof ArrayBuffer) {
                                            const view = new Uint8Array(buffer);
                                            view[0] = 0xFF;
                                            
                                            if (view[0] === 0xFF) {
                                                log('TEST 40: XHR ArrayBuffer writable', 'SUCCESS');
                                            }
                                        }
                                    } catch(e) {}
                                };
                            }
                            
                        } catch(e) {}
                    }
                }
                
                setTimeout(() => {
                    for (let i = 0; i < responses.length; i++) {
                        try {
                            const resp = responses[i];
                            if (resp.response && resp.response.length > 0) {
                                if (resp.index !== i) {
                                    log('TEST 40: XHR response index mismatch', 'SUCCESS');
                                    return;
                                }
                            }
                        } catch(e) {}
                    }
                    
                    xhrs.forEach(xhr => {
                        try {
                            xhr.abort();
                        } catch(e) {}
                    });
                    
                    log('TEST 40: No XMLHttpRequest UAF', 'FAIL');
                }, 2000);
                
            } catch(e) {
                log('TEST 40: Exception - ' + e.message, 'SUCCESS');
            }
        }

        log('PS4 WebKit Tests 31-40 Loaded', 'INFO');
    </script>
</body>
</html>
