
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PS4 WebKit Fuzzer v2.0</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    font-family: 'Courier New', monospace; 
    background: #000; 
    color: #0f0; 
    padding: 15px;
    font-size: 14px;
}
.container { max-width: 1400px; margin: 0 auto; }
h1 { 
    color: #0ff; 
    border-bottom: 2px solid #0ff; 
    padding-bottom: 10px; 
    margin-bottom: 20px;
    font-size: 24px;
}
h2 { 
    color: #ff0; 
    margin: 20px 0 10px 0; 
    font-size: 18px;
}
button {
    background: #003300;
    color: #0f0;
    border: 2px solid #0f0;
    padding: 12px 20px;
    margin: 5px;
    cursor: pointer;
    font-family: monospace;
    font-size: 14px;
    transition: all 0.3s;
}
button:hover { background: #005500; }
button:active { background: #007700; }
button.danger { background: #330000; border-color: #f00; color: #f00; }
button.danger:hover { background: #550000; }
button.primary { background: #000033; border-color: #00f; color: #0ff; }
button.primary:hover { background: #000055; }
input, select {
    background: #001100;
    color: #0f0;
    border: 1px solid #0f0;
    padding: 8px;
    font-family: monospace;
    margin: 5px;
    font-size: 14px;
}
.status-bar {
    background: #001100;
    border: 2px solid #0f0;
    padding: 15px;
    margin: 15px 0;
}
.status-item {
    display: inline-block;
    margin-right: 20px;
    padding: 5px 10px;
    background: #002200;
    border-radius: 3px;
}
.status-value {
    color: #ff0;
    font-weight: bold;
    font-size: 18px;
}
#log {
    background: #001100;
    border: 2px solid #0f0;
    padding: 10px;
    height: 400px;
    overflow-y: auto;
    font-size: 12px;
    white-space: pre-wrap;
    word-wrap: break-word;
}
.crash-list {
    background: #110000;
    border: 2px solid #f00;
    padding: 10px;
    margin: 10px 0;
    max-height: 300px;
    overflow-y: auto;
}
.crash-item {
    background: #220000;
    border-left: 4px solid #f00;
    padding: 8px;
    margin: 5px 0;
    cursor: pointer;
}
.crash-item:hover { background: #330000; }
.info-box {
    background: #000033;
    border: 2px solid #00f;
    padding: 15px;
    margin: 15px 0;
    color: #0ff;
}
.grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
}
.log-info { color: #0ff; }
.log-warn { color: #ff0; }
.log-error { color: #f00; }
.log-success { color: #0f0; }
.log-crash { 
    color: #f00; 
    font-weight: bold;
    background: #330000;
    padding: 2px 5px;
}
</style>
</head>
<body>

<div class="container">
<h1>üéÆ PS4 WebKit Fuzzer v2.0 - Persistent Edition</h1>

<div class="info-box">
<strong>üíæ SISTEMA DE PERSIST√äNCIA ATIVO</strong><br>
‚Ä¢ Crashes salvos automaticamente no localStorage do PS4<br>
‚Ä¢ Dados sobrevivem ao fechamento do browser<br>
‚Ä¢ Exporta√ß√£o em JSON para an√°lise posterior<br>
‚Ä¢ GitHub: <span style="color:#ff0">Hospedar e acessar direto do PS4</span>
</div>

<div class="status-bar">
<div class="status-item">
    Itera√ß√µes: <span class="status-value" id="iter">0</span>
</div>
<div class="status-item">
    Crashes: <span class="status-value" id="crashes">0</span>
</div>
<div class="status-item">
    Exceptions: <span class="status-value" id="exceptions">0</span>
</div>
<div class="status-item">
    Estado: <span class="status-value" id="state">Aguardando</span>
</div>
<div class="status-item">
    Storage: <span class="status-value" id="storage">0 KB</span>
</div>
</div>

<h2>‚öôÔ∏è Configura√ß√£o</h2>
<div>
<label>Itera√ß√µes: <input type="number" id="iterations" value="5000"></label>
<label>Delay (ms): <input type="number" id="delay" value="5"></label>
<label>Auto-save: <input type="checkbox" id="autosave" checked></label>
<label>Verbose log: <input type="checkbox" id="verbose"></label>
</div>

<h2>üéØ Fuzzers Dispon√≠veis</h2>
<div class="grid">
<button onclick="fuzzHistory()">History API</button>
<button onclick="fuzzTypedArrays()">TypedArrays</button>
<button onclick="fuzzCanvas()">Canvas 2D</button>
<button onclick="fuzzWebGL()">WebGL</button>
<button onclick="fuzzIndexedDB()">IndexedDB</button>
<button onclick="fuzzWorkers()">Web Workers</button>
<button onclick="fuzzPromises()">Promises</button>
<button onclick="fuzzJIT()">JIT Compiler</button>
<button onclick="fuzzDOM()">DOM APIs</button>
<button onclick="fuzzMediaSource()">Media Source</button>
<button onclick="fuzzWebAudio()">Web Audio</button>
<button onclick="fuzzFetch()">Fetch/XHR</button>
</div>

<h2>üöÄ A√ß√µes</h2>
<div>
<button onclick="fuzzAll()" class="danger">FUZZ ALL (Agressivo)</button>
<button onclick="stopFuzzing()">‚èπÔ∏è Parar</button>
<button onclick="resumeFuzzing()" class="primary">‚ñ∂Ô∏è Retomar</button>
<button onclick="clearLog()">üóëÔ∏è Limpar Log</button>
</div>

<h2>üíæ Gerenciamento de Dados</h2>
<div>
<button onclick="saveCrashData()" class="primary">üíæ Salvar Crashes</button>
<button onclick="loadCrashData()" class="primary">üìÇ Carregar Crashes</button>
<button onclick="exportJSON()">üì§ Exportar JSON</button>
<button onclick="importJSON()">üì• Importar JSON</button>
<button onclick="clearStorage()" class="danger">üóëÔ∏è Limpar Storage</button>
<button onclick="viewStats()">üìä Ver Estat√≠sticas</button>
</div>

<h2>üìã Crashes Salvos (<span id="crashCount">0</span>)</h2>
<div class="crash-list" id="crashList">
<em>Nenhum crash salvo ainda. Execute o fuzzer!</em>
</div>

<h2>üìù Log de Execu√ß√£o</h2>
<div id="log"></div>

</div>

<script>
// ============================================
// ESTADO GLOBAL
// ============================================
let running = false;
let paused = false;
let iterCount = 0;
let crashCount = 0;
let exceptionCount = 0;
let crashLog = [];
let currentFuzzer = null;

const STORAGE_KEY = 'ps4_fuzzer_crashes';
const CONFIG_KEY = 'ps4_fuzzer_config';
const STATS_KEY = 'ps4_fuzzer_stats';

// ============================================
// SISTEMA DE PERSIST√äNCIA
// ============================================

function saveCrashData() {
    try {
        const data = {
            version: '2.0',
            timestamp: new Date().toISOString(),
            crashes: crashLog,
            stats: {
                totalIterations: iterCount,
                totalCrashes: crashCount,
                totalExceptions: exceptionCount
            }
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        updateStorageSize();
        log('üíæ Dados salvos no localStorage (persistente)', 'success');
        
    } catch (e) {
        log('‚ùå Erro ao salvar: ' + e.message, 'error');
        
        // Se localStorage cheio, tentar limpar dados antigos
        if (e.name === 'QuotaExceededError') {
            if (confirm('Storage cheio! Limpar dados antigos?')) {
                clearOldCrashes();
                saveCrashData();
            }
        }
    }
}

function loadCrashData() {
    try {
        const data = localStorage.getItem(STORAGE_KEY);
        
        if (!data) {
            log('‚ÑπÔ∏è Nenhum dado salvo encontrado', 'info');
            return;
        }
        
        const parsed = JSON.parse(data);
        crashLog = parsed.crashes || [];
        
        if (parsed.stats) {
            iterCount = parsed.stats.totalIterations || 0;
            crashCount = parsed.stats.totalCrashes || 0;
            exceptionCount = parsed.stats.totalExceptions || 0;
        }
        
        updateCounters();
        updateCrashList();
        updateStorageSize();
        
        log(`üìÇ ${crashLog.length} crashes carregados do localStorage`, 'success');
        
    } catch (e) {
        log('‚ùå Erro ao carregar: ' + e.message, 'error');
    }
}

function exportJSON() {
    try {
        const data = {
            version: '2.0',
            exported: new Date().toISOString(),
            device: 'PS4 WebKit v12.00',
            crashes: crashLog,
            stats: {
                totalIterations: iterCount,
                totalCrashes: crashCount,
                totalExceptions: exceptionCount
            }
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `ps4_fuzzer_crashes_${Date.now()}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
        
        log('üì§ JSON exportado com sucesso!', 'success');
        
    } catch (e) {
        log('‚ùå Erro ao exportar: ' + e.message, 'error');
        
        // Fallback: mostrar JSON em nova janela
        const data = {crashes: crashLog, stats: {iterCount, crashCount, exceptionCount}};
        const win = window.open();
        win.document.write('<pre>' + JSON.stringify(data, null, 2) + '</pre>');
    }
}

function importJSON() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                if (data.crashes) {
                    crashLog = crashLog.concat(data.crashes);
                    crashCount = crashLog.length;
                    updateCounters();
                    updateCrashList();
                    saveCrashData();
                    log(`üì• ${data.crashes.length} crashes importados!`, 'success');
                }
                
            } catch (e) {
                log('‚ùå Erro ao importar: ' + e.message, 'error');
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

function clearStorage() {
    if (!confirm('üóëÔ∏è Limpar TODOS os dados salvos?\n\nEsta a√ß√£o n√£o pode ser desfeita!')) {
        return;
    }
    
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(CONFIG_KEY);
    localStorage.removeItem(STATS_KEY);
    
    crashLog = [];
    crashCount = 0;
    iterCount = 0;
    exceptionCount = 0;
    
    updateCounters();
    updateCrashList();
    updateStorageSize();
    
    log('üóëÔ∏è Storage limpo!', 'success');
}

function clearOldCrashes() {
    // Manter apenas os 100 crashes mais recentes
    if (crashLog.length > 100) {
        crashLog = crashLog.slice(-100);
        log('üóëÔ∏è Crashes antigos removidos (mantidos √∫ltimos 100)', 'warn');
    }
}

function updateStorageSize() {
    try {
        const data = localStorage.getItem(STORAGE_KEY) || '';
        const sizeKB = (data.length / 1024).toFixed(2);
        document.getElementById('storage').textContent = sizeKB + ' KB';
    } catch (e) {
        document.getElementById('storage').textContent = 'N/A';
    }
}

function updateCrashList() {
    const listEl = document.getElementById('crashList');
    document.getElementById('crashCount').textContent = crashLog.length;
    
    if (crashLog.length === 0) {
        listEl.innerHTML = '<em>Nenhum crash salvo ainda. Execute o fuzzer!</em>';
        return;
    }
    
    listEl.innerHTML = '';
    
    // Mostrar √∫ltimos 20 crashes
    const recent = crashLog.slice(-20).reverse();
    
    recent.forEach((crash, idx) => {
        const div = document.createElement('div');
        div.className = 'crash-item';
        div.innerHTML = `
            <strong>[${crash.timestamp}]</strong> ${crash.fuzzer || 'Unknown'}<br>
            <small>${crash.error}: ${crash.message}</small>
        `;
        div.onclick = () => {
            alert(JSON.stringify(crash, null, 2));
        };
        listEl.appendChild(div);
    });
}

function viewStats() {
    const stats = {
        totalIterations: iterCount,
        totalCrashes: crashCount,
        totalExceptions: exceptionCount,
        crashRate: crashCount > 0 ? ((crashCount / iterCount) * 100).toFixed(2) + '%' : '0%',
        storedCrashes: crashLog.length,
        storageUsed: document.getElementById('storage').textContent
    };
    
    alert('üìä ESTAT√çSTICAS\n\n' + JSON.stringify(stats, null, 2));
}

// ============================================
// SISTEMA DE LOG
// ============================================

const logEl = document.getElementById('log');

function log(msg, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const typeClass = 'log-' + type;
    
    const line = document.createElement('div');
    line.className = typeClass;
    line.textContent = `[${timestamp}] ${msg}`;
    
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
    
    // Auto-save ap√≥s crash
    if (type === 'crash' && document.getElementById('autosave').checked) {
        saveCrashData();
    }
}

function clearLog() {
    logEl.innerHTML = '';
    log('Log limpo', 'info');
}

function updateStatus(state) {
    document.getElementById('state').textContent = state;
    document.getElementById('state').style.color = 
        state === 'Rodando' ? '#0f0' :
        state === 'Pausado' ? '#ff0' :
        state === 'Erro' ? '#f00' : '#0ff';
}

function updateCounters() {
    document.getElementById('iter').textContent = iterCount.toLocaleString();
    document.getElementById('crashes').textContent = crashCount;
    document.getElementById('exceptions').textContent = exceptionCount;
}

// ============================================
// CONTROLES
// ============================================

function stopFuzzing() {
    running = false;
    paused = false;
    updateStatus('Parado');
    log('‚èπÔ∏è Fuzzing interrompido', 'warn');
    saveCrashData();
}

function resumeFuzzing() {
    if (currentFuzzer && paused) {
        paused = false;
        running = true;
        updateStatus('Rodando');
        log('‚ñ∂Ô∏è Fuzzing retomado', 'success');
        currentFuzzer();
    } else {
        log('‚ÑπÔ∏è Nenhum fuzzer para retomar. Inicie um novo.', 'info');
    }
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// ============================================
// GERADORES DE DADOS ALEAT√ìRIOS
// ============================================

function rand(min = 0, max = 0xFFFFFFFF) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randStr(maxLen = 1000) {
    const len = rand(0, maxLen);
    return 'X'.repeat(len);
}

function randBytes(len) {
    const arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) arr[i] = rand(0, 255);
    return arr;
}

function randURL() {
    const schemes = ['#', 'http://', 'https://', 'file://', 'data:', 'javascript:', 'blob:'];
    return schemes[rand(0, schemes.length - 1)] + randStr(rand(10, 10000));
}

function randObj(depth = 0) {
    if (depth > 3) return null;
    const types = [
        () => rand(),
        () => randStr(),
        () => null,
        () => undefined,
        () => new Array(rand(0, 100)),
        () => ({a: randObj(depth + 1)})
    ];
    return types[rand(0, types.length - 1)]();
}

// ============================================
// WRAPPER DE FUZZING
// ============================================

async function runFuzzer(name, fuzzerFn) {
    running = true;
    paused = false;
    currentFuzzer = () => runFuzzer(name, fuzzerFn);
    updateStatus('Rodando');
    
    const iterations = parseInt(document.getElementById('iterations').value);
    const delay = parseInt(document.getElementById('delay').value);
    const verbose = document.getElementById('verbose').checked;
    
    log(`üöÄ Iniciando ${name}...`, 'info');
    
    for (let i = 0; i < iterations && running && !paused; i++) {
        iterCount++;
        
        try {
            await fuzzerFn();
            
            if (verbose && i % 100 === 0) {
                log(`${name}: ${i}/${iterations}`, 'info');
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            
            const crash = {
                timestamp: new Date().toISOString(),
                fuzzer: name,
                iteration: i,
                error: e.name,
                message: e.message,
                stack: e.stack
            };
            
            crashLog.push(crash);
            
            log(`üí• CRASH: ${e.name} - ${e.message}`, 'crash');
            updateCounters();
            updateCrashList();
        }
        
        if (delay > 0) await sleep(delay);
    }
    
    updateStatus(paused ? 'Pausado' : 'Conclu√≠do');
    log(`‚úÖ ${name} finalizado: ${iterations} itera√ß√µes`, 'success');
    saveCrashData();
}

// ============================================
// FUZZERS
// ============================================

async function fuzzHistory() {
    await runFuzzer('History API', async () => {
        const mutations = [
            () => history.pushState({}, '', randURL()),
            () => history.replaceState({}, '', randURL()),
            () => history.pushState(randObj(), randStr(), randURL()),
            () => { for(let i=0; i<rand(1,50); i++) history.pushState({}, '', '#'+i); },
            () => { setTimeout(() => history.back(), 0); history.pushState({}, '', randURL()); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzTypedArrays() {
    await runFuzzer('TypedArrays', async () => {
        const types = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        const Type = types[rand(0, types.length - 1)];
        
        const mutations = [
            () => new Type(rand(0, 0xFFFF)),
            () => { const a = new Type(10); a[rand(-100, 100)] = rand(); },
            () => { const a = new Type(10); a.length = rand(0, 0xFFFFFFFF); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzCanvas() {
    await runFuzzer('Canvas 2D', async () => {
        const c = document.createElement('canvas');
        c.width = rand(1, 10000);
        c.height = rand(1, 10000);
        const ctx = c.getContext('2d');
        
        const mutations = [
            () => ctx.fillRect(rand(), rand(), rand(), rand()),
            () => ctx.createImageData(rand(1, 5000), rand(1, 5000)),
            () => c.toDataURL(),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzWebGL() {
    await runFuzzer('WebGL', async () => {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        if (!gl) return;
        
        const mutations = [
            () => { const b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b); gl.bufferData(gl.ARRAY_BUFFER, randBytes(rand(1000, 100000)), gl.STATIC_DRAW); },
            () => gl.createTexture(),
            () => gl.createShader(gl.VERTEX_SHADER),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzIndexedDB() {
    await runFuzzer('IndexedDB', async () => {
        const req = indexedDB.open('fuzz_' + rand(), rand(1, 10));
        req.onupgradeneeded = (e) => {
            const db = e.target.result;
            try { db.createObjectStore(randStr(20)); } catch(e) {}
        };
    });
}

async function fuzzWorkers() {
    await runFuzzer('Web Workers', async () => {
        const code = `onmessage=()=>postMessage(${rand()})`;
        const blob = new Blob([code], {type: 'application/javascript'});
        const w = new Worker(URL.createObjectURL(blob));
        w.postMessage(randObj());
        setTimeout(() => w.terminate(), 50);
    });
}

async function fuzzPromises() {
    await runFuzzer('Promises', async () => {
        const mutations = [
            () => new Promise((r,j) => setTimeout(() => r(randObj()), rand(0,10))),
            () => Promise.race([new Promise(r=>r(1)), new Promise((_,j)=>j(randObj()))]),
            () => Promise.all(new Array(rand(1,50)).fill(0).map(() => new Promise(r=>r(rand())))),
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzJIT() {
    await runFuzzer('JIT Compiler', async () => {
        const fn = new Function(`let x=${rand()}; for(let i=0;i<1000;i++) x+=${rand()}; return x;`);
        for(let i=0; i<100; i++) fn();
    });
}

async function fuzzDOM() {
    await runFuzzer('DOM APIs', async () => {
        const mutations = [
            () => { const e = document.createElement(randStr(10)); e.innerHTML = randStr(100); document.body.appendChild(e); },
            () => document.createRange(),
            () => { const e = document.createElement('div'); e.style.cssText = randStr(100); },
        ];
        mutations[rand(0, mutations.length - 1)]();
    });
}

async function fuzzMediaSource() {
    await runFuzzer('Media Source', async () => {
        const v = document.createElement('video');
        const ms = new MediaSource();
        v.src = URL.createObjectURL(ms);
    });
}

async function fuzzWebAudio() {
    await runFuzzer('Web Audio', async () => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        osc.frequency.value = rand(20, 20000);
        osc.connect(ctx.destination);
    });
}

async function fuzzFetch() {
    await runFuzzer('Fetch/XHR', async () => {
        fetch(randURL()).catch(() => {});
    });
}

async function fuzzAll() {
    if (!confirm('‚ö†Ô∏è Modo agressivo pode travar o navegador!\n\nContinuar?')) return;
    
    log('üî• MODO AGRESSIVO ATIVADO', 'warn');
    
    const fuzzers = [
        fuzzHistory, fuzzTypedArrays, fuzzCanvas, fuzzWebGL,
        fuzzIndexedDB, fuzzWorkers, fuzzPromises, fuzzJIT,
        fuzzDOM, fuzzMediaSource, fuzzWebAudio, fuzzFetch
    ];
    
    for (const fuzzer of fuzzers) {
        if (!running) break;
        await fuzzer();
        await sleep(1000);
    }
    
    log('üéâ FUZZ ALL COMPLETO!', 'success');
}

// ============================================
// INICIALIZA√á√ÉO
// ============================================

window.addEventListener('load', () => {
    log('üéÆ PS4 WebKit Fuzzer v2.0 carregado', 'success');
    log('üíæ Sistema de persist√™ncia ativo', 'info');
    
    // Carregar dados salvos automaticamente
    loadCrashData();
    updateStorageSize();
    
    log('‚úÖ Pronto para fuzzing!', 'success');
});

// Auto-save ao fechar
window.addEventListener('beforeunload', () => {
    if (crashCount > 0) {
        saveCrashData();
    }
});
</script>

</body>
</html>
