<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>UAF vs OOM Verifier</title>
    <style>
        body { background-color: #222; color: #fff; font-family: sans-serif; padding: 20px; }
        .stat { font-size: 24px; margin: 10px 0; }
        button { padding: 10px 20px; font-size: 18px; cursor: pointer; }
    </style>
</head>
<body>
    <h2>Diagnóstico: UAF ou Falta de Memória?</h2>
    
    <div class="stat">
        <label>Tamanho do Payload:</label>
        <select id="payloadSize">
            <option value="1024">Leve (1 KB)</option>
            <option value="1048576">Pesado (1 MB)</option> </select>
    </div>

    <div class="stat">Iteração Atual: <span id="counter" style="color:yellow">0</span></div>
    
    <button onclick="runTest()">RODAR TESTE</button>
    <div id="log"></div>

    <script>
        let iteration = 0;
        
        function log(msg) {
            document.getElementById('log').innerHTML += `<div>${msg}</div>`;
        }

        async function runTest() {
            const size = parseInt(document.getElementById('payloadSize').value);
            iteration = 0;
            
            log(`Iniciando teste com payload de ${size} bytes...`);

            // Cria o código do worker dinamicamente com o tamanho escolhido
            const workerCode = `
                onmessage = (e) => {
                    const port = e.ports[0];
                    // Cria um buffer do tamanho selecionado
                    const payload = new Uint8Array(${size}); 
                    payload.fill(0x41);
                    
                    setInterval(() => {
                        try { port.postMessage(payload, [payload.buffer]); } catch(e){}
                    }, 0);
                }
            `;
            const blobUrl = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));

            while(true) {
                iteration++;
                document.getElementById('counter').innerText = iteration;
                
                // Força renderização visual
                await new Promise(r => setTimeout(r, 50));

                await runCycle(blobUrl);
                
                // Limpeza forçada (se for leak, isso não vai ajudar muito, o que é o objetivo do teste)
                if(iteration % 50 === 0) log(`Marco atingido: ${iteration}`);
            }
        }

        function runCycle(url) {
            return new Promise((resolve) => {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "stress_" + iteration);
                sw.port.start();
                sw.port.postMessage("init", [mc.port2]);

                setTimeout(() => {
                    sw.port.close();
                    mc.port1.close();
                    
                    // Pequeno delay para a próxima iteração
                    setTimeout(resolve, 10);
                }, 5); 
            });
        }
    </script>
</body>
</html>
