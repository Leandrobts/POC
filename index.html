<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>PS4 WebKit Research Harness v4.1 (SAFE/AGGR bounded)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<h2>PS4 WebKit Research Harness v4.1</h2>
<p><b>Objetivo:</b> encontrar anomalias/crashes com <u>invariantes</u> e <u>reason codes</u> (sem exploração).</p>

<div>
  <button onclick="clearLog()">Limpar</button>
  <button onclick="runOnce('SAFE')">RUN Once SAFE</button>
  <button onclick="runOnce('AGGR')">RUN Once AGGR</button>
  <button onclick="startLoop('SAFE')">Loop SAFE</button>
  <button onclick="startLoop('AGGR')">Loop AGGR</button>
  <button onclick="stopLoop()">Parar</button>
</div>

<div style="margin-top:10px;">
  <label>Loop N <input id="loopN" type="number" value="50" min="1" step="10"></label>
  <label style="margin-left:10px;">Delay ms <input id="delayMs" type="number" value="20" min="0" step="10"></label>
</div>

<div style="margin-top:10px;">
  <label><input type="checkbox" id="t_nav1" checked> NAV1 (History clone/bookkeeping)</label><br>
  <label><input type="checkbox" id="t_nav2" checked> NAV2 (History deferred integrity + cross-entry)</label><br>
  <label><input type="checkbox" id="t_style1" checked> STYLE1 (Fullscreen/blur + DOM mutation invariants)</label><br>
  <label><input type="checkbox" id="t_layout1" checked> LAYOUT1 (Layout thrash + mutation invariants)</label><br>
  <label><input type="checkbox" id="t_media1" checked> MEDIA1 (Media teardown invariants)</label><br>
</div>

<pre id="log" style="white-space:pre-wrap; border:1px solid #999; padding:10px; margin-top:10px; height:60vh; overflow:auto;"></pre>

<script>
/* =========================
   HARNESS CORE
   ========================= */
(function(){
  const logEl = document.getElementById('log');
  const NOW = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  const UA = (navigator && navigator.userAgent) ? navigator.userAgent : "unknown";
  const ORIGIN = (location && location.origin) ? location.origin : "unknown";
  const URL0 = (location && location.href) ? location.href : "unknown";

  function log(s){ logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }
  window.clearLog = () => { logEl.textContent = ""; };

  // Determinístico
  function xorshift32(seed){
    let x = (seed|0) || 0x12345678;
    return function(){
      x ^= (x << 13); x |= 0;
      x ^= (x >>> 17);
      x ^= (x << 5); x |= 0;
      return (x >>> 0);
    };
  }

  function pickTests(){
    const ids = ["nav1","nav2","style1","layout1","media1"];
    const out = [];
    for (let id of ids){
      const cb = document.getElementById("t_"+id);
      if (cb && cb.checked) out.push(id.toUpperCase());
    }
    return out;
  }

  const CAPS = {
    SAFE:  { budgetMs: 6,  historyOps: 12, cloneOps: 40, domNodes: 220, layoutOps: 80,  mediaOps: 20 },
    AGGR:  { budgetMs: 10, historyOps: 25, cloneOps: 90, domNodes: 420, layoutOps: 180, mediaOps: 35 }
  };

  function healthTag(tag, when){
    // drift aproximado: mede atraso de um setTimeout(0)
    const t0 = NOW();
    return new Promise(res => {
      setTimeout(() => {
        const dt = NOW() - t0;
        log(`[HLTH] ${tag}:${when} eventLoop drift ~${dt.toFixed(2)}ms`);
        res(dt);
      }, 0);
    });
  }

  function rc(code, extra){
    // reason code format: RC:NAME key=val ...
    let s = `[RC] ${code}`;
    if (extra) s += " " + extra;
    log(s);
  }

  function capYield(mode){
    // micro-yield para dar chance de popstate/media events rodarem
    const budget = CAPS[mode].budgetMs;
    const t0 = NOW();
    return new Promise(res => {
      function spin(){
        if ((NOW() - t0) >= budget) return res();
        setTimeout(spin, 0);
      }
      spin();
    });
  }

  // Execução controlada
  async function runSuite(mode, seed){
    const caps = CAPS[mode];
    const tests = pickTests();
    log(`[READY] Harness v4.1 carregado. Objetivo: indicadores de vulnerabilidade (sem exploração / sem DoS).`);
    log(`[INFO] UA=${UA}`);
    log(`[INFO] origin=${ORIGIN} url=${URL0}`);
    log(`[INFO] mode=${mode} caps: budgetMs=${caps.budgetMs} historyOps=${caps.historyOps} cloneOps=${caps.cloneOps} domNodes<=${caps.domNodes} layoutOps=${caps.layoutOps} mediaOps=${caps.mediaOps}`);
    log(`[RUN] Once | tests=${tests.length} mode=${mode} seed=${seed}`);

    let fails = 0;
    for (let t of tests){
      const t0 = NOW();
      log("------------------------------------------------------------");
      log(`[CP] begin ${t}`);
      await healthTag(t, "pre");
      try{
        const ok = await TESTS[t](mode, seed);
        if (!ok){
          fails++;
          log(`[FAIL] ${t} :: invariants violados (ver RC acima)`);
        }else{
          log(`[PASS] ${t} :: OK (bounded).`);
        }
      }catch(e){
        fails++;
        log(`[FAIL] ${t} :: exception: ${e && e.message ? e.message : String(e)}`);
        rc(`${t}_EXC`, `name=${(e&&e.name)||'unknown'}`);
      }
      await healthTag(t, "post");
      log(`[CP] end ${t} dt=${(NOW()-t0).toFixed(2)}ms`);
    }
    log("------------------------------------------------------------");
    log(`[RUN] Done. fails=${fails} lastTest=${tests[tests.length-1]||"none"}`);
    return fails;
  }

  let loopTimer = null;
  let loopStop = false;
  window.stopLoop = () => { loopStop = true; if (loopTimer) { clearTimeout(loopTimer); loopTimer = null; } log("[RUN] Loop stop requested."); };

  window.runOnce = (mode) => {
    const seed = 1337;
    runSuite(mode, seed);
  };

  window.startLoop = (mode) => {
    const N = Math.max(1, parseInt(document.getElementById("loopN").value||"50",10));
    const delayMs = Math.max(0, parseInt(document.getElementById("delayMs").value||"20",10));
    loopStop = false;
    log(`[RUN] Loop | mode=${mode} loopN=${N} delayMs=${delayMs}`);
    let i = 0;
    const baseSeed = 1337;
    const step = async () => {
      if (loopStop) { log("[RUN] Loop stopped."); return; }
      i++;
      log("------------------------------------------------------------");
      log(`[ITER] ${i}/${N}`);
      const fails = await runSuite(mode, baseSeed + i - 1);
      if (i >= N) { log(`[RUN] Loop done. fails(last)=${fails}`); return; }
      loopTimer = setTimeout(step, delayMs);
    };
    step();
  };

  /* =========================
     TESTS
     ========================= */

  function makeState(rng, idx){
    // Estado cloneável, com sentinelas suficientes para detectar mistura
    const a = (rng() & 0xFFFF);
    const b = (rng() & 0xFFFF);
    const buf = new ArrayBuffer(64);
    const u32 = new Uint32Array(buf);
    u32[0] = 0xC0FFEE00 ^ idx;
    u32[1] = 0x12345678 ^ a;
    u32[2] = 0x9ABCDEF0 ^ b;
    // objeto com "shape" estável
    return {
      kind: "NAV",
      idx: idx,
      tag: "E" + idx + "_" + a.toString(16),
      nums: [idx, a, b, (a^b)>>>0],
      meta: { a:a, b:b, t: NOW() },
      buf: buf
    };
  }

  function shallowHashState(st){
    try{
      const u32 = new Uint32Array(st.buf);
      return ((u32[0]^u32[1]^u32[2])>>>0);
    }catch(_){
      return 0;
    }
  }

  function tryReplaceState(state, url){
    // Android content:// origin=null pode bloquear. No PS4 file:// geralmente permite.
    history.replaceState(state, "", url);
  }

  async function historyGoAndWait(delta, timeoutMs){
    return new Promise(res => {
      let done = false;
      function finish(ok){
        if (done) return;
        done = true;
        window.removeEventListener("popstate", onPop);
        res(ok);
      }
      const to = setTimeout(() => finish(false), timeoutMs);
      function onPop(_ev){
        clearTimeout(to);
        finish(true);
      }
      window.addEventListener("popstate", onPop, { once: true });
      try{
        history.go(delta);
      }catch(e){
        clearTimeout(to);
        finish(false);
      }
    });
  }

  // NAV1: valida bookkeeping e clone no push (sem tentar aliasing)
  async function NAV1(mode, seed){
    const caps = CAPS[mode];
    const rng = xorshift32(seed);
    const ops = caps.historyOps;

    let popSeen = 0;
    let cloneAtPush = 0;
    let wrong = 0;
    let timeouts = 0;
    let envBlocked = 0;

    // Cria entradas
    const baseLen = history.length;
    rc("NAV1_BASE", `historyLen=${baseLen}`);

    const entries = [];
    for (let i=0;i<ops;i++){
      const st = makeState(rng, i);
      const hash0 = shallowHashState(st);
      // tenta detectar clone no push: muta após push e vê se pop retorna o valor antigo
      const url = "#nav1_" + seed + "_" + i;
      try{
        history.pushState(st, "", url);
      }catch(e){
        rc("NAV1_PUSH_THROW", `i=${i} name=${e.name||'err'}`);
        return false;
      }
      // mutate local object after push
      try{
        st.meta.a ^= 0x1111;
        const u32 = new Uint32Array(st.buf);
        u32[1] ^= 0x01010101;
      }catch(_){}
      entries.push({ idx:i, url:url, hash0:hash0, expect0:(0xC0FFEE00 ^ i)>>>0 });
      await capYield(mode);
    }

    // Caminha para trás e valida popstate
    for (let step=0; step<ops-1; step++) {
        // After pushing idx 0..ops-1, we are currently at idx=ops-1.
        // The first go(-1) navigates to idx=ops-2. Start expected at ops-2.
        const expected = (ops - 2) - step;

        const st = await historyGoAndWait(-1, 80);
        if (st === '__TIMEOUT__') {
            timeouts++;
            RC('NAV1_POP_TIMEOUT', { step, expected });
            continue;
        }
        popSeen++;

        // If we landed outside our NAV1 entries, it's a dirty stack (not memory corruption).
        if (!st || st.kind !== 'NAV1' || st.token !== token) {
            envBlocked++;
            RC('NAV1_ENV_DIRTY_ENTRY', { step, expected, gotKind: st ? st.kind : null, url: location.href });
            break;
        }

        if (st.idx !== expected) {
            wrong++;
            RC('NAV1_IDX_MISMATCH', { expect: expected, got: st.idx, url: location.href });
        }
    }

// buffer sentinel integrity (detecta mistura)
      try{
        const u32 = new Uint32Array(st.buf);
        const s0 = u32[0]>>>0;
        if (s0 !== ((0xC0FFEE00 ^ st.idx)>>>0)){
          wrong++;
          rc("NAV1_BUF_SENTINEL_BAD", `idx=${st.idx} got=0x${s0.toString(16)}`);
        }
      }catch(e){
        wrong++;
        rc("NAV1_BUF_ACCESS_THROW", `idx=${st.idx} name=${e.name||'err'}`);
      }

      // clone-at-push signal (se pop retorna valores originais, não os mutados)
      // heurística: se meta.a == original (sem xor 0x1111) e buf[1] não foi xor 0x01010101
      // Como não guardamos original, inferimos pela consistência interna: nums[1] deve bater meta.a.
      if (st && st.meta && st.nums && st.nums.length >= 3){
        if (((st.nums[1]>>>0) === (st.meta.a>>>0)) && ((st.nums[2]>>>0) === (st.meta.b>>>0))){
          cloneAtPush++;
        }
      }

      await capYield(mode);
    }

    // tenta voltar ao fim (não falhar se não conseguir)
    for (let k=0;k<ops;k++){
      const ok = await historyGoAndWait(+1, 800);
      if (!ok) break;
      await capYield(mode);
    }

    log(`[OK] popSeen=${popSeen} cloneAtPush=${cloneAtPush} wrong/inconclusive=${wrong} timeouts=${timeouts} envBlocked=${envBlocked}`);
    return (wrong === 0); // timeouts contam como inconclusivo (não marca falha por si)
  }

  // NAV2: integridade deferida + cross-entry contamination detector
  async function NAV2(mode, seed){
    const caps = CAPS[mode];
    const rng = xorshift32(seed ^ 0xA5A5A5A5);
    const ops = Math.max(8, Math.min(caps.historyOps, 18));

    let popSeen = 0, wrong = 0, timeouts = 0, cross = 0;

    // cria dois "grupos" com sentinelas bem diferentes para detectar cross contamination
    const rec = []; // expected per index
    for (let i=0;i<ops;i++){
      const st = makeState(rng, i);
      // grupo A/B alternado
      const group = (i & 1) ? 0xA0A00000 : 0xB0B00000;
      try{
        const u32 = new Uint32Array(st.buf);
        u32[3] = (group ^ i)>>>0;
      }catch(_){}
      const expect = { idx:i, group:group>>>0, url:"#nav2_"+seed+"_"+i };
      rec.push(expect);
      history.pushState(st, "", expect.url);

      // after push: aggressively overwrite local references (helps detect stale pointer use, without "spray")
      // (não é exploração; é só reduzir determinismo)
      let trash = [];
      for (let t=0;t<12;t++){
        trash.push({x:t, y:"T"+t, z:[t,t^1,t^2]});
      }
      trash = null;

      await capYield(mode);
    }

    // bounce pattern: go back 2, forward 1 repeatedly to stress bookkeeping order
    for (let step=0; step<ops; step++){
      const delta = (step % 3 === 0) ? -2 : +1;
      const ok = await historyGoAndWait(delta, 1200);
      if (!ok){ timeouts++; rc("NAV2_POP_TIMEOUT", `step=${step} delta=${delta}`); continue; }
      popSeen++;

      const st = history.state;
      if (!st || st.kind !== "NAV"){ wrong++; rc("NAV2_KIND_BAD", `gotKind=${st && st.kind}`); continue; }

      // expected group from sentinel u32[3]
      try{
        const u32 = new Uint32Array(st.buf);
        const g = (u32[3] ^ st.idx) & 0xFFFF0000;
        const expectG = (st.idx & 1) ? 0xA0A00000 : 0xB0B00000;
        if (((g>>>0) !== (expectG>>>0))){
          cross++;
          rc("NAV2_CROSS_GROUP", `idx=${st.idx} got=0x${(g>>>0).toString(16)} exp=0x${expectG.toString(16)}`);
        }
      }catch(e){
        wrong++;
        rc("NAV2_BUF_THROW", `idx=${st.idx} name=${e.name||'err'}`);
      }

      // URL bookkeeping sanity: hash should match our pattern sometimes; if not, log but not fail
      if (String(location.hash).indexOf("nav2_") === -1){
        rc("NAV2_HASH_ANOM", `hash=${location.hash}`);
      }

      await capYield(mode);
    }

    log(`[OK] popSeen=${popSeen} wrong/inconclusive=${wrong} crossContam=${cross} timeouts=${timeouts}`);
    return (wrong === 0 && cross === 0);
  }

  // STYLE1: fullscreen/blur + DOM mutation + animation lifecycle invariants
  async function STYLE1(mode, seed){
    const caps = CAPS[mode];
    const rng = xorshift32(seed ^ 0x13579BDF);
    const N = Math.min(caps.domNodes, 220);

    let skips = 0, anom = 0, throws = 0;

    // container
    const host = document.createElement("div");
    host.id = "style1_host";
    host.style.cssText = "position:relative; width:320px; height:180px; overflow:hidden; border:1px solid #444;";
    document.body.appendChild(host);

    // create nodes with animation + filter toggles
    const nodes = [];
    for (let i=0;i<N;i++){
      const d = document.createElement("div");
      d.textContent = "n"+i;
      d.style.cssText = "position:absolute; left:"+(i%16)*20+"px; top:"+((i/16)|0)*12+"px; font-size:10px;";
      // quick style changes
      d.style.filter = (i%3===0) ? "blur(0.6px)" : "none";
      host.appendChild(d);
      nodes.push(d);
    }

    // attempt fullscreen if available (PS4 may require user gesture; we are in button click path)
    const fsEl = document.documentElement;
    try{
      if (fsEl && fsEl.webkitRequestFullscreen){
        fsEl.webkitRequestFullscreen();
      }else if (fsEl && fsEl.requestFullscreen){
        fsEl.requestFullscreen();
      }else{
        skips++;
        rc("STYLE1_NO_FULLSCREEN", "");
      }
    }catch(e){
      skips++;
      rc("STYLE1_FULLSCREEN_THROW", `name=${e.name||'err'}`);
    }

    // mutation/blur toggles + detach/reattach
    for (let k=0;k<Math.min(18, caps.historyOps);k++){
      try{
        const idx = (rng() % nodes.length) | 0;
        const n = nodes[idx];
        if (!n || !n.isConnected){ anom++; rc("STYLE1_NODE_NOT_CONNECTED", `k=${k} idx=${idx}`); continue; }
        // toggle filter + contentVisibility (often tricky in WebKit variants)
        n.style.filter = (n.style.filter === "none") ? "blur(1px)" : "none";
        host.style.webkitFilter = (k%2===0) ? "blur(0.8px)" : "none";
        // detach/reattach slice
        if (k % 3 === 0){
          const frag = document.createDocumentFragment();
          for (let j=0;j<8 && nodes.length;j++){
            const m = nodes[(idx+j)%nodes.length];
            if (m && m.parentNode === host) frag.appendChild(m);
          }
          host.appendChild(frag);
        }
        // force style/layout reads (bounded)
        void host.offsetHeight;
        void n.getBoundingClientRect();
      }catch(e){
        throws++;
        rc("STYLE1_MUT_THROW", `k=${k} name=${e.name||'err'}`);
      }
      await capYield(mode);
    }

    // invariants: host must be connected, no node should have NaN geometry
    try{
      if (!host.isConnected){ anom++; rc("STYLE1_HOST_DISCONNECTED", ""); }
      for (let i=0;i<Math.min(40, nodes.length);i++){
        const r = nodes[i].getBoundingClientRect();
        if (!(r.width >= 0) || !(r.height >= 0)){ anom++; rc("STYLE1_RECT_NAN", `i=${i} w=${r.width} h=${r.height}`); break; }
      }
    }catch(e){
      throws++;
      rc("STYLE1_POST_THROW", `name=${e.name||'err'}`);
    }

    // cleanup
    try{ host.remove(); }catch(_){}

    log(`[OK] skips=${skips} anom=${anom} throws=${throws}`);
    return (anom === 0 && throws === 0);
  }

  // LAYOUT1: layout thrash + mutation; invariants about monotonic counters & stable reads
  async function LAYOUT1(mode, seed){
    const caps = CAPS[mode];
    const rng = xorshift32(seed ^ 0xCAFEBABE);
    const ops = caps.layoutOps;

    let anom = 0, throws = 0;

    const root = document.createElement("div");
    root.id = "layout1_root";
    root.style.cssText = "width:320px; border:1px dashed #777; padding:4px;";
    document.body.appendChild(root);

    // build a nested tree (bounded)
    const depth = (mode === "AGGR") ? 20 : 14;
    let cur = root;
    for (let d=0; d<depth; d++){
      const box = document.createElement("div");
      box.textContent = "d"+d;
      box.style.cssText = "padding:2px; margin:1px; border:1px solid #999;";
      cur.appendChild(box);
      cur = box;
    }

    let lastH = -1;
    for (let i=0;i<ops;i++){
      try{
        // mutate: toggle class-like style and innerHTML for small subtrees
        if (i % 5 === 0){
          cur.style.borderWidth = ((i%3)+1) + "px";
          cur.style.letterSpacing = ((i%4)) + "px";
        }
        if (i % 9 === 0){
          cur.innerHTML = "<span>t"+i+"</span><span>u"+(i^1)+"</span>";
        }
        // read forcing layout
        const h = root.offsetHeight;
        if (lastH !== -1 && h <= 0){
          anom++; rc("LAYOUT1_HEIGHT_BAD", `i=${i} h=${h}`); break;
        }
        lastH = h;
        // random sibling insert/remove
        if (i % 7 === 0){
          const s = document.createElement("div");
          s.textContent = "s"+i;
          root.insertBefore(s, root.firstChild);
          if (root.childNodes.length > 30) root.removeChild(root.firstChild);
        }
      }catch(e){
        throws++;
        rc("LAYOUT1_THROW", `i=${i} name=${e.name||'err'}`);
      }
      await capYield(mode);
    }

    try{ root.remove(); }catch(_){}

    log(`[OK] anom=${anom} throws=${throws}`);
    return (anom === 0 && throws === 0);
  }

  // MEDIA1: bounded teardown; invariants around event ordering & no stuck state
  async function MEDIA1(mode, seed){
    const caps = CAPS[mode];
    const ops = caps.mediaOps;
    let throws = 0, skips = 0;

    // Use a tiny silent audio via AudioContext if present; fallback to <video> element teardown without src.
    const hasAC = (typeof AudioContext !== "undefined") || (typeof webkitAudioContext !== "undefined");

    for (let i=0;i<ops;i++){
      try{
        if (hasAC){
          const AC = AudioContext || webkitAudioContext;
          const ctx = new AC();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          gain.gain.value = 0.0;
          osc.connect(gain); gain.connect(ctx.destination);
          osc.start();
          // rapid close
          if (ctx.close) await ctx.close();
        }else{
          skips++;
          const v = document.createElement("video");
          v.preload = "none";
          document.body.appendChild(v);
          v.load();
          v.src = "";
          v.remove();
        }
      }catch(e){
        throws++;
        rc("MEDIA1_THROW", `i=${i} name=${e.name||'err'}`);
      }
      await capYield(mode);
    }

    log(`[OK] ops=${ops} skips=${skips} throws=${throws}`);
    return (throws === 0);
  }

  const TESTS = {
    "NAV1": NAV1,
    "NAV2": NAV2,
    "STYLE1": STYLE1,
    "LAYOUT1": LAYOUT1,
    "MEDIA1": MEDIA1
  };

})();
</script>
</body>
</html>
