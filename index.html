<!DOCTYPE html>
<html>
<head>
    <title>Memory Layout Fingerprinter</title>
    <style>
        body { background-color: #0d1117; color: #c9d1d9; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #30363d; padding: 10px; height: 400px; overflow-y: auto; background: #010409; }
        .highlight { color: #58a6ff; font-weight: bold; }
        .warn { color: #d29922; }
    </style>
</head>
<body>
    <h2>Memory Layout Fingerprinter</h2>
    <p>Analisando limites de alocação para inferir Heap Layout.</p>
    <button onclick="startFingerprint()" style="padding:15px; font-size:18px; cursor:pointer;">INICIAR ANÁLISE</button>
    <div id="log"></div>

    <script>
        function log(msg, type='') {
            const el = document.getElementById('log');
            el.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startFingerprint() {
            log("Iniciando Mapeamento de Limites...", 'highlight');
            
            // TESTE 1: Limite de ArrayBuffer (Large Heap)
            // Tenta achar o maior bloco contíguo permitido.
            let size = 1024 * 1024 * 10; // Começa com 10MB
            let maxBuffer = 0;
            
            log("--- Teste 1: Limite de ArrayBuffer ---");
            while(true) {
                try {
                    let ab = new ArrayBuffer(size);
                    maxBuffer = size;
                    size += 1024 * 1024 * 10; // +10MB
                    // Limpa para não dar OOM falso
                    ab = null; 
                    if (size > 1024 * 1024 * 2048) break; // Limite segurança 2GB
                } catch(e) {
                    break;
                }
                await new Promise(r => setTimeout(r, 10));
            }
            log(`Maior ArrayBuffer único permitido: ${(maxBuffer / 1024 / 1024).toFixed(2)} MB`, 'highlight');

            // TESTE 2: Densidade de Alocação (Fragmentação)
            // Tenta alocar muitos pequenos buffers para ver se o sistema prefere
            // juntá-los ou espalhá-los (IsoHeap Check).
            log("--- Teste 2: Densidade (IsoHeap Behavior) ---");
            let smallBuffers = [];
            let t0 = performance.now();
            try {
                for(let i=0; i<50000; i++) {
                    smallBuffers.push(new Uint8Array(128));
                }
            } catch(e) {}
            let t1 = performance.now();
            log(`Tempo para 50k alocações pequenas: ${(t1-t0).toFixed(2)}ms`);
            
            if (t1-t0 < 100) {
                log(">> ALOCAÇÃO RÁPIDA: Indica fastMalloc/BumpPointer (Bom para exploração)", 'highlight');
            } else {
                log(">> ALOCAÇÃO LENTA: Indica Allocator complexo/Seguro (Difícil exploração)", 'warn');
            }

            // TESTE 3: Detecção de Compressão de Ponteiros (Inferência)
            // Aloca um array gigante de objetos. Se estourar a memória rápido,
            // os ponteiros são 64-bit. Se demorar, são 32-bit (Comprimidos).
            log("--- Teste 3: Pointer Compression Check ---");
            let ptrArr = [];
            let count = 0;
            try {
                // Tenta alocar 5 milhões de referências
                for(let i=0; i<5000000; i++) {
                    ptrArr.push({});
                    count++;
                }
                log("Conseguiu alocar 5M objetos sem crash.");
                log(">> Provavelmente POINTER COMPRESSION ATIVO (32-bit Offsets)", 'highlight');
            } catch(e) {
                log(`Crashou/OOM em ${count} objetos.`);
                log(">> Provavelmente 64-BIT POINTERS (Sem compressão)", 'warn');
            }

            log("--- FIM DA ANÁLISE ---");
        }
    </script>
</body>
</html>
