<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit Fuzzer v1.0</title>
</head>
<body>

<h2>PS4 WebKit Fuzzer v1.0</h2>
<p>Fuzzing automatico de APIs vulneraveis do WebKit PS4 v12.00</p>

<h3>Configuracao</h3>
<label>Iteracoes por teste: <input type="number" id="iterations" value="1000"></label><br>
<label>Delay entre testes (ms): <input type="number" id="delay" value="10"></label><br>
<label>Auto-save crashes: <input type="checkbox" id="autosave" checked></label><br>

<h3>Alvos de Fuzzing</h3>
<button onclick="fuzzHistory()">Fuzz: History API</button>
<button onclick="fuzzTypedArrays()">Fuzz: TypedArrays</button>
<button onclick="fuzzCanvas()">Fuzz: Canvas/WebGL</button><br>
<button onclick="fuzzIndexedDB()">Fuzz: IndexedDB</button>
<button onclick="fuzzWebWorkers()">Fuzz: Web Workers</button>
<button onclick="fuzzPromises()">Fuzz: Promises/Async</button><br>
<button onclick="fuzzJIT()">Fuzz: JIT Compiler</button>
<button onclick="fuzzDOM()">Fuzz: DOM Manipulation</button>
<button onclick="fuzzAll()">FUZZ ALL (Modo Agressivo)</button><br>

<h3>Controles</h3>
<button onclick="stopFuzzing()">Parar Fuzzing</button>
<button onclick="clearLog()">Limpar Log</button>
<button onclick="exportCrashes()">Exportar Crashes</button>

<h3>Status</h3>
<div id="status">
  Iteracoes: <span id="iter">0</span> | 
  Crashes: <span id="crashes">0</span> | 
  Exceptions: <span id="exceptions">0</span> | 
  Estado: <span id="state">Aguardando</span>
</div>

<h3>Log de Crashes</h3>
<pre id="log" style="height:400px; overflow-y:scroll; background:#000; color:#0f0; padding:10px;"></pre>

<script>
let running = false;
let iterCount = 0;
let crashCount = 0;
let exceptionCount = 0;
let crashLog = [];

const logEl = document.getElementById("log");
const statusEl = document.getElementById("state");

function log(msg, type = "info") {
    const timestamp = new Date().toISOString();
    const prefix = {
        "info": "[INFO]",
        "crash": "[CRASH]",
        "exception": "[EXCEPTION]",
        "success": "[SUCCESS]"
    }[type] || "[INFO]";
    
    const line = `[${timestamp}] ${prefix} ${msg}\n`;
    logEl.textContent += line;
    logEl.scrollTop = logEl.scrollHeight;
    
    if (type === "crash") {
        crashLog.push({timestamp, msg});
        document.getElementById("crashes").textContent = crashCount;
    }
}

function updateStatus(state) {
    statusEl.textContent = state;
}

function updateCounters() {
    document.getElementById("iter").textContent = iterCount;
    document.getElementById("crashes").textContent = crashCount;
    document.getElementById("exceptions").textContent = exceptionCount;
}

function clearLog() {
    logEl.textContent = "";
    iterCount = 0;
    crashCount = 0;
    exceptionCount = 0;
    crashLog = [];
    updateCounters();
}

function stopFuzzing() {
    running = false;
    updateStatus("Parado");
    log("Fuzzing interrompido pelo usuario");
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// ============================================
// GERADORES DE DADOS ALEATÓRIOS
// ============================================

function randomInt(min = 0, max = 0xFFFFFFFF) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomString(maxLen = 1000) {
    const len = randomInt(0, maxLen);
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:',.<>?/`~";
    let result = "";
    for (let i = 0; i < len; i++) {
        result += chars[randomInt(0, chars.length - 1)];
    }
    return result;
}

function randomBytes(len) {
    const arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        arr[i] = randomInt(0, 255);
    }
    return arr;
}

function randomURL() {
    const schemes = ["#", "http://", "https://", "file://", "data:", "javascript:", "blob:"];
    const scheme = schemes[randomInt(0, schemes.length - 1)];
    return scheme + randomString(randomInt(10, 10000));
}

function randomObject(depth = 0) {
    if (depth > 5) return null;
    
    const types = [
        () => randomInt(),
        () => randomString(),
        () => null,
        () => undefined,
        () => true,
        () => false,
        () => new Array(randomInt(0, 100)),
        () => randomBytes(randomInt(0, 1000)),
        () => ({a: randomObject(depth + 1), b: randomObject(depth + 1)})
    ];
    
    return types[randomInt(0, types.length - 1)]();
}

// ============================================
// FUZZER 1: HISTORY API
// ============================================
async function fuzzHistory() {
    running = true;
    updateStatus("Fuzzing History API");
    log("Iniciando fuzzing de History API...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    const mutations = [
        // Tamanhos extremos
        () => history.pushState({}, "", randomURL()),
        () => history.replaceState({}, "", randomURL()),
        
        // Objetos malformados
        () => history.pushState(randomObject(), randomString(), randomURL()),
        () => history.replaceState(null, null, null),
        
        // Loops aninhados
        () => {
            for (let i = 0; i < randomInt(1, 100); i++) {
                history.pushState({}, "", "#" + i);
            }
        },
        
        // Race conditions
        () => {
            setTimeout(() => history.back(), 0);
            setTimeout(() => history.forward(), 0);
            history.pushState({}, "", randomURL());
        },
        
        // Payloads gigantes
        () => history.pushState({}, "", "#" + "A".repeat(randomInt(1000000, 10000000))),
        
        // Caracteres especiais
        () => history.pushState({}, "", "#\x00\x01\xFF\xFE" + String.fromCharCode(randomInt(0, 0xFFFF))),
        
        // URLs malformadas
        () => history.pushState({}, "", "javascript:alert(1)" + randomString()),
        () => history.pushState({}, "", "data:text/html," + randomString()),
    ];
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const mutation = mutations[randomInt(0, mutations.length - 1)];
            mutation();
            
            if (i % 100 === 0) {
                log(`History fuzzing: ${i}/${iterations} iteracoes`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH em iteracao ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`History fuzzing completo: ${iterations} iteracoes, ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 2: TYPED ARRAYS
// ============================================
async function fuzzTypedArrays() {
    running = true;
    updateStatus("Fuzzing TypedArrays");
    log("Iniciando fuzzing de TypedArrays...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    const arrayTypes = [
        Int8Array, Uint8Array, Uint8ClampedArray,
        Int16Array, Uint16Array,
        Int32Array, Uint32Array,
        Float32Array, Float64Array
    ];
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const ArrayType = arrayTypes[randomInt(0, arrayTypes.length - 1)];
            const size = randomInt(0, 0xFFFFFFFF);
            
            // Mutações
            const mutations = [
                () => new ArrayType(size),
                () => {
                    const arr = new ArrayType(10);
                    arr[randomInt(-1000, 1000)] = randomInt();
                },
                () => {
                    const arr = new ArrayType(10);
                    arr.length = randomInt(0, 0xFFFFFFFF);
                },
                () => {
                    const arr = new ArrayType(10);
                    Object.defineProperty(arr, 'length', {value: randomInt()});
                },
                () => {
                    const arr1 = new ArrayType(10);
                    const arr2 = new ArrayType(arr1.buffer);
                    arr1[0] = randomInt();
                },
            ];
            
            const mutation = mutations[randomInt(0, mutations.length - 1)];
            mutation();
            
            if (i % 100 === 0) {
                log(`TypedArray fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH TypedArray ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`TypedArray fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 3: CANVAS/WEBGL
// ============================================
async function fuzzCanvas() {
    running = true;
    updateStatus("Fuzzing Canvas/WebGL");
    log("Iniciando fuzzing de Canvas...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const canvas = document.createElement('canvas');
            canvas.width = randomInt(1, 10000);
            canvas.height = randomInt(1, 10000);
            
            const mutations = [
                () => {
                    const ctx = canvas.getContext('2d');
                    ctx.fillRect(randomInt(), randomInt(), randomInt(), randomInt());
                },
                () => {
                    const ctx = canvas.getContext('2d');
                    const imgData = ctx.createImageData(randomInt(1, 10000), randomInt(1, 10000));
                    ctx.putImageData(imgData, randomInt(), randomInt());
                },
                () => {
                    const gl = canvas.getContext('webgl');
                    if (gl) {
                        const buffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        gl.bufferData(gl.ARRAY_BUFFER, randomBytes(randomInt(1000, 1000000)), gl.STATIC_DRAW);
                    }
                },
                () => {
                    canvas.toDataURL('image/png');
                },
                () => {
                    canvas.toBlob(blob => {});
                },
            ];
            
            const mutation = mutations[randomInt(0, mutations.length - 1)];
            mutation();
            
            if (i % 50 === 0) {
                log(`Canvas fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH Canvas ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`Canvas fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 4: INDEXEDDB
// ============================================
async function fuzzIndexedDB() {
    running = true;
    updateStatus("Fuzzing IndexedDB");
    log("Iniciando fuzzing de IndexedDB...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const dbName = "fuzz_" + randomString(20);
            const request = indexedDB.open(dbName, randomInt(1, 100));
            
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                const storeName = randomString(20);
                
                try {
                    const store = db.createObjectStore(storeName, {keyPath: randomString(10)});
                    store.createIndex(randomString(10), randomString(10));
                } catch (e) {
                    exceptionCount++;
                }
            };
            
            request.onsuccess = (e) => {
                const db = e.target.result;
                
                try {
                    const tx = db.transaction([Object.keys(db.objectStoreNames)[0] || "default"], "readwrite");
                    const store = tx.objectStore(Object.keys(db.objectStoreNames)[0] || "default");
                    
                    store.put(randomObject());
                    store.get(randomInt());
                    store.delete(randomInt());
                } catch (e) {
                    exceptionCount++;
                }
                
                db.close();
            };
            
            if (i % 50 === 0) {
                log(`IndexedDB fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH IndexedDB ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`IndexedDB fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 5: WEB WORKERS
// ============================================
async function fuzzWebWorkers() {
    running = true;
    updateStatus("Fuzzing Web Workers");
    log("Iniciando fuzzing de Web Workers...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const workerCode = `
                onmessage = function(e) {
                    ${randomString(100)}
                    postMessage(${randomInt()});
                }
            `;
            
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const workerURL = URL.createObjectURL(blob);
            const worker = new Worker(workerURL);
            
            worker.postMessage(randomObject());
            
            setTimeout(() => worker.terminate(), 100);
            
            if (i % 50 === 0) {
                log(`Web Worker fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH Worker ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`Web Worker fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 6: PROMISES/ASYNC
// ============================================
async function fuzzPromises() {
    running = true;
    updateStatus("Fuzzing Promises");
    log("Iniciando fuzzing de Promises...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const mutations = [
                () => {
                    new Promise((resolve, reject) => {
                        setTimeout(() => resolve(randomObject()), randomInt(0, 10));
                    }).then(() => {
                        throw new Error(randomString());
                    });
                },
                () => {
                    Promise.race([
                        new Promise(r => setTimeout(r, randomInt(0, 100))),
                        new Promise((r, rej) => rej(randomObject()))
                    ]);
                },
                () => {
                    Promise.all(new Array(randomInt(1, 100)).fill(0).map(() => 
                        new Promise(r => r(randomInt()))
                    ));
                },
            ];
            
            const mutation = mutations[randomInt(0, mutations.length - 1)];
            mutation();
            
            if (i % 100 === 0) {
                log(`Promise fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH Promise ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`Promise fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 7: JIT COMPILER
// ============================================
async function fuzzJIT() {
    running = true;
    updateStatus("Fuzzing JIT");
    log("Iniciando fuzzing de JIT Compiler...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            // Forçar JIT compilation
            const hotFunc = new Function(`
                let x = ${randomInt()};
                for (let i = 0; i < 100; i++) {
                    x += ${randomInt()};
                    x *= ${randomInt()};
                    x = x | ${randomInt()};
                }
                return x;
            `);
            
            for (let j = 0; j < 1000; j++) {
                hotFunc();
            }
            
            if (i % 10 === 0) {
                log(`JIT fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH JIT ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`JIT fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER 8: DOM MANIPULATION
// ============================================
async function fuzzDOM() {
    running = true;
    updateStatus("Fuzzing DOM");
    log("Iniciando fuzzing de DOM...", "info");
    
    const iterations = parseInt(document.getElementById("iterations").value);
    const delay = parseInt(document.getElementById("delay").value);
    
    for (let i = 0; i < iterations && running; i++) {
        iterCount++;
        
        try {
            const mutations = [
                () => {
                    const el = document.createElement(randomString(10));
                    el.innerHTML = randomString(1000);
                    document.body.appendChild(el);
                },
                () => {
                    const el = document.createElement('div');
                    el.setAttribute(randomString(20), randomString(100));
                },
                () => {
                    const range = document.createRange();
                    range.setStart(document.body, randomInt(0, 10));
                    range.setEnd(document.body, randomInt(0, 10));
                },
                () => {
                    document.body.style.cssText = randomString(500);
                },
            ];
            
            const mutation = mutations[randomInt(0, mutations.length - 1)];
            mutation();
            
            if (i % 100 === 0) {
                log(`DOM fuzzing: ${i}/${iterations}`);
                updateCounters();
            }
            
        } catch (e) {
            exceptionCount++;
            crashCount++;
            log(`CRASH DOM ${i}: ${e.name} - ${e.message}`, "crash");
            updateCounters();
        }
        
        await sleep(delay);
    }
    
    updateStatus("Concluido");
    log(`DOM fuzzing completo: ${crashCount} crashes`, "success");
}

// ============================================
// FUZZER: ALL
// ============================================
async function fuzzAll() {
    log("=== MODO AGRESSIVO: FUZZ ALL ===", "info");
    log("AVISO: Pode travar o navegador!", "crash");
    
    if (!confirm("Modo agressivo pode travar o PS4!\nContinuar?")) {
        return;
    }
    
    running = true;
    const fuzzers = [
        fuzzHistory, fuzzTypedArrays, fuzzCanvas,
        fuzzIndexedDB, fuzzWebWorkers, fuzzPromises,
        fuzzJIT, fuzzDOM
    ];
    
    for (const fuzzer of fuzzers) {
        if (!running) break;
        await fuzzer();
        await sleep(2000);
    }
    
    log("=== FUZZ ALL COMPLETO ===", "success");
}

// ============================================
// EXPORT
// ============================================
function exportCrashes() {
    if (crashLog.length === 0) {
        alert("Nenhum crash para exportar");
        return;
    }
    
    const json = JSON.stringify(crashLog, null, 2);
    const blob = new Blob([json], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ps4_webkit_crashes_' + Date.now() + '.json';
    a.click();
    
    log(`Exportados ${crashLog.length} crashes`, "success");
}

// ============================================
// INIT
// ============================================
log("PS4 WebKit Fuzzer v1.0 carregado");
log("Selecione um fuzzer para iniciar");
updateStatus("Pronto");
</script>

</body>
</html>
