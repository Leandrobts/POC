<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - JIT Type Confusion Hunt</title>
</head>
<body>
<h2>PS4 12.00 - Searching for JIT Type Confusion</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="testJITIntOverflow()">JIT TEST 1 - Integer Overflow</button>
<button onclick="testJITArrayTransition()">JIT TEST 2 - Array Type Transition</button>
<button onclick="testJITPolymorphic()">JIT TEST 3 - Polymorphic Confusion</button>
<button onclick="testJITBailout()">JIT TEST 4 - Bailout Bypass</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Force JIT compilation
function forceJIT(func, iterations = 10000) {
  for(let i=0; i<iterations; i++) {
    func(i);
  }
}

// =====================================================
// JIT TEST 1 - Integer Overflow in Optimized Code
// =====================================================
function testJITIntOverflow(){
  logEl.textContent = "";
  statusEl.textContent = "Testing JIT Int Overflow...";
  
  log("=== JIT TEST 1: Integer Overflow ===\n");
  log("Goal: Trigger integer overflow in JIT-compiled code\n");
  
  // Setup pollution
  Array.prototype.magicLength = 0x7FFFFFFF;
  
  log("[SETUP] Function to be JIT compiled:");
  
  // This will be JIT compiled
  function vulnerableLoop(arr) {
    let sum = 0;
    
    // JIT assumes arr.length is small
    for(let i=0; i<arr.length; i++) {
      sum += arr[i] | 0;
    }
    
    return sum;
  }
  
  log("  Created vulnerableLoop function\n");
  
  // Force JIT compilation with small arrays
  log("[PHASE 1] Training JIT with small arrays (10k iterations)");
  
  let trainingArray = [1, 2, 3, 4, 5];
  forceJIT(vulnerableLoop.bind(null, trainingArray));
  
  log("  JIT training complete\n");
  
  // Now use array with polluted length
  log("[PHASE 2] Calling with polluted array");
  
  let victimArray = [10, 20, 30, 40];
  
  log(`  Real length: ${victimArray.length}`);
  log(`  Magic length: ${victimArray.magicLength}`);
  
  try {
    // If JIT uses magicLength, this could overflow
    let result = vulnerableLoop(victimArray);
    
    log(`\n  Result: ${result}`);
    log("  Expected: 100 (10+20+30+40)");
    
    if(result !== 100) {
      log("\nðŸš¨ ANOMALY DETECTED!");
      log(`Unexpected result: ${result}`);
      log("JIT may be using polluted length!");
      statusEl.textContent = "ANOMALY FOUND";
    } else {
      log("\nâœ“ Result correct (JIT bounds check working)");
    }
    
  } catch(e) {
    log(`\nException: ${e.message}`);
    log("This might indicate JIT bailout or crash prevention");
  }
  
  delete Array.prototype.magicLength;
  
  log("\n=== JIT TEST 1 END ===");
}

// =====================================================
// JIT TEST 2 - Array Type Transition
// =====================================================
function testJITArrayTransition(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Array Transition...";
  
  log("=== JIT TEST 2: Array Type Transition ===\n");
  log("Goal: Confuse JIT with array structure changes\n");
  
  // Pollution
  Array.prototype.fakeStructure = 0x41414141;
  
  log("[SETUP] JIT-compiled array access function:");
  
  function accessArray(arr, index) {
    return arr[index];
  }
  
  log("  Created accessArray function\n");
  
  // Train JIT with int arrays
  log("[PHASE 1] Training with integer arrays");
  
  let intArray = [1, 2, 3, 4, 5];
  forceJIT(accessArray.bind(null, intArray, 2));
  
  log("  JIT compiled for int arrays\n");
  
  // Transition to double array
  log("[PHASE 2] Forcing array transition");
  
  let transitionArray = [1, 2, 3, 4, 5];
  transitionArray[0] = 1.1; // Force transition to double
  
  log(`  Array transitioned to double storage\n`);
  
  // Access with JIT-compiled code
  log("[PHASE 3] Accessing transitioned array");
  
  try {
    let val = accessArray(transitionArray, 10); // OOB
    
    log(`  arr[10] = ${val}`);
    
    if(val !== undefined) {
      log("\nðŸš¨ OOB READ DETECTED!");
      log(`Read value beyond bounds: ${val}`);
      
      if(typeof val === 'number') {
        log(`  As hex: 0x${val.toString(16)}`);
      }
      
      statusEl.textContent = "OOB READ FOUND";
    } else {
      log("\nâœ“ Bounds check still working");
    }
    
  } catch(e) {
    log(`\nException: ${e.message}`);
  }
  
  delete Array.prototype.fakeStructure;
  
  log("\n=== JIT TEST 2 END ===");
}

// =====================================================
// JIT TEST 3 - Polymorphic Inline Cache Confusion
// =====================================================
function testJITPolymorphic(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Polymorphic IC...";
  
  log("=== JIT TEST 3: Polymorphic Confusion ===\n");
  log("Goal: Confuse polymorphic inline cache\n");
  
  // Pollution
  Object.prototype.hiddenClass = 0xDEADBEEF;
  
  log("[SETUP] Polymorphic function:");
  
  function processObject(obj) {
    return obj.value * 2;
  }
  
  // Train with multiple object shapes
  log("[PHASE 1] Training with multiple shapes");
  
  class ShapeA { constructor(v) { this.value = v; } }
  class ShapeB { constructor(v) { this.value = v; this.extra = 0; } }
  class ShapeC { constructor(v) { this.value = v; this.other = 1; } }
  
  for(let i=0; i<3000; i++) {
    processObject(new ShapeA(i));
    processObject(new ShapeB(i));
    processObject(new ShapeC(i));
  }
  
  log("  Polymorphic IC trained\n");
  
  // Create object with polluted prototype
  log("[PHASE 2] Using polluted object");
  
  let victim = { value: 100 };
  
  log(`  victim.value: ${victim.value}`);
  log(`  victim.hiddenClass: 0x${victim.hiddenClass.toString(16)}`);
  
  try {
    let result = processObject(victim);
    
    log(`\n  Result: ${result}`);
    log(`  Expected: 200`);
    
    // Check if pollution affected execution
    if(result !== 200 && !isNaN(result)) {
      log("\nðŸš¨ POLYMORPHIC CONFUSION!");
      log(`Unexpected result: ${result}`);
      statusEl.textContent = "IC CONFUSION FOUND";
    }
    
  } catch(e) {
    log(`\nException: ${e.message}`);
  }
  
  delete Object.prototype.hiddenClass;
  
  log("\n=== JIT TEST 3 END ===");
}

// =====================================================
// JIT TEST 4 - Bailout Bypass
// =====================================================
function testJITBailout(){
  logEl.textContent = "";
  statusEl.textContent = "Testing Bailout Bypass...";
  
  log("=== JIT TEST 4: Bailout Bypass ===\n");
  log("Goal: Prevent JIT bailout with pollution\n");
  
  // Pollution to bypass checks
  Array.prototype.isArray = true;
  Array.prototype.constructor = Array;
  
  log("[SETUP] Function with type checks:");
  
  function typeConfused(input) {
    // JIT assumes this always gets real arrays
    if(Array.isArray(input)) {
      let sum = 0;
      for(let i=0; i<input.length; i++) {
        sum += input[i];
      }
      return sum;
    }
    return 0;
  }
  
  // Train with real arrays
  log("[PHASE 1] Training with real arrays");
  
  for(let i=0; i<10000; i++) {
    typeConfused([1, 2, 3, 4, 5]);
  }
  
  log("  JIT compiled\n");
  
  // Try with fake array (object pretending to be array)
  log("[PHASE 2] Using fake array object");
  
  let fakeArray = {
    0: 10,
    1: 20,
    2: 30,
    length: 3
  };
  
  // Make it pass Array.isArray via pollution
  fakeArray.__proto__ = Array.prototype;
  
  log(`  fakeArray.isArray: ${Array.isArray(fakeArray)}`);
  log(`  fakeArray.length: ${fakeArray.length}`);
  
  try {
    let result = typeConfused(fakeArray);
    
    log(`\n  Result: ${result}`);
    log(`  Expected: 60 (10+20+30)`);
    
    if(result === 60) {
      log("\nâœ“ JIT accepted fake array!");
      log("But no type confusion (correct result)");
    } else if(result !== 0) {
      log("\nðŸš¨ TYPE CONFUSION!");
      log(`Unexpected result: ${result}`);
      statusEl.textContent = "BAILOUT BYPASSED";
    }
    
  } catch(e) {
    log(`\nException: ${e.message}`);
  }
  
  delete Array.prototype.isArray;
  delete Array.prototype.constructor;
  
  log("\n=== JIT TEST 4 END ===");
}

log("PS4 12.00 - JIT Type Confusion Hunt");
log("\nStrategy: Use confirmed pollution to confuse JIT");
log("\nTests:");
log("1. Integer Overflow - JIT with polluted length");
log("2. Array Transition - Structure change confusion");
log("3. Polymorphic IC - Inline cache confusion");
log("4. Bailout Bypass - Prevent deoptimization");
log("\nLooking for:");
log("- Anomalous results (wrong calculations)");
log("- OOB access (read beyond bounds)");
log("- Type confusion (wrong type handling)");
log("- Crashes (optimization gone wrong)");
</script>
</body>
</html>
