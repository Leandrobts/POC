<!doctype html>
<meta charset="utf-8">
<title>PS4 WebKit - RenderLayer recompute stress (no spray)</title>

<button id="run">RUN 80x</button>
<button id="stop">STOP</button>
<button id="clear">CLEAR LOG</button>
<pre id="log" style="height:260px;overflow:auto;border:1px solid #ccc;padding:8px;"></pre>

<div id="viewport" style="position:relative;width:95vw;height:62vh;border:2px solid #444;overflow:hidden;">
  <div id="spacer" style="height:140vh;"></div>
  <div id="root"></div>
</div>

<script>
const logEl = document.getElementById('log');
function log(s){ logEl.textContent += `[${new Date().toLocaleTimeString()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; }

const viewport = document.getElementById('viewport');
const root = document.getElementById('root');

let stop = false;

function setCV(el, v){
  el.style.contentVisibility = v;
  el.style.webkitContentVisibility = v;
}

function forceReflow(){
  void viewport.offsetHeight;
  void root.offsetHeight;
  void document.body.offsetHeight;
}

function raf(){ return new Promise(r => requestAnimationFrame(() => r())); }

function buildTree(iter){
  root.textContent = "";

  // 2 níveis ancestrais + overflow/contain
  const A = document.createElement('div');
  A.id = 'A';
  A.style.position = 'relative';
  A.style.width = '110%';
  A.style.height = '70vh';
  A.style.left = '-5%';
  A.style.overflow = (iter % 2) ? 'hidden' : 'clip';
  A.style.border = '1px solid #999';
  A.style.transform = 'translateZ(0)';

  const B = document.createElement('div');
  B.id = 'B';
  B.style.position = 'relative';
  B.style.width = '100%';
  B.style.height = '100%';
  B.style.overflow = (iter % 3) ? 'hidden' : 'clip';
  B.style.transform = 'translateZ(0)';
  B.style.contain = (iter % 2) ? 'layout paint' : 'paint';

  // camada “azul” + stacks
  const blue = document.createElement('div');
  blue.id = 'blue';
  blue.style.width = '140px';
  blue.style.height = '140px';
  blue.style.background = '#09f';
  blue.style.left = (iter % 2) ? '84%' : '-30px';   // força truncation/overflow
  blue.style.top  = (iter % 2) ? '68%' : '20px';

  // alterna fixed/absolute para mexer em stacking/containing blocks
  blue.style.position = (iter % 4 === 0) ? 'fixed' : 'absolute';
  blue.style.zIndex = '9999';
  blue.style.transform = 'translateZ(0)';

  // filter costuma empurrar para compositing
  blue.style.filter = (iter % 3 === 0) ? 'blur(0.2px)' : 'none';
  blue.style.willChange = 'transform, filter, opacity';

  // cria mais elementos para z-order lists
  for (let i = 0; i < 18; i++){
    const d = document.createElement('div');
    d.style.position = 'absolute';
    d.style.width = (40 + (i % 5) * 20) + 'px';
    d.style.height = (40 + (i % 7) * 15) + 'px';
    d.style.left = (10 + (i * 12)) + 'px';
    d.style.top = (10 + (i * 7)) + 'px';
    d.style.background = (i % 2) ? '#ddd' : '#bbb';
    d.style.zIndex = String(10 + i);
    d.style.opacity = (i % 5 === 0) ? '0.98' : '1';
    if (i % 6 === 0) d.style.transform = 'translateZ(0)';
    B.appendChild(d);
  }

  B.appendChild(blue);
  A.appendChild(B);
  root.appendChild(A);

  return { A, B, blue };
}

async function oneIter(iter){
  const { A, B, blue } = buildTree(iter);
  forceReflow();

  // fase 1: content-visibility hidden no ancestral
  log(`iter ${iter}: CV=hidden on A`);
  setCV(A, 'hidden');
  await raf();
  forceReflow();

  // fase 2: remove subtree interno (teardown mais agressivo)
  log(`iter ${iter}: remove BLUE then detach B`);
  blue.remove();
  await raf();
  B.remove();     // remove o container do meio
  forceReflow();

  // fase 3: reattach (simula churn de layer tree)
  log(`iter ${iter}: reattach new B + CV=auto`);
  const newB = document.createElement('div');
  newB.style.position = 'relative';
  newB.style.width = '100%';
  newB.style.height = '100%';
  newB.style.overflow = (iter % 3) ? 'hidden' : 'clip';
  newB.style.transform = 'translateZ(0)';
  newB.style.contain = (iter % 2) ? 'layout paint' : 'paint';

  // recoloca um "blue" novo para mudar topology de layers
  const blue2 = document.createElement('div');
  blue2.style.width = '140px';
  blue2.style.height = '140px';
  blue2.style.background = '#09f';
  blue2.style.position = (iter % 4 === 1) ? 'fixed' : 'absolute';
  blue2.style.left = (iter % 2) ? '80%' : '-25px';
  blue2.style.top  = (iter % 2) ? '66%' : '25px';
  blue2.style.zIndex = '9999';
  blue2.style.transform = 'translateZ(0)';
  blue2.style.filter = (iter % 3 === 1) ? 'blur(0.2px)' : 'none';
  newB.appendChild(blue2);

  A.appendChild(newB);

  // volta CV para auto e força recompute em duas frames
  setCV(A, 'auto');
  await raf();
  await raf();
  forceReflow();

  // fase 4: “scroll pulse” e resize-pulse do viewport
  // (mexe em layout + compositing sem ser pesado)
  viewport.scrollTop = (iter % 2) ? 30 : 0;
  viewport.style.width = (iter % 2) ? '94vw' : '95vw';
  await raf();
  forceReflow();

  log(`iter ${iter}: done (children A:${A.childElementCount})`);
}

document.getElementById('run').onclick = async () => {
  stop = false;
  log("UA: " + navigator.userAgent);
  log("Starting 80 iterations...");
  try {
    for (let i = 1; i <= 80; i++){
      if (stop) { log("STOPPED"); break; }
      await oneIter(i);
      // pausa leve para não travar o console
      await new Promise(r => setTimeout(r, 15));
    }
  } catch(e){
    log("JS exception: " + (e && e.message ? e.message : e));
  } finally {
    log("Done.");
  }
};

document.getElementById('stop').onclick = () => { stop = true; };
document.getElementById('clear').onclick = () => { logEl.textContent = ""; };
</script>
