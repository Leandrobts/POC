<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit – Sanity Harness</title>
<style>
  body { font-family: monospace; }
  .ok { color: green; }
  .warn { color: #b58900; }
  .bad { color: red; }
</style>
</head>
<body>

<h2>PS4 WebKit – Sanity Harness</h2>
<button onclick="runAll()">RUN SANITY</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById('log');
function log(msg, cls='') {
  const line = document.createElement('div');
  line.textContent = msg;
  if (cls) line.className = cls;
  logEl.appendChild(line);
}

function section(t){ log('\n=== ' + t + ' ==='); }

function runAll() {
  logEl.textContent = '';
  test_ArrayBufferBounds();
  test_ObjectIsolation();
  test_OOBPrevention();
  test_TypeStability();
  test_FunctionControl();
  test_InfoLeak();
  log('\nSANITY COMPLETE');
}

/* 1) ArrayBuffer bounds */
function test_ArrayBufferBounds() {
  section('ArrayBuffer Bounds');
  const buf = new ArrayBuffer(64);
  const u32 = new Uint32Array(buf);
  let ok = true;

  try {
    u32[0] = 0x11111111;
    u32[15] = 0x22222222;
    if (u32.length !== 16) ok = false;
  } catch(e) { ok = false; }

  log(ok
    ? 'OK: Writes confined to buffer bounds'
    : 'BAD: Unexpected bounds behavior',
    ok ? 'ok' : 'bad'
  );
}

/* 2) Object adjacency isolation */
function test_ObjectIsolation() {
  section('Object Isolation');
  const a = { tag: 'A', arr: new Uint32Array(8) };
  const b = { tag: 'B', arr: new Uint32Array(8) };

  a.arr[0] = 0xAAAA;
  b.arr[0] = 0xBBBB;

  const ok = (a.arr[0] === 0xAAAA && b.arr[0] === 0xBBBB);
  log(ok
    ? 'OK: Adjacent objects isolated'
    : 'CRITICAL: Cross-object corruption',
    ok ? 'ok' : 'bad'
  );
}

/* 3) OOB prevention */
function test_OOBPrevention() {
  section('OOB Prevention');
  const buf = new ArrayBuffer(32);
  const u32 = new Uint32Array(buf);
  let blocked = false;

  try {
    u32[100] = 0xDEADBEEF;
  } catch(e) {
    blocked = true;
  }

  log(blocked
    ? 'OK: OOB write blocked'
    : 'WARN: OOB index ignored (JS semantics), no native write',
    blocked ? 'ok' : 'warn'
  );
}

/* 4) Type stability */
function test_TypeStability() {
  section('Type Stability');
  const n = 13.37;
  const a = [1,2,3];
  const ok =
    (typeof n === 'number') &&
    (Array.isArray(a)) &&
    (typeof a.length === 'number');

  log(ok
    ? 'OK: No type confusion observed'
    : 'CRITICAL: Type instability',
    ok ? 'ok' : 'bad'
  );
}

/* 5) Function control */
function test_FunctionControl() {
  section('Function Control');
  function f(){ return 1; }
  const before = f();

  try {
    // Attempt to corrupt via data write (should be impossible)
    const buf = new ArrayBuffer(16);
    new Uint32Array(buf)[0] = 0xDEADBEEF;
  } catch {}

  const after = f();
  const ok = (before === after);

  log(ok
    ? 'OK: No control-flow hijack'
    : 'CRITICAL: Function behavior changed',
    ok ? 'ok' : 'bad'
  );
}

/* 6) Info leak */
function test_InfoLeak() {
  section('Information Leak');
  let leaked = false;

  try {
    throw new Error('test');
  } catch(e) {
    if (e.stack && /0x[0-9a-fA-F]{8,}/.test(e.stack)) {
      leaked = true;
    }
  }

  log(!leaked
    ? 'OK: No address leak detected'
    : 'CRITICAL: Address disclosure',
    !leaked ? 'ok' : 'bad'
  );
}
</script>
</body>
</html>

