<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Libc String Fuzzer</title>
    <style>
        body { background-color: #100000; color: #ff4444; font-family: monospace; padding: 20px; }
        button { 
            background: #330000; color: #ff4444; border: 2px solid #ff4444; 
            padding: 15px; width: 100%; margin-bottom: 10px; 
            font-size: 18px; font-weight: bold; cursor: pointer;
        }
        button:hover { background: #550000; }
        #log { border: 1px solid #ff4444; padding: 10px; height: 250px; overflow-y: scroll; white-space: pre-wrap; }
    </style>
</head>
<body>

    <h1>LIBC STRING & BUFFER ATTACKS</h1>
    <p>Target: mbstowcs_s (Unicode Conv), decodeURI, Intl Segmenter</p>

    <button onclick="runURIBomb()">TEST 1: decodeURIComponent Buffer Overflow</button>
    <button onclick="runSegmenterOOM()">TEST 2: Intl.Segmenter Allocator Panic</button>
    <button onclick="runTypedArrayWrap()">TEST 3: TypedArray Offset Wraparound</button>

    <div id="log">Status: Aguardando testes...</div>

    <script>
        function log(msg) { 
            document.getElementById('log').innerText = `> ${msg}\n` + document.getElementById('log').innerText;
        }

        // --- TESTE 1: decodeURIComponent Buffer Overflow ---
        // Ataca a função 'mbstowcs_s' (Multibyte to Wide Char) encontrada no libc.
        // Tenta decodificar uma string que expande violentamente na memória.
        function runURIBomb() {
            log("Iniciando URI Decode Attack...");
            
            try {
                // Cria uma string gigante de caracteres codificados
                // O navegador precisa alocar um buffer temporário para converter isso.
                // Sequências % repetidas podem confundir o cálculo de tamanho do buffer de destino.
                const part = "%C0%AF".repeat(50000); // Caracteres 'overlong' inválidos
                const hugeURI = part + part + part;
                
                log("Decodificando URI de " + hugeURI.length + " bytes...");
                
                // Se o cálculo de tamanho falhar (Integer Overflow), ele aloca pouco e escreve muito.
                const result = decodeURIComponent(hugeURI);
                
                log("Decode sobreviveu (Length: " + result.length + ")");
            } catch(e) {
                log("Erro URI: " + e.message);
                if (e.message.includes("URI")) {
                    log("Nota: Erro de URI padrão. Procuramos Crash.");
                }
            }
        }

        // --- TESTE 2: Intl.Segmenter Allocator Panic ---
        // A API Intl.Segmenter (nova no Safari 17 base) é complexa.
        // Ela precisa criar um iterador sobre o texto. Vamos tentar forçar o erro "Bad Array New Length".
        function runSegmenterOOM() {
            log("Atacando Intl.Segmenter (Heap Allocation)...");
            
            if (!window.Intl || !Intl.Segmenter) {
                log("Intl.Segmenter não suportado.");
                return;
            }

            try {
                // Cria uma string maciça
                const blob = new Array(1024 * 1024 * 10).join("A "); // 20MB
                
                const segmenter = new Intl.Segmenter("en", {granularity: "word"});
                log("Segmentando string gigante...");
                
                // O iterador pode tentar alocar um array de índices internamente.
                // Se a string for grande demais, o tamanho do array de índices pode estourar 32-bit.
                const segments = segmenter.segment(blob);
                
                // Força a leitura para efetivar a alocação
                let count = 0;
                for (const seg of segments) {
                    count++;
                    if (count > 1000) break; // Só para testar o início
                }
                
                log("Segmentação iniciada sem crash.");
                
            } catch(e) {
                log("Erro Segmenter: " + e.message);
            }
        }

        // --- TESTE 3: TypedArray Offset Wraparound ---
        // Explora o cálculo de ponteiros: (Base + Offset).
        // Se passarmos um offset negativo (que em 32-bit é um número gigante),
        // o cálculo pode "dar a volta" (Wrap Around) e apontar para memória antes do buffer.
        function runTypedArrayWrap() {
            log("Testando TypedArray Offset Wraparound...");
            
            try {
                const buffer = new ArrayBuffer(1024);
                
                // Vetores de ataque para Offset:
                // -1  (0xFFFFFFFF em 32-bit)
                // -4  (Para alinhamento de Int32)
                // MaxSafeInteger
                const offsets = [-1, -4, 4294967292, 2147483644];
                
                offsets.forEach(off => {
                    try {
                        // Tenta criar uma view que aponta para (Buffer + Offset Gigante)
                        // Se o sistema somar sem checar, pode acessar memória proibida.
                        const view = new Uint32Array(buffer, off, 1);
                        log(`ALERTA: View criada com offset ${off}! Leitura OOB possível.`);
                        log("Valor lido: " + view[0]);
                    } catch(e) {
                        // Erro esperado se a proteção funcionar
                    }
                });
                
                log("Teste de Offset finalizado.");
                
            } catch(e) {
                log("Erro Fatal: " + e.message);
            }
        }

    </script>
</body>
</html>
