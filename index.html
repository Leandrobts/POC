<!DOCTYPE html>
<html>
<head>
    <title>PS4 pushState Fuzzer</title>
    <style>
        body { background-color: #111; color: #0f0; font-family: monospace; padding: 20px; font-size: 20px; }
        .box { border: 1px solid #444; padding: 15px; margin-bottom: 10px; }
        button { font-size: 20px; padding: 10px; cursor: pointer; background: #333; color: white; border: 1px solid #fff; }
        #status { color: yellow; }
        .danger { color: red; font-weight: bold; }
    </style>
</head>
<body>

    <h2>PS4 IPC Fuzzer (history.pushState)</h2>

    <div class="box">
        <div>Status: <span id="status">Parado</span></div>
        <div id="log">Aguardando início...</div>
    </div>

    <div class="box">
        <strong>Resultado Anterior (Pós-Crash):</strong><br>
        <span id="last-attempt" class="danger">Nenhum registro.</span>
    </div>

    <br>
    <button onclick="startFuzz()">INICIAR FUZZING</button>
    <button onclick="resetFuzz()">RESETAR CONTADOR</button>
    <button onclick="stopFuzz()">PARAR</button>

    <script>
        // CONFIGURAÇÕES
        const START_SIZE = 1000;      // Tamanho inicial (bytes)
        const STEP_SIZE = 1024;       // Aumenta 1KB por vez (diminua para 100 ou 1 para precisão final)
        const DELAY_MS = 2000;        // Tempo antes de executar (dá tempo de fechar a aba se precisar)

        // Elementos da UI
        const logEl = document.getElementById('log');
        const statusEl = document.getElementById('status');
        const lastEl = document.getElementById('last-attempt');

        // Lê o último registro salvo no HD
        let currentSize = parseInt(localStorage.getItem('fuzz_current_size')) || START_SIZE;
        let lastCrashSize = localStorage.getItem('fuzz_last_attempt');

        // Mostra o registro do provável crash anterior
        if (lastCrashSize) {
            lastEl.innerText = lastCrashSize + " bytes (Este valor causou o crash?)";
        }

        // Verifica se deve continuar rodando automaticamente (auto-resume)
        let isRunning = localStorage.getItem('fuzz_running') === 'true';

        if (isRunning) {
            runIteration();
        }

        function startFuzz() {
            localStorage.setItem('fuzz_running', 'true');
            location.reload(); // Recarrega para iniciar limpo
        }

        function stopFuzz() {
            localStorage.setItem('fuzz_running', 'false');
            statusEl.innerText = "Parado pelo usuário.";
            clearTimeout(window.fuzzTimer);
        }

        function resetFuzz() {
            localStorage.removeItem('fuzz_current_size');
            localStorage.removeItem('fuzz_last_attempt');
            localStorage.removeItem('fuzz_running');
            location.reload();
        }

        function runIteration() {
            statusEl.innerText = "RODANDO...";
            logEl.innerText = "Preparando teste com: " + currentSize + " bytes...";

            // 1. Salva o tamanho ATUAL como "Última tentativa"
            // Se o console morrer agora, sabemos que foi este número.
            localStorage.setItem('fuzz_last_attempt', currentSize);

            // 2. Prepara o PRÓXIMO tamanho para o refresh
            localStorage.setItem('fuzz_current_size', currentSize + STEP_SIZE);

            // 3. Executa o payload
            window.fuzzTimer = setTimeout(() => {
                try {
                    const payload = "/" + "A".repeat(currentSize);
                    
                    logEl.innerText = "Enviando payload (" + currentSize + " bytes)...";
                    
                    // A CHAMADA CRÍTICA
                    history.pushState({}, "fuzz", payload);
                    
                    // Se chegou aqui, não crashou.
                    logEl.innerText = "Sucesso! Recarregando para o próximo...";
                    
                    // Recarrega para limpar memória e ir para o próximo step
                    setTimeout(() => location.reload(), 500);

                } catch (e) {
                    // Erros de JavaScript normais (ex: SecurityError) não são crashes de Kernel
                    logEl.innerText = "Erro JS capturado: " + e.message;
                    // Se der erro de JS, ainda assim tentamos o próximo tamanho?
                    // Geralmente sim, pois queremos achar o estouro de memória, não o limite lógico do JS.
                    setTimeout(() => location.reload(), 1000);
                }
            }, DELAY_MS);
        }
    </script>
</body>
</html>
