<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Memory Debugger V2 (Perfect Match)</title>
<style>
    body { background-color: #000; color: #ff0; font-family: monospace; text-align: center; padding: 20px; }
    button { background: #333; color: white; border: 2px solid #ff0; padding: 20px 40px; font-size: 1.5em; cursor: pointer; margin: 10px; }
    button:hover { background: #555; }
    #log { text-align: left; margin: 20px auto; border: 1px solid #555; padding: 10px; height: 300px; overflow-y: scroll; background: #111; }
</style>
</head>
<body>

<h1>DEBUGGER V2: PERFECT MATCH</h1>
<p>Estratégia: Usar o mesmo tamanho para forçar a reescrita no mesmo endereço.</p>

<button onclick="step1()">1. ALOCAR (BEACON)</button>
<br>
<button onclick="step2()">2. GATILHO (OPTIONS)</button>

<div id="log">Logs...</div>

<script>
    const Log = document.getElementById('log');
    function log(txt) { Log.innerHTML += ">> " + txt + "<br>"; Log.scrollTop = Log.scrollHeight;}

    // VALORES PARA O SCAN (Use Hex no Cheater Neo)
    // Beacon: 1234567890 (Int) -> Hex: D2 02 96 49 (ou 49 96 02 D2)
    // Vamos usar Uint32 para facilitar sua vida no Hex Editor
    const BEACON_VAL = 0xDEADBEEF; // 3735928559
    const POISON_VAL = 0x41414141; // "AAAA"

    let victims = [];
    const COUNT = 20000; // Aumentei a quantidade para criar blocos maiores

    function step1() {
        log("Alocando memória com 0xDEADBEEF...");
        
        // Criamos arrays de Uint32 com tamanho 32
        // Tamanho em bytes: 32 * 4 = 128 bytes.
        for(let i=0; i<COUNT; i++) {
            let v = new Uint32Array(32);
            v.fill(BEACON_VAL);
            victims.push(v);
        }

        log("MEMÓRIA PRONTA!");
        log("------------------------------------------------");
        log("NO PC (Cheater Neo):");
        log("1. Scan Type: 4 Bytes (Hex)");
        log("2. Busque por: DEADBEEF");
        log("3. Abra o Hex Editor em um endereço cheio de DEADBEEF.");
        log("------------------------------------------------");
    }

    function step2() {
        log("Gatilho armado via Fullscreen...");
        
        const doc = document.documentElement;
        if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
        else if (doc.requestFullscreen) doc.requestFullscreen();

        window.onblur = function() {
            log("BLUR! Trocando memória...");
            document.body.style.background = "#500";

            // 1. FREE (Libera os arrays DEADBEEF)
            victims = null;

            // FORÇAR GARBAGE COLLECTION
            // Às vezes a memória não é limpa instantaneamente.
            // Criamos um pouco de pressão para forçar o sistema a limpar.
            let trash = [];
            for(let k=0; k<100; k++) trash.push(new ArrayBuffer(1000));

            // 2. SPRAY (Enche com 41414141)
            // IMPORTANTE: Usamos EXATAMENTE o mesmo tamanho (32) e mesmo tipo.
            let spray = [];
            try {
                // Aumentamos o spray para garantir que preencha tudo
                for(let i=0; i<COUNT + 5000; i++) {
                    let s = new Uint32Array(32); // TAMANHO IDÊNTICO AO VÍTIMA
                    s.fill(POISON_VAL);
                    spray.push(s);
                }
            } catch(e) {}

            log("TROCA FEITA! Dê Refresh no Hex Editor.");
            log("Se DEADBEEF virou 41414141, você tem controle total.");
        };
    }
</script>
</body>
</html>
