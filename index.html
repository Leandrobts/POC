
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v380000: Memory Sieve</title>

</head>
<body>

<h1>v380000: MEMORY SIEVE</h1>

<div class="status">
    ESTRATÉGIA: FRAGMENTAÇÃO DE RAM + SOFTLOCK<br>
    CLIQUE -> FULLSCREEN -> FECHE ALERTA
</div>

<button onclick="sieve(s01)">01. Buffer Sieve (RAM Fragmentation)</button>

<button onclick="sieve(s02)">02. Canvas Sieve (VRAM Fragmentation)</button>

<button onclick="sieve(s03)">03. DOM Sieve (Heap Fragmentation)</button>

<div id="stage">ALVO</div>

<script>
    const Stage = document.getElementById('stage');
    
    // Armazém global para impedir o Garbage Collector de limpar tudo
    const memory = []; 

    // =================================================================
    // EXECUTOR DA PENEIRA
    // =================================================================
    function sieve(vectorFunc) {
        Stage.innerHTML = "";
        memory.length = 0; // Limpa testes anteriores
        
        // 1. Configura o Alvo
        const target = vectorFunc(Stage);
        
        // 2. Fullscreen
        if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
        else if (target.requestFullscreen) target.requestFullscreen();

        // 3. Timing
        requestAnimationFrame(() => {
            setTimeout(() => {
                // ALERTA
                window.alert("⚠️ SIEVE ARMED ⚠️\n\nAo fechar, vamos peneirar a memória RAM.");

                // A. DETONAÇÃO (Visual)
                if(target._detonate) target._detonate();

                // B. LOOP DE FRAGMENTAÇÃO (O ataque)
                if(target._fragment) {
                    function loop() {
                        // Executa a lógica de fragmentação
                        target._fragment();
                        // Mantém o loop vivo em alta frequência
                        requestAnimationFrame(loop);
                    }
                    loop();
                }
                
            }, 50);
        });
    }

    // =================================================================
    // 01. Buffer Sieve (RAM Fragmentation)
    // Cria blocos de 1MB, apaga os pares, tenta encaixar blocos de 1.1MB
    // =================================================================
    function s01(stage) {
        const d = document.createElement('div');
        d.innerText = "RAM SIEVE";
        stage.appendChild(d);

        // FASE 1: PREENCHIMENTO (Fill)
        // Aloca cerca de 200MB de RAM em blocos de 1MB
        const blocks = [];
        const blockSize = 1024 * 256; // 1MB (Uint32 = 4 bytes)
        for(let i=0; i<200; i++) {
            blocks.push(new Uint32Array(blockSize).fill(0xAAAAAAAA));
        }

        d._detonate = () => {
            // FASE 2: PENEIRA (Holes)
            // Remove todos os índices pares
            // Memória fica: [DADO] [LIVRE] [DADO] [LIVRE]...
            for(let i=0; i<blocks.length; i+=2) {
                blocks[i] = null;
            }
            
            // Tela Preta (Nuke)
            document.body.innerHTML = "";
        };

        d._fragment = () => {
            // FASE 3: PRESSÃO (Stress)
            // Tenta alocar blocos levemente MAIORES que os buracos (1.1MB)
            // O Kernel tenta desfragmentar para caber, mas falha porque a CPU está ocupada
            try {
                // Aloca e descarta imediatamente para forçar o Kernel a trabalhar
                const temp = new Uint32Array(blockSize + 1024); 
                temp.fill(0xBBBBBBBB);
            } catch(e) {}
            
            // Loop matemático para manter o Softlock
            Math.sin(Math.random());
        };
        return d;
    }

    // =================================================================
    // 02. Canvas Sieve (VRAM Fragmentation)
    // O mesmo conceito, mas usando Canvas para atacar a memória de vídeo
    // =================================================================
    function s02(stage) {
        const d = document.createElement('div');
        d.innerText = "VRAM SIEVE";
        stage.appendChild(d);

        // FASE 1: PREENCHIMENTO VRAM
        const canvases = [];
        for(let i=0; i<50; i++) {
            const c = document.createElement('canvas');
            c.width = 512; c.height = 512; // Texturas médias
            const ctx = c.getContext('2d');
            ctx.fillStyle = 'red';
            ctx.fillRect(0,0,512,512);
            canvases.push(c);
            document.body.appendChild(c);
        }

        d._detonate = () => {
            // FASE 2: PENEIRA
            // Remove canvas pares do DOM e zera referência
            for(let i=0; i<canvases.length; i+=2) {
                canvases[i].remove();
                canvases[i].width = 0; // Libera VRAM
                canvases[i] = null;
            }
            // Tela Preta
            document.body.style.backgroundColor = "black";
            stage.style.display = "none";
        };

        d._fragment = () => {
            // FASE 3: PRESSÃO VRAM
            // Tenta criar texturas novas nos buracos
            const c = document.createElement('canvas');
            c.width = 520; c.height = 520; // Pouco maior que o buraco
            const ctx = c.getContext('2d');
            ctx.fillRect(0,0,1,1);
            // Não adiciona ao DOM, deixa o GC limpar, criando ciclo de alocação/liberação
        };
        return d;
    }

    // =================================================================
    // 03. DOM Sieve (Heap Fragmentation)
    // Fragmenta a memória de objetos C++ do navegador
    // =================================================================
    function s03(stage) {
        const d = document.createElement('div');
        d.innerText = "HEAP SIEVE";
        stage.appendChild(d);

        // FASE 1: PREENCHIMENTO HEAP
        const nodes = [];
        const container = document.createElement('div');
        for(let i=0; i<10000; i++) {
            const s = document.createElement('span');
            s.innerText = "X";
            container.appendChild(s);
            nodes.push(s);
        }
        document.body.appendChild(container);

        d._detonate = () => {
            // FASE 2: PENEIRA
            // Remove nós pares
            for(let i=0; i<nodes.length; i+=2) {
                nodes[i].remove();
                nodes[i] = null;
            }
            container.remove(); // Remove o pai, mas os filhos ímpares ainda existem em 'nodes'
            // Tela Preta
            document.body.innerHTML = "";
        };

        d._fragment = () => {
            // FASE 3: PRESSÃO
            // Cria nós complexos (divs com estilo) para tentar caber nos buracos dos spans
            const div = document.createElement('div');
            div.style.color = "red";
            // Força cálculo
            const x = div.style.color;
        };
        return d;
    }

</script>
</body>
</html>

