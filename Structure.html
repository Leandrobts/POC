<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Struct Hunter</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; padding: 20px; text-align: center; }
        textarea { width: 90%; height: 400px; background: #000; color: #0f0; border: 1px solid #555; margin-top: 10px; }
        button { padding: 15px; background: #005500; color: #fff; border: 1px solid #0f0; cursor: pointer; }
    </style>
</head>
<body>
    <h1>STRUCT HUNTER (WebKit Analysis)</h1>
    <p>Carregue: <b>1200_libSceNKWebKit.sprx.elf</b></p>
    <input type="file" id="fileInput" />
    <br><br>
    <button onclick="analyze()">ANALISAR SHAREDWORKER</button>
    <textarea id="output"></textarea>

    <script>
        function analyze() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo!");

            const reader = new FileReader();
            reader.onload = function(e) {
                const view = new Uint8Array(e.target.result);
                let log = "--- ANÁLISE DE ESTRUTURA ---\n";

                // 1. Procurar strings de referência
                // IsoHeapCellType::finishSweep geralmente aparece perto do tamanho
                const strWorker = "SharedWorker";
                const bytesWorker = new TextEncoder().encode(strWorker);
                
                // Busca simplificada por padrões de alocação (mov edi, SIZE)
                // Padrão comum de alocação x64: BF XX XX 00 00 (mov edi, SIZE) -> call malloc
                // Vamos procurar referências à string "SharedWorker" e olhar o código em volta.
                
                let found = 0;
                for(let i=0; i<view.length - bytesWorker.length; i++) {
                    let match = true;
                    for(let j=0; j<bytesWorker.length; j++) {
                        if(view[i+j] !== bytesWorker[j]) { match = false; break; }
                    }
                    
                    if(match) {
                        // Encontrou a string. Vamos olhar "atrás" (referências cruzadas na .text seriam ideais, 
                        // mas aqui fazemos uma heurística de proximidade de código).
                        // Em ELF, a string está na .rodata, o código na .text.
                        // Sem disassembler completo, vamos listar os offsets para mapear manualmente se precisar.
                        log += `String '${strWorker}' encontrada em 0x${i.toString(16)}\n`;
                        found++;
                        if(found > 10) break; // Limita
                    }
                }

                // 2. Busca por Tamanhos Comuns de IsoHeap (Heurística)
                // WebKit costuma ter tabelas de tamanhos para IsoHeap.
                // Vamos procurar sequências que definam tamanhos de objetos DOM.
                // Tamanhos prováveis: 0x60, 0x70, 0x80, 0x90, 0xA0...
                
                log("\n--- BUSCA DE ASSINATURAS DE ISOHEAP ---\n");
                // Assinatura genérica para vtable de SharedWorker (chute baseado em versões anteriores)
                // Se conseguirmos achar a VTable, sabemos o início do objeto.
                
                log("Análise concluída. Se você tiver o IDA Pro, procure por 'WebCore::SharedWorker::create'.\n");
                log("Sem IDA, precisamos confiar nos testes empíricos de tamanho: 0x400 falhou, tente menores.");
                
                document.getElementById('output').value = log;
            };
            reader.readAsArrayBuffer(file);
        }
    </script>
</body>
</html>
