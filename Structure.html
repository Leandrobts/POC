<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 STRUCT LAYOUT MAPPER</title>
    <style>
        body { background: #0d1117; color: #58a6ff; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        textarea { width: 95%; height: 500px; background: #000; color: #e6edf3; border: 1px solid #30363d; margin-top: 15px; font-size: 13px; }
        button { padding: 15px 30px; background: #238636; color: #fff; border: none; cursor: pointer; font-weight: bold; font-size: 16px; border-radius: 6px; }
    </style>
</head>
<body>
    <h1>STRUCT LAYOUT MAPPER</h1>
    <p>Objetivo: Mapear offsets internos do SharedWorker (0x839A98)</p>
    <input type="file" id="fileInput" />
    <br><br>
    <button onclick="mapStructure()">MAPEAR ESTRUTURA</button>
    <textarea id="output" readonly>Aguardando...</textarea>

    <script>
        function mapStructure() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo!");

            const reader = new FileReader();
            document.getElementById('output').value = "Analisando acessos de memória...";

            reader.onload = function(e) {
                const view = new DataView(e.target.result);
                const bytes = new Uint8Array(e.target.result);
                const REF = 0x839A98; // Referência confirmada
                
                let log = `=== MAPA DE ACESSO À ESTRUTURA (Baseado em 0x${REF.toString(16)}) ===\n\n`;
                
                // Analisa 1000 bytes APÓS a referência (uso do objeto)
                // Procuramos instruções como: MOV RAX, [RBX + Offset]
                // Assumindo que RBX ou RDI contém o ponteiro "this" do objeto
                
                let offsetsFound = {};
                
                // Heurística: Em métodos C++, 'this' geralmente está em RDI (arg0) ou RBX (callee-saved)
                // Vamos procurar acessos relativos a registradores comuns.
                
                for(let i = REF; i < REF + 2000; i++) {
                    const b = bytes[i];
                    
                    // Padrão: MOV Reg, [Reg + Disp8] (48 8B 43 XX)
                    // Padrão: MOV Reg, [Reg + Disp32] (48 8B 83 XX XX XX XX)
                    
                    if (b === 0x48 && bytes[i+1] === 0x8B) { // MOV R64, [M64]
                        const modrm = bytes[i+2];
                        
                        // Decodificação simplificada de ModR/M para achar offsets
                        // Mod = 01 (Disp8), Mod = 10 (Disp32)
                        const mod = (modrm >> 6) & 0x03;
                        
                        let offset = 0;
                        let size = 0;
                        
                        if (mod === 1) { // Disp8
                            offset = bytes[i+3];
                            size = 4;
                        } else if (mod === 2) { // Disp32
                            offset = view.getInt32(i+3, true);
                            size = 7;
                        }
                        
                        if (offset > 0 && offset < 0x200) { // Filtra offsets dentro do tamanho provável (0xC0)
                            if (!offsetsFound[offset]) offsetsFound[offset] = 0;
                            offsetsFound[offset]++;
                            
                            // log(`[OFFSET +0x${offset.toString(16).toUpperCase()}] Acessado em 0x${i.toString(16)}`);
                        }
                    }
                }
                
                log("Offsets mais acessados (Hotspots da Estrutura):\n");
                const sorted = Object.keys(offsetsFound).sort((a,b) => parseInt(a) - parseInt(b));
                
                sorted.forEach(off => {
                    const hexOff = parseInt(off).toString(16).toUpperCase();
                    const count = offsetsFound[off];
                    let note = "";
                    
                    if (off == 0) note = " (VTABLE / TypeInfo)";
                    if (off == 8) note = " (Ref Count / Parent?)";
                    
                    log(`+0x${hexOff.padEnd(4)} : ${count} acessos ${note}`);
                });
                
                log("\nINTERPRETAÇÃO:");
                log("1. O Offset 0x0 é quase sempre a VTable.");
                log("2. Offsets com muitos acessos são ponteiros vitais.");
                log("3. Offsets sem acesso (buracos) são seguros para corrupção (Data Fields).");

                document.getElementById('output').value = log;
            };
            reader.readAsArrayBuffer(file);
        }
    </script>
</body>
</html>
