<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 VTable Structure Analyzer</title>
    <style>
        body { background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        .container { max-width: 900px; margin: 0 auto; background: #252526; padding: 20px; border: 1px solid #3e3e42; border-radius: 8px; }
        textarea { width: 100%; height: 450px; background: #1e1e1e; color: #9cdcfe; border: 1px solid #3e3e42; margin-top: 15px; font-size: 13px; white-space: pre; }
        button { padding: 12px 24px; font-size: 16px; cursor: pointer; background: #0e639c; color: white; border: none; border-radius: 4px; margin: 10px; font-weight: bold; }
        button:hover { background: #1177bb; }
        .highlight { color: #ce9178; font-weight: bold; }
        .found { color: #b5cea8; }
    </style>
</head>
<body>

    <div class="container">
        <h1>üß¨ VTABLE & STRUCTURE ANALYZER</h1>
        <p>Foco: Encontrar o Offset da VTable do SharedWorker</p>
        
        <input type="file" id="fileInput" />
        <br>
        <button onclick="startAnalysis()">RASTREAR ESTRUTURA</button>
        
        <textarea id="output" readonly>Aguardando arquivo ELF...</textarea>
    </div>

    <script>
        function log(msg) {
            document.getElementById('output').value += msg + "\n";
        }

        function startAnalysis() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput.files.length === 0) return alert("Selecione o arquivo ELF!");

            const reader = new FileReader();
            document.getElementById('output').value = "Iniciando leitura bin√°ria...\n";

            reader.onload = function(e) {
                const buffer = e.target.result;
                const view = new DataView(buffer);
                const bytes = new Uint8Array(buffer);
                
                analyze(view, bytes);
            };
            reader.readAsArrayBuffer(fileInput.files[0]);
        }

        function analyze(view, bytes) {
            log("=== AN√ÅLISE ESTRUTURAL (SharedWorker) ===\n");

            // 1. Localizar String "SharedWorker"
            // Esta string √© usada pelo m√©todo class_name() ou type_info
            const targetStr = "SharedWorker";
            const strOffset = findString(bytes, targetStr);
            
            if (strOffset === -1) {
                log("[-] String n√£o encontrada.");
                return;
            }
            log(`[1] String '${targetStr}' encontrada em: 0x${strOffset.toString(16).toUpperCase()}`);

            // 2. Encontrar XREFs (C√≥digos que usam a string)
            // No x64 (PS4), usa-se RIP-Relative Addressing (LEA ou MOV)
            // Instru√ß√£o: [Opcode] [Offset 32-bit]
            // Destino = Endere√ßoInstrucao + TamanhoInstrucao + Offset
            
            const codeRefs = findRipRelativeRefs(view, strOffset);
            if (codeRefs.length === 0) {
                log("[-] Nenhuma refer√™ncia de c√≥digo encontrada para a string.");
                return;
            }

            log(`[2] Encontradas ${codeRefs.length} refer√™ncias de c√≥digo (XREFs).`);

            codeRefs.forEach(codeOffset => {
                log(`\n   >>> Analisando C√≥digo em: 0x${codeOffset.toString(16).toUpperCase()} <<<`);
                
                // A. Validar Tamanho 0xA0 perto daqui
                // Procura por MOV EDI, 0xA0 (BF A0 00 00 00) num raio de 500 bytes para tr√°s
                let sizeFound = false;
                for(let i = codeOffset; i > Math.max(0, codeOffset - 500); i--) {
                    // BF = MOV EDI (Arg 1)
                    if (bytes[i] === 0xBF && bytes[i+1] === 0xA0 && bytes[i+2] === 0x00) {
                         log(`       [CONFIRMA√á√ÉO] Aloca√ß√£o de 0xA0 (160 bytes) encontrada em 0x${i.toString(16).toUpperCase()}`);
                         sizeFound = true;
                    }
                }
                if (!sizeFound) log("       [-] Aloca√ß√£o expl√≠cita 0xA0 n√£o vista (pode ser impl√≠cita/herdada).");

                // B. Encontrar a VTable (O Pulo do Gato)
                // A VTable √© uma lista de ponteiros na se√ß√£o .data.
                // Um dos ponteiros da VTable aponta para ESTE c√≥digo (ou o in√≠cio da fun√ß√£o dele).
                
                // Vamos procurar ponteiros de 64-bits que apontem para a regi√£o [codeOffset-100 at√© codeOffset]
                // Assumindo que o ponteiro aponta para o in√≠cio da fun√ß√£o.
                
                const startSearchFn = codeOffset - 200;
                const endSearchFn = codeOffset + 4; // Um pouco depois por seguran√ßa
                
                const vtables = findPointersToRange(view, startSearchFn, endSearchFn);
                
                if (vtables.length > 0) {
                    vtables.forEach(vt => {
                        log(`       [!!!] CANDIDATO A VTABLE ENCONTRADO [!!!]`);
                        log(`       Endere√ßo do Ponteiro (No Arquivo): 0x${vt.loc.toString(16).toUpperCase()}`);
                        log(`       Aponta para a fun√ß√£o em: 0x${vt.target.toString(16).toUpperCase()}`);
                        
                        // A VTable real come√ßa geralmente 16 bytes antes do primeiro m√©todo (offset do RTTI)
                        // Mas para fins de exploit, o endere√ßo onde achamos o ponteiro √© o 'AddressOfVtable + Offset'
                        
                        log(`       ---> OFFSET M√ÅGICO PARA O EXPLOIT: 0x${vt.loc.toString(16).toUpperCase()}`);
                    });
                } else {
                    log("       [-] Nenhum ponteiro direto encontrado para este c√≥digo na se√ß√£o de dados.");
                }
            });
            
            log("\n=== FIM DA AN√ÅLISE ===");
        }

        // Utilit√°rios de Busca
        function findString(bytes, str) {
            const target = new TextEncoder().encode(str);
            for(let i=0; i<bytes.length - target.length; i++) {
                let match = true;
                for(let j=0; j<target.length; j++) {
                    if(bytes[i+j] !== target[j]) { match = false; break; }
                }
                // Verifica null terminator para garantir string exata
                if(match && bytes[i+target.length] === 0) return i;
            }
            return -1;
        }

        function findRipRelativeRefs(view, target) {
            const refs = [];
            // Varre o arquivo procurando instru√ß√µes LEA/MOV com offset relativo
            // Otimiza√ß√£o: pular de 1 em 1 √© lento, mas seguro.
            const len = view.byteLength - 7;
            
            for (let i = 0; i < len; i++) {
                // 48 8D ?? ?? ?? ?? ?? (LEA R64, [RIP+disp])
                const b1 = view.getUint8(i);
                const b2 = view.getUint8(i+1);
                
                if (b1 === 0x48 && (b2 === 0x8D || b2 === 0x8B)) { // LEA ou MOV
                    const offset = view.getInt32(i+3, true);
                    const nextInstr = i + 7;
                    const dest = nextInstr + offset;
                    
                    if (dest === target) {
                        refs.push(i);
                    }
                }
            }
            return refs;
        }

        function findPointersToRange(view, startRange, endRange) {
            const refs = [];
            // VTables est√£o alinhadas a 8 bytes. Varre de 8 em 8.
            // Come√ßa depois do c√≥digo (heur√≠stica), mas varrer tudo √© mais seguro.
            const len = view.byteLength - 8;
            
            for (let i = 0; i < len; i+=8) {
                try {
                    // Pega valor de 64 bits
                    const val = Number(view.getBigUint64(i, true));
                    
                    // Verifica se aponta para dentro da fun√ß√£o
                    if (val >= startRange && val <= endRange) {
                        refs.push({ loc: i, target: val });
                    }
                } catch(e){}
            }
            return refs;
        }
    </script>
</body>
</html>
