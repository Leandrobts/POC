<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 BINARY DISSECTOR</title>
    <style>
        body { background-color: #0d0d0d; color: #00ff00; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        textarea { width: 95%; height: 600px; background: #000; color: #e0e0e0; border: 1px solid #333; margin-top: 15px; font-size: 13px; white-space: pre; }
        button { padding: 15px 40px; background: #b30000; color: #fff; border: none; cursor: pointer; font-weight: bold; font-size: 18px; border-radius: 5px; }
        button:hover { background: #ff0000; }
        .info { color: #aaa; margin-bottom: 20px; }
    </style>
</head>
<body>

    <h1>BINARY DISSECTOR (Opcode Analyzer)</h1>
    <p class="info">Alvo: Encontrar a instrução 'MOV EDI, SIZE' antes do construtor.</p>
    
    <p>Selecione: <b>1200_libSceNKWebKit.sprx.elf</b></p>
    <input type="file" id="fileInput" />
    <br><br>
    <button onclick="dissect()">DISSECAR CÓDIGO</button>
    
    <textarea id="output" readonly>Aguardando arquivo...</textarea>

    <script>
        function dissect() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo ELF!");

            const reader = new FileReader();
            document.getElementById('output').value = "Lendo e desmontando... (Aguarde)";

            reader.onload = function(e) {
                const view = new DataView(e.target.result);
                const bytes = new Uint8Array(e.target.result);
                let log = "=== RELATÓRIO DE ALOCAÇÃO (SharedWorker) ===\n\n";

                // Ponto de referência conhecido (Uso da String SharedWorker)
                // Do seu relatório anterior: 0x839A9B (aproximado)
                // Vamos olhar para trás, onde a alocação acontece.
                const REF_POINT = 0x839A98;
                
                log += `Ponto de Referência: 0x${REF_POINT.toString(16).toUpperCase()}\n`;
                log += "Procurando instruções de alocação (MOV EDI/ESI, SIZE) nos 500 bytes anteriores...\n\n";
                log("OFFSET     | HEXBYTES          | INSTRUÇÃO (Estimada)\n");
                log("-----------|-------------------|---------------------\n");

                // Varre 500 bytes para trás
                const start = Math.max(0, REF_POINT - 500);
                const end = REF_POINT;

                for (let i = start; i < end; i++) {
                    const b = bytes[i];
                    let line = "";
                    let hex = b.toString(16).toUpperCase().padStart(2,'0');
                    let isInteresting = false;

                    // 1. Padrão: MOV EDI, imm32 (BF XX XX XX XX)
                    // Usado para passar o 1º argumento (Tamanho) para funções C
                    if (b === 0xBF) {
                        if (i + 4 < end) {
                            const val = view.getInt32(i + 1, true);
                            // Filtra tamanhos plausíveis (entre 32 e 4096)
                            if (val >= 0x20 && val <= 0x1000) {
                                line = `MOV EDI, 0x${val.toString(16).toUpperCase()} (${val})`;
                                isInteresting = true;
                            }
                        }
                    }
                    
                    // 2. Padrão: MOV ESI, imm32 (BE XX XX XX XX)
                    // Usado para passar o 2º argumento
                    else if (b === 0xBE) {
                        if (i + 4 < end) {
                            const val = view.getInt32(i + 1, true);
                            if (val >= 0x20 && val <= 0x1000) {
                                line = `MOV ESI, 0x${val.toString(16).toUpperCase()} (${val})`;
                                isInteresting = true;
                            }
                        }
                    }

                    // 3. Padrão: MOV EDX, imm32 (BA XX XX XX XX)
                    // 3º Argumento
                    else if (b === 0xBA) {
                        if (i + 4 < end) {
                            const val = view.getInt32(i + 1, true);
                            if (val >= 0x20 && val <= 0x1000) {
                                line = `MOV EDX, 0x${val.toString(16).toUpperCase()} (${val})`;
                                isInteresting = true;
                            }
                        }
                    }
                    
                    // 4. CALL (E8)
                    // Indica chamada de função (possivelmente o alocador)
                    else if (b === 0xE8) {
                         line = "CALL (Função)";
                         isInteresting = true;
                    }

                    if (isInteresting) {
                        // Mostra o offset e os bytes seguintes
                        let fullHex = "";
                        for(let k=0; k<5; k++) {
                            if(i+k < bytes.length) fullHex += bytes[i+k].toString(16).toUpperCase().padStart(2,'0') + " ";
                        }
                        
                        log += `0x${i.toString(16).toUpperCase()} | ${fullHex} | ${line}\n`;
                        
                        // Adiciona marcador visual se for um tamanho muito suspeito
                        // Tamanhos comuns de WebKit: 0x90, 0xA0, 0xC0, 0x140
                        if (line.includes("0x90") || line.includes("0xA0") || line.includes("0xC0") || line.includes("0x140")) {
                            log += "           ^^^^^ CANDIDATO FORTE ^^^^^\n";
                        }
                    }
                }

                document.getElementById('output').value = log;
            };
            reader.readAsArrayBuffer(file);
        }
    </script>
</body>
</html>
