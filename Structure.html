<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 MASTER BINARY ANALYZER</title>
    <style>
        body { background: #121212; color: #00ff00; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        .container { max-width: 1100px; margin: 0 auto; border: 1px solid #333; padding: 20px; background: #1e1e1e; }
        textarea { width: 100%; height: 600px; background: #000; color: #e0e0e0; border: 1px solid #444; margin-top: 15px; font-size: 12px; white-space: pre; }
        button { padding: 15px 40px; background: #006600; color: #fff; border: 1px solid #0f0; cursor: pointer; font-weight: bold; font-size: 16px; margin: 10px; }
        button:hover { background: #008800; }
        .info { color: #aaa; font-size: 14px; margin-bottom: 20px; }
        input { padding: 10px; background: #333; color: #fff; border: 1px solid #555; }
    </style>
</head>
<body>

    <div class="container">
        <h1>üß† MASTER ANALYZER (RIP-RELATIVE)</h1>
        <p class="info">Engenharia Reversa Autom√°tica para encontrar Tamanho e VTable.</p>
        
        <p>Selecione: <b>1200_libSceNKWebKit.sprx.elf</b></p>
        <input type="file" id="fileInput" />
        <br>
        <button onclick="startMasterScan()">INICIAR AN√ÅLISE PROFUNDA</button>
        
        <div id="status" style="color: #ff0; margin: 10px;">Aguardando...</div>
        <textarea id="output" readonly></textarea>
    </div>

    <script>
        function log(msg) {
            document.getElementById('output').value += msg + "\n";
        }

        async function startMasterScan() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo!");

            const reader = new FileReader();
            document.getElementById('status').innerText = "Lendo arquivo (pode demorar)...";
            document.getElementById('output').value = "=== INICIANDO AN√ÅLISE DE BIN√ÅRIO PS4 ===\n";

            reader.onload = function(e) {
                const buffer = e.target.result;
                const view = new DataView(buffer);
                const bytes = new Uint8Array(buffer);
                
                setTimeout(() => analyze(view, bytes), 100);
            };
            reader.readAsArrayBuffer(file);
        }

        function analyze(view, bytes) {
            const TARGET_NAME = "SharedWorker";
            log(`[1] Buscando string '${TARGET_NAME}'...`);

            // 1. Encontrar String
            const strOffset = findString(bytes, TARGET_NAME);
            if (strOffset === -1) {
                log("[-] String n√£o encontrada. Verifique se √© o arquivo correto.");
                return;
            }
            log(`[+] String encontrada em: 0x${strOffset.toString(16).toUpperCase()}`);

            // 2. Encontrar Refer√™ncias de C√≥digo (XREFs via LEA/MOV)
            // No x64, refer√™ncias a strings geralmente usam LEA (Load Effective Address)
            // Opcode: 48 8D xx [Offset 32-bit]
            log(`[2] Rastreando c√≥digo que usa a string (XREFs)...`);
            
            const codeRefs = findRipRelativeRefs(view, strOffset);
            
            if (codeRefs.length === 0) {
                log("[-] Nenhuma refer√™ncia de c√≥digo direta encontrada.");
                log("    Tentando varredura por ponteiros diretos (tabelas)...");
                // Fallback para ponteiros absolutos (menos comum em c√≥digo, comum em data)
            }

            // Para cada lugar onde o c√≥digo usa o nome "SharedWorker"...
            codeRefs.forEach(ref => {
                log(`\n>>> ANALISANDO REFER√äNCIA EM 0x${ref.toString(16).toUpperCase()} <<<`);
                
                // A. BUSCAR TAMANHO (SIZE HUNTER)
                // Olhamos para tr√°s (at√© 200 bytes antes) procurando a aloca√ß√£o.
                // Padr√µes comuns:
                // BF XX XX 00 00  -> MOV EDI, size
                // BE XX XX 00 00  -> MOV ESI, size
                // BA XX XX 00 00  -> MOV EDX, size
                let sizeFound = false;
                for (let i = ref; i > Math.max(0, ref - 500); i--) {
                    // MOV EDI, imm32 (Argumento 1 padr√£o para fun√ß√µes C++)
                    if (bytes[i] === 0xBF) {
                        const size = view.getInt32(i + 1, true);
                        // Filtro de sanidade (tamanho de objeto WebKit)
                        if (size >= 0x20 && size <= 0x800) {
                            // Verifica alinhamento (mallocs s√£o alinhados a 8 ou 16)
                            if (size % 8 === 0 || size % 16 === 0) {
                                log(`    [SIZE CANDIDATE] 0x${size.toString(16).toUpperCase()} (${size} bytes)`);
                                log(`    (Encontrado em 0x${i.toString(16).toUpperCase()} - MOV EDI, ${size})`);
                                sizeFound = true;
                            }
                        }
                    }
                    // MOV ESI, imm32 (Argumento 2)
                    else if (bytes[i] === 0xBE) {
                        const size = view.getInt32(i + 1, true);
                        if (size >= 0x20 && size <= 0x800) {
                            log(`    [SIZE CANDIDATE] 0x${size.toString(16).toUpperCase()} (${size} bytes) [ESI]`);
                            sizeFound = true;
                        }
                    }
                }
                if (!sizeFound) log("    [-] Nenhum padr√£o de tamanho √≥bvio encontrado perto daqui.");

                // B. BUSCAR VTABLE (POINTER HUNTER)
                // A VTable aponta para o c√≥digo. O c√≥digo que achamos (ref) provavelmente √©
                // 'SharedWorker::class_name()' ou RTTI.
                // Vamos procurar na se√ß√£o de DADOS quem tem um ponteiro para 'ref' ou perto de 'ref'.
                
                // Procuramos ponteiros para o IN√çCIO da fun√ß√£o onde 'ref' est√°.
                // Como n√£o sabemos o in√≠cio, procuramos ponteiros que caiam no intervalo [ref-200, ref].
                
                const vtableRefs = findPointersToRange(view, ref - 100, ref + 4);
                if (vtableRefs.length > 0) {
                    vtableRefs.forEach(vt => {
                        log(`    [VTABLE CANDIDATE] Dados em 0x${vt.loc.toString(16).toUpperCase()} apontam para 0x${vt.target.toString(16).toUpperCase()}`);
                        // Ajuste t√≠pico: O ponteiro RTTI fica no offset -8 da VTable.
                        // Ent√£o o endere√ßo base da VTable seria vt.loc + 8.
                        log(`    >>> OFFSET POTENCIAL DA VTABLE: 0x${(vt.loc + 8).toString(16).toUpperCase()}`);
                    });
                }
            });

            document.getElementById('status').innerText = "An√°lise conclu√≠da.";
        }

        // Encontra String
        function findString(bytes, str) {
            const target = new TextEncoder().encode(str);
            for(let i=0; i<bytes.length - target.length; i++) {
                let match = true;
                for(let j=0; j<target.length; j++) {
                    if(bytes[i+j] !== target[j]) { match = false; break; }
                }
                if(match && bytes[i+target.length] === 0) return i;
            }
            return -1;
        }

        // Encontra refer√™ncias RIP-Relative (LEA/MOV)
        function findRipRelativeRefs(view, target) {
            const refs = [];
            const len = view.byteLength - 7;
            
            // Varre o arquivo (passo 1 byte)
            for (let i = 0; i < len; i++) {
                // Verifica opcodes comuns de LEA/MOV com RIP addressing
                // 48 8D xx [Offset] (LEA)
                // 48 8B 05 [Offset] (MOV RAX, [RIP+...])
                // 48 8B 0D [Offset] (MOV RCX, [RIP+...])
                // 48 8B 15 [Offset] (MOV RDX, [RIP+...])
                // 48 8B 35 [Offset] (MOV RSI, [RIP+...])
                // 48 8B 3D [Offset] (MOV RDI, [RIP+...])
                
                const b1 = view.getUint8(i);
                const b2 = view.getUint8(i+1);
                
                // Filtro simples para opcodes 48 8x
                if (b1 === 0x48 && (b2 === 0x8D || b2 === 0x8B)) {
                    // O offset (relativo) come√ßa no byte 3 (i+3)
                    const relOffset = view.getInt32(i + 3, true);
                    
                    // Endere√ßo da Pr√≥xima Instru√ß√£o = i + 7 (tamanho da instru√ß√£o t√≠pica)
                    const nextInstr = i + 7;
                    
                    // Destino = Next + Rel
                    const dest = nextInstr + relOffset;
                    
                    if (dest === target) {
                        refs.push(i);
                    }
                }
            }
            return refs;
        }

        // Encontra ponteiros absolutos apontando para uma faixa
        function findPointersToRange(view, startRange, endRange) {
            const refs = [];
            const len = view.byteLength - 8;
            
            // Varre alinhado a 8 bytes (Ponteiros na .data/.rdata est√£o alinhados)
            for (let i = 0; i < len; i+=4) { // Passo 4 para pegar desalinhados eventuais
                try {
                    const val = view.getBigUint64(i, true);
                    // Converte BigInt para Number (seguro para offsets de arquivo < 4GB)
                    // CUIDADO: Se o arquivo for mapeado em base alta, isso falha.
                    // Assumindo bin√°rio raw ou offset relativo a 0.
                    
                    // Em ELF PIE, os ponteiros na se√ß√£o .data.rel.ro s√£o offsets puros.
                    if (val > BigInt(startRange) && val < BigInt(endRange)) {
                        refs.push({ loc: i, target: Number(val) });
                    }
                } catch(e){}
            }
            return refs;
        }
    </script>
</body>
</html>
