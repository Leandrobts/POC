<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 CONSTRUCTOR HUNTER (ASYNC)</title>
    <style>
        body { background: #050505; color: #00ff00; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        .container { max-width: 900px; margin: 0 auto; border: 1px solid #333; padding: 20px; background: #111; }
        textarea { width: 95%; height: 500px; background: #000; color: #e0e0e0; border: 1px solid #333; margin-top: 15px; font-size: 13px; }
        button { padding: 15px 30px; background: #440044; color: #fff; border: 1px solid #f0f; cursor: pointer; font-weight: bold; font-size: 16px; margin: 10px; }
        #progress-container { width: 100%; background: #333; height: 20px; margin-top: 10px; display: none; }
        #progress-bar { width: 0%; height: 100%; background: #00ff00; }
        .highlight { color: #ff00ff; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>CONSTRUCTOR HUNTER (NO-FREEZE)</h1>
        <p>Alvo VTable: <b>0x3837CC8</b> (Busca Reversa de Tamanho)</p>
        
        <input type="file" id="fileInput" />
        <br>
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div id="status" style="margin:10px; color: yellow;">Aguardando...</div>
        
        <button onclick="initScan()">RASTREAR CONSTRUTOR</button>
        <textarea id="output" readonly></textarea>
    </div>

    <script>
        let isRunning = false;

        function log(msg) {
            document.getElementById('output').value += msg + "\n";
        }

        function initScan() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo ELF!");

            document.getElementById('output').value = "";
            document.getElementById('progress-container').style.display = "block";
            isRunning = true;

            const reader = new FileReader();
            reader.onload = function(e) {
                const view = new DataView(e.target.result);
                scanAsync(view);
            };
            reader.readAsArrayBuffer(file);
        }

        async function scanAsync(view) {
            const len = view.byteLength;
            const status = document.getElementById('status');
            const pBar = document.getElementById('progress-bar');
            
            // VTable encontrada anteriormente
            const VTABLE_TARGET = 0x3837CC8;
            
            log(`=== RASTREAMENTO ASSÍNCRONO ===`);
            log(`Buscando código que carregue a VTable 0x${VTABLE_TARGET.toString(16).toUpperCase()}...`);

            let foundCount = 0;
            const CHUNK_SIZE = 200000; // 200KB por tick
            
            // Limita a busca à seção de código (.text) para ganhar tempo
            // Geralmente os primeiros 15MB do arquivo
            const CODE_LIMIT = Math.min(len, 0x1500000); 

            for (let i = 0; i < CODE_LIMIT; i++) {
                
                // Pausa para UI não travar
                if (i % CHUNK_SIZE === 0) {
                    const pct = (i / CODE_LIMIT) * 100;
                    pBar.style.width = pct + "%";
                    status.innerText = `Varrendo Código: ${pct.toFixed(1)}%`;
                    await new Promise(r => setTimeout(r, 0));
                }

                // Procura instrução LEA (48 8D)
                // LEA REG, [RIP + Offset]
                const b1 = view.getUint8(i);
                const b2 = view.getUint8(i+1);

                if (b1 === 0x48 && b2 === 0x8D) {
                    const offset = view.getInt32(i + 3, true);
                    const nextInstr = i + 7;
                    const dest = nextInstr + offset;
                    
                    // Margem de erro pequena (+/- 16 bytes) caso aponte para RTTI ou Offset Table
                    if (Math.abs(dest - VTABLE_TARGET) <= 16) {
                        foundCount++;
                        let msg = `\n[CONSTRUTOR LOCALIZADO] Offset 0x${i.toString(16).toUpperCase()}`;
                        msg += `\n   Aponta para VTable: 0x${dest.toString(16).toUpperCase()}`;
                        log(msg);
                        
                        // ANÁLISE LOCAL DO TAMANHO (Síncrona, pois é curta)
                        analyzeSizeLocal(view, i);
                    }
                }
            }

            status.innerText = "Concluído.";
            pBar.style.width = "100%";
            
            if (foundCount === 0) {
                log("\n[-] Nenhuma referência direta encontrada. O código pode usar offsets indiretos.");
            }
        }

        function analyzeSizeLocal(view, refOffset) {
            let msg = "";
            // Olha 200 bytes para trás
            const start = Math.max(0, refOffset - 200);
            
            log(`   -> Buscando tamanho de alocação (MOV EDI...) nos 200 bytes anteriores...`);

            let bestSize = null;

            for (let k = refOffset; k > start; k--) {
                const b = view.getUint8(k);
                
                // BF = MOV EDI (Arg 1) - Padrão mais comum
                if (b === 0xBF) {
                    const size = view.getInt32(k+1, true);
                    if (size >= 0x20 && size <= 0x800) {
                        msg += `      [CANDIDATO] Em 0x${k.toString(16).toUpperCase()}: MOV EDI, 0x${size.toString(16).toUpperCase()} (${size} bytes)\n`;
                        if(!bestSize) bestSize = size; // O mais próximo é o mais provável
                    }
                }
                // BE = MOV ESI (Arg 2)
                else if (b === 0xBE) {
                    const size = view.getInt32(k+1, true);
                    if (size >= 0x20 && size <= 0x800) {
                        msg += `      [CANDIDATO] Em 0x${k.toString(16).toUpperCase()}: MOV ESI, 0x${size.toString(16).toUpperCase()} (${size} bytes)\n`;
                    }
                }
                // BA = MOV EDX
                else if (b === 0xBA) {
                    const size = view.getInt32(k+1, true);
                    if (size >= 0x20 && size <= 0x800) {
                         msg += `      [CANDIDATO] Em 0x${k.toString(16).toUpperCase()}: MOV EDX, 0x${size.toString(16).toUpperCase()} (${size} bytes)\n`;
                    }
                }
            }
            
            if (bestSize) {
                msg += `   >>> TAMANHO RECOMENDADO: 0x${bestSize.toString(16).toUpperCase()} <<<\n`;
            } else {
                msg += "      [-] Nenhum tamanho padrão encontrado perto daqui.\n";
            }
            log(msg);
        }
    </script>
</body>
</html>
