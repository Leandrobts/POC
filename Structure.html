<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 ULTIMATE ANALYZER</title>
    
</head>
<body>
    <div class="container">
        <h1>ðŸ”¬ ULTIMATE ELF ANALYZER</h1>
        <h3>Foco: Tamanho de AlocaÃ§Ã£o (SharedWorker)</h3>
        
        <div class="file-input">
            <p>Selecione TODOS os arquivos .elf (WebKit, Libc, Kernel...)</p>
            <input type="file" id="fileInput" multiple onchange="updateList()" />
            <div id="fileList" style="color: #aaa; font-size: 12px; margin-top: 5px;"></div>
        </div>

        <button onclick="startAnalysis()">INICIAR VARREDURA PROFUNDA</button>
        <textarea id="output" readonly>Aguardando arquivos...</textarea>
    </div>

    <script>
        function updateList() {
            const files = document.getElementById('fileInput').files;
            document.getElementById('fileList').innerText = `${files.length} arquivos selecionados.`;
        }

        async function startAnalysis() {
            const files = document.getElementById('fileInput').files;
            if (files.length === 0) return alert("Selecione os arquivos!");

            const out = document.getElementById('output');
            out.value = "Iniciando anÃ¡lise cruzada...\n";

            let binaries = {};

            // 1. Carregar
            for (let f of files) {
                out.value += `Lendo ${f.name}...\n`;
                const buf = await readFile(f);
                binaries[f.name] = {
                    view: new DataView(buf),
                    bytes: new Uint8Array(buf)
                };
            }

            let log = "\n=== RELATÃ“RIO DE TAMANHOS (HEURÃSTICA) ===\n";

            // 2. Localizar WebKit
            const wkKey = Object.keys(binaries).find(k => k.includes("WebKit"));
            if (!wkKey) {
                out.value += "ERRO: WebKit nÃ£o encontrado.\n";
                return;
            }
            const wk = binaries[wkKey];

            // 3. Ponto de ReferÃªncia (String SharedWorker)
            const targetStr = "SharedWorker";
            const strOffset = findString(wk.bytes, targetStr);
            
            if (strOffset === -1) {
                log += "[-] String 'SharedWorker' nÃ£o encontrada no WebKit.\n";
            } else {
                log += `[+] String '${targetStr}' em 0x${strOffset.toString(16).toUpperCase()}\n`;
                
                // 4. Achar quem usa a string (CÃ³digo)
                const codeRefs = findRelativeRefs(wk.view, strOffset);
                
                codeRefs.forEach(ref => {
                    log += `\n>>> Analisando CÃ³digo em 0x${ref.toString(16).toUpperCase()} <<<\n`;
                    
                    // 5. VARREDURA REVERSA INTELIGENTE
                    // Procura por qualquer instruÃ§Ã£o que mova um valor "pequeno" (size) para um registro
                    // num raio de 500 bytes antes do uso da string.
                    
                    const start = Math.max(0, ref - 500);
                    let sizesFound = {};

                    for (let i = ref; i > start; i--) {
                        let size = -1;
                        let reg = "";

                        // MOV RDI, imm32 (48 C7 C7 ...)
                        if (wk.bytes[i] === 0x48 && wk.bytes[i+1] === 0xC7 && wk.bytes[i+2] === 0xC7) {
                            size = wk.view.getInt32(i+3, true);
                            reg = "RDI";
                        }
                        // MOV ESI, imm32 (BE ...)
                        else if (wk.bytes[i] === 0xBE) {
                            size = wk.view.getInt32(i+1, true);
                            reg = "ESI";
                        }
                        // MOV EDI, imm32 (BF ...)
                        else if (wk.bytes[i] === 0xBF) {
                            size = wk.view.getInt32(i+1, true);
                            reg = "EDI";
                        }
                        // MOV EDX, imm32 (BA ...)
                        else if (wk.bytes[i] === 0xBA) {
                            size = wk.view.getInt32(i+1, true);
                            reg = "EDX";
                        }

                        // Filtro de Tamanho de Objeto (32 bytes a 4096 bytes)
                        if (size >= 0x20 && size <= 0x1000) {
                            // Filtra alinhamento (malloc geralmente alinha em 16 ou 8 bytes)
                            if (size % 8 === 0) {
                                let dist = ref - i;
                                log += `   [OFFSET -${dist}] MOV ${reg}, 0x${size.toString(16).toUpperCase()} (${size})\n`;
                                
                                if(!sizesFound[size]) sizesFound[size] = 0;
                                sizesFound[size]++;
                            }
                        }
                    }
                });
            }

            // 6. Checar ISOHEAP em outros arquivos
            log += "\n=== ESTRUTURAS ISOHEAP DETECTADAS ===\n";
            for (let name in binaries) {
                const b = binaries[name];
                // Procura assinaturas de IsoHeapCellType::finishSweep
                // PadrÃ£o comum de cÃ³digo de alocador
                const isoScan = findPattern(b.bytes, "48 8B 05 ?? ?? ?? ?? 48 85 C0 74"); // Exemplo genÃ©rico
                if(isoScan.length > 0) {
                    log += `[${name}] PossÃ­vel cÃ³digo de IsoHeap detectado em ${isoScan.length} locais.\n`;
                }
            }

            out.value = log;
        }

        function readFile(file) {
            return new Promise(resolve => {
                const r = new FileReader();
                r.onload = e => resolve(e.target.result);
                r.readAsArrayBuffer(file);
            });
        }

        function findString(bytes, str) {
            const target = new TextEncoder().encode(str);
            for(let i=0; i<bytes.length-target.length; i++) {
                let match = true;
                for(let j=0; j<target.length; j++) {
                    if(bytes[i+j] !== target[j]) { match = false; break; }
                }
                if(match && bytes[i+target.length] === 0) return i;
            }
            return -1;
        }

        function findRelativeRefs(view, targetOffset) {
            const results = [];
            const len = view.byteLength - 4;
            for (let i = 0; i < len; i+=1) { // Scan byte a byte para garantir
                const rel = view.getInt32(i, true);
                if (i + 4 + rel === targetOffset) {
                    // Valida se parece instruÃ§Ã£o (LEA/MOV)
                    // LEA geralmente Ã© 48 8D ...
                    if (i >= 3 && view.getUint8(i-3) === 0x48 && view.getUint8(i-2) === 0x8D) {
                        results.push(i-3);
                    }
                }
            }
            return results;
        }
        
        function findPattern(view, patternHex) {
            // Simplificado para demo
            return [];
        }
    </script>
</body>
</html>
