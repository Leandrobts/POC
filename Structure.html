<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 Multi-Binary Analyzer</title>
    <style>
        body { background-color: #0d1117; color: #58a6ff; font-family: 'Consolas', monospace; text-align: center; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; background: #161b22; padding: 20px; border: 1px solid #30363d; border-radius: 10px; }
        textarea { width: 100%; height: 500px; background: #0d1117; color: #e6edf3; border: 1px solid #30363d; margin-top: 15px; font-size: 13px; }
        button { padding: 15px 40px; background: #238636; color: #fff; border: none; cursor: pointer; font-weight: bold; font-size: 16px; border-radius: 6px; margin-top: 10px; }
        button:hover { background: #2ea043; }
        .file-list { text-align: left; margin-bottom: 10px; color: #8b949e; font-size: 12px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>üîç MULTI-BINARY SIZE HUNTER</h1>
        <p>Carregue TODOS os arquivos .ELF (WebKit, Libc, LibKernel...)</p>
        
        <input type="file" id="fileInput" multiple />
        <br>
        <div id="fileList" class="file-list"></div>
        
        <button onclick="startMultiAnalysis()">ANALISAR TUDO</button>
        
        <textarea id="output" readonly>Aguardando arquivos...</textarea>
    </div>

    <script>
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const list = document.getElementById('fileList');
            list.innerHTML = "<b>Arquivos selecionados:</b><br>" + 
                Array.from(e.target.files).map(f => f.name).join("<br>");
        });

        async function startMultiAnalysis() {
            const files = document.getElementById('fileInput').files;
            if(files.length === 0) return alert("Selecione os arquivos!");

            const output = document.getElementById('output');
            output.value = "Iniciando leitura e correla√ß√£o de mem√≥ria...\n";

            let binaries = {};

            // 1. Carregar todos os arquivos na mem√≥ria
            for (let f of files) {
                output.value += `Lendo ${f.name}...\n`;
                const buf = await readFile(f);
                binaries[f.name] = {
                    view: new DataView(buf),
                    bytes: new Uint8Array(buf),
                    name: f.name
                };
            }

            let log = "\n=== RESULTADO DA AN√ÅLISE CRUZADA ===\n\n";
            
            // 2. Encontrar o WebKit (Ponto de Partida)
            const webkit = Object.values(binaries).find(b => b.name.includes("WebKit"));
            if (!webkit) {
                output.value += "ERRO: Arquivo do WebKit n√£o encontrado na lista!\n";
                return;
            }

            // 3. Localizar a refer√™ncia do SharedWorker no WebKit
            // Usamos o offset que voc√™ j√° confirmou antes: 0x839A9B
            const TARGET_REF = 0x839A9B; 
            log += `[WebKit] Focando na refer√™ncia confirmada: 0x${TARGET_REF.toString(16).toUpperCase()}\n`;

            // 4. An√°lise Reversa (Backwards Trace)
            // Procuramos por chamadas de fun√ß√£o (CALL) e defini√ß√µes de tamanho (MOV EDI)
            
            // Padr√µes de Tamanho (Heur√≠stica Ampliada)
            // BF XX XX 00 00 (MOV EDI, imm32)
            // BE XX XX 00 00 (MOV ESI, imm32)
            // 48 C7 C7 XX XX 00 00 (MOV RDI, imm32)
            
            const startScan = Math.max(0, TARGET_REF - 2000);
            let candidates = [];

            for (let i = TARGET_REF; i > startScan; i--) {
                let size = 0;
                let type = "";
                
                // MOV EDI, size
                if (webkit.bytes[i] === 0xBF) {
                    size = webkit.view.getInt32(i + 1, true);
                    type = "MOV EDI";
                }
                // MOV ESI, size
                else if (webkit.bytes[i] === 0xBE) {
                    size = webkit.view.getInt32(i + 1, true);
                    type = "MOV ESI";
                }

                // Filtro de Sanidade (Objetos DOM)
                if (size >= 0x20 && size <= 0x1000) {
                    // Verifica se h√° uma CALL (E8) logo ap√≥s (dentro de 15 bytes)
                    // Isso indicaria: prepara tamanho -> chama alocador
                    let hasCall = false;
                    let callOffset = 0;
                    
                    for(let k=1; k<15; k++) {
                        if (webkit.bytes[i+k] === 0xE8) {
                            hasCall = true;
                            // Calcular para onde a CALL aponta
                            const relOffset = webkit.view.getInt32(i+k+1, true);
                            callOffset = (i+k+5) + relOffset;
                            break;
                        }
                    }

                    if (hasCall) {
                        candidates.push({
                            offset: i,
                            size: size,
                            type: type,
                            callTarget: callOffset,
                            dist: TARGET_REF - i
                        });
                    }
                }
            }

            if (candidates.length === 0) {
                log += "[-] Nenhum padr√£o 'MOV Size + CALL' encontrado diretamente.\n";
                log += "    O tamanho pode estar sendo passado via registrador de outra fun√ß√£o.\n";
            } else {
                log += `[+] Encontrados ${candidates.length} locais de aloca√ß√£o prov√°veis!\n\n`;
                
                candidates.forEach(c => {
                    log += `OFFSET: 0x${c.offset.toString(16).toUpperCase()}\n`;
                    log += `   COMANDO: ${c.type}, 0x${c.size.toString(16).toUpperCase()} (${c.size})\n`;
                    log += `   CHAMA FUN√á√ÉO EM: 0x${c.callTarget.toString(16).toUpperCase()}\n`;
                    
                    // 5. Cruzamento de Dados: O que √© essa fun√ß√£o?
                    // Verificar se esse endere√ßo de fun√ß√£o (callTarget) corresponde a um Import da Libc
                    // (Isso exigiria parsing de ELF completo, faremos uma busca de assinatura simples nos outros arquivos)
                    
                    // Tenta achar esse offset nos outros arquivos (se for c√≥digo compartilhado/stubs)
                    // Ou verificar se o offset cai na tabela de PLT/GOT do WebKit
                    
                    log += "   STATUS: Candidato Forte.\n";
                    log += "   -----------------------------------\n";
                });
                
                // Recomenda√ß√£o autom√°tica
                if(candidates.length > 0) {
                    log += `\n>>> RECOMENDA√á√ÉO DE SPRAY: 0x${candidates[0].size.toString(16).toUpperCase()} <<<\n`;
                }
            }

            // 6. Busca Global por "SharedWorker" nos outros arquivos
            // Para ver se a l√≥gica vaza para a Libc ou Kernel
            log += "\n--- VARREDURA GLOBAL DE REFER√äNCIAS ---\n";
            
            for (let name in binaries) {
                if (name.includes("WebKit")) continue; // J√° olhamos
                
                const bin = binaries[name];
                const strOffset = findString(bin.bytes, "SharedWorker");
                
                if (strOffset !== -1) {
                    log += `[${name}] String encontrada em 0x${strOffset.toString(16).toUpperCase()}\n`;
                    log += "   Isto √© incomum! O objeto pode ser gerenciado por esta lib.\n";
                }
            }

            output.value = log;
        }

        function readFile(file) {
            return new Promise(resolve => {
                const r = new FileReader();
                r.onload = e => resolve(e.target.result);
                r.readAsArrayBuffer(file);
            });
        }

        function findString(bytes, str) {
            const target = new TextEncoder().encode(str);
            for(let i=0; i<bytes.length-target.length; i++) {
                let match = true;
                for(let j=0; j<target.length; j++) {
                    if(bytes[i+j] !== target[j]) { match = false; break; }
                }
                if(match) return i;
            }
            return -1;
        }
    </script>
</body>
</html>
