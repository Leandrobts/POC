<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Caller Hunter</title>
    <style>
        body { background: #0d1117; color: #58a6ff; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        .container { max-width: 1000px; margin: 0 auto; border: 1px solid #30363d; padding: 20px; background: #161b22; border-radius: 10px; }
        textarea { width: 100%; height: 500px; background: #0d1117; color: #e6edf3; border: 1px solid #30363d; margin-top: 15px; font-size: 13px; }
        button { padding: 15px 40px; background: #238636; color: #fff; border: none; cursor: pointer; font-weight: bold; font-size: 16px; border-radius: 6px; }
        button:hover { background: #2ea043; }
        .step { color: #8b949e; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>CALLER HUNTER (Reverse Trace)</h1>
        <p class="step">Alvo: Quem aloca o objeto SharedWorker?</p>
        
        <input type="file" id="fileInput" />
        <br><br>
        <button onclick="startTrace()">RASTREAR ALOCAÇÃO</button>
        <textarea id="output" readonly>Aguardando arquivo...</textarea>
    </div>

    <script>
        function startTrace() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo!");

            const reader = new FileReader();
            document.getElementById('output').value = "Mapeando fluxo de execução... (Pode levar 30s)";

            reader.onload = function(e) {
                const view = new DataView(e.target.result);
                const bytes = new Uint8Array(e.target.result);
                let log = "=== RELATÓRIO DE RASTREAMENTO ===\n\n";

                // 1. Ponto de Referência (Uso da String)
                const REF_ADDR = 0x839A9B; 
                log += `[1] Ponto de Partida (Ref String): 0x${REF_ADDR.toString(16).toUpperCase()}\n`;

                // 2. Encontrar o Início da Função (Procura por 'Prologue' ou 'Padding' para trás)
                // Padding comum: 0xCC (INT3) ou 0x90 (NOP)
                // Prologue comum: 55 48 89 E5 (push rbp; mov rbp, rsp)
                
                let funcStart = -1;
                for (let i = REF_ADDR; i > REF_ADDR - 0x2000; i--) {
                    // Verifica padding (fim da função anterior)
                    if (bytes[i] === 0xCC && bytes[i-1] === 0xCC) {
                        funcStart = i + 1;
                        break;
                    }
                    // Verifica prologue padrão
                    if (bytes[i] === 0x55 && bytes[i+1] === 0x48 && bytes[i+2] === 0x89 && bytes[i+3] === 0xE5) {
                        funcStart = i;
                        break;
                    }
                }

                if (funcStart === -1) {
                    log += "[-] Não foi possível determinar o início da função automaticamente.\n";
                    // Fallback: Assume um offset razoável para trás
                    funcStart = REF_ADDR - 0x100;
                }

                log(`[2] Função estimada inicia em: 0x${funcStart.toString(16).toUpperCase()}\n`);
                log("    (SharedWorker::SharedWorker constructor)\n\n");

                // 3. Encontrar quem CHAMA essa função (Callers)
                // Procuramos no arquivo todo por: E8 XX XX XX XX (CALL relativo)
                // Onde (Endereço_Call + 5 + Offset) == funcStart
                
                let callers = [];
                for (let i = 0; i < bytes.length - 5; i++) {
                    if (bytes[i] === 0xE8) { // CALL opcode
                        const offset = view.getInt32(i + 1, true);
                        const destination = i + 5 + offset;
                        
                        // Se o destino for o início da nossa função (com margem de erro de 16 bytes para alinhamento)
                        if (Math.abs(destination - funcStart) < 16) {
                            callers.push(i);
                        }
                    }
                }

                log(`[3] Encontrados ${callers.length} locais que chamam esta função.\n`);
                log("    Analisando o código ANTES dessas chamadas para achar o tamanho...\n\n");

                // 4. Analisar o código antes de cada chamada (Procurando o Size)
                let foundSize = false;

                callers.forEach(callAddr => {
                    log(`   --> Chamada em: 0x${callAddr.toString(16).toUpperCase()}\n`);
                    
                    // Olha os 100 bytes antes da chamada
                    const lookBack = Math.max(0, callAddr - 100);
                    let bestSize = null;

                    for (let k = callAddr; k > lookBack; k--) {
                        // Padrão: MOV EDI, size (BF XX XX 00 00)
                        // Padrão: MOV ESI, size (BE XX XX 00 00) - Usado se for o 2º argumento
                        
                        if (bytes[k] === 0xBF || bytes[k] === 0xBE) {
                            const val = view.getInt32(k + 1, true);
                            
                            // Filtro de tamanho realista (32 a 2048 bytes)
                            if (val >= 0x20 && val <= 0x800) {
                                bestSize = val;
                                log(`       [!] ALOCAÇÃO DETECTADA: 0x${val.toString(16).toUpperCase()} (${val} bytes)\n`);
                                log(`           Instrução em: 0x${k.toString(16).toUpperCase()}\n`);
                                foundSize = true;
                                break; // Achou o mais próximo
                            }
                        }
                        
                        // Se acharmos outra CALL antes (ex: operator new), paramos
                        if (bytes[k] === 0xE8 && k !== callAddr) {
                            // Pode ser: CALL malloc (e o tamanho estava antes dessa call)
                            // Vamos continuar olhando um pouco mais
                        }
                    }
                    log("   -----------------------------------\n");
                });

                if (!foundSize) {
                    log("\n[-] Tamanho explícito não encontrado nos callers.\n");
                    log("    O objeto pode ser herdado ou usar tamanho dinâmico.\n");
                    log("    Recomendação: Testar tamanhos padrão do WebKit: 0x90, 0xA0, 0x140.\n");
                } else {
                    log("\n>>> CONCLUSÃO: O tamanho mais provável foi listado acima com [!]. Use-o no spray! <<<\n");
                }

                document.getElementById('output').value = log;
            };
            reader.readAsArrayBuffer(file);
        }
    </script>
</body>
</html>
