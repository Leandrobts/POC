<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 GOD MODE ANALYZER</title>
    <style>
        body { background-color: #111; color: #0f0; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        .container { max-width: 1200px; margin: 0 auto; border: 1px solid #333; padding: 20px; background: #000; }
        textarea { width: 100%; height: 600px; background: #0a0a0a; color: #ddd; border: 1px solid #444; font-size: 12px; margin-top: 15px; white-space: pre; }
        button { padding: 15px 30px; background: #0055aa; color: #fff; font-weight: bold; border: none; cursor: pointer; border-radius: 5px; margin: 5px; }
        button:hover { background: #0077cc; }
        .highlight { color: #ff00ff; font-weight: bold; }
        .header { color: #ffff00; border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ GOD MODE BINARY ANALYZER</h1>
        <h3>Alvo: SharedWorker & MessagePort (Size & VTable)</h3>
        
        <input type="file" id="fileInput" />
        <br><br>
        <button onclick="startAnalysis()">INICIAR VARREDURA PROFUNDA</button>
        <textarea id="output" readonly>Carregue o arquivo .ELF do WebKit...</textarea>
    </div>

    <script>
        function log(msg) {
            document.getElementById('output').value += msg + "\n";
        }

        function startAnalysis() {
            const file = document.getElementById('fileInput').files[0];
            if(!file) return alert("Selecione o arquivo!");

            const reader = new FileReader();
            document.getElementById('output').value = "Lendo bin√°rio (Isso pode levar um minuto)...\n";

            reader.onload = function(e) {
                const buffer = e.target.result;
                const view = new DataView(buffer);
                const bytes = new Uint8Array(buffer);
                
                analyze(view, bytes);
            };
            reader.readAsArrayBuffer(file);
        }

        function analyze(view, bytes) {
            log("=== RELAT√ìRIO DE ENGENHARIA REVERSA (PS4 12.00) ===\n");

            // Lista de alvos para comparar
            const TARGETS = ["SharedWorker", "MessagePort", "Worker"];

            TARGETS.forEach(name => {
                log(`\n========================================`);
                log(`   ANALISANDO OBJETO: ${name}`);
                log(`========================================`);

                // 1. Localizar a String (Nome da Classe)
                const strOffset = findString(bytes, name);
                if (strOffset === -1) {
                    log(`[-] String '${name}' n√£o encontrada.`);
                    return;
                }
                log(`[+] String encontrada em: 0x${strOffset.toString(16).toUpperCase()}`);

                // 2. Localizar XREFs (C√≥digo que usa a string)
                // Isso geralmente √© o construtor ou RTTI
                const codeRefs = findRipRelativeRefs(view, strOffset);
                if (codeRefs.length === 0) {
                    log(`[-] Nenhuma refer√™ncia de c√≥digo direta encontrada.`);
                    return;
                }

                codeRefs.forEach(ref => {
                    log(`\n   -> Refer√™ncia de C√≥digo em: 0x${ref.toString(16).toUpperCase()}`);
                    
                    // 3. SIZE HUNTER (Rastreamento Reverso de Aloca√ß√£o)
                    // Olhamos 1000 bytes para tr√°s procurando 'MOV EDI, size' ou 'MOV ESI, size'
                    // Filtramos apenas tamanhos que fazem sentido para WebKit (32 a 2048 bytes)
                    
                    let sizes = [];
                    const lookback = 1000;
                    const startScan = Math.max(0, ref - lookback);

                    for (let i = ref; i > startScan; i--) {
                        let size = 0;
                        let reg = "";
                        
                        // MOV EDI, imm32 (Argumento 1 - Malloc)
                        if (bytes[i] === 0xBF) {
                            size = view.getInt32(i+1, true);
                            reg = "EDI";
                        }
                        // MOV ESI, imm32 (Argumento 2 - Operator New)
                        else if (bytes[i] === 0xBE) {
                            size = view.getInt32(i+1, true);
                            reg = "ESI";
                        }
                        // MOV RDI, imm32 (64-bit)
                        else if (bytes[i] === 0x48 && bytes[i+1] === 0xC7 && bytes[i+2] === 0xC7) {
                            size = view.getInt32(i+3, true);
                            reg = "RDI";
                        }

                        if (size >= 0x20 && size <= 0x800) {
                            // Verifica se √© alinhado (frequentemente √©)
                            let confidence = "Baixa";
                            if (size % 16 === 0) confidence = "Alta";
                            else if (size % 8 === 0) confidence = "M√©dia";

                            // Verifica se tem CALL perto
                            let hasCall = false;
                            for(let k=0; k<15; k++) { if(bytes[i+5+k] === 0xE8) hasCall = true; }
                            if(hasCall) confidence = "MUITO ALTA (Perto de Call)";

                            sizes.push({ offset: i, size: size, reg: reg, conf: confidence, dist: ref - i });
                        }
                    }

                    if (sizes.length > 0) {
                        log(`      [CANDIDATOS A TAMANHO]`);
                        // Mostra apenas os top 5 mais pr√≥ximos ou confi√°veis
                        sizes.sort((a, b) => a.dist - b.dist);
                        sizes.slice(0, 5).forEach(s => {
                            log(`      * 0x${s.size.toString(16).toUpperCase()} (${s.size} bytes) | Confian√ßa: ${s.conf} | Dist: -${s.dist}`);
                        });
                    } else {
                        log(`      [-] Nenhum tamanho √≥bvio encontrado.`);
                    }

                    // 4. VTABLE HUNTER (Rastreamento de Ponteiros)
                    // Procura quem aponta para este c√≥digo (ref)
                    // VTables s√£o arrays de ponteiros absolutos na se√ß√£o .data
                    
                    // Procuramos ponteiros para 'ref' ou 'ref - offset' (in√≠cio da fun√ß√£o)
                    // Varredura heur√≠stica: Assume que 'ref' est√° dentro da fun√ß√£o
                    const vtables = findAbsoluteRefsToRange(view, ref - 200, ref + 20);
                    
                    if (vtables.length > 0) {
                        log(`      [CANDIDATOS A VTABLE (Para Leak)]`);
                        vtables.forEach(vt => {
                            // O ponteiro da VTable geralmente aponta para o in√≠cio da fun√ß√£o.
                            // O local ONDE achamos o ponteiro (vt.loc) √© o endere√ßo da VTable.
                            log(`      * Offset no Arquivo: 0x${vt.loc.toString(16).toUpperCase()} (Aponta para 0x${vt.target.toString(16).toUpperCase()})`);
                        });
                    }
                });
            });
        }

        // --- UTILIT√ÅRIOS ---
        function findString(bytes, str) {
            const target = new TextEncoder().encode(str);
            for(let i=0; i<bytes.length - target.length; i++) {
                let match = true;
                for(let j=0; j<target.length; j++) {
                    if(bytes[i+j] !== target[j]) { match = false; break; }
                }
                if(match && bytes[i+target.length] === 0) return i;
            }
            return -1;
        }

        function findRipRelativeRefs(view, target) {
            const refs = [];
            const len = view.byteLength - 7;
            for (let i = 0; i < len; i++) {
                // Opcode LEA/MOV (48 8D / 48 8B)
                if (view.getUint8(i) === 0x48 && (view.getUint8(i+1) === 0x8D || view.getUint8(i+1) === 0x8B)) {
                    const offset = view.getInt32(i + 3, true);
                    const dest = i + 7 + offset;
                    if (dest === target) refs.push(i);
                }
            }
            return refs;
        }

        function findAbsoluteRefsToRange(view, start, end) {
            const refs = [];
            const len = view.byteLength - 8;
            for (let i = 0; i < len; i+=8) {
                try {
                    const val = Number(view.getBigUint64(i, true)); // Safe for file offsets
                    if (val >= start && val <= end) {
                        refs.push({ loc: i, target: val });
                    }
                } catch(e){}
            }
            return refs;
        }
    </script>
</body>
</html>
