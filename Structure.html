<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 ELF Gadget Extractor</title>
    <style>
        body { background-color: #1e1e1e; color: #d4d4d4; font-family: Consolas, monospace; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; }
        h2 { border-bottom: 1px solid #444; padding-bottom: 10px; color: #4ec9b0; }
        #drop-zone {
            border: 2px dashed #444; padding: 30px; text-align: center; margin-bottom: 20px; cursor: pointer; background: #252526;
        }
        #drop-zone:hover { border-color: #4ec9b0; background: #2d2d30; }
        #log-output {
            width: 100%; height: 400px; background-color: #000; color: #ce9178; 
            border: 1px solid #444; font-family: monospace; padding: 10px; resize: vertical;
        }
        #progress-bar { width: 100%; height: 20px; background-color: #333; margin-bottom: 10px; }
        #progress-fill { height: 100%; background-color: #4ec9b0; width: 0%; transition: width 0.1s; }
        button { padding: 10px 20px; background: #0e639c; color: white; border: none; cursor: pointer; font-size: 16px; }
        button:hover { background: #1177bb; }
    </style>
</head>
<body>

<div class="container">
    <h2>PS4 ELF Analyzer & Gadget Extractor</h2>
    <p>Carregue o arquivo .elf ou .sprx (FW 12.00) para extrair os offsets necessários.</p>
    
    <div id="drop-zone" onclick="document.getElementById('fileInput').click()">
        Clique aqui para selecionar o arquivo ou arraste-o.
        <input type="file" id="fileInput" style="display:none">
    </div>

    <div id="status">Aguardando arquivo...</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>
    
    <textarea id="log-output" readonly>Os resultados aparecerão aqui...</textarea>
    <br>
    <button onclick="copyLog()">Copiar Log</button>
</div>

<script>
    // Assinaturas de Bytes para Gadgets Comuns (x64)
    const TARGETS = {
        // Gadgets Básicos de Argumentos
        "pop rdi; ret": "5F C3",
        "pop rsi; ret": "5E C3",
        "pop rdx; ret": "5A C3",
        "pop rcx; ret": "59 C3",
        "pop rax; ret": "58 C3",
        "pop r8; ret":  "41 58 C3",
        "pop r9; ret":  "41 59 C3",
        "pop rsp; ret": "5C C3", // Stack Pivot

        // Movimentação de Memória (Primitives)
        "mov [rdi], rax; ret": "48 89 07 C3", // Write Primitive
        "mov rax, [rdi]; ret": "48 8B 07 C3", // Read Primitive
        "mov [rax], rsi; ret": "48 89 30 C3",
        
        // JOP Gadgets (Para o PSFree)
        "jmp [rsi]": "FF 26", 
        "jmp [rdi]": "FF 27",
        "call [rax]": "FF 10",

        // Instruções Especiais
        "syscall": "0F 05",
        "ret": "C3"
    };

    // Converte string hex "5F C3" para array de bytes [0x5F, 0xC3]
    const GADGET_BYTES = {};
    for (let key in TARGETS) {
        GADGET_BYTES[key] = TARGETS[key].split(' ').map(h => parseInt(h, 16));
    }

    let fileData = null;
    let textSectionOffset = 0;
    let textSectionSize = 0;

    document.getElementById('fileInput').addEventListener('change', handleFile);

    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;

        document.getElementById('status').innerText = `Carregando ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)...`;
        
        const reader = new FileReader();
        reader.onload = function(evt) {
            fileData = new Uint8Array(evt.target.result);
            parseELF(file.name);
        };
        reader.readAsArrayBuffer(file);
    }

    function log(msg) {
        const area = document.getElementById('log-output');
        area.value += msg + "\n";
        area.scrollTop = area.scrollHeight;
    }

    function parseELF(filename) {
        document.getElementById('log-output').value = `--- ANÁLISE DE: ${filename} ---\n`;
        
        // 1. Validar Magic ELF (0x7F E L F)
        if (fileData[0] !== 0x7F || fileData[1] !== 0x45 || fileData[2] !== 0x4C || fileData[3] !== 0x46) {
            log("ERRO: Não é um arquivo ELF válido.");
            return;
        }

        // 2. Achar Seção .text (Código Executável)
        // Header ELF64: e_phoff em 0x20 (8 bytes), e_phnum em 0x38 (2 bytes)
        const phOff = read64(0x20);
        const phNum = read16(0x38);
        const phEntSize = read16(0x36);

        log(`Program Headers: ${phNum} em offset 0x${phOff.toString(16)}`);

        let foundText = false;

        // Varre os Program Headers procurando PT_LOAD (1) com Flag Exec (1 ou 0x5)
        for (let i = 0; i < phNum; i++) {
            let offset = phOff + (i * phEntSize);
            let p_type = read32(offset);
            let p_flags = read32(offset + 4);
            let p_offset = read64(offset + 8);
            let p_filesz = read64(offset + 32);

            // PT_LOAD = 1, PF_X = 1 (Executable)
            if (p_type === 1 && (p_flags & 1)) {
                textSectionOffset = Number(p_offset);
                textSectionSize = Number(p_filesz);
                log(`SEGMENTO EXECUTÁVEL (.text) encontrado:`);
                log(`  Offset Arquivo: 0x${textSectionOffset.toString(16)}`);
                log(`  Tamanho: 0x${textSectionSize.toString(16)} (${textSectionSize} bytes)`);
                foundText = true;
                break; // Assume que o primeiro executável é o principal
            }
        }

        if (!foundText) {
            log("AVISO: Segmento .text não identificado claramente. Escaneando arquivo todo (Lento).");
            textSectionOffset = 0;
            textSectionSize = fileData.length;
        }

        // Inicia escaneamento em blocos
        startScanning();
    }

    function startScanning() {
        const CHUNK_SIZE = 1024 * 512; // 512KB por bloco
        let currentPos = 0;
        let foundGadgets = {};

        function processChunk() {
            let end = Math.min(currentPos + CHUNK_SIZE, textSectionSize);
            let absoluteStart = textSectionOffset + currentPos;
            let absoluteEnd = textSectionOffset + end;

            // Atualiza UI
            let progress = (currentPos / textSectionSize) * 100;
            document.getElementById('progress-fill').style.width = progress + "%";
            document.getElementById('status').innerText = `Escaneando: ${Math.floor(progress)}%`;

            // Varredura byte a byte no bloco
            for (let i = absoluteStart; i < absoluteEnd; i++) {
                
                // Otimização: Só checa se o byte atual for o início de algum gadget conhecido
                // Para simplificar, checamos todas as assinaturas
                for (let name in GADGET_BYTES) {
                    if (foundGadgets[name] && foundGadgets[name].length >= 3) continue; // Limite de 3 por tipo

                    let bytes = GADGET_BYTES[name];
                    if (fileData[i] === bytes[0]) { // Match primeiro byte
                        let match = true;
                        for (let j = 1; j < bytes.length; j++) {
                            if (fileData[i + j] !== bytes[j]) {
                                match = false;
                                break;
                            }
                        }

                        if (match) {
                            if (!foundGadgets[name]) foundGadgets[name] = [];
                            // Salva o offset RELATIVO ao início do arquivo (que será o offset da lib)
                            foundGadgets[name].push(i);
                        }
                    }
                }
            }

            currentPos = end;

            if (currentPos < textSectionSize) {
                setTimeout(processChunk, 0); // Próximo bloco
            } else {
                finishScan(foundGadgets);
            }
        }

        processChunk();
    }

    function finishScan(results) {
        document.getElementById('progress-fill').style.width = "100%";
        document.getElementById('status').innerText = "Concluído!";
        
        log("\n--- RESULTADOS (Offsets Hex) ---");
        log("// Copie estes valores para o seu arquivo .mjs");
        log("const gadget_map = {");
        
        for (let name in TARGETS) {
            if (results[name]) {
                let offsets = results[name].map(o => "0x" + o.toString(16)).join(", ");
                log(`    "${name}": ${offsets},`);
            } else {
                log(`    "${name}": null, // NÃO ENCONTRADO`);
            }
        }
        log("};");
    }

    // Helpers de leitura Little Endian
    function read16(offset) {
        return fileData[offset] | (fileData[offset+1] << 8);
    }
    function read32(offset) {
        return (fileData[offset] | (fileData[offset+1] << 8) | (fileData[offset+2] << 16) | (fileData[offset+3] << 24)) >>> 0;
    }
    function read64(offset) {
        // Retorna Number (seguro até 53 bits, suficiente para offsets de arquivo)
        let lo = read32(offset);
        let hi = read32(offset+4);
        return lo + (hi * 4294967296);
    }

    function copyLog() {
        const copyText = document.getElementById("log-output");
        copyText.select();
        document.execCommand("copy");
        alert("Log copiado!");
    }
</script>

</body>
</html>
