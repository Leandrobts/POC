<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 VTable Hunter (JS Edition)</title>
    <style>
        body { background-color: #1e1e1e; color: #00ff00; font-family: 'Consolas', monospace; text-align: center; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; border: 1px solid #333; padding: 20px; background: #252526; border-radius: 8px; }
        textarea { width: 100%; height: 500px; background: #000; color: #0f0; border: 1px solid #555; margin-top: 15px; font-size: 13px; }
        button { padding: 15px 40px; font-size: 18px; background: #007acc; color: white; border: none; cursor: pointer; font-weight: bold; border-radius: 5px; margin-top: 10px; }
        button:hover { background: #005c99; }
        .highlight { color: #ff00ff; font-weight: bold; }
        input { margin: 15px; color: #fff; }
    </style>
</head>
<body>

    <div class="container">
        <h1>üõ†Ô∏è VTable Hunter (Web Edition)</h1>
        <h3>Alvo: Encontrar Offset da VTable do SharedWorker</h3>
        <p>Selecione o arquivo: <b>1200_libSceNKWebKit.sprx.elf</b></p>
        
        <input type="file" id="fileInput" />
        <br>
        <button onclick="startAnalysis()">RASTREAR (START)</button>
        
        <div id="status" style="margin-top:10px; color: #aaa;">Aguardando...</div>
        <textarea id="output" readonly></textarea>
    </div>

    <script>
        function log(msg) {
            document.getElementById('output').value += msg + "\n";
        }

        function startAnalysis() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput.files.length === 0) {
                alert("Selecione o arquivo ELF primeiro!");
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            document.getElementById('output').value = "";
            document.getElementById('status').innerText = "Lendo arquivo (30MB+)... aguarde...";

            reader.onload = function(e) {
                document.getElementById('status').innerText = "Processando Bin√°rio...";
                
                // Pequeno delay para a UI n√£o travar
                setTimeout(() => {
                    try {
                        const buffer = e.target.result;
                        analyzeBinary(buffer);
                        document.getElementById('status').innerText = "An√°lise Conclu√≠da!";
                    } catch (err) {
                        log("ERRO FATAL: " + err);
                    }
                }, 100);
            };

            reader.readAsArrayBuffer(file);
        }

        function analyzeBinary(buffer) {
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);
            const targets = ["SharedWorker", "MessagePort"];

            log("=== RELAT√ìRIO DE VTABLES (12.00) ===");
            log("Arquivo carregado. Tamanho: " + buffer.byteLength + " bytes.\n");

            targets.forEach(targetName => {
                log(`\n>>> RASTREANDO: ${targetName} <<<`);
                
                // 1. ACHAR A STRING
                const strOffset = findString(bytes, targetName);
                if (strOffset === -1) {
                    log("   [X] String n√£o encontrada.");
                    return;
                }
                log(`   1. String encontrada em: 0x${strOffset.toString(16).toUpperCase()}`);

                // 2. ACHAR QUEM USA A STRING (Refer√™ncia Cruzada - XREF)
                // Procura por instru√ß√µes que apontam para essa string.
                // Em x64 (PS4), o c√≥digo usa endere√ßamento relativo (RIP-Relative).
                // F√≥rmula: Destino = Offset_Instrucao + 4 + Valor_Int32
                
                const xrefs = findRelativeRefs(view, strOffset);
                
                if (xrefs.length === 0) {
                    log("   [X] Nenhuma refer√™ncia de c√≥digo encontrada (estranho).");
                    return;
                }

                log(`   2. Encontradas ${xrefs.length} refer√™ncias de c√≥digo (XREFs).`);

                xrefs.forEach(codeOffset => {
                    log(`      -> C√≥digo em 0x${codeOffset.toString(16).toUpperCase()} aponta para a string.`);
                    
                    // 3. ACHAR A VTABLE
                    // A VTable √© uma lista de ponteiros. O segundo ou terceiro ponteiro costuma
                    // ser a fun√ß√£o 'type_info::name' ou o destrutor, que usa o c√≥digo acima.
                    // Vamos procurar ponteiros absolutos (64-bit) que apontem para 'codeOffset'.
                    // NOTA: Procuramos ponteiros para o IN√çCIO da fun√ß√£o (heur√≠stica: codeOffset - alguns bytes)
                    // Mas para ser exato, procuramos ponteiros diretos para onde achamos a refer√™ncia.
                    
                    const vtables = findAbsoluteRefs(view, codeOffset);
                    
                    if (vtables.length > 0) {
                        vtables.forEach(vt => {
                            // Ajuste de Heur√≠stica C++:
                            // Se encontramos um ponteiro para o c√≥digo RTTI, a VTable real come√ßa geralmente +8 ou +16 bytes depois.
                            // Mas o n√∫mero cru j√° serve para calcularmos a base.
                            log(`      [!!!] PONTEIRO ENCONTRADO EM: 0x${vt.toString(16).toUpperCase()}`);
                            log(`            Este endere√ßo cont√©m um ponteiro para o c√≥digo acima.`);
                            log(`            >>> OFFSET POTENCIAL DA VTABLE: 0x${vt.toString(16).toUpperCase()} <<<`);
                        });
                    }
                });
            });
        }

        // Busca string exata terminada em null
        function findString(bytes, str) {
            const encoder = new TextEncoder();
            const target = encoder.encode(str);
            
            for (let i = 0; i < bytes.length - target.length; i++) {
                let match = true;
                for (let j = 0; j < target.length; j++) {
                    if (bytes[i + j] !== target[j]) {
                        match = false;
                        break;
                    }
                }
                // Verifica null terminator
                if (match && bytes[i + target.length] === 0) {
                    return i;
                }
            }
            return -1;
        }

        // Busca refer√™ncias relativas (LEA/MOV com offset 32-bit)
        function findRelativeRefs(view, targetOffset) {
            const results = [];
            const len = view.byteLength - 4;
            
            // Varre o arquivo procurando inteiros de 32 bits
            for (let i = 0; i < len; i++) {
                // Pega o valor de 32 bits na posi√ß√£o i
                const relOffset = view.getInt32(i, true); // Little Endian
                
                // Calcula onde isso apontaria: Posi√ß√£o Atual + 4 bytes da instru√ß√£o + Offset
                const destination = i + 4 + relOffset;
                
                if (destination === targetOffset) {
                    // Filtro simples: Instru√ß√µes x64 LEA geralmente come√ßam com 0x48 0x8D
                    // Vamos aceitar por enquanto e o humano filtra
                    results.push(i); 
                }
            }
            return results;
        }

        // Busca refer√™ncias absolutas (Ponteiros de 64 bits)
        function findAbsoluteRefs(view, targetOffset) {
            const results = [];
            const len = view.byteLength - 8;
            const targetBig = BigInt(targetOffset);
            
            // Varre alinhado a 4 ou 8 bytes
            for (let i = 0; i < len; i += 4) {
                const val = view.getBigUint64(i, true);
                if (val === targetBig) {
                    results.push(i);
                }
            }
            return results;
        }
    </script>
</body>
</html>
