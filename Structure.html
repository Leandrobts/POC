<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 Constructor Hunter (V4)</title>
    <style>
        body { background-color: #0d1117; color: #00ff00; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        .container { max-width: 1000px; margin: 0 auto; background: #161b22; padding: 20px; border: 1px solid #30363d; border-radius: 10px; }
        textarea { width: 100%; height: 600px; background: #0d1117; color: #e6edf3; border: 1px solid #30363d; margin-top: 15px; font-size: 13px; }
        button { padding: 15px 40px; background: #238636; color: #fff; border: none; cursor: pointer; font-weight: bold; font-size: 16px; border-radius: 6px; margin-top: 10px; }
        button:hover { background: #2ea043; }
        .step { color: #8b949e; font-size: 12px; margin-bottom: 5px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>ðŸ§¬ CONSTRUCTOR HUNTER V4</h1>
        <p>Rastreamento: String -> VTable -> Construtor -> Malloc Size</p>
        <p class="step">Selecione TODOS os arquivos .elf (WebKit, Libc, LibKernel...)</p>
        
        <input type="file" id="fileInput" multiple />
        <br>
        <button onclick="startDeepAnalysis()">INICIAR RASTREAMENTO PROFUNDO</button>
        
        <textarea id="output" readonly>Aguardando binÃ¡rios...</textarea>
    </div>

    <script>
        async function startDeepAnalysis() {
            const files = document.getElementById('fileInput').files;
            if(files.length === 0) return alert("Selecione os arquivos!");

            const output = document.getElementById('output');
            output.value = "Carregando arquivos na memÃ³ria...\n";

            let webkit = null;
            
            // 1. Carregar arquivos
            for (let f of files) {
                if (f.name.includes("WebKit")) {
                    const buf = await readFile(f);
                    webkit = {
                        view: new DataView(buf),
                        bytes: new Uint8Array(buf),
                        size: buf.byteLength
                    };
                    output.value += `[OK] WebKit carregado (${(buf.byteLength/1024/1024).toFixed(2)} MB)\n`;
                }
            }

            if (!webkit) {
                output.value += "ERRO: Arquivo WebKit nÃ£o encontrado!\n";
                return;
            }

            let log = "\n=== RASTREAMENTO REVERSO ===\n";

            // 2. Achar a String "SharedWorker"
            const str = "SharedWorker";
            const strOffset = findString(webkit.bytes, str);
            
            if (strOffset === -1) {
                log += "[-] String 'SharedWorker' nÃ£o encontrada.\n";
                output.value += log;
                return;
            }
            log += `[1] String encontrada em: 0x${strOffset.toString(16).toUpperCase()}\n`;

            // 3. Achar XREFs (CÃ³digo que usa a string)
            // RIP-Relative: Procure instruÃ§Ãµes que apontem para strOffset
            const codeRefs = findRelativeRefs(webkit.view, strOffset);
            
            if (codeRefs.length === 0) {
                log += "[-] Nenhuma referÃªncia de cÃ³digo direta (XREF) encontrada.\n";
                // Tenta heurÃ­stica de VTable direta (ponteiro para string)
            } else {
                log += `[2] ${codeRefs.length} locais usam a string (RTTI/ClassName).\n`;
                codeRefs.forEach(ref => log += `    -> CÃ³digo em 0x${ref.toString(16).toUpperCase()}\n`);
            }

            // 4. Achar a VTable (O Elo Perdido)
            // A VTable Ã© uma lista de ponteiros. Um deles aponta para o cÃ³digo acima (RTTI).
            // Vamos escanear o arquivo inteiro procurando ponteiros (64-bit) para os codeRefs.
            
            let vtableCandidates = [];
            // Adiciona a prÃ³pria string como alvo (caso nÃ£o tenha RTTI intermediÃ¡rio)
            let targets = [...codeRefs, strOffset]; 
            
            targets.forEach(target => {
                const pointers = findAbsoluteRefs(webkit.view, target);
                pointers.forEach(ptr => {
                    // Se achamos um ponteiro para o cÃ³digo, a VTable real geralmente comeÃ§a +8 ou +16 bytes depois
                    // Mas o endereÃ§o do ponteiro jÃ¡ nos localiza na seÃ§Ã£o .data.rel.ro
                    vtableCandidates.push(ptr);
                });
            });

            if (vtableCandidates.length === 0) {
                log += "[-] Nenhuma VTable Ã³bvia encontrada.\n";
            } else {
                log += `[3] ${vtableCandidates.length} candidatos a VTable encontrados.\n`;
                
                // 5. Achar o CONSTRUTOR
                // O Construtor Ã© o cÃ³digo que CARREGA o endereÃ§o da VTable no objeto.
                // Procuramos: LEA RAX, [VTable] ou MOV [RDI], VTable_Addr
                // Como Ã© x64, serÃ¡ RIP-Relative: LEA REG, [RIP + offset] == VTable
                
                vtableCandidates.forEach(vt => {
                    // Ajuste: O inÃ­cio da VTable usada pelo objeto geralmente Ã© offset+16 (pula RTTI/Offset)
                    const objectVTable = vt + 16; 
                    
                    log(`    Analisando VTable em 0x${objectVTable.toString(16).toUpperCase()}...\n`);
                    
                    // Procura no cÃ³digo quem referencia esse endereÃ§o
                    const constructors = findRelativeRefs(webkit.view, objectVTable);
                    
                    constructors.forEach(ctor => {
                        log(`    [!] CONSTRUTOR POTENCIAL EM: 0x${ctor.toString(16).toUpperCase()}\n`);
                        
                        // 6. Achar o TAMANHO (Size)
                        // Olhar 200 bytes ANTES do construtor.
                        // Procurar: MOV EDI, imm32 (BF XX XX 00 00)
                        
                        const scanStart = Math.max(0, ctor - 200);
                        for(let i = ctor; i > scanStart; i--) {
                            if (webkit.bytes[i] === 0xBF) { // MOV EDI
                                const size = webkit.view.getInt32(i+1, true);
                                if (size > 0x20 && size <= 0x800) {
                                    log += `        >>> TAMANHO ENCONTRADO: 0x${size.toString(16).toUpperCase()} (${size}) <<<\n`;
                                    log += `        (DistÃ¢ncia: ${ctor - i} bytes antes da ref)\n`;
                                }
                            }
                            // MOV ESI (BE)
                            else if (webkit.bytes[i] === 0xBE) { 
                                const size = webkit.view.getInt32(i+1, true);
                                if (size > 0x20 && size <= 0x800) {
                                    log += `        >>> TAMANHO (ESI): 0x${size.toString(16).toUpperCase()} <<<\n`;
                                }
                            }
                        }
                    });
                });
            }

            log("\n=== FIM DA ANÃLISE ===\n");
            log("DICA: Se aparecer mais de um tamanho, o menor (0x80-0x200) Ã© o mais provÃ¡vel para SharedWorker.");
            
            output.value = log;
        }

        function readFile(file) {
            return new Promise(resolve => {
                const r = new FileReader();
                r.onload = e => resolve(e.target.result);
                r.readAsArrayBuffer(file);
            });
        }

        function findString(bytes, str) {
            const target = new TextEncoder().encode(str);
            for(let i=0; i<bytes.length-target.length; i++) {
                let match = true;
                for(let j=0; j<target.length; j++) {
                    if(bytes[i+j] !== target[j]) { match = false; break; }
                }
                if(match && bytes[i+target.length] === 0) return i;
            }
            return -1;
        }

        // Busca referÃªncias relativas (LEA/MOV com offset 32-bit)
        function findRelativeRefs(view, targetOffset) {
            const results = [];
            const len = view.byteLength - 4;
            for (let i = 0; i < len; i+=1) { // Varredura fina
                const relOffset = view.getInt32(i, true);
                const destination = i + 4 + relOffset;
                if (destination === targetOffset) results.push(i);
            }
            return results;
        }

        // Busca referÃªncias absolutas (Ponteiros 64-bit)
        function findAbsoluteRefs(view, targetOffset) {
            const results = [];
            const len = view.byteLength - 8;
            const targetBig = BigInt(targetOffset);
            for (let i = 0; i < len; i += 8) { // Alinhado a 8
                if (view.getBigUint64(i, true) === targetBig) results.push(i);
            }
            return results;
        }
    </script>
</body>
</html>
