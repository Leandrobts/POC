<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>PS4 12.00 HEX DUMPER V2</title>
    <style>
        body { background: #000; color: #0f0; font-family: 'Consolas', monospace; padding: 20px; text-align: center; }
        textarea { width: 95%; height: 500px; background: #111; color: #e0e0e0; border: 1px solid #555; margin-top: 15px; font-size: 13px; line-height: 1.4; }
        button { padding: 15px 30px; background: #006600; color: #fff; border: 1px solid #0f0; cursor: pointer; font-weight: bold; font-size: 16px; }
        .highlight { color: #ff00ff; }
    </style>
</head>
<body>
    <h1>HEX DUMPER V2 (Sliced Read)</h1>
    <p>Alvo: <b>0x839A98</b> (SharedWorker Reference)</p>
    <input type="file" id="fileInput" />
    <br><br>
    <button onclick="readSlice()">LER REGIÃO (INSTANTÂNEO)</button>
    <textarea id="output" readonly>Aguardando arquivo...</textarea>

    <script>
        function readSlice() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput.files.length === 0) return alert("Selecione o arquivo ELF!");

            const file = fileInput.files[0];
            const TARGET = 0x839A98;
            
            // Lê apenas 512 bytes antes e 64 depois (foco na alocação)
            const start = Math.max(0, TARGET - 512);
            const end = Math.min(file.size, TARGET + 64);
            
            const blob = file.slice(start, end);
            const reader = new FileReader();

            reader.onload = function(e) {
                const bytes = new Uint8Array(e.target.result);
                const view = new DataView(e.target.result);
                let log = `=== DUMP HEXADECIMAL (${start.toString(16).toUpperCase()} - ${end.toString(16).toUpperCase()}) ===\n`;
                log += `Alvo (String Ref): 0x${TARGET.toString(16).toUpperCase()}\n\n`;
                
                log += "OFFSET     | BYTES (Instruções)              | ASCII / ANÁLISE\n";
                log += "-----------|---------------------------------|----------------\n";

                for (let i = 0; i < bytes.length; i++) {
                    const globalOffset = start + i;
                    const b = bytes[i];

                    // Detectar Instruções de Tamanho (Heurística)
                    // BF = MOV EDI (Arg 1)
                    // BE = MOV ESI (Arg 2)
                    let comment = "";
                    
                    if (b === 0xBF) {
                        // Verifica se há espaço para ler int32
                        if (i + 4 < bytes.length) {
                            const val = view.getInt32(i + 1, true);
                            if (val > 0x20 && val <= 0x1000) {
                                comment = `<<< MOV EDI, 0x${val.toString(16).toUpperCase()} (${val}) [POSSÍVEL TAMANHO]`;
                            }
                        }
                    }
                    
                    if (b === 0xBE) {
                         if (i + 4 < bytes.length) {
                            const val = view.getInt32(i + 1, true);
                            if (val > 0x20 && val <= 0x1000) {
                                comment = `<<< MOV ESI, 0x${val.toString(16).toUpperCase()} (${val}) [ALTERNATIVA]`;
                            }
                        }
                    }
                    
                    if (globalOffset === TARGET) {
                        comment = "<<< REFERÊNCIA DO ALVO (SharedWorker)";
                    }

                    // Formatação de linha (16 bytes por linha)
                    if (globalOffset % 16 === 0) {
                        if (i > 0) log += "\n";
                        log += `0x${globalOffset.toString(16).toUpperCase().padStart(8, '0')} | `;
                    }
                    
                    log += b.toString(16).toUpperCase().padStart(2, '0') + " ";
                    
                    if ((globalOffset + 1) % 16 === 0 || i === bytes.length - 1 || comment !== "") {
                        // Preenchimento se a linha quebrar no meio por causa de um comentário
                        if (comment !== "") {
                             log += " " + comment + "\n";
                             // Ajusta alinhamento da próxima linha se não terminou os 16 bytes
                             if ((globalOffset + 1) % 16 !== 0) {
                                 log += `0x${(globalOffset+1).toString(16).toUpperCase().padStart(8, '0')} | `.padStart(13 + ((globalOffset % 16) * 3)); 
                             }
                        }
                    }
                }

                document.getElementById('output').value = log;
            };

            reader.readAsArrayBuffer(blob);
        }
    </script>
</body>
</html>
